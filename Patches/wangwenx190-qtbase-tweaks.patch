From 2aab993b299d02cdc646cac80245188bb80bf6d6 Mon Sep 17 00:00:00 2001
From: Yuhang Zhao <2546789017@qq.com>
Date: Fri, 17 Jun 2022 20:33:03 +0800
Subject: [PATCH] wangwenx190: Custom tweaks

Important changes list:

01. Win32: Remove WS_POPUP for most cases.
02. Win32: Remove UI Automation wrapper layer.
03. Win32: Remove the Direct2D QPA, it's useless and has bad performance.
04. Remove the offscreen QPA, it's useless.
05. Remove the minimal QPA, it's useless.
06. Win32: Add more entries to QOperatingSystemVersion.
07. Win32: Add environment variable to add offset to the system menu.
08. Win32: Add environment variable to disable bitmap redirection.
09. Win32: Restore Windows 7 compatibility (QtMutex & QtRhi & QPA).
10. MSVC: Add support for VC-LTL.
11. Other minor tweaks.

Signed-off-by: Yuhang Zhao <2546789017@qq.com>
---
 cmake/QtBaseGlobalTargets.cmake               |    1 +
 cmake/QtBuild.cmake                           |    7 +
 cmake/QtCompilerOptimization.cmake            |   15 +-
 cmake/QtInternalTargets.cmake                 |   23 +-
 cmake/VC-LTL.cmake                            |   94 +
 src/corelib/CMakeLists.txt                    |    2 +
 src/corelib/global/qlibraryinfo.cpp           |   20 +-
 src/corelib/global/qlibraryinfo.h             |    5 +
 .../global/qoperatingsystemversion.cpp        |    7 +
 src/corelib/global/qoperatingsystemversion.h  |   37 +
 .../global/qoperatingsystemversion_win.cpp    |   17 +-
 src/corelib/global/qsysinfo.cpp               |   32 +-
 src/corelib/kernel/qcoreapplication.cpp       |   11 +
 src/corelib/kernel/qeventdispatcher_win.cpp   |   13 +-
 src/corelib/kernel/qfunctions_win.cpp         |   13 +-
 src/corelib/text/qlocale_win.cpp              |   23 +-
 src/corelib/thread/qfutex_p.h                 |   76 +-
 src/corelib/thread/qlocking_p.h               |    7 +-
 src/corelib/thread/qmutex.cpp                 |    2 +
 src/corelib/thread/qmutex_p.h                 |    9 +-
 src/corelib/thread/qmutex_win.cpp             |   30 +
 src/corelib/thread/qwaitcondition_p.h         |    7 +-
 src/gui/CMakeLists.txt                        |   16 -
 .../windows/apisupport/qwindowsuiawrapper.cpp |   89 -
 .../windows/apisupport/qwindowsuiawrapper_p.h |   67 -
 .../windows/apisupport/uiaattributeids_p.h    |   63 -
 .../apisupport/uiaclientinterfaces_p.h        |  230 ---
 .../windows/apisupport/uiacontroltypeids_p.h  |   60 -
 .../windows/apisupport/uiaerrorids_p.h        |   26 -
 .../windows/apisupport/uiaeventids_p.h        |   54 -
 .../windows/apisupport/uiageneralids_p.h      |   21 -
 .../windows/apisupport/uiapatternids_p.h      |   53 -
 .../windows/apisupport/uiapropertyids_p.h     |  188 --
 .../apisupport/uiaserverinterfaces_p.h        |  367 ----
 .../windows/apisupport/uiatypes_p.h           |  157 --
 src/gui/opengl/qopengl.cpp                    |   29 +-
 src/gui/rhi/qrhid3d11.cpp                     |  301 +--
 src/gui/rhi/qrhid3d11_p_p.h                   |    1 +
 .../text/windows/qwindowsfontdatabasebase.cpp |    9 +-
 .../qnetworklistmanagerevents.cpp             |   54 +-
 src/plugins/platforms/CMakeLists.txt          |    9 -
 src/plugins/platforms/direct2d/CMakeLists.txt |  224 --
 src/plugins/platforms/direct2d/direct2d.json  |    3 -
 .../direct2d/qwindowsdirect2dbackingstore.cpp |  103 -
 .../direct2d/qwindowsdirect2dbackingstore.h   |   33 -
 .../direct2d/qwindowsdirect2dbitmap.cpp       |  172 --
 .../direct2d/qwindowsdirect2dbitmap.h         |   49 -
 .../direct2d/qwindowsdirect2dcontext.cpp      |  184 --
 .../direct2d/qwindowsdirect2dcontext.h        |   46 -
 .../qwindowsdirect2ddevicecontext.cpp         |  132 --
 .../direct2d/qwindowsdirect2ddevicecontext.h  |   70 -
 .../direct2d/qwindowsdirect2dhelpers.h        |   66 -
 .../direct2d/qwindowsdirect2dintegration.cpp  |  161 --
 .../direct2d/qwindowsdirect2dintegration.h    |   43 -
 .../qwindowsdirect2dnativeinterface.cpp       |   26 -
 .../qwindowsdirect2dnativeinterface.h         |   20 -
 .../direct2d/qwindowsdirect2dpaintdevice.cpp  |   96 -
 .../direct2d/qwindowsdirect2dpaintdevice.h    |   37 -
 .../direct2d/qwindowsdirect2dpaintengine.cpp  | 1814 -----------------
 .../direct2d/qwindowsdirect2dpaintengine.h    |  106 -
 .../qwindowsdirect2dplatformpixmap.cpp        |  157 --
 .../direct2d/qwindowsdirect2dplatformpixmap.h |   50 -
 .../qwindowsdirect2dplatformplugin.cpp        |   30 -
 .../direct2d/qwindowsdirect2dwindow.cpp       |  283 ---
 .../direct2d/qwindowsdirect2dwindow.h         |   47 -
 src/plugins/platforms/minimal/CMakeLists.txt  |   41 -
 src/plugins/platforms/minimal/main.cpp        |   30 -
 src/plugins/platforms/minimal/minimal.json    |    3 -
 .../minimal/qminimalbackingstore.cpp          |   57 -
 .../platforms/minimal/qminimalbackingstore.h  |   30 -
 .../platforms/minimal/qminimalintegration.cpp |  173 --
 .../platforms/minimal/qminimalintegration.h   |   66 -
 .../platforms/offscreen/CMakeLists.txt        |   42 -
 src/plugins/platforms/offscreen/main.cpp      |   30 -
 .../platforms/offscreen/offscreen.json        |    3 -
 .../platforms/offscreen/qoffscreencommon.cpp  |  241 ---
 .../platforms/offscreen/qoffscreencommon.h    |  102 -
 .../offscreen/qoffscreenintegration.cpp       |  443 ----
 .../offscreen/qoffscreenintegration.h         |   67 -
 .../offscreen/qoffscreenintegration_x11.cpp   |  301 ---
 .../offscreen/qoffscreenintegration_x11.h     |  102 -
 .../platforms/offscreen/qoffscreenwindow.cpp  |  173 --
 .../platforms/offscreen/qoffscreenwindow.h    |   49 -
 src/plugins/platforms/windows/CMakeLists.txt  |    2 +
 .../platforms/windows/qwin10helpers.cpp       |   39 +-
 .../platforms/windows/qwindowsapplication.cpp |   12 +-
 .../platforms/windows/qwindowscontext.cpp     |  190 +-
 .../platforms/windows/qwindowscontext.h       |  104 +-
 .../platforms/windows/qwindowsdrag.cpp        |    7 +-
 .../platforms/windows/qwindowsintegration.cpp |   29 +-
 .../platforms/windows/qwindowskeymapper.cpp   |   18 +-
 .../windows/qwindowspointerhandler.cpp        |   25 +-
 .../platforms/windows/qwindowsscreen.cpp      |   45 +-
 .../platforms/windows/qwindowstheme.cpp       |  135 +-
 .../platforms/windows/qwindowswindow.cpp      |   95 +-
 .../uiautomation/qwindowsuiaaccessibility.cpp |    9 +-
 .../uiautomation/qwindowsuiabaseprovider.h    |    4 +-
 .../uiautomation/qwindowsuiamainprovider.cpp  |   53 +-
 .../windows/uiautomation/qwindowsuiautils.h   |    2 +-
 .../windowsvista/qwindowsvistastyle.cpp       |   31 +
 .../windowsvista/qwindowsvistastyle_p_p.h     |    1 +
 src/tools/rcc/main.cpp                        |    7 +-
 src/tools/rcc/rcc.cpp                         |    8 +-
 src/widgets/dialogs/qwizard_win.cpp           |    9 +-
 104 files changed, 1254 insertions(+), 7721 deletions(-)
 create mode 100644 cmake/VC-LTL.cmake
 create mode 100644 src/corelib/thread/qmutex_win.cpp
 delete mode 100644 src/gui/accessible/windows/apisupport/qwindowsuiawrapper.cpp
 delete mode 100644 src/gui/accessible/windows/apisupport/qwindowsuiawrapper_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiaattributeids_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiaclientinterfaces_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiacontroltypeids_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiaerrorids_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiaeventids_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiageneralids_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiapatternids_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiapropertyids_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiaserverinterfaces_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiatypes_p.h
 delete mode 100644 src/plugins/platforms/direct2d/CMakeLists.txt
 delete mode 100644 src/plugins/platforms/direct2d/direct2d.json
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dbackingstore.cpp
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dbackingstore.h
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dbitmap.cpp
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dbitmap.h
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dcontext.cpp
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dcontext.h
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2ddevicecontext.cpp
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2ddevicecontext.h
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dhelpers.h
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dintegration.cpp
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dintegration.h
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dnativeinterface.cpp
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dnativeinterface.h
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dpaintdevice.cpp
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dpaintdevice.h
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dpaintengine.cpp
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dpaintengine.h
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dplatformpixmap.cpp
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dplatformpixmap.h
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dplatformplugin.cpp
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dwindow.cpp
 delete mode 100644 src/plugins/platforms/direct2d/qwindowsdirect2dwindow.h
 delete mode 100644 src/plugins/platforms/minimal/CMakeLists.txt
 delete mode 100644 src/plugins/platforms/minimal/main.cpp
 delete mode 100644 src/plugins/platforms/minimal/minimal.json
 delete mode 100644 src/plugins/platforms/minimal/qminimalbackingstore.cpp
 delete mode 100644 src/plugins/platforms/minimal/qminimalbackingstore.h
 delete mode 100644 src/plugins/platforms/minimal/qminimalintegration.cpp
 delete mode 100644 src/plugins/platforms/minimal/qminimalintegration.h
 delete mode 100644 src/plugins/platforms/offscreen/CMakeLists.txt
 delete mode 100644 src/plugins/platforms/offscreen/main.cpp
 delete mode 100644 src/plugins/platforms/offscreen/offscreen.json
 delete mode 100644 src/plugins/platforms/offscreen/qoffscreencommon.cpp
 delete mode 100644 src/plugins/platforms/offscreen/qoffscreencommon.h
 delete mode 100644 src/plugins/platforms/offscreen/qoffscreenintegration.cpp
 delete mode 100644 src/plugins/platforms/offscreen/qoffscreenintegration.h
 delete mode 100644 src/plugins/platforms/offscreen/qoffscreenintegration_x11.cpp
 delete mode 100644 src/plugins/platforms/offscreen/qoffscreenintegration_x11.h
 delete mode 100644 src/plugins/platforms/offscreen/qoffscreenwindow.cpp
 delete mode 100644 src/plugins/platforms/offscreen/qoffscreenwindow.h

diff --git a/cmake/QtBaseGlobalTargets.cmake b/cmake/QtBaseGlobalTargets.cmake
index ac3b63a874..ac79b3db05 100644
--- a/cmake/QtBaseGlobalTargets.cmake
+++ b/cmake/QtBaseGlobalTargets.cmake
@@ -286,6 +286,7 @@ qt_copy_or_install(FILES
                    cmake/QtWasmHelpers.cmake
                    cmake/QtWrapperScriptHelpers.cmake
                    cmake/QtWriteArgsFile.cmake
+                   cmake/VC-LTL.cmake
                    cmake/modulecppexports.h.in
                    cmake/modulecppexports_p.h.in
                    cmake/qbatchedtestrunner.in.cpp
diff --git a/cmake/QtBuild.cmake b/cmake/QtBuild.cmake
index 7f87cf71b1..840ae858b9 100644
--- a/cmake/QtBuild.cmake
+++ b/cmake/QtBuild.cmake
@@ -573,3 +573,10 @@ _qt_internal_generate_tool_command_wrapper()
 if(CMAKE_VERSION VERSION_LESS "3.19.0")
     variable_watch(CMAKE_CURRENT_LIST_DIR qt_watch_current_list_dir)
 endif()
+
+if(MSVC)
+    include(VC-LTL)
+    if("x${SupportLTL}" STREQUAL "xtrue")
+        set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>" CACHE STRING "" FORCE)
+    endif()
+endif()
diff --git a/cmake/QtCompilerOptimization.cmake b/cmake/QtCompilerOptimization.cmake
index b5b49ab78a..2a756b229b 100644
--- a/cmake/QtCompilerOptimization.cmake
+++ b/cmake/QtCompilerOptimization.cmake
@@ -92,10 +92,15 @@ endif()
 
 # Windows MSVC
 if(MSVC)
-    set(QT_CFLAGS_OPTIMIZE "-O2")
-    set(QT_CFLAGS_OPTIMIZE_DEBUG "-Od")
-    set(QT_CFLAGS_OPTIMIZE_SIZE "-O1")
-    set(QT_CFLAGS_OPTIMIZE_VALID_VALUES "/O2" "/O1" "/Od" "/Ob0" "/Ob1" "/Ob2" "/O0" "-O0")
+    set(QT_CFLAGS_OPTIMIZE "-O2 -Oi -Oy -Ot")
+    if(MSVC_VERSION GREATER_EQUAL 1920) # Visual Studio 2019 version 16.0
+        string(APPEND QT_CFLAGS_OPTIMIZE " -Ob3 ")
+    else()
+        string(APPEND QT_CFLAGS_OPTIMIZE " -Ob2 ")
+    endif()
+    set(QT_CFLAGS_OPTIMIZE_DEBUG "-Od -Ob0")
+    set(QT_CFLAGS_OPTIMIZE_SIZE "-O1 -Ob2 -Oi- -Os")
+    set(QT_CFLAGS_OPTIMIZE_VALID_VALUES "/O2" "/O1" "/Od" "/Ob0" "/Ob1" "/Ob2" "/Ob3" "/O0" "-O0")
 
     if(CLANG)
         set(QT_CFLAGS_OPTIMIZE_FULL "/clang:-O3")
@@ -124,5 +129,5 @@ endif()
 # Emscripten Clang
 if(WASM)
     set(QT_CFLAGS_OPTIMIZE_DEBUG "-O2 -g") # -Og is not supported
-    set(QT_CFLAGS_SSE2 -O2 -msimd128 -msse -msse2)
+    set(QT_CFLAGS_SSE2 "-O2 -msimd128 -msse -msse2")
 endif()
diff --git a/cmake/QtInternalTargets.cmake b/cmake/QtInternalTargets.cmake
index dc45b57eec..b7cc0a14ad 100644
--- a/cmake/QtInternalTargets.cmake
+++ b/cmake/QtInternalTargets.cmake
@@ -253,6 +253,11 @@ if (MSVC)
             #-Zc:preprocessor # breaks build due to bug in default Windows SDK 10.0.19041
         )
     endif()
+    if (MSVC_VERSION GREATER_EQUAL 1925 AND NOT CLANG) # Visual Studio 2019 version 16.5
+        target_compile_options(PlatformCommonInternal INTERFACE
+            $<$<NOT:$<CONFIG:Debug>>:-QIntel-jcc-erratum>
+        )
+    endif()
 
     target_compile_options(PlatformCommonInternal INTERFACE
         -Zc:wchar_t
@@ -260,13 +265,19 @@ if (MSVC)
     )
 
     target_compile_options(PlatformCommonInternal INTERFACE
-        $<$<NOT:$<CONFIG:Debug>>:-guard:cf -Gw>
+        $<$<NOT:$<CONFIG:Debug>>:-fp:fast -guard:cf -GF -GT -Gw -Gy> # -GA for executables.
     )
 
     target_link_options(PlatformCommonInternal INTERFACE
         -DYNAMICBASE -NXCOMPAT -LARGEADDRESSAWARE
-        $<$<NOT:$<CONFIG:Debug>>:-OPT:REF -OPT:ICF -GUARD:CF>
+        $<$<NOT:$<CONFIG:Debug>>:-OPT:REF -OPT:ICF -OPT:LBR -GUARD:CF>
     )
+
+    if(TEST_architecture_arch STREQUAL "x86_64")
+        target_link_options(PlatformCommonInternal INTERFACE
+            -HIGHENTROPYVA
+        )
+    endif()
 endif()
 
 if(MINGW)
@@ -279,9 +290,11 @@ endif()
 
 if(QT_FEATURE_intelcet)
     if(MSVC)
-        target_link_options(PlatformCommonInternal INTERFACE
-            -CETCOMPAT
-        )
+        if(MSVC_VERSION GREATER_EQUAL 1920) # Visual Studio 2019 version 16.0
+            target_link_options(PlatformCommonInternal INTERFACE
+                -CETCOMPAT
+            )
+        endif()
     else()
         target_compile_options(PlatformCommonInternal INTERFACE
             -fcf-protection=full
diff --git a/cmake/VC-LTL.cmake b/cmake/VC-LTL.cmake
new file mode 100644
index 0000000000..2bab2f21d6
--- /dev/null
+++ b/cmake/VC-LTL.cmake
@@ -0,0 +1,94 @@
+﻿# https://github.com/Chuyu-Team/VC-LTL5
+
+#
+#  VC-LTL自动化加载配置，建议你将此文件单独复制到你的工程再使用，该文件能自动识别当前环境是否存在VC-LTL，并且自动应用。
+#
+#  使用方法：
+#    1. 在“CMakeLists.txt” 添加 “include("VC-LTL helper for cmake.cmake")”。
+#
+#  VC-LTL默认搜索顺序
+#    1. “VC-LTL helper for cmake.cmake”所在根目录，即 ${CMAKE_CURRENT_LIST_DIR}
+#    2. 当前CMake根目录，即 ${CMAKE_CURRENT_SOURCE_DIR}/VC-LTL
+#    3. 当前项目根目录，即 ${PROJECT_SOURCE_DIR}/VC-LTL
+#    4. 当前CMake父目录，即 ${CMAKE_CURRENT_SOURCE_DIR}/../VC-LTL
+#    5. 当前项目根目录，即 ${PROJECT_SOURCE_DIR}/../VC-LTL
+#    6. 注册表HKEY_CURRENT_USER\Code\VC-LTL@Root
+#
+#  把VC-LTL放在其中一个位置即可，VC-LTL就能被自动引用。
+#
+#  如果你对默认搜索顺序不满，你可以修改此文件。你也可以直接指定${VC_LTL_Root}宏更加任性的去加载VC-LTL。
+#
+
+if(NOT MSVC OR DEFINED __VC_LTL_CMAKE_INCLUDE_GUARD)
+    return()
+endif()
+set(__VC_LTL_CMAKE_INCLUDE_GUARD 1)
+
+#####################################################################VC-LTL设置#####################################################################
+
+#控制TargetPlatform版本，目前可用版本为5.1.2600.0     6.0.6000.0（默认）    6.2.9200.0     10.0.10240.0    10.0.19041.0
+if(NOT DEFINED WindowsTargetPlatformMinVersion)
+    set(WindowsTargetPlatformMinVersion "10.0.19041.0" CACHE STRING "" FORCE)
+endif()
+
+#启用干净的导入表，消除 ucrt apiset(如：api-ms-win-crt-time-l1-1-0.dll)，满足强迫症患者。
+if(NOT DEFINED CleanImport)
+    set(CleanImport "true" CACHE STRING "" FORCE)
+endif()
+
+####################################################################################################################################################
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${CMAKE_CURRENT_LIST_DIR}/_msvcrt.h)
+		set(VC_LTL_Root ${CMAKE_CURRENT_LIST_DIR})
+	endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/VC-LTL/_msvcrt.h)
+		set(VC_LTL_Root ${CMAKE_CURRENT_SOURCE_DIR}/VC-LTL)
+	endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${PROJECT_SOURCE_DIR}/VC-LTL/_msvcrt.h)
+        set(VC_LTL_Root ${PROJECT_SOURCE_DIR}/VC-LTL)
+    endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/../VC-LTL/_msvcrt.h)
+        set(VC_LTL_Root ${CMAKE_CURRENT_SOURCE_DIR}/../VC-LTL)
+    endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${PROJECT_SOURCE_DIR}/../VC-LTL/_msvcrt.h)
+        set(VC_LTL_Root ${PROJECT_SOURCE_DIR}/../VC-LTL)
+    endif()
+endif()
+
+if(NOT VC_LTL_Root)
+    EXECUTE_PROCESS(COMMAND reg query "HKEY_CURRENT_USER\\Code\\VC-LTL" -v "Root"
+                    OUTPUT_VARIABLE FOUND_FILE
+                    ERROR_VARIABLE ERROR_INFO
+                   )
+
+    string(REGEX MATCH "[a-zA-Z]:\\\\.+\\\\"
+           FOUND_LTL
+           ${FOUND_FILE})
+    if (NOT ${FOUND_LTL} STREQUAL "")
+        set(VC_LTL_Root ${FOUND_LTL})
+    endif()
+
+    if(NOT DEFINED VC_LTL_Root)
+        string(REGEX MATCH "\\\\\\\\.+\\\\" FOUND_LTL ${FOUND_FILE})
+        if (NOT ${FOUND_LTL} STREQUAL "")
+            set(VC_LTL_Root ${FOUND_LTL})
+        endif()
+    endif()
+endif()
+
+if(VC_LTL_Root)
+    include("${VC_LTL_Root}\\config\\config.cmake")
+endif()
diff --git a/src/corelib/CMakeLists.txt b/src/corelib/CMakeLists.txt
index 8fc301e27f..ce803de948 100644
--- a/src/corelib/CMakeLists.txt
+++ b/src/corelib/CMakeLists.txt
@@ -540,6 +540,7 @@ qt_internal_extend_target(Core CONDITION QT_FEATURE_animation
 # from the wrong DLL at runtime and crash!
 qt_internal_extend_target(Core CONDITION QT_FEATURE_thread AND WIN32
     SOURCES
+        thread/qmutex_win.cpp
         thread/qwaitcondition_win.cpp
     LIBRARIES
         synchronization
@@ -1320,6 +1321,7 @@ qt_internal_extend_target(Core CONDITION WASM
 set_source_files_properties(
     thread/qmutex_mac.cpp
     thread/qmutex_unix.cpp
+    thread/qmutex_win.cpp
     PROPERTIES HEADER_FILE_ONLY ON)  # special case: These files are included by qmutex.cpp!
 
 
diff --git a/src/corelib/global/qlibraryinfo.cpp b/src/corelib/global/qlibraryinfo.cpp
index 715bda488c..6973de9d76 100644
--- a/src/corelib/global/qlibraryinfo.cpp
+++ b/src/corelib/global/qlibraryinfo.cpp
@@ -296,8 +296,13 @@ static QString prefixFromQtCoreLibraryHelper(const QString &qtCoreLibraryPath)
 {
     const QString qtCoreLibrary = QDir::fromNativeSeparators(qtCoreLibraryPath);
     const QString libDir = QFileInfo(qtCoreLibrary).absolutePath();
-    const QString prefixDir = libDir + "/" QT_CONFIGURE_LIBLOCATION_TO_PREFIX_PATH;
-    return QDir::cleanPath(prefixDir);
+    const QString prefix = libDir + "/";
+    return QDir::cleanPath([&prefix]() -> QString {
+        if (qEnvironmentVariableIntValue("QT_FORCE_LOAD_PLUGINS_FROM_CORE_DIR")) {
+            return prefix;
+        }
+        return prefix + QT_CONFIGURE_LIBLOCATION_TO_PREFIX_PATH;
+    }());
 }
 #endif
 
@@ -686,6 +691,17 @@ const char *qVersion() noexcept
     return QT_VERSION_STR;
 }
 
+/*!
+    A special function to identify this custom Qt build.
+    It will always return the magic number "2546789017"
+    as the result. It's my QQ number and you can contact
+    me by sending me an e-mail to "2546789017@qq.com".
+*/
+quint64 __wangwenx190__() noexcept
+{
+    return 2546789017;
+}
+
 #if QT_DEPRECATED_SINCE(6, 9)
 
 bool qSharedBuild() noexcept
diff --git a/src/corelib/global/qlibraryinfo.h b/src/corelib/global/qlibraryinfo.h
index d4e8f8b050..6cd0b448cf 100644
--- a/src/corelib/global/qlibraryinfo.h
+++ b/src/corelib/global/qlibraryinfo.h
@@ -61,6 +61,11 @@ Q_CORE_EXPORT Q_DECL_CONST_FUNCTION bool qSharedBuild() noexcept;
 
 #endif
 
+#if (!defined(QT_NAMESPACE) && defined(__cplusplus))
+extern "C"
+#endif
+Q_CORE_EXPORT Q_DECL_CONST_FUNCTION quint64 __wangwenx190__(void) noexcept;
+
 QT_END_NAMESPACE
 
 #endif // QLIBRARYINFO_H
diff --git a/src/corelib/global/qoperatingsystemversion.cpp b/src/corelib/global/qoperatingsystemversion.cpp
index b9da31149e..38f7a3b055 100644
--- a/src/corelib/global/qoperatingsystemversion.cpp
+++ b/src/corelib/global/qoperatingsystemversion.cpp
@@ -393,6 +393,13 @@ const QOperatingSystemVersion QOperatingSystemVersion::Windows8_1 =
 const QOperatingSystemVersion QOperatingSystemVersion::Windows10 =
     QOperatingSystemVersion(QOperatingSystemVersion::Windows, 10);
 
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1507;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1511;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1607;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1703;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1709;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1803;
+
 /*!
     \variable QOperatingSystemVersion::Windows10_1809
     \brief a version corresponding to Windows 10 October 2018 Update
diff --git a/src/corelib/global/qoperatingsystemversion.h b/src/corelib/global/qoperatingsystemversion.h
index 1e4eb5cc49..8523df1e19 100644
--- a/src/corelib/global/qoperatingsystemversion.h
+++ b/src/corelib/global/qoperatingsystemversion.h
@@ -188,6 +188,12 @@ public:
     static constexpr QOperatingSystemVersionBase Android11 { QOperatingSystemVersionBase::Android, 11, 0 };
 #endif // New (static constexpr) entries go here, only cherry-pick as far back as 6.3 (QTBUG-97808):
 
+    static constexpr QOperatingSystemVersionBase Windows10_1507 { QOperatingSystemVersionBase::Windows, 10, 0, 10240 }; // TH1
+    static constexpr QOperatingSystemVersionBase Windows10_1511 { QOperatingSystemVersionBase::Windows, 10, 0, 10586 }; // TH2
+    static constexpr QOperatingSystemVersionBase Windows10_1607 { QOperatingSystemVersionBase::Windows, 10, 0, 14393 }; // RS1
+    static constexpr QOperatingSystemVersionBase Windows10_1703 { QOperatingSystemVersionBase::Windows, 10, 0, 15063 }; // RS2
+    static constexpr QOperatingSystemVersionBase Windows10_1709 { QOperatingSystemVersionBase::Windows, 10, 0, 16299 }; // RS3
+    static constexpr QOperatingSystemVersionBase Windows10_1803 { QOperatingSystemVersionBase::Windows, 10, 0, 17134 }; // RS4
     static constexpr QOperatingSystemVersionBase Windows10_1809 { QOperatingSystemVersionBase::Windows, 10, 0, 17763 }; // RS5
     static constexpr QOperatingSystemVersionBase Windows10_1903 { QOperatingSystemVersionBase::Windows, 10, 0, 18362 }; // 19H1
     static constexpr QOperatingSystemVersionBase Windows10_1909 { QOperatingSystemVersionBase::Windows, 10, 0, 18363 }; // 19H2
@@ -206,6 +212,37 @@ public:
 
     static constexpr QOperatingSystemVersionBase MacOSVentura { QOperatingSystemVersionBase::MacOS, 13, 0 };
 
+#ifdef Q_OS_WINDOWS
+#  define MAKE_VERSION_FUNCTION(Name, Version) \
+    static bool isWin##Name##OrGreater() \
+    { \
+        static const bool result = QOperatingSystemVersion::current() >= QOperatingSystemVersion::Windows##Version; \
+        return result; \
+    }
+    MAKE_VERSION_FUNCTION(7, 7)
+    MAKE_VERSION_FUNCTION(8, 8)
+    MAKE_VERSION_FUNCTION(8Point1, 8_1)
+    MAKE_VERSION_FUNCTION(10, 10)
+    MAKE_VERSION_FUNCTION(10TH1, 10_1507)
+    MAKE_VERSION_FUNCTION(10TH2, 10_1511)
+    MAKE_VERSION_FUNCTION(10RS1, 10_1607)
+    MAKE_VERSION_FUNCTION(10RS2, 10_1703)
+    MAKE_VERSION_FUNCTION(10RS3, 10_1709)
+    MAKE_VERSION_FUNCTION(10RS4, 10_1803)
+    MAKE_VERSION_FUNCTION(10RS5, 10_1809)
+    MAKE_VERSION_FUNCTION(1019H1, 10_1903)
+    MAKE_VERSION_FUNCTION(1019H2, 10_1909)
+    MAKE_VERSION_FUNCTION(1020H1, 10_2004)
+    MAKE_VERSION_FUNCTION(1020H2, 10_20H2)
+    MAKE_VERSION_FUNCTION(1021H1, 10_21H1)
+    MAKE_VERSION_FUNCTION(1021H2, 10_21H2)
+    MAKE_VERSION_FUNCTION(1022H2, 10_22H2)
+    MAKE_VERSION_FUNCTION(11, 11)
+    MAKE_VERSION_FUNCTION(1121H2, 11_21H2)
+    MAKE_VERSION_FUNCTION(1122H2, 11_22H2)
+#  undef MAKE_VERSION_FUNCTION
+#endif // Q_OS_WINDOWS
+
     constexpr QOperatingSystemVersion(const QOperatingSystemVersionBase &osversion)
         : QOperatingSystemVersionBase(osversion) {}
 
diff --git a/src/corelib/global/qoperatingsystemversion_win.cpp b/src/corelib/global/qoperatingsystemversion_win.cpp
index a209fb17b6..5fa500b4dc 100644
--- a/src/corelib/global/qoperatingsystemversion_win.cpp
+++ b/src/corelib/global/qoperatingsystemversion_win.cpp
@@ -51,7 +51,16 @@ OSVERSIONINFOEX qWindowsVersionInfo()
             result.wServicePackMinor = 0;
 
             const QByteArray winVerOverride = qgetenv("QT_WINVER_OVERRIDE");
-            if (winVerOverride == "WINDOWS10" || winVerOverride == "2016"
+            if (winVerOverride == "WINDOWS7" || winVerOverride == "2008_R2") {
+                result.dwMajorVersion = 6;
+                result.dwMinorVersion = 1;
+            } else if (winVerOverride == "WINDOWS8" || winVerOverride == "2012") {
+                result.dwMajorVersion = 6;
+                result.dwMinorVersion = 2;
+            } else if (winVerOverride == "WINDOWS8_1" || winVerOverride == "2012_R2") {
+                result.dwMajorVersion = 6;
+                result.dwMinorVersion = 3;
+            } else if (winVerOverride == "WINDOWS10" || winVerOverride == "2016"
                 || winVerOverride == "2019" || winVerOverride == "2022") {
                 result.dwMajorVersion = 10;
             } else if (winVerOverride == "WINDOWS11") {
@@ -61,7 +70,11 @@ OSVERSIONINFOEX qWindowsVersionInfo()
                 return realResult;
             }
 
-            if (winVerOverride == "2016" || winVerOverride == "2019"
+            if (winVerOverride == "2008_R2"
+                || winVerOverride == "2012"
+                || winVerOverride == "2012_R2"
+                || winVerOverride == "2016"
+                || winVerOverride == "2019"
                 || winVerOverride == "2022") {
                 // If the current host OS is a domain controller and the override OS
                 // is also a server type OS, preserve that information
diff --git a/src/corelib/global/qsysinfo.cpp b/src/corelib/global/qsysinfo.cpp
index 9df9d96b5e..95bcb1a936 100644
--- a/src/corelib/global/qsysinfo.cpp
+++ b/src/corelib/global/qsysinfo.cpp
@@ -165,12 +165,17 @@ static inline QString windowsDisplayVersion()
 {
     // https://tickets.puppetlabs.com/browse/FACT-3058
     // The "ReleaseId" key stopped updating since Windows 10 20H2.
-    if (QOperatingSystemVersion::current() >= QOperatingSystemVersion::Windows10_20H2)
+    if (QOperatingSystemVersion::isWin1020H2OrGreater())
         return readVersionRegistryString(L"DisplayVersion");
     else
         return readVersionRegistryString(L"ReleaseId");
 }
 
+static QString windows7Build()
+{
+    return readVersionRegistryString(L"CurrentBuild");
+}
+
 static QString winSp_helper()
 {
     const auto osv = qWindowsVersionInfo();
@@ -194,6 +199,12 @@ static const char *osVer_helper(QOperatingSystemVersion version = QOperatingSyst
 
 #define Q_WINVER(major, minor) (major << 8 | minor)
     switch (Q_WINVER(osver.dwMajorVersion, osver.dwMinorVersion)) {
+    case Q_WINVER(6, 1):
+        return workstation ? "7" : "Server 2008 R2";
+    case Q_WINVER(6, 2):
+        return workstation ? "8" : "Server 2012";
+    case Q_WINVER(6, 3):
+        return workstation ? "8.1" : "Server 2012 R2";
     case Q_WINVER(10, 0):
         if (workstation) {
             if (osver.dwBuildNumber >= 22000)
@@ -885,10 +896,21 @@ QString QSysInfo::prettyProductName()
     return result + " ("_L1 + versionString + u')';
 #  else
     // (resembling winver.exe): Windows 10 "Windows 10 Version 1809"
-    const auto displayVersion = windowsDisplayVersion();
-    if (!displayVersion.isEmpty())
-        result += " Version "_L1 + displayVersion;
-    return result;
+    if (majorVersion >= 10) {
+        const auto displayVersion = windowsDisplayVersion();
+        if (!displayVersion.isEmpty())
+            result += " Version "_L1 + displayVersion;
+        return result;
+    }
+    // Windows 7: "Windows 7 Version 6.1 (Build 7601: Service Pack 1)"
+    result += " Version "_L1 + versionString + " ("_L1;
+    const auto build = windows7Build();
+    if (!build.isEmpty())
+        result += "Build "_L1 + build;
+    const auto servicePack = winSp_helper();
+    if (!servicePack.isEmpty())
+        result += ": "_L1 + servicePack;
+    return result + u')';
 #  endif // Windows
 #elif defined(Q_OS_HAIKU)
     return "Haiku "_L1 + productVersion();
diff --git a/src/corelib/kernel/qcoreapplication.cpp b/src/corelib/kernel/qcoreapplication.cpp
index d9a42413e4..2bc9ec726d 100644
--- a/src/corelib/kernel/qcoreapplication.cpp
+++ b/src/corelib/kernel/qcoreapplication.cpp
@@ -108,6 +108,10 @@ QT_BEGIN_NAMESPACE
 
 using namespace Qt::StringLiterals;
 
+#ifndef QT_BOOTSTRAPPED
+static constexpr const char kWwx190EnvVar[] = "__wangwenx190__";
+#endif
+
 #if defined(Q_OS_WIN) || defined(Q_OS_MAC)
 extern QString qAppFileName();
 #endif
@@ -446,6 +450,9 @@ QCoreApplicationPrivate::QCoreApplicationPrivate(int &aargc, char **aargv)
 
 QCoreApplicationPrivate::~QCoreApplicationPrivate()
 {
+#ifndef QT_BOOTSTRAPPED
+    qunsetenv(kWwx190EnvVar);
+#endif
 #ifndef QT_NO_QOBJECT
     cleanupThreadData();
 #endif
@@ -784,6 +791,10 @@ void QCoreApplicationPrivate::init()
     Q_ASSERT_X(!QCoreApplication::self, "QCoreApplication", "there should be only one application object");
     QCoreApplication::self = q;
 
+#ifndef QT_BOOTSTRAPPED
+    qputenv(kWwx190EnvVar, QByteArray::number(__wangwenx190__()));
+#endif
+
 #if QT_CONFIG(thread)
 #ifdef Q_OS_WASM
     emscripten::val hardwareConcurrency = emscripten::val::global("navigator")["hardwareConcurrency"];
diff --git a/src/corelib/kernel/qeventdispatcher_win.cpp b/src/corelib/kernel/qeventdispatcher_win.cpp
index 1c54c97514..3577cb5f52 100644
--- a/src/corelib/kernel/qeventdispatcher_win.cpp
+++ b/src/corelib/kernel/qeventdispatcher_win.cpp
@@ -18,6 +18,8 @@
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 #ifndef TIME_KILL_SYNCHRONOUS
 #  define TIME_KILL_SYNCHRONOUS 0x0100
 #endif
@@ -355,8 +357,15 @@ void QEventDispatcherWin32Private::registerTimer(WinTimerInfo *t)
     }
 
     if (!ok) {
-        // user normal timers for (Very)CoarseTimers, or if no more multimedia timers available
-        ok = SetCoalescableTimer(internalHwnd, t->timerId, interval, nullptr, tolerance);
+        if (QOperatingSystemVersion::isWin8OrGreater()) {
+            static const auto pSetCoalescableTimer =
+                reinterpret_cast<decltype(&::SetCoalescableTimer)>(
+                    QSystemLibrary::resolve(u"user32"_s, "SetCoalescableTimer"));
+            if (pSetCoalescableTimer) {
+                // user normal timers for (Very)CoarseTimers, or if no more multimedia timers available
+                ok = pSetCoalescableTimer(internalHwnd, t->timerId, interval, nullptr, tolerance);
+            }
+        }
     }
     if (!ok)
         ok = SetTimer(internalHwnd, t->timerId, interval, nullptr);
diff --git a/src/corelib/kernel/qfunctions_win.cpp b/src/corelib/kernel/qfunctions_win.cpp
index ed0e25467c..64108cce84 100644
--- a/src/corelib/kernel/qfunctions_win.cpp
+++ b/src/corelib/kernel/qfunctions_win.cpp
@@ -4,6 +4,8 @@
 #include "qfunctions_win_p.h"
 
 #include <QtCore/qdebug.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 
 #include <combaseapi.h>
 #include <objbase.h>
@@ -15,6 +17,8 @@
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 QComHelper::QComHelper(COINIT concurrencyModel)
 {
     // Avoid overhead of initializing and using obsolete technology
@@ -44,8 +48,15 @@ bool qt_win_hasPackageIdentity()
 {
 #if defined(HAS_APPMODEL)
     static const bool hasPackageIdentity = []() {
+        if (!QOperatingSystemVersion::isWin8OrGreater())
+            return false;
+        static const auto pGetCurrentPackageFullName =
+            reinterpret_cast<decltype(&::GetCurrentPackageFullName)>(
+                QSystemLibrary::resolve(u"kernel32"_s, "GetCurrentPackageFullName"));
+        if (!pGetCurrentPackageFullName)
+            return false;
         UINT32 length = 0;
-        switch (const auto result = GetCurrentPackageFullName(&length, nullptr)) {
+        switch (const auto result = pGetCurrentPackageFullName(&length, nullptr)) {
         case ERROR_INSUFFICIENT_BUFFER:
             return true;
         case APPMODEL_ERROR_NO_PACKAGE:
diff --git a/src/corelib/text/qlocale_win.cpp b/src/corelib/text/qlocale_win.cpp
index 67fac95304..0486aa84b4 100644
--- a/src/corelib/text/qlocale_win.cpp
+++ b/src/corelib/text/qlocale_win.cpp
@@ -15,6 +15,7 @@
 #include <q20algorithm.h>
 
 #ifdef Q_OS_WIN
+#   include <qoperatingsystemversion.h>
 #   include <qt_windows.h>
 #   include <time.h>
 #endif
@@ -663,17 +664,19 @@ QVariant QSystemLocalePrivate::uiLanguages()
 {
     QStringList result;
 #if QT_CONFIG(cpp_winrt)
-    using namespace winrt;
-    using namespace Windows::System::UserProfile;
-    QT_TRY {
-        auto languages = GlobalizationPreferences::Languages();
-        for (const auto &lang : languages)
-            result << QString::fromStdString(winrt::to_string(lang));
-    } QT_CATCH(...) {
-        // pass, just fall back to WIN32 API implementation
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        using namespace winrt;
+        using namespace Windows::System::UserProfile;
+        QT_TRY {
+            const auto languages = GlobalizationPreferences::Languages();
+            for (auto &&lang : languages)
+                result << QString::fromStdString(winrt::to_string(lang));
+        } QT_CATCH(...) {
+            // pass, just fall back to WIN32 API implementation
+        }
+        if (!result.isEmpty())
+            return result; // else just fall back to WIN32 API implementation
     }
-    if (!result.isEmpty())
-        return result; // else just fall back to WIN32 API implementation
 #endif // QT_CONFIG(cpp_winrt)
     // mingw and clang still have to use Win32 API
     unsigned long cnt = 0;
diff --git a/src/corelib/thread/qfutex_p.h b/src/corelib/thread/qfutex_p.h
index 48f03f5ed0..fe799c68ca 100644
--- a/src/corelib/thread/qfutex_p.h
+++ b/src/corelib/thread/qfutex_p.h
@@ -17,9 +17,12 @@
 
 #include <private/qglobal_p.h>
 #include <QtCore/qtsan_impl.h>
+#include <QtCore/qstring.h>
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 namespace QtDummyFutex {
     constexpr inline bool futexAvailable() { return false; }
     template <typename Atomic>
@@ -109,35 +112,86 @@ namespace QtFutex = QtLinuxFutex;
 QT_END_NAMESPACE
 
 #elif defined(Q_OS_WIN)
-#  include <qt_windows.h>
+#  include <QtCore/qoperatingsystemversion.h>
+#  include <QtCore/private/qsystemlibrary_p.h>
+#  include <QtCore/qt_windows.h>
 
 QT_BEGIN_NAMESPACE
-namespace QtWindowsFutex {
-#define QT_ALWAYS_USE_FUTEX
-constexpr inline bool futexAvailable() { return true; }
+namespace QtWindowsFutex
+{
+#ifdef QT_ALWAYS_USE_FUTEX
+#  undef QT_ALWAYS_USE_FUTEX
+#endif
+
+inline bool futexAvailable()
+{
+    return QOperatingSystemVersion::isWin8OrGreater();
+}
+
+struct QFutexApi
+{
+    decltype(&::WaitOnAddress) pWaitOnAddress = nullptr;
+    decltype(&::WakeByAddressAll) pWakeByAddressAll = nullptr;
+    decltype(&::WakeByAddressSingle) pWakeByAddressSingle = nullptr;
+
+    static QFutexApi *instance()
+    {
+        static QFutexApi api;
+        return &api;
+    }
+
+private:
+    Q_DISABLE_COPY_MOVE(QFutexApi)
+
+    explicit QFutexApi()
+    {
+        if (!futexAvailable())
+            return;
+        QSystemLibrary library(u"kernelbase"_s);
+        pWaitOnAddress = reinterpret_cast<decltype(pWaitOnAddress)>(library.resolve("WaitOnAddress"));
+        pWakeByAddressAll = reinterpret_cast<decltype(pWakeByAddressAll)>(library.resolve("WakeByAddressAll"));
+        pWakeByAddressSingle = reinterpret_cast<decltype(pWakeByAddressSingle)>(library.resolve("WakeByAddressSingle"));
+    }
+
+    ~QFutexApi() = default;
+};
 
 template <typename Atomic>
 inline void futexWait(Atomic &futex, typename Atomic::Type expectedValue)
 {
+    if (!QFutexApi::instance()->pWaitOnAddress)
+        return;
     QtTsan::futexRelease(&futex);
-    WaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), INFINITE);
+    QFutexApi::instance()->pWaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), INFINITE);
     QtTsan::futexAcquire(&futex);
 }
+
 template <typename Atomic>
 inline bool futexWait(Atomic &futex, typename Atomic::Type expectedValue, qint64 nstimeout)
 {
-    BOOL r = WaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), DWORD(nstimeout / 1000 / 1000));
+    if (!QFutexApi::instance()->pWaitOnAddress)
+        return false;
+    const BOOL r = QFutexApi::instance()->pWaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), DWORD(nstimeout / 1000 / 1000));
     return r || GetLastError() != ERROR_TIMEOUT;
 }
-template <typename Atomic> inline void futexWakeAll(Atomic &futex)
+
+template <typename Atomic>
+inline void futexWakeAll(Atomic &futex)
 {
-    WakeByAddressAll(&futex);
+    if (!QFutexApi::instance()->pWakeByAddressAll)
+        return;
+    QFutexApi::instance()->pWakeByAddressAll(&futex);
 }
-template <typename Atomic> inline void futexWakeOne(Atomic &futex)
+
+template <typename Atomic>
+inline void futexWakeOne(Atomic &futex)
 {
-    WakeByAddressSingle(&futex);
-}
+    if (!QFutexApi::instance()->pWakeByAddressSingle)
+        return;
+    QFutexApi::instance()->pWakeByAddressSingle(&futex);
 }
+} // namespace QtWindowsFutex
+
 namespace QtFutex = QtWindowsFutex;
 QT_END_NAMESPACE
 #else
diff --git a/src/corelib/thread/qlocking_p.h b/src/corelib/thread/qlocking_p.h
index 9fa7e70da9..0c205fff66 100644
--- a/src/corelib/thread/qlocking_p.h
+++ b/src/corelib/thread/qlocking_p.h
@@ -8,9 +8,10 @@
 //  W A R N I N G
 //  -------------
 //
-// This file is not part of the Qt API. It exists for the convenience of
-// qmutex.cpp and qmutex_unix.cpp. This header file may change from version to
-// version without notice, or even be removed.
+// This file is not part of the Qt API.  It exists for the convenience
+// of qmutex.cpp, qmutex_unix.cpp, and qmutex_win.cpp.  This header
+// file may change from version to version without notice, or even be
+// removed.
 //
 // We mean it.
 //
diff --git a/src/corelib/thread/qmutex.cpp b/src/corelib/thread/qmutex.cpp
index 7b4aac9532..ae1a3a7313 100644
--- a/src/corelib/thread/qmutex.cpp
+++ b/src/corelib/thread/qmutex.cpp
@@ -869,6 +869,8 @@ QT_END_NAMESPACE
 // nothing
 #elif defined(Q_OS_MAC)
 #  include "qmutex_mac.cpp"
+#elif defined(Q_OS_WIN)
+#  include "qmutex_win.cpp"
 #else
 #  include "qmutex_unix.cpp"
 #endif
diff --git a/src/corelib/thread/qmutex_p.h b/src/corelib/thread/qmutex_p.h
index e5932d0a66..9985a068c5 100644
--- a/src/corelib/thread/qmutex_p.h
+++ b/src/corelib/thread/qmutex_p.h
@@ -10,9 +10,10 @@
 //  W A R N I N G
 //  -------------
 //
-// This file is not part of the Qt API. It exists for the convenience of
-// qmutex.cpp and qmutex_unix.cpp. This header file may change from version to
-// version without notice, or even be removed.
+// This file is not part of the Qt API.  It exists for the convenience
+// of qmutex.cpp, qmutex_unix.cpp, and qmutex_win.cpp.  This header
+// file may change from version to version without notice, or even be
+// removed.
 //
 // We mean it.
 //
@@ -89,6 +90,8 @@ public:
     bool wakeup;
     pthread_mutex_t mutex;
     pthread_cond_t cond;
+#elif defined(Q_OS_WIN)
+    Qt::HANDLE event;
 #endif
 };
 
diff --git a/src/corelib/thread/qmutex_win.cpp b/src/corelib/thread/qmutex_win.cpp
new file mode 100644
index 0000000000..8c7741c113
--- /dev/null
+++ b/src/corelib/thread/qmutex_win.cpp
@@ -0,0 +1,30 @@
+// Copyright (C) 2016 The Qt Company Ltd.
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
+
+#include "qmutex.h"
+#include <qatomic.h>
+#include "qmutex_p.h"
+#include <qt_windows.h>
+
+QT_BEGIN_NAMESPACE
+
+QMutexPrivate::QMutexPrivate()
+{
+    event = CreateEvent(0, FALSE, FALSE, 0);
+
+    if (!event)
+        qWarning("QMutexPrivate::QMutexPrivate: Cannot create event");
+}
+
+QMutexPrivate::~QMutexPrivate()
+{ CloseHandle(event); }
+
+bool QMutexPrivate::wait(int timeout)
+{
+    return (WaitForSingleObjectEx(event, timeout < 0 ? INFINITE : timeout, FALSE) == WAIT_OBJECT_0);
+}
+
+void QMutexPrivate::wakeUp() noexcept
+{ SetEvent(event); }
+
+QT_END_NAMESPACE
diff --git a/src/corelib/thread/qwaitcondition_p.h b/src/corelib/thread/qwaitcondition_p.h
index 0893e9dd35..e82f832817 100644
--- a/src/corelib/thread/qwaitcondition_p.h
+++ b/src/corelib/thread/qwaitcondition_p.h
@@ -7,9 +7,10 @@
 //  W A R N I N G
 //  -------------
 //
-// This file is not part of the Qt API. It exists for the convenience of
-// qmutex.cpp and qmutex_unix.cpp. This header file may change from version to
-// version without notice, or even be removed.
+// This file is not part of the Qt API.  It exists for the convenience
+// of qmutex.cpp, qmutex_unix.cpp, and qmutex_win.cpp.  This header
+// file may change from version to version without notice, or even be
+// removed.
 //
 // We mean it.
 //
diff --git a/src/gui/CMakeLists.txt b/src/gui/CMakeLists.txt
index a8e4d12718..e1ab0ca9a2 100644
--- a/src/gui/CMakeLists.txt
+++ b/src/gui/CMakeLists.txt
@@ -433,7 +433,6 @@ qt_internal_extend_target(Gui CONDITION WIN32
         d3d11
         dxgi
         dxguid
-        dcomp
 )
 
 #### Keys ignored in scope 7:.:.:gui.pro:WIN32:
@@ -509,21 +508,6 @@ qt_internal_extend_target(Gui CONDITION APPLE AND QT_FEATURE_accessibility
         ${FWFoundation}
 )
 
-qt_internal_extend_target(Gui CONDITION QT_FEATURE_accessibility AND WIN32
-    SOURCES
-        accessible/windows/apisupport/qwindowsuiawrapper.cpp accessible/windows/apisupport/qwindowsuiawrapper_p.h
-        accessible/windows/apisupport/uiaattributeids_p.h
-        accessible/windows/apisupport/uiaclientinterfaces_p.h
-        accessible/windows/apisupport/uiacontroltypeids_p.h
-        accessible/windows/apisupport/uiaerrorids_p.h
-        accessible/windows/apisupport/uiaeventids_p.h
-        accessible/windows/apisupport/uiageneralids_p.h
-        accessible/windows/apisupport/uiapatternids_p.h
-        accessible/windows/apisupport/uiapropertyids_p.h
-        accessible/windows/apisupport/uiaserverinterfaces_p.h
-        accessible/windows/apisupport/uiatypes_p.h
-)
-
 if(QT_FEATURE_accessibility AND QT_FEATURE_accessibility_atspi_bridge)
     set(atspi_accessibility ON)
 else()
diff --git a/src/gui/accessible/windows/apisupport/qwindowsuiawrapper.cpp b/src/gui/accessible/windows/apisupport/qwindowsuiawrapper.cpp
deleted file mode 100644
index d9ff723a61..0000000000
--- a/src/gui/accessible/windows/apisupport/qwindowsuiawrapper.cpp
+++ /dev/null
@@ -1,89 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include <initguid.h>
-
-#include "qwindowsuiawrapper_p.h"
-#include <QtCore/private/qsystemlibrary_p.h>
-
-QT_BEGIN_NAMESPACE
-
-// private constructor
-QWindowsUiaWrapper::QWindowsUiaWrapper()
-{
-    QSystemLibrary uiaLib(QStringLiteral("UIAutomationCore"));
-    if (uiaLib.load()) {
-        m_pUiaReturnRawElementProvider = reinterpret_cast<PtrUiaReturnRawElementProvider>(uiaLib.resolve("UiaReturnRawElementProvider"));
-        m_pUiaHostProviderFromHwnd = reinterpret_cast<PtrUiaHostProviderFromHwnd>(uiaLib.resolve("UiaHostProviderFromHwnd"));
-        m_pUiaRaiseAutomationPropertyChangedEvent = reinterpret_cast<PtrUiaRaiseAutomationPropertyChangedEvent>(uiaLib.resolve("UiaRaiseAutomationPropertyChangedEvent"));
-        m_pUiaRaiseAutomationEvent = reinterpret_cast<PtrUiaRaiseAutomationEvent>(uiaLib.resolve("UiaRaiseAutomationEvent"));
-        m_pUiaRaiseNotificationEvent = reinterpret_cast<PtrUiaRaiseNotificationEvent>(uiaLib.resolve("UiaRaiseNotificationEvent"));
-        m_pUiaClientsAreListening = reinterpret_cast<PtrUiaClientsAreListening>(uiaLib.resolve("UiaClientsAreListening"));
-    }
-}
-
-QWindowsUiaWrapper::~QWindowsUiaWrapper()
-{
-}
-
-// shared instance
-QWindowsUiaWrapper *QWindowsUiaWrapper::instance()
-{
-    static QWindowsUiaWrapper wrapper;
-    return &wrapper;
-}
-
-// True if most symbols resolved (UiaRaiseNotificationEvent is optional).
-BOOL QWindowsUiaWrapper::ready()
-{
-    return m_pUiaReturnRawElementProvider
-        && m_pUiaHostProviderFromHwnd
-        && m_pUiaRaiseAutomationPropertyChangedEvent
-        && m_pUiaRaiseAutomationEvent
-        && m_pUiaClientsAreListening;
-}
-
-BOOL QWindowsUiaWrapper::clientsAreListening()
-{
-    if (!m_pUiaClientsAreListening)
-        return FALSE;
-    return m_pUiaClientsAreListening();
-}
-
-LRESULT QWindowsUiaWrapper::returnRawElementProvider(HWND hwnd, WPARAM wParam, LPARAM lParam, IRawElementProviderSimple *el)
-{
-    if (!m_pUiaReturnRawElementProvider)
-        return static_cast<LRESULT>(NULL);
-    return m_pUiaReturnRawElementProvider(hwnd, wParam, lParam, el);
-}
-
-HRESULT QWindowsUiaWrapper::hostProviderFromHwnd(HWND hwnd, IRawElementProviderSimple **ppProvider)
-{
-    if (!m_pUiaHostProviderFromHwnd)
-        return UIA_E_NOTSUPPORTED;
-    return m_pUiaHostProviderFromHwnd(hwnd, ppProvider);
-}
-
-HRESULT QWindowsUiaWrapper::raiseAutomationPropertyChangedEvent(IRawElementProviderSimple *pProvider, PROPERTYID id, VARIANT oldValue, VARIANT newValue)
-{
-    if (!m_pUiaRaiseAutomationPropertyChangedEvent)
-        return UIA_E_NOTSUPPORTED;
-    return m_pUiaRaiseAutomationPropertyChangedEvent(pProvider, id, oldValue, newValue);
-}
-
-HRESULT QWindowsUiaWrapper::raiseAutomationEvent(IRawElementProviderSimple *pProvider, EVENTID id)
-{
-    if (!m_pUiaRaiseAutomationEvent)
-        return UIA_E_NOTSUPPORTED;
-    return m_pUiaRaiseAutomationEvent(pProvider, id);
-}
-
-HRESULT QWindowsUiaWrapper::raiseNotificationEvent(IRawElementProviderSimple *provider, NotificationKind notificationKind, NotificationProcessing notificationProcessing, BSTR displayString, BSTR activityId)
-{
-    if (!m_pUiaRaiseNotificationEvent)
-        return UIA_E_NOTSUPPORTED;
-    return m_pUiaRaiseNotificationEvent(provider, notificationKind, notificationProcessing, displayString, activityId);
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/gui/accessible/windows/apisupport/qwindowsuiawrapper_p.h b/src/gui/accessible/windows/apisupport/qwindowsuiawrapper_p.h
deleted file mode 100644
index 05b93f8393..0000000000
--- a/src/gui/accessible/windows/apisupport/qwindowsuiawrapper_p.h
+++ /dev/null
@@ -1,67 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QWINDOWSUIAWRAPPER_H
-#define QWINDOWSUIAWRAPPER_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists for the convenience
-// of other Qt classes.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <QtGui/private/qtguiglobal_p.h>
-
-#include "uiatypes_p.h"
-#include "uiaattributeids_p.h"
-#include "uiacontroltypeids_p.h"
-#include "uiaerrorids_p.h"
-#include "uiaeventids_p.h"
-#include "uiageneralids_p.h"
-#include "uiapatternids_p.h"
-#include "uiapropertyids_p.h"
-#include "uiaserverinterfaces_p.h"
-#include "uiaclientinterfaces_p.h"
-
-QT_REQUIRE_CONFIG(accessibility);
-
-QT_BEGIN_NAMESPACE
-
-class Q_GUI_EXPORT QWindowsUiaWrapper
-{
-    QWindowsUiaWrapper();
-    virtual ~QWindowsUiaWrapper();
-public:
-    static QWindowsUiaWrapper *instance();
-    BOOL ready();
-    BOOL clientsAreListening();
-    LRESULT returnRawElementProvider(HWND hwnd, WPARAM wParam, LPARAM lParam, IRawElementProviderSimple *el);
-    HRESULT hostProviderFromHwnd(HWND hwnd, IRawElementProviderSimple **ppProvider);
-    HRESULT raiseAutomationPropertyChangedEvent(IRawElementProviderSimple *pProvider, PROPERTYID id, VARIANT oldValue, VARIANT newValue);
-    HRESULT raiseAutomationEvent(IRawElementProviderSimple *pProvider, EVENTID id);
-    HRESULT raiseNotificationEvent(IRawElementProviderSimple *provider, NotificationKind notificationKind, NotificationProcessing notificationProcessing, BSTR displayString, BSTR activityId);
-
-private:
-    typedef LRESULT (WINAPI *PtrUiaReturnRawElementProvider)(HWND, WPARAM, LPARAM, IRawElementProviderSimple *);
-    typedef HRESULT (WINAPI *PtrUiaHostProviderFromHwnd)(HWND, IRawElementProviderSimple **);
-    typedef HRESULT (WINAPI *PtrUiaRaiseAutomationPropertyChangedEvent)(IRawElementProviderSimple *, PROPERTYID, VARIANT, VARIANT);
-    typedef HRESULT (WINAPI *PtrUiaRaiseAutomationEvent)(IRawElementProviderSimple *, EVENTID);
-    typedef HRESULT (WINAPI *PtrUiaRaiseNotificationEvent)(IRawElementProviderSimple *, NotificationKind, NotificationProcessing, BSTR, BSTR);
-    typedef BOOL (WINAPI *PtrUiaClientsAreListening)();
-    PtrUiaReturnRawElementProvider             m_pUiaReturnRawElementProvider = nullptr;
-    PtrUiaHostProviderFromHwnd                 m_pUiaHostProviderFromHwnd = nullptr;
-    PtrUiaRaiseAutomationPropertyChangedEvent  m_pUiaRaiseAutomationPropertyChangedEvent = nullptr;
-    PtrUiaRaiseAutomationEvent                 m_pUiaRaiseAutomationEvent = nullptr;
-    PtrUiaRaiseNotificationEvent               m_pUiaRaiseNotificationEvent = nullptr;
-    PtrUiaClientsAreListening                  m_pUiaClientsAreListening = nullptr;
-};
-
-QT_END_NAMESPACE
-
-#endif //QWINDOWSUIAWRAPPER_H
-
diff --git a/src/gui/accessible/windows/apisupport/uiaattributeids_p.h b/src/gui/accessible/windows/apisupport/uiaattributeids_p.h
deleted file mode 100644
index 2078351a98..0000000000
--- a/src/gui/accessible/windows/apisupport/uiaattributeids_p.h
+++ /dev/null
@@ -1,63 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIAATTRIBUTEIDS_H
-#define UIAATTRIBUTEIDS_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#define UIA_AnimationStyleAttributeId            40000
-#define UIA_BackgroundColorAttributeId           40001
-#define UIA_BulletStyleAttributeId               40002
-#define UIA_CapStyleAttributeId                  40003
-#define UIA_CultureAttributeId                   40004
-#define UIA_FontNameAttributeId                  40005
-#define UIA_FontSizeAttributeId                  40006
-#define UIA_FontWeightAttributeId                40007
-#define UIA_ForegroundColorAttributeId           40008
-#define UIA_HorizontalTextAlignmentAttributeId   40009
-#define UIA_IndentationFirstLineAttributeId      40010
-#define UIA_IndentationLeadingAttributeId        40011
-#define UIA_IndentationTrailingAttributeId       40012
-#define UIA_IsHiddenAttributeId                  40013
-#define UIA_IsItalicAttributeId                  40014
-#define UIA_IsReadOnlyAttributeId                40015
-#define UIA_IsSubscriptAttributeId               40016
-#define UIA_IsSuperscriptAttributeId             40017
-#define UIA_MarginBottomAttributeId              40018
-#define UIA_MarginLeadingAttributeId             40019
-#define UIA_MarginTopAttributeId                 40020
-#define UIA_MarginTrailingAttributeId            40021
-#define UIA_OutlineStylesAttributeId             40022
-#define UIA_OverlineColorAttributeId             40023
-#define UIA_OverlineStyleAttributeId             40024
-#define UIA_StrikethroughColorAttributeId        40025
-#define UIA_StrikethroughStyleAttributeId        40026
-#define UIA_TabsAttributeId                      40027
-#define UIA_TextFlowDirectionsAttributeId        40028
-#define UIA_UnderlineColorAttributeId            40029
-#define UIA_UnderlineStyleAttributeId            40030
-#define UIA_AnnotationTypesAttributeId           40031
-#define UIA_AnnotationObjectsAttributeId         40032
-#define UIA_StyleNameAttributeId                 40033
-#define UIA_StyleIdAttributeId                   40034
-#define UIA_LinkAttributeId                      40035
-#define UIA_IsActiveAttributeId                  40036
-#define UIA_SelectionActiveEndAttributeId        40037
-#define UIA_CaretPositionAttributeId             40038
-#define UIA_CaretBidiModeAttributeId             40039
-#define UIA_LineSpacingAttributeId               40040
-#define UIA_BeforeParagraphSpacingAttributeId    40041
-#define UIA_AfterParagraphSpacingAttributeId     40042
-#define UIA_SayAsInterpretAsAttributeId          40043
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiaclientinterfaces_p.h b/src/gui/accessible/windows/apisupport/uiaclientinterfaces_p.h
deleted file mode 100644
index fb74042bfa..0000000000
--- a/src/gui/accessible/windows/apisupport/uiaclientinterfaces_p.h
+++ /dev/null
@@ -1,230 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIACLIENTINTERFACES_H
-#define UIACLIENTINTERFACES_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <unknwn.h>
-
-#ifndef __IUIAutomationElement_INTERFACE_DEFINED__
-
-struct IUIAutomationCondition;
-struct IUIAutomationCacheRequest;
-struct IUIAutomationElementArray;
-struct IUIAutomationTreeWalker;
-struct IUIAutomationEventHandler;
-struct IUIAutomationPropertyChangedEventHandler;
-struct IUIAutomationStructureChangedEventHandler;
-struct IUIAutomationFocusChangedEventHandler;
-struct IUIAutomationProxyFactory;
-struct IUIAutomationProxyFactoryEntry;
-struct IUIAutomationProxyFactoryMapping;
-#ifndef __IAccessible_FWD_DEFINED__
-#define __IAccessible_FWD_DEFINED__
-struct IAccessible;
-#endif   /* __IAccessible_FWD_DEFINED__ */
-
-#define __IUIAutomationElement_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IUIAutomationElement, 0xd22108aa, 0x8ac5, 0x49a5, 0x83,0x7b, 0x37,0xbb,0xb3,0xd7,0x59,0x1e);
-MIDL_INTERFACE("d22108aa-8ac5-49a5-837b-37bbb3d7591e")
-IUIAutomationElement : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE SetFocus() = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetRuntimeId(__RPC__deref_out_opt SAFEARRAY **runtimeId) = 0;
-    virtual HRESULT STDMETHODCALLTYPE FindFirst(enum TreeScope scope, __RPC__in_opt IUIAutomationCondition *condition, __RPC__deref_out_opt IUIAutomationElement **found) = 0;
-    virtual HRESULT STDMETHODCALLTYPE FindAll(enum TreeScope scope, __RPC__in_opt IUIAutomationCondition *condition, __RPC__deref_out_opt IUIAutomationElementArray **found) = 0;
-    virtual HRESULT STDMETHODCALLTYPE FindFirstBuildCache(enum TreeScope scope, __RPC__in_opt IUIAutomationCondition *condition, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **found) = 0;
-    virtual HRESULT STDMETHODCALLTYPE FindAllBuildCache(enum TreeScope scope, __RPC__in_opt IUIAutomationCondition *condition, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElementArray **found) = 0;
-    virtual HRESULT STDMETHODCALLTYPE BuildUpdatedCache(__RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **updatedElement) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCurrentPropertyValue(PROPERTYID propertyId, __RPC__out VARIANT *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCurrentPropertyValueEx(PROPERTYID propertyId, BOOL ignoreDefaultValue, __RPC__out VARIANT *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCachedPropertyValue(PROPERTYID propertyId, __RPC__out VARIANT *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCachedPropertyValueEx(PROPERTYID propertyId, BOOL ignoreDefaultValue, __RPC__out VARIANT *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCurrentPatternAs(PATTERNID patternId, __RPC__in REFIID riid, __RPC__deref_out_opt void **patternObject) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCachedPatternAs(PATTERNID patternId, __RPC__in REFIID riid, __RPC__deref_out_opt void **patternObject) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCurrentPattern(PATTERNID patternId, __RPC__deref_out_opt IUnknown **patternObject) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCachedPattern(PATTERNID patternId, __RPC__deref_out_opt IUnknown **patternObject) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCachedParent(__RPC__deref_out_opt IUIAutomationElement **parent) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCachedChildren(__RPC__deref_out_opt IUIAutomationElementArray **children) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentProcessId(__RPC__out int *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentControlType(__RPC__out CONTROLTYPEID *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentLocalizedControlType(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentName(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentAcceleratorKey(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentAccessKey(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentHasKeyboardFocus(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentIsKeyboardFocusable(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentIsEnabled(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentAutomationId(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentClassName(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentHelpText(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentCulture(__RPC__out int *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentIsControlElement(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentIsContentElement(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentIsPassword(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentNativeWindowHandle(__RPC__deref_out_opt UIA_HWND *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentItemType(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentIsOffscreen(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentOrientation(__RPC__out enum OrientationType *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentFrameworkId(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentIsRequiredForForm(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentItemStatus(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentBoundingRectangle(__RPC__out RECT *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentLabeledBy(__RPC__deref_out_opt IUIAutomationElement **retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentAriaRole(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentAriaProperties(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentIsDataValidForForm(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentControllerFor(__RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentDescribedBy(__RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentFlowsTo(__RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentProviderDescription(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedProcessId(__RPC__out int *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedControlType(__RPC__out CONTROLTYPEID *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedLocalizedControlType(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedName(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedAcceleratorKey(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedAccessKey(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedHasKeyboardFocus(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedIsKeyboardFocusable(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedIsEnabled(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedAutomationId(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedClassName(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedHelpText(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedCulture(__RPC__out int *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedIsControlElement(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedIsContentElement(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedIsPassword(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedNativeWindowHandle(__RPC__deref_out_opt UIA_HWND *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedItemType(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedIsOffscreen(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedOrientation(__RPC__out enum OrientationType *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedFrameworkId(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedIsRequiredForForm(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedItemStatus(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedBoundingRectangle(__RPC__out RECT *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedLabeledBy(__RPC__deref_out_opt IUIAutomationElement **retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedAriaRole(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedAriaProperties(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedIsDataValidForForm(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedControllerFor(__RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedDescribedBy(__RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedFlowsTo(__RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedProviderDescription(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetClickablePoint(__RPC__out POINT *clickable, __RPC__out BOOL *gotClickable) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IUIAutomationElement, 0xd22108aa, 0x8ac5, 0x49a5, 0x83,0x7b, 0x37,0xbb,0xb3,0xd7,0x59,0x1e)
-#endif
-#endif
-
-
-#ifndef __IUIAutomation_INTERFACE_DEFINED__
-#define __IUIAutomation_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IUIAutomation, 0x30cbe57d, 0xd9d0, 0x452a, 0xab,0x13, 0x7a,0xc5,0xac,0x48,0x25,0xee);
-MIDL_INTERFACE("30cbe57d-d9d0-452a-ab13-7ac5ac4825ee")
-IUIAutomation : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE CompareElements(__RPC__in_opt IUIAutomationElement *el1, __RPC__in_opt IUIAutomationElement *el2, __RPC__out BOOL *areSame) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CompareRuntimeIds(__RPC__in SAFEARRAY * runtimeId1, __RPC__in SAFEARRAY * runtimeId2, __RPC__out BOOL *areSame) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetRootElement(__RPC__deref_out_opt IUIAutomationElement **root) = 0;
-    virtual HRESULT STDMETHODCALLTYPE ElementFromHandle(__RPC__in UIA_HWND hwnd, __RPC__deref_out_opt IUIAutomationElement **element) = 0;
-    virtual HRESULT STDMETHODCALLTYPE ElementFromPoint(POINT pt, __RPC__deref_out_opt IUIAutomationElement **element) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetFocusedElement(__RPC__deref_out_opt IUIAutomationElement **element) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetRootElementBuildCache(__RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **root) = 0;
-    virtual HRESULT STDMETHODCALLTYPE ElementFromHandleBuildCache(__RPC__in UIA_HWND hwnd, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **element) = 0;
-    virtual HRESULT STDMETHODCALLTYPE ElementFromPointBuildCache(POINT pt, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **element) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetFocusedElementBuildCache(__RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **element) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateTreeWalker(__RPC__in_opt IUIAutomationCondition *pCondition, __RPC__deref_out_opt IUIAutomationTreeWalker **walker) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ControlViewWalker(__RPC__deref_out_opt IUIAutomationTreeWalker **walker) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ContentViewWalker(__RPC__deref_out_opt IUIAutomationTreeWalker **walker) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_RawViewWalker(__RPC__deref_out_opt IUIAutomationTreeWalker **walker) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_RawViewCondition(__RPC__deref_out_opt IUIAutomationCondition **condition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ControlViewCondition(__RPC__deref_out_opt IUIAutomationCondition **condition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ContentViewCondition(__RPC__deref_out_opt IUIAutomationCondition **condition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateCacheRequest(__RPC__deref_out_opt IUIAutomationCacheRequest **cacheRequest) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateTrueCondition(__RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateFalseCondition(__RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreatePropertyCondition(PROPERTYID propertyId, VARIANT value, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreatePropertyConditionEx(PROPERTYID propertyId, VARIANT value, enum PropertyConditionFlags flags, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateAndCondition(__RPC__in_opt IUIAutomationCondition *condition1, __RPC__in_opt IUIAutomationCondition *condition2, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateAndConditionFromArray(__RPC__in_opt SAFEARRAY * conditions, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateAndConditionFromNativeArray(__RPC__in_ecount_full(conditionCount) IUIAutomationCondition **conditions, int conditionCount, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateOrCondition(__RPC__in_opt IUIAutomationCondition *condition1, __RPC__in_opt IUIAutomationCondition *condition2, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateOrConditionFromArray(__RPC__in_opt SAFEARRAY * conditions, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateOrConditionFromNativeArray(__RPC__in_ecount_full(conditionCount) IUIAutomationCondition **conditions, int conditionCount, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateNotCondition(__RPC__in_opt IUIAutomationCondition *condition, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE AddAutomationEventHandler(EVENTID eventId, __RPC__in_opt IUIAutomationElement *element, enum TreeScope scope, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__in_opt IUIAutomationEventHandler *handler) = 0;
-    virtual HRESULT STDMETHODCALLTYPE RemoveAutomationEventHandler(EVENTID eventId, __RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationEventHandler *handler) = 0;
-    virtual HRESULT STDMETHODCALLTYPE AddPropertyChangedEventHandlerNativeArray(__RPC__in_opt IUIAutomationElement *element, enum TreeScope scope, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__in_opt IUIAutomationPropertyChangedEventHandler *handler, __RPC__in_ecount_full(propertyCount) PROPERTYID *propertyArray, int propertyCount) = 0;
-    virtual HRESULT STDMETHODCALLTYPE AddPropertyChangedEventHandler(__RPC__in_opt IUIAutomationElement *element, enum TreeScope scope, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__in_opt IUIAutomationPropertyChangedEventHandler *handler, __RPC__in SAFEARRAY * propertyArray) = 0;
-    virtual HRESULT STDMETHODCALLTYPE RemovePropertyChangedEventHandler(__RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationPropertyChangedEventHandler *handler) = 0;
-    virtual HRESULT STDMETHODCALLTYPE AddStructureChangedEventHandler(__RPC__in_opt IUIAutomationElement *element, enum TreeScope scope, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__in_opt IUIAutomationStructureChangedEventHandler *handler) = 0;
-    virtual HRESULT STDMETHODCALLTYPE RemoveStructureChangedEventHandler(__RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationStructureChangedEventHandler *handler) = 0;
-    virtual HRESULT STDMETHODCALLTYPE AddFocusChangedEventHandler(__RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__in_opt IUIAutomationFocusChangedEventHandler *handler) = 0;
-    virtual HRESULT STDMETHODCALLTYPE RemoveFocusChangedEventHandler(__RPC__in_opt IUIAutomationFocusChangedEventHandler *handler) = 0;
-    virtual HRESULT STDMETHODCALLTYPE RemoveAllEventHandlers() = 0;
-    virtual HRESULT STDMETHODCALLTYPE IntNativeArrayToSafeArray(__RPC__in_ecount_full(arrayCount) int *array, int arrayCount, __RPC__deref_out_opt SAFEARRAY **safeArray) = 0;
-    virtual HRESULT STDMETHODCALLTYPE IntSafeArrayToNativeArray(__RPC__in SAFEARRAY * intArray, __RPC__deref_out_ecount_full_opt(*arrayCount) int **array, __RPC__out int *arrayCount) = 0;
-    virtual HRESULT STDMETHODCALLTYPE RectToVariant(RECT rc, __RPC__out VARIANT *var) = 0;
-    virtual HRESULT STDMETHODCALLTYPE VariantToRect(VARIANT var, __RPC__out RECT *rc) = 0;
-    virtual HRESULT STDMETHODCALLTYPE SafeArrayToRectNativeArray(__RPC__in SAFEARRAY * rects, __RPC__deref_out_ecount_full_opt(*rectArrayCount) RECT **rectArray, __RPC__out int *rectArrayCount) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateProxyFactoryEntry(__RPC__in_opt IUIAutomationProxyFactory *factory, __RPC__deref_out_opt IUIAutomationProxyFactoryEntry **factoryEntry) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ProxyFactoryMapping(__RPC__deref_out_opt IUIAutomationProxyFactoryMapping **factoryMapping) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetPropertyProgrammaticName(PROPERTYID property, __RPC__deref_out_opt BSTR *name) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetPatternProgrammaticName(PATTERNID pattern, __RPC__deref_out_opt BSTR *name) = 0;
-    virtual HRESULT STDMETHODCALLTYPE PollForPotentialSupportedPatterns(__RPC__in_opt IUIAutomationElement *pElement, __RPC__deref_out_opt SAFEARRAY **patternIds, __RPC__deref_out_opt SAFEARRAY **patternNames) = 0;
-    virtual HRESULT STDMETHODCALLTYPE PollForPotentialSupportedProperties(__RPC__in_opt IUIAutomationElement *pElement, __RPC__deref_out_opt SAFEARRAY **propertyIds, __RPC__deref_out_opt SAFEARRAY **propertyNames) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CheckNotSupported(VARIANT value, __RPC__out BOOL *isNotSupported) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ReservedNotSupportedValue(__RPC__deref_out_opt IUnknown **notSupportedValue) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ReservedMixedAttributeValue(__RPC__deref_out_opt IUnknown **mixedAttributeValue) = 0;
-    virtual HRESULT STDMETHODCALLTYPE ElementFromIAccessible(__RPC__in_opt IAccessible *accessible, int childId, __RPC__deref_out_opt IUIAutomationElement **element) = 0;
-    virtual HRESULT STDMETHODCALLTYPE ElementFromIAccessibleBuildCache(__RPC__in_opt IAccessible *accessible, int childId, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **element) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IUIAutomation, 0x30cbe57d, 0xd9d0, 0x452a, 0xab,0x13, 0x7a,0xc5,0xac,0x48,0x25,0xee)
-#endif
-#endif
-
-
-#ifndef __IUIAutomationTreeWalker_INTERFACE_DEFINED__
-#define __IUIAutomationTreeWalker_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IUIAutomationTreeWalker, 0x4042c624, 0x389c, 0x4afc, 0xa6,0x30, 0x9d,0xf8,0x54,0xa5,0x41,0xfc);
-MIDL_INTERFACE("4042c624-389c-4afc-a630-9df854a541fc")
-IUIAutomationTreeWalker : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE GetParentElement(__RPC__in_opt IUIAutomationElement *element, __RPC__deref_out_opt IUIAutomationElement **parent) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetFirstChildElement(__RPC__in_opt IUIAutomationElement *element, __RPC__deref_out_opt IUIAutomationElement **first) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetLastChildElement(__RPC__in_opt IUIAutomationElement *element, __RPC__deref_out_opt IUIAutomationElement **last) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetNextSiblingElement(__RPC__in_opt IUIAutomationElement *element, __RPC__deref_out_opt IUIAutomationElement **next) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetPreviousSiblingElement(__RPC__in_opt IUIAutomationElement *element, __RPC__deref_out_opt IUIAutomationElement **previous) = 0;
-    virtual HRESULT STDMETHODCALLTYPE NormalizeElement(__RPC__in_opt IUIAutomationElement *element, __RPC__deref_out_opt IUIAutomationElement **normalized) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetParentElementBuildCache(__RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **parent) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetFirstChildElementBuildCache(__RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **first) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetLastChildElementBuildCache(__RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **last) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetNextSiblingElementBuildCache(__RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **next) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetPreviousSiblingElementBuildCache(__RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **previous) = 0;
-    virtual HRESULT STDMETHODCALLTYPE NormalizeElementBuildCache(__RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **normalized) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_Condition(__RPC__deref_out_opt IUIAutomationCondition **condition) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IUIAutomationTreeWalker, 0x4042c624, 0x389c, 0x4afc, 0xa6,0x30, 0x9d,0xf8,0x54,0xa5,0x41,0xfc)
-#endif
-#endif
-
-DEFINE_GUID(CLSID_CUIAutomation, 0xff48dba4, 0x60ef, 0x4201, 0xaa,0x87, 0x54,0x10,0x3e,0xef,0x59,0x4e);
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiacontroltypeids_p.h b/src/gui/accessible/windows/apisupport/uiacontroltypeids_p.h
deleted file mode 100644
index 21d8080bc2..0000000000
--- a/src/gui/accessible/windows/apisupport/uiacontroltypeids_p.h
+++ /dev/null
@@ -1,60 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIACONTROLTYPEIDS_H
-#define UIACONTROLTYPEIDS_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#define UIA_ButtonControlTypeId         50000
-#define UIA_CalendarControlTypeId       50001
-#define UIA_CheckBoxControlTypeId       50002
-#define UIA_ComboBoxControlTypeId       50003
-#define UIA_EditControlTypeId           50004
-#define UIA_HyperlinkControlTypeId      50005
-#define UIA_ImageControlTypeId          50006
-#define UIA_ListItemControlTypeId       50007
-#define UIA_ListControlTypeId           50008
-#define UIA_MenuControlTypeId           50009
-#define UIA_MenuBarControlTypeId        50010
-#define UIA_MenuItemControlTypeId       50011
-#define UIA_ProgressBarControlTypeId    50012
-#define UIA_RadioButtonControlTypeId    50013
-#define UIA_ScrollBarControlTypeId      50014
-#define UIA_SliderControlTypeId         50015
-#define UIA_SpinnerControlTypeId        50016
-#define UIA_StatusBarControlTypeId      50017
-#define UIA_TabControlTypeId            50018
-#define UIA_TabItemControlTypeId        50019
-#define UIA_TextControlTypeId           50020
-#define UIA_ToolBarControlTypeId        50021
-#define UIA_ToolTipControlTypeId        50022
-#define UIA_TreeControlTypeId           50023
-#define UIA_TreeItemControlTypeId       50024
-#define UIA_CustomControlTypeId         50025
-#define UIA_GroupControlTypeId          50026
-#define UIA_ThumbControlTypeId          50027
-#define UIA_DataGridControlTypeId       50028
-#define UIA_DataItemControlTypeId       50029
-#define UIA_DocumentControlTypeId       50030
-#define UIA_SplitButtonControlTypeId    50031
-#define UIA_WindowControlTypeId         50032
-#define UIA_PaneControlTypeId           50033
-#define UIA_HeaderControlTypeId         50034
-#define UIA_HeaderItemControlTypeId     50035
-#define UIA_TableControlTypeId          50036
-#define UIA_TitleBarControlTypeId       50037
-#define UIA_SeparatorControlTypeId      50038
-#define UIA_SemanticZoomControlTypeId   50039
-#define UIA_AppBarControlTypeId         50040
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiaerrorids_p.h b/src/gui/accessible/windows/apisupport/uiaerrorids_p.h
deleted file mode 100644
index b965fe5c30..0000000000
--- a/src/gui/accessible/windows/apisupport/uiaerrorids_p.h
+++ /dev/null
@@ -1,26 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIAERRORIDS_H
-#define UIAERRORIDS_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#define UIA_E_ELEMENTNOTENABLED      0x80040200
-#define UIA_E_ELEMENTNOTAVAILABLE    0x80040201
-#define UIA_E_NOCLICKABLEPOINT       0x80040202
-#define UIA_E_PROXYASSEMBLYNOTLOADED 0x80040203
-#define UIA_E_NOTSUPPORTED           0x80040204
-#define UIA_E_INVALIDOPERATION       0x80131509
-#define UIA_E_TIMEOUT                0x80131505
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiaeventids_p.h b/src/gui/accessible/windows/apisupport/uiaeventids_p.h
deleted file mode 100644
index 7ac6d85ec5..0000000000
--- a/src/gui/accessible/windows/apisupport/uiaeventids_p.h
+++ /dev/null
@@ -1,54 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIAEVENTIDS_H
-#define UIAEVENTIDS_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#define UIA_ToolTipOpenedEventId                                20000
-#define UIA_ToolTipClosedEventId                                20001
-#define UIA_StructureChangedEventId                             20002
-#define UIA_MenuOpenedEventId                                   20003
-#define UIA_AutomationPropertyChangedEventId                    20004
-#define UIA_AutomationFocusChangedEventId                       20005
-#define UIA_AsyncContentLoadedEventId                           20006
-#define UIA_MenuClosedEventId                                   20007
-#define UIA_LayoutInvalidatedEventId                            20008
-#define UIA_Invoke_InvokedEventId                               20009
-#define UIA_SelectionItem_ElementAddedToSelectionEventId        20010
-#define UIA_SelectionItem_ElementRemovedFromSelectionEventId    20011
-#define UIA_SelectionItem_ElementSelectedEventId                20012
-#define UIA_Selection_InvalidatedEventId                        20013
-#define UIA_Text_TextSelectionChangedEventId                    20014
-#define UIA_Text_TextChangedEventId                             20015
-#define UIA_Window_WindowOpenedEventId                          20016
-#define UIA_Window_WindowClosedEventId                          20017
-#define UIA_MenuModeStartEventId                                20018
-#define UIA_MenuModeEndEventId                                  20019
-#define UIA_InputReachedTargetEventId                           20020
-#define UIA_InputReachedOtherElementEventId                     20021
-#define UIA_InputDiscardedEventId                               20022
-#define UIA_SystemAlertEventId                                  20023
-#define UIA_LiveRegionChangedEventId                            20024
-#define UIA_HostedFragmentRootsInvalidatedEventId               20025
-#define UIA_Drag_DragStartEventId                               20026
-#define UIA_Drag_DragCancelEventId                              20027
-#define UIA_Drag_DragCompleteEventId                            20028
-#define UIA_DropTarget_DragEnterEventId                         20029
-#define UIA_DropTarget_DragLeaveEventId                         20030
-#define UIA_DropTarget_DroppedEventId                           20031
-#define UIA_TextEdit_TextChangedEventId                         20032
-#define UIA_TextEdit_ConversionTargetChangedEventId             20033
-#define UIA_ChangesEventId                                      20034
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiageneralids_p.h b/src/gui/accessible/windows/apisupport/uiageneralids_p.h
deleted file mode 100644
index a6fdeceee3..0000000000
--- a/src/gui/accessible/windows/apisupport/uiageneralids_p.h
+++ /dev/null
@@ -1,21 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIAGENERALIDS_H
-#define UIAGENERALIDS_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#define UiaAppendRuntimeId       3
-#define UiaRootObjectId        -25
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiapatternids_p.h b/src/gui/accessible/windows/apisupport/uiapatternids_p.h
deleted file mode 100644
index 0ff463cd36..0000000000
--- a/src/gui/accessible/windows/apisupport/uiapatternids_p.h
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIAPATTERNIDS_H
-#define UIAPATTERNIDS_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#define UIA_InvokePatternId             10000
-#define UIA_SelectionPatternId          10001
-#define UIA_ValuePatternId              10002
-#define UIA_RangeValuePatternId         10003
-#define UIA_ScrollPatternId             10004
-#define UIA_ExpandCollapsePatternId     10005
-#define UIA_GridPatternId               10006
-#define UIA_GridItemPatternId           10007
-#define UIA_MultipleViewPatternId       10008
-#define UIA_WindowPatternId             10009
-#define UIA_SelectionItemPatternId      10010
-#define UIA_DockPatternId               10011
-#define UIA_TablePatternId              10012
-#define UIA_TableItemPatternId          10013
-#define UIA_TextPatternId               10014
-#define UIA_TogglePatternId             10015
-#define UIA_TransformPatternId          10016
-#define UIA_ScrollItemPatternId         10017
-#define UIA_LegacyIAccessiblePatternId  10018
-#define UIA_ItemContainerPatternId      10019
-#define UIA_VirtualizedItemPatternId    10020
-#define UIA_SynchronizedInputPatternId  10021
-#define UIA_ObjectModelPatternId        10022
-#define UIA_AnnotationPatternId         10023
-#define UIA_TextPattern2Id              10024
-#define UIA_StylesPatternId             10025
-#define UIA_SpreadsheetPatternId        10026
-#define UIA_SpreadsheetItemPatternId    10027
-#define UIA_TransformPattern2Id         10028
-#define UIA_TextChildPatternId          10029
-#define UIA_DragPatternId               10030
-#define UIA_DropTargetPatternId         10031
-#define UIA_TextEditPatternId           10032
-#define UIA_CustomNavigationPatternId   10033
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiapropertyids_p.h b/src/gui/accessible/windows/apisupport/uiapropertyids_p.h
deleted file mode 100644
index 77fc454e0f..0000000000
--- a/src/gui/accessible/windows/apisupport/uiapropertyids_p.h
+++ /dev/null
@@ -1,188 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIAPROPERTYIDS_H
-#define UIAPROPERTYIDS_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#define UIA_RuntimeIdPropertyId                                30000
-#define UIA_BoundingRectanglePropertyId                        30001
-#define UIA_ProcessIdPropertyId                                30002
-#define UIA_ControlTypePropertyId                              30003
-#define UIA_LocalizedControlTypePropertyId                     30004
-#define UIA_NamePropertyId                                     30005
-#define UIA_AcceleratorKeyPropertyId                           30006
-#define UIA_AccessKeyPropertyId                                30007
-#define UIA_HasKeyboardFocusPropertyId                         30008
-#define UIA_IsKeyboardFocusablePropertyId                      30009
-#define UIA_IsEnabledPropertyId                                30010
-#define UIA_AutomationIdPropertyId                             30011
-#define UIA_ClassNamePropertyId                                30012
-#define UIA_HelpTextPropertyId                                 30013
-#define UIA_ClickablePointPropertyId                           30014
-#define UIA_CulturePropertyId                                  30015
-#define UIA_IsControlElementPropertyId                         30016
-#define UIA_IsContentElementPropertyId                         30017
-#define UIA_LabeledByPropertyId                                30018
-#define UIA_IsPasswordPropertyId                               30019
-#define UIA_NativeWindowHandlePropertyId                       30020
-#define UIA_ItemTypePropertyId                                 30021
-#define UIA_IsOffscreenPropertyId                              30022
-#define UIA_OrientationPropertyId                              30023
-#define UIA_FrameworkIdPropertyId                              30024
-#define UIA_IsRequiredForFormPropertyId                        30025
-#define UIA_ItemStatusPropertyId                               30026
-#define UIA_IsDockPatternAvailablePropertyId                   30027
-#define UIA_IsExpandCollapsePatternAvailablePropertyId         30028
-#define UIA_IsGridItemPatternAvailablePropertyId               30029
-#define UIA_IsGridPatternAvailablePropertyId                   30030
-#define UIA_IsInvokePatternAvailablePropertyId                 30031
-#define UIA_IsMultipleViewPatternAvailablePropertyId           30032
-#define UIA_IsRangeValuePatternAvailablePropertyId             30033
-#define UIA_IsScrollPatternAvailablePropertyId                 30034
-#define UIA_IsScrollItemPatternAvailablePropertyId             30035
-#define UIA_IsSelectionItemPatternAvailablePropertyId          30036
-#define UIA_IsSelectionPatternAvailablePropertyId              30037
-#define UIA_IsTablePatternAvailablePropertyId                  30038
-#define UIA_IsTableItemPatternAvailablePropertyId              30039
-#define UIA_IsTextPatternAvailablePropertyId                   30040
-#define UIA_IsTogglePatternAvailablePropertyId                 30041
-#define UIA_IsTransformPatternAvailablePropertyId              30042
-#define UIA_IsValuePatternAvailablePropertyId                  30043
-#define UIA_IsWindowPatternAvailablePropertyId                 30044
-#define UIA_ValueValuePropertyId                               30045
-#define UIA_ValueIsReadOnlyPropertyId                          30046
-#define UIA_RangeValueValuePropertyId                          30047
-#define UIA_RangeValueIsReadOnlyPropertyId                     30048
-#define UIA_RangeValueMinimumPropertyId                        30049
-#define UIA_RangeValueMaximumPropertyId                        30050
-#define UIA_RangeValueLargeChangePropertyId                    30051
-#define UIA_RangeValueSmallChangePropertyId                    30052
-#define UIA_ScrollHorizontalScrollPercentPropertyId            30053
-#define UIA_ScrollHorizontalViewSizePropertyId                 30054
-#define UIA_ScrollVerticalScrollPercentPropertyId              30055
-#define UIA_ScrollVerticalViewSizePropertyId                   30056
-#define UIA_ScrollHorizontallyScrollablePropertyId             30057
-#define UIA_ScrollVerticallyScrollablePropertyId               30058
-#define UIA_SelectionSelectionPropertyId                       30059
-#define UIA_SelectionCanSelectMultiplePropertyId               30060
-#define UIA_SelectionIsSelectionRequiredPropertyId             30061
-#define UIA_GridRowCountPropertyId                             30062
-#define UIA_GridColumnCountPropertyId                          30063
-#define UIA_GridItemRowPropertyId                              30064
-#define UIA_GridItemColumnPropertyId                           30065
-#define UIA_GridItemRowSpanPropertyId                          30066
-#define UIA_GridItemColumnSpanPropertyId                       30067
-#define UIA_GridItemContainingGridPropertyId                   30068
-#define UIA_DockDockPositionPropertyId                         30069
-#define UIA_ExpandCollapseExpandCollapseStatePropertyId        30070
-#define UIA_MultipleViewCurrentViewPropertyId                  30071
-#define UIA_MultipleViewSupportedViewsPropertyId               30072
-#define UIA_WindowCanMaximizePropertyId                        30073
-#define UIA_WindowCanMinimizePropertyId                        30074
-#define UIA_WindowWindowVisualStatePropertyId                  30075
-#define UIA_WindowWindowInteractionStatePropertyId             30076
-#define UIA_WindowIsModalPropertyId                            30077
-#define UIA_WindowIsTopmostPropertyId                          30078
-#define UIA_SelectionItemIsSelectedPropertyId                  30079
-#define UIA_SelectionItemSelectionContainerPropertyId          30080
-#define UIA_TableRowHeadersPropertyId                          30081
-#define UIA_TableColumnHeadersPropertyId                       30082
-#define UIA_TableRowOrColumnMajorPropertyId                    30083
-#define UIA_TableItemRowHeaderItemsPropertyId                  30084
-#define UIA_TableItemColumnHeaderItemsPropertyId               30085
-#define UIA_ToggleToggleStatePropertyId                        30086
-#define UIA_TransformCanMovePropertyId                         30087
-#define UIA_TransformCanResizePropertyId                       30088
-#define UIA_TransformCanRotatePropertyId                       30089
-#define UIA_IsLegacyIAccessiblePatternAvailablePropertyId      30090
-#define UIA_LegacyIAccessibleChildIdPropertyId                 30091
-#define UIA_LegacyIAccessibleNamePropertyId                    30092
-#define UIA_LegacyIAccessibleValuePropertyId                   30093
-#define UIA_LegacyIAccessibleDescriptionPropertyId             30094
-#define UIA_LegacyIAccessibleRolePropertyId                    30095
-#define UIA_LegacyIAccessibleStatePropertyId                   30096
-#define UIA_LegacyIAccessibleHelpPropertyId                    30097
-#define UIA_LegacyIAccessibleKeyboardShortcutPropertyId        30098
-#define UIA_LegacyIAccessibleSelectionPropertyId               30099
-#define UIA_LegacyIAccessibleDefaultActionPropertyId           30100
-#define UIA_AriaRolePropertyId                                 30101
-#define UIA_AriaPropertiesPropertyId                           30102
-#define UIA_IsDataValidForFormPropertyId                       30103
-#define UIA_ControllerForPropertyId                            30104
-#define UIA_DescribedByPropertyId                              30105
-#define UIA_FlowsToPropertyId                                  30106
-#define UIA_ProviderDescriptionPropertyId                      30107
-#define UIA_IsItemContainerPatternAvailablePropertyId          30108
-#define UIA_IsVirtualizedItemPatternAvailablePropertyId        30109
-#define UIA_IsSynchronizedInputPatternAvailablePropertyId      30110
-#define UIA_OptimizeForVisualContentPropertyId                 30111
-#define UIA_IsObjectModelPatternAvailablePropertyId            30112
-#define UIA_AnnotationAnnotationTypeIdPropertyId               30113
-#define UIA_AnnotationAnnotationTypeNamePropertyId             30114
-#define UIA_AnnotationAuthorPropertyId                         30115
-#define UIA_AnnotationDateTimePropertyId                       30116
-#define UIA_AnnotationTargetPropertyId                         30117
-#define UIA_IsAnnotationPatternAvailablePropertyId             30118
-#define UIA_IsTextPattern2AvailablePropertyId                  30119
-#define UIA_StylesStyleIdPropertyId                            30120
-#define UIA_StylesStyleNamePropertyId                          30121
-#define UIA_StylesFillColorPropertyId                          30122
-#define UIA_StylesFillPatternStylePropertyId                   30123
-#define UIA_StylesShapePropertyId                              30124
-#define UIA_StylesFillPatternColorPropertyId                   30125
-#define UIA_StylesExtendedPropertiesPropertyId                 30126
-#define UIA_IsStylesPatternAvailablePropertyId                 30127
-#define UIA_IsSpreadsheetPatternAvailablePropertyId            30128
-#define UIA_SpreadsheetItemFormulaPropertyId                   30129
-#define UIA_SpreadsheetItemAnnotationObjectsPropertyId         30130
-#define UIA_SpreadsheetItemAnnotationTypesPropertyId           30131
-#define UIA_IsSpreadsheetItemPatternAvailablePropertyId        30132
-#define UIA_Transform2CanZoomPropertyId                        30133
-#define UIA_IsTransformPattern2AvailablePropertyId             30134
-#define UIA_LiveSettingPropertyId                              30135
-#define UIA_IsTextChildPatternAvailablePropertyId              30136
-#define UIA_IsDragPatternAvailablePropertyId                   30137
-#define UIA_DragIsGrabbedPropertyId                            30138
-#define UIA_DragDropEffectPropertyId                           30139
-#define UIA_DragDropEffectsPropertyId                          30140
-#define UIA_IsDropTargetPatternAvailablePropertyId             30141
-#define UIA_DropTargetDropTargetEffectPropertyId               30142
-#define UIA_DropTargetDropTargetEffectsPropertyId              30143
-#define UIA_DragGrabbedItemsPropertyId                         30144
-#define UIA_Transform2ZoomLevelPropertyId                      30145
-#define UIA_Transform2ZoomMinimumPropertyId                    30146
-#define UIA_Transform2ZoomMaximumPropertyId                    30147
-#define UIA_FlowsFromPropertyId                                30148
-#define UIA_IsTextEditPatternAvailablePropertyId               30149
-#define UIA_IsPeripheralPropertyId                             30150
-#define UIA_IsCustomNavigationPatternAvailablePropertyId       30151
-#define UIA_PositionInSetPropertyId                            30152
-#define UIA_SizeOfSetPropertyId                                30153
-#define UIA_LevelPropertyId                                    30154
-#define UIA_AnnotationTypesPropertyId                          30155
-#define UIA_AnnotationObjectsPropertyId                        30156
-#define UIA_LandmarkTypePropertyId                             30157
-#define UIA_LocalizedLandmarkTypePropertyId                    30158
-#define UIA_FullDescriptionPropertyId                          30159
-#define UIA_FillColorPropertyId                                30160
-#define UIA_OutlineColorPropertyId                             30161
-#define UIA_FillTypePropertyId                                 30162
-#define UIA_VisualEffectsPropertyId                            30163
-#define UIA_OutlineThicknessPropertyId                         30164
-#define UIA_CenterPointPropertyId                              30165
-#define UIA_RotationPropertyId                                 30166
-#define UIA_SizePropertyId                                     30167
-#define UIA_IsDialogPropertyId                                 30174
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiaserverinterfaces_p.h b/src/gui/accessible/windows/apisupport/uiaserverinterfaces_p.h
deleted file mode 100644
index 6cf15cacb0..0000000000
--- a/src/gui/accessible/windows/apisupport/uiaserverinterfaces_p.h
+++ /dev/null
@@ -1,367 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIASERVERINTERFACES_H
-#define UIASERVERINTERFACES_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <unknwn.h>
-
-#ifndef __IRawElementProviderSimple_INTERFACE_DEFINED__
-#define __IRawElementProviderSimple_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IRawElementProviderSimple, 0xd6dd68d1, 0x86fd, 0x4332, 0x86,0x66, 0x9a,0xbe,0xde,0xa2,0xd2,0x4c);
-MIDL_INTERFACE("d6dd68d1-86fd-4332-8666-9abedea2d24c")
-IRawElementProviderSimple : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE get_ProviderOptions(__RPC__out enum ProviderOptions *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetPatternProvider(PATTERNID patternId, __RPC__deref_out_opt IUnknown **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetPropertyValue(PROPERTYID propertyId, __RPC__out VARIANT *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_HostRawElementProvider(__RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IRawElementProviderSimple, 0xd6dd68d1, 0x86fd, 0x4332, 0x86,0x66, 0x9a,0xbe,0xde,0xa2,0xd2,0x4c)
-#endif
-#endif
-
-
-#ifndef __IRawElementProviderFragmentRoot_FWD_DEFINED__
-#define __IRawElementProviderFragmentRoot_FWD_DEFINED__
-typedef interface IRawElementProviderFragmentRoot IRawElementProviderFragmentRoot;
-#endif
-
-
-#ifndef __IRawElementProviderFragment_FWD_DEFINED__
-#define __IRawElementProviderFragment_FWD_DEFINED__
-typedef interface IRawElementProviderFragment IRawElementProviderFragment;
-#endif
-
-
-#ifndef __IRawElementProviderFragment_INTERFACE_DEFINED__
-#define __IRawElementProviderFragment_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IRawElementProviderFragment, 0xf7063da8, 0x8359, 0x439c, 0x92,0x97, 0xbb,0xc5,0x29,0x9a,0x7d,0x87);
-MIDL_INTERFACE("f7063da8-8359-439c-9297-bbc5299a7d87")
-IRawElementProviderFragment : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE Navigate(enum NavigateDirection direction, __RPC__deref_out_opt IRawElementProviderFragment **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetRuntimeId(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_BoundingRectangle(__RPC__out struct UiaRect *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetEmbeddedFragmentRoots(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE SetFocus() = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_FragmentRoot(__RPC__deref_out_opt IRawElementProviderFragmentRoot **pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IRawElementProviderFragment, 0xf7063da8, 0x8359, 0x439c, 0x92,0x97, 0xbb,0xc5,0x29,0x9a,0x7d,0x87)
-#endif
-#endif
-
-
-#ifndef __IRawElementProviderFragmentRoot_INTERFACE_DEFINED__
-#define __IRawElementProviderFragmentRoot_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IRawElementProviderFragmentRoot, 0x620ce2a5, 0xab8f, 0x40a9, 0x86,0xcb, 0xde,0x3c,0x75,0x59,0x9b,0x58);
-MIDL_INTERFACE("620ce2a5-ab8f-40a9-86cb-de3c75599b58")
-IRawElementProviderFragmentRoot : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE ElementProviderFromPoint(double x, double y, __RPC__deref_out_opt IRawElementProviderFragment **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetFocus(__RPC__deref_out_opt IRawElementProviderFragment **pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IRawElementProviderFragmentRoot, 0x620ce2a5, 0xab8f, 0x40a9, 0x86,0xcb, 0xde,0x3c,0x75,0x59,0x9b,0x58)
-#endif
-#endif
-
-
-#ifndef __IValueProvider_INTERFACE_DEFINED__
-#define __IValueProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IValueProvider, 0xc7935180, 0x6fb3, 0x4201, 0xb1,0x74, 0x7d,0xf7,0x3a,0xdb,0xf6,0x4a);
-MIDL_INTERFACE("c7935180-6fb3-4201-b174-7df73adbf64a")
-IValueProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE SetValue(__RPC__in LPCWSTR val) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_Value(__RPC__deref_out_opt BSTR *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_IsReadOnly(__RPC__out BOOL *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IValueProvider, 0xc7935180, 0x6fb3, 0x4201, 0xb1,0x74, 0x7d,0xf7,0x3a,0xdb,0xf6,0x4a)
-#endif
-#endif
-
-
-#ifndef __IRangeValueProvider_INTERFACE_DEFINED__
-#define __IRangeValueProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IRangeValueProvider, 0x36dc7aef, 0x33e6, 0x4691, 0xaf,0xe1, 0x2b,0xe7,0x27,0x4b,0x3d,0x33);
-MIDL_INTERFACE("36dc7aef-33e6-4691-afe1-2be7274b3d33")
-IRangeValueProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE SetValue(double val) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_Value(__RPC__out double *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_IsReadOnly(__RPC__out BOOL *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_Maximum(__RPC__out double *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_Minimum(__RPC__out double *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_LargeChange(__RPC__out double *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_SmallChange(__RPC__out double *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IRangeValueProvider, 0x36dc7aef, 0x33e6, 0x4691, 0xaf,0xe1, 0x2b,0xe7,0x27,0x4b,0x3d,0x33)
-#endif
-#endif
-
-
-#ifndef __ITextRangeProvider_INTERFACE_DEFINED__
-#define __ITextRangeProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_ITextRangeProvider, 0x5347ad7b, 0xc355, 0x46f8, 0xaf,0xf5, 0x90,0x90,0x33,0x58,0x2f,0x63);
-MIDL_INTERFACE("5347ad7b-c355-46f8-aff5-909033582f63")
-ITextRangeProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE Clone(__RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE Compare(__RPC__in_opt ITextRangeProvider *range, __RPC__out BOOL *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CompareEndpoints(enum TextPatternRangeEndpoint endpoint, __RPC__in_opt ITextRangeProvider *targetRange, enum TextPatternRangeEndpoint targetEndpoint, __RPC__out int *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE ExpandToEnclosingUnit(enum TextUnit unit) = 0;
-    virtual HRESULT STDMETHODCALLTYPE FindAttribute(TEXTATTRIBUTEID attributeId, VARIANT val, BOOL backward, __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE FindText(__RPC__in BSTR text, BOOL backward, BOOL ignoreCase, __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetAttributeValue(TEXTATTRIBUTEID attributeId, __RPC__out VARIANT *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetBoundingRectangles(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetEnclosingElement(__RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetText(int maxLength, __RPC__deref_out_opt BSTR *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE Move(enum TextUnit unit, int count, __RPC__out int *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE MoveEndpointByUnit(enum TextPatternRangeEndpoint endpoint, enum TextUnit unit, int count, __RPC__out int *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE MoveEndpointByRange(enum TextPatternRangeEndpoint endpoint, __RPC__in_opt ITextRangeProvider *targetRange, enum TextPatternRangeEndpoint targetEndpoint) = 0;
-    virtual HRESULT STDMETHODCALLTYPE Select() = 0;
-    virtual HRESULT STDMETHODCALLTYPE AddToSelection() = 0;
-    virtual HRESULT STDMETHODCALLTYPE RemoveFromSelection() = 0;
-    virtual HRESULT STDMETHODCALLTYPE ScrollIntoView(BOOL alignToTop) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetChildren(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(ITextRangeProvider, 0x5347ad7b, 0xc355, 0x46f8, 0xaf,0xf5, 0x90,0x90,0x33,0x58,0x2f,0x63)
-#endif
-#endif
-
-
-#ifndef __ITextProvider_INTERFACE_DEFINED__
-#define __ITextProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_ITextProvider, 0x3589c92c, 0x63f3, 0x4367, 0x99,0xbb, 0xad,0xa6,0x53,0xb7,0x7c,0xf2);
-MIDL_INTERFACE("3589c92c-63f3-4367-99bb-ada653b77cf2")
-ITextProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE GetSelection(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetVisibleRanges(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE RangeFromChild(__RPC__in_opt IRawElementProviderSimple *childElement, __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE RangeFromPoint(struct UiaPoint point, __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_DocumentRange(__RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_SupportedTextSelection(__RPC__out enum SupportedTextSelection *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(ITextProvider, 0x3589c92c, 0x63f3, 0x4367, 0x99,0xbb, 0xad,0xa6,0x53,0xb7,0x7c,0xf2)
-#endif
-#endif
-
-
-#ifndef __ITextProvider2_INTERFACE_DEFINED__
-#define __ITextProvider2_INTERFACE_DEFINED__
-DEFINE_GUID(IID_ITextProvider2, 0x0dc5e6ed, 0x3e16, 0x4bf1, 0x8f,0x9a, 0xa9,0x79,0x87,0x8b,0xc1,0x95);
-MIDL_INTERFACE("0dc5e6ed-3e16-4bf1-8f9a-a979878bc195")
-ITextProvider2 : public ITextProvider
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE RangeFromAnnotation(__RPC__in_opt IRawElementProviderSimple *annotationElement, __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCaretRange(__RPC__out BOOL *isActive, __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(ITextProvider2, 0x0dc5e6ed, 0x3e16, 0x4bf1, 0x8f,0x9a, 0xa9,0x79,0x87,0x8b,0xc1,0x95)
-#endif
-#endif
-
-
-#ifndef __IToggleProvider_INTERFACE_DEFINED__
-#define __IToggleProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IToggleProvider, 0x56d00bd0, 0xc4f4, 0x433c, 0xa8,0x36, 0x1a,0x52,0xa5,0x7e,0x08,0x92);
-MIDL_INTERFACE("56d00bd0-c4f4-433c-a836-1a52a57e0892")
-IToggleProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE Toggle() = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ToggleState(__RPC__out enum ToggleState *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IToggleProvider, 0x56d00bd0, 0xc4f4, 0x433c, 0xa8,0x36, 0x1a,0x52,0xa5,0x7e,0x08,0x92)
-#endif
-#endif
-
-
-#ifndef __IInvokeProvider_INTERFACE_DEFINED__
-#define __IInvokeProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IInvokeProvider, 0x54fcb24b, 0xe18e, 0x47a2, 0xb4,0xd3, 0xec,0xcb,0xe7,0x75,0x99,0xa2);
-MIDL_INTERFACE("54fcb24b-e18e-47a2-b4d3-eccbe77599a2")
-IInvokeProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE Invoke() = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IInvokeProvider, 0x54fcb24b, 0xe18e, 0x47a2, 0xb4,0xd3, 0xec,0xcb,0xe7,0x75,0x99,0xa2)
-#endif
-#endif
-
-
-#ifndef __ISelectionProvider_INTERFACE_DEFINED__
-#define __ISelectionProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_ISelectionProvider, 0xfb8b03af, 0x3bdf, 0x48d4, 0xbd,0x36, 0x1a,0x65,0x79,0x3b,0xe1,0x68);
-MIDL_INTERFACE("fb8b03af-3bdf-48d4-bd36-1a65793be168")
-ISelectionProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE GetSelection(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CanSelectMultiple(__RPC__out BOOL *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_IsSelectionRequired(__RPC__out BOOL *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(ISelectionProvider, 0xfb8b03af, 0x3bdf, 0x48d4, 0xbd,0x36, 0x1a,0x65,0x79,0x3b,0xe1,0x68)
-#endif
-#endif
-
-
-#ifndef __ISelectionItemProvider_INTERFACE_DEFINED__
-#define __ISelectionItemProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_ISelectionItemProvider, 0x2acad808, 0xb2d4, 0x452d, 0xa4,0x07, 0x91,0xff,0x1a,0xd1,0x67,0xb2);
-MIDL_INTERFACE("2acad808-b2d4-452d-a407-91ff1ad167b2")
-ISelectionItemProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE Select() = 0;
-    virtual HRESULT STDMETHODCALLTYPE AddToSelection() = 0;
-    virtual HRESULT STDMETHODCALLTYPE RemoveFromSelection() = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_IsSelected(__RPC__out BOOL *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_SelectionContainer(__RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(ISelectionItemProvider, 0x2acad808, 0xb2d4, 0x452d, 0xa4,0x07, 0x91,0xff,0x1a,0xd1,0x67,0xb2)
-#endif
-#endif
-
-
-#ifndef __ITableProvider_INTERFACE_DEFINED__
-#define __ITableProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_ITableProvider, 0x9c860395, 0x97b3, 0x490a, 0xb5,0x2a, 0x85,0x8c,0xc2,0x2a,0xf1,0x66);
-MIDL_INTERFACE("9c860395-97b3-490a-b52a-858cc22af166")
-ITableProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE GetRowHeaders(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetColumnHeaders(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_RowOrColumnMajor(__RPC__out enum RowOrColumnMajor *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(ITableProvider, 0x9c860395, 0x97b3, 0x490a, 0xb5,0x2a, 0x85,0x8c,0xc2,0x2a,0xf1,0x66)
-#endif
-#endif
-
-
-#ifndef __ITableItemProvider_INTERFACE_DEFINED__
-#define __ITableItemProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_ITableItemProvider, 0xb9734fa6, 0x771f, 0x4d78, 0x9c,0x90, 0x25,0x17,0x99,0x93,0x49,0xcd);
-MIDL_INTERFACE("b9734fa6-771f-4d78-9c90-2517999349cd")
-ITableItemProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE GetRowHeaderItems(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetColumnHeaderItems(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(ITableItemProvider, 0xb9734fa6, 0x771f, 0x4d78, 0x9c,0x90, 0x25,0x17,0x99,0x93,0x49,0xcd)
-#endif
-#endif
-
-
-#ifndef __IGridProvider_INTERFACE_DEFINED__
-#define __IGridProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IGridProvider, 0xb17d6187, 0x0907, 0x464b, 0xa1,0x68, 0x0e,0xf1,0x7a,0x15,0x72,0xb1);
-MIDL_INTERFACE("b17d6187-0907-464b-a168-0ef17a1572b1")
-IGridProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE GetItem(int row, int column, __RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_RowCount(__RPC__out int *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ColumnCount(__RPC__out int *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IGridProvider, 0xb17d6187, 0x0907, 0x464b, 0xa1,0x68, 0x0e,0xf1,0x7a,0x15,0x72,0xb1)
-#endif
-#endif
-
-
-#ifndef __IGridItemProvider_INTERFACE_DEFINED__
-#define __IGridItemProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IGridItemProvider, 0xd02541f1, 0xfb81, 0x4d64, 0xae,0x32, 0xf5,0x20,0xf8,0xa6,0xdb,0xd1);
-MIDL_INTERFACE("d02541f1-fb81-4d64-ae32-f520f8a6dbd1")
-IGridItemProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE get_Row(__RPC__out int *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_Column(__RPC__out int *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_RowSpan(__RPC__out int *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ColumnSpan(__RPC__out int *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ContainingGrid(__RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IGridItemProvider, 0xd02541f1, 0xfb81, 0x4d64, 0xae,0x32, 0xf5,0x20,0xf8,0xa6,0xdb,0xd1)
-#endif
-#endif
-
-
-#ifndef __IWindowProvider_INTERFACE_DEFINED__
-#define __IWindowProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IWindowProvider, 0x987df77b, 0xdb06, 0x4d77, 0x8f,0x8a, 0x86,0xa9,0xc3,0xbb,0x90,0xb9);
-MIDL_INTERFACE("987df77b-db06-4d77-8f8a-86a9c3bb90b9")
-IWindowProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE SetVisualState(enum WindowVisualState state) = 0;
-    virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
-    virtual HRESULT STDMETHODCALLTYPE WaitForInputIdle(int milliseconds, __RPC__out BOOL *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CanMaximize(__RPC__out BOOL *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CanMinimize(__RPC__out BOOL *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_IsModal(__RPC__out BOOL *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_WindowVisualState(__RPC__out enum WindowVisualState *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_WindowInteractionState(__RPC__out enum WindowInteractionState *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_IsTopmost(__RPC__out BOOL *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IWindowProvider, 0x987df77b, 0xdb06, 0x4d77, 0x8f,0x8a, 0x86,0xa9,0xc3,0xbb,0x90,0xb9)
-#endif
-#endif
-
-
-#ifndef __IExpandCollapseProvider_INTERFACE_DEFINED__
-#define __IExpandCollapseProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IExpandCollapseProvider, 0xd847d3a5, 0xcab0, 0x4a98, 0x8c,0x32, 0xec,0xb4,0x5c,0x59,0xad,0x24);
-MIDL_INTERFACE("d847d3a5-cab0-4a98-8c32-ecb45c59ad24")
-IExpandCollapseProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE Expand() = 0;
-    virtual HRESULT STDMETHODCALLTYPE Collapse() = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ExpandCollapseState(__RPC__out enum ExpandCollapseState *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IExpandCollapseProvider, 0xd847d3a5, 0xcab0, 0x4a98, 0x8c,0x32, 0xec,0xb4,0x5c,0x59,0xad,0x24)
-#endif
-#endif
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiatypes_p.h b/src/gui/accessible/windows/apisupport/uiatypes_p.h
deleted file mode 100644
index 465bd07a07..0000000000
--- a/src/gui/accessible/windows/apisupport/uiatypes_p.h
+++ /dev/null
@@ -1,157 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIATYPES_H
-#define UIATYPES_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-typedef int PROPERTYID;
-typedef int PATTERNID;
-typedef int EVENTID;
-typedef int TEXTATTRIBUTEID;
-typedef int CONTROLTYPEID;
-typedef int LANDMARKTYPEID;
-typedef int METADATAID;
-
-typedef void *UIA_HWND;
-
-enum NavigateDirection {
-    NavigateDirection_Parent           = 0,
-    NavigateDirection_NextSibling      = 1,
-    NavigateDirection_PreviousSibling  = 2,
-    NavigateDirection_FirstChild       = 3,
-    NavigateDirection_LastChild        = 4
-};
-
-enum ProviderOptions {
-    ProviderOptions_ClientSideProvider      = 0x1,
-    ProviderOptions_ServerSideProvider      = 0x2,
-    ProviderOptions_NonClientAreaProvider   = 0x4,
-    ProviderOptions_OverrideProvider        = 0x8,
-    ProviderOptions_ProviderOwnsSetFocus    = 0x10,
-    ProviderOptions_UseComThreading         = 0x20,
-    ProviderOptions_RefuseNonClientSupport  = 0x40,
-    ProviderOptions_HasNativeIAccessible    = 0x80,
-    ProviderOptions_UseClientCoordinates    = 0x100
-};
-
-enum SupportedTextSelection {
-    SupportedTextSelection_None      = 0,
-    SupportedTextSelection_Single    = 1,
-    SupportedTextSelection_Multiple  = 2
-};
-
-enum TextUnit {
-    TextUnit_Character  = 0,
-    TextUnit_Format     = 1,
-    TextUnit_Word       = 2,
-    TextUnit_Line       = 3,
-    TextUnit_Paragraph  = 4,
-    TextUnit_Page       = 5,
-    TextUnit_Document   = 6
-};
-
-enum TextPatternRangeEndpoint {
-    TextPatternRangeEndpoint_Start  = 0,
-    TextPatternRangeEndpoint_End    = 1
-};
-
-enum CaretPosition {
-    CaretPosition_Unknown           = 0,
-    CaretPosition_EndOfLine         = 1,
-    CaretPosition_BeginningOfLine   = 2
-};
-
-enum ToggleState {
-    ToggleState_Off            = 0,
-    ToggleState_On             = 1,
-    ToggleState_Indeterminate  = 2
-};
-
-enum RowOrColumnMajor {
-    RowOrColumnMajor_RowMajor       = 0,
-    RowOrColumnMajor_ColumnMajor    = 1,
-    RowOrColumnMajor_Indeterminate  = 2
-};
-
-enum TreeScope {
-    TreeScope_None        = 0,
-    TreeScope_Element     = 0x1,
-    TreeScope_Children    = 0x2,
-    TreeScope_Descendants = 0x4,
-    TreeScope_Parent      = 0x8,
-    TreeScope_Ancestors   = 0x10,
-    TreeScope_Subtree     = TreeScope_Element | TreeScope_Children | TreeScope_Descendants
-};
-
-enum OrientationType {
-    OrientationType_None        = 0,
-    OrientationType_Horizontal  = 1,
-    OrientationType_Vertical    = 2
-};
-
-enum PropertyConditionFlags {
-    PropertyConditionFlags_None        = 0,
-    PropertyConditionFlags_IgnoreCase  = 1
-};
-
-enum WindowVisualState {
-    WindowVisualState_Normal    = 0,
-    WindowVisualState_Maximized = 1,
-    WindowVisualState_Minimized = 2
-};
-
-enum WindowInteractionState {
-    WindowInteractionState_Running                 = 0,
-    WindowInteractionState_Closing                 = 1,
-    WindowInteractionState_ReadyForUserInteraction = 2,
-    WindowInteractionState_BlockedByModalWindow    = 3,
-    WindowInteractionState_NotResponding           = 4
-};
-
-enum ExpandCollapseState {
-    ExpandCollapseState_Collapsed         = 0,
-    ExpandCollapseState_Expanded          = 1,
-    ExpandCollapseState_PartiallyExpanded = 2,
-    ExpandCollapseState_LeafNode          = 3
-};
-
-enum NotificationKind {
-    NotificationKind_ItemAdded       = 0,
-    NotificationKind_ItemRemoved     = 1,
-    NotificationKind_ActionCompleted = 2,
-    NotificationKind_ActionAborted   = 3,
-    NotificationKind_Other           = 4
-};
-
-enum NotificationProcessing {
-    NotificationProcessing_ImportantAll          = 0,
-    NotificationProcessing_ImportantMostRecent   = 1,
-    NotificationProcessing_All                   = 2,
-    NotificationProcessing_MostRecent            = 3,
-    NotificationProcessing_CurrentThenMostRecent = 4
-};
-
-struct UiaRect {
-    double left;
-    double top;
-    double width;
-    double height;
-};
-
-struct UiaPoint {
-    double x;
-    double y;
-};
-
-#endif
diff --git a/src/gui/opengl/qopengl.cpp b/src/gui/opengl/qopengl.cpp
index 7c997103d5..d52d23ebe1 100644
--- a/src/gui/opengl/qopengl.cpp
+++ b/src/gui/opengl/qopengl.cpp
@@ -195,13 +195,32 @@ struct OsTypeTerm
     static QString hostOs();
     static QVersionNumber hostKernelVersion() { return QVersionNumber::fromString(QSysInfo::kernelVersion()); }
     static QString hostOsRelease() {
+        QString ver;
 #ifdef Q_OS_WIN
-        if (QOperatingSystemVersion::current() >= QOperatingSystemVersion::Windows11)
-            return u"11"_s;
-        return u"10"_s;
-#else
-        return {};
+        const auto osver = QOperatingSystemVersion::current();
+#define Q_WINVER(major, minor) (major << 8 | minor)
+        switch (Q_WINVER(osver.majorVersion(), osver.minorVersion())) {
+        case Q_WINVER(6, 1):
+            ver = QStringLiteral("7");
+            break;
+        case Q_WINVER(6, 2):
+            ver = QStringLiteral("8");
+            break;
+        case Q_WINVER(6, 3):
+            ver = QStringLiteral("8.1");
+            break;
+        case Q_WINVER(10, 0):
+            if (osver.microVersion() >= 22000)
+                ver = QStringLiteral("11");
+            else
+                ver = QStringLiteral("10");
+            break;
+        default:
+            break;
+        }
+#undef Q_WINVER
 #endif
+        return ver;
     }
 
     bool isNull() const { return type.isEmpty(); }
diff --git a/src/gui/rhi/qrhid3d11.cpp b/src/gui/rhi/qrhid3d11.cpp
index a4a83e4296..854e6d1483 100644
--- a/src/gui/rhi/qrhid3d11.cpp
+++ b/src/gui/rhi/qrhid3d11.cpp
@@ -9,6 +9,8 @@
 #include <qmath.h>
 #include <private/qsystemlibrary_p.h>
 #include <QtCore/qcryptographichash.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 #include <QtCore/private/qsystemerror_p.h>
 
 #include <d3dcompiler.h>
@@ -129,16 +131,33 @@ inline Int aligned(Int v, Int byteAlign)
     return (v + byteAlign - 1) & ~(byteAlign - 1);
 }
 
+static IDXGIFactory1 *createDXGIFactory1()
+{
+    IDXGIFactory1 *result = nullptr;
+    const HRESULT hr = CreateDXGIFactory1(__uuidof(IDXGIFactory1), reinterpret_cast<void **>(&result));
+    if (SUCCEEDED(hr))
+        return result;
+    qWarning("CreateDXGIFactory1() failed to create DXGI factory: %s",
+        qPrintable(QSystemError::windowsComString(hr)));
+    return nullptr;
+}
+
 static IDXGIFactory1 *createDXGIFactory2()
 {
+    if (!QOperatingSystemVersion::isWin8Point1OrGreater())
+        return nullptr;
+    static const auto pCreateDXGIFactory2 =
+        reinterpret_cast<decltype(&::CreateDXGIFactory2)>(
+            QSystemLibrary::resolve(u"dxgi"_s, "CreateDXGIFactory2"));
+    if (!pCreateDXGIFactory2)
+        return nullptr;
     IDXGIFactory1 *result = nullptr;
-    const HRESULT hr = CreateDXGIFactory2(0, __uuidof(IDXGIFactory2), reinterpret_cast<void **>(&result));
-    if (FAILED(hr)) {
-        qWarning("CreateDXGIFactory2() failed to create DXGI factory: %s",
-            qPrintable(QSystemError::windowsComString(hr)));
-        result = nullptr;
-    }
-    return result;
+    const HRESULT hr = pCreateDXGIFactory2(0, __uuidof(IDXGIFactory2), reinterpret_cast<void **>(&result));
+    if (SUCCEEDED(hr))
+        return result;
+    qWarning("CreateDXGIFactory2() failed to create DXGI factory: %s",
+        qPrintable(QSystemError::windowsComString(hr)));
+    return nullptr;
 }
 
 bool QRhiD3D11::create(QRhi::Flags flags)
@@ -150,31 +169,36 @@ bool QRhiD3D11::create(QRhi::Flags flags)
         devFlags |= D3D11_CREATE_DEVICE_DEBUG;
 
     dxgiFactory = createDXGIFactory2();
+    if (dxgiFactory) {
+        supportsFlipSwapchain = QOperatingSystemVersion::isWin10OrGreater()
+            && !qEnvironmentVariableIntValue("QT_D3D_NO_FLIP");
+    } else {
+        supportsFlipSwapchain = false;
+        dxgiFactory = createDXGIFactory1();
+    }
     if (!dxgiFactory)
         return false;
 
-    // For a FLIP_* swapchain Present(0, 0) is not necessarily
-    // sufficient to get non-blocking behavior, try using ALLOW_TEARING
-    // when available.
     supportsAllowTearing = false;
-    IDXGIFactory5 *factory5 = nullptr;
-    if (SUCCEEDED(dxgiFactory->QueryInterface(__uuidof(IDXGIFactory5), reinterpret_cast<void **>(&factory5)))) {
-        BOOL allowTearing = false;
-        if (SUCCEEDED(factory5->CheckFeatureSupport(DXGI_FEATURE_PRESENT_ALLOW_TEARING, &allowTearing, sizeof(allowTearing))))
-            supportsAllowTearing = allowTearing;
-        factory5->Release();
+    if (supportsFlipSwapchain) {
+        // For a FLIP_* swapchain Present(0, 0) is not necessarily
+        // sufficient to get non-blocking behavior, try using ALLOW_TEARING
+        // when available.
+        IDXGIFactory5 *factory5 = nullptr;
+        if (SUCCEEDED(dxgiFactory->QueryInterface(__uuidof(IDXGIFactory5), reinterpret_cast<void **>(&factory5)))) {
+            BOOL allowTearing = false;
+            if (SUCCEEDED(factory5->CheckFeatureSupport(DXGI_FEATURE_PRESENT_ALLOW_TEARING, &allowTearing, sizeof(allowTearing))))
+                supportsAllowTearing = allowTearing;
+            factory5->Release();
+        }
     }
 
-    if (qEnvironmentVariableIntValue("QT_D3D_FLIP_DISCARD"))
-        qWarning("The default swap effect is FLIP_DISCARD, QT_D3D_FLIP_DISCARD is now ignored");
-
-    if (qEnvironmentVariableIntValue("QT_D3D_NO_FLIP"))
-        qWarning("Non-FLIP swapchains are no longer supported, QT_D3D_NO_FLIP is now ignored");
-
-    qCDebug(QRHI_LOG_INFO, "FLIP_* swapchain supported = true, ALLOW_TEARING supported = %s",
+    qCDebug(QRHI_LOG_INFO, "FLIP_* swapchain supported = %s, ALLOW_TEARING supported = %s",
+            supportsFlipSwapchain ? "true" : "false",
             supportsAllowTearing ? "true" : "false");
 
-    qCDebug(QRHI_LOG_INFO, "Default swap effect: FLIP_DISCARD");
+    qCDebug(QRHI_LOG_INFO, "Default swap effect: %s",
+            supportsFlipSwapchain ? "FLIP_DISCARD" : "DISCARD");
 
     if (!importedDeviceAndContext) {
         IDXGIAdapter1 *adapter;
@@ -4845,12 +4869,21 @@ static const DXGI_FORMAT DEFAULT_SRGB_FORMAT = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
 
 bool QRhiD3D11::ensureDirectCompositionDevice()
 {
+    if (!QOperatingSystemVersion::isWin8OrGreater())
+        return false;
+
+    static const auto pDCompositionCreateDevice =
+        reinterpret_cast<decltype(&::DCompositionCreateDevice)>(
+            QSystemLibrary::resolve(u"dcomp"_s, "DCompositionCreateDevice"));
+    if (!pDCompositionCreateDevice)
+        return false;
+
     if (dcompDevice)
         return true;
 
     qCDebug(QRHI_LOG_INFO, "Creating Direct Composition device (needed for semi-transparent windows)");
 
-    HRESULT hr = DCompositionCreateDevice(nullptr, __uuidof(IDCompositionDevice), reinterpret_cast<void **>(&dcompDevice));
+    HRESULT hr = pDCompositionCreateDevice(nullptr, __uuidof(IDCompositionDevice), reinterpret_cast<void **>(&dcompDevice));
     if (FAILED(hr)) {
         qWarning("Failed to Direct Composition device: %s",
             qPrintable(QSystemError::windowsComString(hr)));
@@ -4883,12 +4916,18 @@ bool QD3D11SwapChain::createOrResize()
     HRESULT hr;
 
     QRHI_RES_RHI(QRhiD3D11);
+    bool useFlipModel = rhiD->supportsFlipSwapchain;
 
+    // Take a shortcut for alpha: whatever the platform plugin does to enable
+    // transparency for our QWindow will be sufficient on the legacy (DISCARD)
+    // path. For FLIP_* we'd need to use DirectComposition (create a
+    // IDCompositionDevice/Target/Visual).
     if (m_flags.testFlag(SurfaceHasPreMulAlpha) || m_flags.testFlag(SurfaceHasNonPreMulAlpha)) {
         if (rhiD->ensureDirectCompositionDevice()) {
             if (!dcompTarget) {
                 hr = rhiD->dcompDevice->CreateTargetForHwnd(hwnd, true, &dcompTarget);
                 if (FAILED(hr)) {
+                    useFlipModel = false;
                     qWarning("Failed to create Direct Compsition target for the window: %s",
                              qPrintable(QSystemError::windowsComString(hr)));
                 }
@@ -4896,10 +4935,15 @@ bool QD3D11SwapChain::createOrResize()
             if (dcompTarget && !dcompVisual) {
                 hr = rhiD->dcompDevice->CreateVisual(&dcompVisual);
                 if (FAILED(hr)) {
+                    useFlipModel = false;
                     qWarning("Failed to create DirectComposition visual: %s",
                              qPrintable(QSystemError::windowsComString(hr)));
                 }
             }
+        } else {
+            // Direct Composition is not available, most likely due to we are running
+            // on Windows 7. Fallback to the legacy non-flip model instead.
+            useFlipModel = false;
         }
         // simple consistency check
         if (window->requestedFormat().alphaBufferSize() <= 0)
@@ -4914,7 +4958,7 @@ bool QD3D11SwapChain::createOrResize()
     // ALLOW_TEARING, and ALLOW_TEARING is not compatible with it at all so the
     // flag must not be set then. Whereas for flip we should use it, if
     // supported, to get better results for 'unthrottled' presentation.
-    if (swapInterval == 0 && rhiD->supportsAllowTearing)
+    if (swapInterval == 0 && useFlipModel && rhiD->supportsAllowTearing)
         swapChainFlags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING;
 
     if (!swapChain) {
@@ -4922,110 +4966,133 @@ bool QD3D11SwapChain::createOrResize()
         colorFormat = DEFAULT_FORMAT;
         srgbAdjustedColorFormat = m_flags.testFlag(sRGB) ? DEFAULT_SRGB_FORMAT : DEFAULT_FORMAT;
 
-        DXGI_COLOR_SPACE_TYPE hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709; // SDR
-        DXGI_OUTPUT_DESC1 hdrOutputDesc;
-        if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &hdrOutputDesc) && m_format != SDR) {
-            // https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range
-            if (hdrOutputDesc.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020) {
-                switch (m_format) {
-                case HDRExtendedSrgbLinear:
-                    colorFormat = DXGI_FORMAT_R16G16B16A16_FLOAT;
-                    hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709;
-                    srgbAdjustedColorFormat = colorFormat;
-                    break;
-                case HDR10:
-                    colorFormat = DXGI_FORMAT_R10G10B10A2_UNORM;
-                    hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
-                    srgbAdjustedColorFormat = colorFormat;
-                    break;
-                default:
-                    break;
+        if (useFlipModel) {
+            DXGI_COLOR_SPACE_TYPE hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709; // SDR
+            DXGI_OUTPUT_DESC1 hdrOutputDesc;
+            if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &hdrOutputDesc) && m_format != SDR) {
+                // https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range
+                if (hdrOutputDesc.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020) {
+                    switch (m_format) {
+                    case HDRExtendedSrgbLinear:
+                        colorFormat = DXGI_FORMAT_R16G16B16A16_FLOAT;
+                        hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709;
+                        srgbAdjustedColorFormat = colorFormat;
+                        break;
+                    case HDR10:
+                        colorFormat = DXGI_FORMAT_R10G10B10A2_UNORM;
+                        hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
+                        srgbAdjustedColorFormat = colorFormat;
+                        break;
+                    default:
+                        break;
+                    }
+                } else {
+                    // This happens also when Use HDR is set to Off in the Windows
+                    // Display settings. Show a helpful warning, but continue with the
+                    // default non-HDR format.
+                    qWarning("The output associated with the window is not HDR capable "
+                             "(or Use HDR is Off in the Display Settings), ignoring HDR format request");
                 }
-            } else {
-                // This happens also when Use HDR is set to Off in the Windows
-                // Display settings. Show a helpful warning, but continue with the
-                // default non-HDR format.
-                qWarning("The output associated with the window is not HDR capable "
-                         "(or Use HDR is Off in the Display Settings), ignoring HDR format request");
             }
-        }
 
-        // We use a FLIP model swapchain which implies a buffer count of 2
-        // (as opposed to the old DISCARD with back buffer count == 1).
-        // This makes no difference for the rest of the stuff except that
-        // automatic MSAA is unsupported and needs to be implemented via a
-        // custom multisample render target and an explicit resolve.
-
-        DXGI_SWAP_CHAIN_DESC1 desc = {};
-        desc.Width = UINT(pixelSize.width());
-        desc.Height = UINT(pixelSize.height());
-        desc.Format = colorFormat;
-        desc.SampleDesc.Count = 1;
-        desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
-        desc.BufferCount = BUFFER_COUNT;
-        desc.Flags = swapChainFlags;
-        desc.Scaling = DXGI_SCALING_NONE;
-        desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
-
-        if (dcompVisual) {
-            // With DirectComposition setting AlphaMode to STRAIGHT fails the
-            // swapchain creation, whereas the result seems to be identical
-            // with any of the other values, including IGNORE. (?)
-            desc.AlphaMode = DXGI_ALPHA_MODE_PREMULTIPLIED;
-
-            // DirectComposition has its own limitations, cannot use
-            // SCALING_NONE. So with semi-transparency requested we are forced
-            // to SCALING_STRETCH.
-            desc.Scaling = DXGI_SCALING_STRETCH;
-        }
+            // We use a FLIP model swapchain which implies a buffer count of 2
+            // (as opposed to the old DISCARD with back buffer count == 1).
+            // This makes no difference for the rest of the stuff except that
+            // automatic MSAA is unsupported and needs to be implemented via a
+            // custom multisample render target and an explicit resolve.
 
-        IDXGIFactory2 *fac = static_cast<IDXGIFactory2 *>(rhiD->dxgiFactory);
-        IDXGISwapChain1 *sc1;
+            DXGI_SWAP_CHAIN_DESC1 desc = {};
+            desc.Width = UINT(pixelSize.width());
+            desc.Height = UINT(pixelSize.height());
+            desc.Format = colorFormat;
+            desc.SampleDesc.Count = 1;
+            desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
+            desc.BufferCount = BUFFER_COUNT;
+            desc.Flags = swapChainFlags;
+            desc.Scaling = DXGI_SCALING_NONE;
+            desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
+
+            if (dcompVisual) {
+                // With DirectComposition setting AlphaMode to STRAIGHT fails the
+                // swapchain creation, whereas the result seems to be identical
+                // with any of the other values, including IGNORE. (?)
+                desc.AlphaMode = DXGI_ALPHA_MODE_PREMULTIPLIED;
+
+                // DirectComposition has its own limitations, cannot use
+                // SCALING_NONE. So with semi-transparency requested we are forced
+                // to SCALING_STRETCH.
+                desc.Scaling = DXGI_SCALING_STRETCH;
+            }
+
+            IDXGIFactory2 *fac = static_cast<IDXGIFactory2 *>(rhiD->dxgiFactory);
+            IDXGISwapChain1 *sc1;
 
-        if (dcompVisual)
-            hr = fac->CreateSwapChainForComposition(rhiD->dev, &desc, nullptr, &sc1);
-        else
-            hr = fac->CreateSwapChainForHwnd(rhiD->dev, hwnd, &desc, nullptr, nullptr, &sc1);
-
-        // If failed and we tried a HDR format, then try with SDR. This
-        // matches other backends, such as Vulkan where if the format is
-        // not supported, the default one is used instead.
-        if (FAILED(hr) && m_format != SDR) {
-            colorFormat = DEFAULT_FORMAT;
-            desc.Format = DEFAULT_FORMAT;
             if (dcompVisual)
                 hr = fac->CreateSwapChainForComposition(rhiD->dev, &desc, nullptr, &sc1);
             else
                 hr = fac->CreateSwapChainForHwnd(rhiD->dev, hwnd, &desc, nullptr, nullptr, &sc1);
-        }
 
-        if (SUCCEEDED(hr)) {
-            swapChain = sc1;
-            if (m_format != SDR) {
-                IDXGISwapChain3 *sc3 = nullptr;
-                if (SUCCEEDED(sc1->QueryInterface(__uuidof(IDXGISwapChain3), reinterpret_cast<void **>(&sc3)))) {
-                    hr = sc3->SetColorSpace1(hdrColorSpace);
-                    if (FAILED(hr))
-                        qWarning("Failed to set color space on swapchain: %s",
-                            qPrintable(QSystemError::windowsComString(hr)));
-                    sc3->Release();
-                } else {
-                    qWarning("IDXGISwapChain3 not available, HDR swapchain will not work as expected");
-                }
+            // If failed and we tried a HDR format, then try with SDR. This
+            // matches other backends, such as Vulkan where if the format is
+            // not supported, the default one is used instead.
+            if (FAILED(hr) && m_format != SDR) {
+                colorFormat = DEFAULT_FORMAT;
+                desc.Format = DEFAULT_FORMAT;
+                if (dcompVisual)
+                    hr = fac->CreateSwapChainForComposition(rhiD->dev, &desc, nullptr, &sc1);
+                else
+                    hr = fac->CreateSwapChainForHwnd(rhiD->dev, hwnd, &desc, nullptr, nullptr, &sc1);
             }
-            if (dcompVisual) {
-                hr = dcompVisual->SetContent(sc1);
-                if (SUCCEEDED(hr)) {
-                    hr = dcompTarget->SetRoot(dcompVisual);
-                    if (FAILED(hr)) {
-                        qWarning("Failed to associate Direct Composition visual with the target: %s",
+
+            if (SUCCEEDED(hr)) {
+                swapChain = sc1;
+                if (m_format != SDR) {
+                    IDXGISwapChain3 *sc3 = nullptr;
+                    if (SUCCEEDED(sc1->QueryInterface(__uuidof(IDXGISwapChain3), reinterpret_cast<void **>(&sc3)))) {
+                        hr = sc3->SetColorSpace1(hdrColorSpace);
+                        if (FAILED(hr)) {
+                            qWarning("Failed to set color space on swapchain: %s",
+                                qPrintable(QSystemError::windowsComString(hr)));
+                        }
+                        sc3->Release();
+                    } else {
+                        qWarning("IDXGISwapChain3 not available, HDR swapchain will not work as expected");
+                    }
+                }
+                if (dcompVisual) {
+                    hr = dcompVisual->SetContent(sc1);
+                    if (SUCCEEDED(hr)) {
+                        hr = dcompTarget->SetRoot(dcompVisual);
+                        if (FAILED(hr)) {
+                            qWarning("Failed to associate Direct Composition visual with the target: %s",
+                                     qPrintable(QSystemError::windowsComString(hr)));
+                        }
+                    } else {
+                        qWarning("Failed to set content for Direct Composition visual: %s",
                                  qPrintable(QSystemError::windowsComString(hr)));
                     }
-                } else {
-                    qWarning("Failed to set content for Direct Composition visual: %s",
-                             qPrintable(QSystemError::windowsComString(hr)));
                 }
             }
+        } else {
+            // Fallback: use DISCARD model. Regardless, keep on using our manual
+            // resolve for symmetry with the FLIP_* code path when MSAA is
+            // requested. This has no HDR support.
+
+            DXGI_SWAP_CHAIN_DESC desc = {};
+            desc.BufferDesc.Width = UINT(pixelSize.width());
+            desc.BufferDesc.Height = UINT(pixelSize.height());
+            desc.BufferDesc.RefreshRate.Numerator = 60;
+            desc.BufferDesc.RefreshRate.Denominator = 1;
+            desc.BufferDesc.Format = colorFormat;
+            desc.SampleDesc.Count = 1;
+            desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
+            desc.BufferCount = 1;
+            desc.OutputWindow = hwnd;
+            desc.Windowed = TRUE;
+            desc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
+            desc.Flags = swapChainFlags;
+
+            hr = rhiD->dxgiFactory->CreateSwapChain(rhiD->dev, &desc, &swapChain);
         }
         if (FAILED(hr)) {
             qWarning("Failed to create D3D11 swapchain: %s",
@@ -5035,8 +5102,8 @@ bool QD3D11SwapChain::createOrResize()
         rhiD->dxgiFactory->MakeWindowAssociation(hwnd, DXGI_MWA_NO_WINDOW_CHANGES);
     } else {
         releaseBuffers();
-        // flip model -> buffer count is the real buffer count, not 1 like with the legacy modes
-        hr = swapChain->ResizeBuffers(UINT(BUFFER_COUNT), UINT(pixelSize.width()), UINT(pixelSize.height()),
+        const UINT count = useFlipModel ? BUFFER_COUNT : 1;
+        hr = swapChain->ResizeBuffers(count, UINT(pixelSize.width()), UINT(pixelSize.height()),
                                       colorFormat, swapChainFlags);
         if (hr == DXGI_ERROR_DEVICE_REMOVED || hr == DXGI_ERROR_DEVICE_RESET) {
             qWarning("Device loss detected in ResizeBuffers()");
diff --git a/src/gui/rhi/qrhid3d11_p_p.h b/src/gui/rhi/qrhid3d11_p_p.h
index 3f4d8e8e31..24d3b3324e 100644
--- a/src/gui/rhi/qrhid3d11_p_p.h
+++ b/src/gui/rhi/qrhid3d11_p_p.h
@@ -739,6 +739,7 @@ public:
     IDXGIAdapter1 *activeAdapter = nullptr;
     IDXGIFactory1 *dxgiFactory = nullptr;
     IDCompositionDevice *dcompDevice = nullptr;
+    bool supportsFlipSwapchain = false;
     bool supportsAllowTearing = false;
     bool deviceLost = false;
     QRhiD3D11NativeHandles nativeHandlesStruct;
diff --git a/src/gui/text/windows/qwindowsfontdatabasebase.cpp b/src/gui/text/windows/qwindowsfontdatabasebase.cpp
index f45678c65c..346952186e 100644
--- a/src/gui/text/windows/qwindowsfontdatabasebase.cpp
+++ b/src/gui/text/windows/qwindowsfontdatabasebase.cpp
@@ -6,6 +6,7 @@
 
 #include <QtCore/QThreadStorage>
 #include <QtCore/QtEndian>
+#include <QtCore/private/qsystemlibrary_p.h>
 
 #if QT_CONFIG(directwrite)
 #  if QT_CONFIG(directwrite3)
@@ -685,7 +686,13 @@ QFont QWindowsFontDatabaseBase::systemDefaultFont()
     // Qt 6: Obtain default GUI font (typically "Segoe UI, 9pt", see QTBUG-58610)
     NONCLIENTMETRICS ncm = {};
     ncm.cbSize = sizeof(ncm);
-    SystemParametersInfoForDpi(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0, defaultVerticalDPI());
+    static const auto pSystemParametersInfoForDpi =
+        reinterpret_cast<decltype(&::SystemParametersInfoForDpi)>(
+            QSystemLibrary::resolve(u"user32"_s, "SystemParametersInfoForDpi"));
+    if (pSystemParametersInfoForDpi)
+        pSystemParametersInfoForDpi(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0, defaultVerticalDPI());
+    else
+        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0);
     const QFont systemFont = QWindowsFontDatabase::LOGFONT_to_QFont(ncm.lfMessageFont);
     qCDebug(lcQpaFonts) << __FUNCTION__ << systemFont;
     return systemFont;
diff --git a/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp b/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp
index f46dfb88ee..6c1da890b9 100644
--- a/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp
+++ b/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp
@@ -5,6 +5,7 @@
 #include <QtCore/private/qsystemerror_p.h>
 
 #include <QtCore/qpointer.h>
+#include <QtCore/qoperatingsystemversion.h>
 
 #include <mutex>
 
@@ -108,20 +109,22 @@ bool QNetworkListManagerEvents::start()
     }
 
 #if QT_CONFIG(cpp_winrt)
-    using namespace winrt::Windows::Networking::Connectivity;
-    using winrt::Windows::Foundation::IInspectable;
-    // Register for changes in the network and store a token to unregister later:
-    token = NetworkInformation::NetworkStatusChanged(
-            [owner = QPointer(this)](const IInspectable sender) {
-                Q_UNUSED(sender);
-                if (owner) {
-                    std::scoped_lock locker(owner->winrtLock);
-                    if (owner->token)
-                        owner->emitWinRTUpdates();
-                }
-            });
-    // Emit initial state
-    emitWinRTUpdates();
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        using namespace winrt::Windows::Networking::Connectivity;
+        using winrt::Windows::Foundation::IInspectable;
+        // Register for changes in the network and store a token to unregister later:
+        token = NetworkInformation::NetworkStatusChanged(
+                [owner = QPointer(this)](const IInspectable sender) {
+                    Q_UNUSED(sender);
+                    if (owner) {
+                        std::scoped_lock locker(owner->winrtLock);
+                        if (owner->token)
+                            owner->emitWinRTUpdates();
+                    }
+                });
+        // Emit initial state
+        emitWinRTUpdates();
+    }
 #endif
 
     return true;
@@ -140,13 +143,15 @@ void QNetworkListManagerEvents::stop()
     // Even if we fail we should still try to unregister from winrt events:
 
 #if QT_CONFIG(cpp_winrt)
-    // Try to synchronize unregistering with potentially in-progress callbacks
-    std::scoped_lock locker(winrtLock);
-    if (token) {
-        using namespace winrt::Windows::Networking::Connectivity;
-        // Pass the token we stored earlier to unregister:
-        NetworkInformation::NetworkStatusChanged(token);
-        token = {};
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        // Try to synchronize unregistering with potentially in-progress callbacks
+        std::scoped_lock locker(winrtLock);
+        if (token) {
+            using namespace winrt::Windows::Networking::Connectivity;
+            // Pass the token we stored earlier to unregister:
+            NetworkInformation::NetworkStatusChanged(token);
+            token = {};
+        }
     }
 #endif
 }
@@ -197,6 +202,9 @@ using namespace winrt::Windows::Networking::Connectivity;
 [[nodiscard]]
 QNetworkInformation::TransportMedium getTransportMedium(const ConnectionProfile &profile)
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return QNetworkInformation::TransportMedium::Unknown;
+
     if (profile.IsWwanConnectionProfile())
         return QNetworkInformation::TransportMedium::Cellular;
     if (profile.IsWlanConnectionProfile())
@@ -230,6 +238,8 @@ QNetworkInformation::TransportMedium getTransportMedium(const ConnectionProfile
 
 [[nodiscard]] bool getMetered(const ConnectionProfile &profile)
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return false;
     ConnectionCost cost(nullptr);
     try {
         cost = profile.GetConnectionCost();
@@ -245,6 +255,8 @@ QNetworkInformation::TransportMedium getTransportMedium(const ConnectionProfile
 
 void QNetworkListManagerEvents::emitWinRTUpdates()
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return;
     using namespace winrt::Windows::Networking::Connectivity;
     ConnectionProfile profile = nullptr;
     try {
diff --git a/src/plugins/platforms/CMakeLists.txt b/src/plugins/platforms/CMakeLists.txt
index dfbec51877..34107a6741 100644
--- a/src/plugins/platforms/CMakeLists.txt
+++ b/src/plugins/platforms/CMakeLists.txt
@@ -6,12 +6,6 @@
 if(ANDROID)
     add_subdirectory(android)
 endif()
-if(NOT ANDROID AND NOT WASM)
-    add_subdirectory(minimal)
-endif()
-if(QT_FEATURE_freetype AND NOT ANDROID AND NOT WASM)
-    add_subdirectory(offscreen)
-endif()
 if(QT_FEATURE_xcb)
     add_subdirectory(xcb)
 endif()
@@ -24,9 +18,6 @@ endif()
 if(WIN32)
     add_subdirectory(windows)
 endif()
-if(QT_FEATURE_direct2d1_1 AND QT_FEATURE_directwrite)
-    add_subdirectory(direct2d)
-endif()
 if(QNX)
     add_subdirectory(qnx)
 endif()
diff --git a/src/plugins/platforms/direct2d/CMakeLists.txt b/src/plugins/platforms/direct2d/CMakeLists.txt
deleted file mode 100644
index d0ab0d1efd..0000000000
--- a/src/plugins/platforms/direct2d/CMakeLists.txt
+++ /dev/null
@@ -1,224 +0,0 @@
-# Copyright (C) 2022 The Qt Company Ltd.
-# SPDX-License-Identifier: BSD-3-Clause
-
-# Generated from direct2d.pro.
-
-#####################################################################
-## QWindowsDirect2DIntegrationPlugin Plugin:
-#####################################################################
-
-qt_internal_add_plugin(QWindowsDirect2DIntegrationPlugin
-    OUTPUT_NAME qdirect2d
-    PLUGIN_TYPE platforms
-    SOURCES
-        ../windows/qtwindowsglobal.h
-        ../windows/qwin10helpers.cpp ../windows/qwin10helpers.h
-        ../windows/qwindowsapplication.cpp ../windows/qwindowsapplication.h
-        ../windows/qwindowscombase.h
-        ../windows/qwindowscontext.cpp ../windows/qwindowscontext.h
-        ../windows/qwindowscursor.cpp ../windows/qwindowscursor.h
-        ../windows/qwindowsdialoghelpers.cpp ../windows/qwindowsdialoghelpers.h
-        ../windows/qwindowsdropdataobject.cpp ../windows/qwindowsdropdataobject.h
-        ../windows/qwindowsinputcontext.cpp ../windows/qwindowsinputcontext.h
-        ../windows/qwindowsintegration.cpp ../windows/qwindowsintegration.h
-        ../windows/qwindowsinternalmimedata.cpp ../windows/qwindowsinternalmimedata.h
-        ../windows/qwindowskeymapper.cpp ../windows/qwindowskeymapper.h
-        ../windows/qwindowsmenu.cpp ../windows/qwindowsmenu.h
-        ../windows/qwindowsmimeregistry.cpp ../windows/qwindowsmimeregistry.h
-        ../windows/qwindowsmousehandler.cpp ../windows/qwindowsmousehandler.h
-        ../windows/qwindowsnativeinterface.cpp ../windows/qwindowsnativeinterface.h
-        ../windows/qwindowsole.cpp ../windows/qwindowsole.h
-        ../windows/qwindowsopengltester.cpp ../windows/qwindowsopengltester.h
-        ../windows/qwindowspointerhandler.cpp ../windows/qwindowspointerhandler.h
-        ../windows/qwindowsscreen.cpp ../windows/qwindowsscreen.h
-        ../windows/qwindowsservices.cpp ../windows/qwindowsservices.h
-        ../windows/qwindowstheme.cpp ../windows/qwindowstheme.h
-        ../windows/qwindowsthreadpoolrunner.h
-        ../windows/qwindowswindow.cpp ../windows/qwindowswindow.h
-        qwindowsdirect2dbackingstore.cpp qwindowsdirect2dbackingstore.h
-        qwindowsdirect2dbitmap.cpp qwindowsdirect2dbitmap.h
-        qwindowsdirect2dcontext.cpp qwindowsdirect2dcontext.h
-        qwindowsdirect2ddevicecontext.cpp qwindowsdirect2ddevicecontext.h
-        qwindowsdirect2dhelpers.h
-        qwindowsdirect2dintegration.cpp qwindowsdirect2dintegration.h
-        qwindowsdirect2dnativeinterface.cpp qwindowsdirect2dnativeinterface.h
-        qwindowsdirect2dpaintdevice.cpp qwindowsdirect2dpaintdevice.h
-        qwindowsdirect2dpaintengine.cpp qwindowsdirect2dpaintengine.h
-        qwindowsdirect2dplatformpixmap.cpp qwindowsdirect2dplatformpixmap.h
-        qwindowsdirect2dplatformplugin.cpp
-        qwindowsdirect2dwindow.cpp qwindowsdirect2dwindow.h
-    DEFINES
-        QT_NO_CAST_FROM_ASCII
-        QT_NO_FOREACH
-    INCLUDE_DIRECTORIES
-        ../windows
-    LIBRARIES
-        Qt::Core
-        Qt::CorePrivate
-        Qt::Gui
-        Qt::GuiPrivate
-        advapi32
-        d2d1 # special case
-        d3d11
-        dwmapi
-        dwrite # special case
-        dxgi
-        dxguid
-        gdi32
-        imm32
-        ole32
-        oleaut32
-        shell32
-        shlwapi
-        user32
-        version
-        winmm
-        winspool
-        wtsapi32
-        shcore
-        comdlg32
-        d3d9
-        runtimeobject
-)
-
-# Resources:
-set_source_files_properties("../windows/openglblacklists/default.json"
-    PROPERTIES QT_RESOURCE_ALIAS "default.json"
-)
-set(openglblacklists_resource_files
-    "../windows/openglblacklists/default.json"
-)
-
-qt_internal_add_resource(QWindowsDirect2DIntegrationPlugin "openglblacklists"
-    PREFIX
-        "/qt-project.org/windows/openglblacklists"
-    FILES
-        ${openglblacklists_resource_files}
-)
-
-#### Keys ignored in scope 1:.:.:direct2d.pro:<TRUE>:
-# OTHER_FILES = "direct2d.json"
-
-## Scopes:
-#####################################################################
-
-#### Keys ignored in scope 2:.:.:direct2d.pro:NOT TARGET___equals____ss_QT_DEFAULT_QPA_PLUGIN:
-# PLUGIN_EXTENDS = "-"
-
-qt_internal_extend_target(QWindowsDirect2DIntegrationPlugin CONDITION QT_FEATURE_opengl AND NOT QT_FEATURE_dynamicgl
-    LIBRARIES
-        opengl32
-)
-
-qt_internal_extend_target(QWindowsDirect2DIntegrationPlugin CONDITION MINGW
-    LIBRARIES
-        uuid
-)
-
-qt_internal_extend_target(QWindowsDirect2DIntegrationPlugin CONDITION QT_FEATURE_opengl
-    SOURCES
-        ../windows/qwindowsglcontext.cpp ../windows/qwindowsglcontext.h
-        ../windows/qwindowsopenglcontext.h
-)
-
-qt_internal_extend_target(QWindowsDirect2DIntegrationPlugin CONDITION QT_FEATURE_systemtrayicon
-    SOURCES
-        ../windows/qwindowssystemtrayicon.cpp ../windows/qwindowssystemtrayicon.h
-)
-
-qt_internal_extend_target(QWindowsDirect2DIntegrationPlugin CONDITION QT_FEATURE_vulkan
-    SOURCES
-        ../windows/qwindowsvulkaninstance.cpp ../windows/qwindowsvulkaninstance.h
-)
-
-qt_internal_extend_target(QWindowsDirect2DIntegrationPlugin CONDITION QT_FEATURE_clipboard
-    SOURCES
-        ../windows/qwindowsclipboard.cpp ../windows/qwindowsclipboard.h
-)
-
-qt_internal_extend_target(QWindowsDirect2DIntegrationPlugin CONDITION QT_FEATURE_clipboard AND QT_FEATURE_draganddrop
-    SOURCES
-        ../windows/qwindowsdrag.cpp ../windows/qwindowsdrag.h
-)
-
-qt_internal_extend_target(QWindowsDirect2DIntegrationPlugin CONDITION QT_FEATURE_tabletevent
-    SOURCES
-        ../windows/qwindowstabletsupport.cpp ../windows/qwindowstabletsupport.h
-    INCLUDE_DIRECTORIES
-        ${QtBase_SOURCE_DIR}/src/3rdparty/wintab
-)
-
-qt_internal_extend_target(QWindowsDirect2DIntegrationPlugin CONDITION QT_FEATURE_sessionmanager
-    SOURCES
-        ../windows/qwindowssessionmanager.cpp ../windows/qwindowssessionmanager.h
-)
-
-if(QT_FEATURE_imageformat_png)
-    # Resources:
-    set(cursors_resource_files
-        "../windows/images/closedhandcursor_32.png"
-        "../windows/images/closedhandcursor_48.png"
-        "../windows/images/closedhandcursor_64.png"
-        "../windows/images/dragcopycursor_32.png"
-        "../windows/images/dragcopycursor_48.png"
-        "../windows/images/dragcopycursor_64.png"
-        "../windows/images/draglinkcursor_32.png"
-        "../windows/images/draglinkcursor_48.png"
-        "../windows/images/draglinkcursor_64.png"
-        "../windows/images/dragmovecursor_32.png"
-        "../windows/images/dragmovecursor_48.png"
-        "../windows/images/dragmovecursor_64.png"
-        "../windows/images/openhandcursor_32.png"
-        "../windows/images/openhandcursor_48.png"
-        "../windows/images/openhandcursor_64.png"
-        "../windows/images/splithcursor_32.png"
-        "../windows/images/splithcursor_48.png"
-        "../windows/images/splithcursor_64.png"
-        "../windows/images/splitvcursor_32.png"
-        "../windows/images/splitvcursor_48.png"
-        "../windows/images/splitvcursor_64.png"
-    )
-
-    qt_internal_add_resource(QWindowsDirect2DIntegrationPlugin "cursors"
-        PREFIX
-            "/qt-project.org/windows/cursors"
-        BASE
-            "../windows"
-        FILES
-            ${cursors_resource_files}
-    )
-endif()
-
-qt_internal_extend_target(QWindowsDirect2DIntegrationPlugin CONDITION QT_FEATURE_accessibility
-    SOURCES
-        ../windows/uiautomation/qwindowsuiaaccessibility.cpp ../windows/uiautomation/qwindowsuiaaccessibility.h
-        ../windows/uiautomation/qwindowsuiabaseprovider.cpp ../windows/uiautomation/qwindowsuiabaseprovider.h
-        ../windows/uiautomation/qwindowsuiaexpandcollapseprovider.cpp ../windows/uiautomation/qwindowsuiaexpandcollapseprovider.h
-        ../windows/uiautomation/qwindowsuiagriditemprovider.cpp ../windows/uiautomation/qwindowsuiagriditemprovider.h
-        ../windows/uiautomation/qwindowsuiagridprovider.cpp ../windows/uiautomation/qwindowsuiagridprovider.h
-        ../windows/uiautomation/qwindowsuiainvokeprovider.cpp ../windows/uiautomation/qwindowsuiainvokeprovider.h
-        ../windows/uiautomation/qwindowsuiamainprovider.cpp ../windows/uiautomation/qwindowsuiamainprovider.h
-        ../windows/uiautomation/qwindowsuiaprovidercache.cpp ../windows/uiautomation/qwindowsuiaprovidercache.h
-        ../windows/uiautomation/qwindowsuiarangevalueprovider.cpp ../windows/uiautomation/qwindowsuiarangevalueprovider.h
-        ../windows/uiautomation/qwindowsuiaselectionitemprovider.cpp ../windows/uiautomation/qwindowsuiaselectionitemprovider.h
-        ../windows/uiautomation/qwindowsuiaselectionprovider.cpp ../windows/uiautomation/qwindowsuiaselectionprovider.h
-        ../windows/uiautomation/qwindowsuiatableitemprovider.cpp ../windows/uiautomation/qwindowsuiatableitemprovider.h
-        ../windows/uiautomation/qwindowsuiatableprovider.cpp ../windows/uiautomation/qwindowsuiatableprovider.h
-        ../windows/uiautomation/qwindowsuiatextprovider.cpp ../windows/uiautomation/qwindowsuiatextprovider.h
-        ../windows/uiautomation/qwindowsuiatextrangeprovider.cpp ../windows/uiautomation/qwindowsuiatextrangeprovider.h
-        ../windows/uiautomation/qwindowsuiatoggleprovider.cpp ../windows/uiautomation/qwindowsuiatoggleprovider.h
-        ../windows/uiautomation/qwindowsuiautils.cpp ../windows/uiautomation/qwindowsuiautils.h
-        ../windows/uiautomation/qwindowsuiavalueprovider.cpp ../windows/uiautomation/qwindowsuiavalueprovider.h
-        ../windows/uiautomation/qwindowsuiawindowprovider.cpp ../windows/uiautomation/qwindowsuiawindowprovider.h
-)
-
-qt_internal_extend_target(QWindowsDirect2DIntegrationPlugin CONDITION MINGW AND QT_FEATURE_accessibility
-    LIBRARIES
-        uuid
-)
-
-# begin special case
-if (MINGW)
-    set_source_files_properties(../windows/qwindowspointerhandler.cpp PROPERTIES SKIP_PRECOMPILE_HEADERS ON)
-endif()
-# end special case
diff --git a/src/plugins/platforms/direct2d/direct2d.json b/src/plugins/platforms/direct2d/direct2d.json
deleted file mode 100644
index aaea92f0ef..0000000000
--- a/src/plugins/platforms/direct2d/direct2d.json
+++ /dev/null
@@ -1,3 +0,0 @@
-{
-    "Keys": [ "direct2d" ]
-}
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dbackingstore.cpp b/src/plugins/platforms/direct2d/qwindowsdirect2dbackingstore.cpp
deleted file mode 100644
index 7ababe6c65..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dbackingstore.cpp
+++ /dev/null
@@ -1,103 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include "qwindowsdirect2dbackingstore.h"
-#include "qwindowsdirect2dplatformpixmap.h"
-#include "qwindowsdirect2dintegration.h"
-#include "qwindowsdirect2dcontext.h"
-#include "qwindowsdirect2dpaintdevice.h"
-#include "qwindowsdirect2dbitmap.h"
-#include "qwindowsdirect2ddevicecontext.h"
-#include "qwindowsdirect2dwindow.h"
-
-#include "qwindowscontext.h"
-
-#include <QtGui/qpainter.h>
-#include <QtGui/qwindow.h>
-#include <QtCore/qdebug.h>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QWindowsDirect2DBackingStore
-    \brief Backing store for windows.
-    \internal
-*/
-
-static inline QWindowsDirect2DPlatformPixmap *platformPixmap(QPixmap *p)
-{
-    return static_cast<QWindowsDirect2DPlatformPixmap *>(p->handle());
-}
-
-static inline QWindowsDirect2DBitmap *bitmap(QPixmap *p)
-{
-    return platformPixmap(p)->bitmap();
-}
-
-static inline QWindowsDirect2DWindow *nativeWindow(QWindow *window)
-{
-    return static_cast<QWindowsDirect2DWindow *>(window->handle());
-}
-
-QWindowsDirect2DBackingStore::QWindowsDirect2DBackingStore(QWindow *window)
-    : QPlatformBackingStore(window)
-{
-}
-
-QWindowsDirect2DBackingStore::~QWindowsDirect2DBackingStore()
-{
-}
-
-void QWindowsDirect2DBackingStore::beginPaint(const QRegion &region)
-{
-    QPixmap *pixmap = nativeWindow(window())->pixmap();
-    bitmap(pixmap)->deviceContext()->begin();
-
-    QPainter painter(pixmap);
-    QColor clear(Qt::transparent);
-
-    painter.setCompositionMode(QPainter::CompositionMode_Source);
-
-    for (const QRect &r : region)
-        painter.fillRect(r, clear);
-}
-
-void QWindowsDirect2DBackingStore::endPaint()
-{
-    bitmap(nativeWindow(window())->pixmap())->deviceContext()->end();
-}
-
-QPaintDevice *QWindowsDirect2DBackingStore::paintDevice()
-{
-    return nativeWindow(window())->pixmap();
-}
-
-void QWindowsDirect2DBackingStore::flush(QWindow *targetWindow, const QRegion &region, const QPoint &offset)
-{
-    if (targetWindow != window()) {
-        QSharedPointer<QWindowsDirect2DBitmap> copy(nativeWindow(window())->copyBackBuffer());
-        nativeWindow(targetWindow)->flush(copy.data(), region, offset);
-    }
-
-    nativeWindow(targetWindow)->present(region);
-}
-
-void QWindowsDirect2DBackingStore::resize(const QSize &size, const QRegion &region)
-{
-    QPixmap old = nativeWindow(window())->pixmap()->copy();
-
-    nativeWindow(window())->resizeSwapChain(size);
-    QPixmap *newPixmap = nativeWindow(window())->pixmap();
-
-    if (!old.isNull()) {
-        for (const QRect &rect : region)
-            platformPixmap(newPixmap)->copy(old.handle(), rect);
-    }
-}
-
-QImage QWindowsDirect2DBackingStore::toImage() const
-{
-    return nativeWindow(window())->pixmap()->toImage();
-}
-
-QT_END_NAMESPACE
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dbackingstore.h b/src/plugins/platforms/direct2d/qwindowsdirect2dbackingstore.h
deleted file mode 100644
index 5ca4580c21..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dbackingstore.h
+++ /dev/null
@@ -1,33 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QWINDOWSDIRECT2DBACKINGSTORE_H
-#define QWINDOWSDIRECT2DBACKINGSTORE_H
-
-#include <QtGui/qpa/qplatformbackingstore.h>
-
-QT_BEGIN_NAMESPACE
-
-class QWindowsDirect2DWindow;
-
-class QWindowsDirect2DBackingStore : public QPlatformBackingStore
-{
-    Q_DISABLE_COPY_MOVE(QWindowsDirect2DBackingStore)
-
-public:
-    QWindowsDirect2DBackingStore(QWindow *window);
-    ~QWindowsDirect2DBackingStore();
-
-    void beginPaint(const QRegion &) override;
-    void endPaint() override;
-
-    QPaintDevice *paintDevice() override;
-    void flush(QWindow *targetWindow, const QRegion &region, const QPoint &offset) override;
-    void resize(const QSize &size, const QRegion &staticContents) override;
-
-    QImage toImage() const override;
-};
-
-QT_END_NAMESPACE
-
-#endif // QWINDOWSDIRECT2DBACKINGSTORE_H
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dbitmap.cpp b/src/plugins/platforms/direct2d/qwindowsdirect2dbitmap.cpp
deleted file mode 100644
index 310053eedc..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dbitmap.cpp
+++ /dev/null
@@ -1,172 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include "qwindowsdirect2dbitmap.h"
-#include "qwindowsdirect2dcontext.h"
-#include "qwindowsdirect2dhelpers.h"
-#include "qwindowsdirect2ddevicecontext.h"
-
-#include <QtGui/qimage.h>
-#include <QtGui/qcolor.h>
-
-#include <wrl.h>
-
-using Microsoft::WRL::ComPtr;
-
-QT_BEGIN_NAMESPACE
-
-class QWindowsDirect2DBitmapPrivate
-{
-public:
-    QWindowsDirect2DBitmapPrivate(ID2D1DeviceContext *dc = nullptr,
-                                  ID2D1Bitmap1 *bm = nullptr)
-        : deviceContext(new QWindowsDirect2DDeviceContext(dc))
-        , bitmap(bm)
-
-    {
-        deviceContext->get()->SetTarget(bm);
-    }
-
-    D2D1_BITMAP_PROPERTIES1 bitmapProperties() const
-    {
-QT_WARNING_PUSH
-QT_WARNING_DISABLE_DEPRECATED // see QTBUG-94043
-        FLOAT dpiX, dpiY;
-        QWindowsDirect2DContext::instance()->d2dFactory()->GetDesktopDpi(&dpiX, &dpiY);
-QT_WARNING_POP
-
-        return D2D1::BitmapProperties1(
-                    D2D1_BITMAP_OPTIONS_TARGET,
-                    D2D1::PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM,
-                                      D2D1_ALPHA_MODE_PREMULTIPLIED),
-                    dpiX, dpiY);
-
-    }
-
-    bool resize(int width, int height, const void *data = nullptr, int pitch = 0)
-    {
-        deviceContext->get()->SetTarget(nullptr);
-        bitmap.Reset();
-
-        D2D1_SIZE_U size = {
-            UINT32(width), UINT32(height)
-        };
-
-        HRESULT hr = deviceContext->get()->CreateBitmap(size, data, UINT32(pitch),
-                                                        bitmapProperties(),
-                                                        bitmap.ReleaseAndGetAddressOf());
-        if (SUCCEEDED(hr))
-            deviceContext->get()->SetTarget(bitmap.Get());
-        else
-            qWarning("%s: Could not create bitmap: %#lx", __FUNCTION__, hr);
-
-        return SUCCEEDED(hr);
-    }
-
-    QImage toImage(const QRect &rect)
-    {
-        if (!bitmap)
-            return QImage();
-
-        ComPtr<ID2D1Bitmap1> mappingCopy;
-
-        HRESULT hr = S_OK;
-        D2D1_SIZE_U size = bitmap->GetPixelSize();
-
-        D2D1_BITMAP_PROPERTIES1 properties = bitmapProperties();
-        properties.bitmapOptions = D2D1_BITMAP_OPTIONS_CANNOT_DRAW | D2D1_BITMAP_OPTIONS_CPU_READ;
-
-        hr = deviceContext->get()->CreateBitmap(size, nullptr, 0,
-                                                properties, &mappingCopy);
-        if (FAILED(hr)) {
-            qWarning("%s: Could not create bitmap: %#lx", __FUNCTION__, hr);
-            return QImage();
-        }
-
-        hr = mappingCopy->CopyFromBitmap(nullptr, bitmap.Get(), nullptr);
-        if (FAILED(hr)) {
-            qWarning("%s: Could not copy from bitmap: %#lx", __FUNCTION__, hr);
-            return QImage();
-        }
-
-        D2D1_MAPPED_RECT mappedRect;
-        hr = mappingCopy->Map(D2D1_MAP_OPTIONS_READ, &mappedRect);
-        if (FAILED(hr)) {
-            qWarning("%s: Could not map: %#lx", __FUNCTION__, hr);
-            return QImage();
-        }
-
-        return QImage(static_cast<const uchar *>(mappedRect.bits),
-                      int(size.width), int(size.height), int(mappedRect.pitch),
-                      QImage::Format_ARGB32_Premultiplied).copy(rect);
-    }
-
-    QScopedPointer<QWindowsDirect2DDeviceContext> deviceContext;
-    ComPtr<ID2D1Bitmap1> bitmap;
-};
-
-QWindowsDirect2DBitmap::QWindowsDirect2DBitmap()
-    : d_ptr(new QWindowsDirect2DBitmapPrivate)
-{
-}
-
-QWindowsDirect2DBitmap::QWindowsDirect2DBitmap(ID2D1Bitmap1 *bitmap, ID2D1DeviceContext *dc)
-    : d_ptr(new QWindowsDirect2DBitmapPrivate(dc, bitmap))
-{
-}
-
-QWindowsDirect2DBitmap::~QWindowsDirect2DBitmap()
-{
-}
-
-bool QWindowsDirect2DBitmap::resize(int width, int height)
-{
-    Q_D(QWindowsDirect2DBitmap);
-    return d->resize(width, height);
-}
-
-bool QWindowsDirect2DBitmap::fromImage(const QImage &image, Qt::ImageConversionFlags flags)
-{
-    Q_D(QWindowsDirect2DBitmap);
-
-    QImage converted = image.convertToFormat(QImage::Format_ARGB32_Premultiplied, flags);
-    return d->resize(converted.width(), converted.height(),
-                     converted.constBits(), converted.bytesPerLine());
-}
-
-ID2D1Bitmap1* QWindowsDirect2DBitmap::bitmap() const
-{
-    Q_D(const QWindowsDirect2DBitmap);
-    return d->bitmap.Get();
-}
-
-QWindowsDirect2DDeviceContext *QWindowsDirect2DBitmap::deviceContext() const
-{
-    Q_D(const QWindowsDirect2DBitmap);
-    return d->deviceContext.data();
-}
-
-void QWindowsDirect2DBitmap::fill(const QColor &color)
-{
-    Q_D(QWindowsDirect2DBitmap);
-
-    d->deviceContext->begin();
-    d->deviceContext->get()->Clear(to_d2d_color_f(color));
-    d->deviceContext->end();
-}
-
-QImage QWindowsDirect2DBitmap::toImage(const QRect &rect)
-{
-    Q_D(QWindowsDirect2DBitmap);
-    return d->toImage(rect);
-}
-
-QSize QWindowsDirect2DBitmap::size() const
-{
-    Q_D(const QWindowsDirect2DBitmap);
-
-    D2D1_SIZE_U size = d->bitmap->GetPixelSize();
-    return QSize(int(size.width), int(size.height));
-}
-
-QT_END_NAMESPACE
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dbitmap.h b/src/plugins/platforms/direct2d/qwindowsdirect2dbitmap.h
deleted file mode 100644
index 206121f8bd..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dbitmap.h
+++ /dev/null
@@ -1,49 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QWINDOWSDIRECT2DBITMAP_H
-#define QWINDOWSDIRECT2DBITMAP_H
-
-#include <QtCore/qnamespace.h>
-#include <QtCore/qrect.h>
-#include <QtCore/qscopedpointer.h>
-
-struct ID2D1DeviceContext;
-struct ID2D1Bitmap1;
-
-QT_BEGIN_NAMESPACE
-
-class QWindowsDirect2DDeviceContext;
-class QWindowsDirect2DBitmapPrivate;
-
-class QImage;
-class QSize;
-class QColor;
-
-class QWindowsDirect2DBitmap
-{
-    Q_DECLARE_PRIVATE(QWindowsDirect2DBitmap)
-    Q_DISABLE_COPY_MOVE(QWindowsDirect2DBitmap)
-public:
-    QWindowsDirect2DBitmap();
-    QWindowsDirect2DBitmap(ID2D1Bitmap1 *bitmap, ID2D1DeviceContext *dc);
-    ~QWindowsDirect2DBitmap();
-
-    bool resize(int width, int height);
-    bool fromImage(const QImage &image, Qt::ImageConversionFlags flags);
-
-    ID2D1Bitmap1* bitmap() const;
-    QWindowsDirect2DDeviceContext* deviceContext() const;
-
-    void fill(const QColor &color);
-    QImage toImage(const QRect &rect = QRect());
-
-    QSize size() const;
-
-private:
-    QScopedPointer<QWindowsDirect2DBitmapPrivate> d_ptr;
-};
-
-QT_END_NAMESPACE
-
-#endif // QWINDOWSDIRECT2DBITMAP_H
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dcontext.cpp b/src/plugins/platforms/direct2d/qwindowsdirect2dcontext.cpp
deleted file mode 100644
index 307ca2e550..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dcontext.cpp
+++ /dev/null
@@ -1,184 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include <QtCore/qt_windows.h>
-#include "qwindowsdirect2dcontext.h"
-#include "qwindowsdirect2dhelpers.h"
-#include "qwindowsdirect2dintegration.h"
-
-#include <d3d11_1.h>
-#include <d2d1_1.h>
-#include <d2d1_1helper.h>
-#include <dxgi1_2.h>
-#include <wrl.h>
-#include <dwrite.h>
-
-using Microsoft::WRL::ComPtr;
-
-QT_BEGIN_NAMESPACE
-
-class QWindowsDirect2DContextPrivate
-{
-public:
-    bool init()
-    {
-        HRESULT hr;
-
-        D3D_FEATURE_LEVEL level;
-
-        D3D_DRIVER_TYPE typeAttempts[] = {
-            D3D_DRIVER_TYPE_HARDWARE,
-            D3D_DRIVER_TYPE_WARP
-        };
-        const int ntypes = int(sizeof(typeAttempts) / sizeof(typeAttempts[0]));
-
-        for (int i = 0; i < ntypes; i++) {
-            hr = D3D11CreateDevice(nullptr,
-                                   typeAttempts[i],
-                                   nullptr,
-                                   D3D11_CREATE_DEVICE_SINGLETHREADED | D3D11_CREATE_DEVICE_BGRA_SUPPORT,
-                                   nullptr,
-                                   0,
-                                   D3D11_SDK_VERSION,
-                                   &d3dDevice,
-                                   &level,
-                                   &d3dDeviceContext);
-
-            if (SUCCEEDED(hr))
-                break;
-        }
-
-        if (FAILED(hr)) {
-            qWarning("%s: Could not create Direct3D Device: %#lx", __FUNCTION__, hr);
-            return false;
-        }
-
-        ComPtr<IDXGIDevice1> dxgiDevice;
-        ComPtr<IDXGIAdapter> dxgiAdapter;
-
-        hr = d3dDevice.As(&dxgiDevice);
-        if (FAILED(hr)) {
-            qWarning("%s: DXGI Device interface query failed on D3D Device: %#lx", __FUNCTION__, hr);
-            return false;
-        }
-
-        // Ensure that DXGI doesn't queue more than one frame at a time.
-        dxgiDevice->SetMaximumFrameLatency(1);
-
-        hr = dxgiDevice->GetAdapter(&dxgiAdapter);
-        if (FAILED(hr)) {
-            qWarning("%s: Failed to probe DXGI Device for parent DXGI Adapter: %#lx", __FUNCTION__, hr);
-            return false;
-        }
-
-        hr = dxgiAdapter->GetParent(IID_PPV_ARGS(&dxgiFactory));
-        if (FAILED(hr)) {
-            qWarning("%s: Failed to probe DXGI Adapter for parent DXGI Factory: %#lx", __FUNCTION__, hr);
-            return false;
-        }
-
-        D2D1_FACTORY_OPTIONS options = {};
-
-#ifdef QT_D2D_DEBUG_OUTPUT
-        qDebug("Turning on Direct2D debugging messages");
-        options.debugLevel = D2D1_DEBUG_LEVEL_INFORMATION;
-#endif // QT_D2D_DEBUG_OUTPUT
-
-        hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, options, d2dFactory.GetAddressOf());
-        if (FAILED(hr)) {
-            qWarning("%s: Could not create Direct2D Factory: %#lx", __FUNCTION__, hr);
-            return false;
-        }
-
-        hr = d2dFactory->CreateDevice(dxgiDevice.Get(), &d2dDevice);
-        if (FAILED(hr)) {
-            qWarning("%s: Could not create D2D Device: %#lx", __FUNCTION__, hr);
-            return false;
-        }
-
-        hr = DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
-                                 static_cast<IUnknown **>(&directWriteFactory));
-        if (FAILED(hr)) {
-            qWarning("%s: Could not create DirectWrite factory: %#lx", __FUNCTION__, hr);
-            return false;
-        }
-
-        hr = directWriteFactory->GetGdiInterop(&directWriteGdiInterop);
-        if (FAILED(hr)) {
-            qWarning("%s: Could not create DirectWrite GDI Interop: %#lx", __FUNCTION__, hr);
-            return false;
-        }
-
-        return true;
-    }
-
-    ComPtr<ID3D11Device>  d3dDevice;
-    ComPtr<ID2D1Factory1> d2dFactory;
-    ComPtr<ID2D1Device>   d2dDevice;
-    ComPtr<IDXGIFactory2>  dxgiFactory;
-    ComPtr<ID3D11DeviceContext> d3dDeviceContext;
-    ComPtr<IDWriteFactory> directWriteFactory;
-    ComPtr<IDWriteGdiInterop> directWriteGdiInterop;
-};
-
-QWindowsDirect2DContext::QWindowsDirect2DContext()
-    : d_ptr(new QWindowsDirect2DContextPrivate)
-{
-}
-
-QWindowsDirect2DContext::~QWindowsDirect2DContext() = default;
-
-bool QWindowsDirect2DContext::init()
-{
-    Q_D(QWindowsDirect2DContext);
-    return d->init();
-}
-
-QWindowsDirect2DContext *QWindowsDirect2DContext::instance()
-{
-    return QWindowsDirect2DIntegration::instance()->direct2DContext();
-}
-
-ID3D11Device *QWindowsDirect2DContext::d3dDevice() const
-{
-    Q_D(const QWindowsDirect2DContext);
-    return d->d3dDevice.Get();
-}
-
-ID2D1Device *QWindowsDirect2DContext::d2dDevice() const
-{
-    Q_D(const QWindowsDirect2DContext);
-    return d->d2dDevice.Get();
-}
-
-ID2D1Factory1 *QWindowsDirect2DContext::d2dFactory() const
-{
-    Q_D(const QWindowsDirect2DContext);
-    return d->d2dFactory.Get();
-}
-
-IDXGIFactory2 *QWindowsDirect2DContext::dxgiFactory() const
-{
-    Q_D(const QWindowsDirect2DContext);
-    return d->dxgiFactory.Get();
-}
-
-ID3D11DeviceContext *QWindowsDirect2DContext::d3dDeviceContext() const
-{
-    Q_D(const QWindowsDirect2DContext);
-    return d->d3dDeviceContext.Get();
-}
-
-IDWriteFactory *QWindowsDirect2DContext::dwriteFactory() const
-{
-    Q_D(const QWindowsDirect2DContext);
-    return d->directWriteFactory.Get();
-}
-
-IDWriteGdiInterop *QWindowsDirect2DContext::dwriteGdiInterop() const
-{
-    Q_D(const QWindowsDirect2DContext);
-    return d->directWriteGdiInterop.Get();
-}
-
-QT_END_NAMESPACE
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dcontext.h b/src/plugins/platforms/direct2d/qwindowsdirect2dcontext.h
deleted file mode 100644
index 360582ff93..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dcontext.h
+++ /dev/null
@@ -1,46 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QWINDOWSDIRECT2DCONTEXT_H
-#define QWINDOWSDIRECT2DCONTEXT_H
-
-#include <QtCore/qscopedpointer.h>
-
-struct ID3D11Device;
-struct ID2D1Device;
-struct ID2D1Factory1;
-struct IDXGIFactory2;
-struct ID3D11DeviceContext;
-struct IDWriteFactory;
-struct IDWriteGdiInterop;
-
-QT_BEGIN_NAMESPACE
-
-class QWindowsDirect2DContextPrivate;
-class QWindowsDirect2DContext
-{
-    Q_DECLARE_PRIVATE( QWindowsDirect2DContext )
-
-public:
-    QWindowsDirect2DContext();
-    ~QWindowsDirect2DContext();
-
-    bool init();
-
-    static QWindowsDirect2DContext *instance();
-
-    ID3D11Device *d3dDevice() const;
-    ID2D1Device *d2dDevice() const;
-    ID2D1Factory1 *d2dFactory() const;
-    IDXGIFactory2 *dxgiFactory() const;
-    ID3D11DeviceContext *d3dDeviceContext() const;
-    IDWriteFactory *dwriteFactory() const;
-    IDWriteGdiInterop *dwriteGdiInterop() const;
-
-private:
-    QScopedPointer<QWindowsDirect2DContextPrivate> d_ptr;
-};
-
-QT_END_NAMESPACE
-
-#endif // QWINDOWSDIRECT2DCONTEXT_H
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2ddevicecontext.cpp b/src/plugins/platforms/direct2d/qwindowsdirect2ddevicecontext.cpp
deleted file mode 100644
index 2eb6e2c36d..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2ddevicecontext.cpp
+++ /dev/null
@@ -1,132 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include "qwindowsdirect2dcontext.h"
-#include "qwindowsdirect2dhelpers.h"
-#include "qwindowsdirect2ddevicecontext.h"
-
-#include <wrl.h>
-
-using Microsoft::WRL::ComPtr;
-
-QT_BEGIN_NAMESPACE
-
-class QWindowsDirect2DDeviceContextPrivate {
-public:
-    QWindowsDirect2DDeviceContextPrivate(ID2D1DeviceContext *dc)
-        : deviceContext(dc)
-    {
-        if (!dc) {
-            HRESULT hr = QWindowsDirect2DContext::instance()->d2dDevice()->CreateDeviceContext(
-                        D2D1_DEVICE_CONTEXT_OPTIONS_NONE,
-                        &deviceContext);
-            if (Q_UNLIKELY(FAILED(hr)))
-                qFatal("%s: Couldn't create Direct2D Device Context: %#lx", __FUNCTION__, hr);
-        }
-
-        Q_ASSERT(deviceContext);
-        deviceContext->SetUnitMode(D2D1_UNIT_MODE_PIXELS);
-    }
-
-    void begin()
-    {
-        Q_ASSERT(deviceContext);
-        Q_ASSERT(refCount >= 0);
-
-        if (refCount == 0)
-            deviceContext->BeginDraw();
-
-        refCount++;
-    }
-
-    bool end()
-    {
-        Q_ASSERT(deviceContext);
-        Q_ASSERT(refCount > 0);
-
-        bool success = true;
-        refCount--;
-
-        if (refCount == 0) {
-            D2D1_TAG tag1, tag2;
-            HRESULT hr = deviceContext->EndDraw(&tag1, &tag2);
-
-            if (FAILED(hr)) {
-                success = false;
-                qWarning("%s: EndDraw failed: %#lx, tag1: %lld, tag2: %lld",
-                         __FUNCTION__, long(hr), tag1, tag2);
-            }
-        }
-
-        return success;
-    }
-
-    ComPtr<ID2D1DeviceContext> deviceContext;
-    int refCount = 0;
-};
-
-QWindowsDirect2DDeviceContext::QWindowsDirect2DDeviceContext(ID2D1DeviceContext *dc)
-    : d_ptr(new QWindowsDirect2DDeviceContextPrivate(dc))
-{
-}
-
-QWindowsDirect2DDeviceContext::~QWindowsDirect2DDeviceContext()
-{
-
-}
-
-ID2D1DeviceContext *QWindowsDirect2DDeviceContext::get() const
-{
-    Q_D(const QWindowsDirect2DDeviceContext);
-    Q_ASSERT(d->deviceContext);
-
-    return d->deviceContext.Get();
-}
-
-void QWindowsDirect2DDeviceContext::begin()
-{
-    Q_D(QWindowsDirect2DDeviceContext);
-    d->begin();
-}
-
-bool QWindowsDirect2DDeviceContext::end()
-{
-    Q_D(QWindowsDirect2DDeviceContext);
-    return d->end();
-}
-
-void QWindowsDirect2DDeviceContext::suspend()
-{
-    Q_D(QWindowsDirect2DDeviceContext);
-    if (d->refCount > 0)
-        d->deviceContext->EndDraw();
-}
-
-void QWindowsDirect2DDeviceContext::resume()
-{
-    Q_D(QWindowsDirect2DDeviceContext);
-    if (d->refCount > 0)
-        d->deviceContext->BeginDraw();
-}
-
-QWindowsDirect2DDeviceContextSuspender::QWindowsDirect2DDeviceContextSuspender(QWindowsDirect2DDeviceContext *dc)
-    : m_dc(dc)
-{
-    Q_ASSERT(m_dc);
-    m_dc->suspend();
-}
-
-QWindowsDirect2DDeviceContextSuspender::~QWindowsDirect2DDeviceContextSuspender()
-{
-    resume();
-}
-
-void QWindowsDirect2DDeviceContextSuspender::resume()
-{
-    if (m_dc) {
-        m_dc->resume();
-        m_dc = nullptr;
-    }
-}
-
-QT_END_NAMESPACE
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2ddevicecontext.h b/src/plugins/platforms/direct2d/qwindowsdirect2ddevicecontext.h
deleted file mode 100644
index 9cc0691954..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2ddevicecontext.h
+++ /dev/null
@@ -1,70 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QWINDOWSDIRECT2DDEVICECONTEXT_H
-#define QWINDOWSDIRECT2DDEVICECONTEXT_H
-
-#include <QtCore/qscopedpointer.h>
-
-QT_BEGIN_NAMESPACE
-
-/*
- * Convenience class for handling device contexts. We have to call BeginDraw
- * before anything can happen, and EndDraw once we're done, for every frame and
- * pretty much any kind of operation.
- *
- * Unfortunately, these calls cannot be interleaved, and there is no way to check
- * what state a device context is in.
- *
- * The end result is that the following throws an error if we don't track it:
- *      QPixmap pmap;
- *      QPainter painter(&pmap);
- *      pmap.clear();
- *
- * Here BeginDraw would first be called through the paint device, then when we clear
- * the pixmap we would have to call it again. There is no way to know what state
- * the device context is in when performing the clear, and activating the dc is an
- * error. Bummer.
- *
- * Hence we keep a reference count here and only activate/deactivate the device
- * if the refcount is zero.
- *
- * In a nutshell: Do not call BeginDraw/EndDraw yourself on the device pointer, do
- * so through the begin/end members below.
- */
-
-class QWindowsDirect2DDeviceContextPrivate;
-class QWindowsDirect2DDeviceContext
-{
-    Q_DECLARE_PRIVATE(QWindowsDirect2DDeviceContext)
-    friend class QWindowsDirect2DDeviceContextSuspender;
-public:
-    QWindowsDirect2DDeviceContext(ID2D1DeviceContext *dc);
-    ~QWindowsDirect2DDeviceContext();
-
-    ID2D1DeviceContext *get() const;
-
-    void begin();
-    bool end();
-
-private:
-    void suspend();
-    void resume();
-
-    QScopedPointer<QWindowsDirect2DDeviceContextPrivate> d_ptr;
-};
-
-class QWindowsDirect2DDeviceContextSuspender {
-    Q_DISABLE_COPY_MOVE(QWindowsDirect2DDeviceContextSuspender)
-
-    QWindowsDirect2DDeviceContext *m_dc;
-public:
-    QWindowsDirect2DDeviceContextSuspender(QWindowsDirect2DDeviceContext *dc);
-    ~QWindowsDirect2DDeviceContextSuspender();
-
-    void resume();
-};
-
-QT_END_NAMESPACE
-
-#endif // QWINDOWSDIRECT2DDEVICECONTEXT_H
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dhelpers.h b/src/plugins/platforms/direct2d/qwindowsdirect2dhelpers.h
deleted file mode 100644
index 07924332cd..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dhelpers.h
+++ /dev/null
@@ -1,66 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QWINDOWSDIRECT2DHELPERS_H
-#define QWINDOWSDIRECT2DHELPERS_H
-
-#include <QtCore/qrect.h>
-#include <QtCore/qsize.h>
-#include <QtCore/qpoint.h>
-#include <QtGui/qcolor.h>
-#include <QtGui/qtransform.h>
-
-#ifdef Q_CC_MINGW
-#  include <qt_windows.h>
-#  include <d2d1.h>
-#  include <d2d1helper.h>
-#  include <d2dbasetypes.h>
-#  include <d2d1_1.h>
-#endif // Q_CC_MINGW
-#include <d2d1_1helper.h>
-
-QT_BEGIN_NAMESPACE
-
-inline D2D1_RECT_U to_d2d_rect_u(const QRect &qrect)
-{
-    return D2D1::RectU(qrect.x(), qrect.y(), qrect.x() + qrect.width(), qrect.y() + qrect.height());
-}
-
-inline D2D1_RECT_F to_d2d_rect_f(const QRectF &qrect)
-{
-    return D2D1::RectF(qrect.x(), qrect.y(), qrect.x() + qrect.width(), qrect.y() + qrect.height());
-}
-
-inline D2D1_SIZE_U to_d2d_size_u(const QSizeF &qsize)
-{
-
-    return D2D1::SizeU(UINT32(qRound(qsize.width())),
-                       UINT32(qRound(qsize.height())));
-}
-
-inline D2D1_SIZE_U to_d2d_size_u(const QSize &qsize)
-{
-    return D2D1::SizeU(UINT32(qsize.width()),
-                       UINT32(qsize.height()));
-}
-
-inline D2D1_POINT_2F to_d2d_point_2f(const QPointF &qpoint)
-{
-    return D2D1::Point2F(qpoint.x(), qpoint.y());
-}
-
-inline D2D1::ColorF to_d2d_color_f(const QColor &c)
-{
-    return D2D1::ColorF(c.redF(), c.greenF(), c.blueF(), c.alphaF());
-}
-
-inline D2D1_MATRIX_3X2_F to_d2d_matrix_3x2_f(const QTransform &transform)
-{
-    return D2D1::Matrix3x2F(transform.m11(), transform.m12(),
-                            transform.m21(), transform.m22(),
-                            transform.m31(), transform.m32());
-}
-
-QT_END_NAMESPACE
-
-#endif // QWINDOWSDIRECT2DHELPERS_H
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dintegration.cpp b/src/plugins/platforms/direct2d/qwindowsdirect2dintegration.cpp
deleted file mode 100644
index a5fbb7ad5a..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dintegration.cpp
+++ /dev/null
@@ -1,161 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include <QtCore/qt_windows.h>
-#include "qwindowsdirect2dcontext.h"
-#include "qwindowsdirect2dintegration.h"
-#include "qwindowsdirect2dbackingstore.h"
-#include "qwindowsdirect2dplatformpixmap.h"
-#include "qwindowsdirect2dnativeinterface.h"
-#include "qwindowsdirect2dwindow.h"
-
-#include "qwindowscontext.h"
-
-#include <qplatformdefs.h>
-#include <QtCore/qcoreapplication.h>
-#include <QtCore/qversionnumber.h>
-#include <QtGui/private/qpixmap_raster_p.h>
-#include <QtGui/qpa/qwindowsysteminterface.h>
-
-#include <QVarLengthArray>
-
-QT_BEGIN_NAMESPACE
-
-class QWindowsDirect2DIntegrationPrivate
-{
-public:
-    QWindowsDirect2DNativeInterface m_nativeInterface;
-    QWindowsDirect2DContext m_d2dContext;
-};
-
-static QVersionNumber systemD2DVersion()
-{
-    static const int bufSize = 512;
-    TCHAR filename[bufSize];
-
-    UINT i = GetSystemDirectory(filename, bufSize);
-    if (i > 0 && i < bufSize) {
-        if (_tcscat_s(filename, bufSize, __TEXT("\\d2d1.dll")) == 0) {
-            DWORD versionInfoSize = GetFileVersionInfoSize(filename, nullptr);
-            if (versionInfoSize) {
-                QVarLengthArray<BYTE> info(static_cast<int>(versionInfoSize));
-                if (GetFileVersionInfo(filename, 0, versionInfoSize, info.data())) {
-                    UINT size;
-                    DWORD *fi;
-
-                    if (VerQueryValue(info.constData(), __TEXT("\\"),
-                                      reinterpret_cast<void **>(&fi), &size) && size) {
-                        const auto *verInfo = reinterpret_cast<const VS_FIXEDFILEINFO *>(fi);
-                        return QVersionNumber{HIWORD(verInfo->dwFileVersionMS), LOWORD(verInfo->dwFileVersionMS),
-                                              HIWORD(verInfo->dwFileVersionLS), LOWORD(verInfo->dwFileVersionLS)};
-                    }
-                }
-            }
-        }
-    }
-    return QVersionNumber();
-}
-
-static QVersionNumber minimumD2DVersion()
-{
-    // 6.2.9200.16492 corresponds to Direct2D 1.1 on Windows 7 SP1 with Platform Update
-    enum : int {
-        D2DMinVersionPart1 = 6,
-        D2DMinVersionPart2 = 2,
-        D2DMinVersionPart3 = 9200,
-        D2DMinVersionPart4 = 16492
-    };
-
-    return QVersionNumber{D2DMinVersionPart1, D2DMinVersionPart2, D2DMinVersionPart3, D2DMinVersionPart4};
-}
-
-QWindowsDirect2DIntegration *QWindowsDirect2DIntegration::create(const QStringList &paramList)
-{
-    const QVersionNumber systemVersion = systemD2DVersion();
-    const QVersionNumber minimumVersion = minimumD2DVersion();
-    if (!systemVersion.isNull() && systemVersion < minimumVersion) {
-        QString msg = QCoreApplication::translate("QWindowsDirect2DIntegration",
-            "Qt cannot load the direct2d platform plugin because " \
-            "the Direct2D version on this system is too old. The " \
-            "minimum system requirement for this platform plugin " \
-            "is Windows 7 SP1 with Platform Update.\n\n" \
-            "The minimum Direct2D version required is %1. " \
-            "The Direct2D version on this system is %2.")
-            .arg(minimumVersion.toString(), systemVersion.toString());
-
-        QString caption = QCoreApplication::translate("QWindowsDirect2DIntegration",
-            "Cannot load direct2d platform plugin");
-
-        MessageBoxW(nullptr,
-                    msg.toStdWString().c_str(),
-                    caption.toStdWString().c_str(),
-                    MB_OK | MB_ICONERROR);
-
-        return nullptr;
-    }
-
-    auto *integration = new QWindowsDirect2DIntegration(paramList);
-
-    if (!integration->init()) {
-        delete integration;
-        integration = nullptr;
-    }
-
-    return integration;
-}
-
-QWindowsDirect2DIntegration::~QWindowsDirect2DIntegration()
-{
-
-}
-
- QWindowsDirect2DIntegration *QWindowsDirect2DIntegration::instance()
- {
-     return static_cast<QWindowsDirect2DIntegration *>(QWindowsIntegration::instance());
- }
-
-
-QWindowsWindow *QWindowsDirect2DIntegration::createPlatformWindowHelper(QWindow *window, const QWindowsWindowData &data) const
-{
-    return new QWindowsDirect2DWindow(window, data);
-}
-
- QPlatformNativeInterface *QWindowsDirect2DIntegration::nativeInterface() const
- {
-     return &d->m_nativeInterface;
- }
-
-QPlatformPixmap *QWindowsDirect2DIntegration::createPlatformPixmap(QPlatformPixmap::PixelType type) const
-{
-    switch (type) {
-    case QPlatformPixmap::BitmapType:
-        return new QRasterPlatformPixmap(type);
-        break;
-    default:
-        return new QWindowsDirect2DPlatformPixmap(type);
-        break;
-    }
-}
-
-QPlatformBackingStore *QWindowsDirect2DIntegration::createPlatformBackingStore(QWindow *window) const
-{
-    return new QWindowsDirect2DBackingStore(window);
-}
-
-QWindowsDirect2DContext *QWindowsDirect2DIntegration::direct2DContext() const
-{
-    return &d->m_d2dContext;
-}
-
-QWindowsDirect2DIntegration::QWindowsDirect2DIntegration(const QStringList &paramList)
-    : QWindowsIntegration(paramList)
-    , d(new QWindowsDirect2DIntegrationPrivate)
-{
-}
-
-bool QWindowsDirect2DIntegration::init()
-{
-    return d->m_d2dContext.init();
-}
-
-QT_END_NAMESPACE
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dintegration.h b/src/plugins/platforms/direct2d/qwindowsdirect2dintegration.h
deleted file mode 100644
index 342482c346..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dintegration.h
+++ /dev/null
@@ -1,43 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QWINDOWSDIRECT2DINTEGRATION_H
-#define QWINDOWSDIRECT2DINTEGRATION_H
-
-#include "qwindowsintegration.h"
-
-#include <QtCore/qscopedpointer.h>
-
-QT_BEGIN_NAMESPACE
-
-class QWindowsDirect2DContext;
-class QWindowsDirect2DIntegrationPrivate;
-
-class QWindowsDirect2DIntegration : public QWindowsIntegration
-{
-public:
-    static QWindowsDirect2DIntegration *create(const QStringList &paramList);
-
-    virtual ~QWindowsDirect2DIntegration();
-
-    static QWindowsDirect2DIntegration *instance();
-
-    QPlatformNativeInterface *nativeInterface() const override;
-    QPlatformPixmap *createPlatformPixmap(QPlatformPixmap::PixelType type) const override;
-    QPlatformBackingStore *createPlatformBackingStore(QWindow *window) const override;
-
-    QWindowsDirect2DContext *direct2DContext() const;
-
-protected:
-    QWindowsWindow *createPlatformWindowHelper(QWindow *window, const QWindowsWindowData &) const override;
-
-private:
-    explicit QWindowsDirect2DIntegration(const QStringList &paramList);
-    bool init();
-
-    QScopedPointer<QWindowsDirect2DIntegrationPrivate> d;
-};
-
-QT_END_NAMESPACE
-
-#endif // QWINDOWSDIRECT2DINTEGRATION_H
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dnativeinterface.cpp b/src/plugins/platforms/direct2d/qwindowsdirect2dnativeinterface.cpp
deleted file mode 100644
index 0523f2cd5f..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dnativeinterface.cpp
+++ /dev/null
@@ -1,26 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include "qwindowsdirect2dnativeinterface.h"
-
-#include <QtGui/qbackingstore.h>
-
-QT_BEGIN_NAMESPACE
-
-void *QWindowsDirect2DNativeInterface::nativeResourceForBackingStore(const QByteArray &resource, QBackingStore *bs)
-{
-    if (!bs || !bs->handle()) {
-        qWarning("%s: '%s' requested for null backingstore or backingstore without handle.", __FUNCTION__, resource.constData());
-        return nullptr;
-    }
-
-    // getDC is so common we don't want to print an "invalid key" line for it
-    if (resource == "getDC")
-        return nullptr;
-
-    qWarning("%s: Invalid key '%s' requested.", __FUNCTION__, resource.constData());
-    return nullptr;
-
-}
-
-QT_END_NAMESPACE
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dnativeinterface.h b/src/plugins/platforms/direct2d/qwindowsdirect2dnativeinterface.h
deleted file mode 100644
index a532ca2760..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dnativeinterface.h
+++ /dev/null
@@ -1,20 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QWINDOWSDIRECT2DNATIVEINTERFACE_H
-#define QWINDOWSDIRECT2DNATIVEINTERFACE_H
-
-#include "qwindowsnativeinterface.h"
-
-QT_BEGIN_NAMESPACE
-
-class QWindowsDirect2DNativeInterface : public QWindowsNativeInterface
-{
-    Q_OBJECT
-public:
-    void *nativeResourceForBackingStore(const QByteArray &resource, QBackingStore *bs) override;
-};
-
-QT_END_NAMESPACE
-
-#endif // QWINDOWSDIRECT2DNATIVEINTERFACE_H
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dpaintdevice.cpp b/src/plugins/platforms/direct2d/qwindowsdirect2dpaintdevice.cpp
deleted file mode 100644
index 2866c68de2..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dpaintdevice.cpp
+++ /dev/null
@@ -1,96 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include "qwindowsdirect2dpaintdevice.h"
-#include "qwindowsdirect2dpaintengine.h"
-#include "qwindowsdirect2dcontext.h"
-#include "qwindowsdirect2dhelpers.h"
-#include "qwindowsdirect2dbitmap.h"
-#include "qwindowsdirect2ddevicecontext.h"
-
-#include "qwindowswindow.h"
-
-QT_BEGIN_NAMESPACE
-
-class QWindowsDirect2DPaintDevicePrivate
-{
-public:
-    QWindowsDirect2DPaintDevicePrivate(QWindowsDirect2DBitmap *bitmap, QInternal::PaintDeviceFlags f,
-                                       QWindowsDirect2DPaintEngine::Flags paintFlags)
-        : engine(new QWindowsDirect2DPaintEngine(bitmap, paintFlags))
-        , bitmap(bitmap)
-        , flags(f)
-    {}
-
-    QScopedPointer<QWindowsDirect2DPaintEngine> engine;
-    QWindowsDirect2DBitmap *bitmap;
-    QInternal::PaintDeviceFlags flags;
-};
-
-QWindowsDirect2DPaintDevice::QWindowsDirect2DPaintDevice(QWindowsDirect2DBitmap *bitmap, QInternal::PaintDeviceFlags flags,
-                                                         QWindowsDirect2DPaintEngine::Flags paintFlags)
-    : d_ptr(new QWindowsDirect2DPaintDevicePrivate(bitmap, flags, paintFlags))
-{
-}
-
-QWindowsDirect2DPaintDevice::~QWindowsDirect2DPaintDevice()
-{
-}
-
-QPaintEngine *QWindowsDirect2DPaintDevice::paintEngine() const
-{
-    Q_D(const QWindowsDirect2DPaintDevice);
-
-    return d->engine.data();
-}
-
-int QWindowsDirect2DPaintDevice::devType() const
-{
-    Q_D(const QWindowsDirect2DPaintDevice);
-
-    return d->flags;
-}
-
-int QWindowsDirect2DPaintDevice::metric(QPaintDevice::PaintDeviceMetric metric) const
-{
-    Q_D(const QWindowsDirect2DPaintDevice);
-
-    switch (metric) {
-    case QPaintDevice::PdmWidth:
-        return int(d->bitmap->bitmap()->GetPixelSize().width);
-    case QPaintDevice::PdmHeight:
-        return int(d->bitmap->bitmap()->GetPixelSize().height);
-    case QPaintDevice::PdmNumColors:
-        return INT_MAX;
-    case QPaintDevice::PdmDepth:
-        return 32;
-    case QPaintDevice::PdmDpiX:
-    case QPaintDevice::PdmPhysicalDpiX:
-    {
-QT_WARNING_PUSH
-QT_WARNING_DISABLE_DEPRECATED // See QTBUG-94043
-        FLOAT x, y;
-        QWindowsDirect2DContext::instance()->d2dFactory()->GetDesktopDpi(&x, &y);
-        return qRound(x);
-    }
-    case QPaintDevice::PdmDpiY:
-    case QPaintDevice::PdmPhysicalDpiY:
-    {
-        FLOAT x, y;
-        QWindowsDirect2DContext::instance()->d2dFactory()->GetDesktopDpi(&x, &y);
-        return qRound(y);
-QT_WARNING_POP
-    }
-    case QPaintDevice::PdmDevicePixelRatio:
-        return 1;
-    case QPaintDevice::PdmDevicePixelRatioScaled:
-        return qRound(devicePixelRatioFScale());
-    case QPaintDevice::PdmWidthMM:
-    case QPaintDevice::PdmHeightMM:
-        break;
-    }
-
-    return -1;
-}
-
-QT_END_NAMESPACE
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dpaintdevice.h b/src/plugins/platforms/direct2d/qwindowsdirect2dpaintdevice.h
deleted file mode 100644
index e22727f37f..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dpaintdevice.h
+++ /dev/null
@@ -1,37 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QWINDOWSDIRECT2DPAINTDEVICE_H
-#define QWINDOWSDIRECT2DPAINTDEVICE_H
-
-#include <QtCore/qscopedpointer.h>
-#include <QtGui/qpaintdevice.h>
-#include "qwindowsdirect2dpaintengine.h"
-
-QT_BEGIN_NAMESPACE
-
-class QWindowsDirect2DBitmap;
-
-class QWindowsDirect2DPaintDevicePrivate;
-class QWindowsDirect2DPaintDevice : public QPaintDevice
-{
-    Q_DECLARE_PRIVATE(QWindowsDirect2DPaintDevice)
-
-public:
-    QWindowsDirect2DPaintDevice(QWindowsDirect2DBitmap *bitmap, QInternal::PaintDeviceFlags flags,
-                                QWindowsDirect2DPaintEngine::Flags paintFlags = QWindowsDirect2DPaintEngine::NoFlag);
-    ~QWindowsDirect2DPaintDevice();
-
-    QPaintEngine *paintEngine() const override;
-    int devType() const override;
-
-protected:
-    int metric(PaintDeviceMetric metric) const override;
-
-private:
-    QScopedPointer<QWindowsDirect2DPaintDevicePrivate> d_ptr;
-};
-
-QT_END_NAMESPACE
-
-#endif // QWINDOWSDIRECT2DPAINTDEVICE_H
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dpaintengine.cpp b/src/plugins/platforms/direct2d/qwindowsdirect2dpaintengine.cpp
deleted file mode 100644
index bc304f78be..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dpaintengine.cpp
+++ /dev/null
@@ -1,1814 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include "qwindowsdirect2dpaintengine.h"
-#include "qwindowsdirect2dplatformpixmap.h"
-#include "qwindowsdirect2dpaintdevice.h"
-#include "qwindowsdirect2dcontext.h"
-#include "qwindowsdirect2dhelpers.h"
-#include "qwindowsdirect2dbitmap.h"
-#include "qwindowsdirect2ddevicecontext.h"
-
-#include <QtGui/private/qwindowsfontdatabase_p.h>
-#include "qwindowsintegration.h"
-
-#include <QtCore/qmath.h>
-#include <QtCore/qstack.h>
-#include <QtCore/qsettings.h>
-#include <QtGui/private/qpaintengine_p.h>
-#include <QtGui/private/qtextengine_p.h>
-#include <QtGui/private/qfontengine_p.h>
-#include <QtGui/private/qstatictext_p.h>
-
-#include <d2d1_1.h>
-#include <dwrite_1.h>
-#include <wrl.h>
-
-using Microsoft::WRL::ComPtr;
-
-QT_BEGIN_NAMESPACE
-
-// The enum values below are set as tags on the device context
-// in the various draw methods. When EndDraw is called the device context
-// will report the last set tag number in case of errors
-// along with an error code
-
-// Microsoft keeps a list of d2d error codes here:
-// http://msdn.microsoft.com/en-us/library/windows/desktop/dd370979(v=vs.85).aspx
-enum {
-    D2DDebugDrawInitialStateTag = -1,
-    D2DDebugFillTag = 1,
-    D2DDebugFillRectTag,
-    D2DDebugDrawRectsTag,
-    D2DDebugDrawRectFsTag,
-    D2DDebugDrawEllipseTag,
-    D2DDebugDrawEllipseFTag,
-    D2DDebugDrawImageTag,
-    D2DDebugDrawPixmapTag,
-    D2DDebugDrawStaticTextItemTag,
-    D2DDebugDrawTextItemTag
-};
-
-//Clipping flags
-enum : unsigned {
-    SimpleSystemClip = 0x1
-};
-
-enum ClipType {
-    AxisAlignedClip,
-    LayerClip
-};
-
-// Since d2d is a float-based system we need to be able to snap our drawing to whole pixels.
-// Applying the magical aliasing offset to coordinates will do so, just make sure that
-// aliased painting is turned on on the d2d device context.
-static const qreal MAGICAL_ALIASING_OFFSET = 0.5;
-
-#define D2D_TAG(tag) d->dc()->SetTags(tag, tag)
-
-Q_GUI_EXPORT QImage qt_imageForBrush(int brushStyle, bool invert);
-
-static inline ID2D1Factory1 *factory()
-{
-    return QWindowsDirect2DContext::instance()->d2dFactory();
-}
-
-static inline D2D1_MATRIX_3X2_F transformFromLine(const QLineF &line, qreal penWidth, qreal dashOffset)
-{
-    const qreal halfWidth = penWidth / 2;
-    const qreal angle = -qDegreesToRadians(line.angle());
-    const qreal sinA = qSin(angle);
-    const qreal cosA = qCos(angle);
-    QTransform transform = QTransform::fromTranslate(line.p1().x() + dashOffset * cosA + sinA * halfWidth,
-                                                     line.p1().y() + dashOffset * sinA - cosA * halfWidth);
-    transform.rotateRadians(angle);
-    return to_d2d_matrix_3x2_f(transform);
-}
-
-static void adjustLine(QPointF *p1, QPointF *p2);
-static bool isLinePositivelySloped(const QPointF &p1, const QPointF &p2);
-
-static QList<D2D1_GRADIENT_STOP> qGradientStopsToD2DStops(const QGradientStops &qstops)
-{
-    QList<D2D1_GRADIENT_STOP> stops(qstops.count());
-    for (int i = 0, count =  stops.size(); i < count; ++i) {
-        stops[i].position = FLOAT(qstops.at(i).first);
-        stops[i].color = to_d2d_color_f(qstops.at(i).second);
-    }
-    return stops;
-}
-
-class Direct2DPathGeometryWriter
-{
-public:
-    bool begin()
-    {
-        HRESULT hr = factory()->CreatePathGeometry(&m_geometry);
-        if (FAILED(hr)) {
-            qWarning("%s: Could not create path geometry: %#lx", __FUNCTION__, hr);
-            return false;
-        }
-
-        hr = m_geometry->Open(&m_sink);
-        if (FAILED(hr)) {
-            qWarning("%s: Could not create geometry sink: %#lx", __FUNCTION__, hr);
-            return false;
-        }
-
-        return true;
-    }
-
-    void setWindingFillEnabled(bool enable)
-    {
-        if (enable)
-            m_sink->SetFillMode(D2D1_FILL_MODE_WINDING);
-        else
-            m_sink->SetFillMode(D2D1_FILL_MODE_ALTERNATE);
-    }
-
-    void setAliasingEnabled(bool enable)
-    {
-        m_roundCoordinates = enable;
-    }
-
-    void setPositiveSlopeAdjustmentEnabled(bool enable)
-    {
-        m_adjustPositivelySlopedLines = enable;
-    }
-
-    bool isInFigure() const
-    {
-        return m_inFigure;
-    }
-
-    void moveTo(const QPointF &point)
-    {
-        if (m_inFigure)
-            m_sink->EndFigure(D2D1_FIGURE_END_OPEN);
-
-        m_sink->BeginFigure(adjusted(point), D2D1_FIGURE_BEGIN_FILLED);
-        m_inFigure = true;
-        m_previousPoint = point;
-    }
-
-    void lineTo(const QPointF &point)
-    {
-        QPointF pt = point;
-        if (m_adjustPositivelySlopedLines && isLinePositivelySloped(m_previousPoint, point)) {
-            moveTo(m_previousPoint - QPointF(0, 1));
-            pt -= QPointF(0, 1);
-        }
-        m_sink->AddLine(adjusted(pt));
-        if (pt != point)
-            moveTo(point);
-        m_previousPoint = point;
-    }
-
-    void curveTo(const QPointF &p1, const QPointF &p2, const QPointF &p3)
-    {
-        D2D1_BEZIER_SEGMENT segment = {
-            adjusted(p1),
-            adjusted(p2),
-            adjusted(p3)
-        };
-
-        m_sink->AddBezier(segment);
-        m_previousPoint = p3;
-    }
-
-    void close()
-    {
-        if (m_inFigure)
-            m_sink->EndFigure(D2D1_FIGURE_END_OPEN);
-
-        m_sink->Close();
-    }
-
-    ComPtr<ID2D1PathGeometry1> geometry() const
-    {
-        return m_geometry;
-    }
-
-private:
-    D2D1_POINT_2F adjusted(const QPointF &point)
-    {
-        static const QPointF adjustment(MAGICAL_ALIASING_OFFSET,
-                                        MAGICAL_ALIASING_OFFSET);
-
-        if (m_roundCoordinates)
-            return to_d2d_point_2f(point + adjustment);
-        else
-            return to_d2d_point_2f(point);
-    }
-
-    ComPtr<ID2D1PathGeometry1> m_geometry;
-    ComPtr<ID2D1GeometrySink> m_sink;
-
-    bool m_inFigure = false;
-    bool m_roundCoordinates = false;
-    bool m_adjustPositivelySlopedLines = false;
-    QPointF m_previousPoint;
-};
-
-struct D2DVectorPathCache {
-    ComPtr<ID2D1PathGeometry1> aliased;
-    ComPtr<ID2D1PathGeometry1> antiAliased;
-
-    static void cleanup_func(QPaintEngineEx *engine, void *data) {
-        Q_UNUSED(engine);
-        auto *e = static_cast<D2DVectorPathCache *>(data);
-        delete e;
-    }
-};
-
-class QWindowsDirect2DPaintEnginePrivate : public QPaintEngineExPrivate
-{
-    Q_DECLARE_PUBLIC(QWindowsDirect2DPaintEngine)
-public:
-    QWindowsDirect2DPaintEnginePrivate(QWindowsDirect2DBitmap *bm, QWindowsDirect2DPaintEngine::Flags flags)
-        : bitmap(bm)
-        , flags(flags)
-    {
-        pen.reset();
-        brush.reset();
-
-        dc()->SetAntialiasMode(D2D1_ANTIALIAS_MODE_ALIASED);
-    }
-
-    QWindowsDirect2DBitmap *bitmap;
-    QImage fallbackImage;
-
-    unsigned int clipFlags = 0;
-    QStack<ClipType> pushedClips;
-    QWindowsDirect2DPaintEngine::Flags flags;
-
-    QPointF currentBrushOrigin;
-
-    QHash< QFontDef, ComPtr<IDWriteFontFace> > fontCache;
-
-    struct {
-        bool emulate;
-        QPen qpen;
-        ComPtr<ID2D1Brush> brush;
-        ComPtr<ID2D1StrokeStyle1> strokeStyle;
-        ComPtr<ID2D1BitmapBrush1> dashBrush;
-        int dashLength;
-
-        inline void reset() {
-            emulate = false;
-            qpen = QPen();
-            brush.Reset();
-            strokeStyle.Reset();
-            dashBrush.Reset();
-            dashLength = 0;
-        }
-    } pen;
-
-    struct {
-        bool emulate;
-        QBrush qbrush;
-        ComPtr<ID2D1Brush> brush;
-
-        inline void reset() {
-            emulate = false;
-            brush.Reset();
-            qbrush = QBrush();
-        }
-    } brush;
-
-    inline ID2D1DeviceContext *dc() const
-    {
-        Q_ASSERT(bitmap);
-        return bitmap->deviceContext()->get();
-    }
-
-    inline D2D1_INTERPOLATION_MODE interpolationMode() const
-    {
-        Q_Q(const QWindowsDirect2DPaintEngine);
-        return (q->state()->renderHints & QPainter::SmoothPixmapTransform) ? D2D1_INTERPOLATION_MODE_LINEAR
-                                                                           : D2D1_INTERPOLATION_MODE_NEAREST_NEIGHBOR;
-    }
-
-    inline D2D1_ANTIALIAS_MODE antialiasMode() const
-    {
-        Q_Q(const QWindowsDirect2DPaintEngine);
-        return (q->state()->renderHints & QPainter::Antialiasing) ? D2D1_ANTIALIAS_MODE_PER_PRIMITIVE
-                                                                  : D2D1_ANTIALIAS_MODE_ALIASED;
-    }
-
-    inline D2D1_LAYER_OPTIONS1 layerOptions() const
-    {
-        if (flags & QWindowsDirect2DPaintEngine::TranslucentTopLevelWindow)
-            return D2D1_LAYER_OPTIONS1_NONE;
-        else
-            return D2D1_LAYER_OPTIONS1_INITIALIZE_FROM_BACKGROUND;
-    }
-
-    void updateTransform(const QTransform &transform)
-    {
-        dc()->SetTransform(to_d2d_matrix_3x2_f(transform));
-    }
-
-    void updateOpacity(qreal opacity)
-    {
-        if (brush.brush)
-            brush.brush->SetOpacity(FLOAT(opacity));
-        if (pen.brush)
-            pen.brush->SetOpacity(FLOAT(opacity));
-    }
-
-    void pushClip(const QVectorPath &path)
-    {
-        Q_Q(QWindowsDirect2DPaintEngine);
-
-        if (path.isEmpty()) {
-            D2D_RECT_F rect = {0, 0, 0, 0};
-            dc()->PushAxisAlignedClip(rect, antialiasMode());
-            pushedClips.push(AxisAlignedClip);
-        } else if (path.isRect() && (q->state()->matrix.type() <= QTransform::TxScale)) {
-            const qreal * const points = path.points();
-            D2D_RECT_F rect = {
-                FLOAT(points[0]), // left
-                FLOAT(points[1]), // top
-                FLOAT(points[2]), // right,
-                FLOAT(points[5])  // bottom
-            };
-
-            dc()->PushAxisAlignedClip(rect, antialiasMode());
-            pushedClips.push(AxisAlignedClip);
-        } else {
-            ComPtr<ID2D1PathGeometry1> geometry = vectorPathToID2D1PathGeometry(path);
-            if (!geometry) {
-                qWarning("%s: Could not convert vector path to painter path!", __FUNCTION__);
-                return;
-            }
-
-            dc()->PushLayer(D2D1::LayerParameters1(D2D1::InfiniteRect(),
-                                                   geometry.Get(),
-                                                   antialiasMode(),
-                                                   D2D1::IdentityMatrix(),
-                                                   1.0,
-                                                   nullptr,
-                                                   layerOptions()),
-                            nullptr);
-            pushedClips.push(LayerClip);
-        }
-    }
-
-    void clearClips()
-    {
-        while (!pushedClips.isEmpty()) {
-            switch (pushedClips.pop()) {
-            case AxisAlignedClip:
-                dc()->PopAxisAlignedClip();
-                break;
-            case LayerClip:
-                dc()->PopLayer();
-                break;
-            }
-        }
-    }
-
-    void updateClipEnabled(bool enabled)
-    {
-        if (!enabled)
-            clearClips();
-        else if (pushedClips.isEmpty())
-            replayClipOperations();
-    }
-
-    void clip(const QVectorPath &path, Qt::ClipOperation operation)
-    {
-        switch (operation) {
-        case Qt::NoClip:
-            clearClips();
-            break;
-        case Qt::ReplaceClip:
-            clearClips();
-            pushClip(path);
-            break;
-        case Qt::IntersectClip:
-            pushClip(path);
-            break;
-        }
-    }
-
-    void updateCompositionMode(QPainter::CompositionMode mode)
-    {
-        switch (mode) {
-        case QPainter::CompositionMode_Source:
-            dc()->SetPrimitiveBlend(D2D1_PRIMITIVE_BLEND_COPY);
-            break;
-        case QPainter::CompositionMode_SourceOver:
-            dc()->SetPrimitiveBlend(D2D1_PRIMITIVE_BLEND_SOURCE_OVER);
-            break;
-
-        default:
-            // Activating an unsupported mode at any time will cause the QImage
-            // fallback to be used for the remainder of the active paint session
-            dc()->SetPrimitiveBlend(D2D1_PRIMITIVE_BLEND_COPY);
-            flags |= QWindowsDirect2DPaintEngine::EmulateComposition;
-            break;
-        }
-    }
-
-    void updateBrush(const QBrush &newBrush)
-    {
-        Q_Q(const QWindowsDirect2DPaintEngine);
-
-        if (qbrush_fast_equals(brush.qbrush, newBrush) && (brush.brush || brush.emulate))
-            return;
-
-        brush.brush = to_d2d_brush(newBrush, &brush.emulate);
-        brush.qbrush = newBrush;
-
-        if (brush.brush) {
-            brush.brush->SetOpacity(FLOAT(q->state()->opacity));
-            applyBrushOrigin(currentBrushOrigin);
-        }
-    }
-
-    void updateBrushOrigin(const QPointF &brushOrigin)
-    {
-        negateCurrentBrushOrigin();
-        applyBrushOrigin(brushOrigin);
-    }
-
-    void negateCurrentBrushOrigin()
-    {
-        if (brush.brush && !currentBrushOrigin.isNull()) {
-            D2D1_MATRIX_3X2_F transform;
-            brush.brush->GetTransform(&transform);
-
-            brush.brush->SetTransform(*(D2D1::Matrix3x2F::ReinterpretBaseType(&transform))
-                                      * D2D1::Matrix3x2F::Translation(FLOAT(-currentBrushOrigin.x()),
-                                                                      FLOAT(-currentBrushOrigin.y())));
-        }
-    }
-
-    void applyBrushOrigin(const QPointF &origin)
-    {
-        if (brush.brush && !origin.isNull()) {
-            D2D1_MATRIX_3X2_F transform;
-            brush.brush->GetTransform(&transform);
-
-            brush.brush->SetTransform(*(D2D1::Matrix3x2F::ReinterpretBaseType(&transform))
-                                      * D2D1::Matrix3x2F::Translation(FLOAT(origin.x()), FLOAT(origin.y())));
-        }
-
-        currentBrushOrigin = origin;
-    }
-
-    void updatePen(const QPen &newPen)
-    {
-        Q_Q(const QWindowsDirect2DPaintEngine);
-        if (qpen_fast_equals(newPen, pen.qpen) && (pen.brush || pen.emulate))
-            return;
-
-        pen.reset();
-        pen.qpen = newPen;
-
-        if (newPen.style() == Qt::NoPen)
-            return;
-
-        pen.brush = to_d2d_brush(newPen.brush(), &pen.emulate);
-        if (!pen.brush)
-            return;
-
-        pen.brush->SetOpacity(FLOAT(q->state()->opacity));
-
-        D2D1_STROKE_STYLE_PROPERTIES1 props = {};
-
-        switch (newPen.capStyle()) {
-        case Qt::SquareCap:
-            props.startCap = props.endCap = props.dashCap = D2D1_CAP_STYLE_SQUARE;
-            break;
-        case Qt::RoundCap:
-            props.startCap = props.endCap = props.dashCap = D2D1_CAP_STYLE_ROUND;
-            break;
-        case Qt::FlatCap:
-        default:
-            props.startCap = props.endCap = props.dashCap = D2D1_CAP_STYLE_FLAT;
-            break;
-        }
-
-        switch (newPen.joinStyle()) {
-        case Qt::BevelJoin:
-            props.lineJoin = D2D1_LINE_JOIN_BEVEL;
-            break;
-        case Qt::RoundJoin:
-            props.lineJoin = D2D1_LINE_JOIN_ROUND;
-            break;
-        case Qt::MiterJoin:
-        default:
-            props.lineJoin = D2D1_LINE_JOIN_MITER;
-            break;
-        }
-
-        props.miterLimit = FLOAT(newPen.miterLimit() * qreal(2.0)); // D2D and Qt miter specs differ
-        props.dashOffset = FLOAT(newPen.dashOffset());
-
-        if (newPen.widthF() == 0)
-            props.transformType = D2D1_STROKE_TRANSFORM_TYPE_HAIRLINE;
-        else if (newPen.isCosmetic())
-            props.transformType = D2D1_STROKE_TRANSFORM_TYPE_FIXED;
-        else
-            props.transformType = D2D1_STROKE_TRANSFORM_TYPE_NORMAL;
-
-        switch (newPen.style()) {
-        case Qt::SolidLine:
-            props.dashStyle = D2D1_DASH_STYLE_SOLID;
-            break;
-
-        case Qt::DotLine:
-        case Qt::DashDotLine:
-        case Qt::DashDotDotLine:
-            // Try and match Qt's raster engine in output as closely as possible
-            if (newPen.widthF() <= 1.0)
-                props.startCap = props.endCap = props.dashCap = D2D1_CAP_STYLE_FLAT;
-
-            Q_FALLTHROUGH();
-        default:
-            props.dashStyle = D2D1_DASH_STYLE_CUSTOM;
-            break;
-        }
-
-        HRESULT hr;
-
-        if (props.dashStyle == D2D1_DASH_STYLE_CUSTOM) {
-            QList<qreal> dashes = newPen.dashPattern();
-            QList<FLOAT> converted(dashes.size());
-            qreal penWidth = pen.qpen.widthF();
-            qreal brushWidth = 0;
-            for (int i = 0; i < dashes.size(); i++) {
-                converted[i] = FLOAT(dashes[i]);
-                brushWidth += penWidth * dashes[i];
-            }
-
-            hr = factory()->CreateStrokeStyle(props, converted.constData(), UINT32(converted.size()), &pen.strokeStyle);
-
-            // Create a combined brush/dash pattern for optimized line drawing
-            QWindowsDirect2DBitmap bitmap;
-            bitmap.resize(int(ceil(brushWidth)), int(ceil(penWidth)));
-            bitmap.deviceContext()->begin();
-            bitmap.deviceContext()->get()->SetAntialiasMode(antialiasMode());
-            bitmap.deviceContext()->get()->SetTransform(D2D1::IdentityMatrix());
-            bitmap.deviceContext()->get()->Clear();
-            const qreal offsetX = (qreal(bitmap.size().width()) - brushWidth) / 2;
-            const qreal offsetY = qreal(bitmap.size().height()) / 2;
-            bitmap.deviceContext()->get()->DrawLine(D2D1::Point2F(FLOAT(offsetX), FLOAT(offsetY)),
-                                                    D2D1::Point2F(FLOAT(brushWidth), FLOAT(offsetY)),
-                                                    pen.brush.Get(), FLOAT(penWidth), pen.strokeStyle.Get());
-            bitmap.deviceContext()->end();
-            D2D1_BITMAP_BRUSH_PROPERTIES1 bitmapBrushProperties = D2D1::BitmapBrushProperties1(
-                        D2D1_EXTEND_MODE_WRAP, D2D1_EXTEND_MODE_CLAMP, D2D1_INTERPOLATION_MODE_LINEAR);
-            hr = dc()->CreateBitmapBrush(bitmap.bitmap(), bitmapBrushProperties, &pen.dashBrush);
-            pen.dashLength = bitmap.size().width();
-        } else {
-            hr = factory()->CreateStrokeStyle(props, nullptr, 0, &pen.strokeStyle);
-        }
-
-        if (FAILED(hr))
-            qWarning("%s: Could not create stroke style: %#lx", __FUNCTION__, hr);
-    }
-
-    ComPtr<ID2D1Brush> to_d2d_brush(const QBrush &newBrush, bool *needsEmulation)
-    {
-        HRESULT hr;
-        ComPtr<ID2D1Brush> result;
-
-        Q_ASSERT(needsEmulation);
-
-        *needsEmulation = false;
-
-        switch (newBrush.style()) {
-        case Qt::NoBrush:
-            break;
-
-        case Qt::SolidPattern:
-        {
-            ComPtr<ID2D1SolidColorBrush> solid;
-
-            hr = dc()->CreateSolidColorBrush(to_d2d_color_f(newBrush.color()), &solid);
-            if (FAILED(hr)) {
-                qWarning("%s: Could not create solid color brush: %#lx", __FUNCTION__, hr);
-                break;
-            }
-
-            hr = solid.As(&result);
-            if (FAILED(hr))
-                qWarning("%s: Could not convert solid color brush: %#lx", __FUNCTION__, hr);
-        }
-            break;
-
-        case Qt::Dense1Pattern:
-        case Qt::Dense2Pattern:
-        case Qt::Dense3Pattern:
-        case Qt::Dense4Pattern:
-        case Qt::Dense5Pattern:
-        case Qt::Dense6Pattern:
-        case Qt::Dense7Pattern:
-        case Qt::HorPattern:
-        case Qt::VerPattern:
-        case Qt::CrossPattern:
-        case Qt::BDiagPattern:
-        case Qt::FDiagPattern:
-        case Qt::DiagCrossPattern:
-        {
-            ComPtr<ID2D1BitmapBrush1> bitmapBrush;
-            D2D1_BITMAP_BRUSH_PROPERTIES1 bitmapBrushProperties = {
-                D2D1_EXTEND_MODE_WRAP,
-                D2D1_EXTEND_MODE_WRAP,
-                interpolationMode()
-            };
-
-            QImage brushImg = qt_imageForBrush(newBrush.style(), false);
-            brushImg.setColor(0, newBrush.color().rgba());
-            brushImg.setColor(1, qRgba(0, 0, 0, 0));
-
-            QWindowsDirect2DBitmap bitmap;
-            bool success = bitmap.fromImage(brushImg, Qt::AutoColor);
-            if (!success) {
-                qWarning("%s: Could not create Direct2D bitmap from Qt pattern brush image", __FUNCTION__);
-                break;
-            }
-
-            hr = dc()->CreateBitmapBrush(bitmap.bitmap(),
-                                         bitmapBrushProperties,
-                                         &bitmapBrush);
-            if (FAILED(hr)) {
-                qWarning("%s: Could not create Direct2D bitmap brush for Qt pattern brush: %#lx", __FUNCTION__, hr);
-                break;
-            }
-
-            hr = bitmapBrush.As(&result);
-            if (FAILED(hr))
-                qWarning("%s: Could not convert Direct2D bitmap brush for Qt pattern brush: %#lx", __FUNCTION__, hr);
-        }
-            break;
-
-        case Qt::LinearGradientPattern:
-            if (newBrush.gradient()->spread() != QGradient::PadSpread) {
-                *needsEmulation = true;
-            } else {
-                ComPtr<ID2D1LinearGradientBrush> linear;
-                const auto *qlinear = static_cast<const QLinearGradient *>(newBrush.gradient());
-
-                D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES linearGradientBrushProperties;
-                ComPtr<ID2D1GradientStopCollection> gradientStopCollection;
-
-                linearGradientBrushProperties.startPoint = to_d2d_point_2f(qlinear->start());
-                linearGradientBrushProperties.endPoint = to_d2d_point_2f(qlinear->finalStop());
-
-                const QList<D2D1_GRADIENT_STOP> stops = qGradientStopsToD2DStops(qlinear->stops());
-
-                hr = dc()->CreateGradientStopCollection(stops.constData(),
-                                                        UINT32(stops.size()),
-                                                        &gradientStopCollection);
-                if (FAILED(hr)) {
-                    qWarning("%s: Could not create gradient stop collection for linear gradient: %#lx", __FUNCTION__, hr);
-                    break;
-                }
-
-                hr = dc()->CreateLinearGradientBrush(linearGradientBrushProperties, gradientStopCollection.Get(),
-                                                     &linear);
-                if (FAILED(hr)) {
-                    qWarning("%s: Could not create Direct2D linear gradient brush: %#lx", __FUNCTION__, hr);
-                    break;
-                }
-
-                hr = linear.As(&result);
-                if (FAILED(hr)) {
-                    qWarning("%s: Could not convert Direct2D linear gradient brush: %#lx", __FUNCTION__, hr);
-                    break;
-                }
-            }
-            break;
-
-        case Qt::RadialGradientPattern:
-            if (newBrush.gradient()->spread() != QGradient::PadSpread) {
-                *needsEmulation = true;
-            } else {
-                ComPtr<ID2D1RadialGradientBrush> radial;
-                const auto *qradial = static_cast<const QRadialGradient *>(newBrush.gradient());
-
-                D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES radialGradientBrushProperties;
-                ComPtr<ID2D1GradientStopCollection> gradientStopCollection;
-
-                radialGradientBrushProperties.center = to_d2d_point_2f(qradial->center());
-                radialGradientBrushProperties.gradientOriginOffset = to_d2d_point_2f(qradial->focalPoint() - qradial->center());
-                radialGradientBrushProperties.radiusX = FLOAT(qradial->radius());
-                radialGradientBrushProperties.radiusY = FLOAT(qradial->radius());
-
-                const QList<D2D1_GRADIENT_STOP> stops = qGradientStopsToD2DStops(qradial->stops());
-
-                hr = dc()->CreateGradientStopCollection(stops.constData(), stops.size(), &gradientStopCollection);
-                if (FAILED(hr)) {
-                    qWarning("%s: Could not create gradient stop collection for radial gradient: %#lx", __FUNCTION__, hr);
-                    break;
-                }
-
-                hr = dc()->CreateRadialGradientBrush(radialGradientBrushProperties, gradientStopCollection.Get(),
-                                                     &radial);
-                if (FAILED(hr)) {
-                    qWarning("%s: Could not create Direct2D radial gradient brush: %#lx", __FUNCTION__, hr);
-                    break;
-                }
-
-                radial.As(&result);
-                if (FAILED(hr)) {
-                    qWarning("%s: Could not convert Direct2D radial gradient brush: %#lx", __FUNCTION__, hr);
-                    break;
-                }
-            }
-            break;
-
-        case Qt::ConicalGradientPattern:
-            *needsEmulation = true;
-            break;
-
-        case Qt::TexturePattern:
-        {
-            ComPtr<ID2D1BitmapBrush1> bitmapBrush;
-            D2D1_BITMAP_BRUSH_PROPERTIES1 bitmapBrushProperties = {
-                D2D1_EXTEND_MODE_WRAP,
-                D2D1_EXTEND_MODE_WRAP,
-                interpolationMode()
-            };
-
-            QWindowsDirect2DPlatformPixmap *pp = static_cast<QWindowsDirect2DPlatformPixmap *>(newBrush.texture().handle());
-            QWindowsDirect2DBitmap *bitmap = pp->bitmap();
-            hr = dc()->CreateBitmapBrush(bitmap->bitmap(),
-                                         bitmapBrushProperties,
-                                         &bitmapBrush);
-
-            if (FAILED(hr)) {
-                qWarning("%s: Could not create texture brush: %#lx", __FUNCTION__, hr);
-                break;
-            }
-
-            hr = bitmapBrush.As(&result);
-            if (FAILED(hr))
-                qWarning("%s: Could not convert texture brush: %#lx", __FUNCTION__, hr);
-        }
-            break;
-        }
-
-        if (result && !newBrush.transform().isIdentity())
-            result->SetTransform(to_d2d_matrix_3x2_f(newBrush.transform()));
-
-        return result;
-    }
-
-    ComPtr<ID2D1PathGeometry1> vectorPathToID2D1PathGeometry(const QVectorPath &path)
-    {
-        Q_Q(QWindowsDirect2DPaintEngine);
-
-        const bool alias = !q->antiAliasingEnabled();
-
-        QVectorPath::CacheEntry *cacheEntry = path.isCacheable() ? path.lookupCacheData(q)
-                                                                 : nullptr;
-
-        if (cacheEntry) {
-            auto *e = static_cast<D2DVectorPathCache *>(cacheEntry->data);
-            if (alias && e->aliased)
-                return e->aliased;
-            else if (!alias && e->antiAliased)
-                return e->antiAliased;
-        }
-
-        Direct2DPathGeometryWriter writer;
-        if (!writer.begin())
-            return nullptr;
-
-        writer.setWindingFillEnabled(path.hasWindingFill());
-        writer.setAliasingEnabled(alias);
-        writer.setPositiveSlopeAdjustmentEnabled(path.shape() == QVectorPath::LinesHint
-                                                 || path.shape() == QVectorPath::PolygonHint);
-
-        const QPainterPath::ElementType *types = path.elements();
-        const int count = path.elementCount();
-        const qreal *points = path.points();
-
-        Q_ASSERT(points);
-
-        if (types) {
-            qreal x, y;
-
-            for (int i = 0; i < count; i++) {
-                x = points[i * 2];
-                y = points[i * 2 + 1];
-
-                switch (types[i]) {
-                case QPainterPath::MoveToElement:
-                    writer.moveTo(QPointF(x, y));
-                    break;
-
-                case QPainterPath::LineToElement:
-                    writer.lineTo(QPointF(x, y));
-                    break;
-
-                case QPainterPath::CurveToElement:
-                {
-                    Q_ASSERT((i + 2) < count);
-                    Q_ASSERT(types[i+1] == QPainterPath::CurveToDataElement);
-                    Q_ASSERT(types[i+2] == QPainterPath::CurveToDataElement);
-
-                    i++;
-                    const qreal x2 = points[i * 2];
-                    const qreal y2 = points[i * 2 + 1];
-
-                    i++;
-                    const qreal x3 = points[i * 2];
-                    const qreal y3 = points[i * 2 + 1];
-
-                    writer.curveTo(QPointF(x, y), QPointF(x2, y2), QPointF(x3, y3));
-                }
-                    break;
-
-                case QPainterPath::CurveToDataElement:
-                    qWarning("%s: Unhandled Curve Data Element", __FUNCTION__);
-                    break;
-                }
-            }
-        } else {
-            writer.moveTo(QPointF(points[0], points[1]));
-            for (int i = 1; i < count; i++)
-                writer.lineTo(QPointF(points[i * 2], points[i * 2 + 1]));
-        }
-
-        if (writer.isInFigure())
-            if (path.hasImplicitClose())
-                writer.lineTo(QPointF(points[0], points[1]));
-
-        writer.close();
-        ComPtr<ID2D1PathGeometry1> geometry = writer.geometry();
-
-        if (path.isCacheable()) {
-            if (!cacheEntry)
-                cacheEntry = path.addCacheData(q, new D2DVectorPathCache, D2DVectorPathCache::cleanup_func);
-
-            auto *e = static_cast<D2DVectorPathCache *>(cacheEntry->data);
-            if (alias)
-                e->aliased = geometry;
-            else
-                e->antiAliased = geometry;
-        } else {
-            path.makeCacheable();
-        }
-
-        return geometry;
-    }
-
-    void updateHints()
-    {
-        dc()->SetAntialiasMode(antialiasMode());
-    }
-
-    void drawGlyphRun(const D2D1_POINT_2F &pos,
-                      IDWriteFontFace *fontFace,
-                      const QFontDef &fontDef,
-                      int numGlyphs,
-                      const UINT16 *glyphIndices,
-                      const FLOAT *glyphAdvances,
-                      const DWRITE_GLYPH_OFFSET *glyphOffsets,
-                      bool rtl)
-    {
-        Q_Q(QWindowsDirect2DPaintEngine);
-
-        DWRITE_GLYPH_RUN glyphRun = {
-            fontFace,          //    IDWriteFontFace           *fontFace;
-            FLOAT(fontDef.pixelSize), // FLOAT                 fontEmSize;
-            UINT32(numGlyphs), //    UINT32                    glyphCount;
-            glyphIndices,      //    const UINT16              *glyphIndices;
-            glyphAdvances,     //    const FLOAT               *glyphAdvances;
-            glyphOffsets,      //    const DWRITE_GLYPH_OFFSET *glyphOffsets;
-            FALSE,             //    BOOL                      isSideways;
-            rtl ? 1u : 0u      //    UINT32                    bidiLevel;
-        };
-
-        const bool antiAlias = bool((q->state()->renderHints & QPainter::TextAntialiasing)
-                                    && !(fontDef.styleStrategy & QFont::NoAntialias));
-        const D2D1_TEXT_ANTIALIAS_MODE antialiasMode = (flags & QWindowsDirect2DPaintEngine::TranslucentTopLevelWindow)
-                ? D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE : D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE;
-        dc()->SetTextAntialiasMode(antiAlias ? antialiasMode : D2D1_TEXT_ANTIALIAS_MODE_ALIASED);
-
-        dc()->DrawGlyphRun(pos,
-                           &glyphRun,
-                           nullptr,
-                           pen.brush.Get(),
-                           DWRITE_MEASURING_MODE_GDI_CLASSIC);
-    }
-
-    void stroke(const QVectorPath &path)
-    {
-        Q_Q(QWindowsDirect2DPaintEngine);
-
-        // Default path (no optimization)
-        if (!(path.shape() == QVectorPath::LinesHint || path.shape() == QVectorPath::PolygonHint)
-                || !pen.dashBrush
-                || q->state()->renderHints.testFlag(QPainter::Antialiasing)) {
-            ComPtr<ID2D1Geometry> geometry = vectorPathToID2D1PathGeometry(path);
-            if (!geometry) {
-                qWarning("%s: Could not convert path to d2d geometry", __FUNCTION__);
-                return;
-            }
-            dc()->DrawGeometry(geometry.Get(), pen.brush.Get(),
-                               FLOAT(pen.qpen.widthF()), pen.strokeStyle.Get());
-            return;
-        }
-
-        // Optimized dash line drawing
-        const bool isPolygon = path.shape() == QVectorPath::PolygonHint && path.elementCount() >= 3;
-        const bool implicitClose = isPolygon && (path.hints() & QVectorPath::ImplicitClose);
-        const bool skipJoin = !isPolygon // Non-polygons don't require joins
-                || (pen.qpen.joinStyle() == Qt::MiterJoin && qFuzzyIsNull(pen.qpen.miterLimit()));
-        const qreal *points = path.points();
-        const int lastElement = path.elementCount() - (implicitClose ? 1 : 2);
-        qreal dashOffset = 0;
-        QPointF jointStart;
-        ID2D1Brush *brush = pen.dashBrush ? pen.dashBrush.Get() : pen.brush.Get();
-        for (int i = 0; i <= lastElement; ++i) {
-            QPointF p1(points[i * 2], points[i * 2 + 1]);
-            QPointF p2 = implicitClose && i == lastElement ? QPointF(points[0], points[1])
-                                                           : QPointF(points[i * 2 + 2], points[i * 2 + 3]);
-            if (!isPolygon) // Advance the count for lines
-                ++i;
-
-            // Match raster engine output
-            if (p1 == p2 && pen.qpen.widthF() <= 1.0) {
-                q->fillRect(QRectF(p1, QSizeF(pen.qpen.widthF(), pen.qpen.widthF())), pen.qpen.brush());
-                continue;
-            }
-
-            if (!q->antiAliasingEnabled())
-                adjustLine(&p1, &p2);
-
-            q->adjustForAliasing(&p1);
-            q->adjustForAliasing(&p2);
-
-            const QLineF line(p1, p2);
-            const qreal lineLength = line.length();
-            if (pen.dashBrush) {
-                pen.dashBrush->SetTransform(transformFromLine(line, pen.qpen.widthF(), dashOffset));
-                dashOffset = pen.dashLength - fmod(lineLength - dashOffset, pen.dashLength);
-            }
-            dc()->DrawLine(to_d2d_point_2f(p1), to_d2d_point_2f(p2),
-                           brush, FLOAT(pen.qpen.widthF()), nullptr);
-
-            if (skipJoin)
-                continue;
-
-            // Patch the join with the original brush
-            const qreal patchSegment = pen.dashBrush ? qBound(0.0, (pen.dashLength - dashOffset) / lineLength, 1.0)
-                                                     : pen.qpen.widthF();
-            if (i > 0) {
-                Direct2DPathGeometryWriter writer;
-                writer.begin();
-                writer.moveTo(jointStart);
-                writer.lineTo(p1);
-                writer.lineTo(line.pointAt(patchSegment));
-                writer.close();
-                dc()->DrawGeometry(writer.geometry().Get(), pen.brush.Get(),
-                                   FLOAT(pen.qpen.widthF()), pen.strokeStyle.Get());
-            }
-            // Record the start position of the next joint
-            jointStart = line.pointAt(1 - patchSegment);
-
-            if (implicitClose && i == lastElement) { // Close the polygon
-                Direct2DPathGeometryWriter writer;
-                writer.begin();
-                writer.moveTo(jointStart);
-                writer.lineTo(p2);
-                writer.lineTo(QLineF(p2, QPointF(points[2], points[3])).pointAt(patchSegment));
-                writer.close();
-                dc()->DrawGeometry(writer.geometry().Get(), pen.brush.Get(),
-                                   FLOAT(pen.qpen.widthF()), pen.strokeStyle.Get());
-            }
-        }
-    }
-
-    ComPtr<IDWriteFontFace> fontFaceFromFontEngine(QFontEngine *fe)
-    {
-        const QFontDef fontDef = fe->fontDef;
-        ComPtr<IDWriteFontFace> fontFace = fontCache.value(fontDef);
-        if (fontFace)
-            return fontFace;
-
-        LOGFONT lf = QWindowsFontDatabase::fontDefToLOGFONT(fontDef, QString());
-
-        // Get substitute name
-        static const char keyC[] = "HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes";
-        const QString familyName = QString::fromWCharArray(lf.lfFaceName);
-        const QString nameSubstitute = QSettings(QLatin1StringView(keyC), QSettings::NativeFormat).value(familyName, familyName).toString();
-        if (nameSubstitute != familyName) {
-            const int nameSubstituteLength = qMin(nameSubstitute.length(), LF_FACESIZE - 1);
-            memcpy(lf.lfFaceName, nameSubstitute.data(), size_t(nameSubstituteLength) * sizeof(wchar_t));
-            lf.lfFaceName[nameSubstituteLength] = 0;
-        }
-
-        ComPtr<IDWriteFont> dwriteFont;
-        HRESULT hr = QWindowsDirect2DContext::instance()->dwriteGdiInterop()->CreateFontFromLOGFONT(&lf, &dwriteFont);
-        if (FAILED(hr)) {
-            qDebug("%s: CreateFontFromLOGFONT failed: %#lx", __FUNCTION__, hr);
-            return fontFace;
-        }
-
-        hr = dwriteFont->CreateFontFace(&fontFace);
-        if (FAILED(hr)) {
-            qDebug("%s: CreateFontFace failed: %#lx", __FUNCTION__, hr);
-            return fontFace;
-        }
-
-        if (fontFace)
-            fontCache.insert(fontDef, fontFace);
-
-        return fontFace;
-    }
-};
-
-QWindowsDirect2DPaintEngine::QWindowsDirect2DPaintEngine(QWindowsDirect2DBitmap *bitmap, Flags flags)
-    : QPaintEngineEx(*(new QWindowsDirect2DPaintEnginePrivate(bitmap, flags)))
-{
-    QPaintEngine::PaintEngineFeatures unsupported =
-            // As of 1.1 Direct2D does not natively support complex composition modes
-            // However, using Direct2D effects that implement them should be possible
-            QPaintEngine::PorterDuff
-            | QPaintEngine::BlendModes
-            | QPaintEngine::RasterOpModes
-
-            // As of 1.1 Direct2D does not natively support perspective transforms
-            // However, writing a custom effect that implements them should be possible
-            // The built-in 3D transform effect unfortunately changes output image size, making
-            // it unusable for us.
-            | QPaintEngine::PerspectiveTransform;
-
-    gccaps &= ~unsupported;
-}
-
-bool QWindowsDirect2DPaintEngine::begin(QPaintDevice * pdev)
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-
-    d->bitmap->deviceContext()->begin();
-    d->dc()->SetTransform(D2D1::Matrix3x2F::Identity());
-
-    if (systemClip().rectCount() > 1) {
-        QPainterPath p;
-        p.addRegion(systemClip());
-
-        ComPtr<ID2D1PathGeometry1> geometry = d->vectorPathToID2D1PathGeometry(qtVectorPathForPath(p));
-        if (!geometry)
-            return false;
-
-        d->dc()->PushLayer(D2D1::LayerParameters1(D2D1::InfiniteRect(),
-                                               geometry.Get(),
-                                               d->antialiasMode(),
-                                               D2D1::IdentityMatrix(),
-                                               1.0,
-                                               nullptr,
-                                               d->layerOptions()),
-                        nullptr);
-    } else {
-        QRect clip(0, 0, pdev->width(), pdev->height());
-        if (!systemClip().isEmpty())
-            clip &= systemClip().boundingRect();
-        d->dc()->PushAxisAlignedClip(to_d2d_rect_f(clip), D2D1_ANTIALIAS_MODE_ALIASED);
-        d->clipFlags |= SimpleSystemClip;
-    }
-
-    D2D_TAG(D2DDebugDrawInitialStateTag);
-
-    setActive(true);
-    return true;
-}
-
-bool QWindowsDirect2DPaintEngine::end()
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-
-    // Always clear all emulation-related things so we are in a clean state for our next painting run
-    const bool emulatingComposition = d->flags.testFlag(EmulateComposition);
-    d->flags &= ~QWindowsDirect2DPaintEngine::EmulateComposition;
-    if (!d->fallbackImage.isNull()) {
-        if (emulatingComposition)
-            drawImage(d->fallbackImage.rect(), d->fallbackImage, d->fallbackImage.rect());
-        d->fallbackImage = QImage();
-    }
-
-    // Pop any user-applied clipping
-    d->clearClips();
-    // Now the system clip from begin() above
-    if (d->clipFlags & SimpleSystemClip) {
-        d->dc()->PopAxisAlignedClip();
-        d->clipFlags &= ~SimpleSystemClip;
-    } else {
-        d->dc()->PopLayer();
-    }
-
-    return d->bitmap->deviceContext()->end();
-}
-
-QPaintEngine::Type QWindowsDirect2DPaintEngine::type() const
-{
-    return QPaintEngine::Direct2D;
-}
-
-void QWindowsDirect2DPaintEngine::setState(QPainterState *s)
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-
-    QPaintEngineEx::setState(s);
-    d->clearClips();
-
-    clipEnabledChanged();
-    penChanged();
-    brushChanged();
-    brushOriginChanged();
-    opacityChanged();
-    compositionModeChanged();
-    renderHintsChanged();
-    transformChanged();
-}
-
-void QWindowsDirect2DPaintEngine::draw(const QVectorPath &path)
-{
-    const QBrush &brush = state()->brush;
-    if (qbrush_style(brush) != Qt::NoBrush) {
-        if (emulationRequired(BrushEmulation))
-            rasterFill(path, brush);
-        else
-            fill(path, brush);
-    }
-
-    const QPen &pen = state()->pen;
-    if (qpen_style(pen) != Qt::NoPen && qbrush_style(qpen_brush(pen)) != Qt::NoBrush) {
-        if (emulationRequired(PenEmulation))
-            QPaintEngineEx::stroke(path, pen);
-        else
-            stroke(path, pen);
-    }
-}
-
-void QWindowsDirect2DPaintEngine::fill(const QVectorPath &path, const QBrush &brush)
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    D2D_TAG(D2DDebugFillTag);
-
-    if (path.isEmpty())
-        return;
-
-    ensureBrush(brush);
-    if (emulationRequired(BrushEmulation)) {
-        rasterFill(path, brush);
-        return;
-    }
-
-    if (!d->brush.brush)
-        return;
-
-    ComPtr<ID2D1Geometry> geometry = d->vectorPathToID2D1PathGeometry(path);
-    if (!geometry) {
-        qWarning("%s: Could not convert path to d2d geometry", __FUNCTION__);
-        return;
-    }
-
-    d->dc()->FillGeometry(geometry.Get(), d->brush.brush.Get());
-}
-
-void QWindowsDirect2DPaintEngine::stroke(const QVectorPath &path, const QPen &pen)
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    D2D_TAG(D2DDebugFillTag);
-
-    if (path.isEmpty())
-        return;
-
-    ensurePen(pen);
-    if (emulationRequired(PenEmulation)) {
-        QPaintEngineEx::stroke(path, pen);
-        return;
-    }
-
-    if (!d->pen.brush)
-        return;
-
-    d->stroke(path);
-}
-
-void QWindowsDirect2DPaintEngine::clip(const QVectorPath &path, Qt::ClipOperation op)
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    d->clip(path, op);
-}
-
-void QWindowsDirect2DPaintEngine::clipEnabledChanged()
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    d->updateClipEnabled(state()->clipEnabled);
-}
-
-void QWindowsDirect2DPaintEngine::penChanged()
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    d->updatePen(state()->pen);
-}
-
-void QWindowsDirect2DPaintEngine::brushChanged()
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    d->updateBrush(state()->brush);
-}
-
-void QWindowsDirect2DPaintEngine::brushOriginChanged()
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    d->updateBrushOrigin(state()->brushOrigin);
-}
-
-void QWindowsDirect2DPaintEngine::opacityChanged()
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    d->updateOpacity(state()->opacity);
-}
-
-void QWindowsDirect2DPaintEngine::compositionModeChanged()
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    d->updateCompositionMode(state()->compositionMode());
-}
-
-void QWindowsDirect2DPaintEngine::renderHintsChanged()
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    d->updateHints();
-}
-
-void QWindowsDirect2DPaintEngine::transformChanged()
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    d->updateTransform(state()->transform());
-}
-
-void QWindowsDirect2DPaintEngine::fillRect(const QRectF &rect, const QBrush &brush)
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    D2D_TAG(D2DDebugFillRectTag);
-
-    ensureBrush(brush);
-
-    if (emulationRequired(BrushEmulation)) {
-        QPaintEngineEx::fillRect(rect, brush);
-    } else {
-        QRectF r = rect.normalized();
-        adjustForAliasing(&r);
-
-        if (d->brush.brush)
-            d->dc()->FillRectangle(to_d2d_rect_f(rect), d->brush.brush.Get());
-    }
-}
-
-void QWindowsDirect2DPaintEngine::drawRects(const QRect *rects, int rectCount)
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    D2D_TAG(D2DDebugDrawRectsTag);
-
-    ensureBrush();
-    ensurePen();
-
-    if (emulationRequired(BrushEmulation) || emulationRequired(PenEmulation)) {
-        QPaintEngineEx::drawRects(rects, rectCount);
-    } else {
-        QRectF rect;
-        for (int i = 0; i < rectCount; i++) {
-            rect = rects[i].normalized();
-            adjustForAliasing(&rect);
-
-            D2D1_RECT_F d2d_rect = to_d2d_rect_f(rect);
-
-            if (d->brush.brush)
-                d->dc()->FillRectangle(d2d_rect, d->brush.brush.Get());
-
-            if (d->pen.brush)
-                d->dc()->DrawRectangle(d2d_rect, d->pen.brush.Get(),
-                                       FLOAT(d->pen.qpen.widthF()), d->pen.strokeStyle.Get());
-        }
-    }
-}
-
-void QWindowsDirect2DPaintEngine::drawRects(const QRectF *rects, int rectCount)
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    D2D_TAG(D2DDebugDrawRectFsTag);
-
-    ensureBrush();
-    ensurePen();
-
-    if (emulationRequired(BrushEmulation) || emulationRequired(PenEmulation)) {
-        QPaintEngineEx::drawRects(rects, rectCount);
-    } else {
-        QRectF rect;
-        for (int i = 0; i < rectCount; i++) {
-            rect = rects[i].normalized();
-            adjustForAliasing(&rect);
-
-            D2D1_RECT_F d2d_rect = to_d2d_rect_f(rect);
-
-            if (d->brush.brush)
-                d->dc()->FillRectangle(d2d_rect, d->brush.brush.Get());
-
-            if (d->pen.brush)
-                d->dc()->DrawRectangle(d2d_rect, d->pen.brush.Get(),
-                                       FLOAT(d->pen.qpen.widthF()), d->pen.strokeStyle.Get());
-        }
-    }
-}
-
-static bool isLinePositivelySloped(const QPointF &p1, const QPointF &p2)
-{
-    if (p2.x() > p1.x())
-        return p2.y() < p1.y();
-
-    if (p1.x() > p2.x())
-        return p1.y() < p2.y();
-
-    return false;
-}
-
-static void adjustLine(QPointF *p1, QPointF *p2)
-{
-    if (isLinePositivelySloped(*p1, *p2)) {
-        p1->ry() -= qreal(1.0);
-        p2->ry() -= qreal(1.0);
-    }
-}
-
-void QWindowsDirect2DPaintEngine::drawEllipse(const QRectF &r)
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    D2D_TAG(D2DDebugDrawEllipseFTag);
-
-    ensureBrush();
-    ensurePen();
-
-    if (emulationRequired(BrushEmulation) || emulationRequired(PenEmulation)) {
-        QPaintEngineEx::drawEllipse(r);
-    } else {
-        QPointF p = r.center();
-        adjustForAliasing(&p);
-
-        D2D1_ELLIPSE ellipse = {
-            to_d2d_point_2f(p),
-            FLOAT(r.width() / 2.0),
-            FLOAT(r.height() / 2.0)
-        };
-
-        if (d->brush.brush)
-            d->dc()->FillEllipse(ellipse, d->brush.brush.Get());
-
-        if (d->pen.brush)
-            d->dc()->DrawEllipse(ellipse, d->pen.brush.Get(),
-                                 FLOAT(d->pen.qpen.widthF()),
-                                 d->pen.strokeStyle.Get());
-    }
-}
-
-void QWindowsDirect2DPaintEngine::drawEllipse(const QRect &r)
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    D2D_TAG(D2DDebugDrawEllipseTag);
-
-    ensureBrush();
-    ensurePen();
-
-    if (emulationRequired(BrushEmulation) || emulationRequired(PenEmulation)) {
-        QPaintEngineEx::drawEllipse(r);
-    } else {
-        QPointF p = r.center();
-        adjustForAliasing(&p);
-
-        D2D1_ELLIPSE ellipse = {
-            to_d2d_point_2f(p),
-            FLOAT(r.width() / 2.0),
-            FLOAT(r.height() / 2.0)
-        };
-
-        if (d->brush.brush)
-            d->dc()->FillEllipse(ellipse, d->brush.brush.Get());
-
-        if (d->pen.brush)
-            d->dc()->DrawEllipse(ellipse, d->pen.brush.Get(),
-                                 FLOAT(d->pen.qpen.widthF()),
-                                 d->pen.strokeStyle.Get());
-    }
-}
-
-void QWindowsDirect2DPaintEngine::drawImage(const QRectF &rectangle, const QImage &image,
-                                            const QRectF &sr, Qt::ImageConversionFlags flags)
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    D2D_TAG(D2DDebugDrawImageTag);
-
-    QPixmap pixmap = QPixmap::fromImage(image, flags);
-    drawPixmap(rectangle, pixmap, sr);
-}
-
-void QWindowsDirect2DPaintEngine::drawPixmap(const QRectF &r,
-                                             const QPixmap &pm,
-                                             const QRectF &sr)
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    D2D_TAG(D2DDebugDrawPixmapTag);
-
-    if (pm.isNull())
-        return;
-
-    if (pm.handle()->pixelType() == QPlatformPixmap::BitmapType) {
-        QImage i = pm.toImage();
-        i.setColor(0, qRgba(0, 0, 0, 0));
-        i.setColor(1, d->pen.qpen.color().rgba());
-        drawImage(r, i, sr);
-        return;
-    }
-
-    if (d->flags.testFlag(EmulateComposition)) {
-        const qreal points[] = {
-            r.x(), r.y(),
-            r.x() + r.width(), r.y(),
-            r.x() + r.width(), r.y() + r.height(),
-            r.x(), r.y() + r.height()
-        };
-        const QVectorPath vp(points, 4, nullptr, QVectorPath::RectangleHint);
-        QBrush brush(sr.isValid() ? pm.copy(sr.toRect()) : pm);
-        brush.setTransform(QTransform::fromTranslate(r.x(), r.y()));
-        rasterFill(vp, brush);
-        return;
-    }
-
-    auto *pp = static_cast<QWindowsDirect2DPlatformPixmap *>(pm.handle());
-    QWindowsDirect2DBitmap *bitmap = pp->bitmap();
-
-    ensurePen();
-
-    if (bitmap->bitmap() != d->bitmap->bitmap()) {
-        // Good, src bitmap != dst bitmap
-        if (sr.isValid())
-            d->dc()->DrawBitmap(bitmap->bitmap(),
-                                to_d2d_rect_f(r), FLOAT(state()->opacity),
-                                d->interpolationMode(),
-                                to_d2d_rect_f(sr));
-        else
-            d->dc()->DrawBitmap(bitmap->bitmap(),
-                                to_d2d_rect_f(r), FLOAT(state()->opacity),
-                                d->interpolationMode());
-    } else {
-        // Ok, so the source pixmap and destination pixmap is the same.
-        // D2D is not fond of this scenario, deal with it through
-        // an intermediate bitmap
-        QWindowsDirect2DBitmap intermediate;
-
-        if (sr.isValid()) {
-            bool r = intermediate.resize(int(sr.width()), int(sr.height()));
-            if (!r) {
-                qWarning("%s: Could not resize intermediate bitmap to source rect size", __FUNCTION__);
-                return;
-            }
-
-            D2D1_RECT_U d2d_sr =  to_d2d_rect_u(sr.toRect());
-            HRESULT hr = intermediate.bitmap()->CopyFromBitmap(nullptr,
-                                                               bitmap->bitmap(),
-                                                               &d2d_sr);
-            if (FAILED(hr)) {
-                qWarning("%s: Could not copy source rect area from source bitmap to intermediate bitmap: %#lx", __FUNCTION__, hr);
-                return;
-            }
-        } else {
-            bool r = intermediate.resize(bitmap->size().width(),
-                                         bitmap->size().height());
-            if (!r) {
-                qWarning("%s: Could not resize intermediate bitmap to source bitmap size", __FUNCTION__);
-                return;
-            }
-
-            HRESULT hr = intermediate.bitmap()->CopyFromBitmap(nullptr,
-                                                               bitmap->bitmap(),
-                                                               nullptr);
-            if (FAILED(hr)) {
-                qWarning("%s: Could not copy source bitmap to intermediate bitmap: %#lx", __FUNCTION__, hr);
-                return;
-            }
-        }
-
-        d->dc()->DrawBitmap(intermediate.bitmap(),
-                            to_d2d_rect_f(r), FLOAT(state()->opacity),
-                            d->interpolationMode());
-    }
-}
-
-void QWindowsDirect2DPaintEngine::drawStaticTextItem(QStaticTextItem *staticTextItem)
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    D2D_TAG(D2DDebugDrawStaticTextItemTag);
-
-    if (staticTextItem->numGlyphs == 0)
-        return;
-
-    ensurePen();
-
-    // If we can't support the current configuration with Direct2D, fall back to slow path
-    if (emulationRequired(PenEmulation)) {
-        QPaintEngineEx::drawStaticTextItem(staticTextItem);
-        return;
-    }
-
-    ComPtr<IDWriteFontFace> fontFace = d->fontFaceFromFontEngine(staticTextItem->fontEngine());
-    if (!fontFace) {
-        qWarning("%s: Could not find font - falling back to slow text rendering path.", __FUNCTION__);
-        QPaintEngineEx::drawStaticTextItem(staticTextItem);
-        return;
-    }
-
-    QVarLengthArray<UINT16> glyphIndices(staticTextItem->numGlyphs);
-    QVarLengthArray<FLOAT> glyphAdvances(staticTextItem->numGlyphs);
-    QVarLengthArray<DWRITE_GLYPH_OFFSET> glyphOffsets(staticTextItem->numGlyphs);
-
-    for (int i = 0; i < staticTextItem->numGlyphs; i++) {
-        glyphIndices[i] = UINT16(staticTextItem->glyphs[i]); // Imperfect conversion here
-
-        // This looks  a little funky because the positions are precalculated
-        glyphAdvances[i] = 0;
-        glyphOffsets[i].advanceOffset = FLOAT(staticTextItem->glyphPositions[i].x.toReal());
-        // Qt and Direct2D seem to disagree on the direction of the ascender offset...
-        glyphOffsets[i].ascenderOffset = FLOAT(staticTextItem->glyphPositions[i].y.toReal() * -1);
-    }
-
-    d->drawGlyphRun(D2D1::Point2F(0, 0),
-                    fontFace.Get(),
-                    staticTextItem->fontEngine()->fontDef,
-                    staticTextItem->numGlyphs,
-                    glyphIndices.constData(),
-                    glyphAdvances.constData(),
-                    glyphOffsets.constData(),
-                    false);
-}
-
-void QWindowsDirect2DPaintEngine::drawTextItem(const QPointF &p, const QTextItem &textItem)
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    D2D_TAG(D2DDebugDrawTextItemTag);
-
-    const auto &ti = static_cast<const QTextItemInt &>(textItem);
-    if (ti.glyphs.numGlyphs == 0)
-        return;
-
-    ensurePen();
-
-    // If we can't support the current configuration with Direct2D, fall back to slow path
-    if (emulationRequired(PenEmulation)) {
-        QPaintEngine::drawTextItem(p, textItem);
-        return;
-    }
-
-    ComPtr<IDWriteFontFace> fontFace = d->fontFaceFromFontEngine(ti.fontEngine);
-    if (!fontFace) {
-        qWarning("%s: Could not find font - falling back to slow text rendering path.", __FUNCTION__);
-        QPaintEngine::drawTextItem(p, textItem);
-        return;
-    }
-
-    QVarLengthArray<UINT16> glyphIndices(ti.glyphs.numGlyphs);
-    QVarLengthArray<FLOAT> glyphAdvances(ti.glyphs.numGlyphs);
-    QVarLengthArray<DWRITE_GLYPH_OFFSET> glyphOffsets(ti.glyphs.numGlyphs);
-
-    for (int i = 0; i < ti.glyphs.numGlyphs; i++) {
-        glyphIndices[i] = UINT16(ti.glyphs.glyphs[i]); // Imperfect conversion here
-        glyphAdvances[i] = FLOAT(ti.glyphs.effectiveAdvance(i).toReal());
-        glyphOffsets[i].advanceOffset = FLOAT(ti.glyphs.offsets[i].x.toReal());
-
-        // XXX Should we negate the y value like for static text items?
-        glyphOffsets[i].ascenderOffset = FLOAT(ti.glyphs.offsets[i].y.toReal());
-    }
-
-    const bool rtl = (ti.flags & QTextItem::RightToLeft);
-    const QPointF offset(rtl ? ti.width.toReal() : 0, 0);
-
-    d->drawGlyphRun(to_d2d_point_2f(p + offset),
-                    fontFace.Get(),
-                    ti.fontEngine->fontDef,
-                    ti.glyphs.numGlyphs,
-                    glyphIndices.constData(),
-                    glyphAdvances.constData(),
-                    glyphOffsets.constData(),
-                    rtl);
-}
-
-void QWindowsDirect2DPaintEngine::ensureBrush()
-{
-    ensureBrush(state()->brush);
-}
-
-void QWindowsDirect2DPaintEngine::ensureBrush(const QBrush &brush)
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    d->updateBrush(brush);
-}
-
-void QWindowsDirect2DPaintEngine::ensurePen()
-{
-    ensurePen(state()->pen);
-}
-
-void QWindowsDirect2DPaintEngine::ensurePen(const QPen &pen)
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-    d->updatePen(pen);
-}
-
-void QWindowsDirect2DPaintEngine::rasterFill(const QVectorPath &path, const QBrush &brush)
-{
-    Q_D(QWindowsDirect2DPaintEngine);
-
-    if (d->fallbackImage.isNull()) {
-        if (d->flags.testFlag(EmulateComposition)) {
-            QWindowsDirect2DPaintEngineSuspender suspender(this);
-            d->fallbackImage = d->bitmap->toImage();
-        } else {
-            d->fallbackImage = QImage(d->bitmap->size(), QImage::Format_ARGB32_Premultiplied);
-            d->fallbackImage.fill(Qt::transparent);
-        }
-    }
-
-    QImage &img = d->fallbackImage;
-    QPainter p;
-    QPaintEngine *engine = img.paintEngine();
-
-    if (engine->isExtended() && p.begin(&img)) {
-        p.setRenderHints(state()->renderHints);
-        p.setCompositionMode(state()->compositionMode());
-        p.setOpacity(state()->opacity);
-        p.setBrushOrigin(state()->brushOrigin);
-        p.setBrush(state()->brush);
-        p.setPen(state()->pen);
-
-        auto *extended = static_cast<QPaintEngineEx *>(engine);
-        for (const QPainterClipInfo &info : std::as_const(state()->clipInfo)) {
-            extended->state()->matrix = info.matrix;
-            extended->transformChanged();
-
-            switch (info.clipType) {
-            case QPainterClipInfo::RegionClip:
-                extended->clip(info.region, info.operation);
-                break;
-            case QPainterClipInfo::PathClip:
-                extended->clip(info.path, info.operation);
-                break;
-            case QPainterClipInfo::RectClip:
-                extended->clip(info.rect, info.operation);
-                break;
-            case QPainterClipInfo::RectFClip:
-                qreal right = info.rectf.x() + info.rectf.width();
-                qreal bottom = info.rectf.y() + info.rectf.height();
-                qreal pts[] = { info.rectf.x(), info.rectf.y(),
-                                right, info.rectf.y(),
-                                right, bottom,
-                                info.rectf.x(), bottom };
-                QVectorPath vp(pts, 4, nullptr, QVectorPath::RectangleHint);
-                extended->clip(vp, info.operation);
-                break;
-            }
-        }
-
-        extended->state()->matrix = state()->matrix;
-        extended->transformChanged();
-
-        extended->fill(path, brush);
-        if (!p.end())
-            qWarning("%s: Paint Engine end returned false", __FUNCTION__);
-
-        if (!d->flags.testFlag(EmulateComposition)) { // Emulated fallback will be flattened in end()
-            d->updateClipEnabled(false);
-            d->updateTransform(QTransform());
-            drawImage(img.rect(), img, img.rect());
-            d->fallbackImage = QImage();
-            transformChanged();
-            clipEnabledChanged();
-        }
-    } else {
-        qWarning("%s: Could not fall back to QImage", __FUNCTION__);
-    }
-}
-
-bool QWindowsDirect2DPaintEngine::emulationRequired(EmulationType type) const
-{
-    Q_D(const QWindowsDirect2DPaintEngine);
-
-    if (d->flags.testFlag(EmulateComposition))
-        return true;
-
-    if (!state()->matrix.isAffine())
-        return true;
-
-    switch (type) {
-    case PenEmulation:
-        return d->pen.emulate;
-        break;
-    case BrushEmulation:
-        return d->brush.emulate;
-        break;
-    }
-
-    return false;
-}
-
-bool QWindowsDirect2DPaintEngine::antiAliasingEnabled() const
-{
-    return state()->renderHints & QPainter::Antialiasing;
-}
-
-void QWindowsDirect2DPaintEngine::adjustForAliasing(QRectF *rect)
-{
-   if (!antiAliasingEnabled()) {
-       rect->adjust(MAGICAL_ALIASING_OFFSET,
-                    MAGICAL_ALIASING_OFFSET,
-                    MAGICAL_ALIASING_OFFSET,
-                    MAGICAL_ALIASING_OFFSET);
-   }
-}
-
-void QWindowsDirect2DPaintEngine::adjustForAliasing(QPointF *point)
-{
-    static const QPointF adjustment(MAGICAL_ALIASING_OFFSET,
-                                    MAGICAL_ALIASING_OFFSET);
-
-    if (!antiAliasingEnabled())
-        (*point) += adjustment;
-}
-
-void QWindowsDirect2DPaintEngine::suspend()
-{
-    end();
-}
-
-void QWindowsDirect2DPaintEngine::resume()
-{
-    begin(paintDevice());
-    clipEnabledChanged();
-    penChanged();
-    brushChanged();
-    brushOriginChanged();
-    opacityChanged();
-    compositionModeChanged();
-    renderHintsChanged();
-    transformChanged();
-}
-
-class QWindowsDirect2DPaintEngineSuspenderImpl
-{
-    Q_DISABLE_COPY_MOVE(QWindowsDirect2DPaintEngineSuspenderImpl)
-    QWindowsDirect2DPaintEngine *m_engine;
-    bool m_active;
-public:
-    QWindowsDirect2DPaintEngineSuspenderImpl(QWindowsDirect2DPaintEngine *engine)
-        : m_engine(engine)
-        , m_active(engine->isActive())
-    {
-        if (m_active)
-            m_engine->suspend();
-    }
-
-    ~QWindowsDirect2DPaintEngineSuspenderImpl()
-    {
-        if (m_active)
-            m_engine->resume();
-    }
-};
-
-class QWindowsDirect2DPaintEngineSuspenderPrivate
-{
-public:
-    QWindowsDirect2DPaintEngineSuspenderPrivate(QWindowsDirect2DPaintEngine *engine)
-        : engineSuspender(engine)
-        , dcSuspender(static_cast<QWindowsDirect2DPaintEnginePrivate *>(engine->d_ptr.data())->bitmap->deviceContext())
-    {
-    }
-
-    QWindowsDirect2DPaintEngineSuspenderImpl engineSuspender;
-    QWindowsDirect2DDeviceContextSuspender dcSuspender;
-};
-
-QWindowsDirect2DPaintEngineSuspender::QWindowsDirect2DPaintEngineSuspender(QWindowsDirect2DPaintEngine *engine)
-    : d_ptr(new QWindowsDirect2DPaintEngineSuspenderPrivate(engine))
-{
-
-}
-
-QWindowsDirect2DPaintEngineSuspender::~QWindowsDirect2DPaintEngineSuspender()
-{
-}
-
-void QWindowsDirect2DPaintEngineSuspender::resume()
-{
-    d_ptr.reset();
-}
-
-QT_END_NAMESPACE
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dpaintengine.h b/src/plugins/platforms/direct2d/qwindowsdirect2dpaintengine.h
deleted file mode 100644
index f2f54f2e01..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dpaintengine.h
+++ /dev/null
@@ -1,106 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QWINDOWSDIRECT2DPAINTENGINE_H
-#define QWINDOWSDIRECT2DPAINTENGINE_H
-
-#include <QtCore/qscopedpointer.h>
-#include <QtGui/private/qpaintengineex_p.h>
-
-struct ID2D1Geometry;
-
-QT_BEGIN_NAMESPACE
-
-class QWindowsDirect2DPaintEnginePrivate;
-class QWindowsDirect2DBitmap;
-
-class QWindowsDirect2DPaintEngine : public QPaintEngineEx
-{
-    Q_DECLARE_PRIVATE(QWindowsDirect2DPaintEngine)
-    friend class QWindowsDirect2DPaintEngineSuspenderImpl;
-    friend class QWindowsDirect2DPaintEngineSuspenderPrivate;
-public:
-    enum Flag {
-        NoFlag = 0,
-        TranslucentTopLevelWindow = 1,
-        EmulateComposition = 2,
-    };
-    Q_DECLARE_FLAGS(Flags, Flag)
-
-    QWindowsDirect2DPaintEngine(QWindowsDirect2DBitmap *bitmap, Flags flags);
-
-    bool begin(QPaintDevice *pdev) override;
-    bool end() override;
-
-    Type type() const override;
-
-    void setState(QPainterState *s) override;
-
-    void draw(const QVectorPath &path) override;
-
-    void fill(const QVectorPath &path, const QBrush &brush) override;
-    void fill(ID2D1Geometry *geometry, const QBrush &brush);
-
-    void stroke(const QVectorPath &path, const QPen &pen) override;
-    void stroke(ID2D1Geometry *geometry, const QPen &pen);
-
-    void clip(const QVectorPath &path, Qt::ClipOperation op) override;
-
-    void clipEnabledChanged() override;
-    void penChanged() override;
-    void brushChanged() override;
-    void brushOriginChanged() override;
-    void opacityChanged() override;
-    void compositionModeChanged() override;
-    void renderHintsChanged() override;
-    void transformChanged() override;
-
-    void fillRect(const QRectF &rect, const QBrush &brush) override;
-
-    void drawRects(const QRect *rects, int rectCount) override;
-    void drawRects(const QRectF *rects, int rectCount) override;
-
-    void drawEllipse(const QRectF &r) override;
-    void drawEllipse(const QRect &r) override;
-
-    void drawImage(const QRectF &rectangle, const QImage &image, const QRectF &sr, Qt::ImageConversionFlags flags = Qt::AutoColor) override;
-    void drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr) override;
-
-    void drawStaticTextItem(QStaticTextItem *staticTextItem) override;
-    void drawTextItem(const QPointF &p, const QTextItem &textItem) override;
-
-private:
-    void ensureBrush();
-    void ensureBrush(const QBrush &brush);
-    void ensurePen();
-    void ensurePen(const QPen &pen);
-
-    void rasterFill(const QVectorPath &path, const QBrush &brush);
-
-    enum EmulationType { PenEmulation, BrushEmulation };
-    bool emulationRequired(EmulationType type) const;
-
-    bool antiAliasingEnabled() const;
-    void adjustForAliasing(QRectF *rect);
-    void adjustForAliasing(QPointF *point);
-
-    void suspend();
-    void resume();
-};
-Q_DECLARE_OPERATORS_FOR_FLAGS(QWindowsDirect2DPaintEngine::Flags)
-
-class QWindowsDirect2DPaintEngineSuspenderPrivate;
-class QWindowsDirect2DPaintEngineSuspender
-{
-    Q_DISABLE_COPY_MOVE(QWindowsDirect2DPaintEngineSuspender)
-    Q_DECLARE_PRIVATE(QWindowsDirect2DPaintEngineSuspender)
-    QScopedPointer<QWindowsDirect2DPaintEngineSuspenderPrivate> d_ptr;
-public:
-    QWindowsDirect2DPaintEngineSuspender(QWindowsDirect2DPaintEngine *engine);
-    ~QWindowsDirect2DPaintEngineSuspender();
-    void resume();
-};
-
-QT_END_NAMESPACE
-
-#endif // QWINDOWSDIRECT2DPAINTENGINE_H
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dplatformpixmap.cpp b/src/plugins/platforms/direct2d/qwindowsdirect2dplatformpixmap.cpp
deleted file mode 100644
index 54095ba920..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dplatformpixmap.cpp
+++ /dev/null
@@ -1,157 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include "qwindowsdirect2dcontext.h"
-#include "qwindowsdirect2dpaintdevice.h"
-#include "qwindowsdirect2dplatformpixmap.h"
-#include "qwindowsdirect2dbitmap.h"
-#include "qwindowsdirect2dhelpers.h"
-
-#include <QtGui/qpainter.h>
-#include <QtGui/qimage.h>
-#include <QtGui/qpaintdevice.h>
-#include <QtGui/qpaintengine.h>
-
-QT_BEGIN_NAMESPACE
-
-class QWindowsDirect2DPlatformPixmapPrivate
-{
-public:
-    QWindowsDirect2DPlatformPixmapPrivate()
-        : owns_bitmap(true)
-        , bitmap(new QWindowsDirect2DBitmap)
-        , device(new QWindowsDirect2DPaintDevice(bitmap, QInternal::Pixmap))
-    {}
-
-    QWindowsDirect2DPlatformPixmapPrivate(QWindowsDirect2DBitmap *bitmap,
-                                          QWindowsDirect2DPaintEngine::Flags flags)
-        : bitmap(bitmap)
-        , device(new QWindowsDirect2DPaintDevice(bitmap, QInternal::Pixmap, flags))
-    {}
-
-    ~QWindowsDirect2DPlatformPixmapPrivate()
-    {
-        if (owns_bitmap)
-            delete bitmap;
-    }
-
-    bool owns_bitmap = false;
-    QWindowsDirect2DBitmap *bitmap;
-    QScopedPointer<QWindowsDirect2DPaintDevice> device;
-    qreal devicePixelRatio = 1.0;
-};
-
-static int qt_d2dpixmap_serno = 0;
-
-QWindowsDirect2DPlatformPixmap::QWindowsDirect2DPlatformPixmap(PixelType pixelType)
-    : QPlatformPixmap(pixelType, Direct2DClass)
-    , d_ptr(new QWindowsDirect2DPlatformPixmapPrivate)
-{
-    setSerialNumber(qt_d2dpixmap_serno++);
-}
-
-QWindowsDirect2DPlatformPixmap::QWindowsDirect2DPlatformPixmap(QPlatformPixmap::PixelType pixelType,
-                                                               QWindowsDirect2DPaintEngine::Flags flags,
-                                                               QWindowsDirect2DBitmap *bitmap)
-    : QPlatformPixmap(pixelType, Direct2DClass)
-    , d_ptr(new QWindowsDirect2DPlatformPixmapPrivate(bitmap, flags))
-{
-    setSerialNumber(qt_d2dpixmap_serno++);
-
-    is_null = false;
-    w = bitmap->size().width();
-    h = bitmap->size().height();
-    this->d = 32;
-}
-
-QWindowsDirect2DPlatformPixmap::~QWindowsDirect2DPlatformPixmap()
-{
-
-}
-
-void QWindowsDirect2DPlatformPixmap::resize(int width, int height)
-{
-    Q_D(QWindowsDirect2DPlatformPixmap);
-
-    if (!d->bitmap->resize(width, height)) {
-        qWarning("%s: Could not resize bitmap", __FUNCTION__);
-        return;
-    }
-
-    is_null = false;
-    w = width;
-    h = height;
-    this->d = 32;
-}
-
-void QWindowsDirect2DPlatformPixmap::fromImage(const QImage &image,
-                                               Qt::ImageConversionFlags flags)
-{
-    Q_D(QWindowsDirect2DPlatformPixmap);
-
-    if (!d->bitmap->fromImage(image, flags)) {
-        qWarning("%s: Could not init from image", __FUNCTION__);
-        return;
-    }
-
-    is_null = false;
-    w = image.width();
-    h = image.height();
-    this->d = 32;
-}
-
-int QWindowsDirect2DPlatformPixmap::metric(QPaintDevice::PaintDeviceMetric metric) const
-{
-    Q_D(const QWindowsDirect2DPlatformPixmap);
-    return qt_paint_device_metric(d->device.data(), metric);
-}
-
-void QWindowsDirect2DPlatformPixmap::fill(const QColor &color)
-{
-    Q_D(QWindowsDirect2DPlatformPixmap);
-    d->bitmap->fill(color);
-}
-
-bool QWindowsDirect2DPlatformPixmap::hasAlphaChannel() const
-{
-    return true;
-}
-
-QImage QWindowsDirect2DPlatformPixmap::toImage() const
-{
-    return toImage(QRect());
-}
-
-QImage QWindowsDirect2DPlatformPixmap::toImage(const QRect &rect) const
-{
-    Q_D(const QWindowsDirect2DPlatformPixmap);
-
-    QWindowsDirect2DPaintEngineSuspender suspender(static_cast<QWindowsDirect2DPaintEngine *>(d->device->paintEngine()));
-    return d->bitmap->toImage(rect);
-}
-
-QPaintEngine* QWindowsDirect2DPlatformPixmap::paintEngine() const
-{
-    Q_D(const QWindowsDirect2DPlatformPixmap);
-    return d->device->paintEngine();
-}
-
-qreal QWindowsDirect2DPlatformPixmap::devicePixelRatio() const
-{
-    Q_D(const QWindowsDirect2DPlatformPixmap);
-    return d->devicePixelRatio;
-}
-
-void QWindowsDirect2DPlatformPixmap::setDevicePixelRatio(qreal scaleFactor)
-{
-    Q_D(QWindowsDirect2DPlatformPixmap);
-    d->devicePixelRatio = scaleFactor;
-}
-
-QWindowsDirect2DBitmap *QWindowsDirect2DPlatformPixmap::bitmap() const
-{
-    Q_D(const QWindowsDirect2DPlatformPixmap);
-    return d->bitmap;
-}
-
-QT_END_NAMESPACE
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dplatformpixmap.h b/src/plugins/platforms/direct2d/qwindowsdirect2dplatformpixmap.h
deleted file mode 100644
index e571fece4e..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dplatformpixmap.h
+++ /dev/null
@@ -1,50 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QWINDOWSDIRECT2DPLATFORMPIXMAP_H
-#define QWINDOWSDIRECT2DPLATFORMPIXMAP_H
-
-#include "qwindowsdirect2dpaintengine.h"
-#include <QtGui/qpa/qplatformpixmap.h>
-#include <QtCore/qscopedpointer.h>
-
-QT_BEGIN_NAMESPACE
-
-class QWindowsDirect2DPlatformPixmapPrivate;
-class QWindowsDirect2DBitmap;
-
-class QWindowsDirect2DPlatformPixmap : public QPlatformPixmap
-{
-    Q_DECLARE_PRIVATE(QWindowsDirect2DPlatformPixmap)
-public:
-    QWindowsDirect2DPlatformPixmap(PixelType pixelType);
-
-    // We do NOT take ownership of the bitmap through this constructor!
-    QWindowsDirect2DPlatformPixmap(PixelType pixelType, QWindowsDirect2DPaintEngine::Flags flags, QWindowsDirect2DBitmap *bitmap);
-    ~QWindowsDirect2DPlatformPixmap();
-
-    void resize(int width, int height) override;
-    void fromImage(const QImage &image, Qt::ImageConversionFlags flags) override;
-
-    int metric(QPaintDevice::PaintDeviceMetric metric) const override;
-    void fill(const QColor &color) override;
-
-    bool hasAlphaChannel() const override;
-
-    QImage toImage() const override;
-    QImage toImage(const QRect &rect) const override;
-
-    QPaintEngine* paintEngine() const override;
-
-    qreal devicePixelRatio() const override;
-    void setDevicePixelRatio(qreal scaleFactor) override;
-
-    QWindowsDirect2DBitmap *bitmap() const;
-
-private:
-    QScopedPointer<QWindowsDirect2DPlatformPixmapPrivate> d_ptr;
-};
-
-QT_END_NAMESPACE
-
-#endif // QWINDOWSDIRECT2DPLATFORMPIXMAP_H
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dplatformplugin.cpp b/src/plugins/platforms/direct2d/qwindowsdirect2dplatformplugin.cpp
deleted file mode 100644
index 9f0face1fc..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dplatformplugin.cpp
+++ /dev/null
@@ -1,30 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include "qwindowsdirect2dintegration.h"
-
-#include <QtGui/qpa/qplatformintegrationplugin.h>
-#include <QtCore/qstringlist.h>
-
-QT_BEGIN_NAMESPACE
-
-using namespace Qt::StringLiterals;
-
-class QWindowsDirect2DIntegrationPlugin : public QPlatformIntegrationPlugin
-{
-    Q_OBJECT
-    Q_PLUGIN_METADATA(IID QPlatformIntegrationFactoryInterface_iid FILE "direct2d.json")
-public:
-    QPlatformIntegration *create(const QString&, const QStringList&) override;
-};
-
-QPlatformIntegration *QWindowsDirect2DIntegrationPlugin::create(const QString& system, const QStringList& paramList)
-{
-    if (system.compare(system, "direct2d"_L1, Qt::CaseInsensitive) == 0)
-        return QWindowsDirect2DIntegration::create(paramList);
-    return nullptr;
-}
-
-QT_END_NAMESPACE
-
-#include "qwindowsdirect2dplatformplugin.moc"
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dwindow.cpp b/src/plugins/platforms/direct2d/qwindowsdirect2dwindow.cpp
deleted file mode 100644
index 669166b73d..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dwindow.cpp
+++ /dev/null
@@ -1,283 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include "qwindowsdirect2dcontext.h"
-#include "qwindowsdirect2dbitmap.h"
-#include "qwindowsdirect2dwindow.h"
-#include "qwindowsdirect2ddevicecontext.h"
-#include "qwindowsdirect2dhelpers.h"
-#include "qwindowsdirect2dplatformpixmap.h"
-
-#include <d3d11.h>
-#include <d2d1_1.h>
-#include <dxgi1_2.h>
-
-using Microsoft::WRL::ComPtr;
-
-QT_BEGIN_NAMESPACE
-
-QWindowsDirect2DWindow::QWindowsDirect2DWindow(QWindow *window, const QWindowsWindowData &data)
-    : QWindowsWindow(window, data)
-    , m_directRendering(!(data.flags & Qt::FramelessWindowHint && window->format().hasAlpha()))
-{
-    if (window->type() == Qt::Desktop)
-        return; // No further handling for Qt::Desktop
-
-    if (m_directRendering)
-        setupSwapChain();
-
-    HRESULT hr = QWindowsDirect2DContext::instance()->d2dDevice()->CreateDeviceContext(
-                D2D1_DEVICE_CONTEXT_OPTIONS_NONE,
-                m_deviceContext.GetAddressOf());
-    if (FAILED(hr))
-        qWarning("%s: Couldn't create Direct2D Device context: %#lx", __FUNCTION__, hr);
-}
-
-QWindowsDirect2DWindow::~QWindowsDirect2DWindow()
-{
-}
-
-void QWindowsDirect2DWindow::setWindowFlags(Qt::WindowFlags flags)
-{
-    m_directRendering = !(flags & Qt::FramelessWindowHint && window()->format().hasAlpha());
-    if (!m_directRendering)
-        m_swapChain.Reset(); // No need for the swap chain; release from memory
-    else if (!m_swapChain)
-        setupSwapChain();
-
-    QWindowsWindow::setWindowFlags(flags);
-}
-
-QPixmap *QWindowsDirect2DWindow::pixmap()
-{
-    setupBitmap();
-
-    return m_pixmap.data();
-}
-
-void QWindowsDirect2DWindow::flush(QWindowsDirect2DBitmap *bitmap, const QRegion &region, const QPoint &offset)
-{
-    QSize size;
-    if (m_directRendering) {
-        DXGI_SWAP_CHAIN_DESC1 desc;
-        HRESULT hr = m_swapChain->GetDesc1(&desc);
-        QRect geom = geometry();
-
-        if (FAILED(hr) || (desc.Width != UINT(geom.width()) || (desc.Height != UINT(geom.height())))) {
-            resizeSwapChain(geom.size());
-            m_swapChain->GetDesc1(&desc);
-        }
-        size.setWidth(int(desc.Width));
-        size.setHeight(int(desc.Height));
-    } else {
-        size = geometry().size();
-    }
-
-    setupBitmap();
-    if (!m_bitmap)
-        return;
-
-    if (bitmap != m_bitmap.data()) {
-        m_bitmap->deviceContext()->begin();
-
-        ID2D1DeviceContext *dc = m_bitmap->deviceContext()->get();
-        if (!m_needsFullFlush) {
-            QRegion clipped = region;
-            clipped &= QRect(QPoint(), size);
-
-            for (const QRect &rect : clipped) {
-                QRectF rectF(rect);
-                dc->DrawBitmap(bitmap->bitmap(),
-                               to_d2d_rect_f(rectF),
-                               1.0,
-                               D2D1_INTERPOLATION_MODE_LINEAR,
-                               to_d2d_rect_f(rectF.translated(offset.x(), offset.y())));
-            }
-        } else {
-            QRectF rectF(QPoint(), size);
-            dc->DrawBitmap(bitmap->bitmap(),
-                           to_d2d_rect_f(rectF),
-                           1.0,
-                           D2D1_INTERPOLATION_MODE_LINEAR,
-                           to_d2d_rect_f(rectF.translated(offset.x(), offset.y())));
-            m_needsFullFlush = false;
-        }
-
-        m_bitmap->deviceContext()->end();
-    }
-}
-
-void QWindowsDirect2DWindow::present(const QRegion &region)
-{
-    if (m_directRendering) {
-        m_swapChain->Present(0, 0);
-        return;
-    }
-
-    ComPtr<IDXGISurface> bitmapSurface;
-    HRESULT hr = m_bitmap->bitmap()->GetSurface(&bitmapSurface);
-    Q_ASSERT(SUCCEEDED(hr));
-    ComPtr<IDXGISurface1> dxgiSurface;
-    hr = bitmapSurface.As(&dxgiSurface);
-    Q_ASSERT(SUCCEEDED(hr));
-
-    HDC hdc;
-    hr = dxgiSurface->GetDC(FALSE, &hdc);
-    if (FAILED(hr)) {
-        qErrnoWarning(hr, "Failed to get DC for presenting the surface");
-        return;
-    }
-
-    const QRect bounds = window()->geometry();
-    const SIZE size = { bounds.width(), bounds.height() };
-    const POINT ptDst = { bounds.x(), bounds.y() };
-    const POINT ptSrc = { 0, 0 };
-    const BLENDFUNCTION blend = { AC_SRC_OVER, 0, BYTE(255.0 * opacity()), AC_SRC_ALPHA };
-    const QRect r = region.boundingRect();
-    const RECT dirty = { r.left(), r.top(), r.left() + r.width(), r.top() + r.height() };
-    UPDATELAYEREDWINDOWINFO info = { sizeof(UPDATELAYEREDWINDOWINFO), nullptr,
-                                     &ptDst, &size, hdc, &ptSrc, 0, &blend, ULW_ALPHA, &dirty };
-    if (!UpdateLayeredWindowIndirect(handle(), &info))
-        qErrnoWarning(int(GetLastError()), "Failed to update the layered window");
-
-    hr = dxgiSurface->ReleaseDC(nullptr);
-    if (FAILED(hr))
-        qErrnoWarning(hr, "Failed to release the DC for presentation");
-}
-
-void QWindowsDirect2DWindow::setupSwapChain()
-{
-    DXGI_SWAP_CHAIN_DESC1 desc = {};
-
-    desc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
-    desc.SampleDesc.Count = 1;
-    desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
-    desc.BufferCount = 1;
-    desc.SwapEffect = DXGI_SWAP_EFFECT_SEQUENTIAL;
-
-    HRESULT hr = QWindowsDirect2DContext::instance()->dxgiFactory()->CreateSwapChainForHwnd(
-                QWindowsDirect2DContext::instance()->d3dDevice(), // [in]   IUnknown *pDevice
-                handle(),                                         // [in]   HWND hWnd
-                &desc,                                            // [in]   const DXGI_SWAP_CHAIN_DESC1 *pDesc
-                nullptr,                                          // [in]   const DXGI_SWAP_CHAIN_FULLSCREEN_DESC *pFullscreenDesc
-                nullptr,                                          // [in]   IDXGIOutput *pRestrictToOutput
-                m_swapChain.ReleaseAndGetAddressOf());            // [out]  IDXGISwapChain1 **ppSwapChain
-
-    if (FAILED(hr))
-        qWarning("%s: Could not create swap chain: %#lx", __FUNCTION__, hr);
-
-    m_needsFullFlush = true;
-}
-
-void QWindowsDirect2DWindow::resizeSwapChain(const QSize &size)
-{
-    m_pixmap.reset();
-    m_bitmap.reset();
-    m_deviceContext->SetTarget(nullptr);
-    m_needsFullFlush = true;
-
-    if (!m_swapChain)
-        return;
-
-    HRESULT hr = m_swapChain->ResizeBuffers(0,
-                                            UINT(size.width()), UINT(size.height()),
-                                            DXGI_FORMAT_UNKNOWN,
-                                            0);
-    if (FAILED(hr))
-        qWarning("%s: Could not resize swap chain: %#lx", __FUNCTION__, hr);
-}
-
-QSharedPointer<QWindowsDirect2DBitmap> QWindowsDirect2DWindow::copyBackBuffer() const
-{
-    const QSharedPointer<QWindowsDirect2DBitmap> null_result;
-
-    if (!m_bitmap)
-        return null_result;
-
-    D2D1_PIXEL_FORMAT format = m_bitmap->bitmap()->GetPixelFormat();
-    D2D1_SIZE_U size = m_bitmap->bitmap()->GetPixelSize();
-
-    FLOAT dpiX, dpiY;
-    m_bitmap->bitmap()->GetDpi(&dpiX, &dpiY);
-
-    D2D1_BITMAP_PROPERTIES1 properties = {
-        format,                     // D2D1_PIXEL_FORMAT pixelFormat;
-        dpiX,                       // FLOAT dpiX;
-        dpiY,                       // FLOAT dpiY;
-        D2D1_BITMAP_OPTIONS_TARGET, // D2D1_BITMAP_OPTIONS bitmapOptions;
-        nullptr                   // _Field_size_opt_(1) ID2D1ColorContext *colorContext;
-    };
-    ComPtr<ID2D1Bitmap1> copy;
-    HRESULT hr = m_deviceContext.Get()->CreateBitmap(size, nullptr, 0, properties, &copy);
-
-    if (FAILED(hr)) {
-        qWarning("%s: Could not create staging bitmap: %#lx", __FUNCTION__, hr);
-        return null_result;
-    }
-
-    hr = copy.Get()->CopyFromBitmap(nullptr, m_bitmap->bitmap(), nullptr);
-    if (FAILED(hr)) {
-        qWarning("%s: Could not copy from bitmap! %#lx", __FUNCTION__, hr);
-        return null_result;
-    }
-
-    return QSharedPointer<QWindowsDirect2DBitmap>(new QWindowsDirect2DBitmap(copy.Get(), nullptr));
-}
-
-void QWindowsDirect2DWindow::setupBitmap()
-{
-    if (m_bitmap)
-        return;
-
-    if (!m_deviceContext)
-        return;
-
-    if (m_directRendering && !m_swapChain)
-        return;
-
-    HRESULT hr;
-    ComPtr<IDXGISurface1> backBufferSurface;
-    if (m_directRendering) {
-        hr = m_swapChain->GetBuffer(0, IID_PPV_ARGS(&backBufferSurface));
-        if (FAILED(hr)) {
-            qWarning("%s: Could not query backbuffer for DXGI Surface: %#lx", __FUNCTION__, hr);
-            return;
-        }
-    } else {
-        const QRect rect = geometry();
-        CD3D11_TEXTURE2D_DESC backBufferDesc(DXGI_FORMAT_B8G8R8A8_UNORM, UINT(rect.width()), UINT(rect.height()), 1, 1);
-        backBufferDesc.BindFlags = D3D11_BIND_RENDER_TARGET;
-        backBufferDesc.MiscFlags = D3D11_RESOURCE_MISC_GDI_COMPATIBLE;
-        ComPtr<ID3D11Texture2D> backBufferTexture;
-        HRESULT hr = QWindowsDirect2DContext::instance()->d3dDevice()->CreateTexture2D(&backBufferDesc, nullptr, &backBufferTexture);
-        if (FAILED(hr)) {
-            qErrnoWarning(hr, "Failed to create backing texture for indirect rendering");
-            return;
-        }
-
-        hr = backBufferTexture.As(&backBufferSurface);
-        if (FAILED(hr)) {
-            qErrnoWarning(hr, "Failed to cast back buffer surface to DXGI surface");
-            return;
-        }
-    }
-
-    ComPtr<ID2D1Bitmap1> backBufferBitmap;
-    hr = m_deviceContext->CreateBitmapFromDxgiSurface(backBufferSurface.Get(), nullptr, backBufferBitmap.GetAddressOf());
-    if (FAILED(hr)) {
-        qWarning("%s: Could not create Direct2D Bitmap from DXGI Surface: %#lx", __FUNCTION__, hr);
-        return;
-    }
-
-    m_bitmap.reset(new QWindowsDirect2DBitmap(backBufferBitmap.Get(), m_deviceContext.Get()));
-
-    QWindowsDirect2DPaintEngine::Flags flags = QWindowsDirect2DPaintEngine::NoFlag;
-    if (!m_directRendering)
-        flags |= QWindowsDirect2DPaintEngine::TranslucentTopLevelWindow;
-    auto *pp = new QWindowsDirect2DPlatformPixmap(QPlatformPixmap::PixmapType,
-                                                                            flags,
-                                                                            m_bitmap.data());
-    m_pixmap.reset(new QPixmap(pp));
-}
-
-QT_END_NAMESPACE
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dwindow.h b/src/plugins/platforms/direct2d/qwindowsdirect2dwindow.h
deleted file mode 100644
index bb7d406a33..0000000000
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dwindow.h
+++ /dev/null
@@ -1,47 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QWINDOWSDIRECT2DWINDOW_H
-#define QWINDOWSDIRECT2DWINDOW_H
-
-#include "qwindowswindow.h"
-#include <wrl.h>
-
-struct IDXGISwapChain1;
-struct ID2D1DeviceContext;
-
-QT_BEGIN_NAMESPACE
-
-class QWindowsDirect2DBitmap;
-
-class QWindowsDirect2DWindow : public QWindowsWindow
-{
-public:
-    QWindowsDirect2DWindow(QWindow *window, const QWindowsWindowData &data);
-    ~QWindowsDirect2DWindow();
-
-    void setWindowFlags(Qt::WindowFlags flags) override;
-
-    QPixmap *pixmap();
-    void flush(QWindowsDirect2DBitmap *bitmap, const QRegion &region, const QPoint &offset);
-    void present(const QRegion &region);
-    void setupSwapChain();
-    void resizeSwapChain(const QSize &size);
-
-    QSharedPointer<QWindowsDirect2DBitmap> copyBackBuffer() const;
-
-private:
-    void setupBitmap();
-
-private:
-    Microsoft::WRL::ComPtr<IDXGISwapChain1> m_swapChain;
-    Microsoft::WRL::ComPtr<ID2D1DeviceContext> m_deviceContext;
-    QScopedPointer<QWindowsDirect2DBitmap> m_bitmap;
-    QScopedPointer<QPixmap> m_pixmap;
-    bool m_needsFullFlush = true;
-    bool m_directRendering = false;
-};
-
-QT_END_NAMESPACE
-
-#endif // QWINDOWSDIRECT2DWINDOW_H
diff --git a/src/plugins/platforms/minimal/CMakeLists.txt b/src/plugins/platforms/minimal/CMakeLists.txt
deleted file mode 100644
index 21377fb466..0000000000
--- a/src/plugins/platforms/minimal/CMakeLists.txt
+++ /dev/null
@@ -1,41 +0,0 @@
-# Copyright (C) 2022 The Qt Company Ltd.
-# SPDX-License-Identifier: BSD-3-Clause
-
-# Generated from minimal.pro.
-
-#####################################################################
-## QMinimalIntegrationPlugin Plugin:
-#####################################################################
-
-qt_find_package(WrapFreetype PROVIDED_TARGETS WrapFreetype::WrapFreetype) # special case
-
-qt_internal_add_plugin(QMinimalIntegrationPlugin
-    OUTPUT_NAME qminimal
-    PLUGIN_TYPE platforms
-    DEFAULT_IF ${QT_QPA_DEFAULT_PLATFORM} MATCHES minimal # special case
-    SOURCES
-        main.cpp
-        qminimalbackingstore.cpp qminimalbackingstore.h
-        qminimalintegration.cpp qminimalintegration.h
-    DEFINES
-        QT_NO_FOREACH
-    LIBRARIES
-        Qt::Core
-        Qt::CorePrivate
-        Qt::Gui
-        Qt::GuiPrivate
-)
-
-#### Keys ignored in scope 1:.:.:minimal.pro:<TRUE>:
-# OTHER_FILES = "minimal.json"
-
-## Scopes:
-#####################################################################
-
-qt_internal_extend_target(QMinimalIntegrationPlugin CONDITION QT_FEATURE_freetype
-    LIBRARIES
-        WrapFreetype::WrapFreetype
-)
-
-#### Keys ignored in scope 3:.:.:minimal.pro:NOT TARGET___equals____ss_QT_DEFAULT_QPA_PLUGIN:
-# PLUGIN_EXTENDS = "-"
diff --git a/src/plugins/platforms/minimal/main.cpp b/src/plugins/platforms/minimal/main.cpp
deleted file mode 100644
index 03cb3ca588..0000000000
--- a/src/plugins/platforms/minimal/main.cpp
+++ /dev/null
@@ -1,30 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-
-#include <qpa/qplatformintegrationplugin.h>
-#include "qminimalintegration.h"
-
-QT_BEGIN_NAMESPACE
-
-using namespace Qt::StringLiterals;
-
-class QMinimalIntegrationPlugin : public QPlatformIntegrationPlugin
-{
-    Q_OBJECT
-    Q_PLUGIN_METADATA(IID QPlatformIntegrationFactoryInterface_iid FILE "minimal.json")
-public:
-    QPlatformIntegration *create(const QString&, const QStringList&) override;
-};
-
-QPlatformIntegration *QMinimalIntegrationPlugin::create(const QString& system, const QStringList& paramList)
-{
-    if (!system.compare("minimal"_L1, Qt::CaseInsensitive))
-        return new QMinimalIntegration(paramList);
-
-    return nullptr;
-}
-
-QT_END_NAMESPACE
-
-#include "main.moc"
diff --git a/src/plugins/platforms/minimal/minimal.json b/src/plugins/platforms/minimal/minimal.json
deleted file mode 100644
index d3cf684b62..0000000000
--- a/src/plugins/platforms/minimal/minimal.json
+++ /dev/null
@@ -1,3 +0,0 @@
-{
-    "Keys": [ "minimal" ]
-}
diff --git a/src/plugins/platforms/minimal/qminimalbackingstore.cpp b/src/plugins/platforms/minimal/qminimalbackingstore.cpp
deleted file mode 100644
index cb432d7ddc..0000000000
--- a/src/plugins/platforms/minimal/qminimalbackingstore.cpp
+++ /dev/null
@@ -1,57 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-
-#include "qminimalbackingstore.h"
-#include "qminimalintegration.h"
-#include "qscreen.h"
-#include <QtCore/qdebug.h>
-#include <qpa/qplatformscreen.h>
-#include <private/qguiapplication_p.h>
-
-QT_BEGIN_NAMESPACE
-
-using namespace Qt::StringLiterals;
-
-QMinimalBackingStore::QMinimalBackingStore(QWindow *window)
-    : QPlatformBackingStore(window)
-    , mDebug(QMinimalIntegration::instance()->options() & QMinimalIntegration::DebugBackingStore)
-{
-    if (mDebug)
-        qDebug() << "QMinimalBackingStore::QMinimalBackingStore:" << (quintptr)this;
-}
-
-QMinimalBackingStore::~QMinimalBackingStore()
-{
-}
-
-QPaintDevice *QMinimalBackingStore::paintDevice()
-{
-    if (mDebug)
-        qDebug("QMinimalBackingStore::paintDevice");
-
-    return &mImage;
-}
-
-void QMinimalBackingStore::flush(QWindow *window, const QRegion &region, const QPoint &offset)
-{
-    Q_UNUSED(window);
-    Q_UNUSED(region);
-    Q_UNUSED(offset);
-
-    if (mDebug) {
-        static int c = 0;
-        QString filename = QString("output%1.png").arg(c++, 4, 10, QChar(u'0'));
-        qDebug() << "QMinimalBackingStore::flush() saving contents to" << filename.toLocal8Bit().constData();
-        mImage.save(filename);
-    }
-}
-
-void QMinimalBackingStore::resize(const QSize &size, const QRegion &)
-{
-    QImage::Format format = QGuiApplication::primaryScreen()->handle()->format();
-    if (mImage.size() != size)
-        mImage = QImage(size, format);
-}
-
-QT_END_NAMESPACE
diff --git a/src/plugins/platforms/minimal/qminimalbackingstore.h b/src/plugins/platforms/minimal/qminimalbackingstore.h
deleted file mode 100644
index 4bd58fd23d..0000000000
--- a/src/plugins/platforms/minimal/qminimalbackingstore.h
+++ /dev/null
@@ -1,30 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QBACKINGSTORE_MINIMAL_H
-#define QBACKINGSTORE_MINIMAL_H
-
-#include <qpa/qplatformbackingstore.h>
-#include <qpa/qplatformwindow.h>
-#include <QtGui/QImage>
-
-QT_BEGIN_NAMESPACE
-
-class QMinimalBackingStore : public QPlatformBackingStore
-{
-public:
-    QMinimalBackingStore(QWindow *window);
-    ~QMinimalBackingStore();
-
-    QPaintDevice *paintDevice() override;
-    void flush(QWindow *window, const QRegion &region, const QPoint &offset) override;
-    void resize(const QSize &size, const QRegion &staticContents) override;
-
-private:
-    QImage mImage;
-    const bool mDebug;
-};
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/plugins/platforms/minimal/qminimalintegration.cpp b/src/plugins/platforms/minimal/qminimalintegration.cpp
deleted file mode 100644
index 4679967431..0000000000
--- a/src/plugins/platforms/minimal/qminimalintegration.cpp
+++ /dev/null
@@ -1,173 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include "qminimalintegration.h"
-#include "qminimalbackingstore.h"
-
-#include <QtGui/private/qpixmap_raster_p.h>
-#include <QtGui/private/qguiapplication_p.h>
-#include <qpa/qplatformfontdatabase.h>
-#include <qpa/qplatformnativeinterface.h>
-#include <qpa/qplatformwindow.h>
-#include <qpa/qwindowsysteminterface.h>
-
-#if defined(Q_OS_WIN)
-#  include <QtGui/private/qwindowsfontdatabase_p.h>
-#  if QT_CONFIG(freetype)
-#    include <QtGui/private/qwindowsfontdatabase_ft_p.h>
-#  endif
-#elif defined(Q_OS_DARWIN)
-#  include <QtGui/private/qcoretextfontdatabase_p.h>
-#endif
-
-#if QT_CONFIG(fontconfig)
-#  include <QtGui/private/qgenericunixfontdatabase_p.h>
-#endif
-
-#if QT_CONFIG(freetype)
-#include <QtGui/private/qfontengine_ft_p.h>
-#include <QtGui/private/qfreetypefontdatabase_p.h>
-#endif
-
-#if !defined(Q_OS_WIN)
-#include <QtGui/private/qgenericunixeventdispatcher_p.h>
-#else
-#include <QtCore/private/qeventdispatcher_win_p.h>
-#endif
-
-QT_BEGIN_NAMESPACE
-
-using namespace Qt::StringLiterals;
-
-class QCoreTextFontEngine;
-
-static const char debugBackingStoreEnvironmentVariable[] = "QT_DEBUG_BACKINGSTORE";
-
-static inline unsigned parseOptions(const QStringList &paramList)
-{
-    unsigned options = 0;
-    for (const QString &param : paramList) {
-        if (param == "enable_fonts"_L1)
-            options |= QMinimalIntegration::EnableFonts;
-        else if (param == "freetype"_L1)
-            options |= QMinimalIntegration::FreeTypeFontDatabase;
-        else if (param == "fontconfig"_L1)
-            options |= QMinimalIntegration::FontconfigDatabase;
-    }
-    return options;
-}
-
-QMinimalIntegration::QMinimalIntegration(const QStringList &parameters)
-    : m_fontDatabase(nullptr)
-    , m_options(parseOptions(parameters))
-{
-    if (qEnvironmentVariableIsSet(debugBackingStoreEnvironmentVariable)
-        && qEnvironmentVariableIntValue(debugBackingStoreEnvironmentVariable) > 0) {
-        m_options |= DebugBackingStore | EnableFonts;
-    }
-
-    m_primaryScreen = new QMinimalScreen();
-
-    m_primaryScreen->mGeometry = QRect(0, 0, 240, 320);
-    m_primaryScreen->mDepth = 32;
-    m_primaryScreen->mFormat = QImage::Format_ARGB32_Premultiplied;
-
-    QWindowSystemInterface::handleScreenAdded(m_primaryScreen);
-}
-
-QMinimalIntegration::~QMinimalIntegration()
-{
-    QWindowSystemInterface::handleScreenRemoved(m_primaryScreen);
-    delete m_fontDatabase;
-}
-
-bool QMinimalIntegration::hasCapability(QPlatformIntegration::Capability cap) const
-{
-    switch (cap) {
-    case ThreadedPixmaps: return true;
-    case MultipleWindows: return true;
-    case RhiBasedRendering: return false;
-    default: return QPlatformIntegration::hasCapability(cap);
-    }
-}
-
-// Dummy font database that does not scan the fonts directory to be
-// used for command line tools like qmlplugindump that do not create windows
-// unless DebugBackingStore is activated.
-class DummyFontDatabase : public QPlatformFontDatabase
-{
-public:
-    virtual void populateFontDatabase() override {}
-};
-
-QPlatformFontDatabase *QMinimalIntegration::fontDatabase() const
-{
-    if (!m_fontDatabase && (m_options & EnableFonts)) {
-#if defined(Q_OS_WIN)
-        if (m_options & FreeTypeFontDatabase) {
-#  if QT_CONFIG(freetype)
-            m_fontDatabase = new QWindowsFontDatabaseFT;
-#  endif // freetype
-        } else {
-            m_fontDatabase = new QWindowsFontDatabase;
-        }
-#elif defined(Q_OS_DARWIN)
-        if (!(m_options & FontconfigDatabase)) {
-            if (m_options & FreeTypeFontDatabase) {
-#  if QT_CONFIG(freetype)
-                m_fontDatabase = new QCoreTextFontDatabaseEngineFactory<QFontEngineFT>;
-#  endif // freetype
-            } else {
-                m_fontDatabase = new QCoreTextFontDatabaseEngineFactory<QCoreTextFontEngine>;
-            }
-        }
-#endif
-
-        if (!m_fontDatabase) {
-#if QT_CONFIG(fontconfig)
-            m_fontDatabase = new QGenericUnixFontDatabase;
-#else
-            m_fontDatabase = QPlatformIntegration::fontDatabase();
-#endif
-        }
-    }
-    if (!m_fontDatabase)
-        m_fontDatabase = new DummyFontDatabase;
-    return m_fontDatabase;
-}
-
-QPlatformWindow *QMinimalIntegration::createPlatformWindow(QWindow *window) const
-{
-    Q_UNUSED(window);
-    QPlatformWindow *w = new QPlatformWindow(window);
-    w->requestActivateWindow();
-    return w;
-}
-
-QPlatformBackingStore *QMinimalIntegration::createPlatformBackingStore(QWindow *window) const
-{
-    return new QMinimalBackingStore(window);
-}
-
-QAbstractEventDispatcher *QMinimalIntegration::createEventDispatcher() const
-{
-#ifdef Q_OS_WIN
-    return new QEventDispatcherWin32;
-#else
-    return createUnixEventDispatcher();
-#endif
-}
-
-QPlatformNativeInterface *QMinimalIntegration::nativeInterface() const
-{
-    if (!m_nativeInterface)
-        m_nativeInterface.reset(new QPlatformNativeInterface);
-    return m_nativeInterface.get();
-}
-
-QMinimalIntegration *QMinimalIntegration::instance()
-{
-    return static_cast<QMinimalIntegration *>(QGuiApplicationPrivate::platformIntegration());
-}
-
-QT_END_NAMESPACE
diff --git a/src/plugins/platforms/minimal/qminimalintegration.h b/src/plugins/platforms/minimal/qminimalintegration.h
deleted file mode 100644
index 6070972b1b..0000000000
--- a/src/plugins/platforms/minimal/qminimalintegration.h
+++ /dev/null
@@ -1,66 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QPLATFORMINTEGRATION_MINIMAL_H
-#define QPLATFORMINTEGRATION_MINIMAL_H
-
-#include <qpa/qplatformintegration.h>
-#include <qpa/qplatformscreen.h>
-
-#include <qscopedpointer.h>
-
-QT_BEGIN_NAMESPACE
-
-class QMinimalScreen : public QPlatformScreen
-{
-public:
-    QMinimalScreen()
-        : mDepth(32), mFormat(QImage::Format_ARGB32_Premultiplied) {}
-
-    QRect geometry() const override { return mGeometry; }
-    int depth() const override { return mDepth; }
-    QImage::Format format() const override { return mFormat; }
-
-public:
-    QRect mGeometry;
-    int mDepth;
-    QImage::Format mFormat;
-    QSize mPhysicalSize;
-};
-
-class QMinimalIntegration : public QPlatformIntegration
-{
-public:
-    enum Options { // Options to be passed on command line or determined from environment
-        DebugBackingStore = 0x1,
-        EnableFonts = 0x2,
-        FreeTypeFontDatabase = 0x4,
-        FontconfigDatabase = 0x8
-    };
-
-    explicit QMinimalIntegration(const QStringList &parameters);
-    ~QMinimalIntegration();
-
-    bool hasCapability(QPlatformIntegration::Capability cap) const override;
-    QPlatformFontDatabase *fontDatabase() const override;
-
-    QPlatformWindow *createPlatformWindow(QWindow *window) const override;
-    QPlatformBackingStore *createPlatformBackingStore(QWindow *window) const override;
-    QAbstractEventDispatcher *createEventDispatcher() const override;
-
-    QPlatformNativeInterface *nativeInterface() const override;
-
-    unsigned options() const { return m_options; }
-
-    static QMinimalIntegration *instance();
-
-private:
-    mutable QPlatformFontDatabase *m_fontDatabase;
-    mutable QScopedPointer<QPlatformNativeInterface> m_nativeInterface;
-    QMinimalScreen *m_primaryScreen;
-    unsigned m_options;
-};
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/plugins/platforms/offscreen/CMakeLists.txt b/src/plugins/platforms/offscreen/CMakeLists.txt
deleted file mode 100644
index cb911638c0..0000000000
--- a/src/plugins/platforms/offscreen/CMakeLists.txt
+++ /dev/null
@@ -1,42 +0,0 @@
-# Copyright (C) 2022 The Qt Company Ltd.
-# SPDX-License-Identifier: BSD-3-Clause
-
-# Generated from offscreen.pro.
-
-#####################################################################
-## QOffscreenIntegrationPlugin Plugin:
-#####################################################################
-
-qt_internal_add_plugin(QOffscreenIntegrationPlugin
-    OUTPUT_NAME qoffscreen
-    PLUGIN_TYPE platforms
-    DEFAULT_IF ${QT_QPA_DEFAULT_PLATFORM} MATCHES offscreen # special case
-    SOURCES
-        main.cpp
-        qoffscreencommon.cpp qoffscreencommon.h
-        qoffscreenintegration.cpp qoffscreenintegration.h
-        qoffscreenwindow.cpp qoffscreenwindow.h
-    DEFINES
-        QT_NO_FOREACH
-    LIBRARIES
-        Qt::Core
-        Qt::CorePrivate
-        Qt::Gui
-        Qt::GuiPrivate
-)
-
-#### Keys ignored in scope 1:.:.:offscreen.pro:<TRUE>:
-# OTHER_FILES = "offscreen.json"
-
-## Scopes:
-#####################################################################
-
-qt_internal_extend_target(QOffscreenIntegrationPlugin CONDITION QT_FEATURE_opengl AND QT_FEATURE_xlib AND NOT QT_FEATURE_opengles2
-    SOURCES
-        qoffscreenintegration_x11.cpp qoffscreenintegration_x11.h
-    LIBRARIES
-        X11::X11
-)
-
-#### Keys ignored in scope 3:.:.:offscreen.pro:NOT TARGET___equals____ss_QT_DEFAULT_QPA_PLUGIN:
-# PLUGIN_EXTENDS = "-"
diff --git a/src/plugins/platforms/offscreen/main.cpp b/src/plugins/platforms/offscreen/main.cpp
deleted file mode 100644
index 4b5527cbde..0000000000
--- a/src/plugins/platforms/offscreen/main.cpp
+++ /dev/null
@@ -1,30 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-
-#include <qpa/qplatformintegrationplugin.h>
-#include "qoffscreenintegration.h"
-
-QT_BEGIN_NAMESPACE
-
-using namespace Qt::StringLiterals;
-
-class QOffscreenIntegrationPlugin : public QPlatformIntegrationPlugin
-{
-    Q_OBJECT
-    Q_PLUGIN_METADATA(IID QPlatformIntegrationFactoryInterface_iid FILE "offscreen.json")
-public:
-    QPlatformIntegration *create(const QString&, const QStringList&) override;
-};
-
-QPlatformIntegration *QOffscreenIntegrationPlugin::create(const QString& system, const QStringList& paramList)
-{
-    if (!system.compare("offscreen"_L1, Qt::CaseInsensitive))
-        return QOffscreenIntegration::createOffscreenIntegration(paramList);
-
-    return nullptr;
-}
-
-QT_END_NAMESPACE
-
-#include "main.moc"
diff --git a/src/plugins/platforms/offscreen/offscreen.json b/src/plugins/platforms/offscreen/offscreen.json
deleted file mode 100644
index 6e87744de0..0000000000
--- a/src/plugins/platforms/offscreen/offscreen.json
+++ /dev/null
@@ -1,3 +0,0 @@
-{
-    "Keys": [ "offscreen" ]
-}
diff --git a/src/plugins/platforms/offscreen/qoffscreencommon.cpp b/src/plugins/platforms/offscreen/qoffscreencommon.cpp
deleted file mode 100644
index 923fffb29c..0000000000
--- a/src/plugins/platforms/offscreen/qoffscreencommon.cpp
+++ /dev/null
@@ -1,241 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include "qoffscreencommon.h"
-#include "qoffscreenintegration.h"
-#include "qoffscreenwindow.h"
-
-
-#include <QtGui/QPainter>
-#include <QtGui/private/qpixmap_raster_p.h>
-#include <QtGui/private/qguiapplication_p.h>
-
-#include <qpa/qplatformcursor.h>
-#include <qpa/qplatformwindow.h>
-
-QT_BEGIN_NAMESPACE
-
-QPlatformWindow *QOffscreenScreen::windowContainingCursor = nullptr;
-
-
-QList<QPlatformScreen *> QOffscreenScreen::virtualSiblings() const
-{
-    QList<QPlatformScreen *> platformScreens;
-    for (auto screen : m_integration->screens()) {
-        platformScreens.append(screen);
-    }
-    return platformScreens;
-}
-
-class QOffscreenCursor : public QPlatformCursor
-{
-public:
-    QOffscreenCursor() : m_pos(10, 10) {}
-
-    QPoint pos() const override { return m_pos; }
-    void setPos(const QPoint &pos) override
-    {
-        m_pos = pos;
-        const QWindowList wl = QGuiApplication::topLevelWindows();
-        QWindow *containing = nullptr;
-        for (QWindow *w : wl) {
-            if (w->type() != Qt::Desktop && w->isExposed() && w->geometry().contains(pos)) {
-                containing = w;
-                break;
-            }
-        }
-
-        QPoint local = pos;
-        if (containing)
-            local -= containing->position();
-
-        QWindow *previous = QOffscreenScreen::windowContainingCursor ? QOffscreenScreen::windowContainingCursor->window() : nullptr;
-
-        if (containing != previous)
-            QWindowSystemInterface::handleEnterLeaveEvent(containing, previous, local, pos);
-
-        QWindowSystemInterface::handleMouseEvent(containing, local, pos, QGuiApplication::mouseButtons(), Qt::NoButton,
-                                                 QEvent::MouseMove, QGuiApplication::keyboardModifiers(), Qt::MouseEventSynthesizedByQt);
-
-        QOffscreenScreen::windowContainingCursor = containing ? containing->handle() : nullptr;
-    }
-#ifndef QT_NO_CURSOR
-    void changeCursor(QCursor *windowCursor, QWindow *window) override
-    {
-        Q_UNUSED(windowCursor);
-        Q_UNUSED(window);
-    }
-#endif
-private:
-    QPoint m_pos;
-};
-
-QOffscreenScreen::QOffscreenScreen(const QOffscreenIntegration *integration)
-    : m_geometry(0, 0, 800, 600)
-    , m_cursor(new QOffscreenCursor)
-    , m_integration(integration)
-{
-}
-
-QPixmap QOffscreenScreen::grabWindow(WId id, int x, int y, int width, int height) const
-{
-    QRect rect(x, y, width, height);
-
-    // id == 0 -> grab the screen, so all windows intersecting rect
-    if (!id) {
-        if (width == -1)
-            rect.setWidth(m_geometry.width());
-        if (height == -1)
-            rect.setHeight(m_geometry.height());
-        QPixmap screenImage(rect.size());
-        QPainter painter(&screenImage);
-        painter.translate(-x, -y);
-        const QWindowList wl = QGuiApplication::topLevelWindows();
-        for (QWindow *w : wl) {
-            if (w->isExposed() && w->geometry().intersects(rect)) {
-                QOffscreenBackingStore *store = QOffscreenBackingStore::backingStoreForWinId(w->winId());
-                const QImage windowImage = store ? store->toImage() : QImage();
-                if (!windowImage.isNull())
-                    painter.drawImage(w->position(), windowImage);
-            }
-        }
-        return screenImage;
-    }
-
-    QOffscreenBackingStore *store = QOffscreenBackingStore::backingStoreForWinId(id);
-    if (store)
-        return store->grabWindow(id, rect);
-    return QPixmap();
-}
-
-QOffscreenBackingStore::QOffscreenBackingStore(QWindow *window)
-    : QPlatformBackingStore(window)
-{
-}
-
-QOffscreenBackingStore::~QOffscreenBackingStore()
-{
-    clearHash();
-}
-
-QPaintDevice *QOffscreenBackingStore::paintDevice()
-{
-    return &m_image;
-}
-
-void QOffscreenBackingStore::flush(QWindow *window, const QRegion &region, const QPoint &offset)
-{
-    Q_UNUSED(region);
-
-    if (m_image.size().isEmpty())
-        return;
-
-    QSize imageSize = m_image.size();
-
-    QRegion clipped = QRect(0, 0, window->width(), window->height());
-    clipped &= QRect(0, 0, imageSize.width(), imageSize.height()).translated(-offset);
-
-    QRect bounds = clipped.boundingRect().translated(offset);
-
-    if (bounds.isNull())
-        return;
-
-    WId id = window->winId();
-
-    m_windowAreaHash[id] = bounds;
-    m_backingStoreForWinIdHash[id] = this;
-}
-
-void QOffscreenBackingStore::resize(const QSize &size, const QRegion &)
-{
-    QImage::Format format = QGuiApplication::primaryScreen()->handle()->format();
-    if (m_image.size() != size)
-        m_image = QImage(size, format);
-    clearHash();
-}
-
-extern void qt_scrollRectInImage(QImage &img, const QRect &rect, const QPoint &offset);
-
-bool QOffscreenBackingStore::scroll(const QRegion &area, int dx, int dy)
-{
-    if (m_image.isNull())
-        return false;
-
-    const QRect rect = area.boundingRect();
-    qt_scrollRectInImage(m_image, rect, QPoint(dx, dy));
-
-    return true;
-}
-
-QPixmap QOffscreenBackingStore::grabWindow(WId window, const QRect &rect) const
-{
-    QRect area = m_windowAreaHash.value(window, QRect());
-    if (area.isNull())
-        return QPixmap();
-
-    QRect adjusted = rect;
-    if (adjusted.width() <= 0)
-        adjusted.setWidth(area.width());
-    if (adjusted.height() <= 0)
-        adjusted.setHeight(area.height());
-
-    adjusted = adjusted.translated(area.topLeft()) & area;
-
-    if (adjusted.isEmpty())
-        return QPixmap();
-
-    return QPixmap::fromImage(m_image.copy(adjusted));
-}
-
-QOffscreenBackingStore *QOffscreenBackingStore::backingStoreForWinId(WId id)
-{
-    return m_backingStoreForWinIdHash.value(id, nullptr);
-}
-
-void QOffscreenBackingStore::clearHash()
-{
-    for (auto it = m_windowAreaHash.cbegin(), end = m_windowAreaHash.cend(); it != end; ++it) {
-        const auto it2 = std::as_const(m_backingStoreForWinIdHash).find(it.key());
-        if (it2.value() == this)
-            m_backingStoreForWinIdHash.erase(it2);
-    }
-    m_windowAreaHash.clear();
-}
-
-QHash<WId, QOffscreenBackingStore *> QOffscreenBackingStore::m_backingStoreForWinIdHash;
-
-QOffscreenPlatformNativeInterface::QOffscreenPlatformNativeInterface(QOffscreenIntegration *integration)
-    : m_integration(integration)
-{
-
-}
-
-QOffscreenPlatformNativeInterface::~QOffscreenPlatformNativeInterface() = default;
-
-/*
-    Set platform configuration, e.g. screen configuration
-*/
-void QOffscreenPlatformNativeInterface::setConfiguration(const QJsonObject &configuration, QOffscreenPlatformNativeInterface *iface)
-{
-    iface->m_integration->setConfiguration(configuration);
-}
-
-/*
-    Get the current platform configuration
-*/
-QJsonObject QOffscreenPlatformNativeInterface::configuration(QOffscreenPlatformNativeInterface *iface)
-{
-    return iface->m_integration->configuration();
-}
-
-void *QOffscreenPlatformNativeInterface::nativeResourceForIntegration(const QByteArray &resource)
-{
-    if (resource == "setConfiguration")
-        return reinterpret_cast<void*>(&QOffscreenPlatformNativeInterface::setConfiguration);
-    else if (resource == "configuration")
-        return reinterpret_cast<void*>(&QOffscreenPlatformNativeInterface::configuration);
-    else
-        return nullptr;
-}
-
-QT_END_NAMESPACE
diff --git a/src/plugins/platforms/offscreen/qoffscreencommon.h b/src/plugins/platforms/offscreen/qoffscreencommon.h
deleted file mode 100644
index a3d6227168..0000000000
--- a/src/plugins/platforms/offscreen/qoffscreencommon.h
+++ /dev/null
@@ -1,102 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QOFFSCREENCOMMON_H
-#define QOFFSCREENCOMMON_H
-
-#include <qpa/qplatformbackingstore.h>
-#if QT_CONFIG(draganddrop)
-#include <qpa/qplatformdrag.h>
-#endif
-#include <qpa/qplatformintegration.h>
-#include <qpa/qplatformnativeinterface.h>
-#include <qpa/qplatformscreen.h>
-#include <qpa/qplatformwindow.h>
-
-#include <qscopedpointer.h>
-#include <qimage.h>
-#include <qjsonobject.h>
-#include <qhash.h>
-
-QT_BEGIN_NAMESPACE
-
-class QOffscreenIntegration;
-class QOffscreenScreen : public QPlatformScreen
-{
-public:
-    QOffscreenScreen(const QOffscreenIntegration *integration);
-
-    QRect geometry() const override { return m_geometry; }
-    int depth() const override { return 32; }
-    QImage::Format format() const override { return QImage::Format_RGB32; }
-    QDpi logicalDpi() const override { return QDpi(m_logicalDpi, m_logicalDpi); }
-    QDpi logicalBaseDpi() const override { return QDpi(m_logicalBaseDpi, m_logicalBaseDpi); }
-    qreal devicePixelRatio() const override { return m_dpr; }
-    QString name() const override { return m_name; }
-    QPlatformCursor *cursor() const override { return m_cursor.data(); }
-    QList<QPlatformScreen *> virtualSiblings() const override;
-
-    QPixmap grabWindow(WId window, int x, int y, int width, int height) const override;
-
-    static QPlatformWindow *windowContainingCursor;
-
-public:
-    QString m_name;
-    QRect m_geometry;
-    int m_logicalDpi = 96;
-    int m_logicalBaseDpi= 96;
-    qreal m_dpr = 1;
-    QScopedPointer<QPlatformCursor> m_cursor;
-    const QOffscreenIntegration *m_integration;
-};
-
-#if QT_CONFIG(draganddrop)
-class QOffscreenDrag : public QPlatformDrag
-{
-public:
-    Qt::DropAction drag(QDrag *) override { return Qt::IgnoreAction; }
-};
-#endif
-
-class QOffscreenBackingStore : public QPlatformBackingStore
-{
-public:
-    QOffscreenBackingStore(QWindow *window);
-    ~QOffscreenBackingStore();
-
-    QPaintDevice *paintDevice() override;
-    void flush(QWindow *window, const QRegion &region, const QPoint &offset) override;
-    void resize(const QSize &size, const QRegion &staticContents) override;
-    bool scroll(const QRegion &area, int dx, int dy) override;
-
-    QPixmap grabWindow(WId window, const QRect &rect) const;
-    QImage toImage() const override { return m_image; }
-
-    static QOffscreenBackingStore *backingStoreForWinId(WId id);
-
-private:
-    void clearHash();
-
-    QImage m_image;
-    QHash<WId, QRect> m_windowAreaHash;
-
-    static QHash<WId, QOffscreenBackingStore *> m_backingStoreForWinIdHash;
-};
-
-class QOffscreenPlatformNativeInterface : public QPlatformNativeInterface
-{
-public:
-    QOffscreenPlatformNativeInterface(QOffscreenIntegration *integration);
-    ~QOffscreenPlatformNativeInterface();
-
-    static void setConfiguration(const QJsonObject &configuration, QOffscreenPlatformNativeInterface *iface);
-    static QJsonObject configuration(QOffscreenPlatformNativeInterface *iface);
-
-    void *nativeResourceForIntegration(const QByteArray &resource) override;
-private:
-    QOffscreenIntegration *m_integration;
-};
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/plugins/platforms/offscreen/qoffscreenintegration.cpp b/src/plugins/platforms/offscreen/qoffscreenintegration.cpp
deleted file mode 100644
index ea8042928a..0000000000
--- a/src/plugins/platforms/offscreen/qoffscreenintegration.cpp
+++ /dev/null
@@ -1,443 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include "qoffscreenintegration.h"
-#include "qoffscreenwindow.h"
-#include "qoffscreencommon.h"
-
-#if defined(Q_OS_UNIX)
-#include <QtGui/private/qgenericunixeventdispatcher_p.h>
-#if defined(Q_OS_MAC)
-#include <qpa/qplatformfontdatabase.h>
-#include <QtGui/private/qcoretextfontdatabase_p.h>
-#else
-#include <QtGui/private/qgenericunixfontdatabase_p.h>
-#endif
-#elif defined(Q_OS_WIN)
-#include <QtGui/private/qfreetypefontdatabase_p.h>
-#include <QtCore/private/qeventdispatcher_win_p.h>
-#endif
-
-#include <QtCore/qfile.h>
-#include <QtCore/qjsonarray.h>
-#include <QtCore/qjsondocument.h>
-#include <QtCore/qjsonobject.h>
-#include <QtCore/qjsonvalue.h>
-#include <QtGui/private/qpixmap_raster_p.h>
-#include <QtGui/private/qguiapplication_p.h>
-#include <qpa/qplatforminputcontextfactory_p.h>
-#include <qpa/qplatforminputcontext.h>
-#include <qpa/qplatformtheme.h>
-#include <qpa/qwindowsysteminterface.h>
-
-#include <qpa/qplatformservices.h>
-
-#if QT_CONFIG(xlib) && QT_CONFIG(opengl) && !QT_CONFIG(opengles2)
-#include "qoffscreenintegration_x11.h"
-#endif
-
-QT_BEGIN_NAMESPACE
-
-using namespace Qt::StringLiterals;
-
-class QCoreTextFontEngine;
-
-template <typename BaseEventDispatcher>
-class QOffscreenEventDispatcher : public BaseEventDispatcher
-{
-public:
-    explicit QOffscreenEventDispatcher(QObject *parent = nullptr)
-        : BaseEventDispatcher(parent)
-    {
-    }
-
-    bool processEvents(QEventLoop::ProcessEventsFlags flags) override
-    {
-        bool didSendEvents = BaseEventDispatcher::processEvents(flags);
-
-        return QWindowSystemInterface::sendWindowSystemEvents(flags) || didSendEvents;
-    }
-};
-
-QOffscreenIntegration::QOffscreenIntegration(const QStringList& paramList)
-{
-#if defined(Q_OS_UNIX)
-#if defined(Q_OS_MAC)
-    m_fontDatabase.reset(new QCoreTextFontDatabaseEngineFactory<QCoreTextFontEngine>);
-#else
-    m_fontDatabase.reset(new QGenericUnixFontDatabase());
-#endif
-#elif defined(Q_OS_WIN)
-    m_fontDatabase.reset(new QFreeTypeFontDatabase());
-#endif
-
-#if QT_CONFIG(draganddrop)
-    m_drag.reset(new QOffscreenDrag);
-#endif
-    m_services.reset(new QPlatformServices);
-
-    QJsonObject config = resolveConfigFileConfiguration(paramList).value_or(defaultConfiguration());
-    setConfiguration(config);
-}
-
-QOffscreenIntegration::~QOffscreenIntegration()
-{
-    while (!m_screens.isEmpty())
-        QWindowSystemInterface::handleScreenRemoved(m_screens.takeLast());
-}
-
-/*
-    The offscren platform plugin is configurable with a JSON configuration.
-    The confiuration can be provided either from a file on disk on startup,
-    or at by calling setConfiguration().
-
-    To provide a configuration on startuip, write the config to disk and pass
-    the file path as a platform argument:
-
-        ./myapp -platform offscreen:configfile=/path/to/config.json
-
-    The supported top-level config keys are:
-    {
-        "synchronousWindowSystemEvents": <bool>
-        "windowFrameMargins": <bool>,
-        "screens": [<screens>],
-    }
-
-    "screens" is an array of:
-    {
-        "name": string,
-        "x": int,
-        "y": int,
-        "width": int,
-        "height": int,
-        "logicalDpi": int,
-        "logicalBaseDpi": int,
-        "dpr": double,
-    }
-*/
-
-QJsonObject QOffscreenIntegration::defaultConfiguration() const
-{
-    const auto defaultScreen = QJsonObject {
-        {"name", ""},
-        {"x", 0},
-        {"y", 0},
-        {"width", 800},
-        {"height", 800},
-        {"logicalDpi", 96},
-        {"logicalBaseDpi", 96},
-        {"dpr", 1.0},
-    };
-    const auto defaultConfiguration = QJsonObject {
-        {"synchronousWindowSystemEvents", false},
-        {"windowFrameMargins", true},
-        {"screens", QJsonArray { defaultScreen } },
-    };
-    return defaultConfiguration;
-}
-
-std::optional<QJsonObject> QOffscreenIntegration::resolveConfigFileConfiguration(const QStringList& paramList) const
-{
-    bool hasConfigFile = false;
-    QString configFilePath;
-    for (const QString &param : paramList) {
-        // Look for "configfile=/path/to/file/"
-        QString configPrefix("configfile="_L1);
-        if (param.startsWith(configPrefix)) {
-            hasConfigFile = true;
-            configFilePath = param.mid(configPrefix.size());
-        }
-    }
-    if (!hasConfigFile)
-        return std::nullopt;
-
-    // Read config file
-    if (configFilePath.isEmpty())
-        qFatal("Missing file path for -configfile platform option");
-    QFile configFile(configFilePath);
-    if (!configFile.exists())
-        qFatal("Could not find platform config file %s", qPrintable(configFilePath));
-    if (!configFile.open(QIODevice::ReadOnly))
-        qFatal("Could not open platform config file for reading %s, %s", qPrintable(configFilePath), qPrintable(configFile.errorString()));
-
-    QByteArray json = configFile.readAll();
-    QJsonParseError error;
-    QJsonDocument config = QJsonDocument::fromJson(json, &error);
-    if (config.isNull())
-        qFatal("Platform config file parse error: %s", qPrintable(error.errorString()));
-
-    return config.object();
-}
-
-
-void QOffscreenIntegration::setConfiguration(const QJsonObject &configuration)
-{
-    // Apply the new configuration, diffing against the current m_configuration
-
-    const bool synchronousWindowSystemEvents = configuration["synchronousWindowSystemEvents"].toBool(
-        m_configuration["synchronousWindowSystemEvents"].toBool(false));
-    QWindowSystemInterface::setSynchronousWindowSystemEvents(synchronousWindowSystemEvents);
-
-    m_windowFrameMarginsEnabled = configuration["windowFrameMargins"].toBool(
-                m_configuration["windowFrameMargins"].toBool(true));
-
-    // Diff screens array, using the screen name as the screen identity.
-    QJsonArray currentScreens = m_configuration["screens"].toArray();
-    QJsonArray newScreens = configuration["screens"].toArray();
-
-    auto getScreenNames = [](const QJsonArray &screens) -> QList<QString> {
-        QList<QString> names;
-        for (QJsonValue screen : screens) {
-            names.append(screen["name"].toString());
-        };
-        std::sort(names.begin(), names.end());
-        return names;
-    };
-
-    auto currentNames = getScreenNames(currentScreens);
-    auto newNames = getScreenNames(newScreens);
-
-    QList<QString> present;
-    std::set_intersection(currentNames.begin(), currentNames.end(), newNames.begin(), newNames.end(),
-                          std::inserter(present, present.begin()));
-    QList<QString> added;
-    std::set_difference(newNames.begin(), newNames.end(), currentNames.begin(), currentNames.end(),
-                          std::inserter(added, added.begin()));
-    QList<QString> removed;
-    std::set_difference(currentNames.begin(), currentNames.end(), newNames.begin(), newNames.end(),
-                              std::inserter(removed, removed.begin()));
-
-    auto platformScreenByName = [](const QString &name, QList<QOffscreenScreen *> screens) -> QOffscreenScreen * {
-        for (QOffscreenScreen *screen : screens) {
-            if (screen->m_name == name)
-                return screen;
-        }
-        Q_UNREACHABLE();
-    };
-
-    auto screenConfigByName = [](const QString &name, QJsonArray screenConfigs) -> QJsonValue {
-        for (QJsonValue screenConfig : screenConfigs) {
-            if (screenConfig["name"].toString() == name)
-                return screenConfig;
-        }
-        Q_UNREACHABLE();
-    };
-
-    auto geometryFromConfig = [](const QJsonObject &config) -> QRect {
-        return QRect(config["x"].toInt(0), config["y"].toInt(0), config["width"].toInt(640), config["height"].toInt(480));
-    };
-
-    // Remove removed screens
-    for (const QString &remove : removed) {
-        QOffscreenScreen *screen = platformScreenByName(remove, m_screens);
-        m_screens.removeAll(screen);
-        QWindowSystemInterface::handleScreenRemoved(screen);
-    }
-
-    // Add new screens
-    for (const QString &add : added) {
-        QJsonValue configValue = screenConfigByName(add, newScreens);
-        QJsonObject config  = configValue.toObject();
-        if (config.isEmpty()) {
-            qWarning("empty screen object");
-            continue;
-        }
-        QOffscreenScreen *offscreenScreen = new QOffscreenScreen(this);
-        offscreenScreen->m_name = config["name"].toString();
-        offscreenScreen->m_geometry = geometryFromConfig(config);
-        offscreenScreen->m_logicalDpi = config["logicalDpi"].toInt(96);
-        offscreenScreen->m_logicalBaseDpi = config["logicalBaseDpi"].toInt(96);
-        offscreenScreen->m_dpr = config["dpr"].toDouble(1.0);
-        m_screens.append(offscreenScreen);
-        QWindowSystemInterface::handleScreenAdded(offscreenScreen);
-    }
-
-    // Update present screens
-    for (const QString &pres : present) {
-        QOffscreenScreen *screen = platformScreenByName(pres, m_screens);
-        Q_ASSERT(screen);
-        QJsonObject currentConfig = screenConfigByName(pres, currentScreens).toObject();
-        QJsonObject newConfig = screenConfigByName(pres, newScreens).toObject();
-
-        // Name can't change, because it'd be a different screen
-        Q_ASSERT(currentConfig["name"] == newConfig["name"]);
-
-        // Geometry
-        QRect currentGeomtry = geometryFromConfig(currentConfig);
-        QRect newGeomtry = geometryFromConfig(newConfig);
-        if (currentGeomtry != newGeomtry) {
-            screen->m_geometry = newGeomtry;
-            QWindowSystemInterface::handleScreenGeometryChange(screen->screen(), newGeomtry, newGeomtry);
-        }
-
-        // logical DPI
-        int currentLogicalDpi = currentConfig["logicalDpi"].toInt(96);
-        int newLogicalDpi = newConfig["logicalDpi"].toInt(96);
-        if (currentLogicalDpi != newLogicalDpi) {
-            screen->m_logicalDpi = newLogicalDpi;
-            QWindowSystemInterface::handleScreenLogicalDotsPerInchChange(screen->screen(), newLogicalDpi, newLogicalDpi);
-        }
-
-        // The base DPI is more of a platform constant, and should not change, and
-        // there is no handleChange function for it. Print a warning.
-        int currentLogicalBaseDpi = currentConfig["logicalBaseDpi"].toInt(96);
-        int newLogicalBaseDpi = newConfig["logicalBaseDpi"].toInt(96);
-        if (currentLogicalBaseDpi != newLogicalBaseDpi) {
-            screen->m_logicalBaseDpi = newLogicalBaseDpi;
-            qWarning("You ain't supposed to change logicalBaseDpi - its a platform constant. Qt may not react to the change");
-        }
-
-        // DPR. There is also no handleChange function in Qt at this point, instead
-        // the new DPR value will be used during the next repaint. We could repaint
-        // all windows here, but don't. Print a warning.
-        double currentDpr = currentConfig["dpr"].toDouble(1);
-        double newDpr = newConfig["dpr"].toDouble(1);
-        if (currentDpr != newDpr) {
-            screen->m_dpr = newDpr;
-            qWarning("DPR change notifications is not implemented - Qt may not react to the change");
-        }
-    }
-
-    // Now the new configuration is the current configuration
-    m_configuration = configuration;
-}
-
-QJsonObject QOffscreenIntegration::configuration() const
-{
-    return m_configuration;
-}
-
-void QOffscreenIntegration::initialize()
-{
-    m_inputContext.reset(QPlatformInputContextFactory::create());
-}
-
-QPlatformInputContext *QOffscreenIntegration::inputContext() const
-{
-    return m_inputContext.data();
-}
-
-bool QOffscreenIntegration::hasCapability(QPlatformIntegration::Capability cap) const
-{
-    switch (cap) {
-    case ThreadedPixmaps: return true;
-    case MultipleWindows: return true;
-    case RhiBasedRendering: return false;
-    default: return QPlatformIntegration::hasCapability(cap);
-    }
-}
-
-QPlatformWindow *QOffscreenIntegration::createPlatformWindow(QWindow *window) const
-{
-    Q_UNUSED(window);
-    QPlatformWindow *w = new QOffscreenWindow(window, m_windowFrameMarginsEnabled);
-    w->requestActivateWindow();
-    return w;
-}
-
-QPlatformBackingStore *QOffscreenIntegration::createPlatformBackingStore(QWindow *window) const
-{
-    return new QOffscreenBackingStore(window);
-}
-
-QAbstractEventDispatcher *QOffscreenIntegration::createEventDispatcher() const
-{
-#if defined(Q_OS_UNIX)
-    return createUnixEventDispatcher();
-#elif defined(Q_OS_WIN)
-    return new QOffscreenEventDispatcher<QEventDispatcherWin32>();
-#else
-    return 0;
-#endif
-}
-
-QPlatformNativeInterface *QOffscreenIntegration::nativeInterface() const
-{
-    if (!m_nativeInterface)
-        m_nativeInterface.reset(new QOffscreenPlatformNativeInterface(const_cast<QOffscreenIntegration*>(this)));
-    return m_nativeInterface.get();
-}
-
-static QString themeName() { return QStringLiteral("offscreen"); }
-
-QStringList QOffscreenIntegration::themeNames() const
-{
-    return QStringList(themeName());
-}
-
-// Restrict the styles to "fusion" to prevent native styles requiring native
-// window handles (eg Windows Vista style) from being used.
-class OffscreenTheme : public QPlatformTheme
-{
-public:
-    OffscreenTheme() {}
-
-    QVariant themeHint(ThemeHint h) const override
-    {
-        switch (h) {
-        case StyleNames:
-            return QVariant(QStringList(QStringLiteral("Fusion")));
-        default:
-            break;
-        }
-        return QPlatformTheme::themeHint(h);
-    }
-
-    virtual const QFont *font(Font type = SystemFont) const override
-    {
-        static QFont systemFont("Sans Serif"_L1, 9);
-        static QFont fixedFont("monospace"_L1, 9);
-        switch (type) {
-        case QPlatformTheme::SystemFont:
-            return &systemFont;
-        case QPlatformTheme::FixedFont:
-            return &fixedFont;
-        default:
-            return nullptr;
-        }
-    }
-};
-
-QPlatformTheme *QOffscreenIntegration::createPlatformTheme(const QString &name) const
-{
-    return name == themeName() ? new OffscreenTheme() : nullptr;
-}
-
-QPlatformFontDatabase *QOffscreenIntegration::fontDatabase() const
-{
-    return m_fontDatabase.data();
-}
-
-#if QT_CONFIG(draganddrop)
-QPlatformDrag *QOffscreenIntegration::drag() const
-{
-    return m_drag.data();
-}
-#endif
-
-QPlatformServices *QOffscreenIntegration::services() const
-{
-    return m_services.data();
-}
-
-QOffscreenIntegration *QOffscreenIntegration::createOffscreenIntegration(const QStringList& paramList)
-{
-    QOffscreenIntegration *offscreenIntegration = nullptr;
-
-#if QT_CONFIG(xlib) && QT_CONFIG(opengl) && !QT_CONFIG(opengles2)
-    QByteArray glx = qgetenv("QT_QPA_OFFSCREEN_NO_GLX");
-    if (glx.isEmpty())
-        offscreenIntegration = new QOffscreenX11Integration(paramList);
-#endif
-
-     if (!offscreenIntegration)
-        offscreenIntegration = new QOffscreenIntegration(paramList);
-    return offscreenIntegration;
-}
-
-QList<QOffscreenScreen *> QOffscreenIntegration::screens() const
-{
-    return m_screens;
-}
-
-QT_END_NAMESPACE
diff --git a/src/plugins/platforms/offscreen/qoffscreenintegration.h b/src/plugins/platforms/offscreen/qoffscreenintegration.h
deleted file mode 100644
index aab8d305b4..0000000000
--- a/src/plugins/platforms/offscreen/qoffscreenintegration.h
+++ /dev/null
@@ -1,67 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QOFFSCREENINTEGRATION_H
-#define QOFFSCREENINTEGRATION_H
-
-#include <qpa/qplatformintegration.h>
-#include <qpa/qplatformnativeinterface.h>
-
-#include <qscopedpointer.h>
-#include <qjsonobject.h>
-
-QT_BEGIN_NAMESPACE
-
-class QOffscreenBackendData;
-class QOffscreenScreen;
-
-class QOffscreenIntegration : public QPlatformIntegration
-{
-public:
-    QOffscreenIntegration(const QStringList& paramList);
-    ~QOffscreenIntegration();
-
-    QJsonObject defaultConfiguration() const;
-    std::optional<QJsonObject> resolveConfigFileConfiguration(const QStringList& paramList) const;
-    void setConfiguration(const QJsonObject &configuration);
-    QJsonObject configuration() const;
-
-    void initialize() override;
-    bool hasCapability(QPlatformIntegration::Capability cap) const override;
-
-    QPlatformWindow *createPlatformWindow(QWindow *window) const override;
-    QPlatformBackingStore *createPlatformBackingStore(QWindow *window) const override;
-#if QT_CONFIG(draganddrop)
-    QPlatformDrag *drag() const override;
-#endif
-
-    QPlatformInputContext *inputContext() const override;
-    QPlatformServices *services() const override;
-
-    QPlatformFontDatabase *fontDatabase() const override;
-    QAbstractEventDispatcher *createEventDispatcher() const override;
-
-    QPlatformNativeInterface *nativeInterface() const override;
-
-    QStringList themeNames() const override;
-    QPlatformTheme *createPlatformTheme(const QString &name) const override;
-
-    static QOffscreenIntegration *createOffscreenIntegration(const QStringList& paramList);
-
-    QList<QOffscreenScreen *> screens() const;
-protected:
-    QScopedPointer<QPlatformFontDatabase> m_fontDatabase;
-#if QT_CONFIG(draganddrop)
-    QScopedPointer<QPlatformDrag> m_drag;
-#endif
-    QScopedPointer<QPlatformInputContext> m_inputContext;
-    QScopedPointer<QPlatformServices> m_services;
-    mutable QScopedPointer<QPlatformNativeInterface> m_nativeInterface;
-    QList<QOffscreenScreen *> m_screens;
-    bool m_windowFrameMarginsEnabled = true;
-    QJsonObject m_configuration;
-};
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/plugins/platforms/offscreen/qoffscreenintegration_x11.cpp b/src/plugins/platforms/offscreen/qoffscreenintegration_x11.cpp
deleted file mode 100644
index fbee6667ea..0000000000
--- a/src/plugins/platforms/offscreen/qoffscreenintegration_x11.cpp
+++ /dev/null
@@ -1,301 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include "qoffscreenintegration_x11.h"
-
-#include <QByteArray>
-#include <QOpenGLContext>
-
-#include <X11/Xlib.h>
-#include <GL/glx.h>
-
-#include <QtGui/private/qglxconvenience_p.h>
-
-#include <qpa/qplatformsurface.h>
-#include <qsurface.h>
-
-QT_BEGIN_NAMESPACE
-
-class QOffscreenX11Info
-{
-public:
-    QOffscreenX11Info(QOffscreenX11Connection *connection)
-        : m_connection(connection)
-    {
-    }
-
-    Display *display() const {
-        return (Display *)m_connection->display();
-    }
-
-    Window root() const {
-        return DefaultRootWindow(display());
-    }
-
-    int screenNumber() const {
-        return m_connection->screenNumber();
-    }
-
-private:
-    QOffscreenX11Connection *m_connection;
-};
-
-QOffscreenX11Integration::QOffscreenX11Integration(const QStringList& paramList)
-: QOffscreenIntegration(paramList)
-{
-
-}
-
-QOffscreenX11Integration::~QOffscreenX11Integration() = default;
-
-bool QOffscreenX11Integration::hasCapability(QPlatformIntegration::Capability cap) const
-{
-    switch (cap) {
-    case OpenGL: return true;
-    case ThreadedOpenGL: return true;
-    case RasterGLSurface: return true;
-    default: return QOffscreenIntegration::hasCapability(cap);
-    }
-}
-
-#if !defined(QT_NO_OPENGL) && QT_CONFIG(xcb_glx_plugin)
-QPlatformOpenGLContext *QOffscreenX11Integration::createPlatformOpenGLContext(QOpenGLContext *context) const
-{
-    auto &connection = nativeInterface()->m_connection;
-
-    if (!connection)
-        connection.reset(new QOffscreenX11Connection);
-
-    if (!connection->display())
-        return nullptr;
-
-    return new QOffscreenX11GLXContext(connection->x11Info(), context);
-}
-#endif // !defined(QT_NO_OPENGL) && QT_CONFIG(xcb_glx_plugin)
-
-QOffscreenX11PlatformNativeInterface *QOffscreenX11Integration::nativeInterface() const
-{
-   if (!m_nativeInterface)
-       m_nativeInterface.reset(new QOffscreenX11PlatformNativeInterface(const_cast<QOffscreenX11Integration *>(this)));
-   return static_cast<QOffscreenX11PlatformNativeInterface *>(m_nativeInterface.data());
-}
-
-QOffscreenX11PlatformNativeInterface::QOffscreenX11PlatformNativeInterface(QOffscreenIntegration *integration)
-:QOffscreenPlatformNativeInterface(integration)
-{
-
-}
-
-QOffscreenX11PlatformNativeInterface::~QOffscreenX11PlatformNativeInterface() = default;
-
-void *QOffscreenX11PlatformNativeInterface::nativeResourceForScreen(const QByteArray &resource, QScreen *screen)
-{
-    Q_UNUSED(screen);
-    if (resource.toLower() == QByteArrayLiteral("display") ) {
-        if (!m_connection)
-            m_connection.reset(new QOffscreenX11Connection);
-        return m_connection->display();
-    }
-    return nullptr;
-}
-
-#if !defined(QT_NO_OPENGL) && QT_CONFIG(xcb_glx_plugin)
-void *QOffscreenX11PlatformNativeInterface::nativeResourceForContext(const QByteArray &resource, QOpenGLContext *context) {
-    if (resource.toLower() == QByteArrayLiteral("glxconfig") ) {
-        if (context) {
-            QOffscreenX11GLXContext *glxPlatformContext = static_cast<QOffscreenX11GLXContext *>(context->handle());
-            if (glxPlatformContext)
-                return glxPlatformContext->glxConfig();
-        }
-    }
-    if (resource.toLower() == QByteArrayLiteral("glxcontext") ) {
-        if (context) {
-            QOffscreenX11GLXContext *glxPlatformContext = static_cast<QOffscreenX11GLXContext *>(context->handle());
-            if (glxPlatformContext)
-                return glxPlatformContext->glxContext();
-        }
-    }
-    return nullptr;
-}
-#endif
-
-#if QT_CONFIG(xcb)
-Display *QOffscreenX11PlatformNativeInterface::display() const
-{
-    return m_connection ? reinterpret_cast<Display *>(m_connection->display()) : nullptr;
-}
-#endif
-
-QOffscreenX11Connection::QOffscreenX11Connection()
-{
-    XInitThreads();
-
-    QByteArray displayName = qgetenv("DISPLAY");
-    Display *display = XOpenDisplay(displayName.constData());
-    m_display = display;
-    m_screenNumber = m_display ? DefaultScreen(m_display) : -1;
-}
-
-QOffscreenX11Connection::~QOffscreenX11Connection()
-{
-    if (m_display)
-        XCloseDisplay((Display *)m_display);
-}
-
-QOffscreenX11Info *QOffscreenX11Connection::x11Info()
-{
-    if (!m_x11Info)
-        m_x11Info.reset(new QOffscreenX11Info(this));
-    return m_x11Info.data();
-}
-
-#if QT_CONFIG(xcb_glx_plugin)
-class QOffscreenX11GLXContextData
-{
-public:
-    QOffscreenX11Info *x11 = nullptr;
-    QSurfaceFormat format;
-    GLXContext context = nullptr;
-    GLXContext shareContext = nullptr;
-    GLXFBConfig config = nullptr;
-    Window window = 0;
-};
-
-static Window createDummyWindow(QOffscreenX11Info *x11, XVisualInfo *visualInfo)
-{
-    Colormap cmap = XCreateColormap(x11->display(), x11->root(), visualInfo->visual, AllocNone);
-    XSetWindowAttributes a;
-    a.background_pixel = WhitePixel(x11->display(), x11->screenNumber());
-    a.border_pixel = BlackPixel(x11->display(), x11->screenNumber());
-    a.colormap = cmap;
-
-
-    Window window = XCreateWindow(x11->display(), x11->root(),
-                                  0, 0, 100, 100,
-                                  0, visualInfo->depth, InputOutput, visualInfo->visual,
-                                  CWBackPixel|CWBorderPixel|CWColormap, &a);
-    XFreeColormap(x11->display(), cmap);
-    return window;
-}
-
-static Window createDummyWindow(QOffscreenX11Info *x11, GLXFBConfig config)
-{
-    XVisualInfo *visualInfo = glXGetVisualFromFBConfig(x11->display(), config);
-    if (Q_UNLIKELY(!visualInfo))
-        qFatal("Could not initialize GLX");
-    Window window = createDummyWindow(x11, visualInfo);
-    XFree(visualInfo);
-    return window;
-}
-
-QOffscreenX11GLXContext::QOffscreenX11GLXContext(QOffscreenX11Info *x11, QOpenGLContext *context)
-    : d(new QOffscreenX11GLXContextData)
-{
-
-    d->x11 = x11;
-    d->format = context->format();
-
-    if (d->format.renderableType() == QSurfaceFormat::DefaultRenderableType)
-        d->format.setRenderableType(QSurfaceFormat::OpenGL);
-
-    if (d->format.renderableType() != QSurfaceFormat::OpenGL)
-        return;
-
-    d->shareContext = nullptr;
-    if (context->shareHandle())
-        d->shareContext = static_cast<QOffscreenX11GLXContext *>(context->shareHandle())->d->context;
-
-    GLXFBConfig config = qglx_findConfig(x11->display(), x11->screenNumber(), d->format);
-    d->config = config;
-
-    if (config) {
-        d->context = glXCreateNewContext(x11->display(), config, GLX_RGBA_TYPE, d->shareContext, true);
-        if (!d->context && d->shareContext) {
-            d->shareContext = nullptr;
-            // re-try without a shared glx context
-            d->context = glXCreateNewContext(x11->display(), config, GLX_RGBA_TYPE, nullptr, true);
-        }
-
-        // Get the basic surface format details
-        if (d->context)
-            qglx_surfaceFormatFromGLXFBConfig(&d->format, x11->display(), config);
-
-        // Create a temporary window so that we can make the new context current
-        d->window = createDummyWindow(x11, config);
-    } else {
-        XVisualInfo *visualInfo = qglx_findVisualInfo(x11->display(), 0, &d->format);
-        if (Q_UNLIKELY(!visualInfo))
-            qFatal("Could not initialize GLX");
-        d->context = glXCreateContext(x11->display(), visualInfo, d->shareContext, true);
-        if (!d->context && d->shareContext) {
-            // re-try without a shared glx context
-            d->shareContext = nullptr;
-            d->context = glXCreateContext(x11->display(), visualInfo, nullptr, true);
-        }
-
-        d->window = createDummyWindow(x11, visualInfo);
-        XFree(visualInfo);
-    }
-}
-
-QOffscreenX11GLXContext::~QOffscreenX11GLXContext()
-{
-    glXDestroyContext(d->x11->display(), d->context);
-    XDestroyWindow(d->x11->display(), d->window);
-}
-
-bool QOffscreenX11GLXContext::makeCurrent(QPlatformSurface *surface)
-{
-    QSize size = surface->surface()->size();
-
-    XResizeWindow(d->x11->display(), d->window, size.width(), size.height());
-    XSync(d->x11->display(), true);
-
-    if (glXMakeCurrent(d->x11->display(), d->window, d->context)) {
-        glViewport(0, 0, size.width(), size.height());
-        return true;
-    }
-
-    return false;
-}
-
-void QOffscreenX11GLXContext::doneCurrent()
-{
-    glXMakeCurrent(d->x11->display(), 0, nullptr);
-}
-
-void QOffscreenX11GLXContext::swapBuffers(QPlatformSurface *)
-{
-}
-
-QFunctionPointer QOffscreenX11GLXContext::getProcAddress(const char *procName)
-{
-    return (QFunctionPointer)glXGetProcAddressARB(reinterpret_cast<const GLubyte *>(procName));
-}
-
-QSurfaceFormat QOffscreenX11GLXContext::format() const
-{
-    return d->format;
-}
-
-bool QOffscreenX11GLXContext::isSharing() const
-{
-    return d->shareContext;
-}
-
-bool QOffscreenX11GLXContext::isValid() const
-{
-    return d->context && d->window;
-}
-
-GLXContext QOffscreenX11GLXContext::glxContext() const
-{
-    return d->context;
-}
-
-void *QOffscreenX11GLXContext::glxConfig() const
-{
-    return d->config;
-}
-#endif // QT_CONFIG(xcb_glx_plugin)
-QT_END_NAMESPACE
diff --git a/src/plugins/platforms/offscreen/qoffscreenintegration_x11.h b/src/plugins/platforms/offscreen/qoffscreenintegration_x11.h
deleted file mode 100644
index d7b5120332..0000000000
--- a/src/plugins/platforms/offscreen/qoffscreenintegration_x11.h
+++ /dev/null
@@ -1,102 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QOFFSCREENINTEGRATION_X11_H
-#define QOFFSCREENINTEGRATION_X11_H
-
-#include "qoffscreenintegration.h"
-#include "qoffscreencommon.h"
-
-#include <qglobal.h>
-#include <qscopedpointer.h>
-
-#include <qpa/qplatformopenglcontext.h>
-#include <QtGui/qguiapplication.h>
-
-QT_BEGIN_NAMESPACE
-
-class QOffscreenX11Connection;
-class QOffscreenX11Info;
-
-class QOffscreenX11PlatformNativeInterface : public QOffscreenPlatformNativeInterface
-#if QT_CONFIG(xcb)
-                                           , public QNativeInterface::QX11Application
-#endif
-{
-public:
-    QOffscreenX11PlatformNativeInterface(QOffscreenIntegration *integration);
-    ~QOffscreenX11PlatformNativeInterface();
-
-    void *nativeResourceForScreen(const QByteArray &resource, QScreen *screen) override;
-#if !defined(QT_NO_OPENGL) && QT_CONFIG(xcb_glx_plugin)
-    void *nativeResourceForContext(const QByteArray &resource, QOpenGLContext *context) override;
-#endif
-#if QT_CONFIG(xcb)
-    Display *display() const override;
-    xcb_connection_t *connection() const override { return nullptr; };
-#endif
-    QScopedPointer<QOffscreenX11Connection> m_connection;
-};
-
-class QOffscreenX11Integration : public QOffscreenIntegration
-{
-public:
-    QOffscreenX11Integration(const QStringList& paramList);
-    ~QOffscreenX11Integration();
-    bool hasCapability(QPlatformIntegration::Capability cap) const override;
-
-#if !defined(QT_NO_OPENGL) && QT_CONFIG(xcb_glx_plugin)
-    QPlatformOpenGLContext *createPlatformOpenGLContext(QOpenGLContext *context) const override;
-#endif
-    QOffscreenX11PlatformNativeInterface *nativeInterface() const override;
-};
-
-class QOffscreenX11Connection {
-public:
-    QOffscreenX11Connection();
-    ~QOffscreenX11Connection();
-
-    QOffscreenX11Info *x11Info();
-
-    void *display() const { return m_display; }
-    int screenNumber() const { return m_screenNumber; }
-
-private:
-    void *m_display;
-    int m_screenNumber;
-
-    QScopedPointer<QOffscreenX11Info> m_x11Info;
-};
-
-#if QT_CONFIG(xcb_glx_plugin)
-class QOffscreenX11GLXContextData;
-
-class QOffscreenX11GLXContext : public QPlatformOpenGLContext
-                              , public QNativeInterface::QGLXContext
-{
-public:
-    QOffscreenX11GLXContext(QOffscreenX11Info *x11, QOpenGLContext *context);
-    ~QOffscreenX11GLXContext();
-
-    bool makeCurrent(QPlatformSurface *surface) override;
-    void doneCurrent() override;
-    void swapBuffers(QPlatformSurface *surface) override;
-    QFunctionPointer getProcAddress(const char *procName) override;
-
-    QSurfaceFormat format() const override;
-    bool isSharing() const override;
-    bool isValid() const override;
-
-    GLXContext nativeContext() const override { return glxContext(); }
-
-    void *glxConfig() const;
-    GLXContext glxContext() const;
-
-private:
-    QScopedPointer<QOffscreenX11GLXContextData> d;
-};
-#endif // QT_CONFIG(xcb_glx_plugin)
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/plugins/platforms/offscreen/qoffscreenwindow.cpp b/src/plugins/platforms/offscreen/qoffscreenwindow.cpp
deleted file mode 100644
index 20ed0ed91b..0000000000
--- a/src/plugins/platforms/offscreen/qoffscreenwindow.cpp
+++ /dev/null
@@ -1,173 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include "qoffscreenwindow.h"
-#include "qoffscreencommon.h"
-
-#include <qpa/qplatformscreen.h>
-#include <qpa/qwindowsysteminterface.h>
-
-#include <private/qwindow_p.h>
-#include <private/qguiapplication_p.h>
-
-QT_BEGIN_NAMESPACE
-
-QOffscreenWindow::QOffscreenWindow(QWindow *window, bool frameMarginsEnabled)
-    : QPlatformWindow(window)
-    , m_positionIncludesFrame(false)
-    , m_visible(false)
-    , m_pendingGeometryChangeOnShow(true)
-    , m_frameMarginsRequested(frameMarginsEnabled)
-{
-    if (window->windowState() == Qt::WindowNoState) {
-        setGeometry(windowGeometry());
-    } else {
-        setWindowState(window->windowStates());
-    }
-
-    static WId counter = 0;
-    m_winId = ++counter;
-
-    m_windowForWinIdHash[m_winId] = this;
-}
-
-QOffscreenWindow::~QOffscreenWindow()
-{
-    if (QOffscreenScreen::windowContainingCursor == this)
-        QOffscreenScreen::windowContainingCursor = nullptr;
-    m_windowForWinIdHash.remove(m_winId);
-}
-
-void QOffscreenWindow::setGeometry(const QRect &rect)
-{
-    if (window()->windowState() != Qt::WindowNoState)
-        return;
-
-    m_positionIncludesFrame = qt_window_private(window())->positionPolicy == QWindowPrivate::WindowFrameInclusive;
-
-    setFrameMarginsEnabled(m_frameMarginsRequested);
-    setGeometryImpl(rect);
-
-    m_normalGeometry = geometry();
-}
-
-void QOffscreenWindow::setGeometryImpl(const QRect &rect)
-{
-    QRect adjusted = rect;
-    if (adjusted.width() <= 0)
-        adjusted.setWidth(1);
-    if (adjusted.height() <= 0)
-        adjusted.setHeight(1);
-
-    if (m_positionIncludesFrame) {
-        adjusted.translate(m_margins.left(), m_margins.top());
-    } else {
-        // make sure we're not placed off-screen
-        if (adjusted.left() < m_margins.left())
-            adjusted.translate(m_margins.left(), 0);
-        if (adjusted.top() < m_margins.top())
-            adjusted.translate(0, m_margins.top());
-    }
-
-    QPlatformWindow::setGeometry(adjusted);
-
-    if (m_visible) {
-        QWindowSystemInterface::handleGeometryChange(window(), adjusted);
-        QWindowSystemInterface::handleExposeEvent(window(), QRect(QPoint(), adjusted.size()));
-    } else {
-        m_pendingGeometryChangeOnShow = true;
-    }
-}
-
-void QOffscreenWindow::setVisible(bool visible)
-{
-    if (visible == m_visible)
-        return;
-
-    if (visible) {
-        if (window()->type() != Qt::ToolTip)
-            QWindowSystemInterface::handleWindowActivated(window(), Qt::ActiveWindowFocusReason);
-
-        if (m_pendingGeometryChangeOnShow) {
-            m_pendingGeometryChangeOnShow = false;
-            QWindowSystemInterface::handleGeometryChange(window(), geometry());
-        }
-    }
-
-    const QPoint cursorPos = QCursor::pos();
-    if (visible) {
-        QRect rect(QPoint(), geometry().size());
-        QWindowSystemInterface::handleExposeEvent(window(), rect);
-        if (QWindowPrivate::get(window())->isPopup() && QGuiApplicationPrivate::currentMouseWindow) {
-            QWindowSystemInterface::handleLeaveEvent<QWindowSystemInterface::SynchronousDelivery>
-                (QGuiApplicationPrivate::currentMouseWindow);
-        }
-        if (geometry().contains(cursorPos))
-            QWindowSystemInterface::handleEnterEvent(window(),
-                                                     window()->mapFromGlobal(cursorPos), cursorPos);
-    } else {
-        QWindowSystemInterface::handleExposeEvent(window(), QRegion());
-        if (window()->type() & Qt::Window) {
-            if (QWindow *windowUnderMouse = QGuiApplication::topLevelAt(cursorPos)) {
-                QWindowSystemInterface::handleEnterEvent(windowUnderMouse,
-                                                        windowUnderMouse->mapFromGlobal(cursorPos),
-                                                        cursorPos);
-            }
-        }
-    }
-
-    m_visible = visible;
-}
-
-void QOffscreenWindow::requestActivateWindow()
-{
-    if (m_visible)
-        QWindowSystemInterface::handleWindowActivated(window(), Qt::ActiveWindowFocusReason);
-}
-
-WId QOffscreenWindow::winId() const
-{
-    return m_winId;
-}
-
-QMargins QOffscreenWindow::frameMargins() const
-{
-    return m_margins;
-}
-
-void QOffscreenWindow::setFrameMarginsEnabled(bool enabled)
-{
-    if (enabled
-        && !(window()->flags() & Qt::FramelessWindowHint)
-        && (parent() == nullptr)) {
-        m_margins = QMargins(2, 2, 2, 2);
-    } else {
-        m_margins = QMargins(0, 0, 0, 0);
-    }
-}
-
-void QOffscreenWindow::setWindowState(Qt::WindowStates state)
-{
-    setFrameMarginsEnabled(m_frameMarginsRequested && !(state & Qt::WindowFullScreen));
-    m_positionIncludesFrame = false;
-
-    if (state & Qt::WindowMinimized)
-        ; // nothing to do
-    else if (state & Qt::WindowFullScreen)
-        setGeometryImpl(screen()->geometry());
-    else if (state & Qt::WindowMaximized)
-        setGeometryImpl(screen()->availableGeometry().adjusted(m_margins.left(), m_margins.top(), -m_margins.right(), -m_margins.bottom()));
-    else
-        setGeometryImpl(m_normalGeometry);
-
-    QWindowSystemInterface::handleWindowStateChanged(window(), state);
-}
-
-QOffscreenWindow *QOffscreenWindow::windowForWinId(WId id)
-{
-    return m_windowForWinIdHash.value(id, nullptr);
-}
-
-Q_CONSTINIT QHash<WId, QOffscreenWindow *> QOffscreenWindow::m_windowForWinIdHash;
-
-QT_END_NAMESPACE
diff --git a/src/plugins/platforms/offscreen/qoffscreenwindow.h b/src/plugins/platforms/offscreen/qoffscreenwindow.h
deleted file mode 100644
index d525f2c657..0000000000
--- a/src/plugins/platforms/offscreen/qoffscreenwindow.h
+++ /dev/null
@@ -1,49 +0,0 @@
-// Copyright (C) 2016 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QOFFSCREENWINDOW_H
-#define QOFFSCREENWINDOW_H
-
-#include <qpa/qplatformbackingstore.h>
-#include <qpa/qplatformwindow.h>
-
-#include <qhash.h>
-
-QT_BEGIN_NAMESPACE
-
-class QOffscreenWindow : public QPlatformWindow
-{
-public:
-    QOffscreenWindow(QWindow *window, bool frameMarginsEnabled);
-    ~QOffscreenWindow();
-
-    void setGeometry(const QRect &rect) override;
-    void setWindowState(Qt::WindowStates states) override;
-
-    QMargins frameMargins() const override;
-
-    void setVisible(bool visible) override;
-    void requestActivateWindow() override;
-
-    WId winId() const override;
-
-    static QOffscreenWindow *windowForWinId(WId id);
-
-private:
-    void setFrameMarginsEnabled(bool enabled);
-    void setGeometryImpl(const QRect &rect);
-
-    QRect m_normalGeometry;
-    QMargins m_margins;
-    bool m_positionIncludesFrame;
-    bool m_visible;
-    bool m_pendingGeometryChangeOnShow;
-    bool m_frameMarginsRequested;
-    WId m_winId;
-
-    Q_CONSTINIT static QHash<WId, QOffscreenWindow *> m_windowForWinIdHash;
-};
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/plugins/platforms/windows/CMakeLists.txt b/src/plugins/platforms/windows/CMakeLists.txt
index 7884fc164e..00ec76fa8f 100644
--- a/src/plugins/platforms/windows/CMakeLists.txt
+++ b/src/plugins/platforms/windows/CMakeLists.txt
@@ -198,6 +198,8 @@ qt_internal_extend_target(QWindowsIntegrationPlugin CONDITION QT_FEATURE_accessi
         uiautomation/qwindowsuiautils.cpp uiautomation/qwindowsuiautils.h
         uiautomation/qwindowsuiavalueprovider.cpp uiautomation/qwindowsuiavalueprovider.h
         uiautomation/qwindowsuiawindowprovider.cpp uiautomation/qwindowsuiawindowprovider.h
+    LIBRARIES
+        uiautomationcore
 )
 
 qt_internal_extend_target(QWindowsIntegrationPlugin CONDITION MINGW AND QT_FEATURE_accessibility
diff --git a/src/plugins/platforms/windows/qwin10helpers.cpp b/src/plugins/platforms/windows/qwin10helpers.cpp
index 026e81cb0c..6131031987 100644
--- a/src/plugins/platforms/windows/qwin10helpers.cpp
+++ b/src/plugins/platforms/windows/qwin10helpers.cpp
@@ -4,6 +4,8 @@
 #include "qwin10helpers.h"
 
 #include <QtCore/qdebug.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 #include <winstring.h>
 #include <roapi.h>
 
@@ -60,23 +62,56 @@ public:
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
+struct QComBaseApi
+{
+    decltype(&::RoGetActivationFactory) pRoGetActivationFactory = nullptr;
+    decltype(&::WindowsCreateStringReference) pWindowsCreateStringReference = nullptr;
+
+    static QComBaseApi *instance()
+    {
+        static QComBaseApi api;
+        return &api;
+    }
+
+private:
+    Q_DISABLE_COPY_MOVE(QComBaseApi)
+
+    explicit QComBaseApi()
+    {
+        if (!QOperatingSystemVersion::isWin8OrGreater())
+            return;
+        QSystemLibrary comBase(u"combase"_s);
+        pRoGetActivationFactory = reinterpret_cast<decltype(pRoGetActivationFactory)>(comBase.resolve("RoGetActivationFactory"));
+        pWindowsCreateStringReference = reinterpret_cast<decltype(pWindowsCreateStringReference)>(comBase.resolve("WindowsCreateStringReference"));
+    }
+
+    ~QComBaseApi() = default;
+};
+
 // Return tablet mode, note: Does not work for GetDesktopWindow().
 bool qt_windowsIsTabletMode(HWND hwnd)
 {
+    if (!QComBaseApi::instance()->pRoGetActivationFactory ||
+        !QComBaseApi::instance()->pWindowsCreateStringReference) {
+        return false;
+    }
+
     bool result = false;
 
     const wchar_t uiViewSettingsId[] = L"Windows.UI.ViewManagement.UIViewSettings";
     HSTRING_HEADER uiViewSettingsIdRefHeader;
     HSTRING uiViewSettingsIdHs = nullptr;
     const auto uiViewSettingsIdLen = UINT32(sizeof(uiViewSettingsId) / sizeof(uiViewSettingsId[0]) - 1);
-    if (FAILED(WindowsCreateStringReference(uiViewSettingsId, uiViewSettingsIdLen, &uiViewSettingsIdRefHeader, &uiViewSettingsIdHs)))
+    if (FAILED(QComBaseApi::instance()->pWindowsCreateStringReference(uiViewSettingsId, uiViewSettingsIdLen, &uiViewSettingsIdRefHeader, &uiViewSettingsIdHs)))
         return false;
 
     IUIViewSettingsInterop *uiViewSettingsInterop = nullptr;
     // __uuidof(IUIViewSettingsInterop);
     const GUID uiViewSettingsInteropRefId = {0x3694dbf9, 0x8f68, 0x44be,{0x8f, 0xf5, 0x19, 0x5c, 0x98, 0xed, 0xe8, 0xa6}};
 
-    HRESULT hr = RoGetActivationFactory(uiViewSettingsIdHs, uiViewSettingsInteropRefId,
+    HRESULT hr = QComBaseApi::instance()->pRoGetActivationFactory(uiViewSettingsIdHs, uiViewSettingsInteropRefId,
                                                    reinterpret_cast<void **>(&uiViewSettingsInterop));
     if (FAILED(hr))
         return false;
diff --git a/src/plugins/platforms/windows/qwindowsapplication.cpp b/src/plugins/platforms/windows/qwindowsapplication.cpp
index 5d1b6d348b..bfef10e673 100644
--- a/src/plugins/platforms/windows/qwindowsapplication.cpp
+++ b/src/plugins/platforms/windows/qwindowsapplication.cpp
@@ -12,6 +12,7 @@
 
 #include <QtCore/qvariant.h>
 #include <QtCore/private/qfunctions_win_p.h>
+#include <QtCore/qoperatingsystemversion.h>
 
 #include <QtGui/qpalette.h>
 
@@ -181,11 +182,12 @@ void QWindowsApplication::lightSystemPalette(QPalette &result) const
     QColor accent = getSysColor(COLOR_HIGHLIGHT);
 
 #if QT_CONFIG(cpp_winrt)
-    // respect the Windows 11 accent color
-    using namespace winrt::Windows::UI::ViewManagement;
-    const auto settings = UISettings();
-
-    accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+    if (QOperatingSystemVersion::isWin10RS5OrGreater()) {
+        // Respect the accent color on modern Windows.
+        using namespace winrt::Windows::UI::ViewManagement;
+        const auto settings = UISettings();
+        accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+    }
 #endif
 
     const QColor btnFace = background;
diff --git a/src/plugins/platforms/windows/qwindowscontext.cpp b/src/plugins/platforms/windows/qwindowscontext.cpp
index 3e2cb79def..9d0f06f6ee 100644
--- a/src/plugins/platforms/windows/qwindowscontext.cpp
+++ b/src/plugins/platforms/windows/qwindowscontext.cpp
@@ -120,15 +120,21 @@ static inline bool sessionManagerInteractionBlocked() { return false; }
 
 static inline int windowDpiAwareness(HWND hwnd)
 {
-    return static_cast<int>(GetAwarenessFromDpiAwarenessContext(GetWindowDpiAwarenessContext(hwnd)));
+    if (QWindowsApi::instance()->pGetAwarenessFromDpiAwarenessContext &&
+        QWindowsApi::instance()->pGetWindowDpiAwarenessContext) {
+        return static_cast<int>(
+            QWindowsApi::instance()->pGetAwarenessFromDpiAwarenessContext(
+                QWindowsApi::instance()->pGetWindowDpiAwarenessContext(hwnd)));
+    }
+    return -1;
 }
 
 // Note: This only works within WM_NCCREATE
 static bool enableNonClientDpiScaling(HWND hwnd)
 {
     bool result = false;
-    if (windowDpiAwareness(hwnd) == 2) {
-        result = EnableNonClientDpiScaling(hwnd) != FALSE;
+    if ((windowDpiAwareness(hwnd) == 2) && QWindowsApi::instance()->pEnableNonClientDpiScaling) {
+        result = QWindowsApi::instance()->pEnableNonClientDpiScaling(hwnd) != FALSE;
         if (!result) {
             const DWORD errorCode = GetLastError();
             qErrnoWarning(int(errorCode), "EnableNonClientDpiScaling() failed for HWND %p (%lu)",
@@ -224,7 +230,8 @@ QWindowsContext::~QWindowsContext()
     unregisterWindowClasses();
     if (d->m_oleInitializeResult == S_OK || d->m_oleInitializeResult == S_FALSE) {
 #ifdef QT_USE_FACTORY_CACHE_REGISTRATION
-        detail::QWinRTFactoryCacheRegistration::clearAllCaches();
+        if (QOperatingSystemVersion::isWin10OrGreater())
+            detail::QWinRTFactoryCacheRegistration::clearAllCaches();
 #endif
         OleUninitialize();
     }
@@ -299,6 +306,12 @@ bool QWindowsContext::initPointer(unsigned integrationOptions)
     if (integrationOptions & QWindowsIntegration::DontUseWMPointer)
         return false;
 
+    if (!QOperatingSystemVersion::isWin8OrGreater())
+        return false;
+
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     d->m_systemInfo |= QWindowsContext::SI_SupportsPointer;
     return true;
 }
@@ -369,29 +382,37 @@ void QWindowsContext::setDetectAltGrModifier(bool a)
 int QWindowsContext::processDpiAwareness()
 {
     PROCESS_DPI_AWARENESS result;
-    if (SUCCEEDED(GetProcessDpiAwareness(nullptr, &result))) {
-        return static_cast<int>(result);
+    if (QWindowsApi::instance()->pGetProcessDpiAwareness) {
+        const HRESULT hr = QWindowsApi::instance()->pGetProcessDpiAwareness(nullptr, &result);
+        if (SUCCEEDED(hr))
+            return static_cast<int>(result);
     }
     return -1;
 }
 
-void QWindowsContext::setProcessDpiAwareness(QtWindows::ProcessDpiAwareness dpiAwareness)
+bool QWindowsContext::setProcessDpiAwareness(QtWindows::ProcessDpiAwareness dpiAwareness)
 {
     qCDebug(lcQpaWindow) << __FUNCTION__ << dpiAwareness;
-    const HRESULT hr = SetProcessDpiAwareness(static_cast<PROCESS_DPI_AWARENESS>(dpiAwareness));
+    if (!QWindowsApi::instance()->pSetProcessDpiAwareness)
+        return false;
+    const HRESULT hr = QWindowsApi::instance()->pSetProcessDpiAwareness(static_cast<PROCESS_DPI_AWARENESS>(dpiAwareness));
     // E_ACCESSDENIED means set externally (MSVC manifest or external app loading Qt plugin).
     // Silence warning in that case unless debug is enabled.
     if (FAILED(hr) && hr != E_ACCESSDENIED) {
         qCWarning(lcQpaWindow).noquote().nospace() << "SetProcessDpiAwareness("
             << dpiAwareness << ") failed: " << QSystemError::windowsComString(hr)
             << ", using " << QWindowsContext::processDpiAwareness();
+        return false;
     }
+    return true;
 }
 
 bool QWindowsContext::setProcessDpiV2Awareness()
 {
     qCDebug(lcQpaWindow) << __FUNCTION__;
-    const BOOL ok = SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);
+    if (!QWindowsApi::instance()->pSetProcessDpiAwarenessContext)
+        return false;
+    const BOOL ok = QWindowsApi::instance()->pSetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);
     if (!ok) {
         const DWORD dwError = GetLastError();
         // ERROR_ACCESS_DENIED means set externally (MSVC manifest or external app loading Qt plugin).
@@ -407,6 +428,17 @@ bool QWindowsContext::setProcessDpiV2Awareness()
     return true;
 }
 
+bool QWindowsContext::setProcessSystemDpiAware()
+{
+    qCDebug(lcQpaWindow) << __FUNCTION__;
+    if (SetProcessDPIAware() == FALSE) {
+        qCWarning(lcQpaWindow).noquote().nospace() << "SetProcessDPIAware() failed: "
+            << QSystemError::windowsComString(HRESULT(GetLastError()));
+        return false;
+    }
+    return true;
+}
+
 bool QWindowsContext::isDarkMode()
 {
     return QWindowsContextPrivate::m_darkMode;
@@ -832,8 +864,8 @@ void QWindowsContext::forceNcCalcSize(HWND hwnd)
 bool QWindowsContext::systemParametersInfo(unsigned action, unsigned param, void *out,
                                            unsigned dpi)
 {
-    const BOOL result = dpi != 0
-        ? SystemParametersInfoForDpi(action, param, out, 0, dpi)
+    const BOOL result = (dpi != 0) && (QWindowsApi::instance()->pSystemParametersInfoForDpi != nullptr)
+        ? QWindowsApi::instance()->pSystemParametersInfoForDpi(action, param, out, 0, dpi)
         : SystemParametersInfo(action, param, out, 0);
     return result == TRUE;
 }
@@ -880,7 +912,8 @@ bool QWindowsContext::shouldHaveNonClientDpiScaling(const QWindow *window)
     if (QWindowsContextPrivate::m_v2DpiAware)
         return true;
 
-    return window->isTopLevel()
+    return QOperatingSystemVersion::isWin10OrGreater()
+        && window->isTopLevel()
         && !window->property(QWindowsWindow::embeddedNativeParentHandleProperty).isValid()
 #if QT_CONFIG(opengl) // /QTBUG-62901, EnableNonClientDpiScaling has problems with GL
         && (window->surfaceType() != QSurface::OpenGLSurface
@@ -1527,4 +1560,137 @@ bool QWindowsContext::filterNativeEvent(QWindow *window, MSG *msg, LRESULT *resu
     return false;
 }
 
+UINT QWindowsContext::getDpiForWindow(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    if (QWindowsApi::instance()->pGetDpiForWindow)
+        return QWindowsApi::instance()->pGetDpiForWindow(hWnd);
+    if (const HDC hdc = GetDC(hWnd)) {
+        const int dpiX = GetDeviceCaps(hdc, LOGPIXELSX);
+        ReleaseDC(hWnd, hdc);
+        if (dpiX > 0)
+            return dpiX;
+    }
+    return 0;
+}
+
+UINT QWindowsContext::getDpiForMonitor(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    if (QWindowsApi::instance()->pGetDpiForMonitor) {
+        UINT dpiX = 0;
+        UINT dpiY = 0;
+        const HRESULT hr = QWindowsApi::instance()->pGetDpiForMonitor(hMonitor, MDT_EFFECTIVE_DPI, &dpiX, &dpiY);
+        if (SUCCEEDED(hr) && (dpiX > 0))
+            return dpiX;
+    }
+    MONITORINFOEXW monitorInfo;
+    SecureZeroMemory(&monitorInfo, sizeof(monitorInfo));
+    monitorInfo.cbSize = sizeof(monitorInfo);
+    GetMonitorInfoW(hMonitor, &monitorInfo);
+    if (const HDC hdc = CreateDCW(monitorInfo.szDevice, monitorInfo.szDevice, nullptr, nullptr)) {
+        const int dpiX = GetDeviceCaps(hdc, LOGPIXELSX);
+        DeleteDC(hdc);
+        if (dpiX > 0)
+            return dpiX;
+    }
+    return 0;
+}
+
+UINT QWindowsContext::getDpiForPrimaryMonitor()
+{
+    if (const HMONITOR hMonitor = MonitorFromWindow(GetDesktopWindow(), MONITOR_DEFAULTTOPRIMARY))
+        return getDpiForMonitor(hMonitor);
+    return 0;
+}
+
+UINT QWindowsContext::getMostPossibleDpiForWindow(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    UINT dpi = getDpiForWindow(hWnd);
+    if (dpi > 0)
+        return dpi;
+    if (const HMONITOR hMonitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTONEAREST)) {
+        dpi = getDpiForMonitor(hMonitor);
+        if (dpi > 0)
+            return dpi;
+    }
+    dpi = getDpiForPrimaryMonitor();
+    if (dpi > 0)
+        return dpi;
+    return USER_DEFAULT_SCREEN_DPI;
+}
+
+UINT QWindowsContext::getMostPossibleDpiForMonitor(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    UINT dpi = getDpiForMonitor(hMonitor);
+    if (dpi > 0)
+        return dpi;
+    dpi = getDpiForPrimaryMonitor();
+    if (dpi > 0)
+        return dpi;
+    return USER_DEFAULT_SCREEN_DPI;
+}
+
+int QWindowsContext::getResizeBorderThicknessForDpi(const UINT dpi)
+{
+    // The thickness of the padded border will always be 0 if DWM composition is disabled.
+    if (QWindowsApi::instance()->pGetSystemMetricsForDpi) {
+        return QWindowsApi::instance()->pGetSystemMetricsForDpi(SM_CXSIZEFRAME, dpi)
+            + QWindowsApi::instance()->pGetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi);
+    }
+    return GetSystemMetrics(SM_CXSIZEFRAME) + GetSystemMetrics(SM_CXPADDEDBORDER);
+}
+
+int QWindowsContext::getResizeBorderThickness(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    return getResizeBorderThicknessForDpi(getMostPossibleDpiForWindow(hWnd));
+}
+
+int QWindowsContext::getResizeBorderThickness(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    return getResizeBorderThicknessForDpi(getMostPossibleDpiForMonitor(hMonitor));
+}
+
+int QWindowsContext::getTitleBarHeightForDpi(const UINT dpi)
+{
+    const int border = getResizeBorderThicknessForDpi(dpi);
+    if (QWindowsApi::instance()->pGetSystemMetricsForDpi) {
+        return border +
+            QWindowsApi::instance()->pGetSystemMetricsForDpi(SM_CYCAPTION, dpi);
+    }
+    return border + GetSystemMetrics(SM_CYCAPTION);
+}
+
+int QWindowsContext::getTitleBarHeight(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    return getTitleBarHeightForDpi(getMostPossibleDpiForWindow(hWnd));
+}
+
+int QWindowsContext::getTitleBarHeight(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    return getTitleBarHeightForDpi(getMostPossibleDpiForMonitor(hMonitor));
+}
+
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/windows/qwindowscontext.h b/src/plugins/platforms/windows/qwindowscontext.h
index 6b3010f33c..31e528190a 100644
--- a/src/plugins/platforms/windows/qwindowscontext.h
+++ b/src/plugins/platforms/windows/qwindowscontext.h
@@ -10,13 +10,18 @@
 #include <QtCore/qscopedpointer.h>
 #include <QtCore/qsharedpointer.h>
 #include <QtCore/qloggingcategory.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 
 #define STRICT_TYPED_ITEMIDS
 #include <shlobj.h>
 #include <shlwapi.h>
+#include <shellscalingapi.h>
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 Q_DECLARE_LOGGING_CATEGORY(lcQpaWindow)
 Q_DECLARE_LOGGING_CATEGORY(lcQpaEvents)
 Q_DECLARE_LOGGING_CATEGORY(lcQpaGl)
@@ -44,6 +49,90 @@ class QPoint;
 class QKeyEvent;
 class QPointingDevice;
 
+struct QWindowsApi
+{
+    decltype(&::GetDpiForWindow) pGetDpiForWindow = nullptr;
+    decltype(&::GetDpiForMonitor) pGetDpiForMonitor = nullptr;
+    decltype(&::SystemParametersInfoForDpi) pSystemParametersInfoForDpi = nullptr;
+    decltype(&::GetSystemMetricsForDpi) pGetSystemMetricsForDpi = nullptr;
+    decltype(&::AdjustWindowRectExForDpi) pAdjustWindowRectExForDpi = nullptr;
+    decltype(&::GetProcessDpiAwareness) pGetProcessDpiAwareness = nullptr;
+    decltype(&::SetProcessDpiAwareness) pSetProcessDpiAwareness = nullptr;
+    decltype(&::SetProcessDpiAwarenessContext) pSetProcessDpiAwarenessContext = nullptr;
+    decltype(&::EnableNonClientDpiScaling) pEnableNonClientDpiScaling = nullptr;
+    decltype(&::GetAwarenessFromDpiAwarenessContext) pGetAwarenessFromDpiAwarenessContext = nullptr;
+    decltype(&::GetWindowDpiAwarenessContext) pGetWindowDpiAwarenessContext = nullptr;
+    decltype(&::GetPointerType) pGetPointerType = nullptr;
+    decltype(&::GetPointerInfo) pGetPointerInfo = nullptr;
+    decltype(&::GetPointerFrameTouchInfo) pGetPointerFrameTouchInfo = nullptr;
+    decltype(&::GetPointerFrameTouchInfoHistory) pGetPointerFrameTouchInfoHistory = nullptr;
+    decltype(&::GetPointerPenInfo) pGetPointerPenInfo = nullptr;
+    decltype(&::GetPointerPenInfoHistory) pGetPointerPenInfoHistory = nullptr;
+    decltype(&::SkipPointerFrameMessages) pSkipPointerFrameMessages = nullptr;
+    decltype(&::GetPointerDeviceRects) pGetPointerDeviceRects = nullptr;
+    decltype(&::SetDisplayAutoRotationPreferences) pSetDisplayAutoRotationPreferences = nullptr;
+    decltype(&::GetDisplayAutoRotationPreferences) pGetDisplayAutoRotationPreferences = nullptr;
+
+    static QWindowsApi *instance()
+    {
+        static QWindowsApi api;
+        return &api;
+    }
+
+    bool supportsPointerApi() const
+    {
+        if (!QOperatingSystemVersion::isWin8OrGreater())
+            return false;
+        return pGetPointerType && pGetPointerInfo && pGetPointerFrameTouchInfo
+            && pGetPointerFrameTouchInfoHistory && pGetPointerPenInfo
+            && pGetPointerPenInfoHistory && pSkipPointerFrameMessages
+            && pGetPointerDeviceRects;
+    }
+
+private:
+    Q_DISABLE_COPY_MOVE(QWindowsApi)
+
+    explicit QWindowsApi()
+    {
+        if (QOperatingSystemVersion::isWin8OrGreater()) {
+            QSystemLibrary user32(u"user32"_s);
+            pGetPointerType = reinterpret_cast<decltype(pGetPointerType)>(user32.resolve("GetPointerType"));
+            pGetPointerInfo = reinterpret_cast<decltype(pGetPointerInfo)>(user32.resolve("GetPointerInfo"));
+            pGetPointerFrameTouchInfo = reinterpret_cast<decltype(pGetPointerFrameTouchInfo)>(user32.resolve("GetPointerFrameTouchInfo"));
+            pGetPointerFrameTouchInfoHistory = reinterpret_cast<decltype(pGetPointerFrameTouchInfoHistory)>(user32.resolve("GetPointerFrameTouchInfoHistory"));
+            pGetPointerPenInfo = reinterpret_cast<decltype(pGetPointerPenInfo)>(user32.resolve("GetPointerPenInfo"));
+            pGetPointerPenInfoHistory = reinterpret_cast<decltype(pGetPointerPenInfoHistory)>(user32.resolve("GetPointerPenInfoHistory"));
+            pSkipPointerFrameMessages = reinterpret_cast<decltype(pSkipPointerFrameMessages)>(user32.resolve("SkipPointerFrameMessages"));
+            pGetPointerDeviceRects = reinterpret_cast<decltype(pGetPointerDeviceRects)>(user32.resolve("GetPointerDeviceRects"));
+            pSetDisplayAutoRotationPreferences = reinterpret_cast<decltype(pSetDisplayAutoRotationPreferences)>(user32.resolve("SetDisplayAutoRotationPreferences"));
+            pGetDisplayAutoRotationPreferences = reinterpret_cast<decltype(pGetDisplayAutoRotationPreferences)>(user32.resolve("GetDisplayAutoRotationPreferences"));
+
+            if (QOperatingSystemVersion::isWin8Point1OrGreater()) {
+                QSystemLibrary shcore(u"shcore"_s);
+                pGetDpiForMonitor = reinterpret_cast<decltype(pGetDpiForMonitor)>(shcore.resolve("GetDpiForMonitor"));
+                pGetProcessDpiAwareness = reinterpret_cast<decltype(pGetProcessDpiAwareness)>(shcore.resolve("GetProcessDpiAwareness"));
+                pSetProcessDpiAwareness = reinterpret_cast<decltype(pSetProcessDpiAwareness)>(shcore.resolve("SetProcessDpiAwareness"));
+
+                if (QOperatingSystemVersion::isWin10RS1OrGreater()) {
+                    pGetDpiForWindow = reinterpret_cast<decltype(pGetDpiForWindow)>(user32.resolve("GetDpiForWindow"));
+                    pSystemParametersInfoForDpi = reinterpret_cast<decltype(pSystemParametersInfoForDpi)>(user32.resolve("SystemParametersInfoForDpi"));
+                    pGetSystemMetricsForDpi = reinterpret_cast<decltype(pGetSystemMetricsForDpi)>(user32.resolve("GetSystemMetricsForDpi"));
+                    pAdjustWindowRectExForDpi = reinterpret_cast<decltype(pAdjustWindowRectExForDpi)>(user32.resolve("AdjustWindowRectExForDpi"));
+                    pEnableNonClientDpiScaling = reinterpret_cast<decltype(pEnableNonClientDpiScaling)>(user32.resolve("EnableNonClientDpiScaling"));
+                    pGetAwarenessFromDpiAwarenessContext = reinterpret_cast<decltype(pGetAwarenessFromDpiAwarenessContext)>(user32.resolve("GetAwarenessFromDpiAwarenessContext"));
+                    pGetWindowDpiAwarenessContext = reinterpret_cast<decltype(pGetWindowDpiAwarenessContext)>(user32.resolve("GetWindowDpiAwarenessContext"));
+
+                    if (QOperatingSystemVersion::isWin10RS2OrGreater()) {
+                        pSetProcessDpiAwarenessContext = reinterpret_cast<decltype(pSetProcessDpiAwarenessContext)>(user32.resolve("SetProcessDpiAwarenessContext"));
+                    }
+                }
+            }
+        }
+    }
+
+    ~QWindowsApi() = default;
+};
+
 class QWindowsContext
 {
     Q_DISABLE_COPY_MOVE(QWindowsContext)
@@ -115,9 +204,10 @@ public:
     QSharedPointer<QWindowCreationContext> windowCreationContext() const;
 
     static void setTabletAbsoluteRange(int a);
-    void setProcessDpiAwareness(QtWindows::ProcessDpiAwareness dpiAwareness);
+    bool setProcessDpiAwareness(QtWindows::ProcessDpiAwareness dpiAwareness);
     static int processDpiAwareness();
     bool setProcessDpiV2Awareness();
+    bool setProcessSystemDpiAware();
 
     static bool isDarkMode();
 
@@ -158,6 +248,18 @@ public:
     static bool filterNativeEvent(MSG *msg, LRESULT *result);
     static bool filterNativeEvent(QWindow *window, MSG *msg, LRESULT *result);
 
+    static UINT getDpiForWindow(const HWND hWnd);
+    static UINT getDpiForMonitor(const HMONITOR hMonitor);
+    static UINT getDpiForPrimaryMonitor();
+    static UINT getMostPossibleDpiForWindow(const HWND hWnd);
+    static UINT getMostPossibleDpiForMonitor(const HMONITOR hMonitor);
+    static int getResizeBorderThicknessForDpi(const UINT dpi);
+    static int getResizeBorderThickness(const HWND hWnd);
+    static int getResizeBorderThickness(const HMONITOR hMonitor);
+    static int getTitleBarHeightForDpi(const UINT dpi);
+    static int getTitleBarHeight(const HWND hWnd);
+    static int getTitleBarHeight(const HMONITOR hMonitor);
+
 private:
     void handleFocusEvent(QtWindows::WindowsEventType et, QWindowsWindow *w);
 #ifndef QT_NO_CONTEXTMENU
diff --git a/src/plugins/platforms/windows/qwindowsdrag.cpp b/src/plugins/platforms/windows/qwindowsdrag.cpp
index 93205259f8..9f5f73588c 100644
--- a/src/plugins/platforms/windows/qwindowsdrag.cpp
+++ b/src/plugins/platforms/windows/qwindowsdrag.cpp
@@ -664,12 +664,13 @@ static HRESULT startDoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
                 return ::DoDragDrop(pDataObj, pDropSource, dwOKEffects, pdwEffect);
             }
 
-            if (msg.message == WM_POINTERUPDATE) {
+            static const bool pointerApiSupported = QWindowsApi::instance()->supportsPointerApi();
+            if (msg.message == WM_POINTERUPDATE && pointerApiSupported) {
 
                 const quint32 pointerId = GET_POINTERID_WPARAM(msg.wParam);
 
                 POINTER_INFO pointerInfo{};
-                if (!GetPointerInfo(pointerId, &pointerInfo))
+                if (!QWindowsApi::instance()->pGetPointerInfo(pointerId, &pointerInfo))
                     return E_FAIL;
 
                 if (pointerInfo.pointerFlags & POINTER_FLAG_PRIMARY) {
@@ -713,7 +714,7 @@ static HRESULT startDoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
                 // Handle other messages.
                 qWindowsWndProc(msg.hwnd, msg.message, msg.wParam, msg.lParam);
 
-                if (msg.message == WM_POINTERLEAVE)
+                if (msg.message == WM_POINTERLEAVE && pointerApiSupported)
                     return E_FAIL;
             }
         } else {
diff --git a/src/plugins/platforms/windows/qwindowsintegration.cpp b/src/plugins/platforms/windows/qwindowsintegration.cpp
index 51f040e719..689d3601f9 100644
--- a/src/plugins/platforms/windows/qwindowsintegration.cpp
+++ b/src/plugins/platforms/windows/qwindowsintegration.cpp
@@ -229,8 +229,10 @@ void QWindowsIntegrationPrivate::parseOptions(QWindowsIntegration *q, const QStr
     initOpenGlBlacklistResources();
 
     static bool dpiAwarenessSet = false;
+    static const bool hasDpiAwarenessContext = QWindowsApi::instance()->pSetProcessDpiAwarenessContext != nullptr;
     // Default to per-monitor-v2 awareness (if available)
-    QtWindows::ProcessDpiAwareness dpiAwareness = QtWindows::ProcessPerMonitorV2DpiAware;
+    QtWindows::ProcessDpiAwareness dpiAwareness = hasDpiAwarenessContext ?
+        QtWindows::ProcessPerMonitorV2DpiAware : QtWindows::ProcessPerMonitorDpiAware;
 
     int tabletAbsoluteRange = -1;
     DarkModeHandling darkModeHandling = DarkModeHandlingFlag::DarkModeWindowFrames
@@ -249,10 +251,10 @@ void QWindowsIntegrationPrivate::parseOptions(QWindowsIntegration *q, const QStr
 
     if (!dpiAwarenessSet) { // Set only once in case of repeated instantiations of QGuiApplication.
         if (!QCoreApplication::testAttribute(Qt::AA_PluginApplication)) {
-            if (dpiAwareness == QtWindows::ProcessPerMonitorV2DpiAware) {
-                // DpiAwareV2 requires using new API
+            // DpiAwareV2 requires using new API
+            if (dpiAwareness == QtWindows::ProcessPerMonitorV2DpiAware && hasDpiAwarenessContext) {
                 if (m_context.setProcessDpiV2Awareness()) {
-                    qCDebug(lcQpaWindow, "DpiAwareness: DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2");
+                    qCDebug(lcQpaWindow) << "DpiAwareness: DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2";
                     dpiAwarenessSet = true;
                 } else {
                     // fallback to old API
@@ -261,12 +263,23 @@ void QWindowsIntegrationPrivate::parseOptions(QWindowsIntegration *q, const QStr
             }
 
             if (!dpiAwarenessSet) {
-                m_context.setProcessDpiAwareness(dpiAwareness);
-                qCDebug(lcQpaWindow) << "DpiAwareness=" << dpiAwareness
-                    << "effective process DPI awareness=" << QWindowsContext::processDpiAwareness();
+                if (m_context.setProcessDpiAwareness(dpiAwareness)) {
+                    qCDebug(lcQpaWindow) << "DpiAwareness=" << dpiAwareness
+                        << "effective process DPI awareness=" << QWindowsContext::processDpiAwareness();
+                    dpiAwarenessSet = true;
+                }
+            }
+
+            if (!dpiAwarenessSet) {
+                if (m_context.setProcessSystemDpiAware()) {
+                    qCDebug(lcQpaWindow) << "DpiAwareness: System Aware";
+                    dpiAwarenessSet = true;
+                }
             }
+
+            if (!dpiAwarenessSet)
+                qCWarning(lcQpaWindow) << "Failed to set Dpi Awareness mode for current process.";
         }
-        dpiAwarenessSet = true;
     }
 
     m_context.initTouch(m_options);
diff --git a/src/plugins/platforms/windows/qwindowskeymapper.cpp b/src/plugins/platforms/windows/qwindowskeymapper.cpp
index 044de5f3ea..4d55581596 100644
--- a/src/plugins/platforms/windows/qwindowskeymapper.cpp
+++ b/src/plugins/platforms/windows/qwindowskeymapper.cpp
@@ -749,21 +749,10 @@ static inline QString messageKeyText(const MSG &msg)
     return ch.isNull() ? QString() : QString(ch);
 }
 
-[[nodiscard]] static inline int getTitleBarHeight(const HWND hwnd)
-{
-    const UINT dpi = GetDpiForWindow(hwnd);
-    const int captionHeight = GetSystemMetricsForDpi(SM_CYCAPTION, dpi);
-    if (IsZoomed(hwnd))
-        return captionHeight;
-    // The frame height should also be taken into account if the window
-    // is not maximized.
-    const int frameHeight = GetSystemMetricsForDpi(SM_CYSIZEFRAME, dpi)
-                            + GetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi);
-    return captionHeight + frameHeight;
-}
-
 [[nodiscard]] static inline bool isSystemMenuOffsetNeeded(const Qt::WindowFlags flags)
 {
+    if (qEnvironmentVariableIntValue("QT_WINDOWS_SYSTEM_MENU_NEED_OFFSET"))
+        return true;
     static constexpr const Qt::WindowFlags titleBarHints =
         Qt::WindowMinMaxButtonsHint | Qt::WindowCloseButtonHint | Qt::WindowContextHelpButtonHint;
     return (flags & Qt::WindowSystemMenuHint) && (flags & Qt::WindowTitleHint) && !(flags & titleBarHints)
@@ -804,7 +793,8 @@ static void showSystemMenu(QWindow* w)
 #undef disabled
 
     const QPoint pos = QHighDpi::toNativePixels(topLevel->geometry().topLeft(), topLevel);
-    const int titleBarOffset = isSystemMenuOffsetNeeded(topLevel->flags()) ? getTitleBarHeight(topLevelHwnd) : 0;
+    const int titleBarOffset = isSystemMenuOffsetNeeded(topLevel->flags())
+        ? QWindowsContext::getTitleBarHeight(topLevelHwnd) : 0;
     const int ret = TrackPopupMenuEx(menu,
                                TPM_LEFTALIGN | TPM_TOPALIGN | TPM_NONOTIFY | TPM_RETURNCMD,
                                pos.x(), pos.y() + titleBarOffset,
diff --git a/src/plugins/platforms/windows/qwindowspointerhandler.cpp b/src/plugins/platforms/windows/qwindowspointerhandler.cpp
index 88f02347b3..75226c3810 100644
--- a/src/plugins/platforms/windows/qwindowspointerhandler.cpp
+++ b/src/plugins/platforms/windows/qwindowspointerhandler.cpp
@@ -45,10 +45,13 @@ QWindowsPointerHandler::~QWindowsPointerHandler()
 
 bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, QtWindows::WindowsEventType et, MSG msg, LRESULT *result)
 {
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     *result = 0;
     const quint32 pointerId = GET_POINTERID_WPARAM(msg.wParam);
 
-    if (!GetPointerType(pointerId, &m_pointerType)) {
+    if (!QWindowsApi::instance()->pGetPointerType(pointerId, &m_pointerType)) {
         qWarning() << "GetPointerType() failed:" << qt_error_string();
         return false;
     }
@@ -62,12 +65,12 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
     }
     case QT_PT_TOUCH: {
         quint32 pointerCount = 0;
-        if (!GetPointerFrameTouchInfo(pointerId, &pointerCount, nullptr)) {
+        if (!QWindowsApi::instance()->pGetPointerFrameTouchInfo(pointerId, &pointerCount, nullptr)) {
             qWarning() << "GetPointerFrameTouchInfo() failed:" << qt_error_string();
             return false;
         }
         QVarLengthArray<POINTER_TOUCH_INFO, 10> touchInfo(pointerCount);
-        if (!GetPointerFrameTouchInfo(pointerId, &pointerCount, touchInfo.data())) {
+        if (!QWindowsApi::instance()->pGetPointerFrameTouchInfo(pointerId, &pointerCount, touchInfo.data())) {
             qWarning() << "GetPointerFrameTouchInfo() failed:" << qt_error_string();
             return false;
         }
@@ -80,7 +83,7 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
         // dispatch any skipped frames if event compression is disabled by the app
         if (historyCount > 1 && !QCoreApplication::testAttribute(Qt::AA_CompressHighFrequencyEvents)) {
             touchInfo.resize(pointerCount * historyCount);
-            if (!GetPointerFrameTouchInfoHistory(pointerId,
+            if (!QWindowsApi::instance()->pGetPointerFrameTouchInfoHistory(pointerId,
                                                  &historyCount,
                                                  &pointerCount,
                                                  touchInfo.data())) {
@@ -101,7 +104,7 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
     }
     case QT_PT_PEN: {
         POINTER_PEN_INFO penInfo;
-        if (!GetPointerPenInfo(pointerId, &penInfo)) {
+        if (!QWindowsApi::instance()->pGetPointerPenInfo(pointerId, &penInfo)) {
             qWarning() << "GetPointerPenInfo() failed:" << qt_error_string();
             return false;
         }
@@ -113,7 +116,7 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
                 || !QCoreApplication::testAttribute(Qt::AA_CompressTabletEvents))) {
             QVarLengthArray<POINTER_PEN_INFO, 10> penInfoHistory(historyCount);
 
-            if (!GetPointerPenInfoHistory(pointerId, &historyCount, penInfoHistory.data())) {
+            if (!QWindowsApi::instance()->pGetPointerPenInfoHistory(pointerId, &historyCount, penInfoHistory.data())) {
                 qWarning() << "GetPointerPenInfoHistory() failed:" << qt_error_string();
                 return false;
             }
@@ -419,6 +422,9 @@ bool QWindowsPointerHandler::translateTouchEvent(QWindow *window, HWND hwnd,
 {
     Q_UNUSED(hwnd);
 
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     auto *touchInfo = static_cast<POINTER_TOUCH_INFO *>(vTouchInfo);
 
     if (et & QtWindows::NonClientEventFlag)
@@ -517,7 +523,7 @@ bool QWindowsPointerHandler::translateTouchEvent(QWindow *window, HWND hwnd,
         inputIds.insert(touchPoint.id);
 
         // Avoid getting repeated messages for this frame if there are multiple pointerIds
-        SkipPointerFrameMessages(touchInfo[i].pointerInfo.pointerId);
+        QWindowsApi::instance()->pSkipPointerFrameMessages(touchInfo[i].pointerInfo.pointerId);
     }
 
     // Some devices send touches for each finger in a different message/frame, instead of consolidating
@@ -557,13 +563,16 @@ bool QWindowsPointerHandler::translatePenEvent(QWindow *window, HWND hwnd, QtWin
                                                MSG msg, PVOID vPenInfo)
 {
 #if QT_CONFIG(tabletevent)
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     if (et & QtWindows::NonClientEventFlag)
         return false; // Let DefWindowProc() handle Non Client messages.
 
     auto *penInfo = static_cast<POINTER_PEN_INFO *>(vPenInfo);
 
     RECT pRect, dRect;
-    if (!GetPointerDeviceRects(penInfo->pointerInfo.sourceDevice, &pRect, &dRect))
+    if (!QWindowsApi::instance()->pGetPointerDeviceRects(penInfo->pointerInfo.sourceDevice, &pRect, &dRect))
         return false;
 
     const auto systemId = (qint64)penInfo->pointerInfo.sourceDevice;
diff --git a/src/plugins/platforms/windows/qwindowsscreen.cpp b/src/plugins/platforms/windows/qwindowsscreen.cpp
index f15a7a870d..3f141adb23 100644
--- a/src/plugins/platforms/windows/qwindowsscreen.cpp
+++ b/src/plugins/platforms/windows/qwindowsscreen.cpp
@@ -26,20 +26,6 @@ QT_BEGIN_NAMESPACE
 
 using namespace Qt::StringLiterals;
 
-static inline QDpi deviceDPI(HDC hdc)
-{
-    return QDpi(GetDeviceCaps(hdc, LOGPIXELSX), GetDeviceCaps(hdc, LOGPIXELSY));
-}
-
-static inline QDpi monitorDPI(HMONITOR hMonitor)
-{
-    UINT dpiX;
-    UINT dpiY;
-    if (SUCCEEDED(GetDpiForMonitor(hMonitor, MDT_EFFECTIVE_DPI, &dpiX, &dpiY)))
-        return QDpi(dpiX, dpiY);
-    return {0, 0};
-}
-
 static bool getPathInfo(const MONITORINFOEX &viewInfo, DISPLAYCONFIG_PATH_INFO *pathInfo)
 {
     // We might want to consider storing adapterId/id from DISPLAYCONFIG_PATH_TARGET_INFO.
@@ -135,8 +121,8 @@ static bool monitorData(HMONITOR hMonitor, QWindowsScreenData *data)
         data->flags |= QWindowsScreenData::LockScreen;
     } else {
         if (const HDC hdc = CreateDC(info.szDevice, nullptr, nullptr, nullptr)) {
-            const QDpi dpi = monitorDPI(hMonitor);
-            data->dpi = dpi.first > 0 ? dpi : deviceDPI(hdc);
+            const UINT dpi = QWindowsContext::getMostPossibleDpiForMonitor(hMonitor);
+            data->dpi = QDpi(dpi, dpi);
             data->depth = GetDeviceCaps(hdc, BITSPIXEL);
             data->format = data->depth == 16 ? QImage::Format_RGB16 : QImage::Format_RGB32;
             data->physicalSizeMM = QSizeF(GetDeviceCaps(hdc, HORZSIZE), GetDeviceCaps(hdc, VERTSIZE));
@@ -424,7 +410,8 @@ QRect QWindowsScreen::virtualGeometry(const QPlatformScreen *screen) // cf QScre
 
 bool QWindowsScreen::setOrientationPreference(Qt::ScreenOrientation o)
 {
-    bool result = false;
+    if (!QWindowsApi::instance()->pSetDisplayAutoRotationPreferences)
+        return false;
     ORIENTATION_PREFERENCE orientationPreference = ORIENTATION_PREFERENCE_NONE;
     switch (o) {
     case Qt::PrimaryOrientation:
@@ -442,33 +429,29 @@ bool QWindowsScreen::setOrientationPreference(Qt::ScreenOrientation o)
         orientationPreference = ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED;
         break;
     }
-    result = SetDisplayAutoRotationPreferences(orientationPreference);
-    return result;
+    return QWindowsApi::instance()->pSetDisplayAutoRotationPreferences(orientationPreference);
 }
 
 Qt::ScreenOrientation QWindowsScreen::orientationPreference()
 {
-    Qt::ScreenOrientation result = Qt::PrimaryOrientation;
+    if (!QWindowsApi::instance()->pGetDisplayAutoRotationPreferences)
+        return Qt::PrimaryOrientation;
     ORIENTATION_PREFERENCE orientationPreference = ORIENTATION_PREFERENCE_NONE;
-    if (GetDisplayAutoRotationPreferences(&orientationPreference)) {
+    if (QWindowsApi::instance()->pGetDisplayAutoRotationPreferences(&orientationPreference)) {
         switch (orientationPreference) {
         case ORIENTATION_PREFERENCE_NONE:
-            break;
+            return Qt::PrimaryOrientation;
         case ORIENTATION_PREFERENCE_LANDSCAPE:
-            result = Qt::LandscapeOrientation;
-            break;
+            return Qt::LandscapeOrientation;
         case ORIENTATION_PREFERENCE_PORTRAIT:
-            result = Qt::PortraitOrientation;
-            break;
+            return Qt::PortraitOrientation;
         case ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED:
-            result = Qt::InvertedLandscapeOrientation;
-            break;
+            return Qt::InvertedLandscapeOrientation;
         case ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED:
-            result = Qt::InvertedPortraitOrientation;
-            break;
+            return Qt::InvertedPortraitOrientation;
         }
     }
-    return result;
+    return Qt::PrimaryOrientation;
 }
 
 /*!
diff --git a/src/plugins/platforms/windows/qwindowstheme.cpp b/src/plugins/platforms/windows/qwindowstheme.cpp
index b9d02a4374..3398668b98 100644
--- a/src/plugins/platforms/windows/qwindowstheme.cpp
+++ b/src/plugins/platforms/windows/qwindowstheme.cpp
@@ -39,6 +39,7 @@
 #include <private/qsystemlibrary_p.h>
 #include <private/qwinregistry_p.h>
 #include <QtCore/private/qfunctions_win_p.h>
+#include <QtCore/qoperatingsystemversion.h>
 
 #include <algorithm>
 
@@ -241,41 +242,62 @@ static void populateLightSystemBasePalette(QPalette &result)
 
 static void populateDarkSystemBasePalette(QPalette &result)
 {
+    QColor foreground;
+    QColor background;
+    QColor accent;
+    QColor accentDark;
+    QColor accentDarker;
+    QColor accentDarkest;
+    QColor accentLight;
+    QColor accentLighter;
+    QColor accentLightest;
+    QColor linkColor;
+
+    bool colorSet = false;
+
 #if QT_CONFIG(cpp_winrt)
-    using namespace winrt::Windows::UI::ViewManagement;
-    const auto settings = UISettings();
-
-    // We have to craft a palette from these colors. The settings.UIElementColor(UIElementType) API
-    // returns the old system colors, not the dark mode colors. If the background is black (which it
-    // usually), then override it with a dark gray instead so that we can go up and down the lightness.
-    const QColor foreground = getSysColor(settings.GetColorValue(UIColorType::Foreground));
-    const QColor background = [&settings]() -> QColor {
-        auto systemBackground = getSysColor(settings.GetColorValue(UIColorType::Background));
-        if (systemBackground == Qt::black)
-            systemBackground = QColor(0x1E, 0x1E, 0x1E);
-        return systemBackground;
-    }();
-
-    const QColor accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
-    const QColor accentDark = getSysColor(settings.GetColorValue(UIColorType::AccentDark1));
-    const QColor accentDarker = getSysColor(settings.GetColorValue(UIColorType::AccentDark2));
-    const QColor accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
-    const QColor accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
-    const QColor accentLighter = getSysColor(settings.GetColorValue(UIColorType::AccentLight2));
-    const QColor accentLightest = getSysColor(settings.GetColorValue(UIColorType::AccentLight3));
-    const QColor linkColor = accent;
-#else
-    const QColor foreground = Qt::white;
-    const QColor background = QColor(0x1E, 0x1E, 0x1E);
-    const QColor accent = QColor(0x00, 0x55, 0xff);
-    const QColor accentDark = accent.darker(120);
-    const QColor accentDarker = accentDark.darker(120);
-    const QColor accentDarkest = accentDarker.darker(120);
-    const QColor accentLight = accent.lighter(120);
-    const QColor accentLighter = accentLight.lighter(120);
-    const QColor accentLightest = accentLighter.lighter(120);
-    const QColor linkColor = Qt::blue;
+    if (QOperatingSystemVersion::isWin10RS5OrGreater()) {
+        using namespace winrt::Windows::UI::ViewManagement;
+        const auto settings = UISettings();
+
+        // We have to craft a palette from these colors. The settings.UIElementColor(UIElementType) API
+        // returns the old system colors, not the dark mode colors. If the background is black (which it
+        // usually), then override it with a dark gray instead so that we can go up and down the lightness.
+        foreground = getSysColor(settings.GetColorValue(UIColorType::Foreground));
+        background = [&settings]() -> QColor {
+            auto systemBackground = getSysColor(settings.GetColorValue(UIColorType::Background));
+            if (systemBackground == Qt::black)
+                systemBackground = QColor(0x1E, 0x1E, 0x1E);
+            return systemBackground;
+        }();
+
+        accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+        accentDark = getSysColor(settings.GetColorValue(UIColorType::AccentDark1));
+        accentDarker = getSysColor(settings.GetColorValue(UIColorType::AccentDark2));
+        accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
+        accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
+        accentLighter = getSysColor(settings.GetColorValue(UIColorType::AccentLight2));
+        accentLightest = getSysColor(settings.GetColorValue(UIColorType::AccentLight3));
+        linkColor = accent;
+
+        colorSet = true;
+    }
 #endif
+
+    if (!colorSet) {
+        foreground = Qt::white;
+        background = QColor(0x1E, 0x1E, 0x1E);
+        accent = QColor(0x00, 0x55, 0xff);
+        accentDark = accent.darker(120);
+        accentDarker = accentDark.darker(120);
+        accentDarkest = accentDarker.darker(120);
+        accentLight = accent.lighter(120);
+        accentLighter = accentLight.lighter(120);
+        accentLightest = accentLighter.lighter(120);
+        linkColor = Qt::blue;
+        colorSet = true;
+    }
+
     const QColor buttonColor = background.lighter(200);
 
     result.setColor(QPalette::All, QPalette::WindowText, foreground);
@@ -532,25 +554,31 @@ void QWindowsTheme::refreshPalettes()
     m_palettes[MenuPalette] = new QPalette(menuPalette(*m_palettes[SystemPalette], light));
     m_palettes[MenuBarPalette] = menuBarPalette(*m_palettes[MenuPalette], light);
     if (!light) {
+        bool colorSet = false;
 #if QT_CONFIG(cpp_winrt)
-        using namespace winrt::Windows::UI::ViewManagement;
-        const auto settings = UISettings();
-        const QColor accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
-        const QColor accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
-        const QColor accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
-        m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Base, accent);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Button, accentLight);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Inactive, QPalette::Base, accentDarkest);
-#else
-        m_palettes[ButtonPalette] = new QPalette(*m_palettes[SystemPalette]);
-        m_palettes[ButtonPalette]->setColor(QPalette::Button, QColor(0x666666u));
-        const QColor checkBoxBlue(0x0078d7u);
-        m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Base, checkBoxBlue);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Button, checkBoxBlue);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::ButtonText, Qt::white);
+        if (QOperatingSystemVersion::isWin10RS5OrGreater()) {
+            using namespace winrt::Windows::UI::ViewManagement;
+            const auto settings = UISettings();
+            const QColor accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+            const QColor accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
+            const QColor accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
+            m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Base, accent);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Button, accentLight);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Inactive, QPalette::Base, accentDarkest);
+            colorSet = true;
+        }
 #endif
+        if (!colorSet) {
+            m_palettes[ButtonPalette] = new QPalette(*m_palettes[SystemPalette]);
+            m_palettes[ButtonPalette]->setColor(QPalette::Button, QColor(0x666666u));
+            const QColor checkBoxBlue(0x0078d7u);
+            m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Base, checkBoxBlue);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Button, checkBoxBlue);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::ButtonText, Qt::white);
+            colorSet = true;
+        }
         m_palettes[RadioButtonPalette] = new QPalette(*m_palettes[CheckBoxPalette]);
     }
 }
@@ -608,7 +636,10 @@ void QWindowsTheme::refreshFonts()
     fixedFont.setStyleHint(QFont::TypeWriter);
 
     LOGFONT lfIconTitleFont;
-    SystemParametersInfoForDpi(SPI_GETICONTITLELOGFONT, sizeof(lfIconTitleFont), &lfIconTitleFont, 0, dpi);
+    if (QWindowsApi::instance()->pSystemParametersInfoForDpi)
+        QWindowsApi::instance()->pSystemParametersInfoForDpi(SPI_GETICONTITLELOGFONT, sizeof(lfIconTitleFont), &lfIconTitleFont, 0, dpi);
+    else
+        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lfIconTitleFont), &lfIconTitleFont, 0);
     const QFont iconTitleFont = QWindowsFontDatabase::LOGFONT_to_QFont(lfIconTitleFont, dpi);
 
     m_fonts[SystemFont] = new QFont(QWindowsFontDatabase::systemDefaultFont());
@@ -1041,7 +1072,7 @@ bool QWindowsTheme::useNativeMenus()
 
 bool QWindowsTheme::queryDarkMode()
 {
-    if (queryHighContrast()) {
+    if (!QOperatingSystemVersion::isWin10RS5OrGreater() || queryHighContrast()) {
         return false;
     }
     const auto setting = QWinRegistryKey(HKEY_CURRENT_USER, LR"(Software\Microsoft\Windows\CurrentVersion\Themes\Personalize)")
diff --git a/src/plugins/platforms/windows/qwindowswindow.cpp b/src/plugins/platforms/windows/qwindowswindow.cpp
index b2e41dca24..9f947d1b5a 100644
--- a/src/plugins/platforms/windows/qwindowswindow.cpp
+++ b/src/plugins/platforms/windows/qwindowswindow.cpp
@@ -22,6 +22,7 @@
 #  include "qwindowscursor.h"
 #endif
 
+#include <QtCore/qoperatingsystemversion.h>
 #include <QtGui/qguiapplication.h>
 #include <QtGui/qscreen.h>
 #include <QtGui/qwindow.h>
@@ -442,13 +443,26 @@ static inline bool windowIsAccelerated(const QWindow *w)
     }
 }
 
+static bool dwmIsCompositionEnabled()
+{
+    if (QOperatingSystemVersion::isWin8OrGreater())
+        return true;
+    BOOL enabled = FALSE;
+    return SUCCEEDED(DwmIsCompositionEnabled(&enabled)) && enabled != FALSE;
+}
+
 static bool applyBlurBehindWindow(HWND hwnd)
 {
     DWM_BLURBEHIND blurBehind = {0, 0, nullptr, 0};
 
-    blurBehind.dwFlags = DWM_BB_ENABLE | DWM_BB_BLURREGION;
-    blurBehind.fEnable = TRUE;
-    blurBehind.hRgnBlur = CreateRectRgn(0, 0, -1, -1);
+    if (dwmIsCompositionEnabled()) {
+        blurBehind.dwFlags = DWM_BB_ENABLE | DWM_BB_BLURREGION;
+        blurBehind.fEnable = TRUE;
+        blurBehind.hRgnBlur = CreateRectRgn(0, 0, -1, -1);
+    } else {
+        blurBehind.dwFlags = DWM_BB_ENABLE;
+        blurBehind.fEnable = FALSE;
+    }
 
     const bool result = DwmEnableBlurBehindWindow(hwnd, &blurBehind) == S_OK;
 
@@ -515,15 +529,6 @@ static inline void updateGLWindowSettings(const QWindow *w, HWND hwnd, Qt::Windo
     setWindowOpacity(hwnd, flags, hasAlpha, isAccelerated, opacity);
 }
 
-[[nodiscard]] static inline int getResizeBorderThickness(const UINT dpi)
-{
-    // The width of the padded border will always be 0 if DWM composition is
-    // disabled, but since it will always be enabled and can't be programtically
-    // disabled from Windows 8, we are safe to go.
-    return GetSystemMetricsForDpi(SM_CXSIZEFRAME, dpi)
-           + GetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi);
-}
-
 /*!
     Calculates the dimensions of the invisible borders within the
     window frames which only exist on Windows 10 and onwards.
@@ -531,22 +536,21 @@ static inline void updateGLWindowSettings(const QWindow *w, HWND hwnd, Qt::Windo
 
 static QMargins invisibleMargins(QPoint screenPoint)
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return QMargins();
     POINT pt = {screenPoint.x(), screenPoint.y()};
     if (HMONITOR hMonitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONULL)) {
-        UINT dpiX;
-        UINT dpiY;
-        if (SUCCEEDED(GetDpiForMonitor(hMonitor, MDT_EFFECTIVE_DPI, &dpiX, &dpiY))) {
-            const int gap = getResizeBorderThickness(dpiX);
-            return QMargins(gap, 0, gap, gap);
-        }
+        const int gap = QWindowsContext::getResizeBorderThickness(hMonitor);
+        return QMargins(gap, 0, gap, gap);
     }
     return QMargins();
 }
 
 [[nodiscard]] static inline QMargins invisibleMargins(const HWND hwnd)
 {
-    const UINT dpi = GetDpiForWindow(hwnd);
-    const int gap = getResizeBorderThickness(dpi);
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return QMargins();
+    const int gap = QWindowsContext::getResizeBorderThickness(hwnd);
     return QMargins(gap, 0, gap, gap);
 }
 
@@ -786,27 +790,17 @@ void WindowCreationData::fromWindow(const QWindow *w, const Qt::WindowFlags flag
     } else if (topLevel) {
         if (flags & Qt::FramelessWindowHint)
             style = WS_POPUP;                // no border
-        else if (flags & Qt::WindowTitleHint)
-            style = WS_OVERLAPPED;
         else
-            style = 0;
+            style = WS_OVERLAPPED;
     } else {
         style = WS_CHILD;
     }
 
-    // if (!testAttribute(Qt::WA_PaintUnclipped))
-    // ### Commented out for now as it causes some problems, but
-    // this should be correct anyway, so dig some more into this
-#ifdef Q_FLATTEN_EXPOSE
-    if (windowIsOpenGL(w)) // a bit incorrect since the is-opengl status may change from false to true at any time later on
-        style |= WS_CLIPSIBLINGS | WS_CLIPCHILDREN; // see SetPixelFormat
-#else
     style |= WS_CLIPSIBLINGS | WS_CLIPCHILDREN ;
-#endif
+
     if (topLevel) {
         if ((type == Qt::Window || dialog || tool)) {
             if (!(flags & Qt::FramelessWindowHint)) {
-                style |= WS_POPUP;
                 if (flags & Qt::MSWindowsFixedSizeDialogHint) {
                     style |= WS_DLGFRAME;
                 } else {
@@ -834,13 +828,15 @@ void WindowCreationData::fromWindow(const QWindow *w, const Qt::WindowFlags flag
             if ((flags & Qt::WindowContextHelpButtonHint) && !showMinimizeButton
                 && !showMaximizeButton)
                 exStyle |= WS_EX_CONTEXTHELP;
+            if (qEnvironmentVariableIntValue("QT_WINDOWS_DISABLE_BITMAP_REDIRECTION"))
+                exStyle |= WS_EX_NOREDIRECTIONBITMAP;
         } else {
              exStyle |= WS_EX_TOOLWINDOW;
         }
 
         // make mouse events fall through this window
         // NOTE: WS_EX_TRANSPARENT flag can make mouse inputs fall through a layered window
-        if (flagsIn & Qt::WindowTransparentForInput)
+        if (flags & Qt::WindowTransparentForInput)
             exStyle |= WS_EX_LAYERED | WS_EX_TRANSPARENT;
     }
 }
@@ -1049,9 +1045,12 @@ QMargins QWindowsGeometryHint::frame(const QWindow *w, DWORD style, DWORD exStyl
 {
     if (!w->isTopLevel() || w->flags().testFlag(Qt::FramelessWindowHint))
         return {};
+    if (!QWindowsApi::instance()->pAdjustWindowRectExForDpi)
+        return frameOnPrimaryScreen(w, style, exStyle);
     RECT rect = {0,0,0,0};
     style &= ~DWORD(WS_OVERLAPPED); // Not permitted, see docs.
-    if (AdjustWindowRectExForDpi(&rect, style, FALSE, exStyle, unsigned(qRound(dpi))) == FALSE) {
+    if (QWindowsApi::instance()->pAdjustWindowRectExForDpi(
+            &rect, style, FALSE, exStyle, unsigned(qRound(dpi))) == FALSE) {
         qErrnoWarning("%s: AdjustWindowRectExForDpi failed", __FUNCTION__);
     }
     const QMargins result(qAbs(rect.left), qAbs(rect.top),
@@ -1091,7 +1090,8 @@ QMargins QWindowsGeometryHint::frame(const QWindow *w, const QRect &geometry,
 {
     if (!w->isTopLevel() || w->flags().testFlag(Qt::FramelessWindowHint))
         return {};
-    if (QWindowsScreenManager::isSingleScreen()
+    if (!QWindowsApi::instance()->pAdjustWindowRectExForDpi
+        || QWindowsScreenManager::isSingleScreen()
         || !QWindowsContext::shouldHaveNonClientDpiScaling(w)) {
         return frameOnPrimaryScreen(w, style, exStyle);
     }
@@ -1542,7 +1542,7 @@ void QWindowsWindow::initialize()
             QWindowSystemInterface::handleGeometryChange<QWindowSystemInterface::SynchronousDelivery>(w, obtainedGeometry);
         }
     }
-    QWindowsWindow::setSavedDpi(GetDpiForWindow(handle()));
+    QWindowsWindow::setSavedDpi(QWindowsContext::getMostPossibleDpiForWindow(handle()));
 }
 
 QSurfaceFormat QWindowsWindow::format() const
@@ -2008,7 +2008,7 @@ void QWindowsWindow::handleDpiChanged(HWND hwnd, WPARAM wParam, LPARAM lParam)
 
 void QWindowsWindow::handleDpiChangedAfterParent(HWND hwnd)
 {
-    const UINT dpi = GetDpiForWindow(hwnd);
+    const UINT dpi = QWindowsContext::getMostPossibleDpiForWindow(hwnd);
     const qreal scale = qreal(dpi) / qreal(savedDpi());
     setSavedDpi(dpi);
 
@@ -2328,13 +2328,22 @@ bool QWindowsWindow::handleWmPaint(HWND hwnd, UINT message,
         return false;
     PAINTSTRUCT ps;
 
-    // GL software rendering (QTBUG-58178) with some AMD cards
+    // GL software rendering (QTBUG-58178) and Windows 7/Aero off with some AMD cards
     // (QTBUG-60527) need InvalidateRect() to suppress artifacts while resizing.
-    if (testFlag(OpenGLSurface) && isSoftwareGl())
+    if (testFlag(OpenGLSurface) && (isSoftwareGl() || !dwmIsCompositionEnabled()))
         InvalidateRect(hwnd, nullptr, false);
 
     BeginPaint(hwnd, &ps);
 
+    // Observed painting problems with Aero style disabled (QTBUG-7865).
+    if (Q_UNLIKELY(!dwmIsCompositionEnabled())
+        && ((testFlag(OpenGLSurface) && testFlag(OpenGLDoubleBuffered))
+            || testFlag(VulkanSurface)
+            || testFlag(Direct3DSurface)))
+    {
+        SelectClipRgn(ps.hdc, nullptr);
+    }
+
     // If the a window is obscured by another window (such as a child window)
     // we still need to send isExposed=true, for compatibility.
     // Our tests depend on it.
@@ -2467,11 +2476,7 @@ void QWindowsWindow::setWindowState_sys(Qt::WindowStates newState)
 
     if (stateChange & Qt::WindowFullScreen) {
         if (newState & Qt::WindowFullScreen) {
-#ifndef Q_FLATTEN_EXPOSE
             UINT newStyle = WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_POPUP;
-#else
-            UINT newStyle = WS_POPUP;
-#endif
             // Save geometry and style to be restored when fullscreen
             // is turned off again, since on Windows, it is not a real
             // Window state but emulated by changing geometry and style.
@@ -2926,7 +2931,7 @@ void QWindowsWindow::getSizeHints(MINMAXINFO *mmi) const
             mmi->ptMaxPosition.x = availablePositionDiff.x();
             mmi->ptMaxPosition.y = availablePositionDiff.y();
             if (!m_data.flags.testFlag(Qt::FramelessWindowHint)) {
-                const int borderWidth = invisibleMargins(m_data.hwnd).left();
+                const int borderWidth = QWindowsContext::getResizeBorderThickness(m_data.hwnd);
                 mmi->ptMaxSize.x += borderWidth * 2;
                 mmi->ptMaxSize.y += borderWidth * 2;
                 mmi->ptMaxTrackSize = mmi->ptMaxSize;
@@ -2967,7 +2972,7 @@ bool QWindowsWindow::handleNonClientHitTest(const QPoint &globalPos, LRESULT *re
             return true;
         }
         if (localPos.y() < 0) {
-            const int topResizeBarPos = invisibleMargins(m_data.hwnd).left() - frameMargins().top();
+            const int topResizeBarPos = QWindowsContext::getResizeBorderThickness(m_data.hwnd) - frameMargins().top();
             if (localPos.y() < topResizeBarPos) {
                 *result = HTCAPTION; // Extend caption over top resize bar, let's user move the window.
                 return true;
diff --git a/src/plugins/platforms/windows/uiautomation/qwindowsuiaaccessibility.cpp b/src/plugins/platforms/windows/uiautomation/qwindowsuiaaccessibility.cpp
index 001cb8505b..3b8ecef292 100644
--- a/src/plugins/platforms/windows/uiautomation/qwindowsuiaaccessibility.cpp
+++ b/src/plugins/platforms/windows/uiautomation/qwindowsuiaaccessibility.cpp
@@ -14,7 +14,6 @@
 #include <QtGui/private/qguiapplication_p.h>
 #include <QtCore/qt_windows.h>
 #include <qpa/qplatformintegration.h>
-#include <QtGui/private/qwindowsuiawrapper_p.h>
 
 #include <QtCore/private/qwinregistry_p.h>
 
@@ -46,7 +45,7 @@ bool QWindowsUiaAccessibility::handleWmGetObject(HWND hwnd, WPARAM wParam, LPARA
     if (QWindow *window = QWindowsContext::instance()->findWindow(hwnd)) {
         if (QAccessibleInterface *accessible = window->accessibleRoot()) {
             QWindowsUiaMainProvider *provider = QWindowsUiaMainProvider::providerForAccessible(accessible);
-            *lResult = QWindowsUiaWrapper::instance()->returnRawElementProvider(hwnd, wParam, lParam, provider);
+            *lResult = UiaReturnRawElementProvider(hwnd, wParam, lParam, provider);
             return true;
         }
     }
@@ -120,12 +119,8 @@ void QWindowsUiaAccessibility::notifyAccessibilityUpdate(QAccessibleEvent *event
     if (!isActive() || !accessible || !accessible->isValid())
         return;
 
-    // Ensures QWindowsUiaWrapper is properly initialized.
-    if (!QWindowsUiaWrapper::instance()->ready())
-        return;
-
     // No need to do anything when nobody is listening.
-    if (!QWindowsUiaWrapper::instance()->clientsAreListening())
+    if (!UiaClientsAreListening())
         return;
 
     switch (event->type()) {
diff --git a/src/plugins/platforms/windows/uiautomation/qwindowsuiabaseprovider.h b/src/plugins/platforms/windows/uiautomation/qwindowsuiabaseprovider.h
index c899b4096e..2bc549f548 100644
--- a/src/plugins/platforms/windows/uiautomation/qwindowsuiabaseprovider.h
+++ b/src/plugins/platforms/windows/uiautomation/qwindowsuiabaseprovider.h
@@ -11,7 +11,9 @@
 #include <QtCore/qpointer.h>
 
 #include <qwindowscombase.h>
-#include <QtGui/private/qwindowsuiawrapper_p.h>
+#include <uiautomationcore.h>
+#include <uiautomationcoreapi.h>
+#include <uiautomationclient.h>
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/plugins/platforms/windows/uiautomation/qwindowsuiamainprovider.cpp b/src/plugins/platforms/windows/uiautomation/qwindowsuiamainprovider.cpp
index cb35ed398c..d7bcf147b9 100644
--- a/src/plugins/platforms/windows/uiautomation/qwindowsuiamainprovider.cpp
+++ b/src/plugins/platforms/windows/uiautomation/qwindowsuiamainprovider.cpp
@@ -24,6 +24,8 @@
 #include "qwindowsuiaprovidercache.h"
 
 #include <QtCore/qloggingcategory.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 #include <QtGui/qaccessible.h>
 #include <QtGui/qguiapplication.h>
 #include <QtGui/qwindow.h>
@@ -36,6 +38,8 @@
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 using namespace QWindowsUiAutomation;
 
 
@@ -77,7 +81,7 @@ void QWindowsUiaMainProvider::notifyFocusChange(QAccessibleEvent *event)
                 accessible = child;
         }
         if (QWindowsUiaMainProvider *provider = providerForAccessible(accessible))
-            QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_AutomationFocusChangedEventId);
+            UiaRaiseAutomationEvent(provider, UIA_AutomationFocusChangedEventId);
     }
 }
 
@@ -94,7 +98,7 @@ void QWindowsUiaMainProvider::notifyStateChange(QAccessibleStateChangeEvent *eve
                     if (accessible->state().checked)
                         toggleState = accessible->state().checkStateMixed ? ToggleState_Indeterminate : ToggleState_On;
                     setVariantI4(toggleState, &newVal);
-                    QWindowsUiaWrapper::instance()->raiseAutomationPropertyChangedEvent(provider, UIA_ToggleToggleStatePropertyId, oldVal, newVal);
+                    UiaRaiseAutomationPropertyChangedEvent(provider, UIA_ToggleToggleStatePropertyId, oldVal, newVal);
                 }
             }
         }
@@ -103,13 +107,13 @@ void QWindowsUiaMainProvider::notifyStateChange(QAccessibleStateChangeEvent *eve
                 // Notifies window opened/closed.
                 if (QWindowsUiaMainProvider *provider = providerForAccessible(accessible)) {
                     if (accessible->state().active) {
-                        QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Window_WindowOpenedEventId);
+                        UiaRaiseAutomationEvent(provider, UIA_Window_WindowOpenedEventId);
                         if (QAccessibleInterface *focused = accessible->focusChild()) {
                             if (QWindowsUiaMainProvider *focusedProvider = providerForAccessible(focused))
-                                QWindowsUiaWrapper::instance()->raiseAutomationEvent(focusedProvider, UIA_AutomationFocusChangedEventId);
+                                UiaRaiseAutomationEvent(focusedProvider, UIA_AutomationFocusChangedEventId);
                         }
                     } else {
-                        QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Window_WindowClosedEventId);
+                        UiaRaiseAutomationEvent(provider, UIA_Window_WindowClosedEventId);
                     }
                 }
             }
@@ -142,21 +146,30 @@ void QWindowsUiaMainProvider::notifyValueChange(QAccessibleValueChangeEvent *eve
                 // Tries to notify the change using UiaRaiseNotificationEvent(), which is only available on
                 // Windows 10 version 1709 or newer. Otherwise uses UiaRaiseAutomationPropertyChangedEvent().
 
-                BSTR displayString = bStrFromQString(event->value().toString());
-                BSTR activityId = bStrFromQString(QString());
+                auto hr = HRESULT(UIA_E_NOTSUPPORTED);
+
+                if (QOperatingSystemVersion::isWin10RS3OrGreater()) {
+                    static const auto pUiaRaiseNotificationEvent =
+                        reinterpret_cast<decltype(&::UiaRaiseNotificationEvent)>(
+                            QSystemLibrary::resolve(u"uiautomationcore"_s, "UiaRaiseNotificationEvent"));
+                    if (pUiaRaiseNotificationEvent) {
+                        BSTR displayString = bStrFromQString(event->value().toString());
+                        BSTR activityId = bStrFromQString(QString());
 
-                HRESULT hr = QWindowsUiaWrapper::instance()->raiseNotificationEvent(provider, NotificationKind_Other,
-                                                                                    NotificationProcessing_ImportantMostRecent,
-                                                                                    displayString, activityId);
+                        hr = pUiaRaiseNotificationEvent(provider, NotificationKind_Other,
+                                                        NotificationProcessing_ImportantMostRecent,
+                                                        displayString, activityId);
 
-                ::SysFreeString(displayString);
-                ::SysFreeString(activityId);
+                        ::SysFreeString(displayString);
+                        ::SysFreeString(activityId);
+                    }
+                }
 
                 if (hr == static_cast<HRESULT>(UIA_E_NOTSUPPORTED)) {
                     VARIANT oldVal, newVal;
                     clearVariant(&oldVal);
                     setVariantString(event->value().toString(), &newVal);
-                    QWindowsUiaWrapper::instance()->raiseAutomationPropertyChangedEvent(provider, UIA_ValueValuePropertyId, oldVal, newVal);
+                    UiaRaiseAutomationPropertyChangedEvent(provider, UIA_ValueValuePropertyId, oldVal, newVal);
                     ::SysFreeString(newVal.bstrVal);
                 }
             }
@@ -166,7 +179,7 @@ void QWindowsUiaMainProvider::notifyValueChange(QAccessibleValueChangeEvent *eve
                 VARIANT oldVal, newVal;
                 clearVariant(&oldVal);
                 setVariantDouble(valueInterface->currentValue().toDouble(), &newVal);
-                QWindowsUiaWrapper::instance()->raiseAutomationPropertyChangedEvent(provider, UIA_RangeValueValuePropertyId, oldVal, newVal);
+                UiaRaiseAutomationPropertyChangedEvent(provider, UIA_RangeValueValuePropertyId, oldVal, newVal);
             }
         }
     }
@@ -182,7 +195,7 @@ void QWindowsUiaMainProvider::notifyNameChange(QAccessibleEvent *event)
                 VARIANT oldVal, newVal;
                 clearVariant(&oldVal);
                 setVariantString(accessible->text(QAccessible::Name), &newVal);
-                QWindowsUiaWrapper::instance()->raiseAutomationPropertyChangedEvent(provider, UIA_NamePropertyId, oldVal, newVal);
+                UiaRaiseAutomationPropertyChangedEvent(provider, UIA_NamePropertyId, oldVal, newVal);
                 ::SysFreeString(newVal.bstrVal);
             }
         }
@@ -193,7 +206,7 @@ void QWindowsUiaMainProvider::notifySelectionChange(QAccessibleEvent *event)
 {
     if (QAccessibleInterface *accessible = event->accessibleInterface()) {
         if (QWindowsUiaMainProvider *provider = providerForAccessible(accessible)) {
-            QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_SelectionItem_ElementSelectedEventId);
+            UiaRaiseAutomationEvent(provider, UIA_SelectionItem_ElementSelectedEventId);
         }
     }
 }
@@ -205,13 +218,13 @@ void QWindowsUiaMainProvider::notifyTextChange(QAccessibleEvent *event)
         if (accessible->textInterface()) {
             if (QWindowsUiaMainProvider *provider = providerForAccessible(accessible)) {
                 if (event->type() == QAccessible::TextSelectionChanged) {
-                    QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Text_TextSelectionChangedEventId);
+                    UiaRaiseAutomationEvent(provider, UIA_Text_TextSelectionChangedEventId);
                 } else if (event->type() == QAccessible::TextCaretMoved) {
                     if (!accessible->state().readOnly) {
-                        QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Text_TextSelectionChangedEventId);
+                        UiaRaiseAutomationEvent(provider, UIA_Text_TextSelectionChangedEventId);
                     }
                 } else {
-                    QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Text_TextChangedEventId);
+                    UiaRaiseAutomationEvent(provider, UIA_Text_TextChangedEventId);
                 }
             }
         }
@@ -514,7 +527,7 @@ HRESULT QWindowsUiaMainProvider::get_HostRawElementProvider(IRawElementProviderS
     // Returns a host provider only for controls associated with a native window handle. Others should return NULL.
     if (QAccessibleInterface *accessible = accessibleInterface()) {
         if (HWND hwnd = hwndForAccessible(accessible)) {
-            return QWindowsUiaWrapper::instance()->hostProviderFromHwnd(hwnd, pRetVal);
+            return UiaHostProviderFromHwnd(hwnd, pRetVal);
         }
     }
     return S_OK;
diff --git a/src/plugins/platforms/windows/uiautomation/qwindowsuiautils.h b/src/plugins/platforms/windows/uiautomation/qwindowsuiautils.h
index 8fe8b1c6d7..07367efe01 100644
--- a/src/plugins/platforms/windows/uiautomation/qwindowsuiautils.h
+++ b/src/plugins/platforms/windows/uiautomation/qwindowsuiautils.h
@@ -12,7 +12,7 @@
 #include <QtGui/qaccessible.h>
 #include <QtGui/qwindow.h>
 #include <QtCore/qrect.h>
-#include <QtGui/private/qwindowsuiawrapper_p.h>
+#include "qwindowsuiabaseprovider.h"
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp b/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp
index 969e53b8e1..4530de2d2a 100644
--- a/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp
+++ b/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp
@@ -3954,6 +3954,21 @@ void QWindowsVistaStyle::drawComplexControl(ComplexControl control, const QStyle
                     theme.partId = flags & State_Horizontal ? SBP_THUMBBTNHORZ : SBP_THUMBBTNVERT;
                     theme.stateId = stateId;
                     d->drawBackground(theme);
+
+                    if (!QOperatingSystemVersion::isWin8OrGreater()) {
+                        const QRect gripperBounds = QWindowsVistaStylePrivate::scrollBarGripperBounds(flags, widget, &theme);
+                        // Draw gripper if there is enough space
+                        if (!gripperBounds.isEmpty() && flags & State_Enabled) {
+                            painter->save();
+                            QWindowsThemeData grippBackground = theme;
+                            grippBackground.partId = flags & State_Horizontal ? SBP_LOWERTRACKHORZ : SBP_LOWERTRACKVERT;
+                            theme.rect = gripperBounds;
+                            painter->setClipRegion(d->region(theme));// Only change inside the region of the gripper
+                            d->drawBackground(grippBackground);// The gutter is the grippers background
+                            d->drawBackground(theme);          // Transparent gripper ontop of background
+                            painter->restore();
+                        }
+                    }
                 }
             }
         }
@@ -5009,4 +5024,20 @@ QIcon QWindowsVistaStyle::standardIcon(StandardPixmap standardIcon,
     return QWindowsStyle::standardIcon(standardIcon, option, widget);
 }
 
+QRect QWindowsVistaStylePrivate::scrollBarGripperBounds(QStyle::State flags, const QWidget *widget, QWindowsThemeData *theme)
+{
+    const bool horizontal = flags & QStyle::State_Horizontal;
+    const qreal factor = QWindowsStylePrivate::nativeMetricScaleFactor(widget);
+    const QMargins contentsMargin =
+        (theme->margins(theme->rect, TMT_SIZINGMARGINS) * factor).toMargins();
+    theme->partId = horizontal ? SBP_GRIPPERHORZ : SBP_GRIPPERVERT;
+    const QSize size = (theme->size() * factor).toSize();
+
+    const int hSpace = theme->rect.width() - size.width();
+    const int vSpace = theme->rect.height() - size.height();
+    const bool sufficientSpace = (horizontal && hSpace > (contentsMargin.left() + contentsMargin.right()))
+        || vSpace > contentsMargin.top() + contentsMargin.bottom();
+    return sufficientSpace ? QRect(theme->rect.topLeft() + QPoint(hSpace, vSpace) / 2, size) : QRect();
+}
+
 QT_END_NAMESPACE
diff --git a/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h b/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h
index 2c38ff4b3b..7705d3200e 100644
--- a/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h
+++ b/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h
@@ -120,6 +120,7 @@ public:
     static int pixelMetricFromSystemDp(QStyle::PixelMetric pm, const QStyleOption *option = nullptr, const QWidget *widget = nullptr);
     static int fixedPixelMetric(QStyle::PixelMetric pm);
     static bool isLineEditBaseColorSet(const QStyleOption *option, const QWidget *widget);
+    static QRect scrollBarGripperBounds(QStyle::State flags, const QWidget *widget, QWindowsThemeData *theme);
     static HWND winId(const QWidget *widget);
     static bool useVista(bool update = false);
     static QBackingStore *backingStoreForWidget(const QWidget *widget);
diff --git a/src/tools/rcc/main.cpp b/src/tools/rcc/main.cpp
index 2751bc39d6..8e44999f52 100644
--- a/src/tools/rcc/main.cpp
+++ b/src/tools/rcc/main.cpp
@@ -34,9 +34,7 @@ void dumpRecursive(const QDir &dir, QTextStream &out)
         if (entry.isDir()) {
             dumpRecursive(entry.filePath(), out);
         } else {
-            out << "<file>"_L1
-                << entry.filePath()
-                << "</file>\n"_L1;
+            out << "  <file>"_L1 << entry.filePath() << "</file>\n"_L1;
         }
     }
 }
@@ -64,7 +62,8 @@ int createProject(const QString &outFileName)
     }
 
     QTextStream out(&file);
-    out << "<!DOCTYPE RCC><RCC version=\"1.0\">\n"
+    out << "<!DOCTYPE RCC>\n"
+           "<RCC version=\"1.0\">\n"
            "<qresource>\n"_L1;
 
     // use "." as dir to get relative file paths
diff --git a/src/tools/rcc/rcc.cpp b/src/tools/rcc/rcc.cpp
index a87f15de33..51933952a5 100644
--- a/src/tools/rcc/rcc.cpp
+++ b/src/tools/rcc/rcc.cpp
@@ -1097,7 +1097,7 @@ bool RCCResourceLibrary::writeDataBlobs()
     Q_ASSERT(m_errorDevice);
     switch (m_format) {
     case C_Code:
-        writeString("static const unsigned char qt_resource_data[] = {\n");
+        writeString("static constexpr const unsigned char qt_resource_data[] = {\n");
         break;
     case Python_Code:
         writeString("qt_resource_data = b\"\\\n");
@@ -1141,7 +1141,7 @@ bool RCCResourceLibrary::writeDataBlobs()
     case Pass1:
         if (offset < 8)
             offset = 8;
-        writeString("\nstatic const unsigned char qt_resource_data[");
+        writeString("\nstatic constexpr const unsigned char qt_resource_data[");
         writeByteArray(QByteArray::number(offset));
         writeString("] = { 'Q', 'R', 'C', '_', 'D', 'A', 'T', 'A' };\n\n");
         break;
@@ -1156,7 +1156,7 @@ bool RCCResourceLibrary::writeDataNames()
     switch (m_format) {
     case C_Code:
     case Pass1:
-        writeString("static const unsigned char qt_resource_name[] = {\n");
+        writeString("static constexpr const unsigned char qt_resource_name[] = {\n");
         break;
     case Python_Code:
         writeString("qt_resource_name = b\"\\\n");
@@ -1218,7 +1218,7 @@ bool RCCResourceLibrary::writeDataStructure()
     switch (m_format) {
     case C_Code:
     case Pass1:
-        writeString("static const unsigned char qt_resource_struct[] = {\n");
+        writeString("static constexpr const unsigned char qt_resource_struct[] = {\n");
         break;
     case Python_Code:
         writeString("qt_resource_struct = b\"\\\n");
diff --git a/src/widgets/dialogs/qwizard_win.cpp b/src/widgets/dialogs/qwizard_win.cpp
index e95f0e3b7b..9c79b56a67 100644
--- a/src/widgets/dialogs/qwizard_win.cpp
+++ b/src/widgets/dialogs/qwizard_win.cpp
@@ -152,7 +152,10 @@ void QVistaHelper::updateCustomMargins(bool vistaMargins)
 
 bool QVistaHelper::isCompositionEnabled()
 {
-    return true;
+    if (QOperatingSystemVersion::isWin8OrGreater())
+        return true;
+    BOOL enabled = FALSE;
+    return SUCCEEDED(DwmIsCompositionEnabled(&enabled)) && enabled != FALSE;
 }
 
 bool QVistaHelper::isThemeActive()
@@ -663,7 +666,9 @@ int QVistaHelper::topOffset(const QPaintDevice *device)
 {
     if (vistaState() != VistaAero)
         return titleBarSize() + 3;
-    static const int aeroOffset = QStyleHelper::dpiScaled(13, device);
+    static const int aeroOffset =
+        QOperatingSystemVersion::isWin8OrGreater() ?
+        QStyleHelper::dpiScaled(13, device) : QStyleHelper::dpiScaled(4, device);
     return aeroOffset + titleBarSize();
 }
 
-- 
2.38.1.windows.1

