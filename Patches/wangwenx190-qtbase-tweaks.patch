From 6f1e6289b0dee11f29caf18fca9cbb95cd98def1 Mon Sep 17 00:00:00 2001
From: Yuhang Zhao <2546789017@qq.com>
Date: Fri, 17 Jun 2022 20:33:03 +0800
Subject: [PATCH] wangwenx190: Custom tweaks

Important changes list:

01. Win32: Remove WS_POPUP for most cases.
02. Win32: Remove UI Automation wrapper layer.
03. Win32: Disable the Direct2D QPA, it's useless and has bad performance.
04. Disable the offscreen QPA, it's useless.
05. Disable the minimal QPA, it's useless.
06. Win32: Add more entries to QOperatingSystemVersion.
07. Win32: Add environment variable to add offset to the system menu.
08. Win32: Add environment variable to disable bitmap redirection.
09. Win32: Restore Windows 7 compatibility (QtMutex & QtRhi & QPA).
10. MSVC: Add support for VC-LTL.
11. MSVC: Add support for YY-Thunks (can help Qt support Windows Vista RTM).
12. Other minor tweaks.

Signed-off-by: Yuhang Zhao <2546789017@qq.com>
---
 build-test.bat                                |  16 +
 cmake/QtBaseGlobalTargets.cmake               |   2 +
 cmake/QtBuild.cmake                           |   9 +
 cmake/QtCompilerOptimization.cmake            |  15 +-
 cmake/QtInternalTargets.cmake                 |  56 +-
 cmake/VC-LTL.cmake                            |  94 +++
 cmake/YY-Thunks.cmake                         |  90 +++
 configure.cmake                               |  10 +
 qt_cmdline.cmake                              |   2 +
 src/corelib/CMakeLists.txt                    |  10 +-
 src/corelib/global/qlibraryinfo.cpp           |  20 +-
 src/corelib/global/qlibraryinfo.h             |   5 +
 .../global/qoperatingsystemversion.cpp        |  10 +
 src/corelib/global/qoperatingsystemversion.h  |  40 ++
 .../global/qoperatingsystemversion_win.cpp    |  20 +-
 src/corelib/global/qsysinfo.cpp               |  34 +-
 src/corelib/io/qfilesystemengine_win.cpp      | 108 ++--
 src/corelib/io/qfilesystemiterator_win.cpp    |   6 +-
 src/corelib/io/qlockfile_win.cpp              |  14 +-
 src/corelib/io/qstandardpaths_win.cpp         |   4 +
 src/corelib/kernel/qcoreapplication.cpp       |  39 ++
 src/corelib/kernel/qeventdispatcher_win.cpp   |  12 +-
 src/corelib/kernel/qfunctions_win.cpp         |  10 +-
 src/corelib/plugin/qsystemlibrary.cpp         |  46 +-
 src/corelib/text/qlocale_win.cpp              |  23 +-
 src/corelib/thread/qfutex_p.h                 |  76 ++-
 src/corelib/thread/qlocking_p.h               |   7 +-
 src/corelib/thread/qmutex.cpp                 |   2 +
 src/corelib/thread/qmutex_p.h                 |   9 +-
 src/corelib/thread/qmutex_win.cpp             |  30 +
 src/corelib/thread/qwaitcondition_p.h         |   7 +-
 src/gui/CMakeLists.txt                        |  30 -
 src/gui/opengl/qopengl.cpp                    |  32 +-
 src/gui/rhi/qrhid3d11.cpp                     | 538 +++++++++++-------
 src/gui/rhi/qrhid3d11_p_p.h                   |   3 +-
 src/gui/rhi/qrhid3d12.cpp                     | 143 +++--
 .../qwindowsdirectwritefontdatabase.cpp       |   6 +-
 src/gui/text/windows/qwindowsfontdatabase.cpp |   3 +-
 .../text/windows/qwindowsfontdatabasebase.cpp |  21 +-
 .../windows/qwindowsfontenginedirectwrite.cpp |   9 +-
 .../socket/qnativesocketengine_win.cpp        |  21 +-
 .../qnetworklistmanagerevents.cpp             |  54 +-
 src/plugins/platforms/CMakeLists.txt          |   9 -
 src/plugins/platforms/windows/CMakeLists.txt  |   6 +-
 .../platforms/windows/qwin10helpers.cpp       |  43 +-
 .../platforms/windows/qwindowsapplication.cpp |  12 +-
 .../platforms/windows/qwindowscontext.cpp     | 283 ++++++++-
 .../platforms/windows/qwindowscontext.h       | 130 +++++
 .../platforms/windows/qwindowsdrag.cpp        |   7 +-
 .../platforms/windows/qwindowsintegration.cpp |  12 +-
 .../platforms/windows/qwindowskeymapper.cpp   |  18 +-
 .../windows/qwindowsmousehandler.cpp          |   9 +-
 .../windows/qwindowsopengltester.cpp          |   6 +-
 .../windows/qwindowspointerhandler.cpp        |  25 +-
 .../platforms/windows/qwindowsscreen.cpp      |  71 +--
 .../windows/qwindowssystemtrayicon.cpp        |   8 +-
 .../platforms/windows/qwindowstheme.cpp       | 135 +++--
 .../platforms/windows/qwindowswindow.cpp      | 151 +++--
 .../uiautomation/qwindowsuiaaccessibility.cpp |   9 +-
 .../uiautomation/qwindowsuiabaseprovider.h    |   4 +-
 .../uiautomation/qwindowsuiamainprovider.cpp  |  53 +-
 .../windows/uiautomation/qwindowsuiautils.h   |   2 +-
 .../windowsvista/qwindowsvistastyle.cpp       |  31 +
 .../windowsvista/qwindowsvistastyle_p_p.h     |   1 +
 src/tools/rcc/main.cpp                        |   7 +-
 src/tools/rcc/rcc.cpp                         |   8 +-
 src/widgets/CMakeLists.txt                    |   1 -
 src/widgets/dialogs/qwizard.cpp               |  72 ++-
 src/widgets/dialogs/qwizard_win.cpp           | 287 ++++++----
 src/widgets/dialogs/qwizard_win_p.h           |  10 +-
 70 files changed, 2286 insertions(+), 810 deletions(-)
 create mode 100644 build-test.bat
 create mode 100644 cmake/VC-LTL.cmake
 create mode 100644 cmake/YY-Thunks.cmake
 create mode 100644 src/corelib/thread/qmutex_win.cpp

diff --git a/build-test.bat b/build-test.bat
new file mode 100644
index 0000000000..fac6bf0c14
--- /dev/null
+++ b/build-test.bat
@@ -0,0 +1,16 @@
+@echo on
+setlocal
+call "%ProgramFiles%\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvars64.bat"
+cd /d "%~dp0"
+if exist build-test rd /s /q build-test
+md build-test
+cd build-test
+md cmake
+cd cmake
+cmake -Wno-dev -DCMAKE_MESSAGE_LOG_LEVEL=STATUS -DCMAKE_INSTALL_PREFIX="%~dp0build-test\install" -DCMAKE_CONFIGURATION_TYPES=Release;Debug -DCMAKE_INTERPROCEDURAL_OPTIMIZATION_RELEASE=ON -DBUILD_SHARED_LIBS=ON -DQT_BUILD_TESTS=OFF -DQT_BUILD_EXAMPLES=OFF -DFEATURE_relocatable=ON -DFEATURE_system_zlib=OFF -DINPUT_intelcet=yes -DINPUT_spectre=yes -DINPUT_ehcont=yes -G"Ninja Multi-Config" "%~dp0"
+cmake --build . --parallel
+ninja install
+endlocal
+cd /d "%~dp0"
+pause
+exit /b 0
diff --git a/cmake/QtBaseGlobalTargets.cmake b/cmake/QtBaseGlobalTargets.cmake
index 6a885fc4ce..286cbfe720 100644
--- a/cmake/QtBaseGlobalTargets.cmake
+++ b/cmake/QtBaseGlobalTargets.cmake
@@ -287,6 +287,8 @@ qt_copy_or_install(FILES
                    cmake/QtWasmHelpers.cmake
                    cmake/QtWrapperScriptHelpers.cmake
                    cmake/QtWriteArgsFile.cmake
+                   cmake/VC-LTL.cmake
+                   cmake/YY-Thunks.cmake
                    cmake/modulecppexports.h.in
                    cmake/modulecppexports_p.h.in
                    cmake/qbatchedtestrunner.in.cpp
diff --git a/cmake/QtBuild.cmake b/cmake/QtBuild.cmake
index 6bf4a9edd5..a570b053bf 100644
--- a/cmake/QtBuild.cmake
+++ b/cmake/QtBuild.cmake
@@ -573,3 +573,12 @@ _qt_internal_find_host_info_package("${__qt_build_requires_host_info_package}")
 if(CMAKE_VERSION VERSION_LESS "3.19.0")
     variable_watch(CMAKE_CURRENT_LIST_DIR qt_watch_current_list_dir)
 endif()
+
+if(MSVC)
+    include(VC-LTL)
+    if("x${SupportLTL}" STREQUAL "xtrue")
+        set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>" CACHE STRING "" FORCE)
+    endif()
+    set(YYTHUNKS_TARGET_OS "WinXP" CACHE STRING "" FORCE)
+    include(YY-Thunks)
+endif()
diff --git a/cmake/QtCompilerOptimization.cmake b/cmake/QtCompilerOptimization.cmake
index b5b49ab78a..2a756b229b 100644
--- a/cmake/QtCompilerOptimization.cmake
+++ b/cmake/QtCompilerOptimization.cmake
@@ -92,10 +92,15 @@ endif()
 
 # Windows MSVC
 if(MSVC)
-    set(QT_CFLAGS_OPTIMIZE "-O2")
-    set(QT_CFLAGS_OPTIMIZE_DEBUG "-Od")
-    set(QT_CFLAGS_OPTIMIZE_SIZE "-O1")
-    set(QT_CFLAGS_OPTIMIZE_VALID_VALUES "/O2" "/O1" "/Od" "/Ob0" "/Ob1" "/Ob2" "/O0" "-O0")
+    set(QT_CFLAGS_OPTIMIZE "-O2 -Oi -Oy -Ot")
+    if(MSVC_VERSION GREATER_EQUAL 1920) # Visual Studio 2019 version 16.0
+        string(APPEND QT_CFLAGS_OPTIMIZE " -Ob3 ")
+    else()
+        string(APPEND QT_CFLAGS_OPTIMIZE " -Ob2 ")
+    endif()
+    set(QT_CFLAGS_OPTIMIZE_DEBUG "-Od -Ob0")
+    set(QT_CFLAGS_OPTIMIZE_SIZE "-O1 -Ob2 -Oi- -Os")
+    set(QT_CFLAGS_OPTIMIZE_VALID_VALUES "/O2" "/O1" "/Od" "/Ob0" "/Ob1" "/Ob2" "/Ob3" "/O0" "-O0")
 
     if(CLANG)
         set(QT_CFLAGS_OPTIMIZE_FULL "/clang:-O3")
@@ -124,5 +129,5 @@ endif()
 # Emscripten Clang
 if(WASM)
     set(QT_CFLAGS_OPTIMIZE_DEBUG "-O2 -g") # -Og is not supported
-    set(QT_CFLAGS_SSE2 -O2 -msimd128 -msse -msse2)
+    set(QT_CFLAGS_SSE2 "-O2 -msimd128 -msse -msse2")
 endif()
diff --git a/cmake/QtInternalTargets.cmake b/cmake/QtInternalTargets.cmake
index 21730457d8..b3fd1da097 100644
--- a/cmake/QtInternalTargets.cmake
+++ b/cmake/QtInternalTargets.cmake
@@ -255,6 +255,11 @@ if (MSVC)
             #-Zc:preprocessor # breaks build due to bug in default Windows SDK 10.0.19041
         )
     endif()
+    if (MSVC_VERSION GREATER_EQUAL 1925 AND NOT CLANG) # Visual Studio 2019 version 16.5
+        target_compile_options(PlatformCommonInternal INTERFACE
+            $<$<NOT:$<CONFIG:Debug>>:-QIntel-jcc-erratum>
+        )
+    endif()
 
     target_compile_options(PlatformCommonInternal INTERFACE
         -Zc:wchar_t
@@ -262,13 +267,19 @@ if (MSVC)
     )
 
     target_compile_options(PlatformCommonInternal INTERFACE
-        $<$<NOT:$<CONFIG:Debug>>:-guard:cf -Gw>
+        $<$<NOT:$<CONFIG:Debug>>:-fp:fast -guard:cf -GF -GT -Gw -Gy> # -GA for executables.
     )
 
     target_link_options(PlatformCommonInternal INTERFACE
         -DYNAMICBASE -NXCOMPAT -LARGEADDRESSAWARE
-        $<$<NOT:$<CONFIG:Debug>>:-OPT:REF -OPT:ICF -GUARD:CF>
+        $<$<NOT:$<CONFIG:Debug>>:-OPT:REF -OPT:ICF -OPT:LBR -GUARD:CF>
     )
+
+    if(TEST_architecture_arch STREQUAL "x86_64")
+        target_link_options(PlatformCommonInternal INTERFACE
+            -HIGHENTROPYVA
+        )
+    endif()
 endif()
 
 if(MINGW)
@@ -281,16 +292,49 @@ endif()
 
 if(QT_FEATURE_intelcet)
     if(MSVC)
-        target_link_options(PlatformCommonInternal INTERFACE
-            -CETCOMPAT
-        )
+        if(MSVC_VERSION GREATER_EQUAL 1920) # Visual Studio 2019 version 16.0
+            target_link_options(PlatformCommonInternal INTERFACE
+                $<$<NOT:$<CONFIG:Debug>>:-CETCOMPAT>
+            )
+        endif()
     else()
         target_compile_options(PlatformCommonInternal INTERFACE
-            -fcf-protection=full
+            $<$<NOT:$<CONFIG:Debug>>:-fcf-protection=full>
         )
     endif()
 endif()
 
+if(QT_FEATURE_spectre)
+    if(MSVC)
+        if(MSVC_VERSION GREATER_EQUAL 1925) # Visual Studio 2019 version 16.5
+            target_compile_options(PlatformCommonInternal INTERFACE
+                -Qspectre-load
+            )
+        elseif(MSVC_VERSION GREATER_EQUAL 1912) # Visual Studio 2017 version 15.5
+            target_compile_options(PlatformCommonInternal INTERFACE
+                -Qspectre
+            )
+        endif()
+    else()
+        # TODO
+    endif()
+endif()
+
+if(QT_FEATURE_ehcont)
+    if(MSVC)
+        if(MSVC_VERSION GREATER_EQUAL 1927) # Visual Studio 2019 version 16.7
+            target_compile_options(PlatformCommonInternal INTERFACE
+                $<$<NOT:$<CONFIG:Debug>>:-guard:ehcont>
+            )
+            target_compile_options(PlatformCommonInternal INTERFACE
+                $<$<NOT:$<CONFIG:Debug>>:-guard:ehcont>
+            )
+        endif()
+    else()
+        # TODO
+    endif()
+endif()
+
 if(QT_FEATURE_force_asserts)
     target_compile_definitions(PlatformCommonInternal INTERFACE QT_FORCE_ASSERTS)
 endif()
diff --git a/cmake/VC-LTL.cmake b/cmake/VC-LTL.cmake
new file mode 100644
index 0000000000..2bab2f21d6
--- /dev/null
+++ b/cmake/VC-LTL.cmake
@@ -0,0 +1,94 @@
+﻿# https://github.com/Chuyu-Team/VC-LTL5
+
+#
+#  VC-LTL自动化加载配置，建议你将此文件单独复制到你的工程再使用，该文件能自动识别当前环境是否存在VC-LTL，并且自动应用。
+#
+#  使用方法：
+#    1. 在“CMakeLists.txt” 添加 “include("VC-LTL helper for cmake.cmake")”。
+#
+#  VC-LTL默认搜索顺序
+#    1. “VC-LTL helper for cmake.cmake”所在根目录，即 ${CMAKE_CURRENT_LIST_DIR}
+#    2. 当前CMake根目录，即 ${CMAKE_CURRENT_SOURCE_DIR}/VC-LTL
+#    3. 当前项目根目录，即 ${PROJECT_SOURCE_DIR}/VC-LTL
+#    4. 当前CMake父目录，即 ${CMAKE_CURRENT_SOURCE_DIR}/../VC-LTL
+#    5. 当前项目根目录，即 ${PROJECT_SOURCE_DIR}/../VC-LTL
+#    6. 注册表HKEY_CURRENT_USER\Code\VC-LTL@Root
+#
+#  把VC-LTL放在其中一个位置即可，VC-LTL就能被自动引用。
+#
+#  如果你对默认搜索顺序不满，你可以修改此文件。你也可以直接指定${VC_LTL_Root}宏更加任性的去加载VC-LTL。
+#
+
+if(NOT MSVC OR DEFINED __VC_LTL_CMAKE_INCLUDE_GUARD)
+    return()
+endif()
+set(__VC_LTL_CMAKE_INCLUDE_GUARD 1)
+
+#####################################################################VC-LTL设置#####################################################################
+
+#控制TargetPlatform版本，目前可用版本为5.1.2600.0     6.0.6000.0（默认）    6.2.9200.0     10.0.10240.0    10.0.19041.0
+if(NOT DEFINED WindowsTargetPlatformMinVersion)
+    set(WindowsTargetPlatformMinVersion "10.0.19041.0" CACHE STRING "" FORCE)
+endif()
+
+#启用干净的导入表，消除 ucrt apiset(如：api-ms-win-crt-time-l1-1-0.dll)，满足强迫症患者。
+if(NOT DEFINED CleanImport)
+    set(CleanImport "true" CACHE STRING "" FORCE)
+endif()
+
+####################################################################################################################################################
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${CMAKE_CURRENT_LIST_DIR}/_msvcrt.h)
+		set(VC_LTL_Root ${CMAKE_CURRENT_LIST_DIR})
+	endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/VC-LTL/_msvcrt.h)
+		set(VC_LTL_Root ${CMAKE_CURRENT_SOURCE_DIR}/VC-LTL)
+	endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${PROJECT_SOURCE_DIR}/VC-LTL/_msvcrt.h)
+        set(VC_LTL_Root ${PROJECT_SOURCE_DIR}/VC-LTL)
+    endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/../VC-LTL/_msvcrt.h)
+        set(VC_LTL_Root ${CMAKE_CURRENT_SOURCE_DIR}/../VC-LTL)
+    endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${PROJECT_SOURCE_DIR}/../VC-LTL/_msvcrt.h)
+        set(VC_LTL_Root ${PROJECT_SOURCE_DIR}/../VC-LTL)
+    endif()
+endif()
+
+if(NOT VC_LTL_Root)
+    EXECUTE_PROCESS(COMMAND reg query "HKEY_CURRENT_USER\\Code\\VC-LTL" -v "Root"
+                    OUTPUT_VARIABLE FOUND_FILE
+                    ERROR_VARIABLE ERROR_INFO
+                   )
+
+    string(REGEX MATCH "[a-zA-Z]:\\\\.+\\\\"
+           FOUND_LTL
+           ${FOUND_FILE})
+    if (NOT ${FOUND_LTL} STREQUAL "")
+        set(VC_LTL_Root ${FOUND_LTL})
+    endif()
+
+    if(NOT DEFINED VC_LTL_Root)
+        string(REGEX MATCH "\\\\\\\\.+\\\\" FOUND_LTL ${FOUND_FILE})
+        if (NOT ${FOUND_LTL} STREQUAL "")
+            set(VC_LTL_Root ${FOUND_LTL})
+        endif()
+    endif()
+endif()
+
+if(VC_LTL_Root)
+    include("${VC_LTL_Root}\\config\\config.cmake")
+endif()
diff --git a/cmake/YY-Thunks.cmake b/cmake/YY-Thunks.cmake
new file mode 100644
index 0000000000..92532d72dc
--- /dev/null
+++ b/cmake/YY-Thunks.cmake
@@ -0,0 +1,90 @@
+#[[
+  MIT License
+
+  Copyright (C) 2023 by wangwenx190 (Yuhang Zhao)
+
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+  SOFTWARE.
+]]
+
+# https://github.com/Chuyu-Team/YY-Thunks
+
+if(NOT MSVC OR DEFINED __YY_THUNKS_CMAKE_INCLUDE_GUARD)
+    return()
+endif()
+set(__YY_THUNKS_CMAKE_INCLUDE_GUARD 1)
+
+if(NOT DEFINED YYTHUNKS_TARGET_OS)
+    set(YYTHUNKS_TARGET_OS "Vista" CACHE STRING "Supported values: Vista, WinXP" FORCE)
+endif()
+
+set(__yy_thunks_dir)
+if(DEFINED ENV{YYTHUNKS_INSTALL_DIR} AND EXISTS "$ENV{YYTHUNKS_INSTALL_DIR}")
+    set(__yy_thunks_dir "$ENV{YYTHUNKS_INSTALL_DIR}")
+else()
+    set(__yy_thunks_reg)
+    cmake_host_system_information(RESULT __yy_thunks_reg
+        QUERY WINDOWS_REGISTRY "HKCU/Code/YY-Thunks"
+        VALUE "Root")
+    if(__yy_thunks_reg AND EXISTS "${__yy_thunks_reg}")
+        set(__yy_thunks_dir "${__yy_thunks_reg}")
+    elseif(EXISTS "${CMAKE_CURRENT_LIST_DIR}/YY-Thunks")
+        set(__yy_thunks_dir "${CMAKE_CURRENT_LIST_DIR}/YY-Thunks")
+    elseif(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/YY-Thunks")
+        set(__yy_thunks_dir "${CMAKE_CURRENT_SOURCE_DIR}/YY-Thunks")
+    elseif(EXISTS "${PROJECT_SOURCE_DIR}/YY-Thunks")
+        set(__yy_thunks_dir "${PROJECT_SOURCE_DIR}/YY-Thunks")
+    elseif(EXISTS "${CMAKE_SOURCE_DIR}/YY-Thunks")
+        set(__yy_thunks_dir "${CMAKE_SOURCE_DIR}/YY-Thunks")
+    elseif(EXISTS "${CMAKE_SOURCE_DIR}/../YY-Thunks")
+        set(__yy_thunks_dir "${CMAKE_SOURCE_DIR}/../YY-Thunks")
+    endif()
+endif()
+
+if(__yy_thunks_dir AND EXISTS "${__yy_thunks_dir}")
+    if(CMAKE_SIZEOF_VOID_P EQUAL 8)
+        set(__yy_thunks_arch x64)
+    else()
+        set(__yy_thunks_arch x86)
+    endif()
+    set(__yy_thunks_obj "${__yy_thunks_dir}/objs/${__yy_thunks_arch}/YY_Thunks_for_${YYTHUNKS_TARGET_OS}.obj")
+    if(EXISTS "${__yy_thunks_obj}")
+        set(YYTHUNKS_FOUND TRUE CACHE BOOL "" FORCE)
+        set(YYTHUNKS_INSTALL_DIR "${__yy_thunks_dir}" CACHE STRING "" FORCE)
+        set(YYTHUNKS_OBJ_PATH "${__yy_thunks_obj}" CACHE STRING "" FORCE)
+        add_link_options("${__yy_thunks_obj}")
+        message("###################################################################################################")
+        message("#                                                                                                 #")
+        message("#           ██    ██ ██    ██       ████████ ██   ██ ██    ██ ███    ██ ██   ██ ███████           #")
+        message("#            ██  ██   ██  ██           ██    ██   ██ ██    ██ ████   ██ ██  ██  ██                #")
+        message("#             ████     ████   █████    ██    ███████ ██    ██ ██ ██  ██ █████   ███████           #")
+        message("#              ██       ██             ██    ██   ██ ██    ██ ██  ██ ██ ██  ██       ██           #")
+        message("#              ██       ██             ██    ██   ██  ██████  ██   ████ ██   ██ ███████           #")
+        message("#                                                                                                 #")
+        message("###################################################################################################")
+        message("")
+        message(" YY-Thunks install dir     :" ${__yy_thunks_dir})
+        message(" YY-Thunks target platform :" ${YYTHUNKS_TARGET_OS})
+        message(" YY-Thunks obj file path   :" ${__yy_thunks_obj})
+        message("")
+    else()
+        message(WARNING "YY-Thunks's obj file is missing!")
+    endif()
+else()
+    message(WARNING "Can't locate the YY-Thunks installation directory!")
+endif()
diff --git a/configure.cmake b/configure.cmake
index 4b3e6ff6d4..2695cc7dec 100644
--- a/configure.cmake
+++ b/configure.cmake
@@ -1125,6 +1125,14 @@ qt_feature("intelcet" PRIVATE
     LABEL "Using Intel CET"
     CONDITION ( INPUT_intelcet STREQUAL yes ) OR TEST_intelcet
 )
+qt_feature("spectre" PRIVATE
+    LABEL "Mitigate Spectre issues"
+    CONDITION INPUT_spectre STREQUAL yes
+)
+qt_feature("ehcont" PRIVATE
+    LABEL "Ehcont guard"
+    CONDITION INPUT_ehcont STREQUAL yes
+)
 qt_configure_add_summary_build_type_and_config()
 qt_configure_add_summary_section(NAME "Build options")
 qt_configure_add_summary_build_mode(Mode)
@@ -1175,6 +1183,8 @@ qt_configure_add_summary_entry(ARGS "relocatable")
 qt_configure_add_summary_entry(ARGS "precompile_header")
 qt_configure_add_summary_entry(ARGS "ltcg")
 qt_configure_add_summary_entry(ARGS "intelcet")
+qt_configure_add_summary_entry(ARGS "spectre")
+qt_configure_add_summary_entry(ARGS "ehcont")
 qt_configure_add_summary_entry(
     ARGS "wasm-simd128"
     CONDITION ( TEST_architecture_arch STREQUAL wasm )
diff --git a/qt_cmdline.cmake b/qt_cmdline.cmake
index 5450b2562c..0bfc75636b 100644
--- a/qt_cmdline.cmake
+++ b/qt_cmdline.cmake
@@ -74,6 +74,8 @@ qt_commandline_option(openssl-runtime TYPE void NAME openssl VALUE runtime)
 qt_commandline_option(linker TYPE optionalString VALUES bfd gold lld mold)
 qt_commandline_option(ltcg TYPE boolean)
 qt_commandline_option(intelcet TYPE boolean)
+qt_commandline_option(spectre TYPE boolean)
+qt_commandline_option(ehcont TYPE boolean)
 # special case begin
 qt_commandline_option(make TYPE addString VALUES examples libs tests tools
                       benchmarks manual-tests minimal-static-tests)
diff --git a/src/corelib/CMakeLists.txt b/src/corelib/CMakeLists.txt
index f9dd14e4ff..af744508a3 100644
--- a/src/corelib/CMakeLists.txt
+++ b/src/corelib/CMakeLists.txt
@@ -487,9 +487,8 @@ qt_internal_extend_target(Core CONDITION QT_FEATURE_animation
 # from the wrong DLL at runtime and crash!
 qt_internal_extend_target(Core CONDITION QT_FEATURE_thread AND WIN32
     SOURCES
+        thread/qmutex_win.cpp
         thread/qwaitcondition_win.cpp
-    LIBRARIES
-        synchronization
 )
 
 qt_internal_extend_target(Core CONDITION WIN32
@@ -756,12 +755,6 @@ qt_internal_extend_target(Core CONDITION WIN32
         text/qlocale_win.cpp
 )
 
-# On MS-Win, clang has two flavors, one of which immitates MSVC (so claims to be it)
-qt_internal_extend_target(Core CONDITION WIN32 AND MSVC AND NOT CLANG
-    LIBRARIES
-        runtimeobject
-)
-
 qt_internal_extend_target(Core CONDITION QT_FEATURE_icu
     SOURCES
         text/qcollator_icu.cpp
@@ -1282,6 +1275,7 @@ qt_internal_extend_target(Core CONDITION QT_FEATURE_ctf AND QT_FEATURE_library
 set_source_files_properties(
     thread/qmutex_mac.cpp
     thread/qmutex_unix.cpp
+    thread/qmutex_win.cpp
     PROPERTIES HEADER_FILE_ONLY ON)  # special case: These files are included by qmutex.cpp!
 
 set_source_files_properties(serialization/qcborstreamwriter.cpp # CBOR macro clashes
diff --git a/src/corelib/global/qlibraryinfo.cpp b/src/corelib/global/qlibraryinfo.cpp
index 715bda488c..6973de9d76 100644
--- a/src/corelib/global/qlibraryinfo.cpp
+++ b/src/corelib/global/qlibraryinfo.cpp
@@ -296,8 +296,13 @@ static QString prefixFromQtCoreLibraryHelper(const QString &qtCoreLibraryPath)
 {
     const QString qtCoreLibrary = QDir::fromNativeSeparators(qtCoreLibraryPath);
     const QString libDir = QFileInfo(qtCoreLibrary).absolutePath();
-    const QString prefixDir = libDir + "/" QT_CONFIGURE_LIBLOCATION_TO_PREFIX_PATH;
-    return QDir::cleanPath(prefixDir);
+    const QString prefix = libDir + "/";
+    return QDir::cleanPath([&prefix]() -> QString {
+        if (qEnvironmentVariableIntValue("QT_FORCE_LOAD_PLUGINS_FROM_CORE_DIR")) {
+            return prefix;
+        }
+        return prefix + QT_CONFIGURE_LIBLOCATION_TO_PREFIX_PATH;
+    }());
 }
 #endif
 
@@ -686,6 +691,17 @@ const char *qVersion() noexcept
     return QT_VERSION_STR;
 }
 
+/*!
+    A special function to identify this custom Qt build.
+    It will always return the magic number "2546789017"
+    as the result. It's my QQ number and you can contact
+    me by sending me an e-mail to "2546789017@qq.com".
+*/
+quint64 __wangwenx190__() noexcept
+{
+    return 2546789017;
+}
+
 #if QT_DEPRECATED_SINCE(6, 9)
 
 bool qSharedBuild() noexcept
diff --git a/src/corelib/global/qlibraryinfo.h b/src/corelib/global/qlibraryinfo.h
index d4e8f8b050..6cd0b448cf 100644
--- a/src/corelib/global/qlibraryinfo.h
+++ b/src/corelib/global/qlibraryinfo.h
@@ -61,6 +61,11 @@ Q_CORE_EXPORT Q_DECL_CONST_FUNCTION bool qSharedBuild() noexcept;
 
 #endif
 
+#if (!defined(QT_NAMESPACE) && defined(__cplusplus))
+extern "C"
+#endif
+Q_CORE_EXPORT Q_DECL_CONST_FUNCTION quint64 __wangwenx190__(void) noexcept;
+
 QT_END_NAMESPACE
 
 #endif // QLIBRARYINFO_H
diff --git a/src/corelib/global/qoperatingsystemversion.cpp b/src/corelib/global/qoperatingsystemversion.cpp
index b9da31149e..49f30720bd 100644
--- a/src/corelib/global/qoperatingsystemversion.cpp
+++ b/src/corelib/global/qoperatingsystemversion.cpp
@@ -361,6 +361,9 @@ bool QOperatingSystemVersionBase::isAnyOfType(std::initializer_list<OSType> type
 
 #ifndef QT_BOOTSTRAPPED
 
+const QOperatingSystemVersion QOperatingSystemVersion::WindowsVista =
+    QOperatingSystemVersion(QOperatingSystemVersion::Windows, 6, 0);
+
 /*!
     \variable QOperatingSystemVersion::Windows7
     \brief a version corresponding to Windows 7 (version 6.1).
@@ -393,6 +396,13 @@ const QOperatingSystemVersion QOperatingSystemVersion::Windows8_1 =
 const QOperatingSystemVersion QOperatingSystemVersion::Windows10 =
     QOperatingSystemVersion(QOperatingSystemVersion::Windows, 10);
 
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1507;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1511;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1607;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1703;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1709;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1803;
+
 /*!
     \variable QOperatingSystemVersion::Windows10_1809
     \brief a version corresponding to Windows 10 October 2018 Update
diff --git a/src/corelib/global/qoperatingsystemversion.h b/src/corelib/global/qoperatingsystemversion.h
index 1e4eb5cc49..499a196fa7 100644
--- a/src/corelib/global/qoperatingsystemversion.h
+++ b/src/corelib/global/qoperatingsystemversion.h
@@ -123,6 +123,7 @@ public:
     // until Qt7
     // @note: New entries should be added after the if-def-ery until Qt 7!!
 #if QT_VERSION < QT_VERSION_CHECK(7, 0, 0) && !defined(QT_BOOTSTRAPPED)
+    static const QOperatingSystemVersion WindowsVista;
     static const QOperatingSystemVersion Windows7;
     static const QOperatingSystemVersion Windows8;
     static const QOperatingSystemVersion Windows8_1;
@@ -153,6 +154,7 @@ public:
     static const QOperatingSystemVersion Android10;
     static const QOperatingSystemVersion Android11;
 #else
+    static constexpr QOperatingSystemVersionBase WindowsVista { QOperatingSystemVersionBase::Windows, 6, 0 };
     static constexpr QOperatingSystemVersionBase Windows7 { QOperatingSystemVersionBase::Windows, 6, 1 };
     static constexpr QOperatingSystemVersionBase Windows8 { QOperatingSystemVersionBase::Windows, 6, 2 };
     static constexpr QOperatingSystemVersionBase Windows8_1 { QOperatingSystemVersionBase::Windows, 6, 3 };
@@ -188,6 +190,12 @@ public:
     static constexpr QOperatingSystemVersionBase Android11 { QOperatingSystemVersionBase::Android, 11, 0 };
 #endif // New (static constexpr) entries go here, only cherry-pick as far back as 6.3 (QTBUG-97808):
 
+    static constexpr QOperatingSystemVersionBase Windows10_1507 { QOperatingSystemVersionBase::Windows, 10, 0, 10240 }; // TH1
+    static constexpr QOperatingSystemVersionBase Windows10_1511 { QOperatingSystemVersionBase::Windows, 10, 0, 10586 }; // TH2
+    static constexpr QOperatingSystemVersionBase Windows10_1607 { QOperatingSystemVersionBase::Windows, 10, 0, 14393 }; // RS1
+    static constexpr QOperatingSystemVersionBase Windows10_1703 { QOperatingSystemVersionBase::Windows, 10, 0, 15063 }; // RS2
+    static constexpr QOperatingSystemVersionBase Windows10_1709 { QOperatingSystemVersionBase::Windows, 10, 0, 16299 }; // RS3
+    static constexpr QOperatingSystemVersionBase Windows10_1803 { QOperatingSystemVersionBase::Windows, 10, 0, 17134 }; // RS4
     static constexpr QOperatingSystemVersionBase Windows10_1809 { QOperatingSystemVersionBase::Windows, 10, 0, 17763 }; // RS5
     static constexpr QOperatingSystemVersionBase Windows10_1903 { QOperatingSystemVersionBase::Windows, 10, 0, 18362 }; // 19H1
     static constexpr QOperatingSystemVersionBase Windows10_1909 { QOperatingSystemVersionBase::Windows, 10, 0, 18363 }; // 19H2
@@ -206,6 +214,38 @@ public:
 
     static constexpr QOperatingSystemVersionBase MacOSVentura { QOperatingSystemVersionBase::MacOS, 13, 0 };
 
+#ifdef Q_OS_WINDOWS
+#  define MAKE_VERSION_FUNCTION(Name, Version) \
+    [[nodiscard]] static inline bool isWin##Name##OrGreater() \
+    { \
+        static const bool result = QOperatingSystemVersion::current() >= QOperatingSystemVersion::Windows##Version; \
+        return result; \
+    }
+    MAKE_VERSION_FUNCTION(Vista, Vista)
+    MAKE_VERSION_FUNCTION(7, 7)
+    MAKE_VERSION_FUNCTION(8, 8)
+    MAKE_VERSION_FUNCTION(8Point1, 8_1)
+    MAKE_VERSION_FUNCTION(10, 10)
+    MAKE_VERSION_FUNCTION(10TH1, 10_1507)
+    MAKE_VERSION_FUNCTION(10TH2, 10_1511)
+    MAKE_VERSION_FUNCTION(10RS1, 10_1607)
+    MAKE_VERSION_FUNCTION(10RS2, 10_1703)
+    MAKE_VERSION_FUNCTION(10RS3, 10_1709)
+    MAKE_VERSION_FUNCTION(10RS4, 10_1803)
+    MAKE_VERSION_FUNCTION(10RS5, 10_1809)
+    MAKE_VERSION_FUNCTION(1019H1, 10_1903)
+    MAKE_VERSION_FUNCTION(1019H2, 10_1909)
+    MAKE_VERSION_FUNCTION(1020H1, 10_2004)
+    MAKE_VERSION_FUNCTION(1020H2, 10_20H2)
+    MAKE_VERSION_FUNCTION(1021H1, 10_21H1)
+    MAKE_VERSION_FUNCTION(1021H2, 10_21H2)
+    MAKE_VERSION_FUNCTION(1022H2, 10_22H2)
+    MAKE_VERSION_FUNCTION(11, 11)
+    MAKE_VERSION_FUNCTION(1121H2, 11_21H2)
+    MAKE_VERSION_FUNCTION(1122H2, 11_22H2)
+#  undef MAKE_VERSION_FUNCTION
+#endif // Q_OS_WINDOWS
+
     constexpr QOperatingSystemVersion(const QOperatingSystemVersionBase &osversion)
         : QOperatingSystemVersionBase(osversion) {}
 
diff --git a/src/corelib/global/qoperatingsystemversion_win.cpp b/src/corelib/global/qoperatingsystemversion_win.cpp
index a209fb17b6..50edb719fd 100644
--- a/src/corelib/global/qoperatingsystemversion_win.cpp
+++ b/src/corelib/global/qoperatingsystemversion_win.cpp
@@ -51,7 +51,18 @@ OSVERSIONINFOEX qWindowsVersionInfo()
             result.wServicePackMinor = 0;
 
             const QByteArray winVerOverride = qgetenv("QT_WINVER_OVERRIDE");
-            if (winVerOverride == "WINDOWS10" || winVerOverride == "2016"
+            if (winVerOverride == "WINDOWSVISTA" || winVerOverride == "2008") {
+                result.dwMajorVersion = 6;
+            } else if (winVerOverride == "WINDOWS7" || winVerOverride == "2008_R2") {
+                result.dwMajorVersion = 6;
+                result.dwMinorVersion = 1;
+            } else if (winVerOverride == "WINDOWS8" || winVerOverride == "2012") {
+                result.dwMajorVersion = 6;
+                result.dwMinorVersion = 2;
+            } else if (winVerOverride == "WINDOWS8_1" || winVerOverride == "2012_R2") {
+                result.dwMajorVersion = 6;
+                result.dwMinorVersion = 3;
+            } else if (winVerOverride == "WINDOWS10" || winVerOverride == "2016"
                 || winVerOverride == "2019" || winVerOverride == "2022") {
                 result.dwMajorVersion = 10;
             } else if (winVerOverride == "WINDOWS11") {
@@ -61,7 +72,12 @@ OSVERSIONINFOEX qWindowsVersionInfo()
                 return realResult;
             }
 
-            if (winVerOverride == "2016" || winVerOverride == "2019"
+            if (winVerOverride == "2008"
+                || winVerOverride == "2008_R2"
+                || winVerOverride == "2012"
+                || winVerOverride == "2012_R2"
+                || winVerOverride == "2016"
+                || winVerOverride == "2019"
                 || winVerOverride == "2022") {
                 // If the current host OS is a domain controller and the override OS
                 // is also a server type OS, preserve that information
diff --git a/src/corelib/global/qsysinfo.cpp b/src/corelib/global/qsysinfo.cpp
index dace55b6ce..45918ca797 100644
--- a/src/corelib/global/qsysinfo.cpp
+++ b/src/corelib/global/qsysinfo.cpp
@@ -165,12 +165,17 @@ static inline QString windowsDisplayVersion()
 {
     // https://tickets.puppetlabs.com/browse/FACT-3058
     // The "ReleaseId" key stopped updating since Windows 10 20H2.
-    if (QOperatingSystemVersion::current() >= QOperatingSystemVersion::Windows10_20H2)
+    if (QOperatingSystemVersion::isWin1020H2OrGreater())
         return readVersionRegistryString(L"DisplayVersion");
     else
         return readVersionRegistryString(L"ReleaseId");
 }
 
+static QString windows7Build()
+{
+    return readVersionRegistryString(L"CurrentBuild");
+}
+
 static QString winSp_helper()
 {
     const auto osv = qWindowsVersionInfo();
@@ -194,6 +199,14 @@ static const char *osVer_helper(QOperatingSystemVersion version = QOperatingSyst
 
 #define Q_WINVER(major, minor) (major << 8 | minor)
     switch (Q_WINVER(osver.dwMajorVersion, osver.dwMinorVersion)) {
+    case Q_WINVER(6, 0):
+        return workstation ? "Vista" : "Server 2008";
+    case Q_WINVER(6, 1):
+        return workstation ? "7" : "Server 2008 R2";
+    case Q_WINVER(6, 2):
+        return workstation ? "8" : "Server 2012";
+    case Q_WINVER(6, 3):
+        return workstation ? "8.1" : "Server 2012 R2";
     case Q_WINVER(10, 0):
         if (workstation) {
             if (osver.dwBuildNumber >= 22000)
@@ -887,10 +900,21 @@ QString QSysInfo::prettyProductName()
     return result + " ("_L1 + versionString + u')';
 #  else
     // (resembling winver.exe): Windows 10 "Windows 10 Version 1809"
-    const auto displayVersion = windowsDisplayVersion();
-    if (!displayVersion.isEmpty())
-        result += " Version "_L1 + displayVersion;
-    return result;
+    if (majorVersion >= 10) {
+        const auto displayVersion = windowsDisplayVersion();
+        if (!displayVersion.isEmpty())
+            result += " Version "_L1 + displayVersion;
+        return result;
+    }
+    // Windows 7: "Windows 7 Version 6.1 (Build 7601: Service Pack 1)"
+    result += " Version "_L1 + versionString + " ("_L1;
+    const auto build = windows7Build();
+    if (!build.isEmpty())
+        result += "Build "_L1 + build;
+    const auto servicePack = winSp_helper();
+    if (!servicePack.isEmpty())
+        result += ": "_L1 + servicePack;
+    return result + u')';
 #  endif // Windows
 #elif defined(Q_OS_HAIKU)
     return "Haiku "_L1 + productVersion();
diff --git a/src/corelib/io/qfilesystemengine_win.cpp b/src/corelib/io/qfilesystemengine_win.cpp
index fbc55954cb..950b390be1 100644
--- a/src/corelib/io/qfilesystemengine_win.cpp
+++ b/src/corelib/io/qfilesystemengine_win.cpp
@@ -1074,7 +1074,10 @@ QByteArray QFileSystemEngine::id(const QFileSystemEntry &entry)
 //static
 QByteArray QFileSystemEngine::id(HANDLE fHandle)
 {
-    return fileIdWin8(HANDLE(fHandle));
+    if (QOperatingSystemVersion::isWin8OrGreater())
+        return fileIdWin8(HANDLE(fHandle));
+    else
+        return fileId(HANDLE(fHandle));
 }
 
 //static
@@ -1793,41 +1796,76 @@ bool QFileSystemEngine::moveFileToTrash(const QFileSystemEntry &source,
     // we need the "display name" of the file, so can't use nativeAbsoluteFilePath
     const QString sourcePath = QDir::toNativeSeparators(absoluteName(source).filePath());
 
-    QComHelper comHelper;
-
-    IFileOperation *pfo = nullptr;
-    IShellItem *deleteItem = nullptr;
-    FileOperationProgressSink *sink = nullptr;
-    HRESULT hres = E_FAIL;
-
-    auto coUninitialize = qScopeGuard([&](){
-        if (sink)
-            sink->Release();
-        if (deleteItem)
-            deleteItem->Release();
-        if (pfo)
-            pfo->Release();
+    /*
+        Windows 7 insists on showing confirmation dialogs and ignores the respective
+        flags set on IFileOperation. Fall back to SHFileOperation, even if it doesn't
+        give us the new location of the file.
+    */
+    if (QOperatingSystemVersion::isWin8OrGreater()) {
+        QComHelper comHelper;
+
+        IFileOperation *pfo = nullptr;
+        IShellItem *deleteItem = nullptr;
+        FileOperationProgressSink *sink = nullptr;
+        HRESULT hres = E_FAIL;
+
+        auto coUninitialize = qScopeGuard([&](){
+            if (sink)
+                sink->Release();
+            if (deleteItem)
+                deleteItem->Release();
+            if (pfo)
+                pfo->Release();
+            if (!SUCCEEDED(hres))
+                error = QSystemError(hres, QSystemError::NativeError);
+        });
+
+        hres = CoCreateInstance(CLSID_FileOperation, nullptr, CLSCTX_ALL, IID_PPV_ARGS(&pfo));
+        if (!pfo)
+            return false;
+        pfo->SetOperationFlags(FOF_ALLOWUNDO | FOFX_RECYCLEONDELETE | FOF_NOCONFIRMATION
+                            | FOF_SILENT | FOF_NOERRORUI);
+        hres = SHCreateItemFromParsingName(reinterpret_cast<const wchar_t*>(sourcePath.utf16()),
+                                        nullptr, IID_PPV_ARGS(&deleteItem));
+        if (!deleteItem)
+            return false;
+        sink = new FileOperationProgressSink;
+        hres = pfo->DeleteItem(deleteItem, static_cast<IFileOperationProgressSink*>(sink));
         if (!SUCCEEDED(hres))
-            error = QSystemError(hres, QSystemError::NativeError);
-    });
-
-    hres = CoCreateInstance(CLSID_FileOperation, nullptr, CLSCTX_ALL, IID_PPV_ARGS(&pfo));
-    if (!pfo)
-        return false;
-    pfo->SetOperationFlags(FOF_ALLOWUNDO | FOFX_RECYCLEONDELETE | FOF_NOCONFIRMATION
-                        | FOF_SILENT | FOF_NOERRORUI);
-    hres = SHCreateItemFromParsingName(reinterpret_cast<const wchar_t*>(sourcePath.utf16()),
-                                    nullptr, IID_PPV_ARGS(&deleteItem));
-    if (!deleteItem)
-        return false;
-    sink = new FileOperationProgressSink;
-    hres = pfo->DeleteItem(deleteItem, static_cast<IFileOperationProgressSink*>(sink));
-    if (!SUCCEEDED(hres))
-        return false;
-    hres = pfo->PerformOperations();
-    if (!SUCCEEDED(hres))
-        return false;
-    newLocation = QFileSystemEntry(sink->targetPath);
+            return false;
+        hres = pfo->PerformOperations();
+        if (!SUCCEEDED(hres))
+            return false;
+        newLocation = QFileSystemEntry(sink->targetPath);
+    } else {
+        // double null termination needed, so can't use QString::utf16
+        QVarLengthArray<wchar_t, MAX_PATH + 1> winFile(sourcePath.length() + 2);
+        sourcePath.toWCharArray(winFile.data());
+        winFile[sourcePath.length()] = wchar_t{};
+        winFile[sourcePath.length() + 1] = wchar_t{};
+
+        SHFILEOPSTRUCTW operation;
+        operation.hwnd = nullptr;
+        operation.wFunc = FO_DELETE;
+        operation.pFrom = winFile.constData();
+        operation.pTo = nullptr;
+        operation.fFlags = FOF_ALLOWUNDO | FOF_NO_UI;
+        operation.fAnyOperationsAborted = FALSE;
+        operation.hNameMappings = nullptr;
+        operation.lpszProgressTitle = nullptr;
+
+        int result = SHFileOperation(&operation);
+        if (result != 0) {
+            error = QSystemError(result, QSystemError::NativeError);
+            return false;
+        }
+        /*
+            This implementation doesn't let us know where the file ended up, even if
+            we would specify FOF_WANTMAPPINGHANDLE | FOF_RENAMEONCOLLISION, as
+            FOF_RENAMEONCOLLISION has no effect unless files are moved, copied, or renamed.
+        */
+        Q_UNUSED(newLocation);
+    }
 
     return true;
 }
diff --git a/src/corelib/io/qfilesystemiterator_win.cpp b/src/corelib/io/qfilesystemiterator_win.cpp
index 2c16cc7f6b..5be794920c 100644
--- a/src/corelib/io/qfilesystemiterator_win.cpp
+++ b/src/corelib/io/qfilesystemiterator_win.cpp
@@ -55,8 +55,10 @@ bool QFileSystemIterator::advance(QFileSystemEntry &fileEntry, QFileSystemMetaDa
         haveData = true;
         int infoLevel = 0 ;         // FindExInfoStandard;
         DWORD dwAdditionalFlags  = 0;
-        dwAdditionalFlags = 2;  // FIND_FIRST_EX_LARGE_FETCH
-        infoLevel = 1 ;         // FindExInfoBasic;
+        if (QOperatingSystemVersion::isWin7OrGreater()) {
+            dwAdditionalFlags = 2;  // FIND_FIRST_EX_LARGE_FETCH
+            infoLevel = 1 ;         // FindExInfoBasic;
+        }
         int searchOps =  0;         // FindExSearchNameMatch
         if (onlyDirs)
             searchOps = 1 ;         // FindExSearchLimitToDirectories
diff --git a/src/corelib/io/qlockfile_win.cpp b/src/corelib/io/qlockfile_win.cpp
index b9d7721517..33a4291035 100644
--- a/src/corelib/io/qlockfile_win.cpp
+++ b/src/corelib/io/qlockfile_win.cpp
@@ -13,8 +13,12 @@
 #include "QtCore/qdebug.h"
 #include "QtCore/qthread.h"
 
+#include <QtCore/private/qsystemlibrary_p.h>
+
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 static inline bool fileExists(const wchar_t *fileName)
 {
     WIN32_FILE_ATTRIBUTE_DATA  data;
@@ -96,12 +100,16 @@ bool QLockFilePrivate::isProcessRunning(qint64 pid, const QString &appname)
 
 QString QLockFilePrivate::processNameByPid(qint64 pid)
 {
+    static const auto pGetModuleFileNameExW =
+        reinterpret_cast<decltype(&::GetModuleFileNameExW)>(
+            QSystemLibrary::resolve(u"psapi"_s, "GetModuleFileNameExW"));
+    if (!pGetModuleFileNameExW)
+        return QString();
     HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, DWORD(pid));
-    if (!hProcess) {
+    if (!hProcess)
         return QString();
-    }
     wchar_t buf[MAX_PATH];
-    const DWORD length = GetModuleFileNameExW(hProcess, NULL, buf, sizeof(buf) / sizeof(wchar_t));
+    const DWORD length = pGetModuleFileNameExW(hProcess, NULL, buf, sizeof(buf) / sizeof(wchar_t));
     CloseHandle(hProcess);
     if (!length)
         return QString();
diff --git a/src/corelib/io/qstandardpaths_win.cpp b/src/corelib/io/qstandardpaths_win.cpp
index 13b8fe224a..581e2695fe 100644
--- a/src/corelib/io/qstandardpaths_win.cpp
+++ b/src/corelib/io/qstandardpaths_win.cpp
@@ -10,6 +10,7 @@
 #include <qcoreapplication.h>
 #endif
 
+#include <qoperatingsystemversion.h>
 #include <qt_windows.h>
 #include <shlobj.h>
 #include <intshcut.h>
@@ -60,6 +61,9 @@ static inline void appendTestMode(QString &path)
 
 static bool isProcessLowIntegrity()
 {
+    if (!QOperatingSystemVersion::isWin8OrGreater())
+        return false;
+
     // same as GetCurrentProcessToken()
     const auto process_token = HANDLE(quintptr(-4));
 
diff --git a/src/corelib/kernel/qcoreapplication.cpp b/src/corelib/kernel/qcoreapplication.cpp
index 093f01e5c4..22fe706782 100644
--- a/src/corelib/kernel/qcoreapplication.cpp
+++ b/src/corelib/kernel/qcoreapplication.cpp
@@ -36,6 +36,7 @@
 #include <qelapsedtimer.h>
 #include <qlibraryinfo.h>
 #include <qvarlengtharray.h>
+#include <qoperatingsystemversion.h>
 #include <private/qfactoryloader_p.h>
 #include <private/qfunctions_p.h>
 #include <private/qlocale_p.h>
@@ -121,6 +122,10 @@ Q_TRACE_POINT(qtcore, QCoreApplication_sendSpontaneousEvent, QObject *receiver,
 Q_TRACE_POINT(qtcore, QCoreApplication_notify_entry, QObject *receiver, QEvent *event, QEvent::Type type);
 Q_TRACE_POINT(qtcore, QCoreApplication_notify_exit, bool consumed, bool filtered);
 
+#ifndef QT_BOOTSTRAPPED
+static constexpr const char kWwx190EnvVar[] = "__wangwenx190__";
+#endif
+
 #if defined(Q_OS_WIN) || defined(Q_OS_MAC)
 extern QString qAppFileName();
 #endif
@@ -459,6 +464,9 @@ QCoreApplicationPrivate::QCoreApplicationPrivate(int &aargc, char **aargv)
 
 QCoreApplicationPrivate::~QCoreApplicationPrivate()
 {
+#ifndef QT_BOOTSTRAPPED
+    qunsetenv(kWwx190EnvVar);
+#endif
 #ifndef QT_NO_QOBJECT
     cleanupThreadData();
 #endif
@@ -581,6 +589,33 @@ void QCoreApplicationPrivate::initConsole()
         // Unknown input, don't make any decision for the user.
         return;
     }
+    if (qEnvironmentVariableIntValue("QT_WIN_DEBUG_CONSOLE_USE_UTF8")) {
+        SetConsoleCP(CP_UTF8);
+        SetConsoleOutputCP(CP_UTF8);
+    }
+    if (consoleAllocated) {
+        SetConsoleTitleW([]() -> const wchar_t * {
+            const QString appName = QCoreApplication::applicationName();
+            if (appName.isEmpty())
+                return L"Qt debug window";
+            return reinterpret_cast<const wchar_t *>(
+                        (u"%1 debug window"_s.arg(appName)).utf16());
+        }());
+    }
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        const auto enableVirtualTerminalProcessingForHandle =
+            [](const HANDLE handle) -> void {
+                if (!handle || handle == INVALID_HANDLE_VALUE)
+                    return;
+                DWORD mode = 0;
+                if (GetConsoleMode(handle, &mode) == FALSE)
+                    return;
+                mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
+                SetConsoleMode(handle, mode);
+            };
+        enableVirtualTerminalProcessingForHandle(GetStdHandle(STD_OUTPUT_HANDLE));
+        enableVirtualTerminalProcessingForHandle(GetStdHandle(STD_ERROR_HANDLE));
+    }
     // The std{in,out,err} handles are read-only, so we need to pass in dummies.
     FILE *in = nullptr;
     FILE *out = nullptr;
@@ -799,6 +834,10 @@ void Q_TRACE_INSTRUMENT(qtcore) QCoreApplicationPrivate::init()
     Q_ASSERT_X(!QCoreApplication::self, "QCoreApplication", "there should be only one application object");
     QCoreApplication::self = q;
 
+#ifndef QT_BOOTSTRAPPED
+    qputenv(kWwx190EnvVar, QByteArray::number(__wangwenx190__()));
+#endif
+
 #if QT_CONFIG(thread)
 #ifdef Q_OS_WASM
     emscripten::val hardwareConcurrency = emscripten::val::global("navigator")["hardwareConcurrency"];
diff --git a/src/corelib/kernel/qeventdispatcher_win.cpp b/src/corelib/kernel/qeventdispatcher_win.cpp
index 1c54c97514..0da2185811 100644
--- a/src/corelib/kernel/qeventdispatcher_win.cpp
+++ b/src/corelib/kernel/qeventdispatcher_win.cpp
@@ -6,7 +6,6 @@
 
 #include "qcoreapplication.h"
 #include <private/qsystemlibrary_p.h>
-#include "qoperatingsystemversion.h"
 #include "qpair.h"
 #include "qset.h"
 #include "qsocketnotifier.h"
@@ -18,6 +17,8 @@
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 #ifndef TIME_KILL_SYNCHRONOUS
 #  define TIME_KILL_SYNCHRONOUS 0x0100
 #endif
@@ -355,8 +356,13 @@ void QEventDispatcherWin32Private::registerTimer(WinTimerInfo *t)
     }
 
     if (!ok) {
-        // user normal timers for (Very)CoarseTimers, or if no more multimedia timers available
-        ok = SetCoalescableTimer(internalHwnd, t->timerId, interval, nullptr, tolerance);
+        static const auto pSetCoalescableTimer =
+            reinterpret_cast<decltype(&::SetCoalescableTimer)>(
+                QSystemLibrary::resolve(u"user32"_s, "SetCoalescableTimer"));
+        if (pSetCoalescableTimer) {
+            // user normal timers for (Very)CoarseTimers, or if no more multimedia timers available
+            ok = pSetCoalescableTimer(internalHwnd, t->timerId, interval, nullptr, tolerance);
+        }
     }
     if (!ok)
         ok = SetTimer(internalHwnd, t->timerId, interval, nullptr);
diff --git a/src/corelib/kernel/qfunctions_win.cpp b/src/corelib/kernel/qfunctions_win.cpp
index ed0e25467c..2022ff2f24 100644
--- a/src/corelib/kernel/qfunctions_win.cpp
+++ b/src/corelib/kernel/qfunctions_win.cpp
@@ -4,6 +4,7 @@
 #include "qfunctions_win_p.h"
 
 #include <QtCore/qdebug.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 
 #include <combaseapi.h>
 #include <objbase.h>
@@ -15,6 +16,8 @@
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 QComHelper::QComHelper(COINIT concurrencyModel)
 {
     // Avoid overhead of initializing and using obsolete technology
@@ -44,8 +47,13 @@ bool qt_win_hasPackageIdentity()
 {
 #if defined(HAS_APPMODEL)
     static const bool hasPackageIdentity = []() {
+        static const auto pGetCurrentPackageFullName =
+            reinterpret_cast<decltype(&::GetCurrentPackageFullName)>(
+                QSystemLibrary::resolve(u"kernel32"_s, "GetCurrentPackageFullName"));
+        if (!pGetCurrentPackageFullName)
+            return false;
         UINT32 length = 0;
-        switch (const auto result = GetCurrentPackageFullName(&length, nullptr)) {
+        switch (const auto result = pGetCurrentPackageFullName(&length, nullptr)) {
         case ERROR_INSUFFICIENT_BUFFER:
             return true;
         case APPMODEL_ERROR_NO_PACKAGE:
diff --git a/src/corelib/plugin/qsystemlibrary.cpp b/src/corelib/plugin/qsystemlibrary.cpp
index d3dff226d9..44129a432c 100644
--- a/src/corelib/plugin/qsystemlibrary.cpp
+++ b/src/corelib/plugin/qsystemlibrary.cpp
@@ -42,9 +42,9 @@ using namespace Qt::StringLiterals;
 extern QString qAppFileName();
 #endif
 
-static QString qSystemDirectory()
+[[nodiscard]] static inline QString qSystemDirectory()
 {
-    static const QString result = []() -> QString {
+    static const auto result = []() -> QString {
         QVarLengthArray<wchar_t, MAX_PATH> fullPath = {};
         UINT retLen = ::GetSystemDirectoryW(fullPath.data(), MAX_PATH);
         if (retLen > MAX_PATH) {
@@ -52,15 +52,39 @@ static QString qSystemDirectory()
             retLen = ::GetSystemDirectoryW(fullPath.data(), retLen);
         }
         // in some rare cases retLen might be 0
-        return QString::fromWCharArray(fullPath.constData(), int(retLen));
+        QString path = QString::fromWCharArray(fullPath.constData(), int(retLen));
+        // Remove any trailing line separators.
+        while (path.endsWith(u'\\') || path.endsWith(u'/'))
+            path.chop(1);
+        return path;
+    }();
+    return result;
+}
+
+[[nodiscard]] static inline bool isLoadFromSystem32Available()
+{
+    static const auto result = []() -> bool {
+        const QString filePath = qSystemDirectory() + u"\\kernel32.dll"_s;
+        const HMODULE library = ::LoadLibraryW(reinterpret_cast<const wchar_t *>(filePath.utf16()));
+        if (!library)
+            return false;
+        const bool ret = ::GetProcAddress(library, "AddDllDirectory") != nullptr;
+        ::FreeLibrary(library);
+        return ret;
     }();
     return result;
 }
 
 HINSTANCE QSystemLibrary::load(const wchar_t *libraryName, bool onlySystemDirectory /* = true */)
 {
-    if (onlySystemDirectory)
-        return ::LoadLibraryExW(libraryName, nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+    const QString fileName = QString::fromWCharArray(libraryName);
+
+    if (onlySystemDirectory) {
+        if (isLoadFromSystem32Available())
+            return ::LoadLibraryExW(libraryName, nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+        const QString path = qSystemDirectory() + u'\\' + fileName;
+        return ::LoadLibraryW(reinterpret_cast<const wchar_t *>(path.utf16()));
+    }
 
     QStringList searchOrder;
 
@@ -72,17 +96,11 @@ HINSTANCE QSystemLibrary::load(const wchar_t *libraryName, bool onlySystemDirect
     const QString PATH(QLatin1StringView(qgetenv("PATH")));
     searchOrder << PATH.split(u';', Qt::SkipEmptyParts);
 
-    const QString fileName = QString::fromWCharArray(libraryName);
-
     // Start looking in the order specified
-    for (int i = 0; i < searchOrder.count(); ++i) {
+    for (int i = 0; i != searchOrder.count(); ++i) {
         QString fullPathAttempt = searchOrder.at(i);
-        if (!fullPathAttempt.endsWith(u'\\')) {
-            fullPathAttempt.append(u'\\');
-        }
-        fullPathAttempt.append(fileName);
-        HINSTANCE inst = ::LoadLibrary(reinterpret_cast<const wchar_t *>(fullPathAttempt.utf16()));
-        if (inst != nullptr)
+        fullPathAttempt += u'\\' + fileName;
+        if (const HINSTANCE inst = ::LoadLibraryW(reinterpret_cast<const wchar_t *>(fullPathAttempt.utf16())))
             return inst;
     }
     return nullptr;
diff --git a/src/corelib/text/qlocale_win.cpp b/src/corelib/text/qlocale_win.cpp
index 550f7dd464..036b3c2a3f 100644
--- a/src/corelib/text/qlocale_win.cpp
+++ b/src/corelib/text/qlocale_win.cpp
@@ -15,6 +15,7 @@
 #include <q20algorithm.h>
 
 #ifdef Q_OS_WIN
+#   include <qoperatingsystemversion.h>
 #   include <qt_windows.h>
 #   include <time.h>
 #endif
@@ -659,17 +660,19 @@ QVariant QSystemLocalePrivate::uiLanguages()
 {
     QStringList result;
 #if QT_CONFIG(cpp_winrt)
-    using namespace winrt;
-    using namespace Windows::System::UserProfile;
-    QT_TRY {
-        auto languages = GlobalizationPreferences::Languages();
-        for (const auto &lang : languages)
-            result << QString::fromStdString(winrt::to_string(lang));
-    } QT_CATCH(...) {
-        // pass, just fall back to WIN32 API implementation
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        using namespace winrt;
+        using namespace Windows::System::UserProfile;
+        QT_TRY {
+            const auto languages = GlobalizationPreferences::Languages();
+            for (auto &&lang : languages)
+                result << QString::fromStdString(winrt::to_string(lang));
+        } QT_CATCH(...) {
+            // pass, just fall back to WIN32 API implementation
+        }
+        if (!result.isEmpty())
+            return result; // else just fall back to WIN32 API implementation
     }
-    if (!result.isEmpty())
-        return result; // else just fall back to WIN32 API implementation
 #endif // QT_CONFIG(cpp_winrt)
     // mingw and clang still have to use Win32 API
     unsigned long cnt = 0;
diff --git a/src/corelib/thread/qfutex_p.h b/src/corelib/thread/qfutex_p.h
index 48f03f5ed0..fe799c68ca 100644
--- a/src/corelib/thread/qfutex_p.h
+++ b/src/corelib/thread/qfutex_p.h
@@ -17,9 +17,12 @@
 
 #include <private/qglobal_p.h>
 #include <QtCore/qtsan_impl.h>
+#include <QtCore/qstring.h>
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 namespace QtDummyFutex {
     constexpr inline bool futexAvailable() { return false; }
     template <typename Atomic>
@@ -109,35 +112,86 @@ namespace QtFutex = QtLinuxFutex;
 QT_END_NAMESPACE
 
 #elif defined(Q_OS_WIN)
-#  include <qt_windows.h>
+#  include <QtCore/qoperatingsystemversion.h>
+#  include <QtCore/private/qsystemlibrary_p.h>
+#  include <QtCore/qt_windows.h>
 
 QT_BEGIN_NAMESPACE
-namespace QtWindowsFutex {
-#define QT_ALWAYS_USE_FUTEX
-constexpr inline bool futexAvailable() { return true; }
+namespace QtWindowsFutex
+{
+#ifdef QT_ALWAYS_USE_FUTEX
+#  undef QT_ALWAYS_USE_FUTEX
+#endif
+
+inline bool futexAvailable()
+{
+    return QOperatingSystemVersion::isWin8OrGreater();
+}
+
+struct QFutexApi
+{
+    decltype(&::WaitOnAddress) pWaitOnAddress = nullptr;
+    decltype(&::WakeByAddressAll) pWakeByAddressAll = nullptr;
+    decltype(&::WakeByAddressSingle) pWakeByAddressSingle = nullptr;
+
+    static QFutexApi *instance()
+    {
+        static QFutexApi api;
+        return &api;
+    }
+
+private:
+    Q_DISABLE_COPY_MOVE(QFutexApi)
+
+    explicit QFutexApi()
+    {
+        if (!futexAvailable())
+            return;
+        QSystemLibrary library(u"kernelbase"_s);
+        pWaitOnAddress = reinterpret_cast<decltype(pWaitOnAddress)>(library.resolve("WaitOnAddress"));
+        pWakeByAddressAll = reinterpret_cast<decltype(pWakeByAddressAll)>(library.resolve("WakeByAddressAll"));
+        pWakeByAddressSingle = reinterpret_cast<decltype(pWakeByAddressSingle)>(library.resolve("WakeByAddressSingle"));
+    }
+
+    ~QFutexApi() = default;
+};
 
 template <typename Atomic>
 inline void futexWait(Atomic &futex, typename Atomic::Type expectedValue)
 {
+    if (!QFutexApi::instance()->pWaitOnAddress)
+        return;
     QtTsan::futexRelease(&futex);
-    WaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), INFINITE);
+    QFutexApi::instance()->pWaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), INFINITE);
     QtTsan::futexAcquire(&futex);
 }
+
 template <typename Atomic>
 inline bool futexWait(Atomic &futex, typename Atomic::Type expectedValue, qint64 nstimeout)
 {
-    BOOL r = WaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), DWORD(nstimeout / 1000 / 1000));
+    if (!QFutexApi::instance()->pWaitOnAddress)
+        return false;
+    const BOOL r = QFutexApi::instance()->pWaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), DWORD(nstimeout / 1000 / 1000));
     return r || GetLastError() != ERROR_TIMEOUT;
 }
-template <typename Atomic> inline void futexWakeAll(Atomic &futex)
+
+template <typename Atomic>
+inline void futexWakeAll(Atomic &futex)
 {
-    WakeByAddressAll(&futex);
+    if (!QFutexApi::instance()->pWakeByAddressAll)
+        return;
+    QFutexApi::instance()->pWakeByAddressAll(&futex);
 }
-template <typename Atomic> inline void futexWakeOne(Atomic &futex)
+
+template <typename Atomic>
+inline void futexWakeOne(Atomic &futex)
 {
-    WakeByAddressSingle(&futex);
-}
+    if (!QFutexApi::instance()->pWakeByAddressSingle)
+        return;
+    QFutexApi::instance()->pWakeByAddressSingle(&futex);
 }
+} // namespace QtWindowsFutex
+
 namespace QtFutex = QtWindowsFutex;
 QT_END_NAMESPACE
 #else
diff --git a/src/corelib/thread/qlocking_p.h b/src/corelib/thread/qlocking_p.h
index 9fa7e70da9..0c205fff66 100644
--- a/src/corelib/thread/qlocking_p.h
+++ b/src/corelib/thread/qlocking_p.h
@@ -8,9 +8,10 @@
 //  W A R N I N G
 //  -------------
 //
-// This file is not part of the Qt API. It exists for the convenience of
-// qmutex.cpp and qmutex_unix.cpp. This header file may change from version to
-// version without notice, or even be removed.
+// This file is not part of the Qt API.  It exists for the convenience
+// of qmutex.cpp, qmutex_unix.cpp, and qmutex_win.cpp.  This header
+// file may change from version to version without notice, or even be
+// removed.
 //
 // We mean it.
 //
diff --git a/src/corelib/thread/qmutex.cpp b/src/corelib/thread/qmutex.cpp
index 7b4aac9532..ae1a3a7313 100644
--- a/src/corelib/thread/qmutex.cpp
+++ b/src/corelib/thread/qmutex.cpp
@@ -869,6 +869,8 @@ QT_END_NAMESPACE
 // nothing
 #elif defined(Q_OS_MAC)
 #  include "qmutex_mac.cpp"
+#elif defined(Q_OS_WIN)
+#  include "qmutex_win.cpp"
 #else
 #  include "qmutex_unix.cpp"
 #endif
diff --git a/src/corelib/thread/qmutex_p.h b/src/corelib/thread/qmutex_p.h
index 565de31ca0..7c9977599f 100644
--- a/src/corelib/thread/qmutex_p.h
+++ b/src/corelib/thread/qmutex_p.h
@@ -10,9 +10,10 @@
 //  W A R N I N G
 //  -------------
 //
-// This file is not part of the Qt API. It exists for the convenience of
-// qmutex.cpp and qmutex_unix.cpp. This header file may change from version to
-// version without notice, or even be removed.
+// This file is not part of the Qt API.  It exists for the convenience
+// of qmutex.cpp, qmutex_unix.cpp, and qmutex_win.cpp.  This header
+// file may change from version to version without notice, or even be
+// removed.
 //
 // We mean it.
 //
@@ -91,6 +92,8 @@ public:
     bool wakeup;
     pthread_mutex_t mutex;
     pthread_cond_t cond;
+#elif defined(Q_OS_WIN)
+    Qt::HANDLE event;
 #endif
 };
 
diff --git a/src/corelib/thread/qmutex_win.cpp b/src/corelib/thread/qmutex_win.cpp
new file mode 100644
index 0000000000..8c7741c113
--- /dev/null
+++ b/src/corelib/thread/qmutex_win.cpp
@@ -0,0 +1,30 @@
+// Copyright (C) 2016 The Qt Company Ltd.
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
+
+#include "qmutex.h"
+#include <qatomic.h>
+#include "qmutex_p.h"
+#include <qt_windows.h>
+
+QT_BEGIN_NAMESPACE
+
+QMutexPrivate::QMutexPrivate()
+{
+    event = CreateEvent(0, FALSE, FALSE, 0);
+
+    if (!event)
+        qWarning("QMutexPrivate::QMutexPrivate: Cannot create event");
+}
+
+QMutexPrivate::~QMutexPrivate()
+{ CloseHandle(event); }
+
+bool QMutexPrivate::wait(int timeout)
+{
+    return (WaitForSingleObjectEx(event, timeout < 0 ? INFINITE : timeout, FALSE) == WAIT_OBJECT_0);
+}
+
+void QMutexPrivate::wakeUp() noexcept
+{ SetEvent(event); }
+
+QT_END_NAMESPACE
diff --git a/src/corelib/thread/qwaitcondition_p.h b/src/corelib/thread/qwaitcondition_p.h
index cfb36ca30b..01bb000366 100644
--- a/src/corelib/thread/qwaitcondition_p.h
+++ b/src/corelib/thread/qwaitcondition_p.h
@@ -7,9 +7,10 @@
 //  W A R N I N G
 //  -------------
 //
-// This file is not part of the Qt API. It exists for the convenience of
-// qmutex.cpp and qmutex_unix.cpp. This header file may change from version to
-// version without notice, or even be removed.
+// This file is not part of the Qt API.  It exists for the convenience
+// of qmutex.cpp, qmutex_unix.cpp, and qmutex_win.cpp.  This header
+// file may change from version to version without notice, or even be
+// removed.
 //
 // We mean it.
 //
diff --git a/src/gui/CMakeLists.txt b/src/gui/CMakeLists.txt
index 96a1ae4bd5..6a6ac13002 100644
--- a/src/gui/CMakeLists.txt
+++ b/src/gui/CMakeLists.txt
@@ -416,12 +416,6 @@ qt_internal_extend_target(Gui CONDITION WIN32
         ole32
         shell32
         user32
-    PUBLIC_LIBRARIES
-        d3d11
-        dxgi
-        dxguid
-        dcomp
-        d3d12
 )
 
 if(QT_FEATURE_egl)
@@ -457,21 +451,6 @@ qt_internal_extend_target(Gui CONDITION APPLE AND QT_FEATURE_accessibility
         ${FWFoundation}
 )
 
-qt_internal_extend_target(Gui CONDITION QT_FEATURE_accessibility AND WIN32
-    SOURCES
-        accessible/windows/apisupport/qwindowsuiawrapper.cpp accessible/windows/apisupport/qwindowsuiawrapper_p.h
-        accessible/windows/apisupport/uiaattributeids_p.h
-        accessible/windows/apisupport/uiaclientinterfaces_p.h
-        accessible/windows/apisupport/uiacontroltypeids_p.h
-        accessible/windows/apisupport/uiaerrorids_p.h
-        accessible/windows/apisupport/uiaeventids_p.h
-        accessible/windows/apisupport/uiageneralids_p.h
-        accessible/windows/apisupport/uiapatternids_p.h
-        accessible/windows/apisupport/uiapropertyids_p.h
-        accessible/windows/apisupport/uiaserverinterfaces_p.h
-        accessible/windows/apisupport/uiatypes_p.h
-)
-
 if(QT_FEATURE_accessibility AND QT_FEATURE_accessibility_atspi_bridge)
     set(atspi_accessibility ON)
 else()
@@ -717,20 +696,11 @@ qt_internal_extend_target(Gui CONDITION QT_FEATURE_freetype AND WIN32
 qt_internal_extend_target(Gui CONDITION QT_FEATURE_direct2d AND QT_FEATURE_directwrite AND WIN32
     SOURCES
         text/windows/qwindowsfontenginedirectwrite.cpp text/windows/qwindowsfontenginedirectwrite_p.h
-    LIBRARIES
-        d2d1
 )
 
 qt_internal_extend_target(Gui CONDITION QT_FEATURE_direct2d AND QT_FEATURE_directwrite AND QT_FEATURE_directwrite3 AND WIN32
     SOURCES
         text/windows/qwindowsdirectwritefontdatabase.cpp text/windows/qwindowsdirectwritefontdatabase_p.h
-    LIBRARIES
-        dwrite
-)
-
-qt_internal_extend_target(Gui CONDITION QT_FEATURE_direct2d AND QT_FEATURE_directwrite AND WIN32 AND NOT QT_FEATURE_directwrite3
-    LIBRARIES
-        dwrite
 )
 
 qt_internal_extend_target(Gui CONDITION MINGW AND WIN32
diff --git a/src/gui/opengl/qopengl.cpp b/src/gui/opengl/qopengl.cpp
index 7c997103d5..2821915c92 100644
--- a/src/gui/opengl/qopengl.cpp
+++ b/src/gui/opengl/qopengl.cpp
@@ -195,13 +195,35 @@ struct OsTypeTerm
     static QString hostOs();
     static QVersionNumber hostKernelVersion() { return QVersionNumber::fromString(QSysInfo::kernelVersion()); }
     static QString hostOsRelease() {
+        QString ver = {};
 #ifdef Q_OS_WIN
-        if (QOperatingSystemVersion::current() >= QOperatingSystemVersion::Windows11)
-            return u"11"_s;
-        return u"10"_s;
-#else
-        return {};
+        const auto osver = QOperatingSystemVersion::current();
+#define Q_WINVER(major, minor) (major << 8 | minor)
+        switch (Q_WINVER(osver.majorVersion(), osver.minorVersion())) {
+        case Q_WINVER(6, 0):
+            ver = QStringLiteral("Vista");
+            break;
+        case Q_WINVER(6, 1):
+            ver = QStringLiteral("7");
+            break;
+        case Q_WINVER(6, 2):
+            ver = QStringLiteral("8");
+            break;
+        case Q_WINVER(6, 3):
+            ver = QStringLiteral("8.1");
+            break;
+        case Q_WINVER(10, 0):
+            if (osver.microVersion() >= 22000)
+                ver = QStringLiteral("11");
+            else
+                ver = QStringLiteral("10");
+            break;
+        default:
+            break;
+        }
+#undef Q_WINVER
 #endif
+        return ver;
     }
 
     bool isNull() const { return type.isEmpty(); }
diff --git a/src/gui/rhi/qrhid3d11.cpp b/src/gui/rhi/qrhid3d11.cpp
index 8da44eee32..9dbb0b4b11 100644
--- a/src/gui/rhi/qrhid3d11.cpp
+++ b/src/gui/rhi/qrhid3d11.cpp
@@ -9,6 +9,8 @@
 #include <qmath.h>
 #include <private/qsystemlibrary_p.h>
 #include <QtCore/qcryptographichash.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 #include <QtCore/private/qsystemerror_p.h>
 
 #include <d3dcompiler.h>
@@ -96,6 +98,9 @@ using namespace Qt::StringLiterals;
 #define D3D11_VS_INPUT_REGISTER_COUNT 32
 #endif
 
+static constexpr const auto qWKPDID_D3DDebugObjectNameA = GUID{0x429b8c22,0x9188,0x4b0c,{0x87,0x42,0xac,0xb0,0xbf,0x85,0xc2,0x00}};
+static constexpr const auto qWKPDID_D3DDebugObjectNameW = GUID{0x4cca5fd8,0x921f,0x42c8,{0x85,0x66,0x70,0xca,0xf2,0xa9,0xb7,0x41}};
+
 QRhiD3D11::QRhiD3D11(QRhiD3D11InitParams *params, QRhiD3D11NativeHandles *importParams)
     : ofr(this),
       deviceCurse(this)
@@ -109,7 +114,7 @@ QRhiD3D11::QRhiD3D11(QRhiD3D11InitParams *params, QRhiD3D11NativeHandles *import
         if (importParams->dev && importParams->context) {
             dev = reinterpret_cast<ID3D11Device *>(importParams->dev);
             ID3D11DeviceContext *ctx = reinterpret_cast<ID3D11DeviceContext *>(importParams->context);
-            if (SUCCEEDED(ctx->QueryInterface(__uuidof(ID3D11DeviceContext1), reinterpret_cast<void **>(&context)))) {
+            if (SUCCEEDED(ctx->QueryInterface(IID_PPV_ARGS(&context)))) {
                 // get rid of the ref added by QueryInterface
                 ctx->Release();
                 importedDeviceAndContext = true;
@@ -129,112 +134,174 @@ inline Int aligned(Int v, Int byteAlign)
     return (v + byteAlign - 1) & ~(byteAlign - 1);
 }
 
-static IDXGIFactory1 *createDXGIFactory2()
+static bool g_using_dxgi_1_0 = false;
+
+static IDXGIFactory *createDXGIFactory()
+{
+    static const auto pCreateDXGIFactory =
+        reinterpret_cast<decltype(&::CreateDXGIFactory)>(
+            QSystemLibrary::resolve(u"dxgi"_s, "CreateDXGIFactory"));
+    if (!pCreateDXGIFactory)
+        return nullptr;
+    IDXGIFactory *result = nullptr;
+    const HRESULT hr = pCreateDXGIFactory(IID_PPV_ARGS(&result));
+    if (SUCCEEDED(hr))
+        return result;
+    qWarning("CreateDXGIFactory() failed to create DXGI factory: %s",
+        qPrintable(QSystemError::windowsComString(hr)));
+    return nullptr;
+}
+
+static IDXGIFactory1 *createDXGIFactory1()
 {
+    static const auto pCreateDXGIFactory1 =
+        reinterpret_cast<decltype(&::CreateDXGIFactory1)>(
+            QSystemLibrary::resolve(u"dxgi"_s, "CreateDXGIFactory1"));
+    if (!pCreateDXGIFactory1)
+        return nullptr;
     IDXGIFactory1 *result = nullptr;
-    const HRESULT hr = CreateDXGIFactory2(0, __uuidof(IDXGIFactory2), reinterpret_cast<void **>(&result));
-    if (FAILED(hr)) {
-        qWarning("CreateDXGIFactory2() failed to create DXGI factory: %s",
-            qPrintable(QSystemError::windowsComString(hr)));
-        result = nullptr;
-    }
-    return result;
+    const HRESULT hr = pCreateDXGIFactory1(IID_PPV_ARGS(&result));
+    if (SUCCEEDED(hr))
+        return result;
+    qWarning("CreateDXGIFactory1() failed to create DXGI factory: %s",
+        qPrintable(QSystemError::windowsComString(hr)));
+    return nullptr;
 }
 
-bool QRhiD3D11::create(QRhi::Flags flags)
+static IDXGIFactory2 *createDXGIFactory2()
 {
-    rhiFlags = flags;
+    static const auto pCreateDXGIFactory2 =
+        reinterpret_cast<decltype(&::CreateDXGIFactory2)>(
+            QSystemLibrary::resolve(u"dxgi"_s, "CreateDXGIFactory2"));
+    if (!pCreateDXGIFactory2)
+        return nullptr;
+    IDXGIFactory2 *result = nullptr;
+    const HRESULT hr = pCreateDXGIFactory2(0, IID_PPV_ARGS(&result));
+    if (SUCCEEDED(hr))
+        return result;
+    qWarning("CreateDXGIFactory2() failed to create DXGI factory: %s",
+        qPrintable(QSystemError::windowsComString(hr)));
+    return nullptr;
+}
 
-    uint devFlags = 0;
-    if (debugLayer)
-        devFlags |= D3D11_CREATE_DEVICE_DEBUG;
+bool QRhiD3D11::create(QRhi::Flags flags)
+{
+    static const auto pD3D11CreateDevice =
+        reinterpret_cast<decltype(&::D3D11CreateDevice)>(
+            QSystemLibrary::resolve(u"d3d11"_s, "D3D11CreateDevice"));
+    if (!pD3D11CreateDevice) {
+        qWarning() << "D3D11 is not available on this platform.";
+        return false;
+    }
 
     dxgiFactory = createDXGIFactory2();
-    if (!dxgiFactory)
-        return false;
+    if (dxgiFactory) {
+        supportsFlipSwapchain = QOperatingSystemVersion::isWin10OrGreater()
+            && !qEnvironmentVariableIntValue("QT_D3D_NO_FLIP");
+    } else {
+        supportsFlipSwapchain = false;
+        dxgiFactory = createDXGIFactory1();
+        if (!dxgiFactory) {
+            dxgiFactory = createDXGIFactory();
+            if (!dxgiFactory) {
+                qWarning() << "DXGI is not available on this platform.";
+                return false;
+            }
+            g_using_dxgi_1_0 = true;
+        }
+    }
 
-    // For a FLIP_* swapchain Present(0, 0) is not necessarily
-    // sufficient to get non-blocking behavior, try using ALLOW_TEARING
-    // when available.
     supportsAllowTearing = false;
-    IDXGIFactory5 *factory5 = nullptr;
-    if (SUCCEEDED(dxgiFactory->QueryInterface(__uuidof(IDXGIFactory5), reinterpret_cast<void **>(&factory5)))) {
-        BOOL allowTearing = false;
-        if (SUCCEEDED(factory5->CheckFeatureSupport(DXGI_FEATURE_PRESENT_ALLOW_TEARING, &allowTearing, sizeof(allowTearing))))
-            supportsAllowTearing = allowTearing;
-        factory5->Release();
+    if (supportsFlipSwapchain) {
+        // For a FLIP_* swapchain Present(0, 0) is not necessarily
+        // sufficient to get non-blocking behavior, try using ALLOW_TEARING
+        // when available.
+        IDXGIFactory5 *factory5 = nullptr;
+        if (SUCCEEDED(dxgiFactory->QueryInterface(IID_PPV_ARGS(&factory5)))) {
+            BOOL allowTearing = false;
+            if (SUCCEEDED(factory5->CheckFeatureSupport(DXGI_FEATURE_PRESENT_ALLOW_TEARING, &allowTearing, sizeof(allowTearing))))
+                supportsAllowTearing = allowTearing;
+            factory5->Release();
+        }
     }
 
-    if (qEnvironmentVariableIntValue("QT_D3D_FLIP_DISCARD"))
-        qWarning("The default swap effect is FLIP_DISCARD, QT_D3D_FLIP_DISCARD is now ignored");
+    qCDebug(QRHI_LOG_INFO, "FLIP_* swapchain supported = %s, ALLOW_TEARING supported = %s",
+            supportsFlipSwapchain ? "true" : "false",
+            supportsAllowTearing ? "true" : "false");
 
-    if (qEnvironmentVariableIntValue("QT_D3D_NO_FLIP"))
-        qWarning("Non-FLIP swapchains are no longer supported, QT_D3D_NO_FLIP is now ignored");
+    qCDebug(QRHI_LOG_INFO, "Default swap effect: %s",
+            supportsFlipSwapchain ? "FLIP_DISCARD" : "DISCARD");
 
-    qCDebug(QRHI_LOG_INFO, "FLIP_* swapchain supported = true, ALLOW_TEARING supported = %s",
-            supportsAllowTearing ? "true" : "false");
+    rhiFlags = flags;
 
-    qCDebug(QRHI_LOG_INFO, "Default swap effect: FLIP_DISCARD");
+    uint devFlags = 0;
+    if (debugLayer)
+        devFlags |= D3D11_CREATE_DEVICE_DEBUG;
 
     if (!importedDeviceAndContext) {
-        IDXGIAdapter1 *adapter;
-        int requestedAdapterIndex = -1;
-        if (qEnvironmentVariableIsSet("QT_D3D_ADAPTER_INDEX"))
-            requestedAdapterIndex = qEnvironmentVariableIntValue("QT_D3D_ADAPTER_INDEX");
-
-        // The importParams may specify an adapter by the luid, take that into account.
-        if (requestedAdapterIndex < 0 && (adapterLuid.LowPart || adapterLuid.HighPart)) {
-            for (int adapterIndex = 0; dxgiFactory->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
-                DXGI_ADAPTER_DESC1 desc;
-                adapter->GetDesc1(&desc);
-                adapter->Release();
-                if (desc.AdapterLuid.LowPart == adapterLuid.LowPart
-                        && desc.AdapterLuid.HighPart == adapterLuid.HighPart)
-                {
-                    requestedAdapterIndex = adapterIndex;
-                    break;
+        activeAdapter = nullptr;
+
+        if (!g_using_dxgi_1_0) {
+            IDXGIAdapter1 *adapter;
+            int requestedAdapterIndex = -1;
+            if (qEnvironmentVariableIsSet("QT_D3D_ADAPTER_INDEX"))
+                requestedAdapterIndex = qEnvironmentVariableIntValue("QT_D3D_ADAPTER_INDEX");
+
+            const auto dxgiFactory1 = static_cast<IDXGIFactory1 *>(dxgiFactory);
+
+            // The importParams may specify an adapter by the luid, take that into account.
+            if (requestedAdapterIndex < 0 && (adapterLuid.LowPart || adapterLuid.HighPart)) {
+                for (int adapterIndex = 0; dxgiFactory1->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
+                    DXGI_ADAPTER_DESC1 desc;
+                    adapter->GetDesc1(&desc);
+                    adapter->Release();
+                    if (desc.AdapterLuid.LowPart == adapterLuid.LowPart
+                            && desc.AdapterLuid.HighPart == adapterLuid.HighPart)
+                    {
+                        requestedAdapterIndex = adapterIndex;
+                        break;
+                    }
+                }
+            }
+
+            if (requestedAdapterIndex < 0 && rhiFlags.testFlag(QRhi::PreferSoftwareRenderer)) {
+                for (int adapterIndex = 0; dxgiFactory1->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
+                    DXGI_ADAPTER_DESC1 desc;
+                    adapter->GetDesc1(&desc);
+                    adapter->Release();
+                    if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) {
+                        requestedAdapterIndex = adapterIndex;
+                        break;
+                    }
                 }
             }
-        }
 
-        if (requestedAdapterIndex < 0 && flags.testFlag(QRhi::PreferSoftwareRenderer)) {
-            for (int adapterIndex = 0; dxgiFactory->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
+            for (int adapterIndex = 0; dxgiFactory1->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
                 DXGI_ADAPTER_DESC1 desc;
                 adapter->GetDesc1(&desc);
-                adapter->Release();
-                if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) {
-                    requestedAdapterIndex = adapterIndex;
-                    break;
+                const QString name = QString::fromUtf16(reinterpret_cast<char16_t *>(desc.Description));
+                qCDebug(QRHI_LOG_INFO, "Adapter %d: '%s' (vendor 0x%X device 0x%X flags 0x%X)",
+                        adapterIndex,
+                        qPrintable(name),
+                        desc.VendorId,
+                        desc.DeviceId,
+                        desc.Flags);
+                if (!activeAdapter && (requestedAdapterIndex < 0 || requestedAdapterIndex == adapterIndex)) {
+                    activeAdapter = adapter;
+                    adapterLuid = desc.AdapterLuid;
+                    driverInfoStruct.deviceName = name.toUtf8();
+                    driverInfoStruct.deviceId = desc.DeviceId;
+                    driverInfoStruct.vendorId = desc.VendorId;
+                    qCDebug(QRHI_LOG_INFO, "  using this adapter");
+                } else {
+                    adapter->Release();
                 }
             }
-        }
-
-        activeAdapter = nullptr;
-        for (int adapterIndex = 0; dxgiFactory->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
-            DXGI_ADAPTER_DESC1 desc;
-            adapter->GetDesc1(&desc);
-            const QString name = QString::fromUtf16(reinterpret_cast<char16_t *>(desc.Description));
-            qCDebug(QRHI_LOG_INFO, "Adapter %d: '%s' (vendor 0x%X device 0x%X flags 0x%X)",
-                    adapterIndex,
-                    qPrintable(name),
-                    desc.VendorId,
-                    desc.DeviceId,
-                    desc.Flags);
-            if (!activeAdapter && (requestedAdapterIndex < 0 || requestedAdapterIndex == adapterIndex)) {
-                activeAdapter = adapter;
-                adapterLuid = desc.AdapterLuid;
-                driverInfoStruct.deviceName = name.toUtf8();
-                driverInfoStruct.deviceId = desc.DeviceId;
-                driverInfoStruct.vendorId = desc.VendorId;
-                qCDebug(QRHI_LOG_INFO, "  using this adapter");
-            } else {
-                adapter->Release();
+            if (!activeAdapter) {
+                qWarning("No adapter");
+                return false;
             }
         }
-        if (!activeAdapter) {
-            qWarning("No adapter");
-            return false;
-        }
 
         // Normally we won't specify a requested feature level list,
         // except when a level was specified in importParams.
@@ -245,27 +312,55 @@ bool QRhiD3D11::create(QRhi::Flags flags)
             requestedFeatureLevels.append(featureLevel);
         }
 
+        const D3D_DRIVER_TYPE driverType =
+                activeAdapter ? D3D_DRIVER_TYPE_UNKNOWN : D3D_DRIVER_TYPE_HARDWARE;
         ID3D11DeviceContext *ctx = nullptr;
-        HRESULT hr = D3D11CreateDevice(activeAdapter, D3D_DRIVER_TYPE_UNKNOWN, nullptr, devFlags,
-                                       requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
-                                       requestFeatureLevels ? requestedFeatureLevels.count() : 0,
-                                       D3D11_SDK_VERSION,
-                                       &dev, &featureLevel, &ctx);
+        HRESULT hr = pD3D11CreateDevice(activeAdapter, driverType, nullptr, devFlags,
+                                        requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
+                                        requestFeatureLevels ? requestedFeatureLevels.count() : 0,
+                                        D3D11_SDK_VERSION,
+                                        &dev, &featureLevel, &ctx);
         // We cannot assume that D3D11_CREATE_DEVICE_DEBUG is always available. Retry without it, if needed.
         if (hr == DXGI_ERROR_SDK_COMPONENT_MISSING && debugLayer) {
             qCDebug(QRHI_LOG_INFO, "Debug layer was requested but is not available. "
                                    "Attempting to create D3D11 device without it.");
             devFlags &= ~D3D11_CREATE_DEVICE_DEBUG;
-            hr = D3D11CreateDevice(activeAdapter, D3D_DRIVER_TYPE_UNKNOWN, nullptr, devFlags,
-                                   requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
-                                   requestFeatureLevels ? requestedFeatureLevels.count() : 0,
-                                   D3D11_SDK_VERSION,
-                                   &dev, &featureLevel, &ctx);
+            hr = pD3D11CreateDevice(activeAdapter, driverType, nullptr, devFlags,
+                                    requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
+                                    requestFeatureLevels ? requestedFeatureLevels.count() : 0,
+                                    D3D11_SDK_VERSION,
+                                    &dev, &featureLevel, &ctx);
         }
         if (FAILED(hr)) {
-            qWarning("Failed to create D3D11 device and context: %s",
-                qPrintable(QSystemError::windowsComString(hr)));
-            return false;
+            qWarning().noquote() << "Failed to create D3D11 device:"
+                                 << QSystemError::windowsComString(hr)
+                                 << "\nTry again using WARP instead ...";
+            hr = pD3D11CreateDevice(nullptr, D3D_DRIVER_TYPE_WARP, nullptr, devFlags,
+                                    requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
+                                    requestFeatureLevels ? requestedFeatureLevels.count() : 0,
+                                    D3D11_SDK_VERSION,
+                                    &dev, &featureLevel, &ctx);
+            if (FAILED(hr)) {
+                qWarning() << "Failed to create D3D11 device with WARP:"
+                           << QSystemError::windowsComString(hr)
+                           << "\nTry again using Mesa instead ...";
+            }
+            const HMODULE soft = QSystemLibrary::load(L"d3d10sw", false);
+            if (!soft) {
+                qWarning() << "Failed to load d3d10sw.dll. D3D11 is not available.";
+                return false;
+            }
+            hr = pD3D11CreateDevice(nullptr, D3D_DRIVER_TYPE_SOFTWARE, soft, devFlags,
+                                    requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
+                                    requestFeatureLevels ? requestedFeatureLevels.count() : 0,
+                                    D3D11_SDK_VERSION,
+                                    &dev, &featureLevel, &ctx);
+            if (FAILED(hr)) {
+                qWarning().noquote() << "Failed to create D3D11 device with Mesa:"
+                                     << QSystemError::windowsComString(hr)
+                                     << "\nD3D11 is not available.";
+                return false;
+            }
         }
 
         // Test if creating a Shader Model 5.0 vertex shader works; we want to
@@ -279,7 +374,7 @@ bool QRhiD3D11::create(QRhi::Flags flags)
             return false;
         }
 
-        const bool supports11_1 = SUCCEEDED(ctx->QueryInterface(__uuidof(ID3D11DeviceContext1), reinterpret_cast<void **>(&context)));
+        const bool supports11_1 = SUCCEEDED(ctx->QueryInterface(IID_PPV_ARGS(&context)));
         ctx->Release();
         if (!supports11_1) {
             qWarning("ID3D11DeviceContext1 not supported");
@@ -289,7 +384,7 @@ bool QRhiD3D11::create(QRhi::Flags flags)
         Q_ASSERT(dev && context);
         featureLevel = dev->GetFeatureLevel();
         IDXGIDevice *dxgiDev = nullptr;
-        if (SUCCEEDED(dev->QueryInterface(__uuidof(IDXGIDevice), reinterpret_cast<void **>(&dxgiDev)))) {
+        if (SUCCEEDED(dev->QueryInterface(IID_PPV_ARGS(&dxgiDev)))) {
             IDXGIAdapter *adapter = nullptr;
             if (SUCCEEDED(dxgiDev->GetAdapter(&adapter))) {
                 DXGI_ADAPTER_DESC desc;
@@ -305,7 +400,7 @@ bool QRhiD3D11::create(QRhi::Flags flags)
         qCDebug(QRHI_LOG_INFO, "Using imported device %p", dev);
     }
 
-    if (FAILED(context->QueryInterface(__uuidof(ID3DUserDefinedAnnotation), reinterpret_cast<void **>(&annotations))))
+    if (FAILED(context->QueryInterface(IID_PPV_ARGS(&annotations))))
         annotations = nullptr;
 
     deviceLost = false;
@@ -374,7 +469,7 @@ void QRhiD3D11::reportLiveObjects(ID3D11Device *device)
 {
     // this works only when params.enableDebugLayer was true
     ID3D11Debug *debug;
-    if (SUCCEEDED(device->QueryInterface(__uuidof(ID3D11Debug), reinterpret_cast<void **>(&debug)))) {
+    if (SUCCEEDED(device->QueryInterface(IID_PPV_ARGS(&debug)))) {
         debug->ReportLiveDeviceObjects(D3D11_RLDO_DETAIL);
         debug->Release();
     }
@@ -2871,7 +2966,7 @@ bool QD3D11Buffer::create()
     }
 
     if (!m_objectName.isEmpty())
-        buffer->SetPrivateData(WKPDID_D3DDebugObjectName, UINT(m_objectName.size()), m_objectName.constData());
+        buffer->SetPrivateData(qWKPDID_D3DDebugObjectNameA, UINT(m_objectName.size()), m_objectName.constData());
 
     generation += 1;
     rhiD->registerResource(this);
@@ -3037,7 +3132,7 @@ bool QD3D11RenderBuffer::create()
     }
 
     if (!m_objectName.isEmpty())
-        tex->SetPrivateData(WKPDID_D3DDebugObjectName, UINT(m_objectName.size()), m_objectName.constData());
+        tex->SetPrivateData(qWKPDID_D3DDebugObjectNameA, UINT(m_objectName.size()), m_objectName.constData());
 
     generation += 1;
     rhiD->registerResource(this);
@@ -3332,7 +3427,7 @@ bool QD3D11Texture::create()
             return false;
         }
         if (!m_objectName.isEmpty())
-            tex->SetPrivateData(WKPDID_D3DDebugObjectName, UINT(m_objectName.size()),
+            tex->SetPrivateData(qWKPDID_D3DDebugObjectNameA, UINT(m_objectName.size()),
                                 m_objectName.constData());
     } else if (!is3D) {
         D3D11_TEXTURE2D_DESC desc = {};
@@ -3353,7 +3448,7 @@ bool QD3D11Texture::create()
             return false;
         }
         if (!m_objectName.isEmpty())
-            tex->SetPrivateData(WKPDID_D3DDebugObjectName, UINT(m_objectName.size()), m_objectName.constData());
+            tex->SetPrivateData(qWKPDID_D3DDebugObjectNameA, UINT(m_objectName.size()), m_objectName.constData());
     } else {
         D3D11_TEXTURE3D_DESC desc = {};
         desc.Width = UINT(size.width());
@@ -3372,7 +3467,7 @@ bool QD3D11Texture::create()
             return false;
         }
         if (!m_objectName.isEmpty())
-            tex3D->SetPrivateData(WKPDID_D3DDebugObjectName, UINT(m_objectName.size()), m_objectName.constData());
+            tex3D->SetPrivateData(qWKPDID_D3DDebugObjectNameA, UINT(m_objectName.size()), m_objectName.constData());
     }
 
     if (!finishCreate())
@@ -4748,7 +4843,7 @@ static bool output6ForWindow(QWindow *w, IDXGIAdapter1 *adapter, IDXGIOutput6 **
         }
     }
     if (currentOutput) {
-        ok = SUCCEEDED(currentOutput->QueryInterface(__uuidof(IDXGIOutput6), reinterpret_cast<void **>(result)));
+        ok = SUCCEEDED(currentOutput->QueryInterface(IID_PPV_ARGS(result)));
         currentOutput->Release();
     }
     return ok;
@@ -4776,6 +4871,8 @@ bool QD3D11SwapChain::isFormatSupported(Format f)
     }
 
     QRHI_RES_RHI(QRhiD3D11);
+    if (!rhiD->activeAdapter)
+        return false;
     DXGI_OUTPUT_DESC1 desc1;
     if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &desc1))
         return desc1.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
@@ -4788,6 +4885,8 @@ QRhiSwapChainHdrInfo QD3D11SwapChain::hdrInfo()
     QRhiSwapChainHdrInfo info = QRhiSwapChain::hdrInfo();
     if (m_format != QRhiSwapChain::SDR && m_window) {
         QRHI_RES_RHI(QRhiD3D11);
+        if (!rhiD->activeAdapter)
+            return info;
         DXGI_OUTPUT_DESC1 hdrOutputDesc;
         if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &hdrOutputDesc)) {
             info.isHardCodedDefaults = false;
@@ -4845,12 +4944,18 @@ static const DXGI_FORMAT DEFAULT_SRGB_FORMAT = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
 
 bool QRhiD3D11::ensureDirectCompositionDevice()
 {
+    static const auto pDCompositionCreateDevice =
+        reinterpret_cast<decltype(&::DCompositionCreateDevice)>(
+            QSystemLibrary::resolve(u"dcomp"_s, "DCompositionCreateDevice"));
+    if (!pDCompositionCreateDevice)
+        return false;
+
     if (dcompDevice)
         return true;
 
     qCDebug(QRHI_LOG_INFO, "Creating Direct Composition device (needed for semi-transparent windows)");
 
-    HRESULT hr = DCompositionCreateDevice(nullptr, __uuidof(IDCompositionDevice), reinterpret_cast<void **>(&dcompDevice));
+    HRESULT hr = pDCompositionCreateDevice(nullptr, IID_PPV_ARGS(&dcompDevice));
     if (FAILED(hr)) {
         qWarning("Failed to Direct Composition device: %s",
             qPrintable(QSystemError::windowsComString(hr)));
@@ -4883,12 +4988,18 @@ bool QD3D11SwapChain::createOrResize()
     HRESULT hr;
 
     QRHI_RES_RHI(QRhiD3D11);
+    bool useFlipModel = rhiD->supportsFlipSwapchain;
 
+    // Take a shortcut for alpha: whatever the platform plugin does to enable
+    // transparency for our QWindow will be sufficient on the legacy (DISCARD)
+    // path. For FLIP_* we'd need to use DirectComposition (create a
+    // IDCompositionDevice/Target/Visual).
     if (m_flags.testFlag(SurfaceHasPreMulAlpha) || m_flags.testFlag(SurfaceHasNonPreMulAlpha)) {
         if (rhiD->ensureDirectCompositionDevice()) {
             if (!dcompTarget) {
                 hr = rhiD->dcompDevice->CreateTargetForHwnd(hwnd, true, &dcompTarget);
                 if (FAILED(hr)) {
+                    useFlipModel = false;
                     qWarning("Failed to create Direct Compsition target for the window: %s",
                              qPrintable(QSystemError::windowsComString(hr)));
                 }
@@ -4896,10 +5007,15 @@ bool QD3D11SwapChain::createOrResize()
             if (dcompTarget && !dcompVisual) {
                 hr = rhiD->dcompDevice->CreateVisual(&dcompVisual);
                 if (FAILED(hr)) {
+                    useFlipModel = false;
                     qWarning("Failed to create DirectComposition visual: %s",
                              qPrintable(QSystemError::windowsComString(hr)));
                 }
             }
+        } else {
+            // Direct Composition is not available, most likely due to we are running
+            // on Windows 7. Fallback to the legacy non-flip model instead.
+            useFlipModel = false;
         }
         // simple consistency check
         if (window->requestedFormat().alphaBufferSize() <= 0)
@@ -4914,7 +5030,7 @@ bool QD3D11SwapChain::createOrResize()
     // ALLOW_TEARING, and ALLOW_TEARING is not compatible with it at all so the
     // flag must not be set then. Whereas for flip we should use it, if
     // supported, to get better results for 'unthrottled' presentation.
-    if (swapInterval == 0 && rhiD->supportsAllowTearing)
+    if (swapInterval == 0 && useFlipModel && rhiD->supportsAllowTearing)
         swapChainFlags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING;
 
     if (!swapChain) {
@@ -4922,121 +5038,145 @@ bool QD3D11SwapChain::createOrResize()
         colorFormat = DEFAULT_FORMAT;
         srgbAdjustedColorFormat = m_flags.testFlag(sRGB) ? DEFAULT_SRGB_FORMAT : DEFAULT_FORMAT;
 
-        DXGI_COLOR_SPACE_TYPE hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709; // SDR
-        DXGI_OUTPUT_DESC1 hdrOutputDesc;
-        if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &hdrOutputDesc) && m_format != SDR) {
-            // https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range
-            if (hdrOutputDesc.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020) {
-                switch (m_format) {
-                case HDRExtendedSrgbLinear:
-                    colorFormat = DXGI_FORMAT_R16G16B16A16_FLOAT;
-                    hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709;
-                    srgbAdjustedColorFormat = colorFormat;
-                    break;
-                case HDR10:
-                    colorFormat = DXGI_FORMAT_R10G10B10A2_UNORM;
-                    hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
-                    srgbAdjustedColorFormat = colorFormat;
-                    break;
-                default:
-                    break;
+        if (useFlipModel) {
+            DXGI_COLOR_SPACE_TYPE hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709; // SDR
+            DXGI_OUTPUT_DESC1 hdrOutputDesc;
+            if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &hdrOutputDesc) && m_format != SDR) {
+                // https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range
+                if (hdrOutputDesc.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020) {
+                    switch (m_format) {
+                    case HDRExtendedSrgbLinear:
+                        colorFormat = DXGI_FORMAT_R16G16B16A16_FLOAT;
+                        hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709;
+                        srgbAdjustedColorFormat = colorFormat;
+                        break;
+                    case HDR10:
+                        colorFormat = DXGI_FORMAT_R10G10B10A2_UNORM;
+                        hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
+                        srgbAdjustedColorFormat = colorFormat;
+                        break;
+                    default:
+                        break;
+                    }
+                } else {
+                    // This happens also when Use HDR is set to Off in the Windows
+                    // Display settings. Show a helpful warning, but continue with the
+                    // default non-HDR format.
+                    qWarning("The output associated with the window is not HDR capable "
+                             "(or Use HDR is Off in the Display Settings), ignoring HDR format request");
                 }
-            } else {
-                // This happens also when Use HDR is set to Off in the Windows
-                // Display settings. Show a helpful warning, but continue with the
-                // default non-HDR format.
-                qWarning("The output associated with the window is not HDR capable "
-                         "(or Use HDR is Off in the Display Settings), ignoring HDR format request");
             }
-        }
 
-        // We use a FLIP model swapchain which implies a buffer count of 2
-        // (as opposed to the old DISCARD with back buffer count == 1).
-        // This makes no difference for the rest of the stuff except that
-        // automatic MSAA is unsupported and needs to be implemented via a
-        // custom multisample render target and an explicit resolve.
-
-        DXGI_SWAP_CHAIN_DESC1 desc = {};
-        desc.Width = UINT(pixelSize.width());
-        desc.Height = UINT(pixelSize.height());
-        desc.Format = colorFormat;
-        desc.SampleDesc.Count = 1;
-        desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
-        desc.BufferCount = BUFFER_COUNT;
-        desc.Flags = swapChainFlags;
-        desc.Scaling = DXGI_SCALING_NONE;
-        desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
-
-        if (dcompVisual) {
-            // With DirectComposition setting AlphaMode to STRAIGHT fails the
-            // swapchain creation, whereas the result seems to be identical
-            // with any of the other values, including IGNORE. (?)
-            desc.AlphaMode = DXGI_ALPHA_MODE_PREMULTIPLIED;
-
-            // DirectComposition has its own limitations, cannot use
-            // SCALING_NONE. So with semi-transparency requested we are forced
-            // to SCALING_STRETCH.
-            desc.Scaling = DXGI_SCALING_STRETCH;
-        }
+            // We use a FLIP model swapchain which implies a buffer count of 2
+            // (as opposed to the old DISCARD with back buffer count == 1).
+            // This makes no difference for the rest of the stuff except that
+            // automatic MSAA is unsupported and needs to be implemented via a
+            // custom multisample render target and an explicit resolve.
 
-        IDXGIFactory2 *fac = static_cast<IDXGIFactory2 *>(rhiD->dxgiFactory);
-        IDXGISwapChain1 *sc1;
+            DXGI_SWAP_CHAIN_DESC1 desc = {};
+            desc.Width = UINT(pixelSize.width());
+            desc.Height = UINT(pixelSize.height());
+            desc.Format = colorFormat;
+            desc.SampleDesc.Count = 1;
+            desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
+            desc.BufferCount = BUFFER_COUNT;
+            desc.Flags = swapChainFlags;
+            desc.Scaling = DXGI_SCALING_NONE;
+            desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
+
+            if (dcompVisual) {
+                // With DirectComposition setting AlphaMode to STRAIGHT fails the
+                // swapchain creation, whereas the result seems to be identical
+                // with any of the other values, including IGNORE. (?)
+                desc.AlphaMode = DXGI_ALPHA_MODE_PREMULTIPLIED;
+
+                // DirectComposition has its own limitations, cannot use
+                // SCALING_NONE. So with semi-transparency requested we are forced
+                // to SCALING_STRETCH.
+                desc.Scaling = DXGI_SCALING_STRETCH;
+            }
+
+            IDXGIFactory2 *fac = static_cast<IDXGIFactory2 *>(rhiD->dxgiFactory);
+            IDXGISwapChain1 *sc1;
 
-        if (dcompVisual)
-            hr = fac->CreateSwapChainForComposition(rhiD->dev, &desc, nullptr, &sc1);
-        else
-            hr = fac->CreateSwapChainForHwnd(rhiD->dev, hwnd, &desc, nullptr, nullptr, &sc1);
-
-        // If failed and we tried a HDR format, then try with SDR. This
-        // matches other backends, such as Vulkan where if the format is
-        // not supported, the default one is used instead.
-        if (FAILED(hr) && m_format != SDR) {
-            colorFormat = DEFAULT_FORMAT;
-            desc.Format = DEFAULT_FORMAT;
             if (dcompVisual)
                 hr = fac->CreateSwapChainForComposition(rhiD->dev, &desc, nullptr, &sc1);
             else
                 hr = fac->CreateSwapChainForHwnd(rhiD->dev, hwnd, &desc, nullptr, nullptr, &sc1);
-        }
 
-        if (SUCCEEDED(hr)) {
-            swapChain = sc1;
-            if (m_format != SDR) {
-                IDXGISwapChain3 *sc3 = nullptr;
-                if (SUCCEEDED(sc1->QueryInterface(__uuidof(IDXGISwapChain3), reinterpret_cast<void **>(&sc3)))) {
-                    hr = sc3->SetColorSpace1(hdrColorSpace);
-                    if (FAILED(hr))
-                        qWarning("Failed to set color space on swapchain: %s",
-                            qPrintable(QSystemError::windowsComString(hr)));
-                    sc3->Release();
-                } else {
-                    qWarning("IDXGISwapChain3 not available, HDR swapchain will not work as expected");
-                }
+            // If failed and we tried a HDR format, then try with SDR. This
+            // matches other backends, such as Vulkan where if the format is
+            // not supported, the default one is used instead.
+            if (FAILED(hr) && m_format != SDR) {
+                colorFormat = DEFAULT_FORMAT;
+                desc.Format = DEFAULT_FORMAT;
+                if (dcompVisual)
+                    hr = fac->CreateSwapChainForComposition(rhiD->dev, &desc, nullptr, &sc1);
+                else
+                    hr = fac->CreateSwapChainForHwnd(rhiD->dev, hwnd, &desc, nullptr, nullptr, &sc1);
             }
-            if (dcompVisual) {
-                hr = dcompVisual->SetContent(sc1);
-                if (SUCCEEDED(hr)) {
-                    hr = dcompTarget->SetRoot(dcompVisual);
-                    if (FAILED(hr)) {
-                        qWarning("Failed to associate Direct Composition visual with the target: %s",
+
+            if (SUCCEEDED(hr)) {
+                swapChain = sc1;
+                if (m_format != SDR) {
+                    IDXGISwapChain3 *sc3 = nullptr;
+                    if (SUCCEEDED(sc1->QueryInterface(IID_PPV_ARGS(&sc3)))) {
+                        hr = sc3->SetColorSpace1(hdrColorSpace);
+                        if (FAILED(hr)) {
+                            qWarning("Failed to set color space on swapchain: %s",
+                                qPrintable(QSystemError::windowsComString(hr)));
+                        }
+                        sc3->Release();
+                    } else {
+                        qWarning("IDXGISwapChain3 not available, HDR swapchain will not work as expected");
+                    }
+                }
+                if (dcompVisual) {
+                    hr = dcompVisual->SetContent(sc1);
+                    if (SUCCEEDED(hr)) {
+                        hr = dcompTarget->SetRoot(dcompVisual);
+                        if (FAILED(hr)) {
+                            qWarning("Failed to associate Direct Composition visual with the target: %s",
+                                     qPrintable(QSystemError::windowsComString(hr)));
+                        }
+                    } else {
+                        qWarning("Failed to set content for Direct Composition visual: %s",
                                  qPrintable(QSystemError::windowsComString(hr)));
                     }
-                } else {
-                    qWarning("Failed to set content for Direct Composition visual: %s",
-                             qPrintable(QSystemError::windowsComString(hr)));
                 }
             }
+        } else {
+            // Fallback: use DISCARD model. Regardless, keep on using our manual
+            // resolve for symmetry with the FLIP_* code path when MSAA is
+            // requested. This has no HDR support.
+
+            DXGI_SWAP_CHAIN_DESC desc = {};
+            desc.BufferDesc.Width = UINT(pixelSize.width());
+            desc.BufferDesc.Height = UINT(pixelSize.height());
+            desc.BufferDesc.RefreshRate.Numerator = 60;
+            desc.BufferDesc.RefreshRate.Denominator = 1;
+            desc.BufferDesc.Format = colorFormat;
+            desc.SampleDesc.Count = 1;
+            desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
+            desc.BufferCount = 1;
+            desc.OutputWindow = hwnd;
+            desc.Windowed = TRUE;
+            desc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
+            desc.Flags = swapChainFlags;
+
+            hr = rhiD->dxgiFactory->CreateSwapChain(rhiD->dev, &desc, &swapChain);
         }
         if (FAILED(hr)) {
             qWarning("Failed to create D3D11 swapchain: %s",
                 qPrintable(QSystemError::windowsComString(hr)));
             return false;
         }
-        rhiD->dxgiFactory->MakeWindowAssociation(hwnd, DXGI_MWA_NO_WINDOW_CHANGES);
+        rhiD->dxgiFactory->MakeWindowAssociation(hwnd,
+            DXGI_MWA_NO_WINDOW_CHANGES | DXGI_MWA_NO_ALT_ENTER | DXGI_MWA_NO_PRINT_SCREEN);
     } else {
         releaseBuffers();
-        // flip model -> buffer count is the real buffer count, not 1 like with the legacy modes
-        hr = swapChain->ResizeBuffers(UINT(BUFFER_COUNT), UINT(pixelSize.width()), UINT(pixelSize.height()),
+        const UINT count = useFlipModel ? BUFFER_COUNT : 1;
+        hr = swapChain->ResizeBuffers(count, UINT(pixelSize.width()), UINT(pixelSize.height()),
                                       colorFormat, swapChainFlags);
         if (hr == DXGI_ERROR_DEVICE_REMOVED || hr == DXGI_ERROR_DEVICE_RESET) {
             qWarning("Device loss detected in ResizeBuffers()");
@@ -5063,7 +5203,7 @@ bool QD3D11SwapChain::createOrResize()
     // swapchain."
 
     // So just query index 0 once (per resize) and be done with it.
-    hr = swapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<void **>(&backBufferTex));
+    hr = swapChain->GetBuffer(0, IID_PPV_ARGS(&backBufferTex));
     if (FAILED(hr)) {
         qWarning("Failed to query swapchain backbuffer: %s",
             qPrintable(QSystemError::windowsComString(hr)));
diff --git a/src/gui/rhi/qrhid3d11_p_p.h b/src/gui/rhi/qrhid3d11_p_p.h
index 3f4d8e8e31..f88c6d047f 100644
--- a/src/gui/rhi/qrhid3d11_p_p.h
+++ b/src/gui/rhi/qrhid3d11_p_p.h
@@ -737,8 +737,9 @@ public:
     LUID adapterLuid = {};
     ID3DUserDefinedAnnotation *annotations = nullptr;
     IDXGIAdapter1 *activeAdapter = nullptr;
-    IDXGIFactory1 *dxgiFactory = nullptr;
+    IDXGIFactory *dxgiFactory = nullptr;
     IDCompositionDevice *dcompDevice = nullptr;
+    bool supportsFlipSwapchain = false;
     bool supportsAllowTearing = false;
     bool deviceLost = false;
     QRhiD3D11NativeHandles nativeHandlesStruct;
diff --git a/src/gui/rhi/qrhid3d12.cpp b/src/gui/rhi/qrhid3d12.cpp
index 5630aa852b..f43ff1cc2e 100644
--- a/src/gui/rhi/qrhid3d12.cpp
+++ b/src/gui/rhi/qrhid3d12.cpp
@@ -20,8 +20,54 @@ QT_BEGIN_NAMESPACE
   Direct 3D 12 backend.
 */
 
+using namespace Qt::StringLiterals;
+
 // https://learn.microsoft.com/en-us/windows/win32/direct3d12/hardware-feature-levels
-static const D3D_FEATURE_LEVEL MIN_FEATURE_LEVEL = D3D_FEATURE_LEVEL_11_0;
+static constexpr const D3D_FEATURE_LEVEL MIN_FEATURE_LEVEL = D3D_FEATURE_LEVEL_11_0;
+
+struct QtD3D12ApiSupport
+{
+    decltype(&::CreateDXGIFactory2) pCreateDXGIFactory2 = nullptr;
+    decltype(&::DCompositionCreateDevice) pDCompositionCreateDevice = nullptr;
+    decltype(&::D3D12CreateDevice) pD3D12CreateDevice = nullptr;
+    decltype(&::D3D12GetDebugInterface) pD3D12GetDebugInterface = nullptr;
+    decltype(&::D3D12SerializeVersionedRootSignature) pD3D12SerializeVersionedRootSignature = nullptr;
+
+    explicit QtD3D12ApiSupport()
+    {
+        pCreateDXGIFactory2 =
+            reinterpret_cast<decltype(pCreateDXGIFactory2)>(
+                QSystemLibrary::resolve(u"dxgi"_s, "CreateDXGIFactory2"));
+        pDCompositionCreateDevice =
+            reinterpret_cast<decltype(pDCompositionCreateDevice)>(
+                QSystemLibrary::resolve(u"dcomp"_s, "DCompositionCreateDevice"));
+        QSystemLibrary d3d12(u"d3d12"_s);
+        pD3D12CreateDevice =
+            reinterpret_cast<decltype(pD3D12CreateDevice)>(
+                d3d12.resolve("D3D12CreateDevice"));
+        pD3D12GetDebugInterface =
+            reinterpret_cast<decltype(pD3D12GetDebugInterface)>(
+                d3d12.resolve("D3D12GetDebugInterface"));
+        pD3D12SerializeVersionedRootSignature =
+            reinterpret_cast<decltype(pD3D12SerializeVersionedRootSignature)>(
+                d3d12.resolve("D3D12SerializeVersionedRootSignature"));
+    }
+
+    ~QtD3D12ApiSupport() = default;
+
+    [[nodiscard]] static QtD3D12ApiSupport *instance()
+    {
+        static QtD3D12ApiSupport support;
+        return &support;
+    }
+
+    [[nodiscard]] bool isAvailable() const
+    {
+        return pCreateDXGIFactory2 && pDCompositionCreateDevice
+                && pD3D12CreateDevice && pD3D12GetDebugInterface
+                && pD3D12SerializeVersionedRootSignature;
+    }
+};
 
 QRhiD3D12::QRhiD3D12(QRhiD3D12InitParams *params, QRhiD3D12NativeHandles *importParams)
 {
@@ -68,12 +114,18 @@ static inline QD3D12RenderTargetData *rtData(QRhiRenderTarget *rt)
 
 bool QRhiD3D12::create(QRhi::Flags flags)
 {
+    if (!QtD3D12ApiSupport::instance()->isAvailable()) {
+        qWarning() << "D3D12 is not available on current platform.";
+        return false;
+    }
+
     rhiFlags = flags;
 
     UINT factoryFlags = 0;
     if (debugLayer)
         factoryFlags |= DXGI_CREATE_FACTORY_DEBUG;
-    HRESULT hr = CreateDXGIFactory2(factoryFlags, __uuidof(IDXGIFactory2), reinterpret_cast<void **>(&dxgiFactory));
+    HRESULT hr = QtD3D12ApiSupport::instance()->pCreateDXGIFactory2(
+                factoryFlags, IID_PPV_ARGS(&dxgiFactory));
     if (FAILED(hr)) {
         qWarning("CreateDXGIFactory2() failed to create DXGI factory: %s",
                  qPrintable(QSystemError::windowsComString(hr)));
@@ -82,7 +134,7 @@ bool QRhiD3D12::create(QRhi::Flags flags)
 
     supportsAllowTearing = false;
     IDXGIFactory5 *factory5 = nullptr;
-    if (SUCCEEDED(dxgiFactory->QueryInterface(__uuidof(IDXGIFactory5), reinterpret_cast<void **>(&factory5)))) {
+    if (SUCCEEDED(dxgiFactory->QueryInterface(IID_PPV_ARGS(&factory5)))) {
         BOOL allowTearing = false;
         if (SUCCEEDED(factory5->CheckFeatureSupport(DXGI_FEATURE_PRESENT_ALLOW_TEARING, &allowTearing, sizeof(allowTearing))))
             supportsAllowTearing = allowTearing;
@@ -91,7 +143,7 @@ bool QRhiD3D12::create(QRhi::Flags flags)
 
     if (debugLayer) {
         ID3D12Debug1 *debug = nullptr;
-        if (SUCCEEDED(D3D12GetDebugInterface(__uuidof(ID3D12Debug1), reinterpret_cast<void **>(&debug)))) {
+        if (SUCCEEDED(QtD3D12ApiSupport::instance()->pD3D12GetDebugInterface(IID_PPV_ARGS(&debug)))) {
             qCDebug(QRHI_LOG_INFO, "Enabling D3D12 debug layer");
             debug->EnableDebugLayer();
             debug->Release();
@@ -161,10 +213,8 @@ bool QRhiD3D12::create(QRhi::Flags flags)
         if (minimumFeatureLevel == 0)
             minimumFeatureLevel = MIN_FEATURE_LEVEL;
 
-        hr = D3D12CreateDevice(activeAdapter,
-                               minimumFeatureLevel,
-                               __uuidof(ID3D12Device),
-                               reinterpret_cast<void **>(&dev));
+        hr = QtD3D12ApiSupport::instance()->pD3D12CreateDevice(
+                activeAdapter, minimumFeatureLevel, IID_PPV_ARGS(&dev));
         if (FAILED(hr)) {
             qWarning("Failed to create D3D12 device: %s", qPrintable(QSystemError::windowsComString(hr)));
             return false;
@@ -192,7 +242,7 @@ bool QRhiD3D12::create(QRhi::Flags flags)
 
     if (debugLayer) {
         ID3D12InfoQueue *infoQueue;
-        if (SUCCEEDED(dev->QueryInterface(__uuidof(ID3D12InfoQueue), reinterpret_cast<void **>(&infoQueue)))) {
+        if (SUCCEEDED(dev->QueryInterface(IID_PPV_ARGS(&infoQueue)))) {
             if (qEnvironmentVariableIntValue("QT_D3D_DEBUG_BREAK")) {
                 infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, true);
                 infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, true);
@@ -221,14 +271,14 @@ bool QRhiD3D12::create(QRhi::Flags flags)
         D3D12_COMMAND_QUEUE_DESC queueDesc = {};
         queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
         queueDesc.Priority = D3D12_COMMAND_QUEUE_PRIORITY_NORMAL;
-        hr = dev->CreateCommandQueue(&queueDesc, __uuidof(ID3D12CommandQueue), reinterpret_cast<void **>(&cmdQueue));
+        hr = dev->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&cmdQueue));
         if (FAILED(hr)) {
             qWarning("Failed to create command queue: %s", qPrintable(QSystemError::windowsComString(hr)));
             return false;
         }
     }
 
-    hr = dev->CreateFence(0, D3D12_FENCE_FLAG_NONE, __uuidof(ID3D12Fence), reinterpret_cast<void **>(&fullFence));
+    hr = dev->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fullFence));
     if (FAILED(hr)) {
         qWarning("Failed to create fence: %s", qPrintable(QSystemError::windowsComString(hr)));
         return false;
@@ -238,8 +288,7 @@ bool QRhiD3D12::create(QRhi::Flags flags)
 
     for (int i = 0; i < QD3D12_FRAMES_IN_FLIGHT; ++i) {
         hr = dev->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT,
-                                         __uuidof(ID3D12CommandAllocator),
-                                         reinterpret_cast<void **>(&cmdAllocators[i]));
+                                         IID_PPV_ARGS(&cmdAllocators[i]));
         if (FAILED(hr)) {
             qWarning("Failed to create command allocator: %s", qPrintable(QSystemError::windowsComString(hr)));
             return false;
@@ -1729,7 +1778,7 @@ bool QD3D12DescriptorHeap::create(ID3D12Device *device,
     heapDesc.NumDescriptors = capacity;
     heapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAGS(heapFlags);
 
-    HRESULT hr = device->CreateDescriptorHeap(&heapDesc, __uuidof(ID3D12DescriptorHeap), reinterpret_cast<void **>(&heap));
+    HRESULT hr = device->CreateDescriptorHeap(&heapDesc, IID_PPV_ARGS(&heap));
     if (FAILED(hr)) {
         qWarning("Failed to create descriptor heap: %s", qPrintable(QSystemError::windowsComString(hr)));
         heap = nullptr;
@@ -1916,8 +1965,7 @@ bool QD3D12StagingArea::create(QRhiD3D12 *rhi, quint32 capacity, D3D12_HEAP_TYPE
                                          D3D12_RESOURCE_STATES(state),
                                          nullptr,
                                          &allocation,
-                                         __uuidof(ID3D12Resource),
-                                         reinterpret_cast<void **>(&resource));
+                                         IID_PPV_ARGS(&resource));
     if (FAILED(hr)) {
         qWarning("Failed to create buffer for staging area: %s",
                  qPrintable(QSystemError::windowsComString(hr)));
@@ -2381,6 +2429,9 @@ QD3D12Descriptor QD3D12SamplerManager::getShaderVisibleDescriptor(const D3D12_SA
 
 bool QD3D12MipmapGenerator::create(QRhiD3D12 *rhiD)
 {
+    if (!QtD3D12ApiSupport::instance()->isAvailable())
+        return false;
+
     this->rhiD = rhiD;
 
     D3D12_ROOT_PARAMETER1 rootParams[3] = {};
@@ -2424,7 +2475,7 @@ bool QD3D12MipmapGenerator::create(QRhiD3D12 *rhiD)
     rsDesc.Desc_1_1.pStaticSamplers = &samplerDesc;
 
     ID3DBlob *signature = nullptr;
-    HRESULT hr = D3D12SerializeVersionedRootSignature(&rsDesc, &signature, nullptr);
+    HRESULT hr = QtD3D12ApiSupport::instance()->pD3D12SerializeVersionedRootSignature(&rsDesc, &signature, nullptr);
     if (FAILED(hr)) {
         qWarning("Failed to serialize root signature: %s", qPrintable(QSystemError::windowsComString(hr)));
         return false;
@@ -2433,8 +2484,7 @@ bool QD3D12MipmapGenerator::create(QRhiD3D12 *rhiD)
     hr = rhiD->dev->CreateRootSignature(0,
                                         signature->GetBufferPointer(),
                                         signature->GetBufferSize(),
-                                        __uuidof(ID3D12RootSignature),
-                                        reinterpret_cast<void **>(&rootSig));
+                                        IID_PPV_ARGS(&rootSig));
     signature->Release();
     if (FAILED(hr)) {
         qWarning("Failed to create root signature: %s",
@@ -2449,9 +2499,7 @@ bool QD3D12MipmapGenerator::create(QRhiD3D12 *rhiD)
     psoDesc.CS.pShaderBytecode = g_csMipmap;
     psoDesc.CS.BytecodeLength = sizeof(g_csMipmap);
     ID3D12PipelineState *pso = nullptr;
-    hr = rhiD->dev->CreateComputePipelineState(&psoDesc,
-                                               __uuidof(ID3D12PipelineState),
-                                               reinterpret_cast<void **>(&pso));
+    hr = rhiD->dev->CreateComputePipelineState(&psoDesc, IID_PPV_ARGS(&pso));
     if (FAILED(hr)) {
         qWarning("Failed to create compute pipeline state: %s",
                  qPrintable(QSystemError::windowsComString(hr)));
@@ -2774,8 +2822,7 @@ bool QRhiD3D12::startCommandListForCurrentFrameSlot(ID3D12GraphicsCommandList **
                                             D3D12_COMMAND_LIST_TYPE_DIRECT,
                                             cmdAlloc,
                                             nullptr,
-                                            __uuidof(ID3D12GraphicsCommandList),
-                                            reinterpret_cast<void **>(cmdList));
+                                            IID_PPV_ARGS(cmdList));
         if (FAILED(hr)) {
             qWarning("Failed to create command list: %s", qPrintable(QSystemError::windowsComString(hr)));
             return false;
@@ -3359,8 +3406,7 @@ bool QD3D12Buffer::create()
                                           resourceState,
                                           nullptr,
                                           &allocation,
-                                          __uuidof(resource),
-                                          reinterpret_cast<void **>(&resource));
+                                          IID_PPV_ARGS(&resource));
             if (FAILED(hr))
                 break;
             if (!m_objectName.isEmpty()) {
@@ -3619,8 +3665,7 @@ bool QD3D12RenderBuffer::create()
                                               D3D12_RESOURCE_STATE_RENDER_TARGET,
                                               &clearValue,
                                               &allocation,
-                                              __uuidof(ID3D12Resource),
-                                              reinterpret_cast<void **>(&resource));
+                                              IID_PPV_ARGS(&resource));
         if (FAILED(hr)) {
             qWarning("Failed to create color buffer: %s", qPrintable(QSystemError::windowsComString(hr)));
             return false;
@@ -3663,8 +3708,7 @@ bool QD3D12RenderBuffer::create()
                                               D3D12_RESOURCE_STATE_DEPTH_WRITE,
                                               &clearValue,
                                               &allocation,
-                                              __uuidof(ID3D12Resource),
-                                              reinterpret_cast<void **>(&resource));
+                                              IID_PPV_ARGS(&resource));
         if (FAILED(hr)) {
             qWarning("Failed to create depth-stencil buffer: %s", qPrintable(QSystemError::windowsComString(hr)));
             return false;
@@ -3994,8 +4038,7 @@ bool QD3D12Texture::create()
                                           D3D12_RESOURCE_STATE_COMMON,
                                           needsOptimizedClearValueSpecified ? &clearValue : nullptr,
                                           &allocation,
-                                          __uuidof(ID3D12Resource),
-                                          reinterpret_cast<void **>(&resource));
+                                          IID_PPV_ARGS(&resource));
     if (FAILED(hr)) {
         qWarning("Failed to create texture: '%s'"
                  " Dim was %d Size was %ux%u Depth/ArraySize was %u MipLevels was %u Format was %d Sample count was %d",
@@ -4550,6 +4593,9 @@ void QD3D12ShaderResourceBindings::visitStorageImage(QD3D12Stage s,
 QD3D12ObjectHandle QD3D12ShaderResourceBindings::createRootSignature(const QD3D12ShaderStageData *stageData,
                                                                      int stageCount)
 {
+    if (!QtD3D12ApiSupport::instance()->pD3D12SerializeVersionedRootSignature)
+        return {};
+
     QRHI_RES_RHI(QRhiD3D12);
 
     // It's not just that the root signature has to be tied to the pipeline
@@ -4636,7 +4682,7 @@ QD3D12ObjectHandle QD3D12ShaderResourceBindings::createRootSignature(const QD3D1
     rsDesc.Desc_1_1.Flags = D3D12_ROOT_SIGNATURE_FLAGS(rsFlags);
 
     ID3DBlob *signature = nullptr;
-    HRESULT hr = D3D12SerializeVersionedRootSignature(&rsDesc, &signature, nullptr);
+    HRESULT hr = QtD3D12ApiSupport::instance()->pD3D12SerializeVersionedRootSignature(&rsDesc, &signature, nullptr);
     if (FAILED(hr)) {
         qWarning("Failed to serialize root signature: %s", qPrintable(QSystemError::windowsComString(hr)));
         return {};
@@ -4645,8 +4691,7 @@ QD3D12ObjectHandle QD3D12ShaderResourceBindings::createRootSignature(const QD3D1
     hr = rhiD->dev->CreateRootSignature(0,
                                         signature->GetBufferPointer(),
                                         signature->GetBufferSize(),
-                                        __uuidof(ID3D12RootSignature),
-                                        reinterpret_cast<void **>(&rootSig));
+                                        IID_PPV_ARGS(&rootSig));
     signature->Release();
     if (FAILED(hr)) {
         qWarning("Failed to create root signature: %s", qPrintable(QSystemError::windowsComString(hr)));
@@ -5220,9 +5265,7 @@ bool QD3D12GraphicsPipeline::create()
     psoDesc.SampleDesc = sampleDesc;
 
     ID3D12PipelineState *pso = nullptr;
-    HRESULT hr = rhiD->dev->CreateGraphicsPipelineState(&psoDesc,
-                                                        __uuidof(ID3D12PipelineState),
-                                                       reinterpret_cast<void **>(&pso));
+    HRESULT hr = rhiD->dev->CreateGraphicsPipelineState(&psoDesc, IID_PPV_ARGS(&pso));
     if (FAILED(hr)) {
         qWarning("Failed to create graphics pipeline state: %s",
                  qPrintable(QSystemError::windowsComString(hr)));
@@ -5326,9 +5369,7 @@ bool QD3D12ComputePipeline::create()
     psoDesc.CS.pShaderBytecode = shaderBytecode.constData();
     psoDesc.CS.BytecodeLength = shaderBytecode.size();
     ID3D12PipelineState *pso = nullptr;
-    HRESULT hr = rhiD->dev->CreateComputePipelineState(&psoDesc,
-                                                       __uuidof(ID3D12PipelineState),
-                                                       reinterpret_cast<void **>(&pso));
+    HRESULT hr = rhiD->dev->CreateComputePipelineState(&psoDesc, IID_PPV_ARGS(&pso));
     if (FAILED(hr)) {
         qWarning("Failed to create compute pipeline state: %s",
                  qPrintable(QSystemError::windowsComString(hr)));
@@ -5591,7 +5632,7 @@ static bool output6ForWindow(QWindow *w, IDXGIAdapter1 *adapter, IDXGIOutput6 **
         }
     }
     if (currentOutput) {
-        ok = SUCCEEDED(currentOutput->QueryInterface(__uuidof(IDXGIOutput6), reinterpret_cast<void **>(result)));
+        ok = SUCCEEDED(currentOutput->QueryInterface(IID_PPV_ARGS(result)));
         currentOutput->Release();
     }
     return ok;
@@ -5661,12 +5702,18 @@ static const DXGI_FORMAT DEFAULT_SRGB_FORMAT = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
 
 bool QRhiD3D12::ensureDirectCompositionDevice()
 {
+    if (!QtD3D12ApiSupport::instance()->pDCompositionCreateDevice) {
+        qWarning() << "DirectComposition is not available on current platform.";
+        return false;
+    }
+
     if (dcompDevice)
         return true;
 
     qCDebug(QRHI_LOG_INFO, "Creating Direct Composition device (needed for semi-transparent windows)");
 
-    HRESULT hr = DCompositionCreateDevice(nullptr, __uuidof(IDCompositionDevice), reinterpret_cast<void **>(&dcompDevice));
+    HRESULT hr = QtD3D12ApiSupport::instance()->pDCompositionCreateDevice(
+                nullptr, IID_PPV_ARGS(&dcompDevice));
     if (FAILED(hr)) {
         qWarning("Failed to Direct Composition device: %s", qPrintable(QSystemError::windowsComString(hr)));
         return false;
@@ -5805,7 +5852,7 @@ bool QD3D12SwapChain::createOrResize()
         }
 
         if (SUCCEEDED(hr)) {
-            if (FAILED(sourceSwapChain1->QueryInterface(__uuidof(IDXGISwapChain3), reinterpret_cast<void **>(&swapChain)))) {
+            if (FAILED(sourceSwapChain1->QueryInterface(IID_PPV_ARGS(&swapChain)))) {
                 qWarning("IDXGISwapChain3 not available");
                 return false;
             }
@@ -5839,8 +5886,7 @@ bool QD3D12SwapChain::createOrResize()
         for (int i = 0; i < QD3D12_FRAMES_IN_FLIGHT; ++i) {
             hr = rhiD->dev->CreateFence(0,
                                         D3D12_FENCE_FLAG_NONE,
-                                        __uuidof(ID3D12Fence),
-                                        reinterpret_cast<void **>(&frameRes[i].fence));
+                                        IID_PPV_ARGS(&frameRes[i].fence));
             if (FAILED(hr)) {
                 qWarning("Failed to create fence for swapchain: %s",
                          qPrintable(QSystemError::windowsComString(hr)));
@@ -5869,7 +5915,7 @@ bool QD3D12SwapChain::createOrResize()
 
     for (UINT i = 0; i < BUFFER_COUNT; ++i) {
         ID3D12Resource *colorBuffer;
-        hr = swapChain->GetBuffer(i, __uuidof(ID3D12Resource), reinterpret_cast<void **>(&colorBuffer));
+        hr = swapChain->GetBuffer(i, IID_PPV_ARGS(&colorBuffer));
         if (FAILED(hr)) {
             qWarning("Failed to get buffer %u for D3D12 swapchain: %s",
                      i, qPrintable(QSystemError::windowsComString(hr)));
@@ -5923,8 +5969,7 @@ bool QD3D12SwapChain::createOrResize()
                                                   D3D12_RESOURCE_STATE_RENDER_TARGET,
                                                   &clearValue,
                                                   &allocation,
-                                                  __uuidof(ID3D12Resource),
-                                                  reinterpret_cast<void **>(&resource));
+                                                  IID_PPV_ARGS(&resource));
             if (FAILED(hr)) {
                 qWarning("Failed to create MSAA color buffer: %s", qPrintable(QSystemError::windowsComString(hr)));
                 return false;
diff --git a/src/gui/text/windows/qwindowsdirectwritefontdatabase.cpp b/src/gui/text/windows/qwindowsdirectwritefontdatabase.cpp
index 6b4933cca7..eed71b6e94 100644
--- a/src/gui/text/windows/qwindowsdirectwritefontdatabase.cpp
+++ b/src/gui/text/windows/qwindowsdirectwritefontdatabase.cpp
@@ -107,8 +107,7 @@ void QWindowsDirectWriteFontDatabase::populateFamily(const QString &familyName)
             IDWriteFont *font;
             if (SUCCEEDED(matchingFonts->GetFont(j, &font))) {
                 IDWriteFont1 *font1 = nullptr;
-                if (!SUCCEEDED(font->QueryInterface(__uuidof(IDWriteFont1),
-                                                   reinterpret_cast<void **>(&font1)))) {
+                if (!SUCCEEDED(font->QueryInterface(IID_PPV_ARGS(&font1)))) {
                     qCWarning(lcQpaFonts) << "COM object does not support IDWriteFont1";
                     continue;
                 }
@@ -271,8 +270,7 @@ QStringList QWindowsDirectWriteFontDatabase::addApplicationFont(const QByteArray
 
     QStringList ret;
     IDWriteFontFace3 *face3 = nullptr;
-    if (SUCCEEDED(face->QueryInterface(__uuidof(IDWriteFontFace3),
-                                      reinterpret_cast<void **>(&face3)))) {
+    if (SUCCEEDED(face->QueryInterface(IID_PPV_ARGS(&face3)))) {
         QString defaultLocaleFamilyName;
         QString englishLocaleFamilyName;
 
diff --git a/src/gui/text/windows/qwindowsfontdatabase.cpp b/src/gui/text/windows/qwindowsfontdatabase.cpp
index 2de53be6a8..4e6ffa14f7 100644
--- a/src/gui/text/windows/qwindowsfontdatabase.cpp
+++ b/src/gui/text/windows/qwindowsfontdatabase.cpp
@@ -1188,8 +1188,7 @@ QFontEngine *QWindowsFontDatabase::createEngine(const QFontDef &request, const Q
                 bool isColorFont = false;
 #if QT_CONFIG(direct2d)
                 IDWriteFontFace2 *directWriteFontFace2 = nullptr;
-                if (SUCCEEDED(directWriteFontFace->QueryInterface(__uuidof(IDWriteFontFace2),
-                                                                  reinterpret_cast<void **>(&directWriteFontFace2)))) {
+                if (SUCCEEDED(directWriteFontFace->QueryInterface(IID_PPV_ARGS(&directWriteFontFace2)))) {
                     if (directWriteFontFace2->IsColorFont())
                         isColorFont = directWriteFontFace2->GetPaletteEntryCount() > 0;
 
diff --git a/src/gui/text/windows/qwindowsfontdatabasebase.cpp b/src/gui/text/windows/qwindowsfontdatabasebase.cpp
index f45678c65c..6f10517714 100644
--- a/src/gui/text/windows/qwindowsfontdatabasebase.cpp
+++ b/src/gui/text/windows/qwindowsfontdatabasebase.cpp
@@ -6,6 +6,7 @@
 
 #include <QtCore/QThreadStorage>
 #include <QtCore/QtEndian>
+#include <QtCore/private/qsystemlibrary_p.h>
 
 #if QT_CONFIG(directwrite)
 #  if QT_CONFIG(directwrite3)
@@ -546,17 +547,23 @@ bool QWindowsFontDatabaseBase::init(QSharedPointer<QWindowsFontEngineData> d)
 #if QT_CONFIG(directwrite) && QT_CONFIG(direct2d)
 void QWindowsFontDatabaseBase::createDirectWriteFactory(IDWriteFactory **factory)
 {
+    static const auto pDWriteCreateFactory =
+        reinterpret_cast<decltype(&::DWriteCreateFactory)>(
+            QSystemLibrary::resolve(u"dwrite"_s, "DWriteCreateFactory"));
+    if (!pDWriteCreateFactory)
+        return;
+
     *factory = nullptr;
     IUnknown *result = nullptr;
 
 #  if QT_CONFIG(directwrite3)
-    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory3), &result);
+    pDWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory3), &result);
 #  endif
     if (result == nullptr)
-        DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory2), &result);
+        pDWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory2), &result);
 
     if (result == nullptr) {
-        if (FAILED(DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory), &result))) {
+        if (FAILED(pDWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory), &result))) {
             qErrnoWarning("DWriteCreateFactory failed");
             return;
         }
@@ -685,7 +692,13 @@ QFont QWindowsFontDatabaseBase::systemDefaultFont()
     // Qt 6: Obtain default GUI font (typically "Segoe UI, 9pt", see QTBUG-58610)
     NONCLIENTMETRICS ncm = {};
     ncm.cbSize = sizeof(ncm);
-    SystemParametersInfoForDpi(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0, defaultVerticalDPI());
+    static const auto pSystemParametersInfoForDpi =
+        reinterpret_cast<decltype(&::SystemParametersInfoForDpi)>(
+            QSystemLibrary::resolve(u"user32"_s, "SystemParametersInfoForDpi"));
+    if (pSystemParametersInfoForDpi)
+        pSystemParametersInfoForDpi(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0, defaultVerticalDPI());
+    else
+        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0);
     const QFont systemFont = QWindowsFontDatabase::LOGFONT_to_QFont(ncm.lfMessageFont);
     qCDebug(lcQpaFonts) << __FUNCTION__ << systemFont;
     return systemFont;
diff --git a/src/gui/text/windows/qwindowsfontenginedirectwrite.cpp b/src/gui/text/windows/qwindowsfontenginedirectwrite.cpp
index 14dd064c33..026211c0a3 100644
--- a/src/gui/text/windows/qwindowsfontenginedirectwrite.cpp
+++ b/src/gui/text/windows/qwindowsfontenginedirectwrite.cpp
@@ -671,8 +671,7 @@ bool QWindowsFontEngineDirectWrite::supportsHorizontalSubPixelPositions() const
 QFontEngine::Properties QWindowsFontEngineDirectWrite::properties() const
 {
     IDWriteFontFace2 *directWriteFontFace2;
-    if (SUCCEEDED(m_directWriteFontFace->QueryInterface(__uuidof(IDWriteFontFace2),
-                                                        reinterpret_cast<void **>(&directWriteFontFace2)))) {
+    if (SUCCEEDED(m_directWriteFontFace->QueryInterface(IID_PPV_ARGS(&directWriteFontFace2)))) {
         DWRITE_FONT_METRICS1 metrics;
         directWriteFontFace2->GetMetrics(&metrics);
 
@@ -739,8 +738,7 @@ QImage QWindowsFontEngineDirectWrite::imageForGlyph(glyph_t t,
             : DWRITE_GRID_FIT_MODE_DEFAULT;
 
     IDWriteFactory2 *factory2 = nullptr;
-    HRESULT hr = m_fontEngineData->directWriteFactory->QueryInterface(__uuidof(IDWriteFactory2),
-                                                                      reinterpret_cast<void **>(&factory2));
+    HRESULT hr = m_fontEngineData->directWriteFactory->QueryInterface(IID_PPV_ARGS(&factory2));
     IDWriteGlyphRunAnalysis *glyphAnalysis = NULL;
     if (!SUCCEEDED(hr)) {
         qErrnoWarning(hr, "%s: Failed to query IDWriteFactory2 interface.", __FUNCTION__);
@@ -1063,8 +1061,7 @@ glyph_metrics_t QWindowsFontEngineDirectWrite::alphaMapBoundingBox(glyph_t glyph
             : DWRITE_GRID_FIT_MODE_DEFAULT;
 
     IDWriteFactory2 *factory2 = nullptr;
-    HRESULT hr = m_fontEngineData->directWriteFactory->QueryInterface(__uuidof(IDWriteFactory2),
-                                                                      reinterpret_cast<void **>(&factory2));
+    HRESULT hr = m_fontEngineData->directWriteFactory->QueryInterface(IID_PPV_ARGS(&factory2));
 
     IDWriteGlyphRunAnalysis *glyphAnalysis = NULL;
     if (SUCCEEDED(hr)) {
diff --git a/src/network/socket/qnativesocketengine_win.cpp b/src/network/socket/qnativesocketengine_win.cpp
index d578e5230f..98c72b8067 100644
--- a/src/network/socket/qnativesocketengine_win.cpp
+++ b/src/network/socket/qnativesocketengine_win.cpp
@@ -274,12 +274,31 @@ bool QNativeSocketEnginePrivate::createNewSocket(QAbstractSocket::SocketType soc
     // MSDN KB179942 states that on winnt 4 WSA_FLAG_OVERLAPPED is needed if socket is to be non
     // blocking and recommends always doing it for cross-windows-version compatibility.
 
-    // WSA_FLAG_NO_HANDLE_INHERIT is atomic (like linux O_CLOEXEC)
+    // WSA_FLAG_NO_HANDLE_INHERIT is atomic (like linux O_CLOEXEC), but requires windows 7 SP 1 or later
+    // SetHandleInformation is supported since W2K but isn't atomic
 #ifndef WSA_FLAG_NO_HANDLE_INHERIT
 #define WSA_FLAG_NO_HANDLE_INHERIT 0x80
 #endif
 
     SOCKET socket = ::WSASocket(protocol, type, 0, NULL, 0, WSA_FLAG_NO_HANDLE_INHERIT | WSA_FLAG_OVERLAPPED);
+    // previous call fails if the windows 7 service pack 1 or hot fix isn't installed.
+
+    // Try the old API if the new one failed on Windows 7
+    if (socket == INVALID_SOCKET && !QOperatingSystemVersion::isWin8OrGreater()) {
+        socket = ::WSASocket(protocol, type, 0, NULL, 0, WSA_FLAG_OVERLAPPED);
+#ifdef HANDLE_FLAG_INHERIT
+        if (socket != INVALID_SOCKET) {
+            // make non inheritable the old way
+            BOOL handleFlags = SetHandleInformation(reinterpret_cast<HANDLE>(socket), HANDLE_FLAG_INHERIT, 0);
+#  ifdef QNATIVESOCKETENGINE_DEBUG
+            qDebug() << "QNativeSocketEnginePrivate::createNewSocket - set inheritable" << handleFlags;
+#  else // !QNATIVESOCKETENGINE_DEBUG
+            Q_UNUSED(handleFlags);
+#  endif // QNATIVESOCKETENGINE_DEBUG
+        }
+#endif // HANDLE_FLAG_INHERIT
+    }
+
     if (socket == INVALID_SOCKET) {
         int err = WSAGetLastError();
         WS_ERROR_DEBUG(err);
diff --git a/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp b/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp
index 5b0a91df3e..ec2207f833 100644
--- a/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp
+++ b/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp
@@ -5,6 +5,7 @@
 #include <QtCore/private/qsystemerror_p.h>
 
 #include <QtCore/qpointer.h>
+#include <QtCore/qoperatingsystemversion.h>
 
 #include <mutex>
 
@@ -100,20 +101,22 @@ bool QNetworkListManagerEvents::start()
     }
 
 #if QT_CONFIG(cpp_winrt)
-    using namespace winrt::Windows::Networking::Connectivity;
-    using winrt::Windows::Foundation::IInspectable;
-    // Register for changes in the network and store a token to unregister later:
-    token = NetworkInformation::NetworkStatusChanged(
-            [owner = QPointer(this)](const IInspectable sender) {
-                Q_UNUSED(sender);
-                if (owner) {
-                    std::scoped_lock locker(owner->winrtLock);
-                    if (owner->token)
-                        owner->emitWinRTUpdates();
-                }
-            });
-    // Emit initial state
-    emitWinRTUpdates();
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        using namespace winrt::Windows::Networking::Connectivity;
+        using winrt::Windows::Foundation::IInspectable;
+        // Register for changes in the network and store a token to unregister later:
+        token = NetworkInformation::NetworkStatusChanged(
+                [owner = QPointer(this)](const IInspectable sender) {
+                    Q_UNUSED(sender);
+                    if (owner) {
+                        std::scoped_lock locker(owner->winrtLock);
+                        if (owner->token)
+                            owner->emitWinRTUpdates();
+                    }
+                });
+        // Emit initial state
+        emitWinRTUpdates();
+    }
 #endif
 
     return true;
@@ -132,13 +135,15 @@ void QNetworkListManagerEvents::stop()
     // Even if we fail we should still try to unregister from winrt events:
 
 #if QT_CONFIG(cpp_winrt)
-    // Try to synchronize unregistering with potentially in-progress callbacks
-    std::scoped_lock locker(winrtLock);
-    if (token) {
-        using namespace winrt::Windows::Networking::Connectivity;
-        // Pass the token we stored earlier to unregister:
-        NetworkInformation::NetworkStatusChanged(token);
-        token = {};
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        // Try to synchronize unregistering with potentially in-progress callbacks
+        std::scoped_lock locker(winrtLock);
+        if (token) {
+            using namespace winrt::Windows::Networking::Connectivity;
+            // Pass the token we stored earlier to unregister:
+            NetworkInformation::NetworkStatusChanged(token);
+            token = {};
+        }
     }
 #endif
 }
@@ -189,6 +194,9 @@ using namespace winrt::Windows::Networking::Connectivity;
 [[nodiscard]]
 QNetworkInformation::TransportMedium getTransportMedium(const ConnectionProfile &profile)
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return QNetworkInformation::TransportMedium::Unknown;
+
     if (profile.IsWwanConnectionProfile())
         return QNetworkInformation::TransportMedium::Cellular;
     if (profile.IsWlanConnectionProfile())
@@ -222,6 +230,8 @@ QNetworkInformation::TransportMedium getTransportMedium(const ConnectionProfile
 
 [[nodiscard]] bool getMetered(const ConnectionProfile &profile)
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return false;
     ConnectionCost cost(nullptr);
     try {
         cost = profile.GetConnectionCost();
@@ -237,6 +247,8 @@ QNetworkInformation::TransportMedium getTransportMedium(const ConnectionProfile
 
 void QNetworkListManagerEvents::emitWinRTUpdates()
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return;
     using namespace winrt::Windows::Networking::Connectivity;
     ConnectionProfile profile = nullptr;
     try {
diff --git a/src/plugins/platforms/CMakeLists.txt b/src/plugins/platforms/CMakeLists.txt
index bcf29dedd1..4095e3f023 100644
--- a/src/plugins/platforms/CMakeLists.txt
+++ b/src/plugins/platforms/CMakeLists.txt
@@ -4,12 +4,6 @@
 if(ANDROID)
     add_subdirectory(android)
 endif()
-if(NOT ANDROID AND NOT WASM)
-    add_subdirectory(minimal)
-endif()
-if(QT_FEATURE_freetype AND NOT ANDROID AND NOT WASM)
-    add_subdirectory(offscreen)
-endif()
 if(QT_FEATURE_xcb)
     add_subdirectory(xcb)
 endif()
@@ -22,9 +16,6 @@ endif()
 if(WIN32)
     add_subdirectory(windows)
 endif()
-if(QT_FEATURE_direct2d1_1 AND QT_FEATURE_directwrite)
-    add_subdirectory(direct2d)
-endif()
 if(QNX)
     add_subdirectory(qnx)
 endif()
diff --git a/src/plugins/platforms/windows/CMakeLists.txt b/src/plugins/platforms/windows/CMakeLists.txt
index 33ccbf6a0a..4422629ec8 100644
--- a/src/plugins/platforms/windows/CMakeLists.txt
+++ b/src/plugins/platforms/windows/CMakeLists.txt
@@ -49,7 +49,6 @@ qt_internal_add_plugin(QWindowsIntegrationPlugin
         Qt::Gui
         Qt::GuiPrivate
         advapi32
-        dwmapi
         gdi32
         imm32
         ole32
@@ -60,10 +59,7 @@ qt_internal_add_plugin(QWindowsIntegrationPlugin
         winmm
         winspool
         wtsapi32
-        shcore
         comdlg32
-        d3d9
-        runtimeobject
 )
 
 # Resources:
@@ -189,6 +185,8 @@ qt_internal_extend_target(QWindowsIntegrationPlugin CONDITION QT_FEATURE_accessi
         uiautomation/qwindowsuiautils.cpp uiautomation/qwindowsuiautils.h
         uiautomation/qwindowsuiavalueprovider.cpp uiautomation/qwindowsuiavalueprovider.h
         uiautomation/qwindowsuiawindowprovider.cpp uiautomation/qwindowsuiawindowprovider.h
+    LIBRARIES
+        uiautomationcore
 )
 
 qt_internal_extend_target(QWindowsIntegrationPlugin CONDITION MINGW AND QT_FEATURE_accessibility
diff --git a/src/plugins/platforms/windows/qwin10helpers.cpp b/src/plugins/platforms/windows/qwin10helpers.cpp
index 026e81cb0c..e17d2bc20d 100644
--- a/src/plugins/platforms/windows/qwin10helpers.cpp
+++ b/src/plugins/platforms/windows/qwin10helpers.cpp
@@ -4,6 +4,8 @@
 #include "qwin10helpers.h"
 
 #include <QtCore/qdebug.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 #include <winstring.h>
 #include <roapi.h>
 
@@ -60,29 +62,62 @@ public:
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
+struct QComBaseApi
+{
+    decltype(&::RoGetActivationFactory) pRoGetActivationFactory = nullptr;
+    decltype(&::WindowsCreateStringReference) pWindowsCreateStringReference = nullptr;
+
+    static QComBaseApi *instance()
+    {
+        static QComBaseApi api;
+        return &api;
+    }
+
+private:
+    Q_DISABLE_COPY_MOVE(QComBaseApi)
+
+    explicit QComBaseApi()
+    {
+        QSystemLibrary comBase(u"combase"_s);
+        pRoGetActivationFactory = reinterpret_cast<decltype(pRoGetActivationFactory)>(comBase.resolve("RoGetActivationFactory"));
+        pWindowsCreateStringReference = reinterpret_cast<decltype(pWindowsCreateStringReference)>(comBase.resolve("WindowsCreateStringReference"));
+    }
+
+    ~QComBaseApi() = default;
+};
+
 // Return tablet mode, note: Does not work for GetDesktopWindow().
 bool qt_windowsIsTabletMode(HWND hwnd)
 {
+    if (!QComBaseApi::instance()->pRoGetActivationFactory ||
+        !QComBaseApi::instance()->pWindowsCreateStringReference) {
+        return false;
+    }
+
     bool result = false;
 
     const wchar_t uiViewSettingsId[] = L"Windows.UI.ViewManagement.UIViewSettings";
     HSTRING_HEADER uiViewSettingsIdRefHeader;
     HSTRING uiViewSettingsIdHs = nullptr;
     const auto uiViewSettingsIdLen = UINT32(sizeof(uiViewSettingsId) / sizeof(uiViewSettingsId[0]) - 1);
-    if (FAILED(WindowsCreateStringReference(uiViewSettingsId, uiViewSettingsIdLen, &uiViewSettingsIdRefHeader, &uiViewSettingsIdHs)))
+    if (FAILED(QComBaseApi::instance()->pWindowsCreateStringReference(uiViewSettingsId, uiViewSettingsIdLen, &uiViewSettingsIdRefHeader, &uiViewSettingsIdHs)))
         return false;
 
     IUIViewSettingsInterop *uiViewSettingsInterop = nullptr;
     // __uuidof(IUIViewSettingsInterop);
-    const GUID uiViewSettingsInteropRefId = {0x3694dbf9, 0x8f68, 0x44be,{0x8f, 0xf5, 0x19, 0x5c, 0x98, 0xed, 0xe8, 0xa6}};
+    static constexpr const GUID uiViewSettingsInteropRefId =
+        {0x3694dbf9, 0x8f68, 0x44be,{0x8f, 0xf5, 0x19, 0x5c, 0x98, 0xed, 0xe8, 0xa6}};
 
-    HRESULT hr = RoGetActivationFactory(uiViewSettingsIdHs, uiViewSettingsInteropRefId,
+    HRESULT hr = QComBaseApi::instance()->pRoGetActivationFactory(uiViewSettingsIdHs, uiViewSettingsInteropRefId,
                                                    reinterpret_cast<void **>(&uiViewSettingsInterop));
     if (FAILED(hr))
         return false;
 
     //  __uuidof(ABI::Windows::UI::ViewManagement::IUIViewSettings);
-    const GUID uiViewSettingsRefId = {0xc63657f6, 0x8850, 0x470d,{0x88, 0xf8, 0x45, 0x5e, 0x16, 0xea, 0x2c, 0x26}};
+    static constexpr const GUID uiViewSettingsRefId =
+        {0xc63657f6, 0x8850, 0x470d,{0x88, 0xf8, 0x45, 0x5e, 0x16, 0xea, 0x2c, 0x26}};
     ABI::Windows::UI::ViewManagement::IUIViewSettings *viewSettings = nullptr;
     hr = uiViewSettingsInterop->GetForWindow(hwnd, uiViewSettingsRefId,
                                              reinterpret_cast<void **>(&viewSettings));
diff --git a/src/plugins/platforms/windows/qwindowsapplication.cpp b/src/plugins/platforms/windows/qwindowsapplication.cpp
index f823a69552..0cb0f82a55 100644
--- a/src/plugins/platforms/windows/qwindowsapplication.cpp
+++ b/src/plugins/platforms/windows/qwindowsapplication.cpp
@@ -12,6 +12,7 @@
 
 #include <QtCore/qvariant.h>
 #include <QtCore/private/qfunctions_win_p.h>
+#include <QtCore/qoperatingsystemversion.h>
 
 #include <QtGui/qpalette.h>
 
@@ -173,11 +174,12 @@ void QWindowsApplication::lightSystemPalette(QPalette &result) const
     QColor accent = getSysColor(COLOR_HIGHLIGHT);
 
 #if QT_CONFIG(cpp_winrt)
-    // respect the Windows 11 accent color
-    using namespace winrt::Windows::UI::ViewManagement;
-    const auto settings = UISettings();
-
-    accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+    if (QOperatingSystemVersion::isWin10RS5OrGreater()) {
+        // Respect the accent color on modern Windows.
+        using namespace winrt::Windows::UI::ViewManagement;
+        const auto settings = UISettings();
+        accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+    }
 #endif
 
     const QColor btnFace = background;
diff --git a/src/plugins/platforms/windows/qwindowscontext.cpp b/src/plugins/platforms/windows/qwindowscontext.cpp
index 7fe5b2592c..41d45ed41d 100644
--- a/src/plugins/platforms/windows/qwindowscontext.cpp
+++ b/src/plugins/platforms/windows/qwindowscontext.cpp
@@ -204,7 +204,8 @@ QWindowsContext::~QWindowsContext()
     unregisterWindowClasses();
     if (d->m_oleInitializeResult == S_OK || d->m_oleInitializeResult == S_FALSE) {
 #ifdef QT_USE_FACTORY_CACHE_REGISTRATION
-        detail::QWinRTFactoryCacheRegistration::clearAllCaches();
+        if (QOperatingSystemVersion::isWin10OrGreater())
+            detail::QWinRTFactoryCacheRegistration::clearAllCaches();
 #endif
         OleUninitialize();
     }
@@ -279,6 +280,9 @@ bool QWindowsContext::initPointer(unsigned integrationOptions)
     if (integrationOptions & QWindowsIntegration::DontUseWMPointer)
         return false;
 
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     d->m_systemInfo |= QWindowsContext::SI_SupportsPointer;
     return true;
 }
@@ -349,18 +353,27 @@ void QWindowsContext::setDetectAltGrModifier(bool a)
 [[nodiscard]] static inline QtWindows::DpiAwareness
     dpiAwarenessContextToQtDpiAwareness(DPI_AWARENESS_CONTEXT context)
 {
+    if (!QWindowsApi::instance()->pIsValidDpiAwarenessContext
+            || !QWindowsApi::instance()->pAreDpiAwarenessContextsEqual) {
+        return QtWindows::DpiAwareness::Invalid;
+    }
     // IsValidDpiAwarenessContext() will handle the NULL pointer case.
-    if (!IsValidDpiAwarenessContext(context))
+    if (!QWindowsApi::instance()->pIsValidDpiAwarenessContext(context))
         return QtWindows::DpiAwareness::Invalid;
-    if (AreDpiAwarenessContextsEqual(context, DPI_AWARENESS_CONTEXT_UNAWARE_GDISCALED))
+    if (QWindowsApi::instance()->pAreDpiAwarenessContextsEqual(
+                context, DPI_AWARENESS_CONTEXT_UNAWARE_GDISCALED))
         return QtWindows::DpiAwareness::Unaware_GdiScaled;
-    if (AreDpiAwarenessContextsEqual(context, DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2))
+    if (QWindowsApi::instance()->pAreDpiAwarenessContextsEqual(
+                context, DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2))
         return QtWindows::DpiAwareness::PerMonitorVersion2;
-    if (AreDpiAwarenessContextsEqual(context, DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE))
+    if (QWindowsApi::instance()->pAreDpiAwarenessContextsEqual(
+                context, DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE))
         return QtWindows::DpiAwareness::PerMonitor;
-    if (AreDpiAwarenessContextsEqual(context, DPI_AWARENESS_CONTEXT_SYSTEM_AWARE))
+    if (QWindowsApi::instance()->pAreDpiAwarenessContextsEqual(
+                context, DPI_AWARENESS_CONTEXT_SYSTEM_AWARE))
         return QtWindows::DpiAwareness::System;
-    if (AreDpiAwarenessContextsEqual(context, DPI_AWARENESS_CONTEXT_UNAWARE))
+    if (QWindowsApi::instance()->pAreDpiAwarenessContextsEqual(
+                context, DPI_AWARENESS_CONTEXT_UNAWARE))
         return QtWindows::DpiAwareness::Unaware;
     return QtWindows::DpiAwareness::Invalid;
 }
@@ -369,8 +382,28 @@ QtWindows::DpiAwareness QWindowsContext::windowDpiAwareness(HWND hwnd)
 {
     if (!hwnd)
         return QtWindows::DpiAwareness::Invalid;
-    const auto context = GetWindowDpiAwarenessContext(hwnd);
-    return dpiAwarenessContextToQtDpiAwareness(context);
+    if (QWindowsApi::instance()->pGetWindowDpiAwarenessContext) {
+        const auto context = QWindowsApi::instance()->pGetWindowDpiAwarenessContext(hwnd);
+        return dpiAwarenessContextToQtDpiAwareness(context);
+    }
+    qCWarning(lcQpaWindow) << "Current platform doesn't support querying DPI awareness "
+                              "mode for a specific window, using current process's DPI "
+                              "awareness mode instead.";
+    return processDpiAwareness();
+}
+
+[[nodiscard]] static inline QtWindows::DpiAwareness
+    processDpiAwarenessToQtDpiAwareness(PROCESS_DPI_AWARENESS pda)
+{
+    switch (pda) {
+    case PROCESS_DPI_UNAWARE:
+        return QtWindows::DpiAwareness::Unaware;
+    case PROCESS_SYSTEM_DPI_AWARE:
+        return QtWindows::DpiAwareness::System;
+    case PROCESS_PER_MONITOR_DPI_AWARE:
+        return QtWindows::DpiAwareness::PerMonitor;
+    }
+    return QtWindows::DpiAwareness::Invalid;
 }
 
 QtWindows::DpiAwareness QWindowsContext::processDpiAwareness()
@@ -382,8 +415,25 @@ QtWindows::DpiAwareness QWindowsContext::processDpiAwareness()
     // return the default DPI_AWARENESS_CONTEXT for the process if
     // SetThreadDpiAwarenessContext() was never called. So we can use
     // it as an equivalent.
-    const auto context = GetThreadDpiAwarenessContext();
-    return dpiAwarenessContextToQtDpiAwareness(context);
+    if (QWindowsApi::instance()->pGetThreadDpiAwarenessContext) {
+        const auto context = QWindowsApi::instance()->pGetThreadDpiAwarenessContext();
+        return dpiAwarenessContextToQtDpiAwareness(context);
+    }
+    if (QWindowsApi::instance()->pGetProcessDpiAwareness) {
+        PROCESS_DPI_AWARENESS pda = PROCESS_DPI_UNAWARE;
+        const HRESULT hr = QWindowsApi::instance()->pGetProcessDpiAwareness(nullptr, &pda);
+        if (SUCCEEDED(hr)) {
+            return processDpiAwarenessToQtDpiAwareness(pda);
+        } else {
+            qCWarning(lcQpaWindow).nospace().noquote()
+                    << "GetProcessDpiAwareness() failed: "
+                    << QSystemError::windowsComString(hr);
+        }
+    }
+    if (IsProcessDPIAware()) {
+        return QtWindows::DpiAwareness::System;
+    }
+    return QtWindows::DpiAwareness::Unaware;
 }
 
 [[nodiscard]] static inline DPI_AWARENESS_CONTEXT
@@ -436,24 +486,67 @@ QDebug operator<<(QDebug d, QtWindows::DpiAwareness dpiAwareness)
 }
 #endif
 
+[[nodiscard]] static inline PROCESS_DPI_AWARENESS
+    qtDpiAwarenessToProcessDpiAwareness(QtWindows::DpiAwareness awareness)
+{
+    switch (awareness) {
+    case QtWindows::DpiAwareness::Invalid:
+        return PROCESS_DPI_AWARENESS(-1);
+    case QtWindows::DpiAwareness::Unaware:
+    case QtWindows::DpiAwareness::Unaware_GdiScaled:
+        return PROCESS_DPI_UNAWARE;
+    case QtWindows::DpiAwareness::System:
+        return PROCESS_SYSTEM_DPI_AWARE;
+    case QtWindows::DpiAwareness::PerMonitor:
+    case QtWindows::DpiAwareness::PerMonitorVersion2:
+        return PROCESS_PER_MONITOR_DPI_AWARE;
+    }
+    return PROCESS_DPI_AWARENESS(-1);
+}
+
 bool QWindowsContext::setProcessDpiAwareness(QtWindows::DpiAwareness dpiAwareness)
 {
     qCDebug(lcQpaWindow) << __FUNCTION__ << dpiAwareness;
     if (processDpiAwareness() == dpiAwareness)
         return true;
-    const auto context = qtDpiAwarenessToDpiAwarenessContext(dpiAwareness);
-    if (!IsValidDpiAwarenessContext(context)) {
-        qCWarning(lcQpaWindow) << dpiAwareness << "is not supported by current system.";
-        return false;
+    if (QWindowsApi::instance()->pIsValidDpiAwarenessContext
+            && QWindowsApi::instance()->pSetProcessDpiAwarenessContext) {
+        const auto context = qtDpiAwarenessToDpiAwarenessContext(dpiAwareness);
+        if (!QWindowsApi::instance()->pIsValidDpiAwarenessContext(context)) {
+            qCWarning(lcQpaWindow) << dpiAwareness << "is not supported by current system.";
+            return false;
+        }
+        if (!QWindowsApi::instance()->pSetProcessDpiAwarenessContext(context)) {
+            qCWarning(lcQpaWindow).noquote().nospace()
+                << "SetProcessDpiAwarenessContext() failed: "
+                << QSystemError::windowsString()
+                << "\nQt's default DPI awareness context is "
+                << "DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2. If you know what you "
+                << "are doing, you can overwrite this default using qt.conf "
+                << "(https://doc.qt.io/qt-6/highdpi.html#configuring-windows).";
+            return false;
+        }
+        return true;
+    }
+    if (QWindowsApi::instance()->pSetProcessDpiAwareness) {
+        const PROCESS_DPI_AWARENESS pda = qtDpiAwarenessToProcessDpiAwareness(dpiAwareness);
+        if (int(pda) == -1) {
+            qCWarning(lcQpaWindow).nospace().noquote()
+                    << "Failed to retrieve the current process's DPI awareness mode.";
+            return false;
+        }
+        const HRESULT hr = QWindowsApi::instance()->pSetProcessDpiAwareness(pda);
+        if (FAILED(hr)) {
+            qCWarning(lcQpaWindow).nospace().noquote()
+                    << "SetProcessDpiAwareness() failed: "
+                    << QSystemError::windowsComString(hr);
+            return false;
+        }
+        return true;
     }
-    if (!SetProcessDpiAwarenessContext(context)) {
-        qCWarning(lcQpaWindow).noquote().nospace()
-            << "SetProcessDpiAwarenessContext() failed: "
-            << QSystemError::windowsString()
-            << "\nQt's default DPI awareness context is "
-            << "DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2. If you know what you "
-            << "are doing, you can overwrite this default using qt.conf "
-            << "(https://doc.qt.io/qt-6/highdpi.html#configuring-windows).";
+    if (!SetProcessDPIAware()) {
+        qCWarning(lcQpaWindow).nospace().noquote()
+                << "SetProcessDPIAware() failed: " << QSystemError::windowsString();
         return false;
     }
     QWindowsContextPrivate::m_v2DpiAware
@@ -886,8 +979,8 @@ void QWindowsContext::forceNcCalcSize(HWND hwnd)
 bool QWindowsContext::systemParametersInfo(unsigned action, unsigned param, void *out,
                                            unsigned dpi)
 {
-    const BOOL result = dpi != 0
-        ? SystemParametersInfoForDpi(action, param, out, 0, dpi)
+    const BOOL result = (dpi != 0) && (QWindowsApi::instance()->pSystemParametersInfoForDpi != nullptr)
+        ? QWindowsApi::instance()->pSystemParametersInfoForDpi(action, param, out, 0, dpi)
         : SystemParametersInfo(action, param, out, 0);
     return result == TRUE;
 }
@@ -934,7 +1027,8 @@ bool QWindowsContext::shouldHaveNonClientDpiScaling(const QWindow *window)
     if (QWindowsContextPrivate::m_v2DpiAware)
         return true;
 
-    return window->isTopLevel()
+    return QOperatingSystemVersion::isWin10OrGreater()
+        && window->isTopLevel()
         && !window->property(QWindowsWindow::embeddedNativeParentHandleProperty).isValid()
 #if QT_CONFIG(opengl) // /QTBUG-62901, EnableNonClientDpiScaling has problems with GL
         && (window->surfaceType() != QSurface::OpenGLSurface
@@ -973,9 +1067,11 @@ static inline bool isInputMessage(UINT m)
 // Note: This only works within WM_NCCREATE
 static bool enableNonClientDpiScaling(HWND hwnd)
 {
+    if (!QWindowsApi::instance()->pEnableNonClientDpiScaling)
+        return false;
     bool result = false;
     if (QWindowsContext::windowDpiAwareness(hwnd) == QtWindows::DpiAwareness::PerMonitor) {
-        result = EnableNonClientDpiScaling(hwnd) != FALSE;
+        result = QWindowsApi::instance()->pEnableNonClientDpiScaling(hwnd) != FALSE;
         if (!result) {
             const DWORD errorCode = GetLastError();
             qErrnoWarning(int(errorCode), "EnableNonClientDpiScaling() failed for HWND %p (%lu)",
@@ -1596,4 +1692,137 @@ bool QWindowsContext::filterNativeEvent(QWindow *window, MSG *msg, LRESULT *resu
     return false;
 }
 
+UINT QWindowsContext::getDpiForWindow(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    if (QWindowsApi::instance()->pGetDpiForWindow)
+        return QWindowsApi::instance()->pGetDpiForWindow(hWnd);
+    if (const HDC hdc = GetDC(hWnd)) {
+        const int dpiX = GetDeviceCaps(hdc, LOGPIXELSX);
+        ReleaseDC(hWnd, hdc);
+        if (dpiX > 0)
+            return dpiX;
+    }
+    return 0;
+}
+
+UINT QWindowsContext::getDpiForMonitor(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    if (QWindowsApi::instance()->pGetDpiForMonitor) {
+        UINT dpiX = 0;
+        UINT dpiY = 0;
+        const HRESULT hr = QWindowsApi::instance()->pGetDpiForMonitor(hMonitor, MDT_EFFECTIVE_DPI, &dpiX, &dpiY);
+        if (SUCCEEDED(hr) && (dpiX > 0))
+            return dpiX;
+    }
+    MONITORINFOEXW monitorInfo;
+    SecureZeroMemory(&monitorInfo, sizeof(monitorInfo));
+    monitorInfo.cbSize = sizeof(monitorInfo);
+    GetMonitorInfoW(hMonitor, &monitorInfo);
+    if (const HDC hdc = CreateDCW(monitorInfo.szDevice, monitorInfo.szDevice, nullptr, nullptr)) {
+        const int dpiX = GetDeviceCaps(hdc, LOGPIXELSX);
+        DeleteDC(hdc);
+        if (dpiX > 0)
+            return dpiX;
+    }
+    return 0;
+}
+
+UINT QWindowsContext::getDpiForPrimaryMonitor()
+{
+    if (const HMONITOR hMonitor = MonitorFromWindow(GetDesktopWindow(), MONITOR_DEFAULTTOPRIMARY))
+        return getDpiForMonitor(hMonitor);
+    return 0;
+}
+
+UINT QWindowsContext::getMostPossibleDpiForWindow(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    UINT dpi = getDpiForWindow(hWnd);
+    if (dpi > 0)
+        return dpi;
+    if (const HMONITOR hMonitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTONEAREST)) {
+        dpi = getDpiForMonitor(hMonitor);
+        if (dpi > 0)
+            return dpi;
+    }
+    dpi = getDpiForPrimaryMonitor();
+    if (dpi > 0)
+        return dpi;
+    return USER_DEFAULT_SCREEN_DPI;
+}
+
+UINT QWindowsContext::getMostPossibleDpiForMonitor(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    UINT dpi = getDpiForMonitor(hMonitor);
+    if (dpi > 0)
+        return dpi;
+    dpi = getDpiForPrimaryMonitor();
+    if (dpi > 0)
+        return dpi;
+    return USER_DEFAULT_SCREEN_DPI;
+}
+
+int QWindowsContext::getResizeBorderThicknessForDpi(const UINT dpi)
+{
+    // The thickness of the padded border will always be 0 if DWM composition is disabled.
+    if (QWindowsApi::instance()->pGetSystemMetricsForDpi) {
+        return QWindowsApi::instance()->pGetSystemMetricsForDpi(SM_CXSIZEFRAME, dpi)
+            + QWindowsApi::instance()->pGetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi);
+    }
+    return GetSystemMetrics(SM_CXSIZEFRAME) + GetSystemMetrics(SM_CXPADDEDBORDER);
+}
+
+int QWindowsContext::getResizeBorderThickness(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    return getResizeBorderThicknessForDpi(getMostPossibleDpiForWindow(hWnd));
+}
+
+int QWindowsContext::getResizeBorderThickness(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    return getResizeBorderThicknessForDpi(getMostPossibleDpiForMonitor(hMonitor));
+}
+
+int QWindowsContext::getTitleBarHeightForDpi(const UINT dpi)
+{
+    const int border = getResizeBorderThicknessForDpi(dpi);
+    if (QWindowsApi::instance()->pGetSystemMetricsForDpi) {
+        return border +
+            QWindowsApi::instance()->pGetSystemMetricsForDpi(SM_CYCAPTION, dpi);
+    }
+    return border + GetSystemMetrics(SM_CYCAPTION);
+}
+
+int QWindowsContext::getTitleBarHeight(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    return getTitleBarHeightForDpi(getMostPossibleDpiForWindow(hWnd));
+}
+
+int QWindowsContext::getTitleBarHeight(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    return getTitleBarHeightForDpi(getMostPossibleDpiForMonitor(hMonitor));
+}
+
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/windows/qwindowscontext.h b/src/plugins/platforms/windows/qwindowscontext.h
index 1a3b47be5e..408ac39529 100644
--- a/src/plugins/platforms/windows/qwindowscontext.h
+++ b/src/plugins/platforms/windows/qwindowscontext.h
@@ -10,13 +10,18 @@
 #include <QtCore/qscopedpointer.h>
 #include <QtCore/qsharedpointer.h>
 #include <QtCore/qloggingcategory.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 
 #define STRICT_TYPED_ITEMIDS
 #include <shlobj.h>
 #include <shlwapi.h>
+#include <shellscalingapi.h>
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 Q_DECLARE_LOGGING_CATEGORY(lcQpaWindow)
 Q_DECLARE_LOGGING_CATEGORY(lcQpaEvents)
 Q_DECLARE_LOGGING_CATEGORY(lcQpaGl)
@@ -44,6 +49,119 @@ class QPoint;
 class QKeyEvent;
 class QPointingDevice;
 
+struct QWindowsApi
+{
+    decltype(&::GetDpiForWindow) pGetDpiForWindow = nullptr;
+    decltype(&::GetDpiForMonitor) pGetDpiForMonitor = nullptr;
+    decltype(&::SystemParametersInfoForDpi) pSystemParametersInfoForDpi = nullptr;
+    decltype(&::GetSystemMetricsForDpi) pGetSystemMetricsForDpi = nullptr;
+    decltype(&::AdjustWindowRectExForDpi) pAdjustWindowRectExForDpi = nullptr;
+    decltype(&::GetProcessDpiAwareness) pGetProcessDpiAwareness = nullptr;
+    decltype(&::SetProcessDpiAwareness) pSetProcessDpiAwareness = nullptr;
+    decltype(&::SetProcessDpiAwarenessContext) pSetProcessDpiAwarenessContext = nullptr;
+    decltype(&::EnableNonClientDpiScaling) pEnableNonClientDpiScaling = nullptr;
+    decltype(&::GetAwarenessFromDpiAwarenessContext) pGetAwarenessFromDpiAwarenessContext = nullptr;
+    decltype(&::GetWindowDpiAwarenessContext) pGetWindowDpiAwarenessContext = nullptr;
+    decltype(&::GetThreadDpiAwarenessContext) pGetThreadDpiAwarenessContext = nullptr;
+    decltype(&::AreDpiAwarenessContextsEqual) pAreDpiAwarenessContextsEqual = nullptr;
+    decltype(&::GetPointerType) pGetPointerType = nullptr;
+    decltype(&::GetPointerInfo) pGetPointerInfo = nullptr;
+    decltype(&::GetPointerFrameTouchInfo) pGetPointerFrameTouchInfo = nullptr;
+    decltype(&::GetPointerFrameTouchInfoHistory) pGetPointerFrameTouchInfoHistory = nullptr;
+    decltype(&::GetPointerPenInfo) pGetPointerPenInfo = nullptr;
+    decltype(&::GetPointerPenInfoHistory) pGetPointerPenInfoHistory = nullptr;
+    decltype(&::SkipPointerFrameMessages) pSkipPointerFrameMessages = nullptr;
+    decltype(&::GetPointerDeviceRects) pGetPointerDeviceRects = nullptr;
+    decltype(&::SetDisplayAutoRotationPreferences) pSetDisplayAutoRotationPreferences = nullptr;
+    decltype(&::GetDisplayAutoRotationPreferences) pGetDisplayAutoRotationPreferences = nullptr;
+    decltype(&::RegisterTouchWindow) pRegisterTouchWindow = nullptr;
+    decltype(&::UnregisterTouchWindow) pUnregisterTouchWindow = nullptr;
+    decltype(&::IsTouchWindow) pIsTouchWindow = nullptr;
+    decltype(&::GetDisplayConfigBufferSizes) pGetDisplayConfigBufferSizes = nullptr;
+    decltype(&::QueryDisplayConfig) pQueryDisplayConfig = nullptr;
+    decltype(&::DisplayConfigGetDeviceInfo) pDisplayConfigGetDeviceInfo = nullptr;
+    decltype(&::GetTouchInputInfo) pGetTouchInputInfo = nullptr;
+    decltype(&::CloseTouchInputHandle) pCloseTouchInputHandle = nullptr;
+    decltype(&::ChangeWindowMessageFilterEx) pChangeWindowMessageFilterEx = nullptr;
+    decltype(&::Shell_NotifyIconGetRect) pShell_NotifyIconGetRect = nullptr;
+    decltype(&::IsValidDpiAwarenessContext) pIsValidDpiAwarenessContext = nullptr;
+
+    static QWindowsApi *instance()
+    {
+        static QWindowsApi api;
+        return &api;
+    }
+
+    bool supportsPointerApi() const
+    {
+        return pGetPointerType && pGetPointerInfo && pGetPointerFrameTouchInfo
+            && pGetPointerFrameTouchInfoHistory && pGetPointerPenInfo
+            && pGetPointerPenInfoHistory && pSkipPointerFrameMessages
+            && pGetPointerDeviceRects;
+    }
+
+private:
+    Q_DISABLE_COPY_MOVE(QWindowsApi)
+
+    explicit QWindowsApi()
+    {
+        if (QOperatingSystemVersion::isWin7OrGreater()) {
+            QSystemLibrary shell32(u"shell32"_s);
+            pShell_NotifyIconGetRect = reinterpret_cast<decltype(pShell_NotifyIconGetRect)>(shell32.resolve("Shell_NotifyIconGetRect"));
+
+            QSystemLibrary user32(u"user32"_s);
+            pRegisterTouchWindow = reinterpret_cast<decltype(pRegisterTouchWindow)>(user32.resolve("RegisterTouchWindow"));
+            pUnregisterTouchWindow = reinterpret_cast<decltype(pUnregisterTouchWindow)>(user32.resolve("UnregisterTouchWindow"));
+            pIsTouchWindow = reinterpret_cast<decltype(pIsTouchWindow)>(user32.resolve("IsTouchWindow"));
+            pGetDisplayConfigBufferSizes = reinterpret_cast<decltype(pGetDisplayConfigBufferSizes)>(user32.resolve("GetDisplayConfigBufferSizes"));
+            pQueryDisplayConfig = reinterpret_cast<decltype(pQueryDisplayConfig)>(user32.resolve("QueryDisplayConfig"));
+            pDisplayConfigGetDeviceInfo = reinterpret_cast<decltype(pDisplayConfigGetDeviceInfo)>(user32.resolve("DisplayConfigGetDeviceInfo"));
+            pGetTouchInputInfo = reinterpret_cast<decltype(pGetTouchInputInfo)>(user32.resolve("GetTouchInputInfo"));
+            pCloseTouchInputHandle = reinterpret_cast<decltype(pCloseTouchInputHandle)>(user32.resolve("CloseTouchInputHandle"));
+            pChangeWindowMessageFilterEx = reinterpret_cast<decltype(pChangeWindowMessageFilterEx)>(user32.resolve("ChangeWindowMessageFilterEx"));
+
+            if (QOperatingSystemVersion::isWin8OrGreater()) {
+                pGetPointerType = reinterpret_cast<decltype(pGetPointerType)>(user32.resolve("GetPointerType"));
+                pGetPointerInfo = reinterpret_cast<decltype(pGetPointerInfo)>(user32.resolve("GetPointerInfo"));
+                pGetPointerFrameTouchInfo = reinterpret_cast<decltype(pGetPointerFrameTouchInfo)>(user32.resolve("GetPointerFrameTouchInfo"));
+                pGetPointerFrameTouchInfoHistory = reinterpret_cast<decltype(pGetPointerFrameTouchInfoHistory)>(user32.resolve("GetPointerFrameTouchInfoHistory"));
+                pGetPointerPenInfo = reinterpret_cast<decltype(pGetPointerPenInfo)>(user32.resolve("GetPointerPenInfo"));
+                pGetPointerPenInfoHistory = reinterpret_cast<decltype(pGetPointerPenInfoHistory)>(user32.resolve("GetPointerPenInfoHistory"));
+                pSkipPointerFrameMessages = reinterpret_cast<decltype(pSkipPointerFrameMessages)>(user32.resolve("SkipPointerFrameMessages"));
+                pGetPointerDeviceRects = reinterpret_cast<decltype(pGetPointerDeviceRects)>(user32.resolve("GetPointerDeviceRects"));
+                pSetDisplayAutoRotationPreferences = reinterpret_cast<decltype(pSetDisplayAutoRotationPreferences)>(user32.resolve("SetDisplayAutoRotationPreferences"));
+                pGetDisplayAutoRotationPreferences = reinterpret_cast<decltype(pGetDisplayAutoRotationPreferences)>(user32.resolve("GetDisplayAutoRotationPreferences"));
+
+                if (QOperatingSystemVersion::isWin8Point1OrGreater()) {
+                    QSystemLibrary shcore(u"shcore"_s);
+                    pGetDpiForMonitor = reinterpret_cast<decltype(pGetDpiForMonitor)>(shcore.resolve("GetDpiForMonitor"));
+                    pGetProcessDpiAwareness = reinterpret_cast<decltype(pGetProcessDpiAwareness)>(shcore.resolve("GetProcessDpiAwareness"));
+                    pSetProcessDpiAwareness = reinterpret_cast<decltype(pSetProcessDpiAwareness)>(shcore.resolve("SetProcessDpiAwareness"));
+
+                    if (QOperatingSystemVersion::isWin10RS1OrGreater()) {
+                        pGetDpiForWindow = reinterpret_cast<decltype(pGetDpiForWindow)>(user32.resolve("GetDpiForWindow"));
+                        pSystemParametersInfoForDpi = reinterpret_cast<decltype(pSystemParametersInfoForDpi)>(user32.resolve("SystemParametersInfoForDpi"));
+                        pGetSystemMetricsForDpi = reinterpret_cast<decltype(pGetSystemMetricsForDpi)>(user32.resolve("GetSystemMetricsForDpi"));
+                        pAdjustWindowRectExForDpi = reinterpret_cast<decltype(pAdjustWindowRectExForDpi)>(user32.resolve("AdjustWindowRectExForDpi"));
+                        pEnableNonClientDpiScaling = reinterpret_cast<decltype(pEnableNonClientDpiScaling)>(user32.resolve("EnableNonClientDpiScaling"));
+                        pGetAwarenessFromDpiAwarenessContext = reinterpret_cast<decltype(pGetAwarenessFromDpiAwarenessContext)>(user32.resolve("GetAwarenessFromDpiAwarenessContext"));
+                        pGetWindowDpiAwarenessContext = reinterpret_cast<decltype(pGetWindowDpiAwarenessContext)>(user32.resolve("GetWindowDpiAwarenessContext"));
+                        pGetThreadDpiAwarenessContext = reinterpret_cast<decltype(pGetThreadDpiAwarenessContext)>(user32.resolve("GetThreadDpiAwarenessContext"));
+                        pAreDpiAwarenessContextsEqual = reinterpret_cast<decltype(pAreDpiAwarenessContextsEqual)>(user32.resolve("AreDpiAwarenessContextsEqual"));
+                        pIsValidDpiAwarenessContext = reinterpret_cast<decltype(pIsValidDpiAwarenessContext)>(user32.resolve("IsValidDpiAwarenessContext"));
+
+                        if (QOperatingSystemVersion::isWin10RS2OrGreater()) {
+                            pSetProcessDpiAwarenessContext = reinterpret_cast<decltype(pSetProcessDpiAwarenessContext)>(user32.resolve("SetProcessDpiAwarenessContext"));
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    ~QWindowsApi() = default;
+};
+
 class QWindowsContext
 {
     Q_DISABLE_COPY_MOVE(QWindowsContext)
@@ -159,6 +277,18 @@ public:
     static bool filterNativeEvent(MSG *msg, LRESULT *result);
     static bool filterNativeEvent(QWindow *window, MSG *msg, LRESULT *result);
 
+    [[nodiscard]] static UINT getDpiForWindow(const HWND hWnd);
+    [[nodiscard]] static UINT getDpiForMonitor(const HMONITOR hMonitor);
+    [[nodiscard]] static UINT getDpiForPrimaryMonitor();
+    [[nodiscard]] static UINT getMostPossibleDpiForWindow(const HWND hWnd);
+    [[nodiscard]] static UINT getMostPossibleDpiForMonitor(const HMONITOR hMonitor);
+    [[nodiscard]] static int getResizeBorderThicknessForDpi(const UINT dpi);
+    [[nodiscard]] static int getResizeBorderThickness(const HWND hWnd);
+    [[nodiscard]] static int getResizeBorderThickness(const HMONITOR hMonitor);
+    [[nodiscard]] static int getTitleBarHeightForDpi(const UINT dpi);
+    [[nodiscard]] static int getTitleBarHeight(const HWND hWnd);
+    [[nodiscard]] static int getTitleBarHeight(const HMONITOR hMonitor);
+
 private:
     void handleFocusEvent(QtWindows::WindowsEventType et, QWindowsWindow *w);
 #ifndef QT_NO_CONTEXTMENU
diff --git a/src/plugins/platforms/windows/qwindowsdrag.cpp b/src/plugins/platforms/windows/qwindowsdrag.cpp
index 93205259f8..9f5f73588c 100644
--- a/src/plugins/platforms/windows/qwindowsdrag.cpp
+++ b/src/plugins/platforms/windows/qwindowsdrag.cpp
@@ -664,12 +664,13 @@ static HRESULT startDoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
                 return ::DoDragDrop(pDataObj, pDropSource, dwOKEffects, pdwEffect);
             }
 
-            if (msg.message == WM_POINTERUPDATE) {
+            static const bool pointerApiSupported = QWindowsApi::instance()->supportsPointerApi();
+            if (msg.message == WM_POINTERUPDATE && pointerApiSupported) {
 
                 const quint32 pointerId = GET_POINTERID_WPARAM(msg.wParam);
 
                 POINTER_INFO pointerInfo{};
-                if (!GetPointerInfo(pointerId, &pointerInfo))
+                if (!QWindowsApi::instance()->pGetPointerInfo(pointerId, &pointerInfo))
                     return E_FAIL;
 
                 if (pointerInfo.pointerFlags & POINTER_FLAG_PRIMARY) {
@@ -713,7 +714,7 @@ static HRESULT startDoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
                 // Handle other messages.
                 qWindowsWndProc(msg.hwnd, msg.message, msg.wParam, msg.lParam);
 
-                if (msg.message == WM_POINTERLEAVE)
+                if (msg.message == WM_POINTERLEAVE && pointerApiSupported)
                     return E_FAIL;
             }
         } else {
diff --git a/src/plugins/platforms/windows/qwindowsintegration.cpp b/src/plugins/platforms/windows/qwindowsintegration.cpp
index 628b2f3209..24a7f0a60e 100644
--- a/src/plugins/platforms/windows/qwindowsintegration.cpp
+++ b/src/plugins/platforms/windows/qwindowsintegration.cpp
@@ -222,8 +222,12 @@ void QWindowsIntegrationPrivate::parseOptions(QWindowsIntegration *q, const QStr
     initOpenGlBlacklistResources();
 
     static bool dpiAwarenessSet = false;
+    static const bool hasDpiAwarenessContext =
+            QWindowsApi::instance()->pSetProcessDpiAwarenessContext != nullptr;
     // Default to per-monitor-v2 awareness (if available)
-    QtWindows::DpiAwareness dpiAwareness = QtWindows::DpiAwareness::PerMonitorVersion2;
+    QtWindows::DpiAwareness dpiAwareness = hasDpiAwarenessContext
+            ? QtWindows::DpiAwareness::PerMonitorVersion2
+            : QtWindows::DpiAwareness::PerMonitor;
 
     int tabletAbsoluteRange = -1;
     DarkModeHandling darkModeHandling = DarkModeHandlingFlag::DarkModeWindowFrames
@@ -242,7 +246,11 @@ void QWindowsIntegrationPrivate::parseOptions(QWindowsIntegration *q, const QStr
 
     if (!dpiAwarenessSet) { // Set only once in case of repeated instantiations of QGuiApplication.
         if (!QCoreApplication::testAttribute(Qt::AA_PluginApplication)) {
-            m_context.setProcessDpiAwareness(dpiAwareness);
+            for (auto i = int(dpiAwareness); i != int(QtWindows::DpiAwareness::Invalid); --i) {
+                if (m_context.setProcessDpiAwareness(QtWindows::DpiAwareness(i))) {
+                    break;
+                }
+            }
             qCDebug(lcQpaWindow) << "DpiAwareness=" << dpiAwareness
                 << "effective process DPI awareness=" << QWindowsContext::processDpiAwareness();
         }
diff --git a/src/plugins/platforms/windows/qwindowskeymapper.cpp b/src/plugins/platforms/windows/qwindowskeymapper.cpp
index 3089e745d4..fa961110d7 100644
--- a/src/plugins/platforms/windows/qwindowskeymapper.cpp
+++ b/src/plugins/platforms/windows/qwindowskeymapper.cpp
@@ -749,21 +749,10 @@ static inline QString messageKeyText(const MSG &msg)
     return ch.isNull() ? QString() : QString(ch);
 }
 
-[[nodiscard]] static inline int getTitleBarHeight(const HWND hwnd)
-{
-    const UINT dpi = GetDpiForWindow(hwnd);
-    const int captionHeight = GetSystemMetricsForDpi(SM_CYCAPTION, dpi);
-    if (IsZoomed(hwnd))
-        return captionHeight;
-    // The frame height should also be taken into account if the window
-    // is not maximized.
-    const int frameHeight = GetSystemMetricsForDpi(SM_CYSIZEFRAME, dpi)
-                            + GetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi);
-    return captionHeight + frameHeight;
-}
-
 [[nodiscard]] static inline bool isSystemMenuOffsetNeeded(const Qt::WindowFlags flags)
 {
+    if (qEnvironmentVariableIntValue("QT_WINDOWS_SYSTEM_MENU_NEED_OFFSET"))
+        return true;
     static constexpr const Qt::WindowFlags titleBarHints =
         Qt::WindowMinMaxButtonsHint | Qt::WindowCloseButtonHint | Qt::WindowContextHelpButtonHint;
     return (flags & Qt::WindowSystemMenuHint) && (flags & Qt::WindowTitleHint) && !(flags & titleBarHints)
@@ -804,7 +793,8 @@ static void showSystemMenu(QWindow* w)
 #undef disabled
 
     const QPoint pos = QHighDpi::toNativePixels(topLevel->geometry().topLeft(), topLevel);
-    const int titleBarOffset = isSystemMenuOffsetNeeded(topLevel->flags()) ? getTitleBarHeight(topLevelHwnd) : 0;
+    const int titleBarOffset = isSystemMenuOffsetNeeded(topLevel->flags())
+        ? QWindowsContext::getTitleBarHeight(topLevelHwnd) : 0;
     const int ret = TrackPopupMenuEx(menu,
                                TPM_LEFTALIGN | TPM_TOPALIGN | TPM_NONOTIFY | TPM_RETURNCMD,
                                pos.x(), pos.y() + titleBarOffset,
diff --git a/src/plugins/platforms/windows/qwindowsmousehandler.cpp b/src/plugins/platforms/windows/qwindowsmousehandler.cpp
index ceb33f6141..1e8188ba18 100644
--- a/src/plugins/platforms/windows/qwindowsmousehandler.cpp
+++ b/src/plugins/platforms/windows/qwindowsmousehandler.cpp
@@ -565,6 +565,11 @@ bool QWindowsMouseHandler::translateTouchEvent(QWindow *window, HWND,
     using QTouchPoint = QWindowSystemInterface::TouchPoint;
     using QTouchPointList = QList<QWindowSystemInterface::TouchPoint>;
 
+    if (!QWindowsApi::instance()->pGetTouchInputInfo
+            || !QWindowsApi::instance()->pCloseTouchInputHandle) {
+        return true;
+    }
+
     if (!QWindowsContext::instance()->initTouch()) {
         qWarning("Unable to initialize touch handling.");
         return true;
@@ -584,7 +589,7 @@ bool QWindowsMouseHandler::translateTouchEvent(QWindow *window, HWND,
     touchPoints.reserve(winTouchPointCount);
     QEventPoint::States allStates;
 
-    GetTouchInputInfo(reinterpret_cast<HTOUCHINPUT>(msg.lParam),
+    QWindowsApi::instance()->pGetTouchInputInfo(reinterpret_cast<HTOUCHINPUT>(msg.lParam),
                       UINT(msg.wParam), winTouchInputs.get(), sizeof(TOUCHINPUT));
     for (int i = 0; i < winTouchPointCount; ++i) {
         const TOUCHINPUT &winTouchInput = winTouchInputs[i];
@@ -626,7 +631,7 @@ bool QWindowsMouseHandler::translateTouchEvent(QWindow *window, HWND,
         touchPoints.append(touchPoint);
     }
 
-    CloseTouchInputHandle(reinterpret_cast<HTOUCHINPUT>(msg.lParam));
+    QWindowsApi::instance()->pCloseTouchInputHandle(reinterpret_cast<HTOUCHINPUT>(msg.lParam));
 
     // all touch points released, forget the ids we've seen, they may not be reused
     if (allStates == QEventPoint::State::Released)
diff --git a/src/plugins/platforms/windows/qwindowsopengltester.cpp b/src/plugins/platforms/windows/qwindowsopengltester.cpp
index 6a790bcc1b..b03bcc1bf5 100644
--- a/src/plugins/platforms/windows/qwindowsopengltester.cpp
+++ b/src/plugins/platforms/windows/qwindowsopengltester.cpp
@@ -65,7 +65,11 @@ private:
 
 QDirect3D9Handle::QDirect3D9Handle()
 {
-    m_direct3D9 = Direct3DCreate9(D3D_SDK_VERSION);
+    static const auto pDirect3DCreate9 =
+        reinterpret_cast<decltype(&::Direct3DCreate9)>(
+            QSystemLibrary::resolve(u"d3d9"_s, "Direct3DCreate9"));
+    if (pDirect3DCreate9)
+        m_direct3D9 = pDirect3DCreate9(D3D_SDK_VERSION);
 }
 
 QDirect3D9Handle::~QDirect3D9Handle()
diff --git a/src/plugins/platforms/windows/qwindowspointerhandler.cpp b/src/plugins/platforms/windows/qwindowspointerhandler.cpp
index 88f02347b3..75226c3810 100644
--- a/src/plugins/platforms/windows/qwindowspointerhandler.cpp
+++ b/src/plugins/platforms/windows/qwindowspointerhandler.cpp
@@ -45,10 +45,13 @@ QWindowsPointerHandler::~QWindowsPointerHandler()
 
 bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, QtWindows::WindowsEventType et, MSG msg, LRESULT *result)
 {
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     *result = 0;
     const quint32 pointerId = GET_POINTERID_WPARAM(msg.wParam);
 
-    if (!GetPointerType(pointerId, &m_pointerType)) {
+    if (!QWindowsApi::instance()->pGetPointerType(pointerId, &m_pointerType)) {
         qWarning() << "GetPointerType() failed:" << qt_error_string();
         return false;
     }
@@ -62,12 +65,12 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
     }
     case QT_PT_TOUCH: {
         quint32 pointerCount = 0;
-        if (!GetPointerFrameTouchInfo(pointerId, &pointerCount, nullptr)) {
+        if (!QWindowsApi::instance()->pGetPointerFrameTouchInfo(pointerId, &pointerCount, nullptr)) {
             qWarning() << "GetPointerFrameTouchInfo() failed:" << qt_error_string();
             return false;
         }
         QVarLengthArray<POINTER_TOUCH_INFO, 10> touchInfo(pointerCount);
-        if (!GetPointerFrameTouchInfo(pointerId, &pointerCount, touchInfo.data())) {
+        if (!QWindowsApi::instance()->pGetPointerFrameTouchInfo(pointerId, &pointerCount, touchInfo.data())) {
             qWarning() << "GetPointerFrameTouchInfo() failed:" << qt_error_string();
             return false;
         }
@@ -80,7 +83,7 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
         // dispatch any skipped frames if event compression is disabled by the app
         if (historyCount > 1 && !QCoreApplication::testAttribute(Qt::AA_CompressHighFrequencyEvents)) {
             touchInfo.resize(pointerCount * historyCount);
-            if (!GetPointerFrameTouchInfoHistory(pointerId,
+            if (!QWindowsApi::instance()->pGetPointerFrameTouchInfoHistory(pointerId,
                                                  &historyCount,
                                                  &pointerCount,
                                                  touchInfo.data())) {
@@ -101,7 +104,7 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
     }
     case QT_PT_PEN: {
         POINTER_PEN_INFO penInfo;
-        if (!GetPointerPenInfo(pointerId, &penInfo)) {
+        if (!QWindowsApi::instance()->pGetPointerPenInfo(pointerId, &penInfo)) {
             qWarning() << "GetPointerPenInfo() failed:" << qt_error_string();
             return false;
         }
@@ -113,7 +116,7 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
                 || !QCoreApplication::testAttribute(Qt::AA_CompressTabletEvents))) {
             QVarLengthArray<POINTER_PEN_INFO, 10> penInfoHistory(historyCount);
 
-            if (!GetPointerPenInfoHistory(pointerId, &historyCount, penInfoHistory.data())) {
+            if (!QWindowsApi::instance()->pGetPointerPenInfoHistory(pointerId, &historyCount, penInfoHistory.data())) {
                 qWarning() << "GetPointerPenInfoHistory() failed:" << qt_error_string();
                 return false;
             }
@@ -419,6 +422,9 @@ bool QWindowsPointerHandler::translateTouchEvent(QWindow *window, HWND hwnd,
 {
     Q_UNUSED(hwnd);
 
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     auto *touchInfo = static_cast<POINTER_TOUCH_INFO *>(vTouchInfo);
 
     if (et & QtWindows::NonClientEventFlag)
@@ -517,7 +523,7 @@ bool QWindowsPointerHandler::translateTouchEvent(QWindow *window, HWND hwnd,
         inputIds.insert(touchPoint.id);
 
         // Avoid getting repeated messages for this frame if there are multiple pointerIds
-        SkipPointerFrameMessages(touchInfo[i].pointerInfo.pointerId);
+        QWindowsApi::instance()->pSkipPointerFrameMessages(touchInfo[i].pointerInfo.pointerId);
     }
 
     // Some devices send touches for each finger in a different message/frame, instead of consolidating
@@ -557,13 +563,16 @@ bool QWindowsPointerHandler::translatePenEvent(QWindow *window, HWND hwnd, QtWin
                                                MSG msg, PVOID vPenInfo)
 {
 #if QT_CONFIG(tabletevent)
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     if (et & QtWindows::NonClientEventFlag)
         return false; // Let DefWindowProc() handle Non Client messages.
 
     auto *penInfo = static_cast<POINTER_PEN_INFO *>(vPenInfo);
 
     RECT pRect, dRect;
-    if (!GetPointerDeviceRects(penInfo->pointerInfo.sourceDevice, &pRect, &dRect))
+    if (!QWindowsApi::instance()->pGetPointerDeviceRects(penInfo->pointerInfo.sourceDevice, &pRect, &dRect))
         return false;
 
     const auto systemId = (qint64)penInfo->pointerInfo.sourceDevice;
diff --git a/src/plugins/platforms/windows/qwindowsscreen.cpp b/src/plugins/platforms/windows/qwindowsscreen.cpp
index f15a7a870d..a513ec937d 100644
--- a/src/plugins/platforms/windows/qwindowsscreen.cpp
+++ b/src/plugins/platforms/windows/qwindowsscreen.cpp
@@ -26,22 +26,14 @@ QT_BEGIN_NAMESPACE
 
 using namespace Qt::StringLiterals;
 
-static inline QDpi deviceDPI(HDC hdc)
-{
-    return QDpi(GetDeviceCaps(hdc, LOGPIXELSX), GetDeviceCaps(hdc, LOGPIXELSY));
-}
-
-static inline QDpi monitorDPI(HMONITOR hMonitor)
-{
-    UINT dpiX;
-    UINT dpiY;
-    if (SUCCEEDED(GetDpiForMonitor(hMonitor, MDT_EFFECTIVE_DPI, &dpiX, &dpiY)))
-        return QDpi(dpiX, dpiY);
-    return {0, 0};
-}
-
 static bool getPathInfo(const MONITORINFOEX &viewInfo, DISPLAYCONFIG_PATH_INFO *pathInfo)
 {
+    if (!QWindowsApi::instance()->pGetDisplayConfigBufferSizes
+            || !QWindowsApi::instance()->pQueryDisplayConfig
+            || !QWindowsApi::instance()->pDisplayConfigGetDeviceInfo) {
+        return false;
+    }
+
     // We might want to consider storing adapterId/id from DISPLAYCONFIG_PATH_TARGET_INFO.
     std::vector<DISPLAYCONFIG_PATH_INFO> pathInfos;
     std::vector<DISPLAYCONFIG_MODE_INFO> modeInfos;
@@ -54,14 +46,15 @@ static bool getPathInfo(const MONITORINFOEX &viewInfo, DISPLAYCONFIG_PATH_INFO *
         // QueryDisplayConfig documentation doesn't say the number of needed elements is updated
         // when the call fails with ERROR_INSUFFICIENT_BUFFER, so we need a separate call to
         // look up the needed buffer sizes.
-        if (GetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &numPathArrayElements,
-                                        &numModeInfoArrayElements) != ERROR_SUCCESS) {
+        if (QWindowsApi::instance()->pGetDisplayConfigBufferSizes(
+                QDC_ONLY_ACTIVE_PATHS, &numPathArrayElements, &numModeInfoArrayElements) != ERROR_SUCCESS) {
             return false;
         }
         pathInfos.resize(numPathArrayElements);
         modeInfos.resize(numModeInfoArrayElements);
-        result = QueryDisplayConfig(QDC_ONLY_ACTIVE_PATHS, &numPathArrayElements, pathInfos.data(),
-                                    &numModeInfoArrayElements, modeInfos.data(), nullptr);
+        result = QWindowsApi::instance()->pQueryDisplayConfig(
+                    QDC_ONLY_ACTIVE_PATHS, &numPathArrayElements, pathInfos.data(),
+                    &numModeInfoArrayElements, modeInfos.data(), nullptr);
     } while (result == ERROR_INSUFFICIENT_BUFFER);
 
     if (result != ERROR_SUCCESS)
@@ -74,7 +67,7 @@ static bool getPathInfo(const MONITORINFOEX &viewInfo, DISPLAYCONFIG_PATH_INFO *
         deviceName.header.size = sizeof(DISPLAYCONFIG_SOURCE_DEVICE_NAME);
         deviceName.header.adapterId = pathInfos[p].sourceInfo.adapterId;
         deviceName.header.id = pathInfos[p].sourceInfo.id;
-        if (DisplayConfigGetDeviceInfo(&deviceName.header) == ERROR_SUCCESS) {
+        if (QWindowsApi::instance()->pDisplayConfigGetDeviceInfo(&deviceName.header) == ERROR_SUCCESS) {
             if (wcscmp(viewInfo.szDevice, deviceName.viewGdiDeviceName) == 0) {
                 *pathInfo = pathInfos[p];
                 return true;
@@ -89,8 +82,9 @@ static bool getPathInfo(const MONITORINFOEX &viewInfo, DISPLAYCONFIG_PATH_INFO *
 // Needed later for HDR support
 static float getMonitorSDRWhiteLevel(DISPLAYCONFIG_PATH_TARGET_INFO *targetInfo)
 {
-    const float defaultSdrWhiteLevel = 200.0;
-    if (!targetInfo)
+    static constexpr const float defaultSdrWhiteLevel = 200.0;
+
+    if (!QWindowsApi::instance()->pDisplayConfigGetDeviceInfo || !targetInfo)
         return defaultSdrWhiteLevel;
 
     DISPLAYCONFIG_SDR_WHITE_LEVEL whiteLevel = {};
@@ -98,7 +92,7 @@ static float getMonitorSDRWhiteLevel(DISPLAYCONFIG_PATH_TARGET_INFO *targetInfo)
     whiteLevel.header.size = sizeof(DISPLAYCONFIG_SDR_WHITE_LEVEL);
     whiteLevel.header.adapterId = targetInfo->adapterId;
     whiteLevel.header.id = targetInfo->id;
-    if (DisplayConfigGetDeviceInfo(&whiteLevel.header) != ERROR_SUCCESS)
+    if (QWindowsApi::instance()->pDisplayConfigGetDeviceInfo(&whiteLevel.header) != ERROR_SUCCESS)
         return defaultSdrWhiteLevel;
     return whiteLevel.SDRWhiteLevel * 80.0 / 1000.0;
 }
@@ -126,7 +120,7 @@ static bool monitorData(HMONITOR hMonitor, QWindowsScreenData *data)
         deviceName.header.size = sizeof(DISPLAYCONFIG_TARGET_DEVICE_NAME);
         deviceName.header.adapterId = pathInfo.targetInfo.adapterId;
         deviceName.header.id = pathInfo.targetInfo.id;
-        if (DisplayConfigGetDeviceInfo(&deviceName.header) == ERROR_SUCCESS)
+        if (QWindowsApi::instance()->pDisplayConfigGetDeviceInfo(&deviceName.header) == ERROR_SUCCESS)
             data->name = QString::fromWCharArray(deviceName.monitorFriendlyDeviceName);
     }
     if (data->name.isEmpty())
@@ -135,8 +129,8 @@ static bool monitorData(HMONITOR hMonitor, QWindowsScreenData *data)
         data->flags |= QWindowsScreenData::LockScreen;
     } else {
         if (const HDC hdc = CreateDC(info.szDevice, nullptr, nullptr, nullptr)) {
-            const QDpi dpi = monitorDPI(hMonitor);
-            data->dpi = dpi.first > 0 ? dpi : deviceDPI(hdc);
+            const UINT dpi = QWindowsContext::getMostPossibleDpiForMonitor(hMonitor);
+            data->dpi = QDpi(dpi, dpi);
             data->depth = GetDeviceCaps(hdc, BITSPIXEL);
             data->format = data->depth == 16 ? QImage::Format_RGB16 : QImage::Format_RGB32;
             data->physicalSizeMM = QSizeF(GetDeviceCaps(hdc, HORZSIZE), GetDeviceCaps(hdc, VERTSIZE));
@@ -424,7 +418,8 @@ QRect QWindowsScreen::virtualGeometry(const QPlatformScreen *screen) // cf QScre
 
 bool QWindowsScreen::setOrientationPreference(Qt::ScreenOrientation o)
 {
-    bool result = false;
+    if (!QWindowsApi::instance()->pSetDisplayAutoRotationPreferences)
+        return false;
     ORIENTATION_PREFERENCE orientationPreference = ORIENTATION_PREFERENCE_NONE;
     switch (o) {
     case Qt::PrimaryOrientation:
@@ -442,33 +437,29 @@ bool QWindowsScreen::setOrientationPreference(Qt::ScreenOrientation o)
         orientationPreference = ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED;
         break;
     }
-    result = SetDisplayAutoRotationPreferences(orientationPreference);
-    return result;
+    return QWindowsApi::instance()->pSetDisplayAutoRotationPreferences(orientationPreference);
 }
 
 Qt::ScreenOrientation QWindowsScreen::orientationPreference()
 {
-    Qt::ScreenOrientation result = Qt::PrimaryOrientation;
+    if (!QWindowsApi::instance()->pGetDisplayAutoRotationPreferences)
+        return Qt::PrimaryOrientation;
     ORIENTATION_PREFERENCE orientationPreference = ORIENTATION_PREFERENCE_NONE;
-    if (GetDisplayAutoRotationPreferences(&orientationPreference)) {
+    if (QWindowsApi::instance()->pGetDisplayAutoRotationPreferences(&orientationPreference)) {
         switch (orientationPreference) {
         case ORIENTATION_PREFERENCE_NONE:
-            break;
+            return Qt::PrimaryOrientation;
         case ORIENTATION_PREFERENCE_LANDSCAPE:
-            result = Qt::LandscapeOrientation;
-            break;
+            return Qt::LandscapeOrientation;
         case ORIENTATION_PREFERENCE_PORTRAIT:
-            result = Qt::PortraitOrientation;
-            break;
+            return Qt::PortraitOrientation;
         case ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED:
-            result = Qt::InvertedLandscapeOrientation;
-            break;
+            return Qt::InvertedLandscapeOrientation;
         case ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED:
-            result = Qt::InvertedPortraitOrientation;
-            break;
+            return Qt::InvertedPortraitOrientation;
         }
     }
-    return result;
+    return Qt::PrimaryOrientation;
 }
 
 /*!
diff --git a/src/plugins/platforms/windows/qwindowssystemtrayicon.cpp b/src/plugins/platforms/windows/qwindowssystemtrayicon.cpp
index 3bad237f9e..7a9b2c5b07 100644
--- a/src/plugins/platforms/windows/qwindowssystemtrayicon.cpp
+++ b/src/plugins/platforms/windows/qwindowssystemtrayicon.cpp
@@ -184,13 +184,16 @@ void QWindowsSystemTrayIcon::updateToolTip(const QString &tooltip)
 
 QRect QWindowsSystemTrayIcon::geometry() const
 {
+    if (!QWindowsApi::instance()->pShell_NotifyIconGetRect)
+        return {};
     NOTIFYICONIDENTIFIER nid;
     memset(&nid, 0, sizeof(nid));
     nid.cbSize = sizeof(nid);
     nid.hWnd = m_hwnd;
     nid.uID = q_uNOTIFYICONID;
     RECT rect;
-    const QRect result = SUCCEEDED(Shell_NotifyIconGetRect(&nid, &rect))
+    const QRect result =
+        SUCCEEDED(QWindowsApi::instance()->pShell_NotifyIconGetRect(&nid, &rect))
         ? QRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top)
         : QRect();
     qCDebug(lcQpaTrayIcon) << __FUNCTION__ << this << "returns" << result;
@@ -272,7 +275,8 @@ bool QWindowsSystemTrayIcon::ensureInstalled()
     if (!MYWM_TASKBARCREATED)
         MYWM_TASKBARCREATED = RegisterWindowMessage(L"TaskbarCreated");
     // Allow the WM_TASKBARCREATED message through the UIPI filter
-    ChangeWindowMessageFilterEx(m_hwnd, MYWM_TASKBARCREATED, MSGFLT_ALLOW, nullptr);
+    if (QWindowsApi::instance()->pChangeWindowMessageFilterEx)
+        QWindowsApi::instance()->pChangeWindowMessageFilterEx(m_hwnd, MYWM_TASKBARCREATED, MSGFLT_ALLOW, nullptr);
     qCDebug(lcQpaTrayIcon) << __FUNCTION__ << this << "MYWM_TASKBARCREATED=" << MYWM_TASKBARCREATED;
 
     QWindowsHwndSystemTrayIconEntry entry{m_hwnd, this};
diff --git a/src/plugins/platforms/windows/qwindowstheme.cpp b/src/plugins/platforms/windows/qwindowstheme.cpp
index 29c4c47c36..706788f126 100644
--- a/src/plugins/platforms/windows/qwindowstheme.cpp
+++ b/src/plugins/platforms/windows/qwindowstheme.cpp
@@ -39,6 +39,7 @@
 #include <private/qsystemlibrary_p.h>
 #include <private/qwinregistry_p.h>
 #include <QtCore/private/qfunctions_win_p.h>
+#include <QtCore/qoperatingsystemversion.h>
 
 #include <algorithm>
 
@@ -234,41 +235,62 @@ static void populateLightSystemBasePalette(QPalette &result)
 
 static void populateDarkSystemBasePalette(QPalette &result)
 {
+    QColor foreground;
+    QColor background;
+    QColor accent;
+    QColor accentDark;
+    QColor accentDarker;
+    QColor accentDarkest;
+    QColor accentLight;
+    QColor accentLighter;
+    QColor accentLightest;
+    QColor linkColor;
+
+    bool colorSet = false;
+
 #if QT_CONFIG(cpp_winrt)
-    using namespace winrt::Windows::UI::ViewManagement;
-    const auto settings = UISettings();
-
-    // We have to craft a palette from these colors. The settings.UIElementColor(UIElementType) API
-    // returns the old system colors, not the dark mode colors. If the background is black (which it
-    // usually), then override it with a dark gray instead so that we can go up and down the lightness.
-    const QColor foreground = getSysColor(settings.GetColorValue(UIColorType::Foreground));
-    const QColor background = [&settings]() -> QColor {
-        auto systemBackground = getSysColor(settings.GetColorValue(UIColorType::Background));
-        if (systemBackground == Qt::black)
-            systemBackground = QColor(0x1E, 0x1E, 0x1E);
-        return systemBackground;
-    }();
-
-    const QColor accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
-    const QColor accentDark = getSysColor(settings.GetColorValue(UIColorType::AccentDark1));
-    const QColor accentDarker = getSysColor(settings.GetColorValue(UIColorType::AccentDark2));
-    const QColor accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
-    const QColor accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
-    const QColor accentLighter = getSysColor(settings.GetColorValue(UIColorType::AccentLight2));
-    const QColor accentLightest = getSysColor(settings.GetColorValue(UIColorType::AccentLight3));
-    const QColor linkColor = accent;
-#else
-    const QColor foreground = Qt::white;
-    const QColor background = QColor(0x1E, 0x1E, 0x1E);
-    const QColor accent = QColor(0x00, 0x55, 0xff);
-    const QColor accentDark = accent.darker(120);
-    const QColor accentDarker = accentDark.darker(120);
-    const QColor accentDarkest = accentDarker.darker(120);
-    const QColor accentLight = accent.lighter(120);
-    const QColor accentLighter = accentLight.lighter(120);
-    const QColor accentLightest = accentLighter.lighter(120);
-    const QColor linkColor = Qt::blue;
+    if (QOperatingSystemVersion::isWin10RS5OrGreater()) {
+        using namespace winrt::Windows::UI::ViewManagement;
+        const auto settings = UISettings();
+
+        // We have to craft a palette from these colors. The settings.UIElementColor(UIElementType) API
+        // returns the old system colors, not the dark mode colors. If the background is black (which it
+        // usually), then override it with a dark gray instead so that we can go up and down the lightness.
+        foreground = getSysColor(settings.GetColorValue(UIColorType::Foreground));
+        background = [&settings]() -> QColor {
+            auto systemBackground = getSysColor(settings.GetColorValue(UIColorType::Background));
+            if (systemBackground == Qt::black)
+                systemBackground = QColor(0x1E, 0x1E, 0x1E);
+            return systemBackground;
+        }();
+
+        accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+        accentDark = getSysColor(settings.GetColorValue(UIColorType::AccentDark1));
+        accentDarker = getSysColor(settings.GetColorValue(UIColorType::AccentDark2));
+        accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
+        accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
+        accentLighter = getSysColor(settings.GetColorValue(UIColorType::AccentLight2));
+        accentLightest = getSysColor(settings.GetColorValue(UIColorType::AccentLight3));
+        linkColor = accent;
+
+        colorSet = true;
+    }
 #endif
+
+    if (!colorSet) {
+        foreground = Qt::white;
+        background = QColor(0x1E, 0x1E, 0x1E);
+        accent = QColor(0x00, 0x55, 0xff);
+        accentDark = accent.darker(120);
+        accentDarker = accentDark.darker(120);
+        accentDarkest = accentDarker.darker(120);
+        accentLight = accent.lighter(120);
+        accentLighter = accentLight.lighter(120);
+        accentLightest = accentLighter.lighter(120);
+        linkColor = Qt::blue;
+        colorSet = true;
+    }
+
     const QColor buttonColor = background.lighter(200);
 
     result.setColor(QPalette::All, QPalette::WindowText, foreground);
@@ -524,25 +546,31 @@ void QWindowsTheme::refreshPalettes()
     m_palettes[MenuPalette] = new QPalette(menuPalette(*m_palettes[SystemPalette], light));
     m_palettes[MenuBarPalette] = menuBarPalette(*m_palettes[MenuPalette], light);
     if (!light) {
+        bool colorSet = false;
 #if QT_CONFIG(cpp_winrt)
-        using namespace winrt::Windows::UI::ViewManagement;
-        const auto settings = UISettings();
-        const QColor accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
-        const QColor accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
-        const QColor accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
-        m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Base, accent);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Button, accentLight);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Inactive, QPalette::Base, accentDarkest);
-#else
-        m_palettes[ButtonPalette] = new QPalette(*m_palettes[SystemPalette]);
-        m_palettes[ButtonPalette]->setColor(QPalette::Button, QColor(0x666666u));
-        const QColor checkBoxBlue(0x0078d7u);
-        m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Base, checkBoxBlue);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Button, checkBoxBlue);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::ButtonText, Qt::white);
+        if (QOperatingSystemVersion::isWin10RS5OrGreater()) {
+            using namespace winrt::Windows::UI::ViewManagement;
+            const auto settings = UISettings();
+            const QColor accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+            const QColor accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
+            const QColor accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
+            m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Base, accent);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Button, accentLight);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Inactive, QPalette::Base, accentDarkest);
+            colorSet = true;
+        }
 #endif
+        if (!colorSet) {
+            m_palettes[ButtonPalette] = new QPalette(*m_palettes[SystemPalette]);
+            m_palettes[ButtonPalette]->setColor(QPalette::Button, QColor(0x666666u));
+            const QColor checkBoxBlue(0x0078d7u);
+            m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Base, checkBoxBlue);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Button, checkBoxBlue);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::ButtonText, Qt::white);
+            colorSet = true;
+        }
         m_palettes[RadioButtonPalette] = new QPalette(*m_palettes[CheckBoxPalette]);
     }
 }
@@ -600,7 +628,10 @@ void QWindowsTheme::refreshFonts()
     fixedFont.setStyleHint(QFont::TypeWriter);
 
     LOGFONT lfIconTitleFont;
-    SystemParametersInfoForDpi(SPI_GETICONTITLELOGFONT, sizeof(lfIconTitleFont), &lfIconTitleFont, 0, dpi);
+    if (QWindowsApi::instance()->pSystemParametersInfoForDpi)
+        QWindowsApi::instance()->pSystemParametersInfoForDpi(SPI_GETICONTITLELOGFONT, sizeof(lfIconTitleFont), &lfIconTitleFont, 0, dpi);
+    else
+        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lfIconTitleFont), &lfIconTitleFont, 0);
     const QFont iconTitleFont = QWindowsFontDatabase::LOGFONT_to_QFont(lfIconTitleFont, dpi);
 
     m_fonts[SystemFont] = new QFont(QWindowsFontDatabase::systemDefaultFont());
@@ -1033,7 +1064,7 @@ bool QWindowsTheme::useNativeMenus()
 
 bool QWindowsTheme::queryDarkMode()
 {
-    if (queryHighContrast()) {
+    if (!QOperatingSystemVersion::isWin10RS5OrGreater() || queryHighContrast()) {
         return false;
     }
     const auto setting = QWinRegistryKey(HKEY_CURRENT_USER, LR"(Software\Microsoft\Windows\CurrentVersion\Themes\Personalize)")
diff --git a/src/plugins/platforms/windows/qwindowswindow.cpp b/src/plugins/platforms/windows/qwindowswindow.cpp
index 7dec51c4cc..6a845462b4 100644
--- a/src/plugins/platforms/windows/qwindowswindow.cpp
+++ b/src/plugins/platforms/windows/qwindowswindow.cpp
@@ -22,6 +22,7 @@
 #  include "qwindowscursor.h"
 #endif
 
+#include <QtCore/qoperatingsystemversion.h>
 #include <QtGui/qguiapplication.h>
 #include <QtGui/qscreen.h>
 #include <QtGui/qwindow.h>
@@ -53,6 +54,36 @@ enum {
     defaultWindowHeight = 160
 };
 
+struct QtDwmApis
+{
+    decltype(&::DwmIsCompositionEnabled) pDwmIsCompositionEnabled = nullptr;
+    decltype(&::DwmEnableBlurBehindWindow) pDwmEnableBlurBehindWindow = nullptr;
+    decltype(&::DwmGetWindowAttribute) pDwmGetWindowAttribute = nullptr;
+    decltype(&::DwmSetWindowAttribute) pDwmSetWindowAttribute = nullptr;
+
+    explicit QtDwmApis()
+    {
+        QSystemLibrary dwmapi(u"dwmapi"_s);
+        pDwmIsCompositionEnabled = reinterpret_cast<decltype(pDwmIsCompositionEnabled)>(dwmapi.resolve("DwmIsCompositionEnabled"));
+        pDwmEnableBlurBehindWindow = reinterpret_cast<decltype(pDwmEnableBlurBehindWindow)>(dwmapi.resolve("DwmEnableBlurBehindWindow"));
+        pDwmGetWindowAttribute = reinterpret_cast<decltype(pDwmGetWindowAttribute)>(dwmapi.resolve("DwmGetWindowAttribute"));
+        pDwmSetWindowAttribute = reinterpret_cast<decltype(pDwmSetWindowAttribute)>(dwmapi.resolve("DwmSetWindowAttribute"));
+    }
+
+    ~QtDwmApis() = default;
+
+    [[nodiscard]] static QtDwmApis *instance()
+    {
+        static QtDwmApis inst;
+        return &inst;
+    }
+
+    [[nodiscard]] bool isDwmAvailable() const
+    {
+        return pDwmIsCompositionEnabled && pDwmEnableBlurBehindWindow && pDwmGetWindowAttribute && pDwmSetWindowAttribute;
+    }
+};
+
 Q_GUI_EXPORT HICON qt_pixmapToWinHICON(const QPixmap &);
 
 static QByteArray debugWinStyle(DWORD style)
@@ -442,15 +473,34 @@ static inline bool windowIsAccelerated(const QWindow *w)
     }
 }
 
+static bool dwmIsCompositionEnabled()
+{
+    // DWM composition is always enabled and can't be disabled since Win8.
+    if (QOperatingSystemVersion::isWin8OrGreater())
+        return true;
+    if (!QtDwmApis::instance()->isDwmAvailable())
+        return false;
+    BOOL enabled = FALSE;
+    return SUCCEEDED(QtDwmApis::instance()->pDwmIsCompositionEnabled(&enabled)) && enabled != FALSE;
+}
+
 static bool applyBlurBehindWindow(HWND hwnd)
 {
+    if (!QtDwmApis::instance()->isDwmAvailable())
+        return false;
+
     DWM_BLURBEHIND blurBehind = {0, 0, nullptr, 0};
 
-    blurBehind.dwFlags = DWM_BB_ENABLE | DWM_BB_BLURREGION;
-    blurBehind.fEnable = TRUE;
-    blurBehind.hRgnBlur = CreateRectRgn(0, 0, -1, -1);
+    if (dwmIsCompositionEnabled()) {
+        blurBehind.dwFlags = DWM_BB_ENABLE | DWM_BB_BLURREGION;
+        blurBehind.fEnable = TRUE;
+        blurBehind.hRgnBlur = CreateRectRgn(0, 0, -1, -1);
+    } else {
+        blurBehind.dwFlags = DWM_BB_ENABLE;
+        blurBehind.fEnable = FALSE;
+    }
 
-    const bool result = DwmEnableBlurBehindWindow(hwnd, &blurBehind) == S_OK;
+    const bool result = QtDwmApis::instance()->pDwmEnableBlurBehindWindow(hwnd, &blurBehind) == S_OK;
 
     if (blurBehind.hRgnBlur)
         DeleteObject(blurBehind.hRgnBlur);
@@ -515,15 +565,6 @@ static inline void updateGLWindowSettings(const QWindow *w, HWND hwnd, Qt::Windo
     setWindowOpacity(hwnd, flags, hasAlpha, isAccelerated, opacity);
 }
 
-[[nodiscard]] static inline int getResizeBorderThickness(const UINT dpi)
-{
-    // The width of the padded border will always be 0 if DWM composition is
-    // disabled, but since it will always be enabled and can't be programtically
-    // disabled from Windows 8, we are safe to go.
-    return GetSystemMetricsForDpi(SM_CXSIZEFRAME, dpi)
-           + GetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi);
-}
-
 /*!
     Calculates the dimensions of the invisible borders within the
     window frames which only exist on Windows 10 and onwards.
@@ -531,22 +572,21 @@ static inline void updateGLWindowSettings(const QWindow *w, HWND hwnd, Qt::Windo
 
 static QMargins invisibleMargins(QPoint screenPoint)
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return QMargins();
     POINT pt = {screenPoint.x(), screenPoint.y()};
     if (HMONITOR hMonitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONULL)) {
-        UINT dpiX;
-        UINT dpiY;
-        if (SUCCEEDED(GetDpiForMonitor(hMonitor, MDT_EFFECTIVE_DPI, &dpiX, &dpiY))) {
-            const int gap = getResizeBorderThickness(dpiX);
-            return QMargins(gap, 0, gap, gap);
-        }
+        const int gap = QWindowsContext::getResizeBorderThickness(hMonitor);
+        return QMargins(gap, 0, gap, gap);
     }
     return QMargins();
 }
 
 [[nodiscard]] static inline QMargins invisibleMargins(const HWND hwnd)
 {
-    const UINT dpi = GetDpiForWindow(hwnd);
-    const int gap = getResizeBorderThickness(dpi);
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return QMargins();
+    const int gap = QWindowsContext::getResizeBorderThickness(hwnd);
     return QMargins(gap, 0, gap, gap);
 }
 
@@ -786,10 +826,8 @@ void WindowCreationData::fromWindow(const QWindow *w, const Qt::WindowFlags flag
     } else if (topLevel) {
         if (flags & Qt::FramelessWindowHint)
             style = WS_POPUP;                // no border
-        else if (flags & Qt::WindowTitleHint)
-            style = WS_OVERLAPPED;
         else
-            style = 0;
+            style = WS_OVERLAPPED;
     } else {
         style = WS_CHILD;
     }
@@ -799,7 +837,6 @@ void WindowCreationData::fromWindow(const QWindow *w, const Qt::WindowFlags flag
     if (topLevel) {
         if ((type == Qt::Window || dialog || tool)) {
             if (!(flags & Qt::FramelessWindowHint)) {
-                style |= WS_POPUP;
                 if (flags & Qt::MSWindowsFixedSizeDialogHint) {
                     style |= WS_DLGFRAME;
                 } else {
@@ -827,13 +864,17 @@ void WindowCreationData::fromWindow(const QWindow *w, const Qt::WindowFlags flag
             if ((flags & Qt::WindowContextHelpButtonHint) && !showMinimizeButton
                 && !showMaximizeButton)
                 exStyle |= WS_EX_CONTEXTHELP;
+            if (qEnvironmentVariableIntValue("QT_WINDOWS_DISABLE_BITMAP_REDIRECTION")
+                    && QOperatingSystemVersion::isWin8OrGreater()) {
+                exStyle |= WS_EX_NOREDIRECTIONBITMAP;
+            }
         } else {
              exStyle |= WS_EX_TOOLWINDOW;
         }
 
         // make mouse events fall through this window
         // NOTE: WS_EX_TRANSPARENT flag can make mouse inputs fall through a layered window
-        if (flagsIn & Qt::WindowTransparentForInput)
+        if (flags & Qt::WindowTransparentForInput)
             exStyle |= WS_EX_LAYERED | WS_EX_TRANSPARENT;
     }
 }
@@ -1043,9 +1084,12 @@ QMargins QWindowsGeometryHint::frame(const QWindow *w, DWORD style, DWORD exStyl
 {
     if (!w->isTopLevel() || w->flags().testFlag(Qt::FramelessWindowHint))
         return {};
+    if (!QWindowsApi::instance()->pAdjustWindowRectExForDpi)
+        return frameOnPrimaryScreen(w, style, exStyle);
     RECT rect = {0,0,0,0};
     style &= ~DWORD(WS_OVERLAPPED); // Not permitted, see docs.
-    if (AdjustWindowRectExForDpi(&rect, style, FALSE, exStyle, unsigned(qRound(dpi))) == FALSE) {
+    if (QWindowsApi::instance()->pAdjustWindowRectExForDpi(
+            &rect, style, FALSE, exStyle, unsigned(qRound(dpi))) == FALSE) {
         qErrnoWarning("%s: AdjustWindowRectExForDpi failed", __FUNCTION__);
     }
     const QMargins result(qAbs(rect.left), qAbs(rect.top),
@@ -1085,7 +1129,8 @@ QMargins QWindowsGeometryHint::frame(const QWindow *w, const QRect &geometry,
 {
     if (!w->isTopLevel() || w->flags().testFlag(Qt::FramelessWindowHint))
         return {};
-    if (QWindowsScreenManager::isSingleScreen()
+    if (!QWindowsApi::instance()->pAdjustWindowRectExForDpi
+        || QWindowsScreenManager::isSingleScreen()
         || !QWindowsContext::shouldHaveNonClientDpiScaling(w)) {
         return frameOnPrimaryScreen(w, style, exStyle);
     }
@@ -1240,10 +1285,12 @@ QMargins QWindowsBaseWindow::frameMargins_sys() const
 std::optional<QWindowsBaseWindow::TouchWindowTouchTypes>
     QWindowsBaseWindow::touchWindowTouchTypes_sys() const
 {
+    if (!QWindowsApi::instance()->pIsTouchWindow)
+        return std::nullopt;
     ULONG touchFlags = 0;
-    if (IsTouchWindow(handle(), &touchFlags) == FALSE)
-        return {};
-    TouchWindowTouchTypes result;
+    if (QWindowsApi::instance()->pIsTouchWindow(handle(), &touchFlags) == FALSE)
+        return std::nullopt;
+    TouchWindowTouchTypes result = {};
     if ((touchFlags & TWF_FINETOUCH) != 0)
         result.setFlag(TouchWindowTouchType::FineTouch);
     if ((touchFlags & TWF_WANTPALM) != 0)
@@ -1511,8 +1558,8 @@ QWindowsWindow::QWindowsWindow(QWindow *aWindow, const QWindowsWindowData &data)
 QWindowsWindow::~QWindowsWindow()
 {
     setFlag(WithinDestroy);
-    if (testFlag(TouchRegistered))
-        UnregisterTouchWindow(m_data.hwnd);
+    if (testFlag(TouchRegistered) && QWindowsApi::instance()->pUnregisterTouchWindow)
+        QWindowsApi::instance()->pUnregisterTouchWindow(m_data.hwnd);
     destroyWindow();
     destroyIcon();
 }
@@ -1539,7 +1586,7 @@ void QWindowsWindow::initialize()
             QWindowSystemInterface::handleGeometryChange<QWindowSystemInterface::SynchronousDelivery>(w, obtainedGeometry);
         }
     }
-    QWindowsWindow::setSavedDpi(GetDpiForWindow(handle()));
+    QWindowsWindow::setSavedDpi(QWindowsContext::getMostPossibleDpiForWindow(handle()));
 }
 
 QSurfaceFormat QWindowsWindow::format() const
@@ -2013,7 +2060,7 @@ void QWindowsWindow::handleDpiChanged(HWND hwnd, WPARAM wParam, LPARAM lParam)
 
 void QWindowsWindow::handleDpiChangedAfterParent(HWND hwnd)
 {
-    const UINT dpi = GetDpiForWindow(hwnd);
+    const UINT dpi = QWindowsContext::getMostPossibleDpiForWindow(hwnd);
     const qreal scale = qreal(dpi) / qreal(savedDpi());
     setSavedDpi(dpi);
 
@@ -2333,13 +2380,22 @@ bool QWindowsWindow::handleWmPaint(HWND hwnd, UINT message,
         return false;
     PAINTSTRUCT ps;
 
-    // GL software rendering (QTBUG-58178) with some AMD cards
+    // GL software rendering (QTBUG-58178) and Windows 7/Aero off with some AMD cards
     // (QTBUG-60527) need InvalidateRect() to suppress artifacts while resizing.
-    if (testFlag(OpenGLSurface) && isSoftwareGl())
+    if (testFlag(OpenGLSurface) && (isSoftwareGl() || !dwmIsCompositionEnabled()))
         InvalidateRect(hwnd, nullptr, false);
 
     BeginPaint(hwnd, &ps);
 
+    // Observed painting problems with Aero style disabled (QTBUG-7865).
+    if (Q_UNLIKELY(!dwmIsCompositionEnabled())
+        && ((testFlag(OpenGLSurface) && testFlag(OpenGLDoubleBuffered))
+            || testFlag(VulkanSurface)
+            || testFlag(Direct3DSurface)))
+    {
+        SelectClipRgn(ps.hdc, nullptr);
+    }
+
     // If the a window is obscured by another window (such as a child window)
     // we still need to send isExposed=true, for compatibility.
     // Our tests depend on it.
@@ -2969,7 +3025,7 @@ void QWindowsWindow::getSizeHints(MINMAXINFO *mmi) const
             mmi->ptMaxPosition.x = availablePositionDiff.x();
             mmi->ptMaxPosition.y = availablePositionDiff.y();
             if (!m_data.flags.testFlag(Qt::FramelessWindowHint)) {
-                const int borderWidth = invisibleMargins(m_data.hwnd).left();
+                const int borderWidth = QWindowsContext::getResizeBorderThickness(m_data.hwnd);
                 mmi->ptMaxSize.x += borderWidth * 2;
                 mmi->ptMaxSize.y += borderWidth * 2;
                 mmi->ptMaxTrackSize = mmi->ptMaxSize;
@@ -3010,7 +3066,7 @@ bool QWindowsWindow::handleNonClientHitTest(const QPoint &globalPos, LRESULT *re
             return true;
         }
         if (localPos.y() < 0) {
-            const int topResizeBarPos = invisibleMargins(m_data.hwnd).left() - frameMargins().top();
+            const int topResizeBarPos = QWindowsContext::getResizeBorderThickness(m_data.hwnd) - frameMargins().top();
             if (localPos.y() < topResizeBarPos) {
                 *result = HTCAPTION; // Extend caption over top resize bar, let's user move the window.
                 return true;
@@ -3200,10 +3256,12 @@ enum : WORD {
 
 static bool queryDarkBorder(HWND hwnd)
 {
+    if (!QtDwmApis::instance()->isDwmAvailable())
+        return false;
     BOOL result = FALSE;
     const bool ok =
-        SUCCEEDED(DwmGetWindowAttribute(hwnd, DwmwaUseImmersiveDarkMode, &result, sizeof(result)))
-        || SUCCEEDED(DwmGetWindowAttribute(hwnd, DwmwaUseImmersiveDarkModeBefore20h1, &result, sizeof(result)));
+        SUCCEEDED(QtDwmApis::instance()->pDwmGetWindowAttribute(hwnd, DwmwaUseImmersiveDarkMode, &result, sizeof(result)))
+        || SUCCEEDED(QtDwmApis::instance()->pDwmGetWindowAttribute(hwnd, DwmwaUseImmersiveDarkModeBefore20h1, &result, sizeof(result)));
     if (!ok)
         qCWarning(lcQpaWindow, "%s: Unable to retrieve dark window border setting.", __FUNCTION__);
     return result == TRUE;
@@ -3211,10 +3269,12 @@ static bool queryDarkBorder(HWND hwnd)
 
 bool QWindowsWindow::setDarkBorderToWindow(HWND hwnd, bool d)
 {
+    if (!QtDwmApis::instance()->isDwmAvailable())
+        return false;
     const BOOL darkBorder = d ? TRUE : FALSE;
     const bool ok =
-        SUCCEEDED(DwmSetWindowAttribute(hwnd, DwmwaUseImmersiveDarkMode, &darkBorder, sizeof(darkBorder)))
-        || SUCCEEDED(DwmSetWindowAttribute(hwnd, DwmwaUseImmersiveDarkModeBefore20h1, &darkBorder, sizeof(darkBorder)));
+        SUCCEEDED(QtDwmApis::instance()->pDwmSetWindowAttribute(hwnd, DwmwaUseImmersiveDarkMode, &darkBorder, sizeof(darkBorder)))
+        || SUCCEEDED(QtDwmApis::instance()->pDwmSetWindowAttribute(hwnd, DwmwaUseImmersiveDarkModeBefore20h1, &darkBorder, sizeof(darkBorder)));
     if (!ok)
         qCWarning(lcQpaWindow, "%s: Unable to set %s window border.", __FUNCTION__, d ? "dark" : "light");
     return ok;
@@ -3335,6 +3395,9 @@ void QWindowsWindow::registerTouchWindow()
     if ((QWindowsContext::instance()->systemInfo() & QWindowsContext::SI_SupportsTouch) == 0)
         return;
 
+    if (!QWindowsApi::instance()->pRegisterTouchWindow)
+        return;
+
     // Initially register or re-register to change the flags
     const auto touchTypes = QWindowsIntegration::instance()->touchWindowTouchType();
     if (testFlag(TouchRegistered)) {
@@ -3348,7 +3411,7 @@ void QWindowsWindow::registerTouchWindow()
         touchFlags |= TWF_FINETOUCH;
     if (touchTypes.testFlag(TouchWindowTouchType::WantPalmTouch))
         touchFlags |= TWF_WANTPALM;
-    if (RegisterTouchWindow(m_data.hwnd, touchFlags))
+    if (QWindowsApi::instance()->pRegisterTouchWindow(m_data.hwnd, touchFlags))
         setFlag(TouchRegistered);
     else
         qErrnoWarning("RegisterTouchWindow() failed for window '%s'.", qPrintable(window()->objectName()));
diff --git a/src/plugins/platforms/windows/uiautomation/qwindowsuiaaccessibility.cpp b/src/plugins/platforms/windows/uiautomation/qwindowsuiaaccessibility.cpp
index 001cb8505b..3b8ecef292 100644
--- a/src/plugins/platforms/windows/uiautomation/qwindowsuiaaccessibility.cpp
+++ b/src/plugins/platforms/windows/uiautomation/qwindowsuiaaccessibility.cpp
@@ -14,7 +14,6 @@
 #include <QtGui/private/qguiapplication_p.h>
 #include <QtCore/qt_windows.h>
 #include <qpa/qplatformintegration.h>
-#include <QtGui/private/qwindowsuiawrapper_p.h>
 
 #include <QtCore/private/qwinregistry_p.h>
 
@@ -46,7 +45,7 @@ bool QWindowsUiaAccessibility::handleWmGetObject(HWND hwnd, WPARAM wParam, LPARA
     if (QWindow *window = QWindowsContext::instance()->findWindow(hwnd)) {
         if (QAccessibleInterface *accessible = window->accessibleRoot()) {
             QWindowsUiaMainProvider *provider = QWindowsUiaMainProvider::providerForAccessible(accessible);
-            *lResult = QWindowsUiaWrapper::instance()->returnRawElementProvider(hwnd, wParam, lParam, provider);
+            *lResult = UiaReturnRawElementProvider(hwnd, wParam, lParam, provider);
             return true;
         }
     }
@@ -120,12 +119,8 @@ void QWindowsUiaAccessibility::notifyAccessibilityUpdate(QAccessibleEvent *event
     if (!isActive() || !accessible || !accessible->isValid())
         return;
 
-    // Ensures QWindowsUiaWrapper is properly initialized.
-    if (!QWindowsUiaWrapper::instance()->ready())
-        return;
-
     // No need to do anything when nobody is listening.
-    if (!QWindowsUiaWrapper::instance()->clientsAreListening())
+    if (!UiaClientsAreListening())
         return;
 
     switch (event->type()) {
diff --git a/src/plugins/platforms/windows/uiautomation/qwindowsuiabaseprovider.h b/src/plugins/platforms/windows/uiautomation/qwindowsuiabaseprovider.h
index c899b4096e..2bc549f548 100644
--- a/src/plugins/platforms/windows/uiautomation/qwindowsuiabaseprovider.h
+++ b/src/plugins/platforms/windows/uiautomation/qwindowsuiabaseprovider.h
@@ -11,7 +11,9 @@
 #include <QtCore/qpointer.h>
 
 #include <qwindowscombase.h>
-#include <QtGui/private/qwindowsuiawrapper_p.h>
+#include <uiautomationcore.h>
+#include <uiautomationcoreapi.h>
+#include <uiautomationclient.h>
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/plugins/platforms/windows/uiautomation/qwindowsuiamainprovider.cpp b/src/plugins/platforms/windows/uiautomation/qwindowsuiamainprovider.cpp
index 16f0a3f9a6..2abb481239 100644
--- a/src/plugins/platforms/windows/uiautomation/qwindowsuiamainprovider.cpp
+++ b/src/plugins/platforms/windows/uiautomation/qwindowsuiamainprovider.cpp
@@ -24,6 +24,8 @@
 #include "qwindowsuiaprovidercache.h"
 
 #include <QtCore/qloggingcategory.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 #include <QtGui/qaccessible.h>
 #include <QtGui/qguiapplication.h>
 #include <QtGui/qwindow.h>
@@ -36,6 +38,8 @@
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 using namespace QWindowsUiAutomation;
 
 QMutex QWindowsUiaMainProvider::m_mutex;
@@ -80,7 +84,7 @@ void QWindowsUiaMainProvider::notifyFocusChange(QAccessibleEvent *event)
                 accessible = child;
         }
         if (QWindowsUiaMainProvider *provider = providerForAccessible(accessible))
-            QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_AutomationFocusChangedEventId);
+            UiaRaiseAutomationEvent(provider, UIA_AutomationFocusChangedEventId);
     }
 }
 
@@ -97,7 +101,7 @@ void QWindowsUiaMainProvider::notifyStateChange(QAccessibleStateChangeEvent *eve
                     if (accessible->state().checked)
                         toggleState = accessible->state().checkStateMixed ? ToggleState_Indeterminate : ToggleState_On;
                     setVariantI4(toggleState, &newVal);
-                    QWindowsUiaWrapper::instance()->raiseAutomationPropertyChangedEvent(provider, UIA_ToggleToggleStatePropertyId, oldVal, newVal);
+                    UiaRaiseAutomationPropertyChangedEvent(provider, UIA_ToggleToggleStatePropertyId, oldVal, newVal);
                 }
             }
         }
@@ -106,13 +110,13 @@ void QWindowsUiaMainProvider::notifyStateChange(QAccessibleStateChangeEvent *eve
                 // Notifies window opened/closed.
                 if (QWindowsUiaMainProvider *provider = providerForAccessible(accessible)) {
                     if (accessible->state().active) {
-                        QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Window_WindowOpenedEventId);
+                        UiaRaiseAutomationEvent(provider, UIA_Window_WindowOpenedEventId);
                         if (QAccessibleInterface *focused = accessible->focusChild()) {
                             if (QWindowsUiaMainProvider *focusedProvider = providerForAccessible(focused))
-                                QWindowsUiaWrapper::instance()->raiseAutomationEvent(focusedProvider, UIA_AutomationFocusChangedEventId);
+                                UiaRaiseAutomationEvent(focusedProvider, UIA_AutomationFocusChangedEventId);
                         }
                     } else {
-                        QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Window_WindowClosedEventId);
+                        UiaRaiseAutomationEvent(provider, UIA_Window_WindowClosedEventId);
                     }
                 }
             }
@@ -145,21 +149,30 @@ void QWindowsUiaMainProvider::notifyValueChange(QAccessibleValueChangeEvent *eve
                 // Tries to notify the change using UiaRaiseNotificationEvent(), which is only available on
                 // Windows 10 version 1709 or newer. Otherwise uses UiaRaiseAutomationPropertyChangedEvent().
 
-                BSTR displayString = bStrFromQString(event->value().toString());
-                BSTR activityId = bStrFromQString(QString());
+                auto hr = HRESULT(UIA_E_NOTSUPPORTED);
+
+                if (QOperatingSystemVersion::isWin10RS3OrGreater()) {
+                    static const auto pUiaRaiseNotificationEvent =
+                        reinterpret_cast<decltype(&::UiaRaiseNotificationEvent)>(
+                            QSystemLibrary::resolve(u"uiautomationcore"_s, "UiaRaiseNotificationEvent"));
+                    if (pUiaRaiseNotificationEvent) {
+                        BSTR displayString = bStrFromQString(event->value().toString());
+                        BSTR activityId = bStrFromQString(QString());
 
-                HRESULT hr = QWindowsUiaWrapper::instance()->raiseNotificationEvent(provider, NotificationKind_Other,
-                                                                                    NotificationProcessing_ImportantMostRecent,
-                                                                                    displayString, activityId);
+                        hr = pUiaRaiseNotificationEvent(provider, NotificationKind_Other,
+                                                        NotificationProcessing_ImportantMostRecent,
+                                                        displayString, activityId);
 
-                ::SysFreeString(displayString);
-                ::SysFreeString(activityId);
+                        ::SysFreeString(displayString);
+                        ::SysFreeString(activityId);
+                    }
+                }
 
                 if (hr == static_cast<HRESULT>(UIA_E_NOTSUPPORTED)) {
                     VARIANT oldVal, newVal;
                     clearVariant(&oldVal);
                     setVariantString(event->value().toString(), &newVal);
-                    QWindowsUiaWrapper::instance()->raiseAutomationPropertyChangedEvent(provider, UIA_ValueValuePropertyId, oldVal, newVal);
+                    UiaRaiseAutomationPropertyChangedEvent(provider, UIA_ValueValuePropertyId, oldVal, newVal);
                     ::SysFreeString(newVal.bstrVal);
                 }
             }
@@ -169,7 +182,7 @@ void QWindowsUiaMainProvider::notifyValueChange(QAccessibleValueChangeEvent *eve
                 VARIANT oldVal, newVal;
                 clearVariant(&oldVal);
                 setVariantDouble(valueInterface->currentValue().toDouble(), &newVal);
-                QWindowsUiaWrapper::instance()->raiseAutomationPropertyChangedEvent(provider, UIA_RangeValueValuePropertyId, oldVal, newVal);
+                UiaRaiseAutomationPropertyChangedEvent(provider, UIA_RangeValueValuePropertyId, oldVal, newVal);
             }
         }
     }
@@ -185,7 +198,7 @@ void QWindowsUiaMainProvider::notifyNameChange(QAccessibleEvent *event)
                 VARIANT oldVal, newVal;
                 clearVariant(&oldVal);
                 setVariantString(accessible->text(QAccessible::Name), &newVal);
-                QWindowsUiaWrapper::instance()->raiseAutomationPropertyChangedEvent(provider, UIA_NamePropertyId, oldVal, newVal);
+                UiaRaiseAutomationPropertyChangedEvent(provider, UIA_NamePropertyId, oldVal, newVal);
                 ::SysFreeString(newVal.bstrVal);
             }
         }
@@ -196,7 +209,7 @@ void QWindowsUiaMainProvider::notifySelectionChange(QAccessibleEvent *event)
 {
     if (QAccessibleInterface *accessible = event->accessibleInterface()) {
         if (QWindowsUiaMainProvider *provider = providerForAccessible(accessible)) {
-            QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_SelectionItem_ElementSelectedEventId);
+            UiaRaiseAutomationEvent(provider, UIA_SelectionItem_ElementSelectedEventId);
         }
     }
 }
@@ -208,13 +221,13 @@ void QWindowsUiaMainProvider::notifyTextChange(QAccessibleEvent *event)
         if (accessible->textInterface()) {
             if (QWindowsUiaMainProvider *provider = providerForAccessible(accessible)) {
                 if (event->type() == QAccessible::TextSelectionChanged) {
-                    QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Text_TextSelectionChangedEventId);
+                    UiaRaiseAutomationEvent(provider, UIA_Text_TextSelectionChangedEventId);
                 } else if (event->type() == QAccessible::TextCaretMoved) {
                     if (!accessible->state().readOnly) {
-                        QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Text_TextSelectionChangedEventId);
+                        UiaRaiseAutomationEvent(provider, UIA_Text_TextSelectionChangedEventId);
                     }
                 } else {
-                    QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Text_TextChangedEventId);
+                    UiaRaiseAutomationEvent(provider, UIA_Text_TextChangedEventId);
                 }
             }
         }
@@ -519,7 +532,7 @@ HRESULT QWindowsUiaMainProvider::get_HostRawElementProvider(IRawElementProviderS
     // Returns a host provider only for controls associated with a native window handle. Others should return NULL.
     if (QAccessibleInterface *accessible = accessibleInterface()) {
         if (HWND hwnd = hwndForAccessible(accessible)) {
-            return QWindowsUiaWrapper::instance()->hostProviderFromHwnd(hwnd, pRetVal);
+            return UiaHostProviderFromHwnd(hwnd, pRetVal);
         }
     }
     return S_OK;
diff --git a/src/plugins/platforms/windows/uiautomation/qwindowsuiautils.h b/src/plugins/platforms/windows/uiautomation/qwindowsuiautils.h
index 8fe8b1c6d7..07367efe01 100644
--- a/src/plugins/platforms/windows/uiautomation/qwindowsuiautils.h
+++ b/src/plugins/platforms/windows/uiautomation/qwindowsuiautils.h
@@ -12,7 +12,7 @@
 #include <QtGui/qaccessible.h>
 #include <QtGui/qwindow.h>
 #include <QtCore/qrect.h>
-#include <QtGui/private/qwindowsuiawrapper_p.h>
+#include "qwindowsuiabaseprovider.h"
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp b/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp
index e90d1c0925..2c80a0c1f2 100644
--- a/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp
+++ b/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp
@@ -3945,6 +3945,21 @@ void QWindowsVistaStyle::drawComplexControl(ComplexControl control, const QStyle
                     theme.partId = flags & State_Horizontal ? SBP_THUMBBTNHORZ : SBP_THUMBBTNVERT;
                     theme.stateId = stateId;
                     d->drawBackground(theme);
+
+                    if (!QOperatingSystemVersion::isWin8OrGreater()) {
+                        const QRect gripperBounds = QWindowsVistaStylePrivate::scrollBarGripperBounds(flags, widget, &theme);
+                        // Draw gripper if there is enough space
+                        if (!gripperBounds.isEmpty() && flags & State_Enabled) {
+                            painter->save();
+                            QWindowsThemeData grippBackground = theme;
+                            grippBackground.partId = flags & State_Horizontal ? SBP_LOWERTRACKHORZ : SBP_LOWERTRACKVERT;
+                            theme.rect = gripperBounds;
+                            painter->setClipRegion(d->region(theme));// Only change inside the region of the gripper
+                            d->drawBackground(grippBackground);// The gutter is the grippers background
+                            d->drawBackground(theme);          // Transparent gripper ontop of background
+                            painter->restore();
+                        }
+                    }
                 }
             }
         }
@@ -5035,4 +5050,20 @@ QIcon QWindowsVistaStyle::standardIcon(StandardPixmap standardIcon,
     return QWindowsStyle::standardIcon(standardIcon, option, widget);
 }
 
+QRect QWindowsVistaStylePrivate::scrollBarGripperBounds(QStyle::State flags, const QWidget *widget, QWindowsThemeData *theme)
+{
+    const bool horizontal = flags & QStyle::State_Horizontal;
+    const qreal factor = QWindowsStylePrivate::nativeMetricScaleFactor(widget);
+    const QMargins contentsMargin =
+        (theme->margins(theme->rect, TMT_SIZINGMARGINS) * factor).toMargins();
+    theme->partId = horizontal ? SBP_GRIPPERHORZ : SBP_GRIPPERVERT;
+    const QSize size = (theme->size() * factor).toSize();
+
+    const int hSpace = theme->rect.width() - size.width();
+    const int vSpace = theme->rect.height() - size.height();
+    const bool sufficientSpace = (horizontal && hSpace > (contentsMargin.left() + contentsMargin.right()))
+        || vSpace > contentsMargin.top() + contentsMargin.bottom();
+    return sufficientSpace ? QRect(theme->rect.topLeft() + QPoint(hSpace, vSpace) / 2, size) : QRect();
+}
+
 QT_END_NAMESPACE
diff --git a/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h b/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h
index 2c38ff4b3b..7705d3200e 100644
--- a/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h
+++ b/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h
@@ -120,6 +120,7 @@ public:
     static int pixelMetricFromSystemDp(QStyle::PixelMetric pm, const QStyleOption *option = nullptr, const QWidget *widget = nullptr);
     static int fixedPixelMetric(QStyle::PixelMetric pm);
     static bool isLineEditBaseColorSet(const QStyleOption *option, const QWidget *widget);
+    static QRect scrollBarGripperBounds(QStyle::State flags, const QWidget *widget, QWindowsThemeData *theme);
     static HWND winId(const QWidget *widget);
     static bool useVista(bool update = false);
     static QBackingStore *backingStoreForWidget(const QWidget *widget);
diff --git a/src/tools/rcc/main.cpp b/src/tools/rcc/main.cpp
index 2751bc39d6..8e44999f52 100644
--- a/src/tools/rcc/main.cpp
+++ b/src/tools/rcc/main.cpp
@@ -34,9 +34,7 @@ void dumpRecursive(const QDir &dir, QTextStream &out)
         if (entry.isDir()) {
             dumpRecursive(entry.filePath(), out);
         } else {
-            out << "<file>"_L1
-                << entry.filePath()
-                << "</file>\n"_L1;
+            out << "  <file>"_L1 << entry.filePath() << "</file>\n"_L1;
         }
     }
 }
@@ -64,7 +62,8 @@ int createProject(const QString &outFileName)
     }
 
     QTextStream out(&file);
-    out << "<!DOCTYPE RCC><RCC version=\"1.0\">\n"
+    out << "<!DOCTYPE RCC>\n"
+           "<RCC version=\"1.0\">\n"
            "<qresource>\n"_L1;
 
     // use "." as dir to get relative file paths
diff --git a/src/tools/rcc/rcc.cpp b/src/tools/rcc/rcc.cpp
index e461ab6294..e6e6cd433b 100644
--- a/src/tools/rcc/rcc.cpp
+++ b/src/tools/rcc/rcc.cpp
@@ -1126,7 +1126,7 @@ bool RCCResourceLibrary::writeDataBlobs()
     Q_ASSERT(m_errorDevice);
     switch (m_format) {
     case C_Code:
-        writeString("static const unsigned char qt_resource_data[] = {\n");
+        writeString("static constexpr const unsigned char qt_resource_data[] = {\n");
         break;
     case Python_Code:
         writeString("qt_resource_data = b\"\\\n");
@@ -1170,7 +1170,7 @@ bool RCCResourceLibrary::writeDataBlobs()
     case Pass1:
         if (offset < 8)
             offset = 8;
-        writeString("\nstatic const unsigned char qt_resource_data[");
+        writeString("\nstatic constexpr const unsigned char qt_resource_data[");
         writeByteArray(QByteArray::number(offset));
         writeString("] = { 'Q', 'R', 'C', '_', 'D', 'A', 'T', 'A' };\n\n");
         break;
@@ -1185,7 +1185,7 @@ bool RCCResourceLibrary::writeDataNames()
     switch (m_format) {
     case C_Code:
     case Pass1:
-        writeString("static const unsigned char qt_resource_name[] = {\n");
+        writeString("static constexpr const unsigned char qt_resource_name[] = {\n");
         break;
     case Python_Code:
         writeString("qt_resource_name = b\"\\\n");
@@ -1247,7 +1247,7 @@ bool RCCResourceLibrary::writeDataStructure()
     switch (m_format) {
     case C_Code:
     case Pass1:
-        writeString("static const unsigned char qt_resource_struct[] = {\n");
+        writeString("static constexpr const unsigned char qt_resource_struct[] = {\n");
         break;
     case Python_Code:
         writeString("qt_resource_struct = b\"\\\n");
diff --git a/src/widgets/CMakeLists.txt b/src/widgets/CMakeLists.txt
index ed9086e19a..292ba6092b 100644
--- a/src/widgets/CMakeLists.txt
+++ b/src/widgets/CMakeLists.txt
@@ -322,7 +322,6 @@ qt_internal_extend_target(Widgets CONDITION MACOS
 
 qt_internal_extend_target(Widgets CONDITION WIN32
     LIBRARIES
-        dwmapi
         shell32
         uxtheme
 )
diff --git a/src/widgets/dialogs/qwizard.cpp b/src/widgets/dialogs/qwizard.cpp
index cd41efa313..7cb2831411 100644
--- a/src/widgets/dialogs/qwizard.cpp
+++ b/src/widgets/dialogs/qwizard.cpp
@@ -328,7 +328,8 @@ void QWizardHeader::setup(const QWizardLayoutInfo &info, const QString &title,
 {
     bool modern = ((info.wizStyle == QWizard::ModernStyle)
 #if QT_CONFIG(style_windowsvista)
-        || vistaDisabled()
+        || ((info.wizStyle == QWizard::AeroStyle
+            && QVistaHelper::vistaState() == QVistaHelper::Classic) || vistaDisabled())
 #endif
     );
 
@@ -534,6 +535,7 @@ public:
     void updatePixmap(QWizard::WizardPixmap which);
 #if QT_CONFIG(style_windowsvista)
     bool vistaDisabled() const;
+    bool isVistaThemeEnabled(QVistaHelper::VistaState state) const;
     bool handleAeroStyleChange();
 #endif
     bool isVistaThemeEnabled() const;
@@ -602,7 +604,7 @@ public:
     QPointer<QShortcut> vistaNextShortcut;
 #  endif
     bool vistaInitPending = true;
-    bool vistaDirty = true;
+    QVistaHelper::VistaState vistaState = QVistaHelper::Dirty;
     bool vistaStateChanged = false;
     bool inHandleAeroStyleChange = false;
 #endif
@@ -886,7 +888,7 @@ QWizardLayoutInfo QWizardPrivate::layoutInfoForCurrentPage()
     info.wizStyle = wizStyle;
     if (info.wizStyle == QWizard::AeroStyle
 #if QT_CONFIG(style_windowsvista)
-        && vistaDisabled()
+        && (QVistaHelper::vistaState() == QVistaHelper::Classic || vistaDisabled())
 #endif
         )
         info.wizStyle = QWizard::ModernStyle;
@@ -1518,6 +1520,13 @@ bool QWizardPrivate::vistaDisabled() const
     return v.isValid() && v.toBool();
 }
 
+bool QWizardPrivate::isVistaThemeEnabled(QVistaHelper::VistaState state) const
+{
+    return wizStyle == QWizard::AeroStyle
+        && QVistaHelper::vistaState() == state
+        && !vistaDisabled();
+}
+
 bool QWizardPrivate::handleAeroStyleChange()
 {
     Q_Q(QWizard);
@@ -1541,17 +1550,25 @@ bool QWizardPrivate::handleAeroStyleChange()
     if (isVistaThemeEnabled()) {
         const int topOffset = vistaHelper->topOffset(q);
         const int topPadding = vistaHelper->topPadding(q);
-        if (isWindow) {
-            vistaHelper->setDWMTitleBar(QVistaHelper::ExtendedTitleBar);
-            q->installEventFilter(vistaHelper);
+        if (isVistaThemeEnabled(QVistaHelper::VistaAero)) {
+            if (isWindow) {
+                vistaHelper->setDWMTitleBar(QVistaHelper::ExtendedTitleBar);
+                q->installEventFilter(vistaHelper);
+            }
+            q->setMouseTracking(true);
+            antiFlickerWidget->move(0, vistaHelper->titleBarSize() + topOffset);
+            vistaHelper->backButton()->move(
+                0, topOffset // ### should ideally work without the '+ 1'
+                - qMin(topOffset, topPadding + 1));
+            vistaMargins = true;
+            vistaHelper->backButton()->show();
+        } else {
+            if (isWindow)
+                vistaHelper->setDWMTitleBar(QVistaHelper::NormalTitleBar);
+            q->setMouseTracking(true);
+            antiFlickerWidget->move(0, topOffset);
+            vistaHelper->backButton()->move(0, -1); // ### should ideally work with (0, 0)
         }
-        q->setMouseTracking(true);
-        antiFlickerWidget->move(0, vistaHelper->titleBarSize() + topOffset);
-        vistaHelper->backButton()->move(
-            0, topOffset // ### should ideally work without the '+ 1'
-            - qMin(topOffset, topPadding + 1));
-        vistaMargins = true;
-        vistaHelper->backButton()->show();
         if (isWindow)
             vistaHelper->setTitleBarIconAndCaptionVisible(false);
         QObject::connect(
@@ -1580,7 +1597,8 @@ bool QWizardPrivate::handleAeroStyleChange()
 bool QWizardPrivate::isVistaThemeEnabled() const
 {
 #if QT_CONFIG(style_windowsvista)
-    return wizStyle == QWizard::AeroStyle && !vistaDisabled();
+    return isVistaThemeEnabled(QVistaHelper::VistaAero)
+        || isVistaThemeEnabled(QVistaHelper::VistaBasic);
 #else
     return false;
 #endif
@@ -1737,6 +1755,13 @@ void QWizardAntiFlickerWidget::paintEvent(QPaintEvent *)
         painter.fillRect(0, buttonLayoutTop, width(), height() - buttonLayoutTop, brush);
         painter.setPen(QPen(QBrush(QColor(223, 223, 223)), 0)); // ### hardcoded for now
         painter.drawLine(0, buttonLayoutTop, width(), buttonLayoutTop);
+        if (wizardPrivate->isVistaThemeEnabled(QVistaHelper::VistaBasic)) {
+            if (window()->isActiveWindow())
+                painter.setPen(QPen(QBrush(QColor(169, 191, 214)), 0)); // ### hardcoded for now
+            else
+                painter.setPen(QPen(QBrush(QColor(182, 193, 204)), 0)); // ### hardcoded for now
+            painter.drawLine(0, 0, width(), 0);
+        }
     }
 }
 #endif
@@ -3146,7 +3171,12 @@ bool QWizard::event(QEvent *event)
 #if QT_CONFIG(style_windowsvista)
     else if (event->type() == QEvent::Show && d->vistaInitPending) {
         d->vistaInitPending = false;
-        d->wizStyle = AeroStyle;
+        // Do not force AeroStyle when in Classic theme.
+        // Note that d->handleAeroStyleChange() needs to be called in any case as it does some
+        // necessary initialization, like ensures that the Aero specific back button is hidden if
+        // Aero theme isn't active.
+        if (QVistaHelper::vistaState() != QVistaHelper::Classic)
+            d->wizStyle = AeroStyle;
         d->handleAeroStyleChange();
     }
     else if (d->isVistaThemeEnabled()) {
@@ -3176,7 +3206,8 @@ void QWizard::resizeEvent(QResizeEvent *event)
 #if QT_CONFIG(style_windowsvista)
     if (d->isVistaThemeEnabled()) {
         heightOffset = d->vistaHelper->topOffset(this);
-        heightOffset += d->vistaHelper->titleBarSize();
+        if (d->isVistaThemeEnabled(QVistaHelper::VistaAero))
+            heightOffset += d->vistaHelper->titleBarSize();
     }
 #endif
     d->antiFlickerWidget->resize(event->size().width(), event->size().height() - heightOffset);
@@ -3203,6 +3234,11 @@ void QWizard::paintEvent(QPaintEvent * event)
     }
 #if QT_CONFIG(style_windowsvista)
     else if (d->isVistaThemeEnabled()) {
+        if (d->isVistaThemeEnabled(QVistaHelper::VistaBasic)) {
+            QPainter painter(this);
+            QColor color = d->vistaHelper->basicWindowFrameColor();
+            painter.fillRect(0, 0, width(), QVistaHelper::topOffset(this), color);
+        }
         d->vistaHelper->paintEvent(event);
     }
 #else
@@ -3221,12 +3257,12 @@ bool QWizard::nativeEvent(const QByteArray &eventType, void *message, qintptr *r
     if (d->isVistaThemeEnabled() && eventType == "windows_generic_MSG") {
         MSG *windowsMessage = static_cast<MSG *>(message);
         const bool winEventResult = d->vistaHelper->handleWinEvent(windowsMessage, result);
-        if (d->vistaDirty) {
+        if (QVistaHelper::vistaState() != d->vistaState) {
             // QTBUG-78300: When Qt::AA_NativeWindows is set, delay further
             // window creation until after the platform window creation events.
             if (windowsMessage->message == WM_GETICON) {
                 d->vistaStateChanged = true;
-                d->vistaDirty = false;
+                d->vistaState = QVistaHelper::vistaState();
                 setWizardStyle(AeroStyle);
             }
         }
diff --git a/src/widgets/dialogs/qwizard_win.cpp b/src/widgets/dialogs/qwizard_win.cpp
index b7788061f1..6cc6bb821a 100644
--- a/src/widgets/dialogs/qwizard_win.cpp
+++ b/src/widgets/dialogs/qwizard_win.cpp
@@ -16,6 +16,7 @@
 #include <QtCore/QOperatingSystemVersion>
 #include <QtCore/QVariant>
 #include <QtCore/QDebug>
+#include <QtCore/private/qsystemlibrary_p.h>
 #include <QtGui/QMouseEvent>
 #include <QtGui/QWindow>
 #include <QtGui/private/qhighdpiscaling_p.h>
@@ -33,7 +34,39 @@ Q_DECLARE_METATYPE(QMargins)
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
+struct DwmApis
+{
+    decltype(&::DwmIsCompositionEnabled) pDwmIsCompositionEnabled = nullptr;
+    decltype(&::DwmExtendFrameIntoClientArea) pDwmExtendFrameIntoClientArea = nullptr;
+    decltype(&::DwmDefWindowProc) pDwmDefWindowProc = nullptr;
+
+    explicit DwmApis()
+    {
+        QSystemLibrary dwmapi(u"dwmapi"_s);
+        pDwmIsCompositionEnabled = reinterpret_cast<decltype(pDwmIsCompositionEnabled)>(dwmapi.resolve("DwmIsCompositionEnabled"));
+        pDwmExtendFrameIntoClientArea = reinterpret_cast<decltype(pDwmExtendFrameIntoClientArea)>(dwmapi.resolve("DwmExtendFrameIntoClientArea"));
+        pDwmDefWindowProc = reinterpret_cast<decltype(pDwmDefWindowProc)>(dwmapi.resolve("DwmDefWindowProc"));
+    }
+
+    ~DwmApis() = default;
+
+    [[nodiscard]] bool isDwmAvailable() const
+    {
+        return pDwmIsCompositionEnabled && pDwmExtendFrameIntoClientArea && pDwmDefWindowProc;
+    }
+
+    [[nodiscard]] static DwmApis *instance()
+    {
+        static DwmApis inst;
+        return &inst;
+    }
+};
+
+int QVistaHelper::instanceCount = 0;
 int QVistaHelper::m_devicePixelRatio = 1;
+QVistaHelper::VistaState QVistaHelper::cachedVistaState = QVistaHelper::Dirty;
 
 /******************************************************************************
 ** QVistaBackButton
@@ -116,14 +149,18 @@ QVistaHelper::QVistaHelper(QWizard *wizard)
     , backButton_(0)
 {
     QVistaHelper::m_devicePixelRatio = wizard->devicePixelRatio();
-
+    if (instanceCount++ == 0)
+        cachedVistaState = Dirty;
     backButton_ = new QVistaBackButton(wizard);
     backButton_->hide();
 
     iconSpacing = QStyleHelper::dpiScaled(7, wizard);
 }
 
-QVistaHelper::~QVistaHelper() = default;
+QVistaHelper::~QVistaHelper()
+{
+    --instanceCount;
+}
 
 void QVistaHelper::updateCustomMargins(bool vistaMargins)
 {
@@ -144,6 +181,30 @@ void QVistaHelper::updateCustomMargins(bool vistaMargins)
     }
 }
 
+bool QVistaHelper::isCompositionEnabled()
+{
+    // DWM composition is always enabled and can't be disabled since Win8.
+    if (QOperatingSystemVersion::isWin8OrGreater())
+        return true;
+    if (!DwmApis::instance()->isDwmAvailable())
+        return false;
+    BOOL enabled = FALSE;
+    return SUCCEEDED(DwmApis::instance()->pDwmIsCompositionEnabled(&enabled)) && enabled != FALSE;
+}
+
+bool QVistaHelper::isThemeActive()
+{
+    return IsThemeActive();
+}
+
+QVistaHelper::VistaState QVistaHelper::vistaState()
+{
+    if (instanceCount == 0 || cachedVistaState == Dirty)
+        cachedVistaState =
+            isCompositionEnabled() ? VistaAero : isThemeActive() ? VistaBasic : Classic;
+    return cachedVistaState;
+}
+
 void QVistaHelper::disconnectBackButton()
 {
     if (backButton_) // Leave QStyleSheetStyle's connections on destroyed() intact.
@@ -164,16 +225,20 @@ QColor QVistaHelper::basicWindowFrameColor()
 
 bool QVistaHelper::setDWMTitleBar(TitleBarChangeType type)
 {
-    MARGINS mar = {0, 0, 0, 0};
-    if (type == NormalTitleBar)
-        mar.cyTopHeight = 0;
-    else
-        mar.cyTopHeight = (titleBarSize() + topOffset(wizard)) * QVistaHelper::m_devicePixelRatio;
-    if (const HWND wizardHandle = wizardHWND()) {
-        if (SUCCEEDED(DwmExtendFrameIntoClientArea(wizardHandle, &mar)))
-            return true;
+    if (!DwmApis::instance()->isDwmAvailable())
+        return false;
+    bool value = false;
+    if (vistaState() == VistaAero) {
+        MARGINS mar = {0, 0, 0, 0};
+        if (type == NormalTitleBar)
+            mar.cyTopHeight = 0;
+        else
+            mar.cyTopHeight = (titleBarSize() + topOffset(wizard)) * QVistaHelper::m_devicePixelRatio;
+        if (const HWND wizardHandle = wizardHWND())
+            if (SUCCEEDED(DwmApis::instance()->pDwmExtendFrameIntoClientArea(wizardHandle, &mar)))
+                value = true;
     }
-    return false;
+    return value;
 }
 
 Q_GUI_EXPORT HICON qt_pixmapToWinHICON(const QPixmap &);
@@ -209,7 +274,7 @@ void QVistaHelper::drawTitleBar(QPainter *painter)
     const bool isWindow = wizard->isWindow();
     const HDC hdc = QVistaHelper::backingStoreDC(wizard, &origin);
 
-    if (isWindow)
+    if (vistaState() == VistaAero && isWindow)
         drawBlackRect(QRect(0, 0, wizard->width(),
                             titleBarSize() + topOffset(wizard)), hdc);
     // The button is positioned in QWizardPrivate::handleAeroStyleChange(),
@@ -224,9 +289,15 @@ void QVistaHelper::drawTitleBar(QPainter *painter)
         font = QApplication::font("QMdiSubWindowTitleBar");
     const QFontMetrics fontMetrics(font);
     const QRect brect = fontMetrics.boundingRect(text);
-    const int glowOffset = glowSize(wizard);
-    int textHeight = brect.height() + 2 * glowOffset;
-    int textWidth = brect.width() + 2 * glowOffset;
+    int textHeight = brect.height();
+    int textWidth = brect.width();
+    int glowOffset = 0;
+
+    if (vistaState() == VistaAero) {
+        glowOffset = glowSize(wizard);
+        textHeight += 2 * glowOffset;
+        textWidth += 2 * glowOffset;
+    }
 
     const int titleLeft = (wizard->layoutDirection() == Qt::LeftToRight
                            ? titleOffset() - glowOffset
@@ -275,7 +346,9 @@ bool QVistaHelper::winEvent(MSG* msg, qintptr *result)
     case WM_NCHITTEST: {
         LRESULT lResult;
         // Perform hit testing using DWM
-        if (DwmDefWindowProc(msg->hwnd, msg->message, msg->wParam, msg->lParam, &lResult)) {
+        if (DwmApis::instance()->isDwmAvailable() &&
+                DwmApis::instance()->pDwmDefWindowProc(
+                    msg->hwnd, msg->message, msg->wParam, msg->lParam, &lResult)) {
             // DWM returned a hit, no further processing necessary
             *result = lResult;
         } else {
@@ -294,7 +367,9 @@ bool QVistaHelper::winEvent(MSG* msg, qintptr *result)
     default:
         LRESULT lResult;
         // Pass to DWM to handle
-        if (DwmDefWindowProc(msg->hwnd, msg->message, msg->wParam, msg->lParam, &lResult))
+        if (DwmApis::instance()->isDwmAvailable() &&
+                DwmApis::instance()->pDwmDefWindowProc(
+                    msg->hwnd, msg->message, msg->wParam, msg->lParam, &lResult))
             *result = lResult;
         // If the message wasn't handled by DWM, continue processing it as normal
         else
@@ -333,8 +408,11 @@ void QVistaHelper::mouseEvent(QEvent *event)
 
 bool QVistaHelper::handleWinEvent(MSG *message, qintptr *result)
 {
+    if (message->message == WM_THEMECHANGED || message->message == WM_DWMCOMPOSITIONCHANGED)
+        cachedVistaState = Dirty;
+
     bool status = false;
-    if (wizard->wizardStyle() == QWizard::AeroStyle) {
+    if (wizard->wizardStyle() == QWizard::AeroStyle && vistaState() == VistaAero) {
         status = winEvent(message, result);
         if (message->message == WM_NCPAINT)
             wizard->update();
@@ -347,6 +425,8 @@ void QVistaHelper::resizeEvent(QResizeEvent * event)
     Q_UNUSED(event);
     rtTop = QRect (0, 0, wizard->width(), frameSize());
     int height = captionSize() + topOffset(wizard);
+    if (vistaState() == VistaBasic)
+        height -= titleBarSize();
     rtTitle = QRect (0, frameSize(), wizard->width(), height);
 }
 
@@ -385,7 +465,7 @@ void QVistaHelper::mouseMoveEvent(QMouseEvent *event)
         }
         wizard->setGeometry(rect);
 
-    } else {
+    } else if (vistaState() == VistaAero) {
         setMouseCursor(event->pos());
     }
     event->ignore();
@@ -403,10 +483,11 @@ void QVistaHelper::mousePressEvent(QMouseEvent *event)
     if (rtTitle.contains(event->pos())) {
         change = movePosition;
     } else if (rtTop.contains(event->pos()))
-        change = resizeTop;
+        change = (vistaState() == VistaAero) ? resizeTop : movePosition;
 
     if (change != noChange) {
-        setMouseCursor(event->pos());
+        if (vistaState() == VistaAero)
+            setMouseCursor(event->pos());
         pressed = true;
         pressedPos = event->pos();
     } else {
@@ -420,7 +501,8 @@ void QVistaHelper::mouseReleaseEvent(QMouseEvent *event)
     if (pressed) {
         pressed = false;
         wizard->releaseMouse();
-        setMouseCursor(event->pos());
+        if (vistaState() == VistaAero)
+            setMouseCursor(event->pos());
     }
     event->ignore();
 }
@@ -508,83 +590,90 @@ HWND QVistaHelper::wizardHWND() const
     return 0;
 }
 
-void QVistaHelper::drawTitleText(QPainter *painter, const QString &text, const QRect &rect, HDC hdc)
+bool QVistaHelper::drawTitleText(QPainter *painter, const QString &text, const QRect &rect, HDC hdc)
 {
-    Q_UNUSED(painter);
-
-    const QRect rectDp = QRect(rect.topLeft() * QVistaHelper::m_devicePixelRatio,
-                               rect.size() * QVistaHelper::m_devicePixelRatio);
-    const HANDLE hTheme = OpenThemeData(GetDesktopWindow(), L"WINDOW");
-    if (!hTheme)
-        return;
-    // Set up a memory DC and bitmap that we'll draw into
-    HDC dcMem;
-    HBITMAP bmp;
-    BITMAPINFO dib;
-    ZeroMemory(&dib, sizeof(dib));
-    dcMem = CreateCompatibleDC(hdc);
-
-    dib.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
-    dib.bmiHeader.biWidth = rectDp.width();
-    dib.bmiHeader.biHeight = -rectDp.height();
-    dib.bmiHeader.biPlanes = 1;
-    dib.bmiHeader.biBitCount = 32;
-    dib.bmiHeader.biCompression = BI_RGB;
-
-    bmp = CreateDIBSection(hdc, &dib, DIB_RGB_COLORS, NULL, NULL, 0);
-
-    // Set up the DC
-    const LOGFONT captionLogFont = getCaptionLogFont(hTheme);
-    const HFONT hCaptionFont = CreateFontIndirect(&captionLogFont);
-    auto hOldBmp = reinterpret_cast<HBITMAP>(SelectObject(dcMem, (HGDIOBJ) bmp));
-    auto hOldFont = reinterpret_cast<HFONT>(SelectObject(dcMem, (HGDIOBJ) hCaptionFont));
-
-    // Draw the text!
-    DTTOPTS dto;
-    memset(&dto, 0, sizeof(dto));
-    dto.dwSize = sizeof(dto);
-    const UINT uFormat = DT_SINGLELINE|DT_CENTER|DT_VCENTER|DT_NOPREFIX;
-    RECT rctext ={0,0, rectDp.width(), rectDp.height()};
-
-    dto.dwFlags = DTT_COMPOSITED|DTT_GLOWSIZE;
-    dto.iGlowSize = glowSize(wizard);
-
-    DrawThemeTextEx(hTheme, dcMem, 0, 0, reinterpret_cast<LPCWSTR>(text.utf16()), -1, uFormat, &rctext, &dto );
-    BitBlt(hdc, rectDp.left(), rectDp.top(), rectDp.width(), rectDp.height(), dcMem, 0, 0, SRCCOPY);
-    SelectObject(dcMem, (HGDIOBJ) hOldBmp);
-    SelectObject(dcMem, (HGDIOBJ) hOldFont);
-    DeleteObject(bmp);
-    DeleteObject(hCaptionFont);
-    DeleteDC(dcMem);
-    //ReleaseDC(hwnd, hdc);
-}
-
-void QVistaHelper::drawBlackRect(const QRect &rect, HDC hdc)
-{
-    // Set up a memory DC and bitmap that we'll draw into
-    const QRect rectDp = QRect(rect.topLeft() * QVistaHelper::m_devicePixelRatio,
+    bool value = false;
+    if (vistaState() == VistaAero) {
+        const QRect rectDp = QRect(rect.topLeft() * QVistaHelper::m_devicePixelRatio,
                                    rect.size() * QVistaHelper::m_devicePixelRatio);
-    HDC dcMem;
-    HBITMAP bmp;
-    BITMAPINFO dib;
-    ZeroMemory(&dib, sizeof(dib));
-    dcMem = CreateCompatibleDC(hdc);
-
-    dib.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
-    dib.bmiHeader.biWidth = rectDp.width();
-    dib.bmiHeader.biHeight = -rectDp.height();
-    dib.bmiHeader.biPlanes = 1;
-    dib.bmiHeader.biBitCount = 32;
-    dib.bmiHeader.biCompression = BI_RGB;
-
-    bmp = CreateDIBSection(hdc, &dib, DIB_RGB_COLORS, NULL, NULL, 0);
-    auto hOldBmp = reinterpret_cast<HBITMAP>(SelectObject(dcMem, (HGDIOBJ) bmp));
-
-    BitBlt(hdc, rectDp.left(), rectDp.top(), rectDp.width(), rectDp.height(), dcMem, 0, 0, SRCCOPY);
-    SelectObject(dcMem, (HGDIOBJ) hOldBmp);
+        const HANDLE hTheme = OpenThemeData(GetDesktopWindow(), L"WINDOW");
+        if (!hTheme) return false;
+        // Set up a memory DC and bitmap that we'll draw into
+        HDC dcMem;
+        HBITMAP bmp;
+        BITMAPINFO dib;
+        ZeroMemory(&dib, sizeof(dib));
+        dcMem = CreateCompatibleDC(hdc);
+
+        dib.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+        dib.bmiHeader.biWidth = rectDp.width();
+        dib.bmiHeader.biHeight = -rectDp.height();
+        dib.bmiHeader.biPlanes = 1;
+        dib.bmiHeader.biBitCount = 32;
+        dib.bmiHeader.biCompression = BI_RGB;
+
+        bmp = CreateDIBSection(hdc, &dib, DIB_RGB_COLORS, NULL, NULL, 0);
+
+        // Set up the DC
+        const LOGFONT captionLogFont = getCaptionLogFont(hTheme);
+        const HFONT hCaptionFont = CreateFontIndirect(&captionLogFont);
+        auto hOldBmp = reinterpret_cast<HBITMAP>(SelectObject(dcMem, (HGDIOBJ) bmp));
+        auto hOldFont = reinterpret_cast<HFONT>(SelectObject(dcMem, (HGDIOBJ) hCaptionFont));
+
+        // Draw the text!
+        DTTOPTS dto;
+        memset(&dto, 0, sizeof(dto));
+        dto.dwSize = sizeof(dto);
+        const UINT uFormat = DT_SINGLELINE|DT_CENTER|DT_VCENTER|DT_NOPREFIX;
+        RECT rctext ={0,0, rectDp.width(), rectDp.height()};
+
+        dto.dwFlags = DTT_COMPOSITED|DTT_GLOWSIZE;
+        dto.iGlowSize = glowSize(wizard);
+
+        DrawThemeTextEx(hTheme, dcMem, 0, 0, reinterpret_cast<LPCWSTR>(text.utf16()), -1, uFormat, &rctext, &dto );
+        BitBlt(hdc, rectDp.left(), rectDp.top(), rectDp.width(), rectDp.height(), dcMem, 0, 0, SRCCOPY);
+        SelectObject(dcMem, (HGDIOBJ) hOldBmp);
+        SelectObject(dcMem, (HGDIOBJ) hOldFont);
+        DeleteObject(bmp);
+        DeleteObject(hCaptionFont);
+        DeleteDC(dcMem);
+        //ReleaseDC(hwnd, hdc);
+    } else if (vistaState() == VistaBasic) {
+        painter->drawText(rect, text);
+    }
+    return value;
+}
 
-    DeleteObject(bmp);
-    DeleteDC(dcMem);
+bool QVistaHelper::drawBlackRect(const QRect &rect, HDC hdc)
+{
+    bool value = false;
+    if (vistaState() == VistaAero) {
+        // Set up a memory DC and bitmap that we'll draw into
+        const QRect rectDp = QRect(rect.topLeft() * QVistaHelper::m_devicePixelRatio,
+                                   rect.size() * QVistaHelper::m_devicePixelRatio);
+        HDC dcMem;
+        HBITMAP bmp;
+        BITMAPINFO dib;
+        ZeroMemory(&dib, sizeof(dib));
+        dcMem = CreateCompatibleDC(hdc);
+
+        dib.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+        dib.bmiHeader.biWidth = rectDp.width();
+        dib.bmiHeader.biHeight = -rectDp.height();
+        dib.bmiHeader.biPlanes = 1;
+        dib.bmiHeader.biBitCount = 32;
+        dib.bmiHeader.biCompression = BI_RGB;
+
+        bmp = CreateDIBSection(hdc, &dib, DIB_RGB_COLORS, NULL, NULL, 0);
+        auto hOldBmp = reinterpret_cast<HBITMAP>(SelectObject(dcMem, (HGDIOBJ) bmp));
+
+        BitBlt(hdc, rectDp.left(), rectDp.top(), rectDp.width(), rectDp.height(), dcMem, 0, 0, SRCCOPY);
+        SelectObject(dcMem, (HGDIOBJ) hOldBmp);
+
+        DeleteObject(bmp);
+        DeleteDC(dcMem);
+    }
+    return value;
 }
 
 int QVistaHelper::frameSizeDp()
@@ -615,7 +704,11 @@ int QVistaHelper::glowSize(const QPaintDevice *device)
 
 int QVistaHelper::topOffset(const QPaintDevice *device)
 {
-    static const int aeroOffset = QStyleHelper::dpiScaled(13, device);
+    if (vistaState() != VistaAero)
+        return titleBarSize() + 3;
+    static const int aeroOffset =
+        QOperatingSystemVersion::isWin8OrGreater() ?
+        QStyleHelper::dpiScaled(13, device) : QStyleHelper::dpiScaled(4, device);
     return aeroOffset + titleBarSize();
 }
 
diff --git a/src/widgets/dialogs/qwizard_win_p.h b/src/widgets/dialogs/qwizard_win_p.h
index 45f26a1ebf..71dfc15b4d 100644
--- a/src/widgets/dialogs/qwizard_win_p.h
+++ b/src/widgets/dialogs/qwizard_win_p.h
@@ -64,6 +64,8 @@ public:
     void disconnectBackButton();
     void hideBackButton() { if (backButton_) backButton_->hide(); }
     QColor basicWindowFrameColor();
+    enum VistaState { VistaAero, VistaBasic, Classic, Dirty };
+    static VistaState vistaState();
     static int titleBarSize() { return QVistaHelper::titleBarSizeDp() / QVistaHelper::m_devicePixelRatio; }
     static int titleBarSizeDp() { return QVistaHelper::frameSizeDp() + QVistaHelper::captionSizeDp(); }
     static int topPadding(const QPaintDevice *device) { // padding under text
@@ -75,8 +77,8 @@ public:
 
 private:
     HWND wizardHWND() const;
-    void drawTitleText(QPainter *painter, const QString &text, const QRect &rect, HDC hdc);
-    static void drawBlackRect(const QRect &rect, HDC hdc);
+    bool drawTitleText(QPainter *painter, const QString &text, const QRect &rect, HDC hdc);
+    static bool drawBlackRect(const QRect &rect, HDC hdc);
 
     static int frameSize() { return QVistaHelper::frameSizeDp() / QVistaHelper::m_devicePixelRatio; }
     static int frameSizeDp();
@@ -100,6 +102,10 @@ private:
     void mouseReleaseEvent(QMouseEvent *event);
     bool eventFilter(QObject *obj, QEvent *event) override;
 
+    static int instanceCount;
+    static VistaState cachedVistaState;
+    static bool isCompositionEnabled();
+    static bool isThemeActive();
     enum Changes { resizeTop, movePosition, noChange } change;
     QPoint pressedPos;
     bool pressed;
-- 
2.39.0.windows.1

