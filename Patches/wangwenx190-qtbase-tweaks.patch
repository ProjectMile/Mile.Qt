From 21310e6ebf92cd5a2c2762a64dd7e51ca962eb38 Mon Sep 17 00:00:00 2001
From: Yuhang Zhao <2546789017@qq.com>
Date: Fri, 17 Jun 2022 20:33:03 +0800
Subject: [PATCH] wangwenx190: Custom tweaks

Important changes list:

01. Win32: Remove WS_POPUP for most cases.
02. Win32: Disable the Direct2D QPA, it's useless and has bad performance.
03. Disable the offscreen QPA, it's useless.
04. Disable the minimal QPA, it's useless.
05. Win32: Add more entries to QOperatingSystemVersion.
06. Win32: Add environment variable to add offset to the system menu.
07. Win32: Add environment variable to disable bitmap redirection.
08. Win32: Restore Windows 7 RTM compatibility (QtMutex & QtRhi & QPA).
09. MSVC: Add support for VC-LTL (reduce final binary size).
10. MSVC: Add support for YY-Thunks (can help Qt run on Windows Vista RTM).
11. Add ZSTD to the bundled libraries.
12. Other minor tweaks.

Signed-off-by: Yuhang Zhao <2546789017@qq.com>
---
 bin/xmlstarlet.exe                            |  Bin 0 -> 2265088 bytes
 build-test.bat                                |  158 +
 cmake/FindWrapSystemZSTD.cmake                |   91 +
 cmake/FindWrapZSTD.cmake                      |  101 +-
 cmake/Qt3rdPartyLibraryHelpers.cmake          |    6 -
 cmake/QtBaseGlobalTargets.cmake               |    2 +
 cmake/QtBuild.cmake                           |   14 +
 cmake/QtCompilerFlags.cmake                   |    4 +-
 cmake/QtCompilerOptimization.cmake            |   86 +-
 cmake/QtFeature.cmake                         |    7 +-
 cmake/QtFlagHandlingHelpers.cmake             |   18 +-
 cmake/QtInternalTargets.cmake                 |  128 +-
 cmake/QtModuleHelpers.cmake                   |    3 -
 cmake/QtPlatformTargetHelpers.cmake           |   10 +
 cmake/VC-LTL.cmake                            |   94 +
 cmake/YY-Thunks.cmake                         |  102 +
 cmake/configure-cmake-mapping.md              |    1 +
 config_help.txt                               |    1 +
 configure.cmake                               |   25 +-
 mkspecs/features/resources.prf                |    1 -
 qmake/CMakeLists.txt                          |    6 -
 qt_cmdline.cmake                              |    5 +-
 src/3rdparty/zstd/CMakeLists.txt              |  105 +
 src/3rdparty/zstd/LICENSE                     |   30 +
 src/3rdparty/zstd/qt_attribution.json         |   17 +
 src/3rdparty/zstd/src/common/allocations.h    |   55 +
 src/3rdparty/zstd/src/common/bits.h           |  200 +
 src/3rdparty/zstd/src/common/bitstream.h      |  437 +
 src/3rdparty/zstd/src/common/compiler.h       |  358 +
 src/3rdparty/zstd/src/common/cpu.h            |  213 +
 src/3rdparty/zstd/src/common/debug.c          |   24 +
 src/3rdparty/zstd/src/common/debug.h          |  107 +
 src/3rdparty/zstd/src/common/entropy_common.c |  340 +
 src/3rdparty/zstd/src/common/error_private.c  |   63 +
 src/3rdparty/zstd/src/common/error_private.h  |  159 +
 src/3rdparty/zstd/src/common/fse.h            |  639 ++
 src/3rdparty/zstd/src/common/fse_decompress.c |  311 +
 src/3rdparty/zstd/src/common/huf.h            |  273 +
 src/3rdparty/zstd/src/common/mem.h            |  435 +
 src/3rdparty/zstd/src/common/pool.c           |  371 +
 src/3rdparty/zstd/src/common/pool.h           |   90 +
 .../zstd/src/common/portability_macros.h      |  156 +
 src/3rdparty/zstd/src/common/threading.c      |  176 +
 src/3rdparty/zstd/src/common/threading.h      |  150 +
 src/3rdparty/zstd/src/common/xxhash.c         |   24 +
 src/3rdparty/zstd/src/common/xxhash.h         | 5686 +++++++++++++
 src/3rdparty/zstd/src/common/zstd_common.c    |   48 +
 src/3rdparty/zstd/src/common/zstd_deps.h      |  111 +
 src/3rdparty/zstd/src/common/zstd_internal.h  |  392 +
 src/3rdparty/zstd/src/common/zstd_trace.h     |  163 +
 src/3rdparty/zstd/src/compress/clevels.h      |  134 +
 src/3rdparty/zstd/src/compress/fse_compress.c |  624 ++
 src/3rdparty/zstd/src/compress/hist.c         |  181 +
 src/3rdparty/zstd/src/compress/hist.h         |   75 +
 src/3rdparty/zstd/src/compress/huf_compress.c | 1435 ++++
 .../zstd/src/compress/zstd_compress.c         | 7032 +++++++++++++++++
 .../src/compress/zstd_compress_internal.h     | 1532 ++++
 .../src/compress/zstd_compress_literals.c     |  235 +
 .../src/compress/zstd_compress_literals.h     |   39 +
 .../src/compress/zstd_compress_sequences.c    |  442 ++
 .../src/compress/zstd_compress_sequences.h    |   54 +
 .../src/compress/zstd_compress_superblock.c   |  577 ++
 .../src/compress/zstd_compress_superblock.h   |   32 +
 src/3rdparty/zstd/src/compress/zstd_cwksp.h   |  742 ++
 .../zstd/src/compress/zstd_double_fast.c      |  758 ++
 .../zstd/src/compress/zstd_double_fast.h      |   39 +
 src/3rdparty/zstd/src/compress/zstd_fast.c    |  960 +++
 src/3rdparty/zstd/src/compress/zstd_fast.h    |   38 +
 src/3rdparty/zstd/src/compress/zstd_lazy.c    | 2157 +++++
 src/3rdparty/zstd/src/compress/zstd_lazy.h    |  127 +
 src/3rdparty/zstd/src/compress/zstd_ldm.c     |  724 ++
 src/3rdparty/zstd/src/compress/zstd_ldm.h     |  117 +
 .../zstd/src/compress/zstd_ldm_geartab.h      |  106 +
 src/3rdparty/zstd/src/compress/zstd_opt.c     | 1472 ++++
 src/3rdparty/zstd/src/compress/zstd_opt.h     |   56 +
 .../zstd/src/compress/zstdmt_compress.c       | 1867 +++++
 .../zstd/src/compress/zstdmt_compress.h       |  113 +
 .../zstd/src/decompress/huf_decompress.c      | 1882 +++++
 .../src/decompress/huf_decompress_amd64.S     |  576 ++
 src/3rdparty/zstd/src/decompress/zstd_ddict.c |  244 +
 src/3rdparty/zstd/src/decompress/zstd_ddict.h |   44 +
 .../zstd/src/decompress/zstd_decompress.c     | 2355 ++++++
 .../src/decompress/zstd_decompress_block.c    | 2192 +++++
 .../src/decompress/zstd_decompress_block.h    |   73 +
 .../src/decompress/zstd_decompress_internal.h |  238 +
 src/3rdparty/zstd/src/dictBuilder/cover.c     | 1257 +++
 src/3rdparty/zstd/src/dictBuilder/cover.h     |  158 +
 .../zstd/src/dictBuilder/divsufsort.c         | 1913 +++++
 .../zstd/src/dictBuilder/divsufsort.h         |   67 +
 src/3rdparty/zstd/src/dictBuilder/fastcover.c |  766 ++
 src/3rdparty/zstd/src/dictBuilder/zdict.c     | 1127 +++
 src/3rdparty/zstd/src/zdict.h                 |  474 ++
 src/3rdparty/zstd/src/zstd.h                  | 3020 +++++++
 src/3rdparty/zstd/src/zstd_errors.h           |  114 +
 src/CMakeLists.txt                            |   31 +-
 src/corelib/CMakeLists.txt                    |   36 +-
 src/corelib/Qt6CoreMacros.cmake               |   22 -
 src/corelib/configure.cmake                   |    2 -
 src/corelib/global/qlibraryinfo.cpp           |   20 +-
 src/corelib/global/qlibraryinfo.h             |    5 +
 .../global/qoperatingsystemversion.cpp        |   10 +
 src/corelib/global/qoperatingsystemversion.h  |   40 +
 .../global/qoperatingsystemversion_win.cpp    |   20 +-
 src/corelib/global/qsysinfo.cpp               |   34 +-
 src/corelib/io/qfilesystemengine_win.cpp      |  108 +-
 src/corelib/io/qfilesystemiterator_win.cpp    |    6 +-
 src/corelib/io/qlockfile_win.cpp              |   14 +-
 src/corelib/io/qresource.cpp                  |   45 +-
 src/corelib/io/qstandardpaths_win.cpp         |    4 +
 src/corelib/kernel/qcoreapplication.cpp       |   39 +
 src/corelib/kernel/qeventdispatcher_win.cpp   |   12 +-
 src/corelib/kernel/qfunctions_win.cpp         |   10 +-
 src/corelib/mimetypes/qmimeprovider.cpp       |    2 +-
 src/corelib/plugin/qsystemlibrary.cpp         |   30 +-
 src/corelib/text/qlocale_win.cpp              |   23 +-
 src/corelib/thread/qfutex_p.h                 |   76 +-
 src/corelib/thread/qlocking_p.h               |    7 +-
 src/corelib/thread/qmutex.cpp                 |    2 +
 src/corelib/thread/qmutex_p.h                 |    9 +-
 src/corelib/thread/qmutex_win.cpp             |   30 +
 src/corelib/thread/qwaitcondition_p.h         |    7 +-
 src/gui/CMakeLists.txt                        |   36 +-
 .../windows/apisupport/qwindowsuiawrapper.cpp |   78 +-
 .../windows/apisupport/qwindowsuiawrapper_p.h |   26 +-
 src/gui/image/qimage.cpp                      |    8 +-
 src/gui/image/qimagereader.cpp                |    1 +
 src/gui/kernel/qhighdpiscaling.cpp            |    4 +-
 src/gui/opengl/qopengl.cpp                    |   32 +-
 src/gui/rhi/qrhid3d11.cpp                     |  538 +-
 src/gui/rhi/qrhid3d11_p_p.h                   |    3 +-
 .../qwindowsdirectwritefontdatabase.cpp       |    6 +-
 src/gui/text/windows/qwindowsfontdatabase.cpp |    3 +-
 .../text/windows/qwindowsfontdatabasebase.cpp |   21 +-
 .../windows/qwindowsfontenginedirectwrite.cpp |    9 +-
 src/network/CMakeLists.txt                    |   23 +-
 src/network/access/qdecompresshelper.cpp      |   21 +-
 .../socket/qnativesocketengine_win.cpp        |   21 +-
 .../imageformats/jpeg/qjpeghandler.cpp        |    3 +
 .../networklistmanager/CMakeLists.txt         |    5 -
 .../qnetworklistmanagerevents.cpp             |   64 +-
 src/plugins/platforms/CMakeLists.txt          |    9 -
 src/plugins/platforms/direct2d/CMakeLists.txt |    9 -
 src/plugins/platforms/windows/CMakeLists.txt  |    4 -
 .../platforms/windows/qtwindowsglobal.h       |   17 +-
 .../platforms/windows/qwin10helpers.cpp       |   43 +-
 .../platforms/windows/qwindowscontext.cpp     |  401 +-
 .../platforms/windows/qwindowscontext.h       |  137 +-
 .../windows/qwindowsdialoghelpers.cpp         |    3 +-
 .../platforms/windows/qwindowsdrag.cpp        |    7 +-
 .../platforms/windows/qwindowsintegration.cpp |   32 +-
 .../platforms/windows/qwindowskeymapper.cpp   |   18 +-
 .../windows/qwindowsmousehandler.cpp          |   11 +-
 .../windows/qwindowsopengltester.cpp          |    6 +-
 .../windows/qwindowspointerhandler.cpp        |   25 +-
 .../platforms/windows/qwindowsscreen.cpp      |   70 +-
 .../windows/qwindowssystemtrayicon.cpp        |    8 +-
 .../platforms/windows/qwindowstheme.cpp       |  146 +-
 .../platforms/windows/qwindowswindow.cpp      |  151 +-
 .../windowsvista/qwindowsvistastyle.cpp       |   31 +
 .../windowsvista/qwindowsvistastyle_p_p.h     |    1 +
 src/tools/rcc/CMakeLists.txt                  |   15 +-
 src/tools/rcc/main.cpp                        |   13 +-
 src/tools/rcc/rcc.cpp                         |   34 +-
 src/tools/rcc/rcc.h                           |    2 -
 src/widgets/CMakeLists.txt                    |    1 -
 src/widgets/dialogs/qwizard_win.cpp           |   55 +-
 src/widgets/kernel/qwidget.cpp                |   18 +
 167 files changed, 51935 insertions(+), 1042 deletions(-)
 create mode 100644 bin/xmlstarlet.exe
 create mode 100644 build-test.bat
 create mode 100644 cmake/FindWrapSystemZSTD.cmake
 create mode 100644 cmake/VC-LTL.cmake
 create mode 100644 cmake/YY-Thunks.cmake
 create mode 100644 src/3rdparty/zstd/CMakeLists.txt
 create mode 100644 src/3rdparty/zstd/LICENSE
 create mode 100644 src/3rdparty/zstd/qt_attribution.json
 create mode 100644 src/3rdparty/zstd/src/common/allocations.h
 create mode 100644 src/3rdparty/zstd/src/common/bits.h
 create mode 100644 src/3rdparty/zstd/src/common/bitstream.h
 create mode 100644 src/3rdparty/zstd/src/common/compiler.h
 create mode 100644 src/3rdparty/zstd/src/common/cpu.h
 create mode 100644 src/3rdparty/zstd/src/common/debug.c
 create mode 100644 src/3rdparty/zstd/src/common/debug.h
 create mode 100644 src/3rdparty/zstd/src/common/entropy_common.c
 create mode 100644 src/3rdparty/zstd/src/common/error_private.c
 create mode 100644 src/3rdparty/zstd/src/common/error_private.h
 create mode 100644 src/3rdparty/zstd/src/common/fse.h
 create mode 100644 src/3rdparty/zstd/src/common/fse_decompress.c
 create mode 100644 src/3rdparty/zstd/src/common/huf.h
 create mode 100644 src/3rdparty/zstd/src/common/mem.h
 create mode 100644 src/3rdparty/zstd/src/common/pool.c
 create mode 100644 src/3rdparty/zstd/src/common/pool.h
 create mode 100644 src/3rdparty/zstd/src/common/portability_macros.h
 create mode 100644 src/3rdparty/zstd/src/common/threading.c
 create mode 100644 src/3rdparty/zstd/src/common/threading.h
 create mode 100644 src/3rdparty/zstd/src/common/xxhash.c
 create mode 100644 src/3rdparty/zstd/src/common/xxhash.h
 create mode 100644 src/3rdparty/zstd/src/common/zstd_common.c
 create mode 100644 src/3rdparty/zstd/src/common/zstd_deps.h
 create mode 100644 src/3rdparty/zstd/src/common/zstd_internal.h
 create mode 100644 src/3rdparty/zstd/src/common/zstd_trace.h
 create mode 100644 src/3rdparty/zstd/src/compress/clevels.h
 create mode 100644 src/3rdparty/zstd/src/compress/fse_compress.c
 create mode 100644 src/3rdparty/zstd/src/compress/hist.c
 create mode 100644 src/3rdparty/zstd/src/compress/hist.h
 create mode 100644 src/3rdparty/zstd/src/compress/huf_compress.c
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_compress.c
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_compress_internal.h
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_compress_literals.c
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_compress_literals.h
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_compress_sequences.c
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_compress_sequences.h
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_compress_superblock.c
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_compress_superblock.h
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_cwksp.h
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_double_fast.c
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_double_fast.h
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_fast.c
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_fast.h
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_lazy.c
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_lazy.h
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_ldm.c
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_ldm.h
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_ldm_geartab.h
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_opt.c
 create mode 100644 src/3rdparty/zstd/src/compress/zstd_opt.h
 create mode 100644 src/3rdparty/zstd/src/compress/zstdmt_compress.c
 create mode 100644 src/3rdparty/zstd/src/compress/zstdmt_compress.h
 create mode 100644 src/3rdparty/zstd/src/decompress/huf_decompress.c
 create mode 100644 src/3rdparty/zstd/src/decompress/huf_decompress_amd64.S
 create mode 100644 src/3rdparty/zstd/src/decompress/zstd_ddict.c
 create mode 100644 src/3rdparty/zstd/src/decompress/zstd_ddict.h
 create mode 100644 src/3rdparty/zstd/src/decompress/zstd_decompress.c
 create mode 100644 src/3rdparty/zstd/src/decompress/zstd_decompress_block.c
 create mode 100644 src/3rdparty/zstd/src/decompress/zstd_decompress_block.h
 create mode 100644 src/3rdparty/zstd/src/decompress/zstd_decompress_internal.h
 create mode 100644 src/3rdparty/zstd/src/dictBuilder/cover.c
 create mode 100644 src/3rdparty/zstd/src/dictBuilder/cover.h
 create mode 100644 src/3rdparty/zstd/src/dictBuilder/divsufsort.c
 create mode 100644 src/3rdparty/zstd/src/dictBuilder/divsufsort.h
 create mode 100644 src/3rdparty/zstd/src/dictBuilder/fastcover.c
 create mode 100644 src/3rdparty/zstd/src/dictBuilder/zdict.c
 create mode 100644 src/3rdparty/zstd/src/zdict.h
 create mode 100644 src/3rdparty/zstd/src/zstd.h
 create mode 100644 src/3rdparty/zstd/src/zstd_errors.h
 create mode 100644 src/corelib/thread/qmutex_win.cpp

diff --git a/bin/xmlstarlet.exe b/bin/xmlstarlet.exe
new file mode 100644
index 0000000000000000000000000000000000000000..830dc3f7c753e9793764ab73426aa8217b389462
GIT binary patch
literal 2265088
zcmeFadw5jU^*?+jIe|e2&Y(e~L>Y0ai3FO|XcH53fCNxcgM>@DSWt}gTU68;#R`}>
zGm^t`AX-$kwi2-xZ!LaB3|^RAAOl)0;HBYeplZ)JVB?LelK1o3`<zJz(f;1|dEWQ0
zmq#<_?7jBdYpuQZ+H0?UIag1qQ_>YhQSpCgr=m3Am;Zd??@#}!Mt0wUulH5f^m_N)
z2FKWU&#j#On>#&o@3`&eJ7(VExpC&Lx8COW+;EfUj=-&+-`wgcyLP<imfL3CG_+5j
zQ@j@HigHC6>*%FyEc~?4uB~0^o8H@zmZi+=rzj5&Qj}?m(w>Q2H~z0f8mZ%Rnxxx-
zN766;<)0^BK6!kQ;7d_F5|#y62LHs5dywK9h?o39%7dqh<dgrIi~8R>c@|UE8H1Fp
zlVs1mXpr&===-sML;W|+^CPqDZtz2b$ZL`bS!#w-F=Obgnf{r0&2!-odGCwg`IJG|
zKc6zAap)ZqaFqsRD~J=ni%*1`>l=E*op-Wi<5c`veQp<$Zco+9+{U3dNqj;^kQK$K
zJdq0TQ}TU7e<R_93?WN}?ezK&;2MXHysnZ}6!K36;3%8-P6FqjBk1!G4zd++TTTLZ
z$4zr?yAd#K8@ADU{BHXJ+z6!p|NnkM0$;a8)|}7$$eS1NC%8Ymps}iE82i}OQ(_ry
zU(Zw=NRMTFkbK&bd}_Cz{Igd&SI<=HKf!yr(SK!3^`@bax#Z@43Z6Uh&pb8gR*e28
zAXY9r<pyQta{Q^EU3i0{yUho}ZY4Nu*&oI!4*x9$jlm7sHd!dm>di7>O021>Gy0c;
zvYOXPA8kiuF`oj}+H2#os%nn*cK9#nPns6~A5<D#7ee8_+5^+^Vmx#hF9nU^ZQ3J^
z@vD#$xr@|QKU$%fvp|8YICzgA1@c%xH)Vm%EN~W5s_KIK^Xm75hgg}{t$=0xIy2?3
zn#Et$n~k59%&YGJpkC&6nM<nrDJ$Jb3U0`2iL3=yTiz228rQLx>Yq-U7@6?Qc>SNj
z{qw(mVRgRwi-+Ax?uJO2cR;YcBc}Wv|6)E>{y622Oa8d!Pp16Il0Vt}34YRHTr3*p
zpcbw{lgz58u_`!dOjeCyZU{e-S=^?DdLj#yn-~c?L4c}vbZ9T1{Ull_+!)wXzXA^h
zJA;QETBrl9A>PA{TFA#@87lZ<8;N8A^eJA$JGD?c^6NXE6grVjNdbxyQ<2X4_}aN8
zxZh=FEOIkp?y?G{v%d>;frypgP|kpI`_MjmKgIl;?pEr@A~%+?#c=})`xJxvc1^+N
z#2Heop>6(>;9iG+@H&zdY;<UA-PK1u3;(UZ6a3myeRPmk_D;e?!&~|e_}*PmU#|Q+
z@ET_ek?r*N*It|O!NKw^j)qf!Oe=3*snm^A>e;}0d7a)GQNuLZdijGogtv88KP7xn
zFJER1qb6ue%0NQFPW`x{{)zePkRO@n&`Z7Mvv@SFUZ$&$8?HYETO9g)uM;5pSg&e6
zfxMFGb%D)B`GY}IH3G|GY7f++=ob^Mc`1cZ1R)sxsd&1(Ui?71^~{I9sggoex&9W^
z(}!Jir3-(;o3#*?&*;xK3vUaYViuyddgeuL`ey3&zn<PATJa4bJhXS%eY~?1ZNQPz
zbQ6}kz(x)aU=AvCR-ir5O87Ak-Ut!wjAamrZLEdA|Gu+xk<g_0S9q+`GrgVt+b<Fg
z9KRJQ5}5T7S(ZfRBC_XzEdCdO6g0*UqB6?xk4Q`DKTw`n2Ahi*%*$$FM>e?P&whu_
zExK7UAK8j|j+Ora^6SLE`kW`nQH4fM&_50C&mto$#z6-^kR*m1VQCb_e>#cliyRQq
z*?*VFbn4CFZT?;;LL8mjHh<kxRR=WFTO?}n7xolgI0vobG|IeQwhn$h<Yn&?5(`V$
z-5wxQjY*5^Q-xG~9Ql=)Pj()ka9(0Q4zoxUu1Cz5E#Ex+NyRrFOc~R>9&`Lv>1?Jy
zkAoO`-Xorc$o^27u9&AULh3`;I22=~6CFFe0(bx{0A2@xag{r~IdCJTgMa2|Bn3+x
z#`r9>9(n}f&TI^}_XuxW`C$7@C6H^3^uTgt1UF<&Z9yq7BxlBFLOB}!Lm&eWGvX^A
z?INRcibF|kuBx-EC_@#ArB!wHes*^Vr3fg3jXnx)6_g?IjL5N4p1sT=bdbdT4%Kw^
z?@1FO0S}~_Z_M`=8h&r7QQ<<f^^A?0OR^1L76`ou9Z=N^z2;jD4$!E#XrVtN6O?A6
zXc2Nif|NYWIdT+H0F7!6h&dF!)fhPqox(pncsR{JP|x=2Uz<;_MF#r%S-C3Ag8!1>
z29Mr`F4hvu@SwlZq9i`7Bg7a(RpP(1#v_s0i<u1(|M?24_mTbUseA0>l!wLj3iOS{
zs)C(~XS(<$yIvL|t0>?W^!vRo7RGZSeyM@^It2MK1W9iF*-RCvb-&jcY!v!A{A0>u
zUSEBhH$S++JN5ebwK=N7H^~7_pG^NH(k(Y)f)IGAF~?g8vYmZ>vR?yKK?79id0w;l
zNQNcjpTkBNcV~i>@IfuK7cl0o+%#sk`q@=nAat@m$LmI=DkMc7Ope2Bs_XisDbVa`
z7-*J!M)cFXGYSqSt|ViR3M~GiMsF0!>xM~S84HBOv<2*=hCG%~fi2kT2)3vte(y9b
zv<w)3z(6`7e|K1rzcKKrkq!uT?nzpv2kc8dTRFI)R9IF0pf%o@i3=oyT4*Np&!}ZZ
z;m!VEN||Qhjm!mHX-W!$I!nGOiD-8CEbBuk<RJUnvc`e~!TH{4%E}kfE$>?pc*Pi<
z&5^nv>LRg#WJh^~{c-rB9*R-vos4uh6VUY35+R~Wi05UfSNt|e+x%y^2O7mc-snyE
z?r;<(VZ(q8ZWQ91L-7@%m@!F=`6()p9^M8S23|4?4^fJNm!u49P9nqRqZ}M4M2>!m
zdTA!5lFsouZP8nOVObKIJT~x8ype-Ow%1(#GZh{KF;Tn?{1bl$c|eh(ptfL^AIwnV
z`v3q7eiHxq$Lx7O49q{U=dl0OH9<B>ZUm<m$uC1jsFLHPxp7)QrH=jG?myGK73jg0
z^rEhyo(Q`vx`;8+Z48AE8*(uHUNzjQg-*vK`$wfW&wOH85Alpq$6SwRW2`p^&6Wox
zV+V3e364cuqv1%>H(ey1!)9CPq*3Y(iXvq_JFAOM(L$?0qbvtUg=IRs%6tw%84I(*
zo&Gau6pc~zWK0#ssdz8hC0WW<pJaXwN(H}n_`Q+x?_o6W$_{?-^q&#@{tW-A!FyeB
zG<$<3yZ0EQ@}PeIHhf;9e*Ci@N@9oAAB@u|0!X7Aq{lmewG~oX=!{>Dck~bAnoMI<
zPP`KtLcSowc`IllIXl1v8sKyMnBTxNh(8Lb6gJbk2u??yu`nBKp4N@cv!{wNZKSc#
z!*)0om3GVRoFaq}K6WDBo?UofU@zP8699{8<(~qb5Qt(v36z$@5XHM9%&i-p-vjgN
zh05f_Mj~8d4Nx%V>;M-m?#a%U6+RfqqyXHgUJPK!>y11VX*}Bpal1J_rT8PzU&HcO
zzWkNoRi%z6_4(&roa}|s1DWhz=C^<q@|NYPcuBwKzu|ej8=jYd=f~)&Kif&G^rQ5Q
z>xSnhn;wpjnSy%CDl*v<KIl)6O!k3Euc1I#q||)$UTOUsS3*OOKy{}ej~|m`&*@3B
zP!9eY|6y{*7P2R<UGr%o@C@)J9hB{Rd%zsIV4(R=SPXQ03x2|+1{wsCS(>=GsxCT;
zZS~PQ#^}C&);~FV1>V=4hBy7Aub&N6qU9@MBZXa;@@{mXvsXrDcN%9ECopd2Eu03;
zn7oeeqfxo&yXa*C;n&Y<k2UG<X%9E)Ul+X-SdKy!u{1J}cr!YUb<o`rb$C&}A~srZ
zmv{;cSL*KMcxHFeb@XTSkD_x>G!?ghQq&~Ao)$i76RIyAqJ?Ua1P1bgW*V&2WPL|&
zGtf_t6t03B21?wR@6UhWJH509Q?%kXf3UduzAs{G4f2%4{`x|Q5W>y83+VCdS|ER&
zLHVmbh+i~kR{b&nCQYB^-CV>0!}ez<^&<i&B~Jn@Z558eJLrDQ6Ls#x{Ga_Hhbf{L
zNhc*mzt61gDOy#u2ij5i-zcE6kD*0Gmn?Mlq(<3znEj`xVTbmISr}e(ia(WyI?Lcw
z`J}4hZA`436w$^mX~!>;#v1u_qqgC#`m!Nfcrza09A=5E!sX0+(au|mhv+k?&{8Zd
z96}0aqQ%p^W3(j?<AudY7D7Qvq;$E_Q-|$6`&9NhE%X!twA@X)OR%oDny+LzDdTLT
zXQV9OL0HFGP6et{W}H!Tv=i|6U4ggki0ctN!~8q~@IGp=ISmz+>F!urA0cC#hNU#<
z2$u+-d3p;N`KsYBl+g2sEhA0h_9Mj_PH#Xu8dMCYcTMQ0G`vaZ`AF?<FYWd)(qTF>
z5zlE+L2GCKYN!a)0$&K}CueXRkM$O`I=S9O!ok@u`#F{Bk_)uZACZ7MS7?x?2%hv0
z0Z(;_qBr|}qW$%cBDWpNZPmYQI+9lW?!t=5m8yQ0w)V8pwm{!RKh}>31>XD_)kpIJ
zU*Zp(@wb5?urWqfs7b<uwDh4hUD4l0p~No9m4nmbNG7A83I=qwv;Tvj0KA<Y$;?kY
z6e&x`2!4SUo(O4TWJF03`2x|^&p<p2D*Lg9f<{qCL1UsW(I?3}AHeyK`8(%UpTysp
zFiDRI;{`W#vI7d?VKWKpgnz;qM-GkFnT<bF&^8%;(dqzmnu87qzq%D>0iB;>-m)fL
zC|er@K}Sf0o8&kc%iuhdj-h$99J5Fu;Iu4R7i{&m{Q_T13%!l<#8++MD}gaJZgYhX
z1l;j2QOdX_D||o;eP$up4#61Z!i!lCorEm+aN5$Gg?U^fNX^qij}s%@^!1B4uyVTi
zDpHJF@_{oe&M>3xuN${0#QiC&0Z!0ql)KRJ@uZraH7xGmDRW%NAp?b&qZ3e!QkHTD
z=zYkkiquu0FjxE<Hl);RHk_qO?~JAWC~Xz;p%AHDj{F7=Ahxll5hCm^z;>@iV*wz%
z83htA3H?Q-q6O<9loN?+r_;ZoRG^kR3V(}4a<&F}uYONRXQLMS9a{7U<nO&+l7Hk(
zxaXiosTQ4ymft)u4uPvOFYTiYalp*4kaFRSwi2Xpawy{}<(#?;f$k}0d(HbFw%7mm
z0(x-&1ki&@OT|yDDD)#02{=$9G5?@W(=Tee=T8<PLPpP=q~YF#6GAF7L4_F9;&(&H
zUGsG?A<C{fiF~WAvTe{jA>?=o%8CZFTae9Swf1#@j(>|LvGdxI7eCuBL58~NhL_OK
z16rVCrmIVFdLk2qas0Ei4N7qxsE9w(4L?bazlDVE_EpYbveCl}P32iMtQB%vR)vt!
zd~bf5wnT?mjXRyuKF?zKVHbXjO-`qwS$nv#s96jB6Ym60M+}wyYNRvjA+T^sTH*HG
zQ?QNssz2Qr?>0ud3O4JRUIYq+R->@;y3nHA=&rSxS$|d)bLAx<U_-VwoFx4hQFnt-
zt!~8&HiPaiJQoN&iM439Xg&!M{uc@H{Wn4iwwZBw8hT4S01FIzKgXNTX>wJ;f%ut7
ziH;;bM)P#y8$q@*w51!7AUM>*|G^_z6!GltET&KxmUZ+a#!19@hJ{fJ-v&_#toIdK
z7&rYiMv#1oMAr=EF-B&ZhhV4~<8rZnO#f9#UDA{31+){;2z<i|K7<0$cBwS+pjEu#
zCyL94YCR$`1e)X5h(e+!QH9+RQ6<_~f<FduNc6m)1O;KYNw{Os(ZEb<(P<Qoa6}<&
ze`fS7zSA;N_*(dg-5(-zJx03h`l`9^HZia`?a9E|D8w$k7i?LLU}jtmhl5%af7Ql8
z!fyqr)jeMUwCHP*xxOyk(|-haSmK8ABMv?mb1D0un7<f)O!uaFz1sR7p~k?d_#%K=
z{y}M}bgN4*(?TndTzY=sir}$yE%XXrIEcQ0U-WD9_rR)mMCLlQ^*%?a(LbtmTA*25
zI}vLnw`!r~fT}*~w>-w9i0Hf~$_F--4hl4a>*e6goRo?q@Fw(oL*~@$Te|EU>h`PQ
zoq-2Yrj}*S6J-()SoD&%@EoWu@*~Vo7y0oUk;Hfik{@RB{;NoCe5{1zWW(Hwq{t{o
zya;K@{tS2qPt7$}<^WlMQ(|+4mDUq!_V_$$V)QBCAHR;G4(@jwXEVS`0YgE~jdK;l
zwx^x&@_^olIFfl2P{CR3&tZ6`c=oqp`YZ;Sme&bloDytSBQ>4Jj~_p@_1sNAtHwY7
z=Xz69-2Gg2HI_!onj%-GX=PiL#^8?hn$KA#__?E66h0-8+j>7!l!O=^hT{=cucsvT
zT?t8`+RyO|=iz#7Z3ZDrbNnBcVovo3bobKB(Qy1NLsXT&BM~A3C#6%h&{h1+)xskv
z7^tX)dOuMw0?K$UGP>IDWX#W&H9ycG_(Zr^jXY%W`F71d!Dw9H3Puk#OHQ{&#(>i%
zWm~W<eTZPxbX1Gdrv&=8RtrWgeW)JBx8YcL0-a#lgJxMz8qIxI^i#C;8GK&#vHwh4
ze_F*{W24CIvFhW%7o{F8v=U5HMy*IjGd+JYE}j;7{v|)fMf_q2!ycmRAtLsidqhE)
zyYO-Jbvt(@b5HQvCIJ#W(7>4g8Ut;`dNV}McO(n0@;DB!1s)`9WE-Tj%n3jokCDHL
z`NV@~(F6X0=lDIc@H@<GW#$Qm-^SpD0+*49KXohoFbkK;!XL7*ev-lwS$GHYf77k-
z1Qza;WbI+*SgWwwjkgL}*kpcQx58O0+$;+>BNK6V(`A)Maba9DW!XWb+8hn|Au#qf
z8~<d23ev0UtoRqaC`1t#Rw0bxjeZ53!m1nBIT^vwLiYnr^jjv|Q3(GX!NckPnbIPk
z82&l*8`0}k)JLOlK8E`642@LG0eB8<!W+$o`4-63xxyvd<8tJ|3dm(1=@ntjGM5XW
z#CEGP4^*aGtZDHHm0c(+LtTpb*HPU}zZe33Vm|iJ9VeNOVfOkFB3@YQz1ZkO(-!%a
zhpsYvhYvMFTap8t@)xKu(w9T&Il$$kcB8*2G{u+LEaOX7JP;`AD;u%gj1Dp8+a7eS
zT4=AW`nZzKtmzjaDgfuaMY!h!&&T>vw&fnkkpk<phVr_Q>^M|gXV15}Xp?QEA!6V&
zvV-BB{_7C}3U}&h3(K{&>H50`2Wzo2B5}3>=ii!5Jy$La;#pkA+2|@h?jKM+-#cJP
zV3)SGTqzpq2)vJZR&Ya}n5v)+vPHFqVz$wbz`M!CjuYm;n9sh;F*i?7Gp2ccm||xe
z=|*M^L(ZGgL>MWuLD{+opM&hubyJ_H>N}thFhGj=bKqMygE>qReugR5uhx|^ag;j=
zs+(pSfPuO)tVCR4wmw!V{|Bgnb)qXaN(4s?L`-1wuZpIlsgjP1-yQA2cY+8na&Qvw
zy5+3MH2+K%1#)1`6j;fzUXc_CfaU@S{Qd)N*oyF@F@y~at|uGiu%Z@K3onEWJjwCa
znBa`5RDLBGSA(V_@CCY{CsxiB#kdf2-zE1z7Kk2wkG7nKvR*il9&Fp_)E+7G4%XII
zdIuMG1e~F5TKG4Bj8bxm>+JD4cr49-uW(?RiI6mRSG@%pJ(=h&DbgZb;{v5dS-x5V
zdl2Z2<{ykL2&W-E7;{9HLco^?k2xZR5fT@81~JD9U1dbViN{K@`yzWc0xYN{u}t<~
zAg`cBWeEV-Yl)nIayiw5@@5g#8VIJbTzE5{@)r6?C5cgM3Gvz4m^)pL`s;|#!jlY$
zJ72{Ld!;PT(&26QH3BYM(4T@R;4^=F1}ZyI40oxv7#8%kL=f+V>gbQj1xQ<-<_qV6
z6t2D`Cw^||j^(8ONm|_uFl+u|L_Y=l8ALose?Pc?T5y;T`rrWd9-~hg`#zS&ld>uG
zp1G}{5yL;qhBpg$3d@nbn(M~^62Y_bre4j#VHE;HrMK|R#zR|vrr5Ec^LL6^4cNl6
z77_)6klXclVGfTL+Gwu%T$q0#SIkY|7O5+#p5|2w)-NFJ5^w>6oSgbklEC@D@F}J-
zP=tq6AM=rSFIImDUv9k{QTcwQ^*$AoPv&1^!|%b;mzu_%P+Ish7^-?7Ue@yudSbRQ
zQ4O{-uA>4uwA*Q3I2Ucv1761`;KCERlXFtBTLTD|jDjv=5|yQYn<%m4D_OFMzXMC=
zg11D-q|EE}X9SBJ{)!+9!<=y&LMF9Z3o(=$TyWTdlq_gVwmwD;tkYu>3FTrI0SQH6
zlp}O510((K=&2-Lf&XF5!-ApzIUwk%Em{dwM)~1RZ@6+5VqQKKRchgVP<F%T#A-;Z
z(KFn*aGo(5FU6v9>M&mq&Qnj-Li6ziPV%t9>3i^<qaR9~L;U6F7Wt}#z99*H4WZ%T
z7cycBKV=^@9+2vC5Qvy0i8mk0RI%|%ng1sGLXH8{96R?P!U`tDLB87Y98b`aL4q)-
zL>0@R7Vw{0e>S=<T38<|Is+G<)oEx&!&l1EPamUbwa^l>2WFT(O0X@mgH|@VuOADX
zFjs|yA?|QvLoqOE<=hM+_iC9>j}_tVY>aIffUxpu*4==?4&!GLj5YW&Jv|wDnkL2@
zyZ^CfQuEDIGPe0wcrnIY1nvXpBnl|Mi7Cpo`xfwWN%)|@zcI=MoodJOD&JRn;RXj1
z_52}IHv<iuoCIHIX>L8r3IHZn%0$ALwaAEHj1s6XaxKd+cFG3Pk4n8!*&r|^pp*og
zpJ5`62hj>s4x$xqLTRbLzYKoi&}x6hRvGP#WWOpfsjH;|oD1nmb@>{jAJioW%5sQf
zX5w7SzG6sDsD_$VjKJ?#0FvMv2(EgA|8ba4v|GB8g#>e~8|DvXXbnVUFz^<%A;%`}
zEx01_O>ix3d0YI!7Iwx5;E(l=Zm7h2<DFV~H9Pzm5*|F<1Dxl>#QC()1)#y`iL4xE
zvG-nr?hhu$CJMU7KlBYov@>f#LN*?K=8=O4i=q^JXiiB_Epm(l5aK#L0$YV@k469A
z($t=Ys`A*k)H;2*3g9uQSJlDfU)GBbT#7D;wUJ=^A+h1^cA&Ae-rU%UMgA6)DHRxJ
zs}hef*9Bb}K<DkokI@?ts-Z$oI*v|s7ngrOWiWa@5P@mz23+zA9t#d)dQ_%&=wIj?
z6N5#|W4i!$a|oPn5_Aw!FCGfrvxKfK@e>Dh5&lpln~VI4p{^>a@C2d|m=l>|HG*Y-
zhy729=j`?{&M>CKv(c7ZfJR~kmSJ&7(dK{{Ittl|%%px8&?ZFju^Wj~aSDhNhWF8d
zN&?FKJ#7B?cS(JuRRmFbMK>Kb&u<WBwb|c`7A|xuhPmYMw;Dae8vdU823oQh(JXe1
zH!l!eLB!-@%}#VgnmLMmOcp86<Y1m{p7O2e8v^RGui*)IYx)N>q_r9g$T387_3gqo
ziH_6{!0~L<Ml_I`dS#b2`u3nOR^joWG)`|YDL*#Vw=v7V8eDKNd|=@~gtj0g;vdon
z-D4!0X*G$5oJua5zc&U&hU}mSfBhU)UQ4xyh*{;;ta7xV{eDrUe*lxO?MnWwMTrSQ
znWa<<Eo2Luqc6og>>tR`U0!n^h8V1cfKe^H5se!!w@TDPz(U%Vl#9O>L%DD=-Yu3B
z))|0F>>z#*s!nWyo^ymXul@wvk0vig{5E)w*epm^%*U)!-?7v)EY-%RC(vxx{uz{C
z0mx3V9*4eH!Oq6L4|zz%*4+Cs9zpDtZ$RxZh6u+-JkeX>zgPx69Qnl2Kt2ig1&_f-
zCsZ+u_S&s)<XU$4H1K1s(?|W_A$1X43q69GqIV+$KxCcM(i*1CmuX~-Y4e$OUn<;e
zriD`A!gr!TEQ91aP%>$cpnX{mL}Uz*SAu0WEj)$I4OSz0%kfhI`{lBvo7)DVII+A(
zuNLF)UICcrXoK;tKvIsjWE~7RP*sXKm=;<MLLwE8f&(1!t4qLk9snR#EdGLs9bB*X
zW=6_hvPBWeUKCvm!eb*DyB7?;hu`Qrq^;}4GGcztO}5cyrlDPATKInO1%h*cu`-rU
zCXLKR$*GYR;&faeuNsw_iYO*bT@L4DeUTb$Ow-467|nqZBQM&LIu-{apdge9bdfQ1
zWphO1VR1q!hEt&}ErqnU&Vqr44MFW$5w%)cY8q(nRFn&>!o(mU?vm2Y!I%arQ46Si
zfK`N11?E{61tbQ<#zs<3ineqvirKdOSGgGA`cnm2ZYs*vQ};07gs~%+;?KdVJeZim
zH$OIpfsv#=P@e)VnR*;vlzA=eSMi?v5=m0Is%>|rG&HZ-=RtI(q5)hANv?<q?I&6B
zD6FVdeAJ}GSK~FhDMjr<^N|sKhb@(iq|AwKOMwX&k<MhxK|$DZn0E#^?;NkLdy#We
z<byJ_mJ*>^J#40R2(whFk93Q|qR0qQM6_l6=dh(Txt2yyQ@U$}|MVYdLzr96QKHg(
z<Uf|bf;!2Y`3Xk%q-2*qOEWFRDEvIL2TW8~ZY^@-+;oio9$iG<=`Tsmy$6;q`ui0A
zL+7G~=%a+=#8|@hVcH6&b!m7IX|W926#k132dcX0hlJ_s8Jwv__oU+A0_f=8RJb>p
z_IWBCw<|;sq{3}t+QC$~olHBD3KwHq8XGFP_b4-(f%h(+!dal7n*-qWRO&l))r(OU
zqTT$35PD90AsB)bv*IC)VphDC?H*4PdPcJf3`%?qvb)-q#?k7g!@<0zGa`;5bw-ql
z0Yz%vR3-CjyY4j9jU~3__(=t0A2rXn!FHnR=(A+qR%a6IFO0s#G{Um^{NCv5l=sZ&
zE8X9<@Y5LUsAvV-5KpSzZ@Cwo4{~&JLvGgKSBgCH8lNeduC#+t<B@>~-*{xYj0)9o
zMy5D)oYKLLO<jE`xgY4K;(ynlB>so;oXPPo2oX<e{IUH#6+3<|_IG&EE!t(TRL$pR
zNIb&77wb)8^oHg6(fxAgPY|O(GLrZSalzlX24;@V=w}7?Ha?EeI7)=*66`W$BkUn%
z1X0uDH;+9H&$cx=o^jXGd$jbxvf{7YhO8}F1r6YP`-1>QaB-tK@n-oHGk59mz`o~%
zGB5CsF=R3gDO}zVP!u1VKd_Ef{hU={qPPiEVGf_(3QL`E6dzl#PdCGz3(pYbJP!^)
z&YW-Iif>#=JfJua#eiBhCm`84dj?WP78bZB8hvK5vdvn!0r-vnv-t*t&Yo}dpM$sJ
zqxZRC23`8G_|G61AzxyvpN35R7^OkoX0;pdaw>5g$Q6^iq^rs%vbL{%1O2BAo}4AN
zX1{2U2TW_Lg*2c>^`x52q>&k5x4bY9Yk0*%@Pa@Ph=Hg&bhjiJ%dr`)`a%|XUKQ&L
zT%V+AAaNhFpsoj0{0gG6_qzuVcfQWH)ykSN<cO(ovI@bn+Ks7!EPe`#C$XOb>=tes
z4RZJVjif*<1P3O@mjE|Oy?}y4o6b*Q|J-4RKmb?AedacM?I)9{_GJW{2N5BSeI@ol
zLlV!yMi6m55EpENLJY$jGV{!(*dfp77V{D8fX4ulr*A|geQA=szFp+q2rThC&|=9<
zS6AjJW^M*!ILh<{_<$;jsN%n6pR*grM{>>rEV`qxQ-2+bezWF$@YZcU(zV}|>B)mZ
zVh-OT{og!TF&`#IWe9g_OU{MzBaRx&puUPS8B|sIL^YL9R8jtu#{n@hj-Ce&lFQ{<
zC<}O^7cxy4MlP9$RHh9{P2(BCXntziE~Z_Sk{0ejWeDv`x{$9loC^T#=_nWNvK1Cm
zZxx+`A&xZwfP9Rzxy8<WW|mW-V+M!peJE5GjC>aLpsw6UeaHqd&)!k#Mel-OhocAt
z&v}olU4l8OngF7i72$=qhG5A9FbI47OvX1VF`vwQ!m^JHRbi8z*$Q(HpDg>ncB`P=
z@gS-q6|7xHmFL{)gr}9KcL>Gj`bhMW?lK5?1pjP}B>#x;K~ds|@Q40JaSFUoz_ZN=
zzuuBpfF3>TG|%>n^_G?7*{lPVdTac3U`qDKXesfb(ZouD|Dx(5IPpsW0kXyZS9BT?
zGe}2a)DOh0#4MAzZUrRWYw-3&9?rB<XX3M=^(;;b?BW{`G2(*NPmEW4C!J)xviA>;
z)z&J;kWa8+1%c-vyvAnpum<dSxH5h{*q7~to$qLsh&m9>=tXOAhR){9*4B$ANC%mC
z^}-BzkVU6H8@NNzs55~C`y&`{^ypjYXtV+%&v969A~GN#)c2^fv_uPii(l+k)!)f|
z8zf~V&Jy)wik%LRL0hl>(s2yiDEgF^_<QNl$`4^k_URpiL3Qx3y0FCPuV6xpeu?nD
z79QW-w4;788J`b9(@n7KQWInyzYu`HG>|aZ<;1GiW}gyla@0P4A7o$LbjN?_v9wlK
z<4w`l_O3os;-3=2LC<#3YxGH0ig9TV6~P_`>`JGlRyvlIzRFhKFxJ{K2mCx(kQW~c
zTB?WDprZ5qmq0Q2WL|ZF*dlo&@a3>?7`_~^Z_c_9mTMx~<qRYW!N>0hR+J*4=1aN#
zl<Hyk<8fYOIaB<@(Su9T#!mXo0An7ARn04b2{YMJe^ou1fiMaw#kgA%*}&4WdszrL
z(*%N`ji470B;K;kvXk(rNA+2ZgV;$l$;A04AIJ#S97I0{nPLw>vj5ooZ}JRi2m)%C
z+Y6)~mV<wl?Zpu%p!esSzOf(#9N8O(mZL`Go2E73Y{`LYT8py2MAXc`8Y^G#rP_OG
z&$*v2AJe`<?%;VBY7744e&brP+gHb?xgAKxzTx#u4@`)!gcQ(!g+`S6@2Eb44ME(s
zU47(yc?h`r$RI7WTcq@Y9cSqyIO=nbc<7^rM&O~Ut`^%^uwTsq%>MEEhmmUz<!&sF
z-?z$fkTODi(cW;Zg-THX)kQLMs*jWgmIOPw^QSZL7D~6Ko!>gbF{gDzn!j~KdI@&M
zaEJ41(ASD%ch(MP*`GSo1BL{@8DOm=j-y0pN&Ft@9_=TwI<a;b<^~}NH#69r(K_P$
zTL3#(!1Cyi?GF)@8-yh2?ZM_Ats}k*0Q|Nj>T{5tY+u4Vlkn$B)bjvaEKq+1r6b6v
z_?0NTfeaTQ|3DTPv(JBYrfZ8{I~jDDfUZXtoPxvnp;EpA6%m?hO&8vR*)=OJkU_FP
zATzP|<oZzw{g~q|3?9XJUk&pfJer0P+&?3_35B|i;bS;n|AT2=V|XFcwxy<dnD$|6
z8qOpt(Ke>xL9R5<DA*ZQ(BbssxqA}lgKa^)h&w~^Bf&;?Lg?zn=hM~J!qhhjg2Wt=
z=>I#EIy?c&14Xb*PM7@9tBT+=k71XB(xW)`gNTDaIJWv;(wb3r--0sBSA2jQ|GG9B
zbVDn<Yp~g4J`5PdD_i`vKfn^H@aUP?9{~tyLFv_B53P`-Tf3)^i28hF?{q-MhXJ4t
zjZhRm;2%SR$h=K+p`^K03vESHr_@NZVA1^^w*A53wDwQ_1(2e~f}NnKf#}R#fB@CN
zqZ1G6zQNm12Kpgzu@yzYRU$QBWg`GJF3}Vg={vfroC<`-#lo`Uj);4Hti;D%%;us*
zyaIs4$_6pGDn_><(@Vz8HYhFgs3nPgV%tjckL3?gJnk1@4grti9x}4^+LQPL|7Y{h
z9-~t&tw0S+yM$dEu6@;c_WTo-sd6Yzp0Xzk@S;g=%sy<-F$8a7-Ik~9;oDfJ?DYzd
z*yv*QZ#f?Dfc;m!MS%LxJYfH9v3Q0~<GzOeUC-CZXCgOm==OXt6Va&CV#&kwv5eaG
znS?@ohzA|y(`wjy{zHG5Y>ZT689e06Ixr!dgs4B9)+_17Fi1%!S#MpbZp93h<&X_Q
zQ0yKQ5Y6O(P>|fJa`%qdwF&zwkpjd@i)FC%>1ZkmW5w4IQm;&du20sMd;khW7~S%h
z|ER3%jpETPl!>Tfy;uJT6=rvfh<6li(n1dq>O4So#aZr(p3iqX{N)csf1Z+mQ}h>n
z?}L&eE^~YI@|66U(Gh&N!*kg5i-{J-AG9mw1hWFKy;57s(=d^d@Nwjf)P@2GG<FwW
zvx6--mz1HdY}_(aNxa?79@z-xak$mdYf=bU8Xd>?uDIWWz!;sH0y95)eRmlDebLz|
z`L{)X+dUsk0>lwWfteGX*Bu5sfbQ>}ANaM!Qq7nw#e)!A25l3^Pn%U=CIu2dfNq>j
zax*D7Cd(232+8ua!uBoz;_{))IwVEItd6}zw1YePNJ{myBjX*#IEJ`zG`zYzYTaqb
zw>mpq@C;Q)ho6DjE#~ThL7*TH%G(phzCs^CgMda$!+}cRS42DkNtHm;HA6x1y^P&0
zXT6+xSahsNq2n}(3hnO^>~h0qbR|K0b`^R4M~Y;NB0T>WeTg7;;5J}mt(lS4c?h;}
z6+vD}!I~d^y*pOFC;ArO#kk3UVlQ$2@qC)6ws-*LZ3fA)u%%#70fY8@9_zp*SXzT0
z=vz<#p)Jfq)OBnmGt2@;UQP7^Wr!a~{rY{^t!c!j_A9~0Tddu<6Ng>3@M0FYD%%(-
z=F2Ru=Xt}M**N~0=KgYoJX*sC#VJ((Xk$FK4r<|#SY{+QApE+XJ%aP`Q-K#vB03fe
zW3~-<5aS)|GMANziKv<V8J3~3HCpbvtEw|gUduoQi9cFyjJb0IBshotQCx!}#yctu
z3A0AUd3R&te!WYNVH==N)NjRfgu;>r0t=@@Y<I~tM_uC-K7JIW=%rqBR0J5NW+6=1
z$k(2WKwL|F8pV&%!TcTfV(3_7&SDBAe|{sV2H?Vfr7Q7tCfe~Vy|qi#zkarXylQ1;
zd<FW1=wDP)>J6zW*lA1SQAk7dHO`0YX_Q$@M>hPr48HLnyr1~3cO);;u*R2e=ezx0
zuL$RGwOvewPzRSGDf4zTN-TqaSvhXR!4v<*GE6*)p)F&7GOZ)|^iA^VFrPTgWqfC)
ztyDmn*_#vpnBJCq7+QB<p;ecu(!=6~5%4Iu`Nd8j3tdLMtUqLy+zCsW2+fB~IRD9k
z17SM^KM@~j8hsLfK*H0{;3Qx84M(o{za6jcak<dl<jiaX^#qjNYH7qJ18jdmdkr;J
z{Y>eo8m3hH3-H(HFTr1rzZ`$_{iouu`}KdIe8X1iLV0sb!@GE}&+j(G#7lBM(6IT0
z_jgj?Cys9zf_BqhLl6LWR-grj;2+K-Wq7UUs+Bo-TF-`lqZ*)k$NPuFTl_s+YY2UZ
z-e$j^i`Tmwd;qai1|el$uqi!wq*q{51HpM#V@>z?BJEAhevVqklin5hp;$)GbF+is
zAm90DN2a`cmY9;{0YHRZzrBYLI1me}B9oob_raC4c6(s$c1J(tyO?qC{auU-(}0Gp
zXik|gipurgO0OUGruI)jgXWzFl(o+iWtrC>@p}s+^W`>*iL!cU0%(Cm9GetpsL-27
zAP?~K*u#eY7+fjhtjGfmwyiNA#`+^R^`pISV9`6#quB~KtYZsS)$D@`)EtElT*4pU
zI<}+#LOy%eu?_v_@Hu}S8y{MMXZJd)#p^;X%H9@xd*)*?hn)r;0v+ZkvdzKL_|L`r
z87~TMRPzj^y)MES033i+Wai-~w^>9b4l{lr`~5GFD&h%P_s?^H9qYUvBH=fPM$^K#
zfRQf$1-9OtjK+d=^J+G*on=hkwr?pjoHh_>O++hECx&OXj(!6$vUMOjKNSG2q)$N_
z-skZ>el=bi(3Lt9PfGg*chQsXzxckYH>eokri^swlMg6UE!aicRY-&BVEkK{jwW*;
zXyYa)Z*&;)#F%YNcIr@}z#B|Pg(B#P!a}#GPRHcBn#dDIr<<kt7<sngv3`LD>to$l
z$gDN8JGWwu>@J1p#f3}^M8QxG`wE98R@Ht6PNb|&$7z%S$?*ZsrVj17*v_)flPB}X
zb1N;bobvMuB3jK#N}?~otrnfk_v5F-GvX}(bt&^7FNol(c`k^EjPX#V%&9E;mELAP
z4S7Q#9{QfbSC6j-7VhO{l{^7(Zem1T^^rdQe$_{&1ttQ|OxE=<>%x}#gu{QHwze;V
zK>iEwZmWigxCkKE1BBbH<`6332<(>AfFwTvnMy2Uk)LR&s^d<eB0j$;$8*bnk;A$w
zw$erBcxTum{3Af2R%K|0F=ji|#s(BzSaP1nx_O*@;kAI93?@~&2bA+oviuA<LzDH5
z1&wt&_RnJu6l~5c-W2%C0(U7heIgPkidjo|+xm;DD++c(r<bfELhJy+oTf4{rdxkG
z+Axd!l~KP{5rIY%n-fr&uEP*$iQcStn9F27$u^6S$-OuJ>x}uk6~n)q?L3@0=dc)T
z&%rI+D|O$~l3S=?26D+4Y#qA?tCS*gnTt^-5whc1pbuW2cQUAMT=-k;w<-H05A_>k
zRKsn|a~X5pR$WjIv5CceK2z|?z;{;ear0i;**qj?DYBqDhs}><qM-hFNCfqh1JA(Q
zz+FHv7^9J7yKpC*kLaeKGE7YU<OpW#=Nqz)HuDbFk)oe&WSz7;@20iO-^=oC`d8*J
zP~Mi8RC1vnUa9Mq0OS1T#Qr*xs4BSLr<(ah1$#5^AEMFP%#UGePL2|{)1?8rs*d;|
zIob2jK>vf5q4^fYtT@r!(<EMxjd#&c;e8&^UHUbC-R;2Ga2wIS6Wq_6nu@3hcOU_J
zS=OYL??8Rr|6K|T!M)<#9^=EW3%|V1&0ake&d?{PvZ->C`vrase@!ZW;w1jeAH(~g
zjrU~jucIffoQbnNE#jCu-1MASx)1IJrTzAb48_`k*vj`y`(pReaR(0o1lw_WPwIJ5
z8Bd|W{o<AtH3C9m_P9kYh0$aE5K%nnA0Zk7gR0nQ@i>6lZ$QsZ=I``hF7s(Of%GXW
zA8IJo=2bum2xzSbs$$!v46uvYLUZ!|!5?beJ{0Bo2vRKL^Nhb9!vS~hi{bL=v#70G
znDr4PN1sbgt6|!UscE+`?Qf}Rzhc_|GEGce#nNjz(#$8Tc(>Ua$a=;NuyGj;cv?Yg
zm+>H;JU8(vgeTuDK25_@yGW~Mu7I13r)rV53Qu)agsa2T7E$6E=8C5m@$|R#2lfOv
zIt7<eiYt*;aIgT*z^jVMy;kr9$`50>DBcrDnDsYt`+K&2Sgy`UH`7com5b5;U(&3F
zM`3hqSO)=`SAtGG7N3rUg3dT2K|%p=6%;qTTTW^Ji!dBW7fYM~d_;r4YlWZB#B<V%
z_=)+8qvRy>7wQX7<Y5)i7`BVcn+P_+I%WDNi20)xq`MTtHJ76zxZSP(OEJ7<Mtq&c
zP1>TrBS-)C4UpY==tIZ5iJsiLlJH-E707d-_nrTQZ*f-e*#5x3(GG#tw%NAF5Beu<
zhuZY!h<c8gv1jQY>U%(h+uCoP{cYJ=^f)A7I26-M_NGVP=YZuu7dV5*U4iZBomqI+
z!ec>)*m!HrSM}Zc*UU83-9F$EIAG3zFPnI7c>tZC<uXw&{%iax*jBJp+%hQZhjeh;
zPNtrTc<`;5mhbfYjj8#FNbC%plDG)t-2fyFHpYwF>kRDj6k9b^GZTnqgkm>hnuL-^
zBtEo`Nce}K|2rF@0N|DPg_!%o>B-{}&Squ+74po@$Vi$cyMJTt4Q%D(?97PWivF%1
z+YM9pYivl`&9iZM@!w=t$o)yn8nv~JhuY9)rPxk_yQ7=g3$`BGUa)DZV+-%tHG1gW
zw4fSdA^k{<vJLzLsZ0}>On%#n{YBHfML@6<2xMu;mc;XB;w1!VnniF9F5MHmdxC)N
zn?H{4Zu^~cwc^)TJMIn(-#dOUq$})G&HiaH6~>!h-gt`DtI!2}UE}2*e(tXl_A2C^
zhgY273m)#HEy^H7NI>w0Wi9j#)XtbJ)*s`13<+e0Z!8oPLx&c6AF142zvOLZKPigh
zp6M3_Tw=7Xf4Gk_7FyE=82%&XKjYUJU5Hc>lC)AY;So{Ua3ALyL7BWC6xT(D);!6g
z_-D*3G_K{vw9gxp;NSXJqKRF9M@zD)zqFeg{>!3&J5ZHA+U>8lii17jZyh5P^zy@v
zYy&OyB|OB~XmPM4F3zLYY@qCf1v5r_2vPyDcCV=9C3Kf`xJg2JvaPDJA!PzeUhV3J
z1D4fQS=D8O%h+fynGs8X^yhHCfI2!YDSn|9Qr;{(#c(ix2Ijc4B5!&rj2IDM>{5#l
z2lfNQ3~?N+(83Vz!~|z{p;1l>#~9`GA;xN<K_Jh-kxZyrp?(;XEyv-lhec}^X-lrh
z)JbGwX$OZdmiX`<DGalk+!)LUym82&g75l&F#1*=q75m-lMmgbkY2QrJ(R1}`>9C)
zh3IPA@vOHF_G7sSeMxU^`izHa3k~%m3YPKKNJUn#(QRb&7>XCg#zd}i2U|$7%NSiG
ztuy1pW069m;x(tj*Fx#=MW8VFrcf0qp`hQ=UmuRlYN4^@XkH=Je-0kS4cD+vIiMsj
zF()~nL9fj*3Qs|f3$z%w6@i?{HSS<*7EKxW^3qITvCG_t$s{X&0c69fmON>x=}t0i
zRjn>()ti|jtB&)r^2r&--N4PA0to79p+!u^gxpZmh;bfU20K{{R~jzuT!~7#y_|cx
z3T+M{G9z=ao_Ue34n}$@EMY|bg^_uo;nZ;<j#GE#ESzLhQGp9G{Z|0vEST`&V&@zh
z(3?0DZm12T*3rBhWy@yZ_sobZAIts@vt*fI$|y3<)Qj~joL@pYh^Wjl7VFJ8>;$Cw
zj`tkzrbACOojbG<h^TPjPbHhDq6AYFEga{N`~BAWfC)c~XHYzY+6DU{1r>Z#bZQ4q
zu|QL`&~fM$(r6}dT!%k+qj|vF|Kbf}z_|qnuvha`Lwx~T>~-{u=4cP4`1`;YP!bsg
zf%!<<j*Fos#<Vpv5=(4pT4689d+AD$9WR5>ArGNfU7hU!ng)HMSucBXh8CU-K)XD+
zD>O3m4K>H`d5TAPw5MqHiLR39zU>BD(3#k3Oen;dCJBp`7lH>RehJ%oLUy-wv288x
z7U{h1#)cQmk#XL%+THThrdXb*_emoM@wIRPR@zg@Oc=V~Tb5^kqZr749vfXGXjm@S
zYE^}}M!PA<%}Edr3|N1$K%NpHg#>w4f?NVD0^~Y?pfrhdvLa4W((%UmHsgaxaGK{v
z97_Bt0m*}vt`~n4^3a2ToB}Bj#Z{tO;XV9ZR_lVv6xD9z0zC#4Ae;Q7$et&%$55^C
zuPlF!i1*4O$@S-cH=fjA(?6t7qW=SXmf-<@gF+~rL&oqc0-*TyevWig+l+}Nyhe)X
zB0M8QWdXjQ$2=SzWtxx*Cqs}+j+y%>`=Yu|WYjmp&xRU>p2iFET@hdhQnwvtN45~>
zpp{^Lm}eVaTd>V$6wCb0Mj)s-Va9ZOkP4#JE+!Dm!Rg?<vI4_);QT}{As_Vq0mfA>
z*d382M;4>M0N)n41;)?nT-MU5bu>C~0b1GAur(>%xRM-bVISL170jBSrQ7jzz0_+S
zo|UfXpPT(~PBO8H1jH1IB=I!uk$6q#>+fxcdlgFC{zJET0ZeDg{jDA;P}QuxK(tLV
zx_^*O0C%kd$73LVr_Z|8)lM%$Iv6v3s0a1i`vc_iBW|Yj$sps8?F|5}*c%`^n$Lq5
z#QqV8u>4^w{)O;W8D@s>0qPAh_m<%B95LSeu+YiUSeh<FyJgE@6owS6Q0wvNvwsyG
zit(E<M&<JFxX_uryA=!R{sqzJ2=b9wc1Lvmmgo^O{E;5V%Tv+sx?XOGcH*ULx%9ed
zPf=1pPKch8f~Gv$KbaXAL*hVzj|5t)>DtoCG*s~H?Ma4gKU`8ucH()+r9T7y<YMyx
zBt)}-v}^TsRdiso5-qe8#iD~!0Pc(Cb^};QfII>uw+P%Cy*LTrzc*SWUTjhPHafB^
z^VaC7l#<s+>-gRSI4RS>97(IR!MDNITI=PYUo7dxr_!bie#F9K{3^VQb<#L5c$PWR
zWES9^5?lBiq>jNccWkruPd6$dzY(7JxyX$^%DQ`6b^8ZL|JX(7InfneFa4q`lP_Ah
zjiV<}+ExUvB5cdQyTzN-3V>Td`(J-4x**&g#k^4wVW$a`L_}iZc%fIp{bP-3-ud=6
z4TME7Acp|XllcrX*mnefRrEHlOQW6%(aP)6I^n%We(NZC(Ob<TToJ%87Ox`Lp+DQ0
zcwL0wsfsIUFGaex_8JHGrw+w4*hpGZ>Wuz2Tq`fOJ1tC0oG$Fqr4tl?A^Jk_m?pQh
zRv#T=<o(g}@;D{%FPcQ7T&?8}Q;1<zr&vkCjUt{vtmgYhz-Xaj^t77qtJm;(m3a2O
z!sm2UU-P{po~MiS#{XsdI0+-*=aLN^HirdvAj&Zv+rs^WXneuzY|!o^w|J+kGm8|w
zhkFh5SR~+%lzYHQj{YqiH!mO<TR>r4I+SsDpW-#%Y82F#>;(ScVW+l;`)6<qgZVdW
z_aEFsF;INe)t0}<2{sr+(Uy-L$JcT|#zes5R~><08rEMg$INws(j)kh65Qx4nFBd2
z3UgWBORvR0l*`AVCx9Y&j9N6yKa*JAf#iv04zXe1EPl*S2a6>lZ*j;X6^HP<wW!x9
ztQ8H4L*{7Ei4K$(Lm_T)32j9hnU5E;SNJjw9C`^Hf)HjUUPP^Pt&LZxd8S1_`5^sI
zJ%;7>5{?_loPI*){meXv7DuXR1im6Y4sk&-u=BbI1X6Gx8>AC%L}&B*2epFNMpCDW
zI)E1S6znuF1~Sl+hvU0Aqt)%AjBM7@K*H^guo@-U#^%-!koCu|tcYv1!GlKKi|@uK
zP2$`{XA=n+%*Tv=2*-QP&I8E6Ln0O_^IlG>EFZ*;_sf8agZ(gpva5Ee)oAQ8!F5$y
z_<6LQwiYm@!?k72yxxsLMP8kgXXRX0dJS_bwGekyGAG;0xx91&b1?JcbVD>0j7fuV
z48a7cp+m`bID=g9fDmZU88$=ok#AsQhRH4!$0Nc21MQ4I1x?0_^UafJ(Nnp&RR6aU
z&n##{O%eMZ_?xALp0SYhLo+9)C+A=2(zD|Cvj_|UWR({@;6Mx|v;^p7pcWN}QN}WH
z^Y?d!@YN@~(q|!^G;T(cC}+WsWxCakDvk*yPxfT8aSGr;V6sPlw+B5M1jiJT9{&Q9
zJ_?nFu0aG3EYXQ@14OrL8AKO>0ubskLeYO^lad<73Mk;UgyJeGp{OnmbgtumDo!`k
zLV^aJK+tbN5YzLKPL!hWtJKh0=C6Sk<!8M<nwg3ZMhvfh+2Qas!(5QS+$0xFG%yqq
zpM~z!K-WKBh$np`U|_=`YTOxx0{}AYfrdzY7X1V$#fm-~29CuCk#a|3XR=AwbXlr6
zZr?GVJPO%LB_@^7K`ydFmrLOF{lGt(gMd*rKmaOiDj7U&wPX;<3|7_3>@j?WGY5#V
zd^AhgK=7nDvenGp?@Q^NV-+5RU;S(PrXznZb1t-U7$;)-&f8I525*3&)GV0@8TNp!
zE|Bq9kUZwqp7LN=nsJ&i7bDeR3m3*jl}`YHxH<d-_>gaCKp%DCkNGhDb71Vw(@>IQ
zm3w*@DsHu8gwGHGPQ94<h2C(Z-lmoFN*||bJPh=fHSh_0ccl%am3<6%%xTW<4&njn
zT*VRkHco<?qq;+28<!S-ghN}%TL%%s#y^N3E%H6n9uzOgT81=ZnSg*b=Zq~MDcI6k
z3m9fbTo38*8gAi8$Yl=hY;&i2qxc3CLj*y@rp&-L$U|&X=UfGsI^cvB9OHb4pF03k
z1XbHjQ1|SFpjt=+xaH!Qpu?DhsK=9n*f?X4)_flJ!-ZWUVzb~wKticfrP%8{@V8JA
zQ6#lYbT95*MmxJ%ku^oLx|QjA=!7)P6AssjCZP=I4udjrDK3QWwM2?XPXsd={PJWP
zqgA*S0ee?CF_w*qN4bE9if=}rFmOqQn8+<aB#F(kzz;~)A!IA0Y-BFCwmEirV)R_!
z1y_Ya&fQrPG6ZW#s{k7IK2(x#=I#JXtrP?m;T_l<cnC$}q!H#L7Ijjx5Hb(j6p4Ff
z0=<nfPVR)Chu$o^pwkH->kTd#pc3^IyqG(e;(KBr%|I2g#F^L+z&&4({hGyaO<J5a
z$DRSOzu344Qsc6?APnA)`TmXEgy-K$;J-{3&n-l{f|`J|8*A}Fu$SxjSSzx%@M;(;
zzBf!ldsKSIV7)ZVXf0SnSQ_`m^BJGP0-9ud+lmFUOwaZ%Q;MDQsLXEl)4_z~Fj?>|
z(!o-nx5-i|&KDYS-;y7cX|c<!waWb6(n#Tqpv+%?Smpz}%>7oGb|whw>{9bksyk11
zHK5oWYn4jzo={WSPn5~B%Je|{Q3`fFZj^yOJcu?5ZkQtm0}-EQ-5d_^>l9+KEZUZT
zO35%5LOixKH$^bo-3&cre2wh|6U+Rk$r*6KBAU+-hVerp<-kgSDFi@=Tg1$3Fls@c
z<c_UJkYjE^yIb#6BeS|fyqmM(zCZ^~+U~$==73IgTopTGAepl^;qB`<_hBVRvu+N?
z0Ng;6OrM2nEk`09>9!-$^J}+lf8>0BEX>*rUS2s1Y={sUeoINDwj=<p6x%mZx*d@c
z?Ce7<hW}z2ImxHI<Ws)&w30EHSVmzoqbT`QiYH)2uFpy{*DMvI&kSMDR4>ay)T%iL
z(+It#o+YgMv8{9EC!nLAn9n>|^BF(Ou(AUwHLa&OA=Y(3McCi^6!YCF4ka?0%Yxj%
z=EHeB+OY_j6WFi$g8(HnW^)x<VJy}nreVVyZiQjPvH%-akOQYheu*v5JO~FDR8bHJ
zO3lX9c?Na~6)h~NGsOKSdHR=75=;ZlIq=`GJ7q@TGqYwZYAGF!3y&aU+glNNpTHW3
zqxxSqP*2TYqEO-=tXTLV;!7s4z!zsd3ok{l7K0_JMs?JQyKr+Ih8#TQ-HIplt7me1
z(8lDMQ~w20k<c;;37A2UEy|w!TaKoO1<%7bLLed{HUHh=wpWaQV!e24_DSN8-Qtyv
zTu()9s8!T3^O}>u|DVLimS;+r-9DGtLd0NchBfoD<70OE82X0jh90mX^}7_u%d{oi
zz&9=-8}1Z`h&S+!H*dX*yFf7Ri8CRIvtuKKc+hr`cJ{*ixM2zKgb3UL>zpNmAkkLP
z&@J8|4v5SLMnXj2MWz@90THUQQ@1dcM@`^$JTBmNGKKLRjEU!4HOAQF%6+w#e-PYI
zYJCF0TJI+Qz1_<7jg5d~g7DRq;2Ps0^Z(sdzdv83e9jbf4%U5+NcoB>94%1yS+Nmf
zTYS6+B|1VzzmCGVS@@0<R#G0|@f0X+wia1|!stojxP)lyO0nGs?fplE8ucYC6gn%k
zFiQ)+2y9e8jB`u4`Fv$o9lUscz)Von>$R>LT(J={DmBl}&15cPPmpJryE$VcMEo*7
z5znIC;vX;-Dh(inKt%oZs6W|<WYQ8OrS2aFbyQFlJ>LZ-S*XR|CQNewv%clT?~A$2
zhIcu@xZ-p19V;td3KT#7y`xjmqyQLOu+yL_X<>fy$oBtQqXWntVi1D6Cj3fGz-Ntm
zSOp`Q%Z*F5wOaL&VOppf`c%*u+8pQ=r)dst_V-1|KwInTskZ_k@CE)*uQBOEHpVaZ
zbaTVs;7d~5V@8_&!6Wy}Nb`g6)8z+`w53?8g`4~cX!x%mJX+``OEOfbg?R6H5ElpV
zgQ3$~qE~<=z13nW@NSZ!i-DiT_<bf#TidVtC>Yv@+Bm)6fnR*lN5#j5BuAMz;0_3I
z1hDWC66KQI9Q-R5ClJUL*Bz>ZkQ4FaBTne^d8@>F(ami53s?eaSt3mf>v)HW3xPN@
zb2Tu~*Mp)K;hFHv;Cl|<F&1`x2<mQ2CP>VV{|lOiO+=0HWmGxU`vB2xgm`UqaXb?p
zGl*_G-V=WlMJ|Gvuzh5krL1ECVcB3GA(vv+2N)5iMEo-$VrHrbFo_)ogqGB0ft71!
zP*btr56Aib%lDy@@e0cx8rbfMrmqw`qt;8gtk{9$6M40;ojdd|8^qgsRHDZ~65k?u
zZ?SuszXC`^9g5UyIZC_4X$w=tmS_-!!u<>J5=RU)I|&sjTd(FG!`2@$x?)!G22+i)
zq2F1^MVZ?c!yNP%SX;3K+#md5LxpayD;lREF!zO7j2#>1H<xp>R;hJUMN%|9D8^M-
zX0tau{lxgy@AUsR9{uS3K~;TIN2FRdHAW=+{N}T9I9TF*kadj$)FHeL2Q#7nSbULA
zy3dUlykT_15C7mr7_j6Dj#xGfXjra+;&jI3sj!xx`hK!ykHq>7W<xL{U!YDA^%wDh
zNOqVNtpfu})F9cg<;JwI!d>d!!{^p{$Hxh>$Lh)cyP{9xT`ocJV8mU~r&IE)qJL&S
zO*QfPtD-Na<WG$Ljrkmi#IE>>=utifJV%Q$2kl)9Ln_ZZa%+!$`8iIJ5o)B6Ut(vn
zlo+)V?<C*FI!EG-=xZspJ`sJLwNmPW%g|rQd~0_YE%bY)Z6+KCItlkU(>_Rrqxho#
zB%I9!f|^YGI2EpjY5NE#7HlXDchu|-6Sx;w`W0hyg0|#q0ModjTY}LvqjH$4pC-Nz
znq*B3c(KtQKq}(AqlAS}q;8CqId8(WG*HXpQ9O0QuvpB3S&p1&;snyZOd)N7MVj~+
zBQA^=B#{<<k{ai>f@seMux2+jZdwHXXkVsrB$MLfR-b4;rllp*a#2=X#ONV;Xlz;t
zk!=Mv?uFfmenaB8yPJq0x8o_qd2HgMC(3NRGyVpK@2G>7+H%*z*P`<z1?dG^CB6(`
zcJ)l)^q#ikJIvZ-&y8@ys5QQ4!&Vk@>)8Q<V%UJyVy-#lL3=IyUwr-Rt-M@>UltmS
zHUR#7V>Z9rHcf6Qj>!*S#^kMv$d;EgBN_<%VBWr)g#%Z!m{@N$#^8GPc~{DB+32NM
zZ+JmY7)RgCYkIPEQ;fE9wl`AEU*ba(JNd&oUwYzC=ubpeaKNa@4sTodCU$<Hf>)8o
zxu$v@q=cGNwkiJ|7C-TO6tvcZQBA>tsk+Hwong@W)i~bG8OU2~G-5f8Sa^hc6+F5w
zsx1G8bpc$Qc$#R}CvezB;@sFJ&=Ol-cWjU{?VdU5lN08vrLb=mJkMRJEx8iyY@E#t
z0b&_NJMD>O9-jCwmXV))Doj3ktf%l!%x06RImxFoJh2nW&(g#)N|QN0>j`}EYEsTB
ziA*$LHDnhYCdy)RND9bNo%JbIysmWO&zT3!*XHz~Bf=Ww^wr$>AwCY?hnQ+wT`(+M
zLf~F&%t0#Z$w6e!ABjyY_O5gxL0fVo#tMiwD{(U&UQP;=w7BY%M3q3%;RNY1b2zkz
zcY$n1wYa|%I55TzL|IaKi`_Qzd+i>ysM&~#HC(sgMimZ!g}>4QMR8@Ng5r<?ce-Ic
zi3(u$n=kr8tNcEa(Vs%Am(|S6h2G_M;UXvGKJcPBxJXQhu_iCiwj-uC)vD;8lhBk0
zniBl5nWdkif<%4NzmaW4twC@B1hAI)wXij|K1y~^ruthksTb(Pjl&jvJ=KH3xdmJ$
z1eYbHr?89T0-MW`BC_G2z~RmkGBNLM7WoW@=V_q<fPvec1rW0a-<@DD?o}cn%EWoF
z97<CQ;cf-d*4h#-cSbma!r_U60~8b?aQb%@eyZxi2c$-mFD)b{0C1hT1s|<}Ks;{a
z!ZV6-bP{UGXw{<^@eVpIbS>ffh&Dl7^k0CG&BSVmvFY=H@V*D54K9%Tp-v{J=Meo(
z${SH!+~3>6^{1>7^a(BWFV-=PeNFEOZgNB8$~$<a;loI`EP<e{YY%GC&jfYLnvFi}
zH2M$~f8o$>782D$yx#_Ql!#AmoQ`MeTr$M92ufmwxZDg&3+@`o4Exa80GFJcOqo8$
zRoFJ`@m~NG@j4M3^qAhWaLa_4yn65{7u-@4z8@$>SA=wmMFsJfIfl*0MZV}&Y#y%v
zG2qOB&*)DP6f`2p`$(f6v-bnBHEO33cPGBNT7ZpE5n%V5_*ezNu?^`D6rbojqU=(x
zvBhUmf#rE~(Rhf1^DMrE6SO4RC?-u<24!<IKmuX$QxE1VLxhmS-;41P1jcViF5}%@
z!6dPj`@)JI@^ggx#`tf6jF<tg#QA;dZW@{Ajb*T*_|GgKBce-Q_K@Fn_M$T8@OgS&
zZ$9Voxv8+1Vm|nX-irB`y}gw<Z#)I=9G1tg7*Fw=XT5V7SV_Eq6!}zNPxB1f4<oL?
zXY51%sL`LPNYVQ%crb@7@6Fx`v|@L43exx=P-8t?1;(gPJ;w?PDH~!yErJfXlF(ti
zrMM&}Zr8QjPb$;NtmVUiiXT7~_S8fCV*UY?T>euVr8#p^eUat?)#j(W<s2kgraSyw
za(K33*PRH<Lfzo2n^NKR{{pYHq{9E|zrg!8rNZa_7x>1_sqja3oxtk}^f$hp3cvZk
z!28}yg@63Nz$^bqh5yZef%k0{@G0$e@rh-+$=|mp6@RZ2VNc-Kw=Wfb`_7-1kMCcp
z@XwtLeuDmKaKF<GyopZf!)2r9y$|8f1GnK%)7|*<cU*8|j$VX6UrofHmtIhm&GDPz
zy^}cnLwTI|G0wt{{Ers*jtt*Y+UxG#i^t<Di$A~nGz`1zXj%15!tta(Sbenk?gYQ1
z!@Z!jn}nwyQL7{Bh)7)rOwEvf=*Pjsz3+afcFW>PYOq}k?(68)oWD6TGOc!!s`p6z
zujOvPc>#O=|4a3sbN4&?7K8N<tl6i*sx`H%`I~z+gNiClX+Xvck_=ftzVd|?$5Zrw
zE<Q6dk|J;}9w$WL7W?oK{Ieomb*cQfiC`r84~-!A!NX_Vy)7~>O`p(FeNWn@fhN?y
zcw&a5F}M$(7c$B_YA0qG(>oTAag3CrULi$&*K*?heV1H+fVV_jbQcU)u>Ep;(Wj}s
zFB;(Tj!uD7pTMtr8CQ4U=7j2b>6dEZ(STh1D@SA;wrGMIZP6u6xQ-lY5AeoD)TS*u
z7Z1rAPviuavX+<fR7A$5?}WLXus^s#-F>~Y`kwTm{&|Z>Wo$9Q8~D9%rZK^6`n)fw
zFv^j3xsJaJ%#!=A*geX*{fq6JcklhUefRc*8yta)w`Xihj8k^RKW;y`p*)adjB+=%
zr&l$Z>X4b3{QZm{u&f$(S?|018WZ;8@YfmQ3$42)Y4W?o!&SX}|Kf3KWCZzotf^pU
zX|LLM?!J6`Mk6q@#?5UPZ@^<gW9^opnO|X)@Ashye!xZBW-zg*d3zHWS?m@#?%J}u
zZFd{@`{jV!_^HW(*WMq?{-J*~KKOPgm82zn5Z_elyVy}%o+usSFTZPG^@79{xtU2E
zT%f9Kk-bHX-?$AlyZT1=@v52|-H!HxZF*na<hj9>>`$eG12JvwJ)*5fQ}fozcDn0j
zYQ&5BVcFAu#_mQvdsFC{xRg8CdB)v!XdX1lrGfh+BOKr}qQ1pm)%5Qk`Vr$^cU5jv
z&A%P(Q2)JZRnrkw-z0?WXzUfM((iSns@g5J6TXI^s3j$k00gzTLMlogUWKBZhX-3x
z7MFkBrS6i9!_ZBtN(AxSBTf6%n!T*Cs_CezZ?UUus?x7=LsUcjml-47qTETF9$O9R
z&s@Df*pwE350BMXxgAn=!{h7merN{-0zHwHMATDz3Dk+_EdO2FL%0fk&|DSvUU2tj
z`x=o6xI2{=4@T3N>%<hlmfv=WEbKhg3YT2*&uyrK#nZoPIyw*wY#oP=anXJOauyGF
z!I+75Fx2pqaoFba4*gifb+GB!z}E+c6XW!@i0i#3^Bl+F$b<UtL2J|DG)I$u_|WJ0
zn$F>#O-D0w+j4g}nsT?o5I8nX`IS%ty+af}^f~hNj;6x{bDJZX597b4eQCuX1#08J
zg=kYN-z6(g)Nop~&|y(N`-hbKXP>O#e*LgjrG5;Q9UBPZ^zBXYb8_22gX2ikku;JS
zQ4dDcRy4Mw2}+T>b&6w?q_|-g#E~K)e<-ycDV_a^M{)ib-r1)-pdce|M*g8z&ISU%
z-u^}KxZ6J$XCi3;U`r~nt-mSWH@NrmkMSWcH3BH5t<T@lmz(zX$Zc9Yvd<QC4-Kl`
z3?*x7cjj&pPr1#Gtym{O_ue(qjs89L`ssU`TFleX02S=>0tM1hUEra*og-Z`Wls~p
z0o$_u3;wnJy$N!_`xF}FJJ{?9oKrocPm?jm6_e51n!Pl;Rt#4k<2u-!7U)q`GsC4F
zKiI4W)an_oj)TokKTbK}Hr!3q5xXV3O5#6B{oJa58s0X3-l)iRo%jgtk%5uyG<_4*
z21=6VXlbA-byJy5xo<mKa^Dx9E<m8ZiHg~F=m?Aq0yJp<>l~46hd}iI084n=J!^x_
zJrge{=XdBo=o_jr-H9_ygK*O|1Tg?s)HU1l?{P}Scr)R^1?C&vNbXC20Co`r?ey<9
zx6E$*%%=#b*~0-k-kgcg;0egUj@iCX?Ywf4SDwsUKfCTdJMTJ?mz&IcdiIJB?7T@L
zuTL`Xf!TAL?Yx;H@5^+nJ}q2@J~Mj@?iP~t+#&L}cIET5_3ZYwcK&@L|K+ZHPPS%u
zth4hCk^fLveh=nXx7hiQiTvBU@;`&}&0g`EoxeilkL${BWq$q_cK)j(zo09h-}{)|
z{*|5IDDwMt<v+lD&#QL+W|9A8S{MJ!pZleq|Dnj=+Lb?w`R+A#{>LK!<*xkmnP0cT
z&i_K>Kh%}qL*zHw`3{rqeS25_XYhq)uh?kkYa)MKSAHw=-LKgBXNmlRu6!QCo4vZj
z&L1rD`*r0%!2B)y?EH&F{+G69qWzg)vDwc5rO4mfl|PF4)o<AOr6T|3uKe?v?|aM6
zzf$Bs)Ro_Z`Kz1k{7EAJcA3vB`n3>`Jj8i_#|igQ(BBkC$X);AvA+H!I@8&DvshsG
zuAou>=hrWw^QGx$MQ%EbevU|NMMZrFrmwT7p&|@wUPN9CwxMq&cH91IHs-jeF)iD6
zKh~U2!?W0p0|{DaBOb9ytNatDRUfSge9*wvDDxI5vfhl&+`4!qju1rdbnr@XZf52d
z?K|+x3ytqt+*i7*bGLs{&^W4gQ(GVUSoE(J_l1o`CLOD$(q4D9$I4CCp?6eYHq?J3
zR;w=!c4lacxYf95>EzGFF$X+HevKm&>Hf1Li<qW=9PI4jzpH2r_W$$v*JvNA4J3BA
z>08VT5dkdNCZfi$cW_Q3lO13Lq$whX17~`aq;8A!0&NEnbV>@5Yde3Xz4kQUwP$x5
zs1yjMf&blYqZZ>k^;(EDlGq0nr1DA|*f(RkiMHq!>{PV}C@chUyxSLiRb`ZawZ>Hi
z7hwA>9XqG*-+s$i7$hUAk9Yo$a3)>~b~^m-U9Rsv;BNG;5$@en+==BsTF|)C2~Xil
zr}#hvSl1TugwCiaU6S~Hcr?mCp;n!Z$K4~`+uILKaUPoD0#flg3KH7gU*(M-xQ!46
zdVot1xmba->MVu#e*hQ@8ckm5sF&{|$QGm+6FL^B@$2loU0ZsC4?NAH3py5`A${#d
z`vDg#Z^vIK5J30hfnFp1C;dplK{=l?rtgv->+n%H=1W&`+K4Si`7V93b8$cEaqkKq
zPuG?NQ7m{|^=DLHp6|cMSkR8E3!KJ;U59q+Q=GtJ+zIc@KSRH|V=;9yJOkt)IWnOm
zh`r5i=8ZTM2lB(>ICFVNb&(Rd$O!C;_277m3egjUe^pwnJ-`ns#>#ggqkGQoHs})|
z%}opo{vaDn2KJ6#d<J+%)e2~j_W_>j-#M_OgPQ^(Bhnz+>ffb77+(@~H|qY3%i7Q*
z>mgX&q#1Zzc;|p+S)BI-HkMsHA`MsayGy6|U8RH3KFFMdD!?NcydUu;GB^b(a2UZL
zzPH8a3A<uxD(Z_fHrl<?d>p4@30ilQSgc_3afL*7v4w1~%o4~PEKZ4$J@NIAQp{wy
zSXeq(3-MzsBxomo#XJmDz5*)$#>7vcK8ZiG?h)y1j`9v!%}~KM4pGZ$NI@!lJb55N
zSAHdly;p(?ig>6E4H6R<LdJiIw>rT&YOKVIk0s%Bx0$1`OOTviCJX<to}VE@)>9(t
z3EXarus4e=*cI#PBG>PO5eavvg))H@OL(cIZ%cxjmYf?Us33g}pQrDNrE?WBKHts(
z<@}yX7v(Oi8h)<^tjZnBp}X+5xWX0Or|BO>Mqrk&mG;&a%|PnGru0Cj^tj)q>lf2E
z9qPokh%D*tcTdy8zh@tru*(?X(!ZitEqfwd<`VUhY)l%oMSVoI9gE%EfWzHC)ko3h
z{FGhwQ8fBJ;sN?Rmk&jiT6h<RurBJ~`$EdS6{%8eyQ~&pgA`lDtN08uuH<g)&=YuD
zJjE6Km&O~7C1(#H?L^L6!P)U2<LpsLRdQCajhxl)=+4zIS>b|Ri$`OMfOJG9w58`U
zZM3V&?2DL05OdU}{gASIv^ymxp@k1(0XQWtp@mH(8Kbj)WP<vCvGy%+QC8{yGcX_;
zHk6oFnpAe7bd%DObd8IHreZUU45*QAr8|+8)r@w-OMvn6Hb%R-wQV=M>~^t@S}WGH
zKwQvrH&VASrKq(!(@@b((MtZ`=Q-z{_Z>j%xBK_=k(oKy=RD`Ro##B~oHvo%+z(4o
zTX+o>4DQX?QT0Bazg6oP;QDgL^;+bH7Z8(`?bW`Ka{-8Y7Q2m#`J?ozGl2w8GLSi!
z`XHX52#)aS{HrrOALUs;71j|Xyrh-aVu}YTR<$yKe!(FX4`3p(5`L{eN|oBg7tJZ8
z4?^G~c%whVuTbH3t?5VYJ#F{5PibrJAaGsV^}-g-wL&Yb(DQfch3)8H%dgU0HF}8J
zg~4Ceny{!J>4&?u!uz!BB&`3c3v0^TJ99#1ogm}>Emhgcdg0wVR?Q!eID<WKA3OTD
zEYzrARdx12B$u~0*mqFLfjWAkl9!x8%d3WukL}-rf_q#m+GeNF7Fr$v{ZVTQxt<0C
z5TNo7io!bGwO-HPsBdDh@*mS&4`_uC=_Tv*!dgA}^orjOJ*>N`^!zHg|MaqohL4iq
z8A)%zN~ztEzE#ghN}N_!fvohm`Ev!*>{~<0<LLohN5jWS>6>9@@sISDP%50MaIX9(
zF@2}KHH6C*T#seC?kk(VGQ7fLx23<cL942&0vUg92VW*&ZI}M0#F+G1=-ET<JI)~I
z2qR*s&a)I+@SVk9v^-TWdnmK4=8or<575gV$Sk}2j<w64TG>DyL>|U^T6r&$^|GY$
zvSj;`UzH~Nn+Do!{uQtdi^RqT>@~rn><;v6o{~f|F1G!EyV=!AqY#@R3Sju%q8F#=
zi&I4-SQ|8lloZelzM0Mwx7+6xjdvo@xD28`8O^IU!(UdTw~pi@QMnNDaIQ`~J4>C{
z2Z0)D>Op*nYe10r?$lGt4><!h(*hykqt1pGcVOFZ+~xQisVqIlI*R@EJPM3}f^))|
zAiC)K8Qz5Qjub3VdH82x_?wL3d&MSM5hh!|=3F&=-0xM=7+9FGU%U+oK-R9ag3hf#
zOiJnC)>`0lfCbxD(kWg;+%*gjav%Ak?jw&!FZ`~6kRo1N2|ScU@j#7-Kf|ML3O-cx
zilqyHjV9PX5*g#sUODbyoR9rVHnvaH;UdR*;oC5-sm_X<nWscHdTvV~qyUcaEl31X
zEMxl!7l@!ijEj*%UOA?RUiesV;^TQ)rw@Ew0erjxX(I7a0en>FNbwnij&%r4?}ZMx
zTX%hj|3JsO6}{0x@4GP`Zn!!I52MkL4m=dY-eNo)$9M>=nhNx^h-`Ef9e<=6gSQN1
z-|I1hCx^C_f6~7cI7`G)tBoKuY86ty%f4hdOoa$e6v|fF%_H7I&;}R#T%VpqI_NTs
zc2znkFrhlv^!BB)x6gD`g&c9(o8khHFum*ADm3)q!vaJ4o*FHR*=X*?*yhN87kMGN
z|Ilmx=9}~P#U>thAM-aFRy;k#1zNFC=kVpdr{hw*635fgex-Ff0;d4OmaguUT`BU4
z+>eQR6zx~;M-PFAV%Q-PvighE4TFjyNgfrM0~poE0Ic#Zuq>lnTtt_3HxOU0BfiW|
z-tha8m;O#E%FyC&_+dY{e*>v~ctpdYxb$yAH`&D?oZ?hihp-z2_=?&}TB97>=4yqM
zpi9sOEQ>)2cOD+MDp9`A#fWMC4G_~D<=1i8->>*BF=dxn2lJ6Y!vpt<s+_ClQr1>+
zZ`h!$FflT)X&Lv}jWP7vFG{cE4ecSnW}4{w>9r%xH_0z2mco)>AD8k=p(uu94~e65
z?4dhi@WBG?%t{EbSJ0*;lvn3l2?bZTNcr^`>|W;Ev+(+7_BY@#=c=U`Soy(3XT|mW
zCC*tv77w`jW`GgpW_Dr&L6(sYk|Q;w*<jS7Wvrp!Mp^Zn%Ro?(*t<a@=t%lahLtNv
zhxmXbZW9p}9rD0?@S1Da)A2IYmHAXJ+yys(3oL8)^z)k^)p;iGJ1U7;ak>A(hKQs5
zKXBF#1z+6%S$DTra=f0u4|ma=05Z}G_Z9R_fmOEy<2_a9-^zjVB{mj5J)!swkP!>T
zLx3V2Bovdj9WoCA>q|+yXz&Z{4`%8m`{*vSWE6m>KpcP#NyD}hEy)UizV}mOTEf{V
zjXAL(cR6AxNy8|$`#7o?^D)di9}~^_m?5hi(cW-Y!~yfhe9R;n&GRva=3^!aU>Qql
zk(!OLplI8LV@zYwK$DTBy{YCyyZ{=bNpUAi_jm)(<n#jv?K|s8f*gp194Eo6jy;a_
zR=AC5{GXUpM?Mufb*_ExzNhY=xArl0T`&PGN+SyI_&%pCD?Htpw|OPtE7!iLm6WO6
zI{ScVnzu`!Q+m$Zdve}J0&dApd=nVv%`yqiug1*VZKx96&rtSa3_o39&fnd#>QUye
zp68F9Ct@|+2%4*%80veP!2EXo#w3J&wZ~&v&WaI8lM~7NXAO|s2WcWH9c5!TiI}ml
zwwS|<)hKthirpa59#eYYVEWGT#(2>9>MCvvOy{h0P<K~DXvxi}Xm{kPs=FSUnXP5#
zfGueYkAz!aWgjuhrZ?)YcCiVk=R(sV-B|-kLq3iT`J4j9@Z>d9RI?XUv(=(<wknl#
z|I$9FW;0at!kWHdpodqn%Bs$>${ptTy~yc}&^ikLb5_y;uy7Xs9I?cYs2-*#;aF;X
zG{=-0d+DW>yD)b6EJ$*kMj*fywh6WjPcYtU!Q8}2L&~{|_QfI8ANe>+h2K%i*Ovw|
z$%aa^u!CXrB=Z#58^cecq=mhW{B|A&@+*)JdbSYdf%P%;T#A*7g`Va8^cRZb2v+i4
zry1&KNk;j><iM!%gO0#iP)fK9r$t0QGC;;2@DiJN3l0me^*P&*7NlFWs1WO^noDeJ
z?CrnrrN7&;%;M#jSNvK+egu2%5=<7XDU11hU9h(@{$m+NPs@lgv#n~F?KMkRJN_n-
zB$oqhuYCwi{=B^=@s}swf&Idm7;WHh>G6AVlC+k#5{w_KR31NJG+cf#DX@>`pHg{=
z0%WqiAZ{mJgINe}iF^Y5LSOX4&s`>dhD)H2fS-91KLuE6spUm}pf`SQg#p9(Nht<F
zPiHmQ1SL%N>}s>CmtKm+kFcY4iJeDK-CW#7?&-sSo@^{I$(~(f$V;!dT(%lBfFAbj
zey#J3$FMyj=0jQ@!R24rL2kaT#3h&XT3kUC2bf=fb1SCbF;ZxYfdf}E7M;+|#>zVY
zn}WffxQ6<Q)LGY`2Yf)x?FuolWv|7^ft-iTVXS%4ikvWMF7)ZY3qAyqc|)Qtvf5m4
zvwa_fkHuy~Gh{<QhmS16ha0x^|9}tAEfOEM0={1OxcWAQ56AC98*S8G<YmGS6Ut|W
zRz`~AW2rfe%Gx92BOOPqkB*PQW<wKYLqCTP8{uONmfuIm$1z8vkL;xqAJ@<k@SgNB
z3x<oL59%wHKHi(vCq9Om!w9}`WPF@>-Ou5p)8xWYvZ0^D$9!y)i8L(D{|9_zERpz_
z4fuNDWAZIl`k?MC^wI3?6CVf6VJ!ITk@3+Vr#pJkhjhh~n<02?Mt#%+2YRf|N_c$)
z^lpndwW<8@kmVog(;YJErTpN8<vZJQV`Jt5j<(jwCh4DUQ*m=&AcCq--}KU*b-!J>
zaN!$tkm|sf4WGv~xqf%CwuXJ9-&C`+vB|aOVk~yb>&H~NYG9sq<F5CnF<NJp>t3#V
zAdG6-*7D6`stSLv(eA<lc*kk8H<W`a_o>)DX9XRL3l;uBdW<2kbCcazKfA>+X-`%s
zVdwWmZL_|KJjzwhDH?yNo@UR%N#-!PQn?o~7D%;cx`C6xkY^6#15XxLQl%!_oGgvM
z=`Yi7)Csw2ni6epF(tr}4q>_&Hx#_T$@PaZ8kgby)6hiP?Y1p!z@F_J&4`#eI6`|X
zqcQ!hzbp4_L~Cv68W9?MQp4ed^d<ydwI_y>U#2?gTeYvr+H2IhB;*Slx|~|cit_fj
z^7?bD`n^H;1=_wMH^iG-i$v~$uasYWC+bS4Zo?08Iy=+T-wGxF$-XUpt32MulOU&p
z<^VB!Y$?M|mV+cL=fySU#b2zuR-j!t;dcU7GzXYk4}67}M&4~W9EYTIgl4@WE7|MQ
z8$-FM=+FyS$i?hIZYZI=DN!M&j!<P;UnlE9(|<hAAatL&<2fdDXr+G5d42hhuQ2?_
zcVZDt6z;630_H-wNx}v@4gUF7v9uMMwmWb$rmRT3c}=2i?mV|oG(eYAlqwv=+XBzP
zd#JgR^noi7%b*yf`=f=3Z%_7#i`?Kxc$4!;g@K1WC=5IAZhVN7Ka$<@+P2FnorkT$
zfi7u$?3MIaL65Ed4iOWeva`_vPD-(AyTYGn<IDV^4HuY$zUx`Z-FecpIsnvW+M6<7
zaAijaMhPGsk>s{klc#k&+85}o&T?R93mX(!-MquK^n?A4(S5u3<-T33b>GgK=BzwS
zYnodf^wf>qCNlSkhGE6Kw5B@SjJGY<vmKUQEjrcFmK`fKoRzbY+GAI1Dw1?hiiSOy
zHK*WvpCUv?1!F}}#bJ=Gp~4!_nzkkl6~ID`p~_MCrahcQe=CR5-zI$x{d$d$Z%R*!
zwuU?r)%=%4$q5^XZ*+dRI*%e9<K%ZD<INgZ5B^>2)E}k>u~J_{o!~;j<;QBB=`C4J
ziDUBcYuWzHm#M(b!?kbphY6zUobG8=@wpoR$Xr92H+`a4GO&9VHhkr1vW>3JcIY8W
z!NgQGN+B14kR!M}cI|!1mjt(L^T0vmH08#RuJXodKft@7s>nuIwvvc!<@yedCh|Zx
zerRu3c@oN-6Biz+B<yyN2&Ag7hetRo5tMIh%1)d!1@zs7hr3E@ykg}IQi{Dud$N7c
z{^gi`=PG&?G^`PGwKlnGMgwd5i8L8<8Un*4zCtDU;!a&gf<#F8D&l#@WynQ&j2Kyh
zMJHw?N(fz!g<2&A6g(gW=D#wU(*I=$%r7}GH8kw}h943Z>T9SN!h4-0lFC1h3nlZm
zSo!92AxN>S#@J48V!Ty(5)VW$-~2;clY*LzGCf3J)8Enf^T6};OQz|S^c{kfMJ&$_
zf?@4D5beoK!`apRw`ofJ#Uw?i(32rFZL-UvxC39}{fciOG&un?l)jUpK$I)($ypku
zVuwbM@SNfxZw1Y2QG&jS38p!j??99bogVQuG4gY~DM}{(`IpMi9IT~d<!23T$B_KI
zXs1PfR$rZHn>PpYb0zFvJ;?HN|Iy{=foZYwlXk8Q`MGD0?AG)RE-6QsTXsnKS%l*W
zUjKH;PkkT>P*1D?9ex!AD7kteKqr}_&U-3Gfc8g$nDxWT4mxhwmp!B-Mj+79OMbrJ
zGdjSCdq}l-5{$HK_1ljoJ987ND!af6W^BN%L~UM#r%Q^oNYi=9>1BhBZfgza(U72D
zj?fh`>XJ2KBAZxaZOajjwP)eNsv3vWGTPQqumVh-(U9H{k~|tBkDyk`J{Eq8MqfiI
zrmR8$@EU;>opY=CJJD{6lC)G>52XT}1E1@a^eY?uq;ZOpx|A6Fi)=s-QCI0(LoDb?
z@}43y(p&U3)Jj%U+?X7Vzmg>WT(+Ib)owmcdy^$`VqWGNYUie}n-WJetR#c0aT}!y
zoYyKlkj+ea;CcG0<gm}Kuc4o?dqyk!CCbgdIPDN(1vD-I-6176&bz1@iL-juNN9PU
z=DT_g{q3V}KcjB{i+j~g(l@dE`Rds6&n|(T2T{)*X@?*usu_NWoTj|wi>vYmAhw?*
zMrheUX(N+$T;)544!87c${UD`W8v#DOk?{xW)e1y2Wp#P6f1N1dng5SxBWnF3Y)?H
zrhaomQ|zQLU|!`{c!c{JsW3KT8@tI>F&Z0UT_f~C8JkIo(sTw+lJpY_R$7TC{5o`p
zoLb7^Ig)c3J^{6KZ%V_*IEHfw=JI9@$0^p3%Mg-MJDL)pGDlJZRYTIZDg_|ru0$cp
zZ=F#HVcv@rU=)OyCS=$IeU*a$9Vz%ZQ_cX>7EJ>bKwr|INL?PKP<n@0g&2W8*`U^$
zW7w<?IsOC#8gC>@jxu=($HYiE$SIzZ2)z)d05v7pdg+4_QVB2yN5f$>!W50?K6WI9
z!2U-uVXu<M<3d?U;-9oTO)6mQKUoE&Vfu^2U028zElhUP19TJYYPOf9*QUG#tI+pl
zd<f1f(JNIGwYS^yQub!2=y<c-lVoqva+BJ;DQyX@SkJW{#O5g6*P^r^9YajnUG^!0
zT0iBW)_uFL+qb8%efM>r?*6jPwUthAt=Q*+LwLoHSpo0vH(Lj`poPjEI7+n*4c>AS
zouSe%OGXeB1<#~t^gzS1X>dUy7`pqGA-L7zthQW4UJ--vF)6S}AQfi63RcD<ccWCZ
z9QNsaq&{N@a;rAa)%ZawuDpAjT73ro9C==zDg#sml5_7FG^CuixhcF!26;_7%DUcJ
zgv%81^q8~aZG=wJo<uV~b(>fOy{EahQ_izU31Ler+u;l*^S%?#v)ilkFf17h*5!CW
zJ!npbP79qb*?R+)ua35PDGOIF9BOYrknQM%q6<2K2@ZO~f%t`59<`<yB|!{M;{!zY
z&9s@YyS{Z?JHW;i^HkJ{4-;@HasKw*^_Yy-f%}jrrv%f3P~&}VuDTBzTKS|KCg{Vm
zR!orY!dq#yvGTDK(N`RHMUz*ui}Ff#VF_h#)MkS&@svhh5{CImy*x`c+18D?E%c`Q
zhOYdWBo4xpEWt_DzM<9GL(4z5m$x6LW``0fO-X6<SOVxI`kj^gfH}9@?ANu6a3dAr
z-h;ch;XnzG@M-arqi<r9@B&MPyQDU@GkV)xPq!X4@$&|1oA?oZ;wKg}eMFT-!K}_h
z+}SR+3S@6IAssOjGBc*b&Y$g2pPfXrVF_-l+=K8oT*QD#Zn^zc<=Q!w*ND!$E=D2<
zMSGu?dsPkPAB`ygI9@B<if0s%Bezu8=52y~i_l1CMLp6p>Z@Hl5fq`PzMKZD0|y<q
zW^Q(tAA}{LyS8G6E1P0#H;{Eqwf{=}$y!k)=&oI0TyX8!l<-ejq*!{5*6TvL>~(6l
z?g&w@nVrtiKu|g&B`WX1r==RC7p-)i6-$w>il;X**ULsG#)YQv(X8GK@Ijn)g8z30
zaP6WEdnW%O0ChDT?$XP)^Pyhsa^n}GO1H~BAWRH4#a4fUG#p3x4ExfZkoMBt<XMQ~
zgVHVdm=An}BS-^jYTv-#!0|ND9rJ(x7X3Jid8Ej<eB_rmBtb^l4m+`bNB6zx!R_EH
z3P~l|X7JN*kyC!?SiE$T?Kp!3%EI!l6lcZpG{yPbo9z?|iYQIxHo>uu?MSeuSfGwh
z$BhJ`BgD`yGDc7?;+R!?iK1C{1d8tdWs*oqn?lGOL-M$G*&Cdd&jYIRZQXUCJCeCo
zhw$0#dXmD|$`2(kcTCd?pM-m7uJ+~|S0fF|Rz^4DF|fiXb;lZ_G<y?{n1v}=vHY#>
z=4^5`bcd(VSY*U4^9_88Gv!3eL%3M#yLN`@neyJtg}@VfJ{o64L=d3Ay*ZA9d7nd@
z@O-w%^TT?W7=-n{Sv@nk{3B;o{?725FuI6f=>)Uf=4~sf6QgY)*uw3t14$S`OhZKP
zZGcjo6RS_dA3(3;5X&(D-ZD2)zCIg`Tlkvihys``Wuw%0G19@sT!x+v116mnUt*~6
zbU?5i-imif@CyTIPJ|g^3sc~_8Lx#S$aMa7WyeFvlR;N6gRa`LlG+}g5AdMzE9ujq
z$M3S76_2369{5rEZ+Pz6XV1~LHo5M$9r*m6Lu`PiZ!QR>7PLL=M<twDO@9ZXU!KP#
z&G_(QOPfH9^kF+IPJ+s4Yo*Spo+aZG5DRA*B`JZ*aYJSU^qyW@>x#0w5v@+&LuGe|
zN<vx}@lun`ZM6^ZmJ15(-n0xo!RJ9AWahAMdH3^o;OCx)Zy_k2r!1Xgi%E{!0i)4#
zY<us4C;#v51!yD*bfQ(FnA*g-cxS~R9*c>N*v_u{uR42^hHRNjSX|D^YmwL#KP$Hf
z>>K{^x5w{Q2$7)mftC=VNCr1!-VYsvwTJd@I&OcW=kE|OLC$qE@)=qGa#qqAA_E9H
zC<cR^0V-6Y;}LUFbgZ_yrs|m7-m9XfcrSP>mzF~Dh;g2JIj@88Mr_o8grKAuD<Z<r
zB&C#(Zz%6~LWGDRMuo^fcejIhM@zB{xk90m)gYX3GfKl~+zt_dk7D^@#|J{6LC(^C
z5m^>kj|Z$|U-k(v))L<!e7q@sDk8{pv9_RKa%C_+Pt1kqTVuJ+I^)5KfPogFAAGHl
z)ck{!g$wgaYlGx9X@u`(W|fVFH)0q)ruN8W&hr`0?K#M~51SK0tJJ>cBjn)SlBW3l
zhEEf7)0+rKdt(O{PC&!P)ElzoN5~R7)x+mwjF}+*4<|#A$%Jr9^s5@xdvJ>t6p)%y
z^HBHD&x6<$Kbc4-d=Ra9JeJD0|DwwIT=_Co_W3N8Cs`_|fc}>BJ^xMdv$;OSSNDz|
zQSq`a1S7Un410h=3=YD5&M_ozaqwQ+Cuv6uaE%SXstZ?ClOQ+LJq70EU|S?`jP6c?
zTCF7eOdY!f$s>%(Eeao`72`g9M>BdB4F6!gUbYXMQ85(EhoC6^e7fJT4OQhy(5wCd
z?sj#6iz@aZ5hc_{kA70+p5?wUof4z?8J)^;2;ZgLPzNqlXc3hZ8jAZ8#2v3Q-xWop
zqA0p3n@VCor*K~uZR@x?GjTgNkq}Y{Vk}P!JN4umk0?PnIUuIPi^2OS3qh6QfyqFK
z3m1??qaRK{FKWH$#&d6c#2y!rsEbm=`$1!7JcL{yUo|t)HfJ`rhk%`n=5Q|vxx*He
zLTmVZ^g<GYH;TrgH1?1s{w#%lnk_-8PZBS6(U1X`sM^G1Msse_k&6Olf+nv!;G_`*
zg-?8n7rZEGPvBuBdBrPe9@9u8#m0SMQshx2E1Xe_7ox>tZto$qR~)8bWJ*89($k&D
zG4{1q<;S)co`DK7K3>KD4U_RKaZGF{!+=x)OLyPHs5s*OJcIj}vDW?ZU>hg?juN9m
z)6U8VFrOIn<=8qbM&R^SjYLo6cAf^ZDCA#EUGx}=B)QJbR79Z25Zw3y5)hN*;ioHc
zlZ-fjBaOLJoWq|T;xv4sV->f9Q$bM@L#mv$<ujz8Bqma3S}_uXJ$D+Z<(AhZR=4t}
zD95C>QNS?qjSw#(wU7Sv;69qk{Q(V`V5uSzMz4`7YH&HKgo}ZCFiMPnXl2JbqIM3E
zj|-d&e&27#TJ&Fi#3{gi$V4t@T>w<G@Q=o*@8yhRIpb=g4t3bXSxL5zUP)=h%O4Tz
zZ6X;<yuXuvah}*oGs1lQIwc~wJ*m8_pYyJMT%9V2#~M(Cj}d=^A{ty|;(3Zt<wL6Y
zQL_O*x`c)g{pCf}1tiL1YHbbuLiAwQvAFIV3C_D{<wXJG6+hw2(@D;XUsJgdm-CPm
zt9lI9QK+n4+eC&QG-lTbts&!`^af|eTFT-00d3PP$~;`hn~mn-M>t_&lN=nOb{gd#
zBR1&Y!Fj@+*jNlvHF9s?fzLiS7O4PlEMjG?HWuyK8vn>#Lz&oE+(gipUjlPGpMaNx
z%o!?!7f$Bj1!pB4s?@n&lYNeALFX}H#zL-k?EbmMDg>Mm^Ec^?OOf|?rZt`CSh<3W
z^-VO17D>84a1q+@iCb_5Y9v!tJ*Lm9JjbR_8Pz0*lw8VE&@09kGSP+ag~@>2n4SSy
z_*SITeAhvPJ%+<dfeUB}TA2gMDmx}_d4a-#o5B|XOf&J#c21;QUd_bs5x$I)bb#7S
zY}w0+<fYfyyvKGeJ8Y|qk|he^)sh?H?D*$dr(F(@9VN8pXs-0)(=Ke4Cl0q@$$1OU
zLBqVu&6}H7qHndi`F2Kg`rF3l=2v)JybIAF7b6-3o10XO{n`i&;mu7pb<E98B9HWD
z2D9ooMA^XAyykMGv9DOKq_5=NrcbreL0?f!5Ahf2-KMX~yRENbg6CXzY*%yTp5Y;k
zAR3`Nt|=@2V%avup)mOAn>j&SL(+#l-Sml2k**OsCn08p14hWxEpaW2R&y>l>)<U8
z+R{+CCu}B^HzX=-UIdDebJyf*A05j72-b(nn)xF}!@Na1(8Mj_hbRg5v2lKYuFk3t
zOy6&_2m2q$8cP1gz^|nm2yX<aWO)QeLB_O-OL4LXKStodr@V9f!*8DwBVR%9(1646
ziTj}7YmMHbwVp4!h>^FTX!v_~;_?7AbS$pD9bgE!B}4Jr^#Jl$OZ$QD>%tKj+_6Ey
z&LjetegL|65&BxiBz)+J`k>5~fYVv-18Xyc@4br2<@+;66YLO?fmiiJdMUGlZuTzk
zf{6GWU(mwcFZ1Bg<em72d(E&K0Ch)iJ%Ur-C6p@z7pdX&G79ijYTA@!-MA4+U58{|
zgoJW^T!ZA%XR0fd$RN*6iK&(+PxtjvP2HZ9N3QG-!fiz<dtAaeB~5!-*I{}7xxBOO
z>bBNaUco{`P6dSUe24!|{0mGYBA@&lIO~Sj-i<9kxCTP0HE=zL_->5!&6Wclgo>mv
zomK#P$}zFwzu<e@ZY&$ropD&QdXN<L{5vaWP>Crit!L0O8bD+zAjTp+hTaTiOU8AU
zY41FQgI}b-tp`M{@w=cLuXy#`KJ1;xDG_rORkS*(bT(h6!5qjVn_-zj4&yPR8=0;_
zf$~g}-cQjNyw05lu`QVk1v>R_MBAMr3!ms;Svd2^a_nv6{0U}Xujs~wm-S`iWNbrE
zXkYv&X|PLt@RIE5UH&ANy9Z1~qI@3?pTe30hiyQf2?eZBVd@dGA#TDPBfm&|4M_M>
zS#(i}N_-Z<!tXLrys{qQ<nmyjxD2{V+8lIgh<-vSrwa_X<mB>0DS=ynu}jbjg3hCy
z4f(;x+eH)95DSp^VeG$zgXh&*I4jXfMuiP~G}<>+Ai7-Xa$PYU7ZlUBOD-;L6dga%
zxG+$sxDn{px+u8)y%+JVRkYv(hMN!OM{p&&ccTEZIfzg^QI9fYA61e(GfuLJ@a6c0
zy7!Uo!`b7I5c$xI7mJC1Uq<JX-!*N$;T65fPo7Vv^PF!Gar60r;CDW-lt<*dFtI&O
z8{Z0JpUE^O-Abk$|K4VH^-?)^Wj)V15AFZ_`GDT%IiJDuQ>_;+m#rR=f3S^)ImsZq
z@ZPtHP*U0o+vynQ&a>pmfzYievAgU`>}`F?+l?J<F6=dS>?zs1`?@dpyY|KhrnBP{
z7d}9Wb4VHOen@w6M{=oMEClJX{e%SvozymsBrQmR^2VBOCQNhQnuu*G_;=iuFVzMk
zviU3^(p<_^T!JY@fJ?18>;*Xejt-5}ib*IS^#^Wdq66&iwRCRVEgm)i3zHpz#&PGu
z-*XhO;h9J~qCdbAk4evsFur}F182=hUL7eOQ{r2luLB9)0bU0U(-D&n{1<L9=S<l`
zeIOSP67g|GKH-m*byT|0BK<+)C6az8W=RPXv)k;LF5{=sa9Ia}gaq#U3aW;Kf2mCo
zr<0;1Mtcw(+*X`IyV>{92@}N9iiLm0z{^QKqX(ZTIuqv;e6*R3wHBCfES9<?CMQaq
z@xu3lB5s}d@jRI<E!aOzg48KN3MS|}6Hi;D;{Y+Md^ny?%^B-oblKx>I+1rB#<~TH
z;gc+NMI2pAC(cvJu{Y9*p(;7{GCE;b$%{7|jnF-G;`2qa?bz$*#7>nQd+VIosFGtZ
zn-fo|<Q0uZ+jPgASgn#{ua*-_RdVc&a$>$pZvVz;gf5a3m#XC0`{Ts<DmnJrIB~K{
zj=e2TI8<`Y7Nc#tBu;#BtsHz!y^&0J!-;oQ@?-xnlIcn~@rFu{y$Mb{t&(FefD`ws
z<k)-P#BC}$_PRH5l}e7i<xR{`$+4HaiE%19_D(l(3Mb?CP`)c!-It8x+tK?G^AYHP
zZ8}$Sf#24__anZg4uJH&A2F+6wv9{qPe4(x$W~{e>Ty3}dxDX766c)}&3oNnJHW_0
zh4cDH^Kd_6l96{N=Y64$C)EdWKVr1a(VX{=k*DrQOgV_jAgKLgIsZj7pQ7FTwGN~0
z@tl9JnSUnbx5OLyzvlcK&HO~l9}~^b<$RBs|0&qhUlV84pThYWW_}apciN5o>70L@
znNRmi`Q6d{%Q*jQbrcC2W)<bv+Kl>M&VR?uUr6~W(fnf0f6>g(qx{9)27XF7|6Viy
zOv<l0Y~)|b`8S&RiIm^@lacS|e2<y`Db`Z{+9>`Paeju(m-h$Kjzstk{OPSPK!2&~
zbXs5x%!`xZvGE7FiPv!|jI_m`z%fu&$&l!gI7H^q^_*6H_bN_NNISNz5cX*h&LqAn
z;k+~{b8)NPN08)6SSImdKb2iS(PE5Hqv0>%GwnMbD#qWq33i%-a99*V^MaOM_V*Bi
z4{HeQr<SxrKS*cSscBX%9c(6J^d-24NZ0Mf|5mrSeuNx9NZ@fYG7|QEfz38otGR&S
z>jm9z{~f?rkytjK{V=3^)=Bl}Ux5s<KNDUWZ8KI;T$#3Ocsml$LeNcbF~$p9E&`Sd
zmT&HYQYda}VOF;C@IZ5)#7gf<cOou!X~)|vQMDWCZ`hUXC}J8hG@^a@-|iMOCRlK8
zm^DjbW%zvl^*n|R7pXA>=98wYquwt(GW<^+4So;7&n?`SrQi=w054-h>QsCHZ(neq
zd9i(dM}2MvE{}k-qxQ)-;}+7QeKv!C(C2ls&vZ;;k=Suz%s9s&QOx{b`s5bYU1E&W
z8`I|k?(>S+K1-?3_c8YWdYs(C_-LOWg2B}|F`p~B&(FujjPow)bK!s4C(kFhuw{}l
z&TGv+F`o}}pG%BBofUN0n&{{$>i0{Gzt6D-#~+;sxVAgm=K-=x<$NO4uPsXT;p5Sp
zG^9=cO;7n2k8OA*Jw90Si{#sTxCE;&`F7dKN<0Kkj}dI2U1VW07HorI0}~hG7&0xx
zRtesKjl50ql_q>~EPr=E1}XR^{WAD2GU3DZqV>TKfN-xk)l6ln+@!?rA5ZEV>Wp4c
z&$~oI4a+}Yc*K08Vz3#GCmaG0azu1*)5zO65HIq#pVu!>nd7@cnfyPaUyAC1e?FK^
z`ej>Gzr1~7-y`|$g+1}V23Ef182I(KN@#oF-_H2I&4llD95MSP`tOat>Epa3z}Gyk
zCw$-kI!Yge&8Az90w2ZxDf&3&m%%rL;Ohf__YCbDe`ocAuMqHA@OR45;2UYex9sL$
zgukV)_l>`=hV%{JU1NLV?`4=0ioXbdOO_r5e-znh@c&J}2)_3=^^L#FjsV|h7xaX0
zFyOP`ujxO1^1r0Nf0^)2`epE4MDVd6G1mTi;e@{NH>DSRL6`*={4M<WDDXXD!uQCH
zzX*T#Z|oa?&LhD0m-Bn#@81{4;O~|8KH-z{^JWvi!;60rd<R~O;;)44S1CU~qEy8-
z0#e72pR)(|jn%I+dO|%S7V0#kBIKvKkRs|;S-)G3=oiS(Jac@f{Ic;4F~=8UpWl;e
zjO0xAH|c}P_vG;uK%Vy+OhG2>O<3}W+S-lC(m-lktA%PFdymHe7YkGaG(_ZOzE6<X
zxA}D81J<@@V1e<KX}*`>44M?MhWXBm3-SETDc~21lxZC&U^%Eroz-J{qIlzYtQh#_
z5cS?>Y<z+YhPekes^a*L>w9)+gu%#GaJ&jDm41AWZZN3)V609HmVz935dlB#jvykV
z1Bp6L@CN;c`GFha;EcNXG?a7krarvHNMiTX*ohpm0c@4+Ez*OnKC$^c%UBFc{0rz{
zJhln1G(fg#2%5<nM&H7G#0=+`(Hz`@uasae3R}q!`quGk4xM}!{0(+tPqHsRo{ucl
zV8JsbbCPrQZ(#b;`DfI3)VW2F8xYh$wb{T0WSYa<Mhl$imPueEOsv-|{%GaTmHx%R
znMFnZjhG>QINd1km6yq@qu!WV1G{*e$HePxCSHBwP!L0w&bvn7^<PoEUT4LtSA2}c
zWN*CgMbJCCQFtwB^@`G80k6U6g_`nyzBRB2*nih2asz}M$WMvf*_TI=d;M`y<lcZX
z61fxX%Lj+A!B6r(GJYpGSI;(^Ap8#IHW<I>m~EVkLO?E191TznyiOM~^o;K)?-*sQ
z$Z5Z6jL9&g7X1?XH6ppzfOMK&bR#=CO1)w=>;=n3qFay%hq52y7C3~rb${SYJrNU-
zrbq>(Hhpds8}m~XHUhIz(I?zk9qX<Z;$MT(Tijw=CeH{;6p2Sh_d(<R$Hmfki$UXr
zLri2|5=gvA+zI|b)8&)w%kFJP{5Qq`G~s*!TBcj^5mked2s}$p@rbA95R{DX4Ne6m
zP7<Jwm7eL8(2VHXJ$Sj^ud;sGDe4T4epwRQpW5s=j?ks`EB_oJpuw-8wPiPs6ae)F
zhzmebqb02oT&4kUh-(+3(01V?GtqeuZRdnPz|v0+1mJPKmu0=k4(igmdJ_tm-S+A;
z{4nLSR5SL!V(8&R0I1~Iuu?hNBkey*d3GdvSawri^iT{bdqjGeFgr>Q?qe0E6+L7P
z$HWGi9`;Mgm*3(M7hh!3!|HSUpofDXKPy|t&;#xw1^QD8io{KzrC&r3K)6_gAT31?
z&kj^j8uXy}kAtQE@AMEmuWh5a@&7YDJSFS>SM&h-_s9BvMbj+lCXaRdiWgLJtjAY8
zpps*qy<(+NI>wJEN>y^K`&W2Xa;(=^Of(vaarTNcRC273R~)O7V_m!AfLD3_V?4T|
zT_wjla>X{49P7UoFRA2Mx2^b-N{;o`iVBq+>!cOespMGStnjJiSeLB0gp;lAeYL*t
z%fH_NrAhA}Jzy|V&-ahUq{81!rTlSU^7}`BQYGQvpFhaR8_0RCXdd1_I^M`TiSyE<
zd5`;Rk2CU4=e&W@yjA|16eBN#^S*vC$~X%l)%=T{Mt&yeza#Ude|ZYYy-V<?_xhjh
z1$DoHj2Hck<W~+F@rlb9$WD&5AIXa5z3U)0njr|l|B%VoapGo5Y%~((qq*3=4UmKl
zT#w_C2-Ep(#x_X!IDLTI?eU7v5fpLJsln)3gOx8`1RuiZJi4Mle2Z<(US`7;5Zl-n
z{KABH-PMSam79V9#;|SxkXO8j77!8a6KA6q?q@ag!)Kx!wDT?6iM-O&Kh+yQb!LAP
z(I1WasQ97xz<c56aZ3C@;U^7FDutgQR<?wn>+p$?4J@g5o`IB}X4NFfWQ^-|6W+V8
zIwF4VMGK6dB-Dz<Pa?WOJ6nDse(p2-8;1UV7C-l23k_qMm=l<O?nI)Aw7_}j|1q=O
zEm!t6j)gTSMH|}@tb4pg;&nL42xGuhF4nR{SrhOnF?QVPNa=~OWC;Gg)+@$+c(gz&
zUBt}c6_)@A8eDJXF4g){gv>>k3LVg)cqddDQ%sSM!Z?sCSS(q#1vewnEjCED)tWP#
z0?CYtD!DGj_ae~&pb_PRUN!eHtl=~S<?&r`#tLORRCu$i13173-~1o>JsHBLzcrSg
zX*@2)>^J=8NR!2Ibm9cMNwL8TIdKmqMtMJQR_QUN9@ShLn(NJrC@?+J#?$jCynbqW
zp2Sj@rspAiN`{Z?YkICbCptaW_hbQy5&uQwNmKLl==>wi4=Q*?8bDX*ZwC5lJYI1O
zB}SK#Jf2aiIX9Y95h1|8AzLt>Gif|UK5+xaLo<T|560YWAH+#$x=7UHyCl6cu?Dq-
z`N%cUz3Es3!Jb4}f2?j1t7b@r8>?2t4JtWSqljXa9IH%3woy7pkBD<ra;*9ggE%=x
zR~~&od<OId^yO>!N}TuJ4_|RQ^b?ixFJS$Yai1zl?**P_<SpjB!O=YE%QPeJcFsHa
zd!ydt{`ymlymHQKi{?RJ4ma{N&TBC8)PDHlAx3@;=dYFdzf4~a)!x#;eI$7=orL8G
z&OkPc4==Ox{3A{*FbAiQibUHbcAD~zIbOF|dpM4BDKK_E=-(&KyD*-Kz8R92=!SAG
zW6mhdvD>bg=Vi@zD<Y{f>a7&#^dAc!6U4s%0YL5+ufkh^Unm0YJEVMTcVt(o(?1wx
zBJbl1J+L03M@S)y=;$jI_?z0sHP$aP)PW*n<zJQ@AIQMcHj|uL)Qj%IZGSVlBdO*Q
zW9uU6mW&n+UeF7ZbUvz-iuhZK{(phG>+0{U_%nS0mr^TJ@vt9Oj7S0ZlOsmYPtvpL
z%+jlRHmz0RLqY9;2Q>pTs8(50kvN`f)zUf>VVTCN8I{rJ9J+|3L@(P#d&GqRnJNW$
z`9!{45*zSwa*|J+DXkjK)za*$B{<OOt2)}Pjno=Y#u;UHaSR}m3&d(X`3GQWu3TI6
zOX<C%%4R@>=VuVGwmKa<SLJ23*fm}VA3Gl12@#2`59Nyxjvf`(HM=%aXIlPNTtT6i
zZOzz|vA@~14pv!rWF(#Rc4Sb#?y75c(D52uZh4cVyxB3Kq}ExnmHKhD(BAa}^fkYQ
zAjOpq$zwcX@N`K*w0f;rjn0wh79&muxP|KpT*rfY;W|2YF@u}gMdgaQnO&JDF2fyj
z()BdPE#90)8fH5aljb<zS@EgST+2z+T%Bw#Oy?TiIBQW>pWfxxOX|IPeyc~^{S6a2
zH9r#b0P5QwLqW-NiBt)L1~C#*U@O18o-6VQ@epZQZDseelM%q?+DgM5`#`Q48w+#<
zKf_B!a95tmm|r#m1q-+9jt4Q16d!0tu;x<X|LCrb$l)+J*G4mwT6S$Qe=GEcffvqd
zaf@WRh7La_w@GpFK3r&YhapA~PCz0?TDcDH0Ig&l-+Zn23$MUWMA%iHgHHmBg53y{
zm9HQnd<vzy)>YQulB(yg!(8hVtMJNTKSc=QoUL&n#8$%K0iLUMdVU=oDtgIwyv!Ti
zVsF)g^;&+r=6V|b5c!fJO)7}Vc-1bFM8gh@t4`GOx9X{X93L0_QqNznJN}s2wQQfq
zUEmY5PE)(iL3l>iYj}Te;scDUw*br4df7VM<1#HXSbww2i#g7(Pv7d+3+u6`h^czI
z)0pGRbI~y}aC11eAfMLl*l<LFyUYRuPyp}(ojx(<MDEkx#J6ir2-f5EXJ8Oll7p%m
z{u8G=20;dZp#kYh_9j#d4+oJIplQtQF|zG*jkW{tg&$Fq;;O}YTTEkxoEME|8>ixl
zmGD>;<>Cbw`)1<1!tM6Wh`}#hues{Nw_=-`C)yJ79DW56#DHzd2t+;Br+<LB+<LqQ
z)LI~3{3<%^b!eI^VzAY(W4;<8<njG_`o0_2pt_R8j)Q0%L~=5K)Jkf@>G%XYpoA^l
zAv<=9vLVD$TQoemoFpDoH5SN{e~vOv5F%@55wRsRP7X`)@H=P(4PF;5MzVEXuVQp7
z0*bvGQ>>DTu^_`03#1dm0koD&aNdS5z5ShPeJK6)ZJ1P63O+Fr4Plf=T>nVFvJ&X&
zB+y5~ME}@q;0Iq{Mk3QoC$ex*1kLMN@bv|5(o?WzT%;G1v|pgC+sYlwa@5xhypM#l
zuQV~qbyGaTmWTR{#dEw+eQt67DaPtjGBAv1J;#B@GsiE-jWx+QlIRfw;cTD7#p7Xg
zM@W|VABXl6sbrtR(2fa`{SXe;Bdn)ko0HlK<s614Tape<N<y2FRwVjiV1%^ZkDAmN
z=Xwv}K9WhO0RZs+#}Cx`K3c{k(^nW9P2#i@KsqJ+fS_Wp7>pliQESX}b>MagOz83;
zqCK8q#f_lg%0Y_V1B>7w!}H#aur2m^MG07P&TOAsqz>l-HR#VR`eCqG2^NXNr=T|@
zfC&c__9-EZ{UhqFkNaHNuIVQkJ@OJjc!ofr=!Cc^2xYWxX~n6j#)ilUd!zfEAKXwL
z`#j?9q5W*L=Kz{j!+5UPa<T(dI%yk+Ot_P0+gs*B-M}O88x#T*;Y%SS05<&HgA~|P
z0CqTECKrj_2c>RwiSS<`d%0*rDmoZDQfm|u=*T(T?)%tQ8>rg+9tDkfVzr-w`Q#(q
ze383-$%UBGg~pU}=vKxoQf=)tvGrsewf8WNxV`d2cru5UWdMT?V%q$*L|zL31!I)Y
zN0+r1iTFno5qG8@o<&yd+p~ooWN&n!z9N{+cbAXT4rn_Me3<^NO5*<9K0+P`h93v@
zt-T)_HUZ`n8Voru$ZT5nq1z3i4)l5<iROV@ynKK;LBZ1mP9r8Tl^&z-Q|y_5KzP{i
z52Inr{WNEV6IjQu-lTzgTzq<$q-DoQF<(-IJXYb56-jV^Bxi}hGIcH8)qpl6H?D$N
zHydP7*j^y!pnnV}qQ%S?PLk7-P)!!`A8*o-CF>P;6-fT;y>73Wwv4=2Uh(7sgU>b`
z&r?(0l@K^L3P1t?00O*X@5z$5dL1|}D)RYXqN&~B<oeKT4XAEfG1AMxom~{|EMIm8
z0=loL6c0H1#Dw1;qgEHEf@U#LG;~fBjxubfFdVZ0N0d`h3jUjLslfpk8PNVpLQ9W<
z@M|IoDA9L3XB2-?`DHhV-7BVej)*_d_p)nwP*?6ZFnG&x1_pzvQM5d9tQw64t1rOV
z;?b-+=?GYj#UR`o+|_5;^MLaJE3hxVH#&`%odT1O)zx7hVAdqmZN`_PBDes9k1|%p
za07p-vPV3wRL$oPEc>a1?D=OKYsFTY)BO{{z&KCfKEp`<h>|~4$+0V4u~j9<E^@_-
zDmiw2D;`wIu}fP~Zj_E$)rv(bId(BC3OO08cVm4wiui%#*Dj0vqBVwE-0gCU8!sb9
z-o+$F_fYI=j=hJ%lwY4o#Uw@7vr6?~zmG1Q2=KB5nnJ9_3}b-|Lw&AC%=!+E7gFQ6
z1w$|3dn`x{62A+40?FvxEq?qJVHSn<QqBo5S~zE~Tilr?7uU4*Bf-a2`vVe8C>~|?
zi5tP;xFCVDMDPSjK=Oi%{~!snqWbu%!aej5ZUg<s(euNR8JUNj7003xL?9RWhkWG$
z&p}(kc(|F?=4?EW@~S*D-o}PR2TT#@CzuJ<g?j*K)d_jkCvdX?yvo%Harr#NVkiFZ
z1DPE=P!YMaq7{ASMRxWn8#50CGAzA&#Qt$c=X9bc37wNOz}2Bob$CR7bdH`WTnT}H
z2!$4BozJL&d<D77RZhDpIvIh6C`BFACEPyBNa+C9wZde}l@|ksz{R%I9zFxIf$y8-
zdAaW!Fcw{uKvT#UjNth(h~)4GFfTI?2d2g%&?7F08G`GKc-uVa77U@-;T3t%AJDmI
zsyePJ5%>yCOw<mCUqXXGqWwdB|Fe|$*#3S7)`&qmba_U&K*}|SYx^jWumJOsv~-L7
z_lSJb6orI8M<ad9w_f~!ef-i<k{Jqj6^N^6#4v+vR}W>*dVI1ZPycYxjd)yXGmtmW
z!@muZp8YkUZm$(}mGeMyh%_O0#VmZKqU5ePe6FH?Uj9*_KjqN6n(j{kx-bPwyVDfD
zjVVMF4lg}!9&J+pQW!#97{R8_if3q|U3=-->Ixm-aYCyZ%@&Erj)6rLY?mhXib=?(
z>tS#OQjtg)93|Z2Bz)j66vypsTT)OoxEoVxZ?5iF<@$C-*|)afUo(FQWOxk@B7@@m
z3y5mna2S(mH~DnMK!O>_C4&Hp5NacQI)#N?b)KZ*{JmJ#GYuE+H4m&YE)ANN)+Y_^
zbV8#`z%U1PEi{}*B;&%!dR_w(8rH8m9xylIUMVZEmFI&#wWeb2L#+1z?wZpGT-Z($
z+&@4uRlB~$*sJ2h$soVX4+A&gW{2p2sZKW9P!a>byxamPUbZlcT1cb@`T=tQL;H{c
z3BNAsoQe6ouZU7WKNco?0sIwSg+F?*!~U&Nt4h@>+2s}6(qmX)8XRlP0wh*#VY=oH
z*aIK^222M4!v8{w^?Va@{q3Wm$VP&U{S%3nPq>iUz%jaWjbs-kcaK9)S#KaMr7TC4
z_i%Y+pii8eGW1Q%eo29U4oZ22^HPQYLehvPvpD9w!X~ppo#Xp28C6i=Uxiw0DQpSC
zY$QGFAm6^iAYk68s^K{f%(bn1WaX16O=G#0Ai6qHvH*etLFpHwj65ldx<<uQNsgj?
z8I>Pvl#l$2(ypSkv}oD}N-L$b<Y?NTDeXo|>q=04MSe$VjKO_ITKIOdv3lGOgJSA^
zMcz+3nekI3zM3NO(|cX0PoYJH;Z>za?AWVH@k3~<Nc`h0@``rQ^HFm$rKErp+Nn;z
zfWtbx!jo?2J;QAsL}i^Yw0vUtra0Sdvig1E@ev?j?7&<sS(Ba70W9Z0u5R%UIC_9O
zTt|<UK659+<fF#9R+4O)kZrIwn_bCZP1;2?upK|$Zu4&kx=07Oug1X>w|Mj&Vqa27
z%~_X2*x8u3{7IcLrEcw2DhQM+3O4A?ffvoO(f2R70}A0L!N<&uJ$zmq+NFAyy}POf
z*N4;#2j7NUz2fn&J+`XJGY?naDZgD{FK>*?eB1fx=FE~L=cD!66`O<q!21gzoMOH%
zBBS2?9=o4LbKZU-m|`;E_Fs-a;@$Hl|D;8e=Tq_<DtZ1mqx993{Ip7b>>?xi8cM!b
zCAW+*l7p0d8z<Ao41rNNO$Aiq!VT^1@<a9|bRYG<fqef;ly>74*+04@RmE_f*2$x)
z0r1#A_#70`kBH}=2`u+%Nfz8q1FNPkhr}zp{7Xo&xw_Mw`N;Ys`9ClpO=3wtJviU#
zCFP70lW>o_ap1^?2rh9IvY_id9-l}$!)Ci;j<?8vH#(Dgyb`Jnr?7aPpN^6cMuw>9
zrOy$+ng%W7N^N#^frdca--TRV=&01@DG+~}!L>1-RIPQxACWKUu9S>=4rHx?x#voT
z22H~MF2r4;G>V?MfmjU3{zs!IGGtl8H*gYieFx&zT`BI;IIc7`+QqI7Psn=YKZrDe
z?G5^zA^Ba#SG)#V=jkaDKjt2Z<)iDvBJtVjG^&m4{|OWG*3w*^>X38gdK#jk2!Iud
zF9qeUquh9vi#?^_!stxq+j%C7#K?iX7r9QEiN$cZo9EH^G4g2tk_HADH9t>Iv|XW>
z)S4~<V`iwAl^B2b;HnySkYn$IgwUIyMx1s+4jI?$Jz~g|6lqPbbBl8mc@)21fo$ih
z$MM(S0WyHcUSE8*kEFz{|Adq%+}NDMA_5jZ(`31gT>wR54&Z5a)uAFwDDtc;8`u~e
z2`<`CkjcSXa}BPStcNm^@@&0H)o@3{y;5<LQnIc()0hsIAdyV2b@;#DE$(oo5H_9$
zHll;Bqd|XyLBl1^KAy^L%P$Sn{>{Rgs>X)@;Mu0y>KQk6hdeDS4)tG>9Ljz)W5>jV
zrST!pGkCxjy=&iAO+KMJ<hU@?^)!j3;M1Wcc1Wd)&4Cf{XIIZ!d^nWTGO_=X+EC7;
z8GBH7U1-iTXgTsEZZYEh4+9!j1GG#+GIpf=SvFf|sa<l}{g)cNF?PdX6v4^;iPAIO
z<TwSshwknKT8|fr{R5av!;fI_{#r~=_;P#;xwaw{p)}3yUjgL*-GRS^6FUEoRy0?A
zh&7VmW?O-bdbi(>uk2hsGum<HhBVo6Bi!yN1k_blqcuRwipN1E$$a5@ho=(2L&I~x
zmKtt7fZMPR0t8Pe*os3gfmc&7Fbs~X?ndD`mG!fOPj5I&_Aw8AL>~0}A^VBGlomSi
zEkM<azD_@!U<=bD$_z=pTl|juPUedqGWOJ=MO*k@!pA5yhv(hb^R+|<zn_iAp`ef6
zV|;6G85lo9HUgeJLF?R5k2b`chk(fi@=PrJ*Mv}rB<&#RD+&8+xSs(~gM?9Mh#OK(
zFY7E4--CnZUSU)Nh;H!>k{~9dMRstJ$ev#ElKq*Nhw`y?mt@@eh!tR$sKx#RdKrc0
zB+rldDFK3+=0Az#zE$NLU5A1#1qGp!zaVpiV+Ht}rvCuYqV3**JD+S?XX)9ZsH?mC
z3V5lPgV#wm{RQnZT|I(!F|j<lz&aX6)TS^xID&rZ3;s@Y69fOe9~Jx;{v7--5d855
z{B&oj34fZn|A2)54QNM#|1-1;_hXUxpx^&b_{a2w|Ir^5{7cZ!QSs04#~JW1#d5(4
z|9iOQknrCPoj~xPWx#*Re+~Z(Bi@GM-)9^8%qvFyx({Q6O^v8N@rohCNuSk|wK?%)
zXe<t%DENtMLVZDiUj|z6iV>8F-ARBvR^^gma(R?MmmOk4@`^&3<=8D)ujmJwGD=8n
zfJbZ0Kn;+zSDcO-)?x;|QOT7c+@A7$0T|vLRbq7>QIJJS49i6*w1wRayHsL#krhHJ
zVm<!Xxy9^DaJ4$NZdS%Cea*X*@1i~Q)l(!pCM%KbtUQEfHhhdfutT203_|Bng~>KM
z3;+x?M#8^>=Aaq0uhHj5Z1s!(d`B_v@E;o}I$y3x09I5%8t5Ya>v^$`URD>?m~~c-
zxsfi9IZFw~{Eep83?EO@P%7_wL%44I2f<aZ?0Z9bH+6x5uD~oj4Eq|rtH6lxJjiv{
zFL)lL59Jc9({M1SKX5_Pl~y~fTYOTn(81k*<|y<9FWf*;p+H^f_mB#3c>f7Mfj=yx
zed4cFjI|0?dYUT@4gU%71IgGPDR377jc)PCuemwW_E0Z`S~4q1!O&)573x931lMl(
zPIlD|oJW4o3ISs_Q1JIHeW9T70Q3vJ*v9H8@;1QniC;<Z!*m6eT;M>T;Q9xD`&6s}
zTIf&hWc+z72Y=Q>?}$6j#;CRo^RLKKDgL)9`FprQ{WX)Q`~)MTl`<B=*5;MEsjtv}
zX;O6a9K_*l#&EE+lm&a;X4}??m3TYqT36y6kF>3k&yPjp3H6d>tPTglqUv9MyTcxE
z!v4)5-Dcdlcl%Iy;rmCf(U;>(;L7sl4twxheacAm`73mi@(uKI7B;cp!`6Y+3D9`{
zag;m-$@NBZ@O6*JpM_)wDWe<AK<)v36$PH6VwT3=A{F}WspxT1cqF((${*R=$>@#H
z$Gu%+H0!LSKv{w+P^>RUO=m?!CE!FLgDI?Fjxj0*o&lJe0p^L(<lh0z`;g4@Y3+Zl
zwV5#XEaYgb(M;;MYP36y<lxCj9&RMRW+Wqi2UOzq`bQ#*Uwx<b35pT{FurPxqQSF}
zOw-TFw;IXLiWIZ}7+VO&TFKI-X;D(Zf|@MZdx3)=v0f_c<m(whsNX(^A6NkSvp``8
zWGfO2hA<g6Pf0~#nECz?fbxo&KXS+fEhhs*Q4#lB+zhchCDpoBMLvd`(|qF8XJz3j
zL#fw)kjrZ*g7NkQl5%iYGy*icU@9Q$HT*2HJY>PbskQD68>Fz`PdK1Q5x_5eo)L!`
z_XIA~b5qfCGWUGtVn(x`i{^U-2_X~{D?Ir&>9+2Vc(rHp2h;aR3>PYo{J3SQOgo5I
zhtmZU$D{kL3{f}}*sP<e8cc30_%GRQg-3aaj-sxoMtuswg|L#ndQLKpHjI4C(Oy)w
zvKgXhd(?zu<vybjyEmx=rMmz*z{}zW%c(=sq0?de5|GW*4QUfZs(OWMh#gU`vk;H0
z-9AfgnvmH{)!lk-F*#|y;_ZBbI+bn}^v**3D$E9Iirm|HT?TEz#|pnVzTi+Q%0GId
z^b!@eYd%Mqwt@kIfAM#aJG;Iy>PFgiZ?T>;o^}&*CPLWiIS#n4^eIENobmdUVOq{a
z+LNA=>K5m1ApPG?@E}+N8#Zn%orLC|DEAID_jrhr;W&bXePG<DAbXFj03v6gPu@-d
zzRsraZ-KgT5|X~hoP@-96q3Vq2WZrPISj_J9!y6210d59%a=hY7{07VO!AFr$R}Pu
z#IZk6;$%`}y@y}ehIH+f#s|=e<_T9%vUX-}O2F3w?8@h*xy21nNs5;URgQLA=*aqW
zi@{m1y^l454{HR%JdO)scC}nb&=V<S|Bs$U((_WQJozK`8@S)V`M?AVj$8*zy5-TF
zp*oU|$=0)mYR8~CG?7?-3x-&W8YCEtL?gV)3i{`1rt=Y`)$a9R>keTOf4GB984Rt8
zJSxaR5SLe<mZT5nM<o5p-+PGq&jxX#5l{hep+<$@;lE)v(9;qi(Ms;H;H;%WC<VJ*
z@{$*#6vY)wSxVxofiP;C9&><D+=#M~Cn(m1t_o_W;rj*68Mf8MS(^a!t5R8{<!Ssa
zT!iV@2l63VFGB{)hM0>QjYp$Wen;1LppVj&sHmh#t^y_u&6$kvh5}U_qBRjT;I4jd
zv5>VkcHKHP+Wji>yP?(H;<9V8Au~cNBadjPtV8*myyE^jl7}fic#@uvH6BjOoHkTV
zP+(6%k$-V6HE=8%K;6hT#wv(nEam||!01S7NE=JnU+j3uUk?`=NM0`khto#pC=mYH
zU;rYpG(L8ElAcGTG6)RUSy1E_FI=a{z+?^a9M($uAT345dz)?tM%)QoDi3?6SKg)y
z-!g&RdPV+Xz!vl9D9SdwQrm$FjbKQ|6}u#D47Ll`o<kC+lQZG$OQ!kcf%X=J=KD8>
zdlai_y$qv-51VA~Bn<3gQV|&B`980|3c$p?Agur?Nuhm%n8QNp0K-@<nCHh*z)@&d
z>YApAly<Rth33<spQ&m;9<hI}t!{yb;7HQVp3B^a^O2_#S0PLor!|wY>#J-rXbTOo
zkZym0p0x;Jku7>=kw{;}h@~^GDH95}IPYGF<rsF|<r^s#=hCmNVJf6_IOnzND{YWN
zzZUUuy4`cFOv}<ZQO`b`v|RQuE&FWjED~kEL<L-1qC1bv#%Ju$knvGq?L5PJga>*&
zqMD1b-*O%V_lGolxsD0JE!Zv0-vxh-ejG(D(MvUG7_J9^VAF3I1{3YL@Oq@eUW5Vw
z7LUb=lKjqW+~=HG*tsl%zUh`^Y<=>^KQtIv+AV5FL5cA$verc9#(~qg$t-F^&cwve
zc_y%@PeKT98l9-+4O43tKm-uorQO))Lvt@Oc@gh1Q%;4IN(>t80J&D~S+2pVId4A)
z2teFTb9+QfYCQ1Vjsx4XXKC41HM&c8I|?v=m@m?#h#$x!W*t^~80CRrq?C^)EVR=_
zrNy%}_t_9*9d2>m2&q9avm6jVO`q+c^%hhcO1B`Im~<d10U0(y@x9r}`Yrw<y?Bw=
zKNj#w8K#66>@4w2ym7!6o4r27BLQn1rlvnYL@-_B4}+qcU9BX$$p5(u_7vExl~{x1
zVsAE6LtO0lard>%(Nt7*5Ac9agqV^%G<r~#6cPK61I$(>5UoRDsYV@4o=>#L$vxz<
ztwrMM{XDN>x|tA}(#W_$PPWz<Zh^q=HD76ie(`+$dveeD+KH`sIbTE|JZ0fRQcySu
zP}Z8hS&=iSG+YS0S>lJ9T}+iF;gqHQY=vtncwGC0x2#FHm4vlmKU>fJ*vIm*YOA3?
z0iZ|hKbgQu_S<Ht6u(BvH?Ru8;HMkO_fc}ON*-g>_y3WSvsH51G^6z6lzfg#e(X{s
z`LC2bh?B9+)XRUU>}%*U$j`Z0|4zVF%wV{)>9!4o?q^NK$H|x!te-I<(Q{5@R)^Pp
zhk3(%y@5U=AL6`TvL7A-oBvh(_KGiYysKGWWC$#?9exD=A0#=2B;%dSabO1om7r0t
zIOU!=axCtNJ{|NE1aYr3erFR5KiKia0Z~=;0EpgUBmG@~fR+@9w|N=5JCA7=OJ#!u
z)%uO^$w(+4Zx2uuo=;3ib$@-d?)LRu_ZW=HQkP4fiowZP3&;dsTLrGBh~{NiK-RrM
zf@>Nb=NKAHiHwJuo02(x*%&BVJtrxY41)zw=41J(JCa~(23wf?vx4tZiG0}5N&2v)
z2%nX}eZ9i<iDZvYL80iJ?(h{ENP~ib|No6rTbP0@<^GhKPkx$+u79aUS86`4z>zde
z1m@Y;u;)3^`4Sc&At`VwqPg!eD~v`3OrRXToIrH%6$u&Gt(l{HlVLp0{wwfc+;PoB
zaX%IZJ=R-8F}avxpNL?2K^)gSowv#h88V;Pa<+u5_qkif^(X&?V^-Zb+=*LDib0aI
zyj~)esf#>CV%$kUXET|O<lgSLKx$Ave?{nudb-I)xea*hMML|(2FTFoIQ=(Qfs_G|
zdLMVB<|ta(do=^h+v>;Bt~%@@as7?laYT>ll%O=E<ER6%(h)=zKAsjTCcb*kA1%z(
z{5^73pY!MOl-j+5HZL#_knlu%ir>N!2rn9#d0sRszuY%LercazC5$@tf1N@Kp(Om~
zVvG1P&M&$PAWSX??EWDBh^9eGe$6zJmr?QyoJ=yNSA4`o!@o@DIT!oyL~*P~&+IuI
zgE@getjFI1VMVX?4hA@J0+}L^(a~%C$sU67M~jjo@zW==#roiHA;>`_@<O03ZZYV6
z<{*@$_-Au(6hE+n82lyY(un{B8Oz<9aLZQ-L=Qm)?Wus)<OK_)MIuig9Oj3J1FK|{
zo4-&^wvclFjEtmQvSIWTeX&C;gh??OqE!p-)v&yFA$I?r1j!lv2yDeWs6eHITXEku
zR`<j+(t5+Hl<zicg)t6Ob6P*r|67Qy(a)J=SOm9_dGB0JRtB|!Gg0E(>%l?D@Fr7B
z@92rj`qOeIH|I<R!9dtAzaUJGi>Yu17&T$TY-{I%AhJs@+>)o^!zJheu-8x&FI?!^
zuzj~=Y4~snI@fellD$(;(L4?vc50et$La=;S^7lAvyx-@sgM`xNFYMz??OjQR^v$@
zXT@f;SKj3a-o+<5hPwS1cCmFvmpA?U7`A!XHFKuNe>`&hL-5BfZhs7m^t_SexevDR
z!sPFQ;ic7Ci$u|TP}mrC_#7}ACiM0&pXBmVj2_mL+WA_J1Ev&(a^5sq%b7|j%ioUk
zCRYGug^bx9CLz7~9ygCdiiq?=81*R#x(wHY*U&8;L`ik)IVo=OPaM5>`_JQnz^<e-
zMFV&!X{0dVTtzb$XS{UK<p4~dIYyFR;=V`YFnyhBq_7+*Z1wHW7?kjFsKC8q#p0}(
zOjZmXWn6tRzGdu(j>$^W9kqFc5U%$ZU<l;_HGDOhW0tptQ>ad`qs{?H^_i%Q;OhQ_
zU;hAxoexa82Sg{qSwUCkxJ@8^;+sd}u#F5z;0U-I>}|CH3Hd4j)GNZEUw<u1NbOt-
zcLYhnRcO%Ps*+(edW4&EQo@UnW08+O9Ccw|&Yr-<<%jKoiNK*({GRw_3wW6{{=(<@
zhtHn{=&gX5#z<%ZzuUld?`oEmNp8)2q`1Y)A1OH!7=sC&o{UZDE1xiurXohuD_&A-
zLi3~mHQ4=8%#7j(q|2*ei`gVQ4&RLGZl8ZqPXJZGa|Nov@`1lkb`!Zjx_^L`FW~Gi
z-J9sJq%l^$|8My?OssuUf?%Ze#{M_(jkR_bsoZR>F%qYJtHarJ0e%wonqDA?<X&kg
zV8)do7{5`Wy^r-g`76kS0)GYUlPPE_7sC1ybhIC#*fSjnBRwCEktYdZ<dj0k<c<O?
zS{dr4Km$X65lzo@DB;}w5&1`CV3au?wZC!n{%A=Cf7>tX&xmE}yFZ?fU}8pn3HDdm
zog4U8&$?Pp8|mLdj2vf2lQkH9t`rSxOc#8oDf-I0ArZB><{ZZf^yOaqiCS`EOnu&S
z{+0be%gn>5;Vr$e)b6hb+Qg%$r`Xoc2kw9+k`!NYb{evW9YppDWEZbpOt=-3YmOmy
z^7_+?vatlEN*=Mi7-y?gfeTPz?FzH4#%NntQ(I##ZFSvaX^ZQ)#aJ{|tPiBlJmNDH
z&<EG3#;{WT12;ATfUTp(K0D0>>^Y;cPG7cdE!A<0&x-ol7%Ys77PYi6`8~>!|6zDw
z?3K3i#<cKvkRl6fyrrk1)h@!uy=c`kg33vdT`E6|dc6_(R;ViJ{EfHtRMfAcd=K)8
z+~{_8D?QWBLLrgQAedF#Q4%rkCE@2zMd;j;zUGh0<GRK|a$}|8KqOo{sahe~WGz%V
zAC<4C%6varAM+ob@4!WR`8r?@?Tq$#{WY`5h4>tBgAJ9%UQ8qBx`kMX^ZNW9g`-1=
z`VY<aex>J*MPp~7u{3V%3QJ?TW3e8jmU72ho9Vs2Q|;-wW6;*X0*(}2fQp2>+)<R~
zML?ljcvM<Xe3o}4@jRpC#gHck(L5eHh6d)wz!Vvz5Htxy67<iY<Z6^dSC*Q7u30Ks
z!7X-Uwa}bE6mG5NMIqT$u}54e`>LV7i00kmNv=fSt(8u(R<ax2)N+lRxCVW<*66q!
zqfji>g70e|Ljiz`!JdOXG5`ERn#4~FX%Yc3<>Gt@H$~s+pB$WO;~{F#K+$qQ(44SX
zl@n<**bLehp0W>~n5cXw{8AZo8Mm!b5Wb$E-)zQ1KGFQGZ9xJp(F+N(OYolBAiwR9
zRN+u?e}0O=XilJF^iL}x`W=Z9U=J48#Fqm}U}HlLS*;*#%IZV~&LY=5vd|yFL+!v5
zks(_wMLRHFlHL9QzFDO|7X$*LZVmrr6RH$Ir8c&${K?~~r}5yL3S&r<Fr?$7L-L4S
zPpT17!Ji+IpT<MBhetdpYqD72{dAufj?{NE>Y>$!fC>%os+{CxZK$>w`ihMa|9vL#
zUNpnNM?RLE8NF{6_>n5bkx{>`QD320{u|miqxE=yAM+OG=|fn1_-KulPt1=4YYD^K
z@a!1{S3}Lh`%@nn5BL-z<yM3KU9et&_$2pQD()7)0{>$JQEOC%euY99M<l-dEj+5l
zLp}ok4_qPpyG-^sRrZ%{_P0~x{`|yavP-Jr7O(MW%r0L;IqI^%#ERK*to&k)b+qwa
zCHphRH=jG3*`u?Ws<WRRALEBqDs4jX>^Lhl{tC1@E0*D_IaE=_`Vc74hcjLY!(Ndw
z3#X;^!HWTj)>t5Ra4FbAK^IDjs}Lmvj>t5dSsQJ}Iz<sLV!|2?krI-PMB*~`9CdzJ
zs(}Df7<L$!L=M6J3u{zdHG0*D6J%a-j_Q_FRub2v`-=lH-JW2;9&qUKkxc~u6BM>n
zAAG@t|D(H1H1J$YG@OH$ENFO(O92gdnwFM1@!@On(UYI`;Y?q90!}bBrag%?@Qz@T
z1%5@c*G7A_QrXJ|R;(2neFhR>UP|~W{z}1bU?NR56^n_|n5L4ArkoWw0`ABQz4-(7
zHFoL9Y@urxCP7SGjF~t^&mw&}q`-^w^CzH9DKGjN1~iUn1mUS5xe=!LOv5Z((3Me-
zG{a0Z<TugxFQw0^tK`JMLS{C?^trtrajyr~UzGJP;6g;6c{IISzGd`~f>wx*Q?00Q
ze6~9gFM>v-dIFJp#21y4n}3czvEl<>Zep?wTnmc{sJU7(UEmV4(-7JtV`?z*6^f})
z2<)#Gh_x^|A-oiLH>0GKuOm>sbb!d2$2fk1YGR_FQ}SgiPB6m2v#f`dJwp^Jxt&>D
zayx7|$?XP1%`;*9x&qqRF%tey1S3{J-N_l93!REW*kLV9rOhCMo`_jWLIPZ{)J-#6
zdKE26*iV$Ouew6Q&P-4r)Uk+TsQv3rg%XD&5F|M3lsbvtw-y~wFZ@cP2~0A39*v&$
ze6nwOJ{5XB1-K3?N9qQJ-qa|F1UJz8pAre8Y%{n{(W?PzEPhi;Q>`ePVr;`ZfIDo%
z6AJN>EI+W-3WK9ju7^P(z$YY<6ebUULxC1JDZ=Og6)B9s;1pj!M3?LkO4?)mmF!;t
zwINOhG9)k%O>!*7Kw4&J)GG#*ff}7AYK|`lY6{_9OV)EnQhWk@_-<t_`esI{z6n%+
z;7+D`aC<H9!w<sVVltMkz+*T0l0bfc#J$XLN+r8}ULnBV1ZE|`RQ$~R5FB7?Kf^-)
z!USj~_ku(1(5PNzB8M)E0z&L}J&I_pXq(YP<3sx-kH|0rc-H_83yh}o(6nJ$o`H(w
zavN9!O7)08<n!c$DKE<$3VwWxHYpS(3^4joh(iv@Vb@$q4pbk*eG*lWueFls!USgQ
z$#gq{uSV*qv^6XvFbcV_nJ97y>;gHD@34A&YJeTHxm|1--Ue~&Z?(`r0!9fixT5AE
zE5`m6-$S~iD}ViLIJC#i!JiuXlX4yY96}pnAJ4%sf66r~#Xsl=ByYmO2!H2qkydLI
zl^MG@$R8&td&_%z{>zoZjw+BA6RN00^M<{x{1c=Q;GrZ*7Y%Gc7-lyxKw(mO`VbIj
z7D9sccs&bivEyeLb1)Y6^&&tQf&RwVq4*kWf=AsWoS#KSKj4Pk-9vyMY-*7hqu@z+
z2@(H)5p*{Ky8y|2J)T@NS+p!14|`J-Ks(*Sf)#+?GOfVp-(_@XI%v>l79s}>UyP)H
z9hfO>c2R#hV|fgqgLTchba6;`WG8%MwP-13_gkOhKyh?^Yys_n`Sc5X%r9sVduATd
z-NB4vv~dqSk-zH!4eE!_LI)OkW5&Cdf##hR%Q0>s_;x*yMmfBIB4b{jrpO8@BVZH6
z4yB(WI<AllXcXypFFOW1bVbsMP#_kg5#ZLa&Avu1f&_R(&Wa}p+X$N@ZWw^(NsHrE
zYsA$Y_amW!<FKU5t9TBEUf9unJmHR9#(}r#imDEA50o%(NWFo}QuUc*J)+H63plkr
zj2fU7F<OcGeB!J7d4}PAg&!ErBo~mcxhRTMuXsK}N9zb_15h3E2OhDG9w?Rhd^F!Y
zAD6tg9-K{%+A>AN3rJyNQ3KpME6A5YxF*4_PoD*g?M%StAO910Dsv?~`jENg9+-u-
zp~7|eoqcgO&~s`E3TZ)FU!pSYJQ@YkFdR(zsNVQu9>#fPa2dlTan24MG`I*AVj7G*
zkJS5OQn6`9y+wYHoGmdq0Dxr;GCGjaj00r&XF|u1om%ZxmajhXF;J@yCM;=<v#~nd
z5f}$)djoME1$$0Npsc`2{^Y}QW$6>Os6l5Z#=|{^5g3YyNdx1)9C$&T2CcE-7a^(T
z6~nP3!GjGx;iqBJynDp~oHIshWYfYL|3j!HsllU~->q^VMVqpf_vjEAy9_HAfDHV5
zqjiR>I#0<uVLwp`JE~0oB*qI_7KD|A0A6+@p9j@)E?mh;3v2X~G3XKSvF9e?aKm4>
z8b0>VFuFQB@W8gLVbrSibYJa_?b)6K?OpLR?Y%x8$c_9X)_?AUK_u5f!Q%i0EEJ19
ztq%pf;ShFWD7fuAn(D~$AYHH6EHCX~{!5QK;`Vub{xJ)%q!p)4W)V_e_FZ@IUy(m6
z{ew$CzH|Gt0fyDBfkbnHd*V~ct1=nS>Z}+DG!ZXRB&t-%*!!tC0LZi-YNCLo7Lcg^
z!ljgiv$7op81Vik;MhSM&Keo4x=-dC8vlaZ$WcX^bfMQ%XlJgn<6YREIs>^<m{Xw9
zGpMTHrTh|f{Tj?6%>EK7#k@X$1;!gCRn+qpbr+E99@3Hav0R;E%a=-&osW2Q*_K;4
zjb+d+SJS#o8NV79j8s>37`%sUH0kw+|0D9Pn=$M27o$_9lTcj6o<;64vPrC|Y-wB5
zB>_JFI@Bt)QIu)J?`TwP@)veyL1=372St42iqpalPXWe3_8X)1rcVvgc|DlIqHj$9
zR$vB8BS`#nnwi~?;^-o2fTp)KMm=0);fhfJioxC12zG5DI_gA8L-!UY&n^auCFvl*
z1}O`kXhA-@tnjCFgZN)I7LL*NfVn?{WhrmQELZ-xz=>oNQoLr&E8SCJJfZWkXwFK+
zb7m{?F%=yfjyiPwntugK`p5*o9%m8sazZKanWFJGQ}_ATp<Jmg@^3%MVmb<H6BAJb
zMI*aS`^|(Gj&uM9aw|&(mre$-S(uuMQ0C)x_CB8sTGPtNyG|o8Rm&e>7Gu(2mrlg`
zlt7{4!FLwY{t*iRsNx>?k<tE9On=4bZx;G<qrVx5amQC@5jrHk8$5vpo6i33BSDc8
zh2j;rf?^awVTA$qxf(CaRGJ^PQ3lQ2+G7Ubput%590KJWi+ntV<Sog^NsUo?i%}X}
zLzqa3uD?j2$%8XTS%qQf6lviTi?(x%u=aojN-7ewjU*WBxK6lOn^UaCn{tN2lTgl(
zGj9cHWl^Ne`CsE1R(;%JP%PX9h|fnRMuf>d(F+SFKglB^2&HERFrX)U^*`*4xWLkE
zAg0+*@lvU!+20z?2A|2O57SwHKSC^6ErR5>tp<QwdExLrvZA4V`~~v?_9_92*3|P=
z6i>7RSj&FUTKY{ps#1)r@=v5eOH-Ik;ad6@lh5l<atV29H)v$0cUak_dhRgYJ5n2a
zC+z59pgY6?Xg3dyE=DoX=G-(yuGvb@HYYB3B<6i4nn4qHY*K2(alDqB=5~i1|3+yW
z=wKvd#of{yp;3+C@8LaZ$Ewcb&j1n-p#L=GG6Eni;R;5kKMh%^Xl8}Uy=A^XhLv{h
z6Id2aMmhgA_=EdOXsxv3Pe$UcoXF?Xx1{;!|ItXli_=F^;jB6%aSbOr*$zqbyT8C~
zHQe&UoPGd{Er0FnM&ZA3;>U6Y=5Kk~NMFb4Z&Kl`SB=C*PJCGvPT6Rrzs2bfQ{nn&
zjl>pCtWt&NN7Hw6`eG_vs~LscIdQHkY+G%lhdDi$3*TcTc5vdaRN=IMk^U{GpFo9I
zyksPHaiU!nt{q@t!)7Nuhrtp4`k;}R#EHB3#7UYZ{WwnF7+ZJ<C;p{Z;nO(%p4h?}
zoOoNW!WVM-m9d4hI5A%qRxUN^Z_xAMX(3^XRX`e<<0y&!e8YmK&C@&`8&+&qB7X+*
zRc1+eR5T~LKVs?wUV7->VTj3`p!7xNdu7lCBlQ_IKkC^dGdq|4Kg!+*zRJ4%|KDKX
zz~PxXbsFhRR5UVXSj=IKjr|dwp6##=|4gm;=t(g#&k;1h;m$#BZilnP%+xTg^pkzE
zk~EV9A%|&+NQQ!mih181tfhu%6u;-|y6^jJ4ElUOKOVYs-}n39^}ep_eZ8;u^}gQM
z`(&1_a?5J**8JV37V=MbR3`mmUmZ@f15V3S^Nz|+>)q|tl}GaCKg^#_pAKU+vyx7o
zjCXx>Y#+(nU2z;^r^EZ=uOs1G*3iASr2F5a(ytGa!W_wy2<<7lmN~>N%8sLyL)7RU
zwv+U-ec!?N@%9~P!WH9xfCqnO^~EfxvCLLIf*uys1ZJO(|5d6U->Xy&PFbmHh4uYx
z_pULi%I;mosR`Y?4oICCRvQ?@M#M5JRYRjxpRaPlazrZW^yMB#pSMphn@d0H$&bg|
zmLs{IcITGlihA8^%b6>F$@#0{>Gvd`8^#k~nnOnt>#I}S^y#AVcCYCBECLDW`X}%4
zO?W=lOX1RDH@Aj^WeBNT?LcShi0TC;sYC2jEPFi?$UdiiG1QIg0FgRJ?yM=SNFNi?
z3$M|p5=<Axt=?;hbE@?xQ4l*!e>}MY-WsgKkQ$ZC%kO}{oab?pI(R_U4Dr)_9cN&D
z_dI;5V_A9m+MEZPg0*hf<ax2o@AY}^MDTEGuXMAE$P7%e<xiow-?n=4Q>n75XH%Ei
zsi3=l6*5V>!{uyC`gtb3cB*IgJGY|6``1_P#2E-VszuwGEiB=u7Q<Y#uCoMNeBuBG
zI=)7^nZ*fjdQ@ZTcm5f|SX(hniLKIINL2m_qy`K6<48+x1|POzzwV|`&-4#enKQ=$
zYW8zH`X7QsP9~i=45s$p;e?-2GL|_?iCakwC!QhtrSr7&V#t$PGK91$m8BIN*i`z#
z=3}2$40L1M@O&H-7B*2kZC4oeJ#{!+pNV3*xy8LJA_&q)Ti#${*)}i0)1K5<;fNxF
zBlX$JGmb^=ko0s&vC(bNbopJ7g}axFP0_1}s!BOhn7~kj8Fsw`qJ&sxwy?n(HXU9w
z1Q$gNWBMXu0H*!s;PrpVKX?NcJ1@dUs~3JA$#*(){b$|Q@m04!0(+!BXVm{SQNG=}
z@y=p>yVyNze2e$7fPBv4$N1zdeuBR=D8nf#D&r4+TBfAomQ=O=YoF#*&)J2u3ZLQl
z4Ye|%htoaXJx2<$)$ZJG71oV+6XRVg+fukeqXg^MW&e(G7+X#8q3|g|bi3Z5^wULn
zrsUgCPJjzg?AyKDvY~O^zX%NNWnX9g!*IB54IMrt^Gy06yZ`k4jYgnn)@o0C@AY_y
zuRppic-ec-?|W+hr5M~L$kcqp?wRAk;XB<Q6~!`NU>&?@VR7lQ)&j(o7R7B|UKotp
zS-^D;87-MHLk&~v#Tu)&URK6oT<Zg5<#NJ56Q{HEK}g~0Iz%4J{K|@@rUcR34&zWz
zx8iya=d-o!s5<k`JJM~e0KJE(#+rEbjn9FtSf)rmiV|?+@gM)CMQ+k+MIvy<oz{P|
z9-N(reu65bispXd{6=wsv()IcRQLz7gK5Zl1(go9cLjru3b@>x+@LtC(TCe^@(HNI
z3YK`3Se9Ii799m>`=zopdwq*kxBl5?;vkI0GB1)vSj+sDhhVkblANL8o<9)k|3uZ)
z6jwJC6X$~GNU~q~7%sHujCVV@v4SJlp0_(NC1IbR0bfM5-LrRXUsP=aM2ltOd@v9i
zd58+l+q=*NlGqv&+5PoAM@Y<G&WmjtyXQ)3WuB&&3GOT7zK<4U##rK|O|s>dg!ISB
z9FTW3q6ls}6)+>3efLpGHx`aN;&cju>$zOM;FaHzr(G;_vnmkDh%CDwlKD-fE2a+%
zi%SNVo5A-G<kSqrO~ZJqkGqS+IjkSA3>H4PV3Ok0jrWUGkK0&`14FB~^D|KgvR?q+
zu%j)ky9LTHe+(Z(+~n?4Z>}BR?yU**4=NL{JVIvwL8$W|^aowtQOY4%nP~7&<Cr%O
zGU~-Lj{>55Qz*fM0VZ3NY*OziDLCHt29Ii5$Ku+5At(O+$ey1*(mfy;cG>|i(c$b^
zW*hk>&pal#ukiU`w_Vo-jPAa^h%whm1I*-@t1-N^dWU^0A^}5r7bPihAmgInbJ3F7
z9Ax<1Bo;?LJ2%+~x@m9G8FqW0hBi<La-bX-<PY5*HAKgCP$oj_vQR&@R`_0E=jD41
zyyR|Jb%<KwzbZyK$2d}<dlO<uj<~eCGsh;p<4=tUn$d6yx;~Pw7p2an%6@D*@L*#+
z?tN!@2#{Y0k$aOB!&_x4;eMSifXhQ;yL{2iwCMUkI%YM;(>0hiFopzyJ^T&=N0H}1
zNzm-=w4Zwgj^*k<Sk0}BAj|5O!mtN+a_#_M3c-KiALoy5@B8!<7ygZ@x~h-ZCA@w{
zA?$p9dG+l|NS$4MyC{cvt<`zY;m%CiT1WE6nwJm)+{d-e<{al0l=D?lXQ;q=CHGF)
ztaFd*$UWiQqdIdB<?SV6H=A%_TLKjPzI)d}sRrhZ+HP;Srjskw!>JYY@T9i_j1plX
zHBq{EZQS|DLCp4hpVy5ZghFxpQtg_2@V;Qy9UK!y9FC@tY=R6-gyI`-3GP46E)0ed
z$l+#!cu~e3=Ur9fA57)FZek+%IUMrR`lNU(Mh?uYzkuDDY*~EpmE#uN7Lcmw2u>Y&
zU-^<HI*sGZ{LV!1EqsM?8v&)mom0}z-P$b)@r?JAi<GlMIX@4jY@B7K{F?3)%bcW-
zl(Jm{1AReIBH-n4f7s^ZDO%q=;WR%c0kB7-T{dTayXRfVv5t3ma=SzVw}Yq@&*=nm
zN0Zw)%OOlu+d57K>*#C!X1l_L0N@&BEb2Dt$0brw+H)FbNq}^yB0gxUElf=d=Kk2?
z)0j!8b2E}s?O3kBc!a_T?So^P|5i1em~PuJHM`Mi-UJu5aY>BF+3eg3+qsWrS}BX(
zDl>v9j;B7HS6xr0cB_^Rz*y!b&gIx0C7iC&Bkj$d<#f!FX#K9Z&FPq-bGw9`vrtid
zDL~EY*u(C$MT~GPSJh2IM{1Pw6cl<3K`RWXq8Z&c2xZ?S)f#1a6U!<lHpd1#H@CNP
z@8Jo5hcGNfbRRQQ%lhmyZjEGc>Wc&y1U*%?WvO<8Kd5B6=n2N!Hd~(cL?3Rd?!c*d
z(}Jg1C=q$PIzDc}qq+O?B75x4f}+$Bp>aNuoCE8I#(D8v{pRY%u?xnuUcQHA#ohe|
z2&ZBQh~z*~`T$WoW<;!QJ%CGtOEKJ9!{A%$nzBKDM&G3B5mPWJ#WJ5L%41d`H1hy4
zhZM!K7lx#VY#{hiVcLyP8o;r9Jf4Vm?0Jzh*8p1eEyM2tVD~0uzFYsCV`ZGi84MWO
z_HRRynV$CB0M(Hg%sjJi<GLL|WBDerq*2#XB)lux38yXLIim?vH%|xb>3>nP?VwqZ
z9{fpVVHCUbO6CA?@D$U!v+MFg?@MOBVNJV1*jlcNIRDD@2TrTnyfCW0n0o?)KIV3A
zXx9~(2d*_4DB00C%ikkD3LA}O&VuwpT}CH}z|MM9kU(2Xz7J6c>1)SE8Eo^=om1SN
z++8%7?EZ~G&k{id5VvW3OY#zO3<LqO2`p#?KNoFJCnt^As}W5|b}wu!V?st9351M$
z{&;lmWj_JQef8VG5}d!yJ%(j)Q7>oV(#QDs@lEmu8YH~SjtC^2S)$F+s_txX@+QFo
zSov85ld@0Rv}6awp6%YXC)EgO+d&!wUomh9X2Np$_ZORJr|h9@huN^NekdIF>BFpq
z;^owXYVQ-5TVBqH*EpQ(Z!8AHs`&WWvJVAr%>=urMs3U~&V4hYK`LO~PB9edpJ_{r
z2PjavGZ#~T+zXi0VwoO3X(CDgEs*JoLzS0A5Bw+uDfI%|Dl(k8Oex;2`On&!(#bmn
z@GkVoBt|uhOA2S^?ukH&Wv0N9#txt1A?}_g8o9OO<H_+5l2d2eDW-^DMl!NC`v((B
zcIFs!KytOnElpzmT(Mk*ztYk-;NB!Uir+N^*CQ7Gd_f@;v}16!<NQW7r<9~@kA~$x
z1ZV$1e6u9P#U?-JmNTn&c%x7f5llehTs*6)KbF}+e-Kkne4PI}j~FNN{!|^_voF~Q
zWC8IT22jw9?4IIb@2gQWu`I(x;#8PYXEwqA)|r1^8+7I-YHn{&TG8_{i+pCF=n@r`
zoP7e>p?OUci@-kL$oT`_Am@Q0DJ8f6BPm~faKEH{I{$eHDeop^WP`}~y-=SCCYA)#
ziTA}tg1prK9eM)L;Cy8S1^DF6dym~kM$q)fMFaOV?FWho$ra!LvWG!%B)U6h_%~47
ze%9Nw6)&mNVy1Bo2ffD?E|xi7k8-}myu+h7`B1TXBB|63N)1n-aGX<bCYs#2Ga>wF
z%y6aQ^@@$t+>Wz}dg$J?4eW9Ao!c<YJ-5keyThqp;U4aGKdjHq_d9J5x#uv+lsFBO
z-ENVAKvYh{l)js`@vMJN^IceM8fRiw)qZo_d-f{BxKn?#p!^m<aJD~i#!e<j!Y7LJ
z3{$_CiogS>1K<(WJXodN9QQVSKREc>_ORQ0hto05t-s%Gd%!vOY^Slw`PMd?vkU)L
zxNUbi2RRMXoc5+@8f4sFf-sEsVndWisRV#=nr}n-T<+H2W+4M^jz(>Srhi-QcVTXI
zK!7|hS2#EXo>}6wPjlODbDDddj<cy@v<!~H_8gzxVSwQdqvy+{idSywb(?Qf5P~w`
zZ({jy2(I0=vP=wfMlv+&oQs+yLfqzF?-MAEfCDzF%5PX7_!M7TklaK!BAh*Wjd5Vq
zjd*MF9AR{@Z;}{PYv^Pb<#L2bO5RVFp=+Nzm1FZDYW!DFb6;Z+Hr^pU(V8qiU_Z4h
z1OldeQCB`mg9YbRKL|$~N889n<JvxP>wC@c*)ov&g6e4N<qA)CdO5h%AUBaLWM;dC
z`>Eq(?ZJMWJ}#H;k(SlVrJHqbQ;<LP6|?ky*&s<>I2a25`_Y(h9|VDHlh5Z<rgZ-^
zmVOWlaFgF8^|HB_(>@(u=huYc3jaDru(eOi@dSfEl`z!%M*unBa(@ZsLw<b&r=ULs
zt8)wa<hh+PwV#KPsI7b9g~L+kvYH}d0-9hyF><&epqFh@_hVxJEou3UN;BziaXv&{
z^2**9H{jx;lfgLu4Y?_AInE6c8%R{@UesdeLp}x3sQgX1q77azOb~ps9&qAXI*+0@
zVSsyAsBYUN>G8H<JC=D(zi9q%D5?DtCH+y4_n1Ek66YDcMT(ZBN^vavaS5A?XUaQq
zvs*_jx~*(*Yuc`BLZ5K!rpaJYH$~_%HQZK%o7kmx7n`W5o9qTw&^m(ECEUe<EV=j!
z%oNyZ<)pZm`YwGO#h7jE`faKNvt%9OVY^e;#LCU7o1$ao)EPmkEr{aum%IPHCw1;Q
zsZ%1%nLfXPEv;TyV9=J=z%2{SbLf}i1Z`r2AY3*&yTbDRRd_dtLnf*+-k$sml?@qi
zxok^o^5uQMo1tvK_IZn!r}MaYPAiyfa2|IH2ZgRNC&^WklM15uS-_uM4ET293(^d}
zBx2cBD0sn`j?4m)XO3Ch6^b;k_WbmF(YSd?d(WEFF^70}=07iYJ7zkBSRCfILe*`;
zaocv3f49cS3(Z?6yERjSdz^#CZBD$RrUHA?;O1(hdSjUcogv1YHF*v`1t$(9O%`Ka
zG)XgEnI03ykcz)PFw^~WC_|$9i>m}0Oi~MfY-8sR_NawDJR&ZH6CCjogGsH{LL`PW
zn4dH}pv1;9Pcr(N*bk}PvSjUE+*FjF4NTbs1&FrPc$BvNpId}2X^vGx?G%45wL-RH
z$QEv-`qTM@JpT!whVYJm8WqPA$#o>{BkJdoMopK90R~($xvTCY1Xw@<xdetJ=;U!Q
z37%Y$m)EvpA>@Ooj-AQ7e;`Tjy7|6;oRP$06>7b;A9((6{ddnP!5HD}3dd74nvVS&
z_LoSWj%9zUZJWdGMX-)7PG#4RWuDNIHMr=B9ZH6PmhRt?4z#!kT2wWZ#Ci@Hu2*7C
z@H#fuv&3Gt2*7A834{p7x(frF-OFicavSFKEmj8ovu)!+w?bvxRbIAF3@toXx0l40
zy`dJ{**)dlc(GH`i;cC$Ij7hm(hM6waT!XFcNd2y*^g;`e>l|jNAE*jUDjL2CNL(|
z+iAQhmc5f7x30Kr@|;)}&zA!C>ysp@yLn_-%4;C*jpQ;*%^RyzSDEVjm0%U~rNP8~
z<DMwbS#F|SiVVz2T_EvMaqYR%>vE&rL)5YF3t7`k(tmerORF2>X`dOYwcY#cR#Wx^
zO*@-_5p0?&W}4E1v3aXE`yH60eJsFKw~vqAV)H=r_7Jn@jIVC%PoI=K{Xbe1KaP1_
zWjp&*hdHm9EmC%d^zTDEqJ+P*_<f<l2n6)mj|qCb6dOvM+eI`s@G6?Xyn5E7wDvN0
z+Ks!NhGMex72QY{M93Uw-)p^B&sX}q%4gW8*|_jC)1CHt>i$c{B3;TT=Yob5dE8}s
z?<vBwwxFPJy;~f(Um-wFTFY&#>zy?;xa<Lygyi!k6+VxtYu==V2fK?^u-hvl%5LGy
zFh?{u*!q(#Oqy`x<FXsg?}7L(8w>|v5pc#<wU3{VeKoesf&>P+orZD?-@$y<(ShR7
zhhYPnhy##8PcYQ|S;!C7&q<q^<#r|GQ&?FnM>^;Kj#MZYPfi)d_$IWdHlwcoiZWD4
z``jvWLhofv{*=iBjI&ZhY3Qm%L|WK=kh4-lnW(XoMJZ~QT$Ri-DRN3e5B<B=tL<gP
za1sjruSP&rFbw=_B~{oKubo)q)K2uKohQP~M@<ktiWy$j?ek*G&M<n;bI+L<V0Ef<
z&b+>&Ue(vvzzTvw?7A;x<Gn`ZmMS~cm^r2DmDn;Z6hY9k77bQy&QGg+ruy{sSih2N
z(R^4Wy|bWt%F<Y7ET5-Vy`0WDQ<fTNO<Wt#Hx}(v0CI}IQzj!^y&6i9LIs0;^a5P`
zg>-`A$~TLXrMPJkd&4}mK*n~`pkJ~83ZQBdujMkswO#lJbUomDYRw?Wu&L8RTmuSI
z)&<1)ts%Tm+@0Qpbx>Q#l!91vi`YNveKW9X5Y+SQo;SrW0L7}dVg8_MjX4KV(cVQ!
zS-=2Zgxm-CZ;{4HRLFIHQ{iT}yv`|i&!1BDaxD9%Yy}c|)BLB&)Z5okE`0iO2@|TO
zTF~<dRY6yRj<6vaxXJ~jp(oZ2dEo1Wp@`^zK46)?hWSGgo(Eg^CBlEg`B46QourUU
z{7=G*8UfxFO;`_}5#HM8`LzM_?yvA@Sv~^3cFzzki8d6`@~^DfE1&Uq16?#<N%@zI
zWqRo>bsJ{L1r}1s$xqTdDUx7O=hIw0c0e!=xJ5IBv}hJS7Ch<#Gje=`T%qTMEgqUo
z&VM41^9r|~SKB_iBbvms8W-j$k=%M9=m;H=BYT4^U+JF#g$}CsyG<2Xk61VKdrL5S
z5K|4DAR{ecm-akP4McMQYH1!+snUfy`5Jh52Z1t*OTvkbRY(wJAWYx$IyjV5n|l^|
z-MJB{sbgC?SL=OYb0DI?%0(s)`dJq^rG5)9K|dbZw;%pzl-ip7Hc9*FL%RJ>niXlG
zW)%YBch3@T*s*gPo8tI4;WQwYGn!--;fORi?{tvU(bS6Bk19+|PN$%jgj(!^Jggl}
z$V_gM(K4->=)6?pzeEMFm+DT=p=55|KI=pH1Bb7+Qg&}y7M=zDrPE*KF5V^{S)HoK
zFRF;cKi)|<8)$qw!M#U`j%BfiosX<(?++LY980A2h!&FnbpB?D5s-zlsD%-&{H`yH
zr^+Uf9wH~VJ>uVq;@<^?8vuX@+(G7EDc5*k3`@1Sw{KH@1`N6cA4i49rXn`R_&O|>
zy$sfsU9i+WtHSxnuG~4nY#UpHvV$PLw0Cf&0gpLto9X(AR7LDdt|>qliYLoULk2@~
zg=W)W*)*h~RqPK)=Qkh+H59RLEb}GEC@?eU@nCLC$(j3B?pKp)^R+zm=;zOchFzHU
zCo-8><h1j7h^m#@nVzpEliSebEM$4K$%btlERC5vosD)bR9sCvLrQEwu8D8jXE+~n
zwNHU}^HyUh%pQj&H;oD1M*6-;F6b=#HTQBh<jq`p{M@{sF3b~Chop&RW<~wJfCmQU
z)@aBMVAQWslIl#(qv@gRkWY~6c8u3dlK||f>ag#}59-O~TvOydwI%FHEZa!Q<b?+@
z>)ZWra`+)a@mN%+-q46!$}<vfIQIC&|DlDKIhAl%=s5HdMWe$cweZtAh#(lHKkXa_
zRjw7G>J)pJ*Yx?IJK-Haf0$j)`09^_p$`S3kHv-PCvE(oxsO7xU7}Z_oRK=xts{>9
zSpLGABb|6TpPd(T&&tarQ9cznvgRGRRbcgfIyqD*<$5Ai#WI?$jQjo&Oj{-3+5Nce
z$fyd@e!wqD8z}OlsL1ztKsXh*CTsRX9c_oX4KocX%*JfCx^WD;+ftYJ)o-U?(S03l
z+iO|1gX=MK8|W+DoOJL$Y<Yml5wPXU#+LthIbzF$jV(<wPQ2LI(ny&8ff{G4kf@5R
z+u}`rD*$2XMa<76$RO;iD-&?@6MhefWpGSo92Lhhck*CmcUal&ltt7bJ<i3k3hB||
zdBN^$?)IR%Q3KV*GIe6gNdELmXgr0)7#~kgjP1k0xgQ1<tY4gmCzzq53SyaSsLtr4
zSW`hov-hpYKU=M;zXLE!;Bi#S`w@Bro%LlVWg1xxLku2B0e`}dLI`I^H^#D;f+$~q
zY<$C5ZT)@+ugRM=V*ZIDH2`1W3x@PEUoaDm59|lNhcxtqfkdeLp+oh0p?)xRkJy|a
zs-LE0FjSA^3Hh8CAi4;^P;)L1u=+OI9m?wdXO!kPg8v8h$Jqzd8K&-uLy#hTt=_Aj
zhw)~OmGHo_w@Bm4?m`%}0opI!6Dkbib~D`mpIZ1?)WU;2&>gifm{5XgnHmR=t=5~N
zsav$X$)iX20vp8N3(#W_pP`YB;uwu=#aP4=xWE2iK@#hOXg;3L<`4E-*}Z-Mxuip0
zEJ`XaOmN3F{HDh<gRgG9*fh$>;wg<1*>{do=gxE+G0EQHHe#o{pRFDTi~LB`9BuYA
zOm>#fhn=+v)G>u)Qx3Z+jgz%M)RuAUE_B<QoJMSVH@ofpy)E2o;wW%|>zYLv)BQ9}
z2SZx^rDUn?Bki?))G&n|B%O5+jcs?eDaPl`c!<^aYDm~Fj(R;x^GP*ZE9S(_-8h>O
zQ;gpZ@0YCML!+j`3IDfiyF{VBrA?Un2OMB!$Et0Gb`1{Ko(%BU-_Hh-!`2u5%37D{
zV<T3OJKXxaoQ}zKGt#7j{q)x4V`_7Nd=oV6Z5tOByMwero49h*f+We=5txSnCOyji
zNJFizh(qy`!cKh`=YN+H|Fgb}R8jB}gzZr5eNx}ry4=y)8JTG$E@i{1uYQRtVP88p
zF4BL3Jr=3g{Ws@V0$)`5V5?i+fq{q1k5$x+O{q6AG~Hvbs3n2#%iuM|52Bh<EFA;=
z9WBheCI5K|R{9R_hG2=H8d5?{+Y+aK3HtkGyr|b)tCrk$i0RQC-Y{19A=yx;`)=As
z^ZLitr(6d1Sb}Zr*y+5sJtRK();1-90ozdn4GT}l-x&WJKGhOU^$sY9uaWlC;uUcI
zFz4_(w|NQsX{{~PbiC<-!Z4d@&jOeRhk>*t?#+DCC==ZGQr{);bvu$Jcg4N0EDEB!
z{xtZ8Quevq><hG0-f#0Ap4M(2^N+|L>`PD9qtJWEwQcUV)&W0_j^0_Tarm%E$W2Kb
zovci@(dT|L(QLw7eodf{G~b6la<{UGIT!|Ssxhl{?vI$OryYtMZ0-X4Ends5!S<+B
z5xbOcKf20Wk*;D_e5!}cjo!Bc(*x7-&)q~BP(DOw3Yo$WaGT25)V$jbTnyd-YJ$&c
z^BSbbTfBotMb3wrEu;w>I$R6uv_R&#_tm8l2WHy&9$>*Au1ACN51@z>Y?6w}j7kiQ
zt$zr6ZNd04M}dv)MkW7biP=uZKiie49gP1VA><{0H0eyfU4a_q5;FHOvD`q-kEnuB
zI>j<uB=;p7GcWKI-mlY=EThbzsYU0}T0=l*4geZ-2-5hPC&S(I&d0c8v9DevF353i
zAQ+GuFBdzJ3HGq=1rHw-yX9?x!mWZAW*@83_Iofw`}rD-&_64EV1(-2zpeOVndf+n
zMkxM-UQtwaEc4SK$yV8F)nAe)!c}12M(Q8d8!|<(3q*}*q@JS;SOAT>6Av)z`p1h(
zZe1CUdgixqE(m}%YPdmaOqgXDS)%i}oR@6lW@#OVXQLc$`V3|Sc~Z%HzsLg0Os#O1
zt^hsGjd$_4r*<Bj6+x_TlKu5xEY!NR7v2unrTV&YhWwAC`Ox++wZ9teUt(Wjlk!s<
zSHb?}Cqjla#|WlN{kk1VEd^qF{I1Pb3@N#mMe}xQRM+H!*pfPZy2!RKgN;kJESVkI
zvShB@VH=nIwyn8M>n}DOZ+ck0(GKGy_F%h~b^soG?m2R<-mL90_9xksWdDghN%kk%
zrDOxD-}Wcjw`4nLvxfQV)Y&F`2u}UZl}5YZ%r7)60KD|Id1y!QI&YyQ#-77;?**l)
z1EWi1<+wXDq98fD40^R~U=+1`H?wcu*I>K)WVZ9v<}=HtCMbUdln>hX955BMQOvzz
zS_gjiGl;!>?F%N5e5uE5MSX(?hH68S`KUI<`$>{Ul&la?1OyjQAG8`bhH&{+6diOv
z-~3z0I?vj6y2oNAT;0J@3(eaiIM+25O(;DtetDt05I@^<@GdL85h2>gUY8*?mRSV;
zgex5;G8xvq9m|*3>Yex*EdVN{e={H)vT>ynGA`Xuw5REzD?1**Lu1uL$4Em+Znyqy
z*Wju5;@&vA6vAml$!7$#V(h&M@7>UIy?#gT2g!#h4SnL?j+Ouw!A(55yRl~olHj0I
za>8LkTE3AdEpvshQ9H!GG(rBr8??#K+4|oz8i|GPwBe|l9y92S9P{T?CaAJ&uQQ{@
z@8~&DxEx4s_kQ+h;C3A#<sT%;O4t~8YAd+)bKSF25g7!fRrUSp|LLnSGq3G1+GTs}
z=`nE}g&<zf|IhJ%KmM9<p|=!O#8A@jOG#i7TTibDt4pHuGWZOg-aoNkSIp>K2b#r*
z=Z)baY%jVlaF`Ddrp0qOE)OmLlxE5X+aw%MGhLG_V%cMO05VQ&qDJk64flx-BOvno
z`LChXY9wBZJLVliedh+7aT??5LWMtB)!Fp`Su`J3t!Cq0qsJQ1ikV2KGC8;z%ShNr
z&DFJZcT5g3yGiV3mZa51$d%k-tgqO}8rJ<37ZU7H;$IO&vdX%(y92Muv*7DHJ{y*o
zVeA+d$6-2rf|!wG%g!4^k)J*~NVEfV#`Dm@`(sU1fl?dBRoCuLFNQ*H+h#fWN!@VU
zCnC9zf^-7oXo0~ZTz6_beu}M@DW;TQ^R3^VZU-l3kk4(HfV)T3v&z+>LupR3Py4~G
z;~2tKPo+)?6KLi*6L<Y66*zk`^$5=$-mRYwN98uUdAW*OWRJP1dBf8O;`k#X-U?n@
zFE6C$xE+Aou?vS`izQ?kxrL8y#(Ca|FRI6K(H<-*Im*H@7Qw_Kd#l#oGY2SoI{edD
zzn&fy_^0r!fxT6ZOI$G}gL$j>@FgJ{z1+{ijrZ`=EZh~C%$+%2m-V&eHpxmK%li7J
zvjP}=cno_huYO6u4)2GC(h7e~l(-2+D3s^^H-nFyLqT#e)k~7&e?$?0kkrD%a|w9@
z{h#@faQvm{qdLZo4^T61Dy8(HfVfD`3m0_yub|4HI1j`F3eWTPIWIZSMkhcK6S-=$
zKS(7Z=)SBO+L&QW<6Q=Fi}SK~D;1e!O}zpnI-iaHA{n}cur&k6E~AaLz0aFY2=+%L
zotQz9RKfh+3A%-*HvKYFH|v+lyPV%}@*bnd{N%ldp5>=Qtgbb&>>bL$<jp*LXy|Oj
zC16b3i6+h2*reF%PfQ8tY`nmkc=6|nW^O0JdNdJ*xG8CjCU2aZHGl6QU6VKVG-mEZ
zlP2%BZNbd#Bqj@Z+oi|de;DUjVwrJ(W3oW=ib&tNIpH04>7aT25X6ksj_hN~nxD*r
zZUq<)dM0Mn7;VeX@2lo(<*2E9?BV}m>b~=={ERQMNB%ycp+eSLa3+r%YIbXj7!r3O
zDEL_}Psr3Qe4`(!6Llv26FQUrah*vor%S0rbte5Fok<@h8(#JjMvpc^rn7GVZ!erd
zxRni_)<^WhmrDs6!RG;VsIt%u{|=#|2DZf6OuL_Lq{d}6oUlxrY?XU*r-p1L2qp`l
zbC`LtGrz!Io9)GH@czEb+HI_=jxEz(B-Syv>@m9Zj&*5NdTmPtX}-)m=+3~J`>hCd
z&J2fxUG!jXu&a}M1Z95ae!!mrbWGk@?OWTu^O?8QT{C^flk@kJ{~JKVh(cC#tI7xa
z$sn)7<U=HI1)*&Y|KUtHLszK={+J(t()@T2#;+9aV84;O3(jJ{k%8qg1ut~tXVd4o
z?wlqm$UgzCT<^#A+6iylw~-3<{pX#ZtUW@jwTGjHLaHU%#23yTCA<rQmQl72L$Rrz
z)0EOJ6NBzZN$cJe{7L#zJA;^?A&>2OeK5aCLa@8lZR=pJ%h*{^5z8(XG!$iGtefG^
ztLX6NbCQTN8Fe$fFRcwoktOQ-L4qdX{p4=Lf({kLvY!R%@O>FcL_i7`3WK80eUFXZ
zd~<iwTxvPacuUAWl>4q1a|wv#!~03SkW_VKZ~4X1%Th!b7bSB1-Mjq`Fj+LtS?iT7
z2xs1f6T0S?@A*`!44!#~YKgaUQ<#)GIJu24b^>^Jqjd=x+m;^yBX$;)rpHSVc&jQ6
z9St+Q#8W6-owmV0MpHu`$>`soDu+{s*cNk72KJ0-oLi+wQz`a~%cvD@0?!T6K_UOW
zHSlCSc_dX0!B6hDnh1vUe{48Y$Su8bMmXVr*`!FBTYGjS!|@E17{8VTj5_`35I0Fv
zB0hCpK+3f)Yl_-<wS7k3BMRZV%L|CN{k;%KRdAT>i;Xk9W}sA{Q6zZn3^g)eO@1vd
z*1lR|^z#M5EgP(j-=r(tZ+2aX^;mX;TIML=k^25({(I(N3ep`#Oi(?u1uR>PM}bs8
z_8uI_xt1hQm^_*^@8E7sm0V9r;8sGSwUsg}|A`%YW&>#&wc`e98mx!wx9Q+hZ4H9;
z<8JK~!T!D)BBE$Jfkn}Gt`6e9G1KB(%E(n1I~iqlq~x$bsGzG1I@=|(B#Y>cCTCef
zeo}8p&26sS>HiZE0^6EjfQ=tD)Zxv(Gr+rsQ0Dgl5Zv{!{0T!gAG3Gy5mM<6<&akE
zr^4OD{#ZMplr&Jg@t2KW>w~~XIsNA+!<vZsJ*U{085}Iq>vFdE*$f{9Zh?VYq3N^M
zH0MoZM!Q2}(sl;s1_3FTOEAH@MCwv0>e4)pJxKljevpz#J|g}Paqy#Q>R|q8XUI%%
zab1&fy#GI%jX-Ru8FDqLsyv=5jc}$;olV7XfEdC!;D>V~9?EQ?c*y$x^E?OmeK`c6
z!z)3isv(X>rL;Ov&!w>ePVi?@27z{*n5(&zoAS0GI>G|6Oo18}D@m+$co%cj1C#au
z+P4M3w<qVRLCTx`%Z5^gue12cCKCJ|WNYVqpnHo3TZ=dMG&`;CJnhQ>6iggL#xrV(
z8En2j!}*AH?pZ`Tmf_N-`HyLmJ-jJ(D0i7h`UA_h&Gexc^a-1&R!t?&W;peV-yo;H
zK7%erS*a@bSY8q%_={uN$6+$cIWIVyHFUhw9*5pE$<*63Bx@?j>MAP3|4fKxhiR*#
z0=_oxhm<*nGAx?MW3E79Zmnqb#(jDiP8hah{|q=8l3zZ30_X46h4O*A{{>Em<o)~*
z(9g$BH2~dze&5`G3u~sM&by#zH)31@tWFpT<-iuBI(&$=VYc*oLxjJG&#mf2@?0=I
zL@2w78UFM^9p`izZ^CWH{9&xzXT@bhPJ^i6!DKbNLb7N7HLn&#@#H=GrutV0NssKC
zq?*TDSFl(lzqJ1h{baCX^~v=9Gu%st{meItd}vFCGTYHk9e}Z?TGMi<&&DxOLhc4m
z;6E5hAm=F-UqxK38N{Gqs`FyM0{OO}Sud+<aM1iWC=ug6wwDqyVE5{*i8jiIjF%~z
z`0(6eZF159@Dq_2m^zNuBmVhV6%XZ6;_E<ts+pt5(|Lr;Sbxtqd7@b?xSAd-DpQV}
z+~&>h;Oe_}uk5H`$kwk`$vvZ~gw@v~gax&xjv&+O_7>tf;iCv6DbKTNh#GLpBWKNQ
zw>7SF9eg>H6W{CkuB)wU2xz}rORnj&y@?Bv>ukakIH6e6Zt~u-5_l~1(wyC^y)6(-
zCcKYw8<Vs<<bpADzQ!cw9#px`QdY)TqDK!YH+%o(W>fBGDreFTo5jX&4r=d8xABsF
z%QepGYrF&u2nBnC($_dk-|=f?##R@+Z&rg23ui6;;h|9hHO7NT4fKvnxZmjO0Tmi&
z0m{~>>k8u8I2e=)_olA>HOb82SPG?cQE4G=)Zo$}ZvH;ds%YbU%6&8#aW8yh5CT4p
z0yE;{(#lW1IzRb*6*BcT&O-pH6EaWcrv@rJh3t7MWCmAuYQC~p=j1E9N|oJ|p|1Z>
zUt(~5lLpr}09?;NeY@blzQ#FGWzb<TaJQ*4v6k@rHj6vB*7W!wHbA4z|5rgJ?gK}O
zOONrhK!$y~u24(&&K*k+?fR%9)!$S5!IZ*l{jQJ3q_#URXEvt3sLu!5=h#g@7%m==
zH#VD72hR&f8J4uvsXg^OxF*n8V_p>(9{xzkWjT*`0{a-p|5JI<(sm3$?R4(wsxC-(
zgX#f1W5bMJ0!L;4U1UUvd*{Dmok1SGRk<a)#FJd}mFu_>VXjF7xkCRNYU=HxkIMFb
zRN0t(wl~z0b}O>aM~VF}=UWPI5m%ns%5#5|=edDAl{;BgaHQAtn1uHR7mkLa;*aEp
z5aFfwVx@DFEneYCfsUkmTG<x^l_pEpDcu4lIa86Y2Y&8Ag|prc`i4$P6x`WYbGA6Z
zlvmCRpg0kmK(wx%V&)^O4WrLgZgj_Wnbn9)RrST*XP9(nav^HF_e@y;hpDLMf)yx&
zuL+`>5&^e~N1H{=CKblyIe20yGR^q-Q?f`7FC1xoH9JE3>Y?=c2dVTg?%lR|5N@~A
z10sYB(C57<+m-ojZ?GB`C{@B`+jg<mRs<*TJLB224Ld!7ae3O&gU00!1uq31fmOYm
z!i>!+<cNDygS{RY>0=y(*5J2`jZcm~$1-P-UDRmq?+XSRj^A1fLXW9xq<%H$ZGRTC
z2JCD;21>2=xo<Y%eW{W@jUDGa?REX!vM^yS`GVF}6yxGcD%gjh%qHu(dX+YbxaKqw
zxM33(2`+nZnr2Ib4x86x6g)ap#(59o2Ih8(=<uJp59_|$;ny2gqxqTv9Lp#IY2DI8
zGcfRHdGx39C%K)uSi@A>KC)uVWJ6f)X}o?uA0*-1(&`;LJ7VW-O1+FHZ&WJ&wAg*U
ze{fPz06?IbAPqnEB}z444M3IuP4WT0Bsc1FG<BVe@4qana!k|JTXFASx+!$+%<~m8
zJ?{OD^Z<ovZhED!c?svFw}H;=WK2#$z4KJBE$ukV{=v;5(YFCm_RxH$1<HgL&p2bf
zo6qF`S@tIA+_^fDjBAQ8P2X}o_c;Smse|wj1@oXp7*>|XOXA5AaR!ip&rV=*g9_-+
z|3+I(+(Csz3y<m+ZGYEkJ@HRNOT)`xj7-2{$ki>$X=;bbJfz!kw8Mx8oqba;lt}P@
z%&NqB$-j&;`1JZU_PgCLvtQ4D%e=SPr`qaI6CZSib81-Mi=P#zMnE%y_F+i>Z7HAe
z<S!|h@ZS4Mo&$bB>k?)4+xu#DD2x}+d12HV{8lALbX`{Zs-j?6u4Ax>Yb;coRH-52
zujEt{GJXuGX{#Oz4jwhhFY_U3#E&MskCp~ZWtv|0a6F$almBnf;Wlq)6C?WsmH8X_
z1CRfdai8!`8-V`vz$hGdT!R0Rgu=ksc=9yEN%y*PM7edW-a`&;k9&W(GU|^wPAdX`
zG}tk=k?;Tsa<&Nf7+6J0a*5x(15YsuvsT<1ba9lmi5=wL;2fl|GhG&w#(Ap6{~F8+
zCM+8oiFf@#wuEJ~#(Zy3Hgp3oF_7(UKo2w#tMF=a265eMf{5<^g&-}FNS4`9*w*45
z@!{x5#-&cu{ujrFW+UQWJBaIZh=UU?nc>|)2xOn+__TF?TRb^-Z^pWQk~%B{%>Y9D
zwxI8_0JM4!T$X30&46m!+a-P<E=BbF<zNhRs6X!AFp%*yD!9DBKN3z3cFMAIKg@Hd
zdl3Wi-F)Wkg(NX!nBP$Ps2qO9W^ymHV}Q@9Nn5lORsAWwz3RPKc7pQPuVZ*Y_c0)i
zxu|cdae%1vGnLqDO4@nspef0J2LZ%3h<_;6fE1#vzr+LwrW{klve$ubKf!Qhqs~7p
z$Rs;R^0d9#ujVtfb5k$vGs>Zrp8TH&9`{JlgL;~`_h_4Bvv=(S>N`*d-1)gHBJT8i
zKv2MyNUFW7fBn?`R9{5(%HP?aNG6qkKs5ezfBCNts1$^te(k^Vg#44Fjj2HJXo0_r
zE<;R-4yo1N%6!i37{(3Ery4Bw*PR1N?=pl144Z+;U+>LT<Ms#4ZSPtBg!kDJn+!EJ
zkEMG5ME-=bz#ParH%oP?XCMsV@YEj)Vr^Mg>`mMwD<Cd%3i?f*;FoIjNUWq^_KSGV
zjoB+edgMQ&!~a^m>YyiG=<vSjP_A*NjTbg{II2}M6U?BOob+hmS0?5dvg~pjG0_eE
zc2gI{_Vam(eO}lcunZaM6o)xCGI-}0S-glXf|zdHVLyr4ch5$kQ7GoBM^*NQmxOEM
zvVoCmus6EQ%gj!<jKp5X?-BGxzt6*w?oB%=E9BTh_IzC!l0GmuIov<u^6cU6HRUvU
zxSI5ydzG7N-QjyRknkF?EekV>_uJNwhJliHo}hsZ^HNmrp~3AJC!3O-*+-`;NtS@{
z%lCA6*E|^0$$V-ZvS~tOKq@L9fB<-Nxo<?%`u{>t?@9ViVQXU`?7V4$*D#AXPcz2U
zJQK|O55#o&T`9Q9=alT2Es@Pf{??#4>4$ZqeoFL1?M}B4>RQl7?hl;6MI*PYSJJxD
z%8gF<b3AHJQyd!So11uJTooL%_cTe%<4MW4?9|!%PcCz`aBn&4Sznzs*jHD|5{fs2
z!s(Wf8yZue^SXS!cdV5fOYQ=vyO=M1K?wdZYIt9rn&hJ8F8%PYug)g0zPkCrTS`Ap
zwfAx({0<2)!Fs>j5_o#*_J~-9g9ae)@;&$)c*lL!QffkPGIIdac)mgncS{uNUtjl<
z;DM)`!>4#6+4a?0yliI1y^qfv0lVqxO+q6uad~I0U>w#l4ojSwvxr*rVl6}Pr4F`v
z6S!^9aJa95TyNb$t}~{M{*tjJ<M>i*c0ElTRHHS8pig+eACWf?oks@tt^4X`35>qF
z+4d8t4c<!!;BjYLa}^-b>Ar)+dsVyBy_!ew>3gtxckfma{yB9?xG@MUvNkyd+Hy%E
zrfAHYpZb(B0_dyUnec955`--VGGE#Yik7dg+_>Z^|22ds_Z@9wjHoDu`zKi8K4UO7
zlzX&St0OUwPFyl19soRQ%-xfm#n;?Tz1^$j#_Jezdy4Ep>;P9885r7+hkN}-4A=4k
z$FggXx|PpVZgef*)V^t@#$<hjQ05=6HUPSxDyecsyBq%KPo;!dgYJ6oicQ$(l@EXN
zE+GMwYiOMmbi*R{Bp;xAl{<qZx;Q3GlSfG8FB!&ftY1$cMyGkT_hA;=rq|1!_y9y>
zDW%CkN)o<C?h?^ho-dE+L-RVfWdc(34C3anWn{rQr;d$|*Eg{(yRIr;63cvrL1fRR
zvCP+a?yD`gKGxcBF>Ys#cJ7F9TH+{b&3FRwk1-|?>zAnlF24h)2f>oG4{khN>`{xe
zc)LK_f~mE^%s=R3PWx>4_UH6@V`>s-3LpZT6`b|(a$|#4I_~%l?1H5ZS0F=ovGT^f
z-$#iU3)Va9-4;wOsUv*VAIj^{`m&KPKppqCf)1!4>q}p~DiM;Ry-C?%QrB~ShT1}B
zJSx4li(Die>ffg9y}@g+8Eth6#X+5K<mOUT=$Xn&s-^-WFIZ>$w$n~lo(hz4VTZ`Q
z1%soGn)N5W*lIgHUz=|ZZ*cSmakQMC;ppfnNF^LWU``7GkMmd9e+)ouyR>b{9iQ(%
zpDa31+}nnr4&d~|h@D~(8HDKDK?r>8<Dq@1AXr4iy@&E;z?Y;m_<9a9d<-ca>~}p!
z{N)StdeYStq*i*;*I>iJotaE{FCA`-5*Uwn0eL_`aygB0cbVwW;=Mj@zm_6AW&ygd
z(d<ODY}=gmo45}tP^>t1A%rWuTSdD!C4x7Wtq~|Ne8VM#;1bp^Fs5Ej9Wg1FSTVfj
zTMQ-c;eCs@s&o8vHh_<l-02e;AEkaF(~=vXXht^%kWuK4rz1SRrGlG-azVk9-S~yV
zr@Ks_-9r?=)E+|`T$nE_?WEnCznEP0C}V_3BaX;e4u8&2bdiRc&cb+K%{1C%E^P{a
z456%V8*~Es#&r^wC71tO9<jf<3vQS+&imI5vWnqD>D@;db@3wlLQ6%}E9v6g$=W7i
z4}VzI=JYOcy);>yx#S4fjiCu7lHWPMg28!;TZh(?I@Yx_i$__<Z(#Q6t1}T0POz$8
z(eo`>t@j16r3$o}*<jnTspHH7ml|s)W%J|q_Hf+RZ)PBlbkAa|VRPs@sHGwsTB4VR
zn@HPmcHAqA%W+AU3P$9UAH_ij86`L>i{sS4B;YK1`#3xTi`iperg^Ewdu+JPYTdgE
z0`JM#&7U$Z)lkgN4Hgvb-XUoIit?M^hjiLD`7tfJL*@_-d};TfHIx_<Ig%M=em{xA
zZ)nGTJpeuK&0d%17619*Bjk>I+ouMz!Dg*1VA9%hXDTWL(zlebEz!rZ&eT$D*TE!$
z(I=Tgq-gGI_ue~R6<1hvAIw#@66t&{;eGPF{8;>{5P~qn2kiw$qu`ej<11j;j2I7J
z6fCRyq}W?HQ;=<vl~Eb@uZWgffcsyB2tNNjFh2V`HbwjQktjha;kko~^KvnDnWRx*
zuB;FM9i;%kCLCu;`x;A>wXe}8Ol+|V1G5=Fh{b4sVw}bacK=8$^ByIMAC0>N9~=(P
zo=Z3oXwe&q-}JYQBgd?b(EI1yQoayh^1p^5TB*$cm`G(_lv$mDjh1UV;_!o+5t6dK
zqA+d91vT~As<o+8%@?;YU6vb<JmkZ%#5Xaw=R$OT1=_JY3FJSD_addzTdF#@a!6Sf
z5pgX*bYG(_w8h51H8Sjw#dkBC^mpRE7xdKvcY++Tp-#3Kw?RvpbX?K$;*Jo^bT!c1
ziW1jouPOSB>!4Ql7A2E*HJ;ttB=<ewp`s@G{7(o6CXU^vOInh<rFOKf!{&y+_HjZT
zGkydz@a-TT`GpZv09B4Y`AyM^o?Y7e;XnWDd<EB)d)mEMgQK;6Wsv9cGVfP!8q7|^
zC4R51nKyvf(|VeB^oUzFc;7)2mGtconwt<c=g&3#ZFAt1#!|ls{)(d>p#zPIvIv>K
z!WLnaPkd;D+GLGXI^wH-p3Q!AUEh3nnK32=%r;R!enkMZV%2zW?~c^m>?GlR3V*`+
z6402jQK#Cy7wqooVAm;I&C=LElg9CY)@1NWA+~daG_7;cS_k^~t8WS8{i5js%EJvp
ztZsG-k;jvf^|bEO<h)DysLcn~k4+ym_~ztGd)?-8w{0v%manFn<!dv9GRSO6zhc2S
zlAk(~ov1C)Ao(_b&;~3vhh2)Cd)!TrbDLS~mx0;hc5XMoEu^i)`>iY>Faz5osT!&}
zfmAsk)|U|^xA`a=Kh9b(*zVo(CF2`km!hZ={vS)G^@oI+axWu-lf}o<v{B}&V@U|E
zWUiu!<RAUxeh|tj1Le!r5dW9*KhD~+itEA|?g)A01kr{3_#cl2SOU<26d-mwStny(
zE5>~d|KriXuZ{b>KOOm%YA(x^iu{$sXke7sjPY*Jd60bG(C07j!(S`_I{gQgJ^B~W
zC#}1iaZ|jSiSTOoP(nS8t$b$bL78W+J62)LW0k9yHWVJen&RE7yHZE?F`e)jTr}Fp
zY=iJxuY*g@`s26pa)$n-KHWE5BUBY}L(l8SP{o?pM|N-f!l*UQ`rL-V&4#)3r(s3i
z9}P==Uo8!bT1wweg_>#3&>uYFhpXYJ!WcQ%yk24z8h|{l*)~$On;(zeb<zTz7QMcU
zVv9ahC9&)m_@eB?qgJpN@~LmQw2i3l14v)<`XNK=E*Z7P;2YGC9B)I1Ax=peeS;0V
z`xH%vsq!Glm^QjkuWy7{xZ=&J1$+tkC(JK>H^?uQcObvs`rjCwU%XK2^xj2tVxQg>
zJVg18zsLYjvDLHWev;7ZMqSXk=k>tfam+;O<I@;jD#;S19-iCt`UQi^!#@n21MXAC
z&b56b^xIodt0wHcb--Uvuj=kxJJjCN{mdS&7{ubt$!miCyGv2;3%ajQ7NpB}t}AkG
z)N6G2pi`T4)_1P$`dv}(&1ihMhfScp;FiL|ryP4z!vo`i^&p;ePG2Qa2A7tM%si9&
zWKY@1t`95HC71RtonBZ|%X4by61RBk7YphZ{nLYKQZs5SYx)n1{`nT~HxRy83&Jy=
z?pCe~*hY8fmM=Y=4fBeV{?ubdo%eF1md+^OGnJ1A)+}i$JmYOjrguEur6Qd@GYcQn
zLr??v{@Q&;;2->S-Y4Tga9^UC3HG{AQL%|rBfA$A4^NGN_qjlRSm%AaAU}TB_wBad
z;`<7yx^nf}Hg}9toVT*iv?o#{7-SHOk(M9t?iiI&dTKanm8&C4hWE?4V^mW<ozy@O
z4dAnTM|t1`MHNT&)R(q8^}9`a1xqmRy4!6#G`Qx7{#kzGZtlO^E58L$^3EKb|K8N3
zFCjE)Y&hgz(D_8jXMyAG5MKkXC`+CRj7U<W&vk=~qPkbZCx}tUtS-z_=@PuZ{^vQi
z6>X39k$ZVk9Fp)>Y2-Om=jR7%N<U@%Ub&MDGQ|wshe}qM)1)=h`3eT`Gi!(3ceQAT
z4X#e&32+`vkz>QFGkV=?<{&3`P)D+cJOj3r>>Mhh124G4HE&C;$F8BUb?GB>$Jp{}
z;b^x<xty|}HYki>s(8`AV<#3AEPS2n;$G!187Q_?U*FTP$FU>#m8+}mcfmP5@xrQi
z=NCB}a__j-mh)l{aTM**tx}9UC!3;jw`Njx<D|KVxc250hMDL0?yl=z!w$&}&r!vH
z3;q?y;iNl(&~Y3K=u6(u8#wX4ey!%j^5EPx>f3j&v^f&P#xm~Kzz?_!!W6i6ESt^y
zhr(jpDW;$VT{T+T)pzx@_3{!=zDjzl*KnIysHBIe!O4|;Nq8x?-gP$J5JHkW?N&~3
zp>aKK$!+^hE+syQC4Y8*$xY=g$=_J=5lXh2X(FmTKC!31x77fOdn>;g0My2p-&&bB
z3AOJo7kM}@Ze^D4242v~nS64zc#Fa^^}SqNY-N6;GK1ThaqDheHkT(=OYNk}jUQY+
z5s#~0t03;x3~KZbR>4=P0FqawyJFb~Q4_?PM$rN5wtoYvROQY-V*~2l<9mGAhhMjf
zD8$QxW%r~Gl(ES;HSeh>g=Z+oDk=*c`)a_kuc03F*#R#juyOA3xlae2d$`*(Q=Ph7
zWt=j1suR46i%S-*Qkrq{3&zQp{UYMz$J~`lJEwAWRsVv+;Nj}!miK1GRB<*`_0P{?
z?-A9EvPS*ncD?T4k5nk{6Ss1io598MkD;}!)P@!p?PV3CNx=GSO5pFpm3qlzIaq4N
za=jF*E42X?%lw$;478iiHg%mdov~#X@G)7g0(EfK2~o+PQj%gW;RhJV9Z|{FsO0F_
zGWJoTlAKUEB`P^LC>bYE(8PGMI{JKxKsgI`aMpit&BS<1vL;GtFd!$A=-#c)6!sN9
zOD`RJsW#NbG81UbT`t7CV}FJx%Arx|Vk@mJ5&`;Ga9~}0@T`F@YRf<DB4g`FN(NVe
ztTH+xLB8c?t>#dI#MMe(g6K^W#4?8xr21|VaQ=E{gGC#RgC@e@3M3hQ)3+Gz?2^T}
zdsb;nK#(?WCp<q$3ealY-fEBqg+=MfVc{nLn)3zJIY7>_q){~JYgWNua;t+pelahD
zxq*mu%Z1F=j-ZaSRZ*)TR3k4gqay1Ao7z1^cT4MIv}I5_sNBiUprp{bjs+R3on_y^
zh}LJal#B(gA<kWClGgI}WiO<JrA>O&U8MwP<v9NK6+LEOmn+@vF)Wwe>MWn6*Yl@j
zw=6u;ojwigy5+8#bZZbUw-(#g4%aGmZCuqj_ENP<^`svT<T@YKQkAtA%l?<@48RFm
zjjwroSUj1GI{l}fSiu$>E`27r1sJ`3^=?Hlb5>2U;`8)3;Ik<=x{Vm0W6O?(_X5#l
zeIXc3&wR2mvyEL6@I_U5`dD89Z2~PgsGz54rSeye{TZ=INoxprIsLlZqqdwLlaK}w
zqH4HXHwiKM$d;mUn@_ucd@F2R^y=7g$-4nR?u{0~md_AyR*dCVPyLE5MWchf0~ueZ
zlQKCsPQ+)i$+ajwgp_URX}&pmA62z@Pg;)B$Nrl)+U43o8#&jb*7bDW+}hrgULiOV
z?eXM85$f){ndVLSQa5N<_k+5tI;O;K(MCmk4+awpLei6dB$0f{+Dg!t+sL4AjlVWw
z+~zS4(664(^;=g8<pO#O*%ID_2<UuH!$8!lcJDydV?+y(pzb%*{Tui0ev9{p0BuCz
zNl0eaAS96nZjY$i)42l3h)3Hov8R50Yfsx&y4afB9`*4_m(9-XY;uZfeRfV!Pu=S#
z1`^-xQKCD^buSX*mb>S`xTarKO@VK(giFM?@48lrYcd{OsZiB&{Y^jGXY-nB4QI@i
zXRFGw%ZL_1MB*bWcLwW|x@lEY9_9ibs%)sbX37nJ4OJYQZ>Uo<bd}Ay>0f9-Uq12j
z!eq(us4`d6ivUwK!2l0*82G%(h{IJ=%$!V;m0LP4Kax@{DpgG>vbX^_W%szX<J@_Z
z(Zt=FQqBarwWSug*bY+RQnl-NAt~P8l1QFG@jB_H-VIBQ^Fq=1i0$?bqk(hOz$+x4
z9}LcLR-YM+oPjw$+Ph|%<E}FK5U6r1#r3uB4U-C|EG9s2RuNeIZT!I^?iTgd78<3L
zl7<cah5TVCMJ#8G1UpB(6!)G4lu*a%QPt5<x^-_}ihH*Q9dfPyp0=Bj@-+Bx+{RI>
zH&^w9b8G6e8el=KaMmLXpcPy)IWT~}<QQ`NQ-IFNYT*0BcJsK|n~1?Fw}yukdGN32
zW1ppqN&G+2O)ju1QIhThayEDcJUeUrYt_wFg1_$oWsMIKbpKcaWa5fEeJ==`zl>7d
zzo!LFU)Dkr6PMN_iS8X`_iE9}hTcqh$iFW=_~#!URB-RE*I1Oby?@eEa7a&4tFs0J
z2BEE+cl8wA*faLVdv}w5(wfIFyY$ja*StA`>HRNjK0Id4N5f9~ZBNmm!Aka|4R(3B
zY<o#n_bV8?z-y!Sz7c9v|GaBO44SyMpw3eyy+!}DrRKX{Cohk`*!(4!FsyszNxuyi
z#rYb&Vk)yckgcVC)_1mlI#!zDmege+2bJ#<+m}n7C)0z11`yN(usB+F5Rs{PBH5ic
z3r(`tt+|B!WjNek0W-(FC#FUw+7sO|TJPcdlOhFoNVCnYS3h#YS=L5O&8)3c=Jln)
z_zt|oiJcKBD^nhlm_ZEV9nLmzX}BMEOO!r#AU)c(B-3LVu-1)O(c!AN_rZ_ym1qNY
z9f@d_cLNskGXj{KoB}KTR_bO!X%<-uKYqAvxKbNxB1w#1T%0->;of%-#a|8!>!W|Q
zPSX=Si%#0$>ozhP5JuX)|E>u!63cjoI@v-q>cF5z+JZ&~)m>K>)O|rvckX-Pb$E;5
z)5_Jp0`o#0;!NQOTp_UN_MAD~$PxB=c)rhgkb$;&c&yciX>b2`gpaq+iDg(;YK;6C
zXcOMq|G?v%s3$d(4ePjg8lcH1EcFznwv}AuPM^%7P45_9@tqFR4&j9|Ark*gSMeCa
zA#<ITeE<DHS>NV`&5nyy$Ckkfzvsp3@W4^Fn>t{u=dFUD2T7pyU3<ST%38vmkSw{c
z>fV#TXj`#B4hU{$pB5pRg9=*IbLX5lbER6TfPJ^<s2CS#mT(3?{d>0ojh>4I;>n%X
zL`~2{ZY4QO=}GYQ<lrlemGFMO!{GH5zKPu*ze|GXC4UA#0Qvy6K>yEM9uZw3AB9{4
z_}6Z`u3N?grcnDSHcELtm=FOUjUYt8M<Y|^&eNo)x6uO*u_e5p22O^#=L0y)DUjQW
z6|d@RI3-*O%h~s|=Uz)Fr}UpKLfMm`u)sePcz!K*_eby~jFcq5$7|es6%GdB{?S9e
z|0eu?1>d_Dc)COg*ulXz!^{Z*C>Da=WQ3H#Y>B#8d$vVwsN&hi-dWM90<nEoCoAnf
zCFuHVt7^-;0SecV64(#J^Z1x2u~V{SZ7pFBn}2~cC-%(7fmJKUba00Wzbx3dFY&v`
zY0v5Fto?ufFyeKecWgkXZ?*<O?s{&CORdD!Cossjdw<ggO+%S+e(DA*K0CoMJOCGV
z#p?GKwj9W|UjqO5X&MN{&M<8<d%5tA`ADQuvemos%)n7YR;voSD}=k8@49nJ#18}4
z!fW-N@K*dWgv|dU)Z~*Z>(^ge0|?xOr87JH>qr@5PY&@FoIhQ_p@Dhl)30`zwv{V2
zgs;@u;X#-5S=Onye~`yX3w}ol@6Rs<E$g!FkH@Ld+s+17a9lp@ls}AKUfMfIa9c0$
zY6^NO(V04lp<~^w?^jPBt{&1;HeWy3eC$(<lwedQyep%IbJ?I*%(wgWC-wj8&k;lW
zbL}fb`%|`0e@^|&{`&J=<A3hYw$uNg{rT6+VZ;0F4_unoK}_Tmh`s<SbwH&=M5X44
zO0s-%p5^;_DzP=Z!wB``-2)x_m=UUa*HA*8=aXk(el;@vqv1byYt;YJEp35nCgeWB
zsO4N{fBeS{QOLDPnqI%AS?-)99<+z#U5cKIhK74P6Snp-h-Fmlwh|Oo?j?V8M>}}n
zeptBhcYy1x*S!n_Yi^4WmC=!Bwr(}*>YtNnXl=rQ8>a*}KGQvORy6z9PLuD%^d=66
za@&ntJK3GiHCdk1ygm16>CZYkSke6jB9Ff#Nx^>ov^#e5R8ZZyE@oG4Q@7LEuUai$
z4?e2S)LHl>IMb)O%^T|QR9Cy_H@Ot#iUo(Iz~YCgK=%;^mu>~uA1zi-S)UdJB(sB}
zH}k1`auGpaMB!VG4wFoB6OlF;_8ngPZ?InX0V|>iaKq#VC4Yep_xq?tP8ZX@ZIJs@
zNpL?dZ3{WGOJX&DD`H3i|2oO$hKcA=jg)lee|xtdT(DH!S8Fj*a{ptSGMl+(*r}c6
z;wCx0Ns$Gbw-QF$Y2tai?o*3TahfLkw%glL-hyj`PJg`ppy1izG?vc{kG%kQ?ptic
zJM-_{?JHg#Q7Q#rvit<5oqeEFRDgZQKV#$)5qdIH`@(jPo@p|(i$O#CfwQ(JzFS@w
zuu^R?cAc_vws`y9BE;r<#{~YR+#6Kyb+0X|feES?cne46UU1T0)dx5Hs-f!N>G$(|
zX;o0Tr=%2D>VxI9QR*Db?zU5!TLt3`?1zN%38hMd8E)(k=BH>lFC97MbhbpduvI;(
zw{B_CXELkPN3zKZk@h(05}cMJk$TKOMi)#uJ-vlE*W7Q;3+;>I!+NHDrZ6f|Uy{@4
zsa$P4NCWawC#KV-gM!gvRD}#jgSEftOc*1qxtJ}RRM$tRr#4saY3wPfURnrH&(Y+&
zT_4ShWpAW_9T4sB`g-A&sfAA$YKyu!p+6Q4?5lp@RA4?CnH6M*Z(+;AU2(7V3q*Dr
ziTWEjaDyp8hYY@UOpMsAiR9S><j&``rAXgMDl726K;E82AvDb0*!A^cvtwq-==%Eb
z(_>jhLhY$5>iT+70sfP`*qGUZIyI=-$L7%j4f~3B3YjAK5&^#@k}C!vz@Qg28~U6Z
zAik`L`_gyp)Ac!|13RfW>TvIFse6XjFTw4j(&e;e>@H!82Y0j!#h9SF*nM~fPtNlc
zE|e?82Hsp9Mj4fwryvm50A9i?C)TT*r~vBFR|p9>5^*M;<G%}vvl}0O2C!qxbtTgB
z`uDmP<O))4wmxDvb7a?o_X^T8so(Ci%HU4%N446fAU^dcauPosTwN%J+4H)4LDSRq
z?_tm4JT5hASJY}(rRj$s|D*7?V0%IO`;YrP=I()iu4-u!5A0x>-p{x8J%2=9&X1It
zv(z+p4%Q)+&xBo26S*H=+6#PR)ybfADbVa)I?<XuE&7=EEE8clqD<PEQQAOr2FCd4
zd%jGx9~|lncuW-EYZNj$s10!9g?4U(D#yEvj7-5XI@FXB_uEFMAOok{aeB1yd?lQE
z{wJac_xjuUl%IhpGu3(eSNhhopxjx|&ymnF1*czp9fuIK`0swIVBQH;YZulg+LIRn
zt76>kA=u2Mfg_F){<_!BB0d_2C~po-%2a-o^Yo&B?)i|NzWZ{&?zynMF!!q4GRyx;
z!1Du#r=u$57_gT-TC`)V&5mr$<11#XL0h$ZdPF58?$@h4b}uL;Xzq*p$iiONs%D<n
zOE7QSt#C|vXP)i!>|jvHN&1H>RaF>Uc8~H|WQJu2U=HQJ;0in;`!Z&(1TPpz2oOr9
zhUzrSkw01X64GT4Rk~aBb9d$>O#bKvzX_rw{~GC;oCUU$4u9B7j3sCd`6sh$YDHLB
zV~d4{7E^Jrv(jcvHRd5f!lMcP)ie^!A9hBaZQEHGZ&cM<XWFVq$e!Jdnb}=gLPmF0
zx&DrHk3hy%*H*;7yZU&6NUmk?3DO=*&syHQ?e9wA!!30SiD0)%f}FsZOb*K>m3m4h
z7j6Kvh3=7>F`RNv=x70r%Vw&M8{KWfV%|L>cbfDM5I^N-Xno_|X)7NiOND#4Rk%uZ
zHT0B}_moWrg;X}oDRhovRhk{I2JbG`-{lkdTe#NETA3aJSGb|@1t)mVs*b`9j^%ai
z&CRMae6zf6k7{x3+wh(Oo@36PB2{)Q&+gs3=_WQ*d&yStshhx>_TXl<XF-~Ns_xcb
zob<$Wt5nSk>=NkLU8%olfwx?vG%?J=ODowjE$Mz@l~|$BE&3&V5X+2V--K^9`bJo8
zQ75(PG3L-pH!Co(`5sldMdG~Zo;v(pKV{Q-wSk!S_&zW!8mkwSrtgXdhg(-6_DC^~
zwazvE>a!tP>`r;Oqs4nL9&*`O<vUyBJz!&T8q4<Ii5b23PRVoHy#UwHS2vF20&#ct
z6RI0CP@#LbF~-N*9fJ!Sn(PbS`&3!~gt9yJkHLkHsph_ES^HFj!2wG+3)}Q#&Pq>R
z-Kl8Mlbq~CVQ{(qtr_QJ73)QzHJ8871EE5dYPfNGgrPOwF@@`2*yUsm<uGrL@~>1<
zm60LVbFsbzgt1&7yymPDHw9$uGeQf@KBKXooK+TpGhl(`s=083+aoC5qD8{j3+nqS
zaR^dn$y$4>Fvye{#ohU+@F{m?z)z~nu~Aa^p1WMNa1Et#C$-+KVjuje@a4i?&Pwrh
zz@v^0uz*J|?R5jbJs9V|%$Il5bXLd!knB<7+q(@}XW^S3%lt(gw^HmLXK)i55GP^;
z`d^644-MQNp_A!g*atXS$Fc`enMQ4F*`H-FXILtBV=S{-Z%vc>vPD!x69rC>+CXYu
z<?EcW+oM6&(cu;y=*}r`=ZeLIH+O>ZirXVs{(&Zbr0kvSE~qLZDd^Rnr8pMdqt-6h
zw|SH5oK<SXu~c~<x9WSq39D4vH6Yy9aqfky9&wi2k%6l@i5JTpsGK(Zd!`I`k3f~U
z4!v-)yV5Xoj$x)rHJE^jyG7LlsChn!2k6(49?qvM%xf`+e66(I`{^Mz<d9KkpjunE
z)#-Ryt2?i>!}~^*oW7FProV@-2LjP8I#gX7My3A4vZ$;S####BYvHJ%O4p#C&&ZcP
z);-`=wo-=k=jCT!ef_m<UEAxscGsj1eZ_xm+s<|M>3ePX`1jDjtD9fljPX+;U7<iA
z#}CMpq5otfgMTo|VLxhV%0D>j#|iG;Vh@TAcjuI~yE97@-m_6^`T})B_Xq_{M4w0I
z!To+d*NN^bn-UD@k^d3sp9erMrn(U5&`a1&j3q99cyK&CJm42XM2R{!#0RC7YC!sb
z1cgW?IX%b^!8<?bC1m+D)1M@Z|FvD}aPp6ma&=?l-skdJPDN~4mj5D)TBsxNBKKC_
zrmRJeO3~M5#xFR&i;Cwz6y+ML0kHs=fbEv?XY5XNc)dZcP!jrwkU1Yu9%-iIo%^mw
z4u>QEvUJ#z`oFRCc%8<@-VRV#KEpC;!Bpqjr9}sm^t7!?7W{2qdUV(Ig;xf7;_;SN
z&#^flr=fnpMN!n`T0y*{t-;#F*43Cw2xH8oUbvP8jk@J_X?s2H{p#(}tQR-~62;ST
z8|4w<x4{S;UfYuUPPk9eYKxU{pJMPD<&)&>x?XD&8Ckoo*V^REJoVHTbzQHuiRM&0
zg*DJ>J*`Up7-{PhUy?7-Pk;={$qeT%=$98}b8$zqjJ@9k_8spOe0#|ODcoM2_NaC2
zhup!!MJEIT1_{<Kz0^z3g0+9#{d`AqvZ~6juXDf2uNMR5I4#?guycl1;~J(q2_~z}
zZ~4_a+HMp8#8K|!EBHiqqDdw%qS|)v7=pm5S8GFK3)v>1nk7k$drzHcqmLvpoT~2P
z7tjYz_=<MzA`bT<PYWhtSx2XmDefI|lFFAjPbW-+?$~1s%IwaChjq<Ade7+8L7`nf
zOxUYpa6mnyfj_inM9P59Kh73PyyNoV0hPeZ%E(Hcb4XU5hWFBNF&B2wPLqY^uDri>
zxc*oCGMNBm%-fSXoc71My4>!N)aa(veD`7w4W$nsv^)<2t@)n>hi=^jvcK8VuG_~r
zzc9w`iGaa{wU+@;MvU6Y<ax3^PTbbFUk?5AQ$Il}we7Iz`(DclhH!Fy+wxDuSJ&54
z#=Up~ZJ%Iq$Oq*=Hp-tq%i<y6yJQ$3b}R%L9;K$<utOp!>2^4M)1Vq&J3eeNJu1j^
zZ*HY747jGGo&FL(;@H3!5af=aYCO>8q!ZG@Klanu%<C{g#WHWfw^8q>mkjEC)@BVw
z8y>R0!|Gu16&1U5hfJt#p19VymkN!0ZN#g3=~+@3Rtp&xh>@e9JU0;yQ=cw^Ho^VS
zMu}L)<!eiau4iYzkBD<(a$~8Pc}iT-q40v8n<GkGAiQ`1CHlril&B|vXt;4}AqZa9
zJKP&3i3VLNG5$>~Jwin4@Tk%HL5-$eZsx(Gbh8<JoCPJU=OY}xLjXtjB9Zq*JL%Lr
z2#To@6nXj{YV_?e`W_dh4$#-GtT+0G{n&Hd{^?tX)K%d9J;wy&Uq>fS=+L=SXmN*n
zm+%sAAZPaua{4*r0h`6JOo$cycc5%^w7`DboHcIO3TnXn?JacvNj>pB&aL{uym4x<
zayREy3*G15dKW3~BBis%?v@6YH)liMZMo0#kzA15nD?K@pprUz=`d!Q@+lRmk}0E7
z#ZyM7il&T7$ClO>)?%OYY`X4TJIFmcKi*9$KCBj-3Z12T;2^`!f%P~30Yzy3Zg4vK
zn=<iMZJ2*KOTKv$+;&{LjE~8F{^V^6PI$OFmiZl@T{|JotxTW#|8<}`Xw!MBr>4-c
z=AFQspr>|LaHPAHGu^Fr%ds_w<#oX7Ff#xltYb~J0lMI4l;|nT0#k5)@BezXJE+E=
z1I^trcG?^#DMTytl@6U(Di%dwomtBKb}~idyK=RI^ZNikIUo8~JCi`{w$;vyEC)Xg
zbv~)<lu{GGrdT;S=_CX?@tC|lx-9)3I~KXFqRz3W(BB(39hmfYi2qFhVV61_du%jH
ze-YKRo3z{`p@5fY(D|G81bc&Q6;2$W6|+=ebr(UEt-zU6l)MZ$ytB}?oVsF6MqknE
z6no{G^l?|{^;7mbme(uwdbGV(@OqVAWA-|Z*YTg@wZLA-^Ln*X|IUQy)J@>^8oj<@
zucf@E_4=Z{mhrk!uj_2~#B@?Fe|AL2fIqv<S7TXtwQXY@j0P<u4WI1Jc<KuF@o2i#
z(X8oA-*LlQ@<wWQiR<H?aAGj<C3-d6{f2=bmR?#)__54KLdlxkh~A|wg;Nz#@Pn?8
zMy0Sak50X#Sc9H2{Xv<Y&mFEL{)|o?tfZ30rAJ_`9zm(}Th6Y;N$V4=+HMP`>u^rg
ztcId-C-B6*^NtDW7|T4$cMF)c4FQF2{OgUOc#dVVbOW->wPf-AWD^C=W_$Yz-YU0b
zH{MX{FXFMzwJ%k#EWDOQ1Hqr%#U^Bm?udJT4K`>%*~?;?!O=>bUDorg4)`dI4Z6?}
z&UVAVp;@{02#u}Y8^=dD^dChE(o}!kV*0zw1Ygw)v1Q-pH*B2<G#ho*eQlv*r*@si
zD@cqjNz<GaP5z5o2OomhHV1~t9VOc7*b7uY9>CaVh$y0-=>BlcbJkn1lYK)_5o}%c
z?j0_|7I!^Gqa3TCr$`bD$DX)*yD-IaCKM`BT`5vlkm7$jM2?~j-A}zTi)!FD{KeKA
zn!)d<RrmH@aszs;HrwoFKxy<X+J8Km+YelF+6o29fIJTLGt>m>2!k0unnl-&%?}%3
z^CM0MvISm;_l0pGiTVSD^7(+drDVX|#hOq4H~z+}roeeNH<Z6ELSMw+o7+!X-wuC2
z5=_T-3h^s>)?PR^&)OV64_I3<pLW=qdE4{(6;JBA7Cf#5_uiLy60)wCz~ef&`n{RL
zu^3{&Qs!(9nD&&AF8M_f86z1Wjul2)y@|&~=<sFcinsgPl2L`pNov}{QSBhVcde&&
z2pd2Z43!?i`<N)&=-7`bqLI80?e%uQ(k2bcGa!VNwbL|UTPvX0;X!a5s^To;Ha-_r
z*Tz!^_uZtkVfx2c{SZx2f{e4;Sfu;vx9S@MdyCynnDB1pc%i(r&issZgN@DL)N-IT
z+R5cO1|GL_6Jf2>=T&Y|juxH0YQ`4Sz3bpqefO>rDeQG4Q`PJ<=e{rdZS$r?g0SQ3
zu2h_(`c3C2ZxJeVY0#RZjCg&)^}y=d@xV^C+_4tts>1ZI6#lWbjH+nkm|)ha>L?{x
zNUM_X8kC%Vn{J#CUF~-pO)z!qq@OzU*s!2ub56C6MTB$N?Le)aFU(v$fyMaf+%>&{
z7u1*Bi?|~?^{!nB&HZcR!R=czm4{J?7QbN2RaBPe<E*0V#^+P!Zw?l+^_#2e#;1N7
zxQpEM1+-AE-ypm>0)*Ojrtb-fkv`t=tjYId(d0XapuYDX8F6;@m+(^MGvvp8vr}#v
zh-eV=wTaC3*Sa^Y0Dcs~+3*<=EE3*F_%Nv%)5qJZ>NllYqKWGuu8DSUu>#L5tPJk6
zY!?B?BFS%xq_{2s^TtK(r)%n}zN;cPY+@hSP457B9EG<-uVst)4EVTVw3K+dZ~4+*
zU_6gS`JU$O>GvzQ_!A|q6hthRdCD?-?nq8RXt_3#UCFOa%>7v8t{ETqZlu^nWX$56
zB35;4g>??kYftK^LC7DqAw)iV8f1lGLcY$*`^prVSmqKvrngFBw&}5XYt{6!SXQ20
zNDtF-6xH*L@;sV#=Mpu62|SkJ&knEVT$2a_K1rfq66Bx<wG-_wE}^`0Q^LC}(DQk2
z3btYG2GS6cZ(=x&C@Z%A?GaIvnRznMHq&G>qd{>sbbp9c^#=lSLloG!fIR-WK}KTi
zyXTE}Z?P2w_szY;5&};vMwN_G$DScBv!XM{gL^F+Lx0@T%g@d$XCU=xXKl;nXRAzS
zC!XqcC9A$Tg>y2c&Svv?O>O`hoxes>J@+Qew}rIa8@8XCw~yGF!&v4;Ng>WUGmzHn
zkq{f)ipn{Ay~uAbmQj?gL1O0QJp@f-RK9VFjmF>#x8=%i>#Jk6d^n%o+SC!O)oMxz
z;Zw|gb3h<$>_PwqC00umnI|Cr=d^ins>pdd_ieaAUWw`V%&RYTXmz?Ibx`nWTj1#T
zj$nODr7coD9w2vp($wxqTsZ#@0GtYdnDuBm2$aa3+Tu)wMkHJ@kGgD&3*!|cBIQLS
zo>$!Ay?t0n;?xUN{~M}zbwBQg=yUq<;GQmRkXrF{%3sPe@)BOK{4z1Di1MfAu$oUk
zM?DG69+TgIZ7h@<s%5Db`VVXNXmIRDOnD7P_NRzvB0OLJDZ?|u;$&ftL;i;6k2~*0
zAd4#}MQz2h<}w$Cx$m{igi?V%gU8K?eD+Mern-0_)+IUqQkLiM3pM&BNn@GORG^vi
z@37YY$J)QZM^#;Y+<1T}0fQ4YDk|Dkv0}v*lqzVnAt408=p;iff`D48Q`Bm8M)86o
zNrb}@#k-=lTB)^_T3YoH5EX@ofTa~LwJ286qMmV3<E4sd<^BHFK4&rs*ysQMysw{+
z<jlUVz4qE`uf6u#Yc&SD4hWrWI4)HkKO3ecHfjP|vJWE-`8WPxJ5Eb}M+w3F&X$MJ
zoCcb|A^QmoLW@!Z=2iYjCY7@lV+sTnw``MF{wj;$XS0|7J0Tm%xy(+g+9a94Q~Vn7
zn;MB}bG5+gf_wiGarvP>Mnx5I@(+{Nbjl!18gF{har%|V*9?-mt2Dm%j9{mkG6<3p
za8vp>1?6A&z~r~7(R(wv@i;dT8`HDBPcz1qP9ch2>UdL7#9GCG=1YmJ(8jA6A;604
zH>Tgu>?zhWsi+BAEx7D##*Rkz8!-iGAXm5%EKvv*sU0?~ay!82f!T%9{x%n9PM|*b
ziW1m6l7|>JEBA`#sqN3krHhh-$Y>OWz4E3tEz+MQ(yH+6PsUThS}vhgPzu;TsGt<E
zB{(+BSHWh|KnFcX{9=GJ{(%bnf%!g;PxMITL`*47iw0|!-`~&B<S666!~vlDWC=A`
zqV>UJ-71~ORCV>(&%nK!^F)ICsgj<q&CIX#|1tsq&E2?BNRvU5#IqNXv9xo%&R>YZ
zA^@CvfT7&0nJPGHA~?48&l_>s|K<K)RU1`RFJ+$0uliqn{|mi8RV6(toReQkzV+Sm
z8oEbB5Un4=9`U!!0<u+>@AzLW-4wNSVtz~V`tMqLuO!zJUbz2@*MBwkc+}X(`{tpc
z6RZWDjqPe+T^NCtzxaift!haV``f6cO`3r%jKZ(6%j=88_NzB>)={XO-7?RR)#>rS
z7s{@WQFeWRvMW>GFZGW18p@RZnY$=O@?IpzNZze#ZZA}0h2>@Gj5+^b&mL9k1PNM(
z^3LSJTgj0ClOGGEnN8Xb8h7$UKtuv)*a12=wk4h%t_nbpySJe6b?taqzitW7BK{3d
zYg01Pvo9AbAl6px4j588<SxR5iaB9p!QG+fG?NCQtvU3#)3sqa^iQx_k?&NNFS6V(
z(HKSYaum@31V6BW+|_o1VH~ONv#jfqv*?rHI%wN#xKpcIzyk)2HwRay#sLd>`D2}?
zWivZeN<|)+2T+u82p|5bC3V5x&xVSM)E)S$$llDhDlVpDdvMwAIcobOqic8GrZca>
z^4OQG7?cv!cNWuQ$~*_qXLl<(sI#Otg2?goC!nOOpJ+Ler;9S^u0HsrUl%Zp-<*-z
ziy|z4d>+3ILc}MH65B4J&&+nNDz#B?OO;$F;)RuI`kP*hdg6o_p`<T0RG6_O?+htj
zg}=YE!V)^8!WZTh{?DsBX<1IALFho06G8{&Mq)wl*!S(srVyn4I<pRlNDp`p&+B4=
zbzuq$172U5VlHgE$&bz-@VT%@zqi&xwPTb`_{TskP(CoY=17Q)zrWj$t#C?8OJ-xb
zcjn);$7Vxt#iMs5<SNX#x-))rK-X<Ekj={u<s`>-FDIFxdzvnzx~FLwbWhV$i|%R2
zraPn+?vTdRbt-g_q1(*%c*;N!P?){o+eg1M$VTnZI*$)`NQ-kG*q#V#>oCw8&}oFn
zVedwOX$l6S?bT!~`XBeVFzx=9KkWXdP+cJ;8DB%>(go!&PBb~iSZ}JIi~Dx|ZMF!A
zfg%VbG@+l2(#9*T9{prIs1DQYP`U%K-x926C*_hmNjq;RX;<!;HhU(7wv*(YbI{q#
zU1>M;v+*$iDo`$Q6e-N^?R+dZ7si9HwJ?p6vpg=Qc~_yq?N~6ATi~MkYRcwF=kVfs
z$(zN=4Rj=j&c8nOTO2xDyBxb53&5V^j|NQUS0qHdyz~Ab_kKhMR&sVRhO^q|DNYF~
zb6s7OJwzTFdFB%Ls|q<4_w5t%xzu~K7T&rs;f=wHi*3TCqf4*IzU@y=br#6^*NOTg
zUid3$9y-<QIZ@EBNFn@5G*|*I>VsEfPA<^Z_vE@dK(LKOJ19pQR!VY(b{_G<gZ>T`
z-X8LvO3%J>L*5Xa`ku5W9pX0VxNt3)%J!5)OW@rqe%(`B=ZQa{v0!Rmrw5w80s*4?
z%B4#40M&_Gogq8a*$J0Xoif$=iPiaf_s+q&es;n&RHsyR&a*mecBr!x?xQ*iYLe7-
zM`Liy4s~|IiBzY*5PzxlbH)yJcETZ5XP{*9tF6x99qR0agR0IT)_KyiI$Qg7$H7kc
znCcAHcy6&et9GcvQrp@56sgVvt22LxI>kG$Q_Kq^2|?4?az(;hb+eqgaWlR@wnn7(
z$cxcVTETh_14oQdg-5@~3hiod+_L3l==~+=-CZT+XkEbR*i#>T>Rj}@7*(6NbbuGU
zYhd5GOSs@-t(f*pUhGs*V@i-cOQ&6Xo8UL%9w~JNHBG@)$!YxbsB-E|k`MYJTf7eG
z)w$%c@i>nu_D<Q-1s!|90{Z#Ck~~)B*&kDhqHorUk#Rt;^!5HJgX)48-rBx>0!!yj
zQe6!9(S_~Rdc;$ZrPbtnQD++pa|1BTadnvbMb{2ZsttwPutN((VI9U=)5!c|a6RaP
zz{4!NXd^D|>_GR@2rM>G%oBpsJF{dSo?HY_#wtEtZ;Uv54Um2mLHdKv(wLB-J&3hl
zATbBMiE|2~`T9yt1Xa5^qOD#mc4Gdnr<6+5aSevLe)VGbj5}lKmcu<7LAaW`^E1YP
zOsh(zzV~hC3~xi-;p=e&5G>lwaOqCRqwC|ziXlvC*K<a4iqa(WPVSY%{3dYLUeljZ
zxf4fZ-X-Fl)Is2}n7KuPx&S_&`Iv%&$7cGyH*Kb4ZD;BH@1~^feEVi~6KIf6D#nwC
zM%caed11FKQ$|im6F9|O)R;W*Xh1tqzWESvq;aGFh(oi(j2>ta?}?%r{2CKi?Ua~S
z)z>#RZC}q13UHr2UDK7{hEuF(+F5<BL<J@6Ne!nDdqz(?*k9j9fy_NB6;GZc9BC;W
z*E5GBX}L7#W_oCI{tFe(&H1T)!a09bqwc|C^xd56u<zGC>eY7498r+oBcnwS-jXYx
z9ENM(HuL>6Gb#Hmr_0=||Bu^qJ7;~#f1CAWkKBkRxmkyX?Kpr4pF564vwlXHSN&*s
zRD<~m@9@8ikr+4x-of-|&fy!hy>BdO*IW;6=OfuCJ4j7v1ODY--K2rU@npE@8SS%Q
zW{je|C}_)YRaz8PN_JKnoU0TS-JcZteJh$S-#rh6EQTBBx{DJk;AYw>hl|*FyuLB$
z{T$7oNe$;BxT&;0c+?k8$}$CR_JgRo@~Ampn*(8Fs0aL)(4brR=kXPZBaOk>-XRf~
z9I<~9Gu^<ueY%~$mJ!$5i?rJ1vartfR*O1AN|20ci3H=Ksa%3CZh1Vp1xWJcJw!a{
zt=~}bm^V>)Fg8LAiQfKAYof)3<*f|!%+%s>vg+zE6>M0+^K930Q_ulZL5t9NlCZ_S
zqVq%!0KjFsN<hg`1}#L%la_SWcAKK}>3bR{S3A$izeh(L`C<(y-(V=`w|{DBT`+R4
zLwO4*hb5-~TNY!%+HWHJ;@!PZAg>G;KbayLWSU!4NUL&Tu27v#^P^ANev#SqCH)lA
zk1_Ed{3W6>&=gV3lN4d39Jw#BN$1FoOciT8hb}Vrl1V=|M*WoM`uVZ-bLAk{&-7d)
z-|y1MJ}iUGL^8u|J~<s&%sncOJ4|yg-u3Q(q9N`f-W6POm}~W5*ZYE~_ot$AvDON)
zkm^MhZAhq#Fujmvv9X{J`3ipYt|ZrWB7-;h?KiCRYX*8fxg+zM26~rsf=ut`S0XmC
zPt%ad<lv)3LU-fU*+|H!bpezZ&Dh(kX=jqDE7`TKpjFjAjYVK|djGDPJ*+j?a4w9_
zAoo0hC0@firC0Vx5njC}ck$Um7U@Lq^F|IxBnQ!Zmu)F`s&r1`ky9Mqt?8sYLG1|t
zU9O@ds1<%_ov#o$-Nie?%OVvL2#b2B*k~WluXmu0;~@;^aSi`!b1~YeyiHG)biQZ|
zF3YPFYaI##SkQ?C3;OB*71jySW>^9{4ZM<a2h>s31|dLQZL6vyo@^EfVuE+D7Ix5R
z9Y$5|igTz;ECZE<Is}y?K_$Ab@NW4yGK9#6bzWtN$b9~g!z1{~C~Ubdpta<}>R&Cj
zcD<1$dE<5A5hLctbgzUEh>sy(-ciM8RZ(+G>`eS4uhZ#Io+4H;#xz^ACV>rDCiT6)
z3duWtlzH!e&6dtvTonrHiw61=25>d!RhA_P6H<qN_G9+a5wt9GFc$GNRl5r3f-vQ$
zw?)fj2^|WLJatIU1do|VBwZ*<Px_atu+ASD_U-5Dv}T_pqkUwl_^Sn{Mgjdh(VZB`
zPoi?Mw%;<P+Sae(uWx%1%_>g1NfXP}-6*>A(hr6qDu`~;mo~$or+)2&Etg?WcL5*%
zNu^%xgFJ3|pUYlJdpE%kFl>FfKKV6^I)9>sFs`<1HyB0-d1D7>eoEn}+aRKrX<CQf
zqndrmlPG`W5a(5XHVn%I`i9s22}Oxu&X*DT!3?hDb&BBvii7bRJYu0chIfpA`@IYS
z&(kMhv)?DY!@p_>$n3o6mk)YSH9TrBwZW&0J$3W^VtQ`I-fbwvLafy+tu*4Re(qDN
zb_4gUaXsj&C?4@_YAv1D2On>Zz*<^${G^vtqg+XqE4<SRrvH(>r_1>5iuq@(G7-lv
zjM)gO8If7k{TboQ{Oa|XFw8g!6w@m$dWAPuViD3_NK9X*eH_w@->{xm=M~<HK&E@c
z*4#tUV`ZICy`jBON}GbraTM;c!mD17nP-~{JD>VFdo1u+M)B-TAbg>wvzuAhZ`>xe
zekWOT$?|X4sR^}%{$&0NM@{ZUQR4}%tH?JkcZKM|zB0d8k*27~nJVHAUMgZ=<}yAx
zEGly1&RRK!R(7J#Nf!m*IfxeB3zDr`16;=U<FBS*67Q<l6XQocnFw(Jk|NjWSO+O&
z*U+`zYhFk2;VUvdvCo%YMUuDR4rF6>w~Bv78E5d*1%1#jcIn6%QpegvFo4T+^<l40
zuBI%geO+gOZbud!b(?~RKMzSL)~aVX0NUiFl3*AzXb#pR)aU4dWP825$pe#n48x-H
zlkNC`Kr38bJVAjb5>(*ZtHPLrf6GK_yg**GJCUby!+`8`zQ>(0&ZbSC@jATMf|?F@
z?sw@Hh$Pl3&xA0ToOx`|PFVj&7UMD_jw^Kk|L@!|778IenqbKJ%wZ`bDDYl$knoA`
z<=`5WS7AE8ezL&^Y}R}R)F(_p4$*D5(`5$xlu-7Tk>GcqrNBK>epLxm_LVW?A$&GR
zgG}BFBxVf!$urFD=ae+(q6la|(X`<6H5k+h{%6Q;nR0bAOu5`1W><E9-ywHz{S_`N
z_~=2q5^vu{KlNYxE=A!N-mcLco4qhz^6pbItF7l+{Gsbx=m<Kfe!r@&&HV3(f`aJ2
z0DJKg(|YEuY`249#^ThW^nLSjvShgsP`49kO@D^22qwS8ua;ICSAtiSYH!in)PMOg
z)9$qtrD?kKUwezJq4ZySi)l3MYq6y$Z4F<7x!vN=DY?DnW&Pp5VC!=1a#|$zH`|;~
zNDhZUVN5#j2HTi9%};1+Q%Y87YjehmoUP4{>sj91kb%;DJLfWZlcvlfGAla(h@E&`
zanL$SE8P5k6OTi3MguqW#r_F8c2mN$EWdJ0Jb603v&010ME`n$To>GFlAK9rjV1NL
z@9)g5;M8z@XpK!>Z9!IW3*bC(6?*O2_x&2_6Zepht&R~_m0)wD1gvAOE^XVM{s7p$
z(IpshH3k!OuF@VAYwZsT{cANN`gI6X1h;A*T|$Cw*a|trP#S~P??klv4MX;)4B;Xq
zmPxAuy6IT!x%#rZpO5^};{hbjK4-5m#uG0hiW#4}2#X>JJRXexB-*N;7OKV-*Cm$=
z6Iw>EJw;p2z;;zxrL(Th-a#=A6bD^xCu>iAr0-77iRwI{IyMmF?)H_@Gq?Ho>E$A@
z5DO!M=cMU+*Hh#;pd}|eXb5v?rw=L197fF$4H-R87L1Ce{GB^&D%|rpr)I>yLhmVp
zVf{_Aa?cZ`2oZ@%WA5%3{_VWmg+wRCPIvoX9-Xsee6TOafX`EBI^b~5Q2L`BWI@>-
zOowJJwMRXeiU(723C9UP&~bA23WY30L0Ms&aGAmIBXZ+`LPrQHwu01&qGD64TI7)A
zaJmUs!GtGOtStLaDiI<kd0uDMkHf5I$w~y@bz930?-88+esC~DVMy)On~a>;`?m8T
zYblwfp`^+1)7g8*TIKNC6kF_nFYw*6wRd_mC%W6|+}DY&v?HXL)L;F{gOH3@&+Qdj
zu7+Z@<8K%S`~)+Cz0l~y!Z$O!V=sWMzz1Y~UX}gSd#yah<7PT3PsUos6wUk0YP|w@
zMyCGDW$OPprvB+Yvx{kK5p6w4TMMy0xYukC(itRvmQ0(rTYtu83AaZJyP}iL;fdWT
z#dLY7g%zR!Ljf>v+Z`@!E=#xKMCQU++vSwNiOf%9<_;F`Kc=VLH&ja%mG_IaX+L%Y
z$uN+&vY%4_qF7sn)$B>lV_X|&$1MDZ+Ni`tBGsjlqq;ZZg3z{_3({(W+8e)2E&=Ny
zyW|kFIUY3LV;c*G`eGF0#WorO|MD_))qVZ_#Q_jy*k_qt`#(7J3+{|3ZT41AX~tse
z*jrt76Lhk|nOT9?#gm^MgYMleJlV>9h=9&tuX<BX86t}%@Y<<z7m~5$4lX*sZ^0Bl
zy}2{To?Mro5NrE_^(R~%#=EJ5V{PVO{?%3>e*qzDZlcG$aXs|DV+p^!zYJfW-ZP_5
z+wX?2kF_4b4>N*Kf1J64Z#B8FYm>L~)1%4MjLznM7B-jqnXCNo%tTVa$L0{N8f+J|
zZg;Gh;b!(`_H1OEdBY6)S>N!&zb(~T<TSXMdeIx~>P=v<AoC|cAOl9Yms!EA!AgI3
zCploDEQNAwqXRng9%%K)7U~&6v-r0T^Rc#C`{eKvYpb+R?Fnti+9!JlbY!10+_9*|
z5W3U)#+#DG3?)<`ixMi!U@S9-AA-sfI*5Fll&yE%+NRwsOdB8%wmnB>r+1>mzd{d#
zG_2s<2i$hII$|75TOR?!9?HzKdyb}!IP?D~8>>v;iXF4`o5v)Qx6o#ekrz+vf$rzE
zgL)QV7DO=B(g}_@=X|Cv6tFLZWKAa|jDs!n_!&i9-~x`XJO9)NoW8L_#})=N()wV|
z?;!32#ECbiUd;Z>+i>_AhFllS|I~QY%;S4_?JXNkopT^FjQIHgGm1Vi8}YDG(*9^^
zuSaR=0~lT?ZO`pR<FGYwS&;d@h$NRqM&@c#c!s{mob{Q0d=6caomo*=mzfQgv;?=X
z$sf84gT~dP?A56Pg=rR_ap&L0;B1Z~YDst0EG8kAC+f-J;K31I!{e$~7S2It4&~f4
z$cFCk-*WzpWKSY%Se=IZxYzZ>ujzbHOpeYs$RbVS{R;<s4V%20@oWTz**=&unbGhU
zyig9AIw$YQYMvvpJ&yY>`@vw|o%v(f4+`H$t<<ntV{0&0Ohj7}C@O+({W-trtru*O
zHE7QnVr^R2n7W&dSgduNtAHMg^#I!3EB(QHJI$BT>|Uxsbeqq;cxkM4Pbzq$`+FA-
z(7_rfTlhSw?ijH?bwmg$122;a5skere+^B+DJc95{l+)%5m2DIA@C9dS=|@j8<IK|
zIbgr;RdG-%;i}oMD)UB{`O+t*ep<&9jCynnZzGM-mPWUaK{BX5frbVFrYs)3v)Ps!
z%-|sJ4WR)yEYc#xT3bZLsOhRVXJlrYz&ES+hE)QBAG~MPvVV=#GO7I-0Lz(<V}3>a
z_}S~I?!1=^avqHZeVyz^kju;!FfFfguzPKT@bQdh$Ex6u=7Dg_*pj(T%Xd-<E^aNX
z{aD{Dwm)GFJTjaL7h`t+qaa!u8#xKtEOT(w3xNZ2InQu_^lQd|iev9Hv}XV4Lqt%M
zKpvdASqw2G7I!{Lp#LhW(~VYgh<X}Z%0+ooF#S;@ZU$r!2g5(M&K0(^T11J*4i^mY
z_2hVss6u!DO~FX3R+4=!>Lm5!umhAh$yF+OQ7Ox(DcIL_kX;Phut<%sxcyUe_n44T
zy~SeIK_|kh;QQJL+rhWt5rfZOFNH<GL^7ozgs?mo78%YAbUzQe_hj}yK<g2TVLeI<
zk=~v4nD<mWT9KSyN_d#mGyS%EGSQ}2uS9fnnysU>j?%qt4W$mCJwpomCj+H1_`ZQs
zlKrhME!JXsf9ZCO7VMxO58hiC(n5!(Y68!}Q|HMU!I*&&P5eYOu{L(gv!LkK6~muR
z1;7L|yS%8$O!xPGH=>Ut$Z%lV`%EHVgMDh7Chfy_!eX&Dou$G)?sk85BlMU?CQrS9
zQ53I}@0iBmK@8rYE%AVO@RwCuW|EtcYC>&1D`nN)ZmpUgMTdG?>9SriP<Q%&$v1T(
zHCp~bkKCG-Ucjpvl$oJLn8(PD&w<=3>+Z}%{t;2I+XNr6QTd61ta`$tQ(sR-^hfLZ
zr_4Na1dc{Z!vd<X68ms-Zv55C2gj%kh}r~}G}5PTb^NGmVCGO)pW33z=V=vG))g5#
z-D){W)X06?pSrG=z8|{P!dOfMxmM?HXsjFOu&H;7OAV)*+wk=t<Z4>5$Z#T4BXMw}
zb(&j7%!+zmzu2vVv0B)*B`|9Ik6c!Sia!wyT<PXxWoEo4qt=egTt&ErG_o}NB!gGS
zT~|(Ha7EZCx7*C2E)MZObC=Pl5D_=Dba<x@%Dkja&)!#a_=98-!?d^cqhW}A54Y^J
zp2GLb(Q?}2*Oo#ZjcR$uat*-+ZyZN7#dgzL;OhPg{1ru$mBt=vd!ug}3;a3U*WEEe
z_HG6;bYrKWoAqgG=*D)@0^vLXc}IOkwEp!ri1lA9KXyB;{}S7gvu1Og+RUn54UYlO
zqmi#FcXK<Tj*BCN$;kvZ9?#$<nHt5hTpEL~$~D4LZ}Rx2;OY-}@=`v~TN$)%v+2p+
z1X7agXw)Wj`@^AvC37h-NBSk>R|A39A3fD?9K+79=*bP6{5T#aH~V;VMZ(07D<W8Y
zxOq?A<i!h#lj+5WYZb=J-O8=|og**Xy6*=wa$NgEAdd&Hw1-(r8j$R;QHsRQ7etz&
zY>Ass|BC*hlRhe9kNKuWQ;pQEsa-#>=uwd#Y68F}4|svJ5nr=7njM8m;Kljg0z^<2
z&~+ZNouJv295^C(1W>1s6X$2Nb7y<E>p%BiBb0-5UQQ!2NQBdl&M{gyWOH}baYj;(
z_i64JyhY>?o`$n~mCtY@tese6t=h=TuSjR+UD1P+;}u+IlMqLC?a=$%&E7Y}^U9#X
zt(HusLygmKw7!@gnj8bvhrhv~nMHrbChn8|Am*~!!#$6MT%<~Ptj&DIem!#=eTxsy
z+;&*1@62rnr*;`Vcc1JdqXl+qaqOuVv%81wyQE*5L&Fj4(;eAYs%9QPBXwEwO8WF?
zyv}0RBkW++qV3yFEN0wo!=RoKpQcI=|FoVc(K?{EIVl0?*;^r4Tl)FN@05xT-iLpI
zBWixPtn3*NPNt&w2JlNjdJ$G)D5-Kdc_SVS&NZBQl-yhh(jx6|(U@<4Z<hicC|{z4
z*HL%)R^0{7BGKAK_Djv2IUJNr+2G(iOAAV;*y|=C$IjT|t!$DNI_Hc{^+5pR(UNLU
z1pk?^i>&yA&f_0KHnH1r=*g)6DBzif@=k-{d6Rp1Z)EJiWD${XXM+HX5?S;(wI3!n
z1{6q&wQ3dmXlOcs3xBY&*0V_%x}rj-ozhv{LH!#6HzU1~9qH)t1lMC%kg{`mXw+Sw
z_5Tz9aVLVTKZAI>CG}0b>N?pD9!^R164C-pw2^qf;B}>2gg_5I-8zhc#qh{Pa`rcN
zu1qu~7k6D{uXfe98S2rN!8N#i^J%+lyhQZla4m5;SK>6zSo!g8^Y~S>aVLCln=f4P
zD7Y3pYO~)sRa^^hCQb#9f>Xh-LQeJDg*i@@x{Bv!{#DJ$_a7I^^xJC>HoR6CUhufV
z?q*EqN5(H<I1+lrVc<5j8hDLUjoZL~;5=hGd5$aZG%ZcZ*TG4sX%Vg-57%Ee&bC`8
zL%KD3&0TO@7oPRcZvJo-9~3ErNjZSWbo=`AMNOC&?9DO48(YThx}4PDtIp!B`tu(o
z+pFUNd8(H;c7QiWzdPO7NS`X_G&Hy|RYQYS{>@>7yMA6dxF_$mTRu|@Bc<=|<&7EO
z-@MgY@O-7y>;Qtl=Jm}lI_F=*hv%y_zryi1kZ18-skpyCOPRF0dwa!rzS!oZME}IV
z%jtW0fCpg$+9A~Wj(^P}3Sy37;KT=bH|n=)SbuKZdHUWq{KqtUuOz&cu~s}i0x+Jh
z5X(Y)wGoK{Ge-JV1N_85Z`dsF;{Fx>F&-}{K2M$NC(0=N2ISjbRi^v#X@hb%GM*i&
zCQ^h3u6%l4;hrAH!uY(xzf(^7?}2cT$m@m5rtd-s9m>o)=Qp9(8=w_&^wg;x?J!vS
z=~f|+FHUP^6z_5+>q@^I9zY_0G@^%w;z^l3;2V;k+<64gw$F>_n4Lbn@=@UOFJxfu
z6_z`fk64XErQ*i~Ga&bP#vl1LpcZBK@ii+YBjUyBe~*}6g1a()r#nt*$rK)+-g5N@
z-`DoW^X&S%;PN}%VPiF%a&O=6hj=sE6c5e}Gur*CLH@V_I=eq})sT6m^P=va^($R>
zds=tJ$6x5WV^`Ykq?Y#!kFV{x`t?qQhRttod^{W#RiFvJiS{I+&($b;VjPU+84k5|
zaTGd5_bUq-&PV=`mTwAD!By{a0vx(FJHYHc<4kgD5-JHw>@stBS?Yw5BR)>8^b37t
zwLLNR6()9-+?IMNIZ6{~uNird@Edjwn~`XvQ+w@|;}H@Hvdc)cndG81xtMC%_6UBi
z_n5Ne;xj9u_cP+bNmETJkc*ES&YzrU9q!NHqEStdJUqbf<yGRyzIaSKCQn)e#bQ4A
z@}Uo?G|wRsRS)o1E-j|i*C>$Q{PZF3;z8bq2+(B7@ww}VjSE8=G5cr1pTjTyfL;;>
zrTa0AsN&i4LDokmkaJ>0;GbT&mop@E0vA3KX*txnLfKqN9syN4JI=?AF&Fx`>8OY?
zPNF_I@wUDk53x4Fc!vGCNG`*|d%Q!UEG$_u&`IqV<``-1n#=SmL8cvZCzpA6(b&jE
z$G>Rb#U!1{7aLha2NVFTrRl)O+qyp9WS^FTk-F14$Q}9*+abUkul(3wO0fIE&_h-x
zyvNUF{!YLmNmQz4N%A}ftLi8rf}8JWZ@>N)I^;Av(zCD3B@CYS+`$3g&<&*uw-Rez
zq%)Ljs=BnjvPdKo4~F1_+OUB|(g2hq*GfFHJ+?l1R2RHv?w4#tC5AV;Ec@G?$^&xH
z2_Ngry4+Q!b)Aoo%|`Fw!@<(zVayV=g=T9EgFh?uFkogWJ)X9+6nNs|^kw=tP{PUe
z$Ho1`7-@(u!MR^mlE`+!3eJrTJ|dRneCn7n$fduwmNHj@j^tuev%wDUV{-4MzYX4t
z2K^uK);*O6Z$<gH!|QEr^d}}0K}k1wKa1dPzb_Bo{<O3+cojS$y&Hp#mbv(Fd=v{L
z>(5-p%z)3npI7w6lHO;2wTlg9IxfKxl^hJ>l>#w_())^&&F)%Z5EYn};b+fB9aF+3
zZZT%Agj|4Id{yt1{O(zgp6Wu<v?dl+nyN7SwCAAF#^Ad@cFG4mPnz4P3)SS1bKp60
z;eJM4Fe~0IDv|Lge~fn8rEba4>>u4(^+A86T%o7$74@@jlIy?<9vUUl-FYv>{8UK!
zHU0sfeP>ck_6}U>{I9)dy>??vtcy<{Vr%d!2hpO|Ke|{}b5*JA@d)}>*`JYlm4)@P
z!E=k%p<u&gLxF!lri4D?^~sstCL5a0Jjn`4K1fD*&HCxD;B#^^m;EDK>lr(#F@YML
z`==HUn~NeR_`mv0)44Hq^x5<A41BRfk9`<gJox5hdHLzpd0HSf;e8rhvdQV8K2JaI
z|4IT^`)oC#|7d1t*G86pOCv+`8(Bov_StGm|Ix^?;rY1>JU{=Irrv!s2T%KKHKqTe
zbsCBjIe&)4S4Z!|+c*?*Sf-g7l^$;U*KXlo$n3D#4Q3zL3p^;8Lp=C=Ts|J$_5`Y#
zG>YtRMQ(lzLnNn83zchDpn?K>S%IGIyHcQnE_7n@t48H=)~r^}s3^z4Xs;Tt-+0vT
z?<M;C&4pE7b73e%iT8&SGzq{?^Y_Ys1;AS*iCUQ#-{?WSD(!bNxG|MetW{pMkOrxL
zqyhEh-%KAt0QSoMNO+JdS-fc)-y?Obsj}8VGy>OT#n=4AAXap-Kg(gNc<5CF2$JRZ
z(^aCnRlE(fRI@+ZzI{q__Br-uTMF8sT^%nm2o0LI7ptz)YcBHQZ1JjwaGR5dO+F~s
z`zo(?i9|f(7B8l_Z%p^?6qo!V-PzCsT(4lgUe5t2yfirFPL{6OM5FEqUD88aM=*Bt
zmv_%4qMKq=wep@fv&B&nUEXU~J9y7qjtXBeECg|Jf70@Vv<H6E8TCQ^DYi<%SAR9f
zi~Z!N6SN$;r#bs>VXe&GwZ>Xcq%k<-1%7Y8xr`mWD0`AU!K`we?Ni&ZKVZYA4e^2C
z(&wYy`X8j$E{8#4xN~Nd8f*KUSusxdBwaTK`yLl^!t5RS{JM90wb(94`qyD(8iiK7
z0lOp~oK+j@6ILkaW^()~%|PTIjg2^aBIfB3DaMt4)o_d`2}A2){yIBQgT4IOoAtM<
z5W3ao-d;7v{Ta>=ewFKwPNLN-;z7}EQY&C~y@m=HfO=J!lCJXznOeQUs~V0~t#`Cn
zRgMyX!V|}$z(}ux=D5q#b5PuRC6ebEX0eXN^;n;~K&}MSvi2I&b!9Sabcka2{#(a-
zCIlxln^309wTm84gv9Wt>rjMNp><uZ#!)bvrS<Y${*C05!<8A#AynGoW=7*;_L6?}
zDh^HwzhOCh6%$p%X7z*9LK?t1zcyQ`_~xPjU?@3qkeaJ07{5Ru0&}LEf^`IzfkSsO
znxyN@iLMd9c1c~(^LbmE^qHMY!_!KG3n#d(vF41-AHssD!IPyC)pbDa!io#Mkg24M
z*1vXEu1RXS3N6yKOv>C2h@I=LlOLuIga3n>G6=4)WhItXjlmPz<_upbyrRP!UpjiQ
zY`e8DWKGH(`~PYCvWGJIP3=ScJqV(IJUA2`isotq%V|q~SXba_OmLY5d&fbNf14PU
zEJ{*`vE_#D=Jn13!tF0);AyQ;A<P(&^BO8t7X&}L)>wg2(`NN)*AHG5dhD^c^ew=+
z;6|_>obq?KhN_CZiDm6orD}2K_DiRu0um2qsl`E(_8zSm?8d<N9{xo5=t94GVYFvy
z!e(jlk{b$HW+Yq1Jo1KP(S5_=xI}$}$|X=>$bK<G5=O0RQ#Z{1<<0J1*S}u-p;x<D
z`nX+OHd3%3Bg&aq`>22FD8HuAt6gF3F7azv>udaLY<1TZ`qyZ=`%PoK-t9HE&|Rpv
z_8MF6Uc+*)X1L!}?qB<;I%!zt)s#z_Si86`*z+dcs4wwrS9sM6y(XscQ3XWn?a^cP
za<6GP&jwsHJWXWH81K|_9UXXCfKGFv2J<ibWW<a7h6lZI#a<lE)WUE{dWivf_-e0S
z2mq=WVbC~fav`&nFV<_3$@?f%8V}AG6LP@C>TLqO$-3%w@z#BrE?o^YjcTu$s+OgL
zs~H1ou~{PayMJn-xaus!lOn$r`lk-}XBl&>-IT*th^O`%#};cswurWMaXk2VJ_xGi
zY_}N%p~m%MG~+c9WRIigCN!+xsbfH|*HjMFqCr(EuQr%7uL{a4BsJoG0G?$tr2nw;
zgwE=9%9%|Ly9(*I@~Y050Id*FbUa}P{kmqqA}*fZQ|ujvJTmT$9Pg&w)6;oW<yHN;
z4;+In%2bTb)IcRs0eJyY>d#o`6~W78kY7388w-mY`J!W3n!FSoaAA9e@te$WV9iZX
zm+8#(fk&}WPZ#`G6gMSTF<<^E#atB9S$%NOtr|`lwAnt=U28l=$>jT5dk3%KG^xd~
z&~I4eS3l^d7i#1Q-rr2sJStF2=6AveZA+wA+cqd6WYsO!a&}?1Uw8c@{*PDs70tLa
zSmEM1IL(!lPyDJg7+t2G$9X|~wByHIGN(@9wvqB&+7=(bixy|9nIK~I!PkyaW&1|@
z(Ml&#KDw{Xqog0$sNb@RsiK+rI#8wN#v7B_Zj|c+9@y(;w)|wD6G2pEA-0bk&J)4E
zZ;rN?TKIKW{d7*Add1@zBV;i}l+IFX()y~Hss-QeeAcL((RyXqD(_7G?NXT{9(WBa
z*#A@);}NjG-1i)JStssdg?h1dn9wjv3xs9OmOpNcK5%%+i;u)`e;j)4&0g&$<eojb
zN~|bj;60Hk+#|~cYPn&#KWj04N<5flyrrt#ZyfABu0C3x>*+NPHtAwrJox=QCtZvl
z+|tog+-CG((Ivgzpu%bw@n?evSmQ=X=wKz+ZgNt9ml*DiE7vfORj){UGc_J1d`}6J
zR*6v$x3R8~0C4Kmh`)sM330`PeMg0iM60gtOCxtpC@rq)Rz8mJ!9?;<&0hYCi74uB
ztj$7N$a;xDX0#yUoo(Z&?q~`Qip;NqP_$Dq#c@DOqLNK<e+p|GeiX;<#9_-wel+XY
zOkM8&4(nK+YD-}~D&~+hg^O5jkFIjZ0faTC<WgRfp}WyIGXG&rc7ATJ%9rpmNz&DE
zH4|}P1^jH1Np2fsZGRyLwGERx^hIf1h}$Q6sWbcKWCaMoVFdp4ZnSk6NpiQk_S_1u
zSQRpqRc7T7=@*Tj2S}^X8Gph>GnMl99ihD&IsZWuc<KPo4>jVmpQ5h|Me~&^4I*Ac
zz0(6;;oLR+VJB_eKpV_u__hR>f!?IeBVLVNFD+H1^Q{@!<JoLKsdh)yZjQ|pDWL)$
zf!a4qc)t<NCFy^`TD0Y-5AP1+T-vv%Ia`A<021wTXzr^94E>zxn3Wen;gY>}Ap~6>
zINb)^Qv=41E!<CSsURt?5ZTpC9r`)Uy(xI+2F8nSGN;fotAS8hZoLL!d8JW`EC(5h
z*wcRY#t@HSVX4WKvhAj0#2evtWX&Kj%_ccwO>CYXwRFMF?(-dTg4nz($OAdYHw!uG
zju96MId6C?GunUQe`#RN-??d(p2TKGP#~k~@kDaZA9pRK@kCe0D;pEZ-*jJSWM|~)
z8=_4lw~(93@(agoBhnqQwi8)OnYY+D0Ko4CfNIK^CS3SCxu2BG0A&$x5ISrDW9Wju
z^g4nua#O>(B-VPnD8e?1L-Q}ndiF@489vK8nRjPh<{qra@@D=@0x{*P9&Eb>XA-V@
zlRpL(-MnF!oIM{J2`>qx3yvobQz?5m5<U~rux2uB$i@3IM^Ty2wz_RZ`h!L!@M6O8
zn%2)_7wG_~P%8bUM%0)@EAR^vxkhCy<5*0kc*Hj8c^Hub{LyR!#oovM=p-wRBiQJ;
zPFYwHq6XU<G{e<6=1^a5Jt19NXio2MB*1a$T;PsWvqtQ|O@&(x12;rhi<fkk(zv9e
zi#r=*zY-;HBiWIaanwjgbG}pka*_Pt%D*M{F7of1>Zf8keEL@mL-TwY!m*ZFtMG7b
zxQjb9jP#p?m-=qWdwQ=5&D$I&$=n4=q2jxsqAMW-e)bj86FW)&Ee~9>Pb8;nG%`Bb
z>Whb#WX@nD$<3r@gB|U6blZVl?AUnQ3cr2~A;n)zH3koF2J_Eah;$^ELJ(TYi=QRB
zeregZXR3H{&z5a_rFL1OIl*9>>%zhCuE|WI=z0?i1rqNFF8voM>_iNf)r6LRG4(R-
zy*!2st4kVlIM`ql_F^M4L0$4K2G^Zrv;Tufn$$0~sYoy1sv<~+8fS@(v#e7E6cu`u
zLfKcl><=8aoQ{wCfzQ!sY5sCvdfe2VVpEr@$-#Dr!FC{6PmZM5{QVj9hWbd3A=@}e
z3nN|!gEm(}vPex9P|4;aIoIYRJ0E(<t)KrJo|7Cr4LNum8ST$(TbJ~h*X1FOZceD&
zk#7E$oEd@gPtSpJYjQJ5*=$b#TbfL%rlMf6tSoS>9+hDVNd&4>Vsm6#GH*Z|I}!Fw
z80gRZmeQquVSlcZnC<U?x3>RU3i?Tvg{Ay{>Y8if{I0DrU6H5u!4ppR#()mZ_Vsj8
zV{o4mZ^;(s{K2$r-#vEyaZF27Q*u6KT%=-b-10jZ;I*F`o1=^6dBbdM;noIi`;`Oz
z0lY(V(QtVJ-cg^t`&)+NN~Vv=o--dfmv<`#oY))-PJeF=66LJH5L);j?c06ErG5pz
zm-b4X*s`@WRmTB^h4p8~w_?ZEu=}m<IJKhXLj>!NmKhzpUv*YUcq`{qWARRE=nmj<
zL6DDT0L$J+#(g_hFrz=VEl;rn?U5;$1D-sNM?H1wi&%BZP17q2lIv(E`62%V*YcPa
zJ*rFoBA0wYesXbDRJxhu<cf49r!m*Yp=1RY5hM;_Bw6wFNE`vrpnYrT2<0`BmzOb2
zO-)wD2|HA>Zl)^lyIm_?s7jVm<SKC?ZR>NAz0d0$pXr+>6}8ML?vXl-!6t&<$Rx=-
zs4rPM9?ZGc_UK~BNQcu&U#~@|({9w)FKOYy*AZh=?_0g+H&Sm^u3p^L+byr&d}qLE
zZG`clqWyLyJ1zIqsUul6hx_&N1a>gT1W16ylchM2sV%Hcz6{R78au|rjb3?|+2W4)
zXGsnl#Wf|2DOlgeHg6AR0lUJpFX}vxY`!Y_8DLte->cLkw*cg5J9B#Wo&6ox#ryEy
zvfi2W1}`nKGY=57N^{+jJdkdXZQ{YwTuxuxI4mGK@IrZmROTd}TihCziM3Y3VzRGv
z*Z(7Lc&~H{o|lN|mH<<yg^CGOiZB62;+Cg_@af;|&Z$dMV9PgqBYIqNij%iBk&Vgg
z=pWHn_Sdb9(q8QwF6_(fC1zhoFFZs4mHyIFH~QZ`@Ui7If}B#ad}Kj(Js)K$KHB+M
z{1hKg@lmmakH`3ke^6PFU8I!9Nx7eo^^ftffRCAf=Ho^_R{WliIeeVKhg~5n_b$FK
z1T#v%lkchSd-45zH;3Oh@O`rTF1Vg=z1^eyVvp}(?puo~Gl=ix)ZEb5wnRg(08P$y
zL5S(hZWQf)U*^tRIt-L}|M33CjN|S*j66mhaQod*+Ri115C$KUd2n&NcF2NcX|?Xi
z6TvV$=b@N_dSk73kmdZYoW3o*b4gDy&qEab-F3j1^SgbuTEzf5t!FcP&~!s_yN)+H
zj<5<i5u~b7^v5G}=f9*dxxjpzk@bk?j_ZDAlGo7y)1;NKdKO)DTM1EN?vH8nW22XH
zD)5-)39W`2&;Dfp(G@?-_8?D6XCF0tx;QvqLJ@J)kQ&E$7h_s=9{B~({vEVso=on1
zELu57(aF3jq6O)hZ}L|{RXlj@1#Q`7ej>$+@8wlpD7zM?g2H}<h89K*#d8hyVHy9;
z<R9{XuYA369g@r6WRCVy2jTBP6JpDB&s^?d04a<*Xc#}o!{lZ`Qx}}<pvjyMVbJy?
z*0*~c@xr6wIMS=h`Ac5T<1Q!ru)BYB=Lh&1Q`VP3b@Q3XgLdBO_0s9vc-wnAii{qH
z>wC|Fae9BgmjVWOG9#!G!MoQRiFmUlc6;l0u{B#b(3SbfmAPqsNJeG;P0E*)zEIbC
zv_5N2uEj50>081UE3b5o{KqBFaLLSvH*041I%kjxoiQr8CW8Ak`lpoD#e-&EKNta1
zX<@EX*y0g8R%$Hc&h(JHN)P5L^&D;E{d}JFWKXRR0@+0*HwE!W!U;h2#{5Cz-t_4X
z{AyS4DOV2&2PaRqB#3|Q)!Vn50F`_K*M`Z<NKdx#Pbdd6R@cUTu8qs{`o569A11je
zc=^v!-)*JzP5Nh+zC4%S`V8sGf*K8gUK8{xWNqZZgT>Ti1DdaKt_27O&W@0jI7rU3
zMuH9)gVwcP5c~j)$AdS(fX$~EO0&2Av|aRpF1mVh#6!GUTD-2Et6e(}hVAHaQ0pvJ
z0Cl?vn0Rs?Me2j6w(c&y22K0RL}Ca-ZM7_H|Dx$qE$e2@zggQ+-Lze8GU|iGh43BY
zT3+S!Oc^DT%MF2yz3HlN8T%^6?jlEHL^V@@>c8x4{|Pm&W%xOC*c5zzL9THl-Ao1T
zgY%f-e9WJ6bFr0lgwOt#KBO~UM>R0klpGMjv~q@E;yOCkx|U4;W{tnnvp<=~NpWn>
zDwRi*cztIja~=7FD!~}_Clg0n%$+YdMR@=Cmi1mr>0mDu45lCmyy?YW&9HeDW0uaR
zpZGj3+2&Q99M=hXT94oglmi%JiFDRVKVasEZaQzJcvEBWsyl9ZRZ03=fMt1Oa11(8
zQHuHcAhpS#g8gs$2j<o^`MT9(UY@>^w#|}lq)OXY7!O9SSP;}(wicy6kc(8A9AO<1
z4<2&FgS7tl>|>Ugj3@7oT0CDZn!5;aTjAMPcGgbx@rEDMq{LdKZWMR=4S!A0i?zzJ
zn?G}%GSDcCeTAMWpU`L3z!A?nmjjGVLYZDW>2c$Ue~ei2RCn(O&W_~l+eg=*k{0(1
z-?v@6h<4(^!$*eq*XhCjM7*7*U($#Op_UvzMz{q>cU{4VEV3jc%Eg#;E(c8T<Dw0r
zZ`H$5&u=SLPv}T}I7*GRo(Dp+t4++bcB^vjI`1|j{_F#J^do=LtWRBg3OR>}!&Ned
z(9MWxAcY)7qVdh>$Dd%*F%<m`jfM2f;A5@J9M<rs%k$d(!NcWwl5C#{$kbGp&N&R+
zyykrJhuo_At&oM&A7yD+|LDxp)R1*al(js{O5<ZKIWtQBO)hydk}$JU)^$D%{&;ZE
z;AlRMwfTs(m4i0TiTtEqM{8zp*c<;2I|#4tekzh;4AB;R;I+#r+|3PDc0+f0Tk%{>
zQ6fW1nHHPX?b-AFQ-+~7#|w+7XWxAJ;l)MKjF;JrBf8wcIY|p?^e~pk6Ze&K4aRr&
zPhjFXVdAQyrr@rqTIw9{69^^f3)?X3q*PyXkl6Y=)K3_0iZhu458>^qGVGDhbXW2%
zi$S@_z+8S4G%eP8INSQr7ft@D^o!>M@K*2UM=6#$8uZb7*-7*+FLDP)y~kQVAzzrS
zE?O$!yibxxP%2P-F4Dwr=tBTFw~f>ITDB*31asr3j(Npe6C^W6@51688JLC#2V43X
zEnZ<9Y<rG_A!T(kG32aL&W1vrm{_b;*Ddx$29T$n-i4RNTCXh@e&A<B6cz4hX*!Tw
z{GJbZg5#j~=R1aOe=;)2jpW0>M#w06D5CJz58c4LPl7Al_yxtKRC0rtZ{THp!oi>R
z2}8DbtBoYP!PBQ3&MSfhf7BczH5^&ve1{46kmN-0tKa839J@PaLZL}PR9F0*x_!dB
zHHM0FckOflF=e7_)m94-w*8%bN^^L15(;Wco<5caBy7BkVX~p2%%3C1GSag@ncq-;
z=!=;*`2#86N^zr#-Vt1~@+krd@)gUMkZ_T@Fvp#W8Mh2(V-zs{<A?(4NbZJ&1%iY3
zZ=5l0PIbe0>k505=2cZ>zC#Ug@`tGVIqspMdeiRaK=_o4fDnX_m=XuVJA5tEjT||_
z3mp*%e<L{rVMab#H3d&{*6SpzMWUP;MNn2#u-62a6K;{QHc!2P%ZW)SDv^9$W8fY>
zSb$q5x`X?74G47_<<FkKtX~LCRSuep95nMPnwP%D+G0OHJ#MRA3Y6eMaJK{f8=z$o
z{R{sgpwmw42IwX-^8no>t|&l1X0h%J(8ZJo-KFEg+1~HL92FAmB1Ctq#0)p%Gu6J$
zxX55xEF9ojA4TY%LUK2B?@QzI&%n9T(0zs`^Hnjja1;wUv@0ivZuvpBQJi7uE>{B@
z#Sz~!iua)h^i>Sx{AeKY-{uA)aZ#<o%q}9^`-GNm{367MakAf2-;L^CzLxDBj_SG(
zqfvPz?|f9#ugM?P3wfjZTT{1DjZ!ZnA~&kLqfs?nyz{v!r949t%(fC|JP-~kHJY)o
z61TWP2%P~_<VNrYU&~-1whW&8z<Ih|OQM56^Aw+<K99zqj~XwF8jrO;<SNsF-`T<J
zTn97MK}p!b&*;Ei-<_T7f@#fT-%UXSS7@E<?0(e@C;p+vZYcV$dg)weUq>i9>Y|;a
z=wk$BM)9MQLljN;O@yM5S*`s%N4oz@S%;!0_*y1SBWMhMyTzgC0TM$L-Nh$7Gr2+C
zi)B9Yi?I8Wt}OE+3Zhas0cSEk%Qm{VhMJIr#jGYHHWKpAq|0GWz{*z>E{ck$_GJ)N
z8iXXMTchN3Und0=b`GL|9^D{5XKt2pM6yA=osFj9O_IT&8_B$ilSBQ9P7iS11uGcH
z6(_^5F!s>FtqF!Hb~B#NZHcWxu?AY0udW<zwnzb-3>WJYPJY!{u*)_wIV?CJLf$3c
zQt(F<WZ3I#!@0ZX{@jW^KF8_%V73Z4!ssp<nX#U)z{j$}aOm&79}Rso$=^QoUp-B(
zjoYs}84;{rWV(UQO=^4r<DqcacW6_r^6XD$zEIDwuZ%|XU}wQD!#>A#KCfy#=+xo#
zTEl2Ch;A{B<i3v1+3+izYVVqNbLP|^(4A=hiZRq|N*0|G&cumPPhIyGiq5O52&XmN
zOjkY?j;%cNCI|zoyPg_ib<D4GST&L~#_<RuT8Py@Qr=<pH+(IFe;GmDn2E4@J;{!m
z+ABtptL!e~%q3T<bJIM;TF-FZOQdNE*4-Da#-D|z(3uM5%Zqw+xx_st4f-?fOdl*m
zlJu*_)0}2JBaM_(itdUiSwF2;vM1w;2N&lC)%F2mR(sXS0xa_u-@LT^#5zAU>Kt<$
z37HUiF_n$T|8>5N--tY468tp<L0+|xCwY9gTpO)JzznDl#bMz<tTQ-C+cozgQr-}2
zn)(iz&3r8bd_(4_@V-CRI#LCq)d@)R%&$vwtN|8$y<C`NX-aMO9fUB=BJb_*%}pT=
zlTfes*JzCn%0goETmw%;4ai<V4cuT2jOuLQX=`9$u7QfMfxo#1E{_`EkYWwIY7O-2
zY(S^S(9X#q7|b#fxtmh0DHstoFh~>lzYflLaMWG^ED3&y=0R%KqzSZj!SKr+^+>i)
z9|&ISr}apFOs^41>^nKMJWq0x;;k7)@JAMRwL*y@ZI2dQX7V!)1(1UOoNKe}FVTVq
zuS6WzS9m=5A0%}FGdLa+#ot_UBMOzP^eo0_W*!CGtA>zLVD=CY$UB0sY8df5@5xQg
zD~8$Ol7S;5nh@M%xyk)Nbnea}%8b=|oY5gy2`EW}()y4&q{hiipL?UcCDMCRh>v)v
z@5#LSwNdSO1B#~_4G~bO8fe7;dLF4dTuIAA*$QJnW-d8i>_(S9&ui&9QML<X)0u~v
z<`Pd(Bu|g9`zu#IqDCa(E@9m#IXS)>?3(bh;+GLGIE!YGEq;i|$d}0E2o{lBHs9rI
z8HXBMHvQglJ99CK;m+KHPw;=I4VA!)({inrxATTsxIff&Y}nALwkB7^N!h{wNUF2b
z^_8s4%)=ew_y*Yc7DnTHnh-j`N3*ml^65IhrySC2H9oP5O?T%g;TOQ+Iv7V+a0jsl
zxmk8&Jb|xey~8mcE+Z4Wt^1yX!wnR|)ZXn@itXKX!5d3x!8WkWHsOw4X-Tvh@9BUQ
z?RJ^G7bpn6#1Rw02{{nkeghsw{98qtlB{1y+GvgV^Eu*`6x8frF@WMtNyCoH-{;Cl
zoIvNF{AzDGB4alcQls549_$~DK^vl`eh2_IL4NVzg7BFdiBAdPk^;3OCX(|b*<^48
zWY--rlLgH%JE<s)*2dqJn~TRCo}ss=k@G@&dxG+AF8;*VG7f%5Z@+vynu`S_M-o(b
z&1<N*C}86JDpOnl@z1CbEyqcGgY$n%oV#L7Q?PnL4w_e?4558<G@=RTbfP_<=j`X&
zFr}J^cvfc{x>3L$&ImZWNh>506aR@27>@8&#Bw*n=lNO&_q7o|@m4g#C6e3!yK3ej
z443{-)y!on5oM&BIg3^!)y(r_UCz!}^i=U&vFHhB8_3_nqW7XXq3iC5MIYgc??9#R
zGq<4JG>Sr3;?9WK93G)+#hdx4`t$n?-%ywo5BR;S|6#<e_KND`Yt_+Wcycsi4#rD3
zvf9&V2WT<@s5h~O0!(@++%)-fB-Ydg|3c*s`=z94zFd@;7?0w%Z782j=<vk#4>~y~
z60Ts5^Em$!wbB&yYwFJVKT)@YcZ&3f6Yq#ft?g$tfh=SftGe&3=*&7rt=A{FMx#Bn
zGwW!wXs~x(xRUyIW@#fK%Pbj$<Bx8Sa6Hni;n7e|mpb{MLJ5m^GJZu^yrnc{9OeRU
z>A{W|X_wg9f1o_=n)QPi>FrUw=?6JlRSFUvt!75av9{}l)4JqnWhutaPdl^zMi!0P
zQA$9Ljk40GlYB}vtfO<u)g(`jk_Y6He?Zq~M_uodOWv1m&yTwOke7Qlqp49#!A;2W
zoBs(ty$XTkF|ab7GQ>5{{mIU8@O_7aD<eQ|&NUr#bk<W;+Cr;<YggDB-1)guhk{sG
z-0RrV+9oE;22Oid!XAK-b)H!hLUa{|oAB{D^kk>FSI+{XTFr{Ahks2eQE(StK959q
zUtsUY$QKbWX2kv-*YPhmBNt`v<72)buJzCl_a89FrF*|+p-M&Gxo`iqiGqHME^>3J
z*F>pmm(;GIWWgmbt8-p?(Zvt*kLK!TAN*oe4WW1&CGa1G<UogJ+Nx_MRok8@5eh!#
z!Q{HoR3P`Jh4I*EFr0|X{;tql&vTP_p`0<9y^A3Ez!FlQdh4@q@Aw|Z)&H&>g{1ps
z_lpM)a!?^qAU@&8lya5vp;`H?#pYqHy$5vm!oo3*#xRCnkvfmjBz+m`@M8*G!f#gS
z+p=usd|t1SCQtHB!OUAiYD=GB?_&o_8ZO~F@0=(j^&WOk>-=%*c0YRn%hQgIc(4x;
zO|<6I_vL$}%(FibJUFdnTIUJ<JbiEDuh0EK`poPM=k<|`FV;ElZ})T$d!)TS5B0_%
zNb*_8DG~hh<_JVw(kItg+S**&F}R(Tf0pKo)DexrHPVi+Zf5KU5!?ynEnt24P1sMV
zkG-NkviES?lC#mSG24pd3N4e#rHNpR3*wGlJiCyL@eJ8^In&MFRhBpI8H7z(to3ci
zr(??tYD;gP&RF1XP~35IJ=r))B<j3S(_E4WR@{ZVz3MF!PGf<A)E7oLUW|VQWIL9>
ztRxpaD(r2<#q}aSxF4Emr@~)ZV>rqv^2dy+3;u_<e~={TdlLd}Ob)6y5L*6XYgfDC
zs3}^vW#n=w2z_qh4px=c?&xg|9O{*Q=&_LKyPZb<v<X&1FEPmtjFl7(mr<#sjgyT*
zWM9K6h?0Wij<FTwZZNI^ZVd~c5f!+NFb56x-pF6DiY%{&n7^f-y~Olt18<o|4^=`a
zyvJT(e8q1n@$R(3H!2qoT0jR3?KKi(a7_goc-F}54c%xVcr<44n`DD3$h-@Y7>dr&
zuMPa#;eA1)w>sgy#EXOr_o>3??4Y{fw?yss?H<g(P0Xanv;IV#&prDE!Iog5-4UP&
z+wM;+WVWzkGYg_F>%sh|0GjTawI1YWs0+Oexg(!mhBKN*+-wvlEQ0&ZcN(!w#s{`y
zj4wPkk65ZjEHx$GR}g(HJJuHSC}$#hf~KKj4Dmg9{ixYqk=kVAe_15bPz>Vi)^gw^
zqmS&>UFJ79|5#(4dn@7z{_6N;ZMe55v@@+olZ7nsZ!oC@g2{_p5QejfV`G-S+o-}b
z6A<}_VoHZ@<Q=fz+iNoBuen6u9!{3y%kDXh_?0DZ>GX@CTgV2`t)aNGU5GT<%IHG6
z)IoIg>DGPbU{{5l#$-{#*_V=im}Qq`XQ>;#?N}t@cq1Z}A(YIlcfS(B`|>3F7ZcG=
zr8(YHtl@Z=sp6Ym0RE5HEjEhqy~=$<Hl10}P~p9EzdnqaOnMeaai4d4&obn`3i9U_
zR?Hh94M)L!W&G^1a-JMSb3~2<LOi(r?`9^$8|riBRcEL5iBCHXejX2g`0DNj^Dg9J
z=T)c9Yj}HFpZaMN@W_rIW2H~u-nRX!V=2!Q%0!P(gV$bCBgLzG9Z6XNt2SW_wVJfm
zqrQW;+Pwt^b6n}!mqB&>E`mLFx4Tgb@2VMuhH3u9<#Df}WJE)8x+kW&wZ(dlur}pb
zCwpKPf2nBNj7z|g#T42$>|Vf@c3NtemVi3R@tu>gV1j#ESrXX`+x{klL|ta#XcZQl
z`41K?C((wtvbk;J1oLk?ukZlqqm?^wN9I$#cHUt%<yGiUg^6t|CZ`S;2V;TCm)4b?
zJ(sCxlWw+#gIt+h*O}de?3}Ac=XCV(<RbF3PeZt!^Vu2CXG%q1LfB{~L&|OT`zbz8
zUHdLd)PKP^$^bBf)f0fu_X}RTk&b_$N;2a|4*fif|JTtYex%8`>Y$dD{dxJF2+qAO
z+95YX3lZG>4Y#-*<qN~-;82HP!8*1ShXIHl{&C*|>(;IE>tzhWny}n?Gv1B|zodZo
zD)HR}D~0CI-NRdd=$rZxjBMGuUu<?(-_MneoU<=)|JGOVG__^M`l9qd=I*h&_mOxb
zJ%4WX+jATK)e@XpzTc&dc1OE?VB5m+^*9?n6OH^X1$>+zYyG;gpkV2jV0Y%Wv)x1b
zrC-~xpT}CippT{a`y%fmRJ!`r(;B!u*1C~joiA2qZaXsl@w}QI^L{}X*>yuV&YwGe
zw;tUfewChD-hOlRobku^sN!X1Max$>B3YMydG0>I`v@tkVNKO<2WP+nw6`3`QqTU<
z%@<=NsjW;&bD;B{$rblk76gy6QVo%;=%#tYY)QkYM4exIAK$MzeJ0b>YahDe(}zx*
zOs!3-bv3n`CuHW*&(eErK*`kZArjKDwnOQJSZ#pPWBu9w9%p;;9&_t@&WZODa4TU#
z(d;kX#VY?a^}^C3`#LApzH~SH`g!WfrMuhLMX5)Y?qOdS$J!JKF?)ZA;WJZrE-iIA
zsT-E=YhRbe+8&^c*-J0o-;$WEp99g-1ML?POxjdnqLRui>AYBLEx+bf-n8@(63TnT
zu04U@Gq+t#yi9c8Gq<I=@8@Ib_pE%%1+vKWR}+U@5`Fa5ufg`~XOM+(^F#Y}L9F#d
z{R)Q@YuiQr^8{e~(xalvf7LHXH$d~We!1~n5^H-!Y+HsJOMhg=e~Lp#{Td$irKiD5
zkGEft*)07!(S9)(cdGIQN*ZZNQ+XGxU!&|715D^wjr}5AO|^cxZZ0KIv??E^q_I}u
z%vjq=O8SnHYAp$9^)zH@+<r0CUi#%=r-l7hyn}z1CZaCh)~`nU#o)d~mza@?cIj!B
zbZ)Hm8Gg;&M#KMRRolwh!pG9nEuU3&pGr@$U%)SK{7cWWU(Czz)!a;L;4I>jSOZk4
zwGW_^uZpEVwbG!mNp+L<>%3Uo&sBGnl0LU3dw#4<Mn9RMN^;0%nh(*hbHh5Vd+XQF
zquvLrcuyt$!jkClGm@63>=(1Kn+m+eKl3W@D&HeE`zv&X5o;-K2w97+8D?$+ynl;f
zcvhDPLK@oA>+Bcwb+>-qV8592>-Ed^0up{hs~PF8m)>Lr!0Gw=b!%9>tyKjkDCv%{
zy|!N{sYXe6SrSt{SxLi`<k(v>);3N_-&NA(l*;U@FCi<_PhXcRP4?PWA@e1LmtL#1
zkMz}|uXpq{Q(qhPHA7!7@HHPjaoaI`WP)v^3)`8cDxo!z`J+m7{m;(hXpc8~>(jm2
z$K@@d?ZxT;o>{)v#Pla;&##zU+^cnM>YbTi9+uj3=9dSj`px`uVrs<9FDIopS7cvk
zTQU8)c^CGWTY7Zsi>VdEUr5DzY?vGGIhtR8t{DD8`qO!%d$g^%dRca1D0cInaYHbh
zB~I$X?DdkL%(Ne&?`JqE=g(Q*%4|>XQ;b9XqxsqO6wd)@Cuyq25jT17pc<s65$;GA
zpH_m8$l#&BAT<o=bhylU^w)Xz{`7DAW4Ru?kLizTTfe*~KAgWQbPu*gXP8-ELr2HY
z+Q7fD8_-MWU{m2)D(4}8LbG2#l_24MbN?#be|XLP*>VwnWaK<?lsAd^bsb3N{+{Th
zJzO$P($ShUc|M^?#VCIwzF{``^?*|3O~UIA9#R5Cb}v2(gGpQk<8xV9nN;LeO%3Z}
zLXFQ5Nn`Q@fdgOsIaChB*%P8rUGUL3lNHR}019R}uV1^WWkioytIksbFY=4g_w1J8
z1+h8O#U#f!>ZDL2(CZ6vA`lP0h}%hw{XcXQB6LjJ?Bl9su8?w)XMgl&3f~C(c_Yic
zy5T+pq!^x}P8;Km9OZ+6+Lzfry|H7w38V0igZl&L&GLF!oeBJ_@UMMMA=^1UWu}vg
zEL`GOl!Re_1_Ky^m5cgTl1V^C{%M8YB;JC=T3^%XG)o#9Qx=ZsVm5n!(h76ud408N
z2w`@VU(0P9`+jyXQE~l|qN_d4CEIB&k%aYQ=6}*UJQ7Y?r!Ev*il;A}Pe~-M0X~5m
zgCnBSDF#<!-VW0bb6n(9h-l0NuV^1>o_*R!j)7?wI7psgaABnL_Ubhx7i5R)UGBJ+
zt%a%4En9o0kgocq%3HSfOC2jC>7$6SmO9c;FTsh|XpcXWmW=2hyWUKoa2is(L{u<r
z4hQ*-E-qVovFNRO4gQNSE=<YuHb2mB%`~46mRHi$l<>z4s0-Rp3h9K>vDUAI$w_Pc
zUZ`4JfGB{9we<sfzjh7YuWT5n^=}{9Uw{wY&Vl%+J3+liCb+6zM<>N~!LK_b$KOs4
z=hS#`if7Pp&Cu`Cy@4Cau&4>@t1a<P8D{zy;11)nK@&A2W-O0g{{^@M5RGVLq0|b6
zcv~xd#QCyV>7uZ(9va7IpJo1dR5f~V7B@*H2_`wDq}RJrQX_N`@+Vqt48Cw+2^oK7
zu=Ru{#?{(b2JvLEX|61Ka)i>%ISzX(L)2v6Hvo(LYr2x+ZXzGNzP`)`rL}iqAxE1;
zumG6}>}hdTI(KXL!1`I}>V7vhMaU%c3G)p*BI8xREXsrb9F6#L3Mr8_dwH>cQPH%L
z+_}iz3(6WxH2irxQ>(jo7KQ%E(vd&9yecpfX$)TX++gT_yCpRRYojFf%<1_gX-8m7
zRmH%p_skQDy<QnPL+!r!=8I$|*<n6i1nZ6`=V<I#6mmvy4DLIb8m7%}udso`cr&xu
zwvyK|J$Cpj2(F}%x?yFrm|!>y#Bj!W_D4ME{||<fxt;w_swns_p{T&vpVXLFa*A59
zZ+t^}W6JSpgRgdP%ox966XnH#Vb~-2i65u+Ufn2MAazou8me7W7rbz#O-N>-dfCl6
zR)FmMx{~^2L05vCrXrI{;$etUl(5M~U?$IH#7jaapt6S91ZLneOrT<K<=KZ%-~`-a
z_3{$s-nikoz*AZL%;Q!t0kG^fFLQEmoY$+Hijfv1p0S|IFtE;rFrHrXSn8=zQgSh{
zX1>CT&d&Rhe+oRlNx%DfYAS?r2I?I6<^H~TpxsNIN5sCXc9Q9w1&gHnO`)<qostK7
z;dz(z`UK9sTQNclW3r{QV6ZXxGxrnBv^>P5pNmd5&PhO`K3M@<$OVck$=<tzeLX(u
zhTs;37nHS|r7e>Bw7q%@|DxzU9TtVVoz2{r-CF%=c30Dwoo$c8W4Ek0uKH6##^F{?
zmU9zlgxo(xly=aJiX7E$buM)kL|B*b<D*ccJS{slrl)e0NVKBA6Ao~TcK|($OR@<p
zu)+PEYn5<tv9|NH4O!TWe0Q6)6YX6NhePa<V=p)XO*Hv4f@CX5K!b??%ahasiqNvo
zrIUTkF*nS#RV=qpW|z2=>pVTnFL3_z!z%>mqSjoD)Ql4RvrV{Z73W4#=k(ZD>PG_}
zur-gT<KjX^C2?JdpcY{ghj-(k2nB>%>jFZ(3-+oC(f5PX-d9FAU9VK#0)W$xuZU8Y
z`NtrZJzxu|qb_*xU5707pKk3u+~c^6%Q_Try~P!&5^K8vRA$@r^ly<oH$a<lnsa@?
z6Iuw@tA;94xa7snsS64m>P!4axm^AT7Yx4#ZCyO#G}^RQ_CNkwp=HMI{<T_zV#{)C
z8xfa;iBwY0cLO0HM_vsKl!RLydDYc5`H4dOm0cbU+Q=&~bOi6_QX#L+9?~T4T&g2~
z8kutlI3Mm$oiL1us3_L<13tZN;$0m<R+~rTsE`0NlgKg()OivL1fsU>LSN%33-2D`
z%ba<zY_z!}c}m>*lRj&?3W~K7;}IGl21KltI}E3^?a%6vva&ebQ&;3uU1?sd10jr<
zj>uZUQawe*Yc0h5=|h@sU7P$23Cd~pJ!BY*f3~;sW|TAqwRw4z4%#cqXu$wTmlChb
zW&5>wdoG#C{kQuq2hi06&^Av&dwyXV@sNLjs?#nG5Qi$u@Z6^X;q5)vI)ksFFGkN=
z=)#K+#LxQNzTy0a_wcP?!4NWoU8r>Ei#^)2eMEM1Pd=_kB^%1jFU#f)=$Y!6H}Z?}
z9+zZhe%UXz*?SZDBVF3#o7T1IOGmsJYvnCA$OX2J9xG=a|HBkdP2mH{cr)uYxM`MA
z1{Xv^*nd=%m$X|CUr&^o>Mev?sk<h>fZk}&-F@blSGw2U-i!`=x1M)+G5LuCsa74?
zifc5g;^Q*Y9I;fF1_j|mldInmZoqhD30)0H76={~wXS!*9tEw;KsqU7>6D18=ij{J
zbxSxr30PF0aDz@c?<Dw(>B)^SVIy4300ad?gc1eIXiD&2M2_l{o1mX?)1OVJlnBE#
zW_B07rUxK1B?r@xT{=&7Mc8>npOT=v!-fO=PgHTn79d|C9EOD2AYdZ)2vKdB*3(8C
zY&wkMIV$PTnSy4?>K_$&x=Vop1olQO5noLA&7SMHthe6BSxb5=?RcOokoz($%5=BT
zeF*n)g#i3olmvRcj}oSx0`B9iv^=bSq8=99LK9V<{mC4pJgBtt^z6O1g0v0?Bp2q*
z*%&n(&Kc1az_D<%Sgnlq?2p}E*c#j7plV897-6<=1eRUr>!nn8%yx^X?VjdWfCiQb
zeMIN?{&s$M@wDF|SPlbquCZOxi&2s!iSDO-@zm~Vy36XGrpxW_X=OX4#itFDD&XEH
zx~l?WZ8}8e-|52-@lPTPhh)W5_(<6RS`xuN9|-*7Wc;rrZL*|ZVbc0FBxNkAV~Z<Q
zrlb!n>7QZJ{M97&I8ALm7bcbbFG(>=dOS=z<5`jpu%v}yQhWtTM_AI0VbXfRb%G^b
zWl1H@L2q=QVE$D&<zh7WV(4Jy0URhL<5bZCiwB2|l&M*f<bD>m)rJ@n!POKKITBky
z#Gz}%!B=s4g~owkuuLDWSTgTl%_vp6PK{2_HTq(O7H#RYg6wlU-H+4G<BJ}aHwJsF
z?!sK%+o;<<IszyX{?tre9YKME#?#p%M#~BV*mhA+IC-va4E}~c!{p1kW=?g@=vfBi
zikh*K3m;<~)vq^WH?F9{uOsd7p0e3pz}jQGR%(e`b;PmmO$0};Hi~rzsF})3G+D;}
z8Os2WQ)rp@hilV?1>ETq{}5bFln?D-^@Xm?b|cQtkXN*>RdN7CM_rgu7$Z8<$EAS0
z#Q;a1;&lRHt&^O*_UugRl8%O`G5E(V-)uh(albxUJRzFX#E*skvW#v?|8M-?N(;&I
zT;+YJymS0>#R2|bnXq&GpQ2{Y%Qf@-iPp@{@IUZT;eUf-9PdXZX3`l5+y`cv6XK-k
z)DrJsA8bS0tZcJrUD-J)5*hD_JXXFgG)fxNTrxAk=3j=S>u!YH%=|DF&df103Ke^N
zLt`-b0yi_bNuW&UAugPm9&R4;X67RpASD}vvu+m2=EnN36O7z}n)k{-FO<t_z$plx
zK;txV3e@mycpQA#IOqo2uo=C=M7?6<#hR(CMZB}dgL5!DX2|W;ud4|SO;<lw1L^rB
zCmce(ncZFTw1SK-pz<i<e{YH?VnYtXkp^Lzxia42{+aj4`RlQb`pKe+5i#vb)t%D=
ztFY@59H*MYay8eLe=7-mH&j@#_z1LvDEV8&27D2);_8FKhP+wV+nsPJUPW-72f2IB
z5sZW|OoQ&A$EM)n3qonyJ(j|>?n%-U!EK%CG7_=*`}K`^WXILFT=NRmDuC{I6%{Q~
z^@Ps4Uosm^6R}uTP&b_v{A*NjXlFrPkNUk;h^s>y21l`0b0ttQMxQbwq3SDCjR%=X
z*msf}z$ITNBlrbO!}!RY%l`|FcH8bmB&>j7{CQT#oJ52i1YHpvWVh)~YFwFF?I<~!
zq_gae;IP-}!qv2&hd4|P7bv@tXr7Vu<1310e&UGE>ILgqKL+H#E^{4TK`xe#F>C9f
zTwAxP`u=KbU{^{#fLk`lyUwF=w;$ck4Xb$9Kp_0~`)lWKFkL0@>dl4Th9l$Ls>bHX
zyk_2{SL)))n+=8ukDAd0{U?HhfYuh{j~ukQE#a#k7NDasxbB8;wsSp@Oj6eY(-&ZN
zr2QP-_dq>MM7PmJ;&P3_$<$8{%T@j>r?R}Q=j{1kYydW#*ex*Fo_fS!%S>@7Z4CPT
zQEYJ?)Q!73?#@|TKa&7?)ldA|^-n{Y1!Gax`2Ev+XHPJB9{p3zh~ZZaLA&Eu7R@Vu
zk|G6OEdlNQ!lF3-xf*O*D$=j0MC}?1`2&iwrY)VZt|=Hi%}v{rju=pV*9HAagMEoE
zg2B*HW-XcFc{4g64nm-83MQkf*GhD;#W+8u4)Lo}>`6Ft>ltg^4lI22BJ@Li8VmR8
zUt4Dp*0n8Rw!|3s)E3@PdrMPr`FNv0klGY{^9S3dCqTKUF_;^$ELC?dM93?&o?ktY
zQ1#>Usz0sjC@4ZffnIv0`bmOl3I={@pja<=P>kJEEpykEI)p?qA(__rdZHp{&cv4p
z77sN!0(ccqHxYCsX`T%%;O}IvHxj`ce9=s9fR~^ZFdlA~6B;iSVbk&87VyftX$l^?
zq>zw5Ih#CcXMgP$td?tXVMt1i!K`E5qL66N#ok2mBpmNPw6QU{feKx`5at9sz%rvW
z#>5a_wjum-kpb+j)&%TM67OH)jzO$u+?4yVjPHqh0HazTIn_X;RZ&5nFclBho@+x%
z1e*|iJhl-bKs{xiKZn*?_r_uV(ZznU-0e3#&9M;j-*wt=CPi!Rwqtg-=0f}tPxK)=
zYHyw(QDj`bV^`Y=lhe5u9Zk25!P7pi4$8G!L90ll;aY79h6udQ*|I9vsp;w!es41D
zzQaslw)Sxw3Ps>H$SsY*PiWg)Nhwr+a(9kqxWZKQFR)78F2>c2vE1QU$5W7XE#BX1
zYX1&>Vjs#jAW0`4y!3>diRzb?^9Y618KjaE3Q-v~23I1&xPjN#<;h@um_N1;+OzTc
zRZ}^vCxTOcl-qsn2riXyVpJlbll)OFjI?lI@Owvz#P_0U-*^vG>n!fpb@t9+NOt!|
zE8@XtKQ(ZHu_*}Lw?*<Mfwp(ONLXA$qzlHa@!YMoDoN&gSv`i%)T8w<X+<I^T@vmi
zcOfq|Q<2+1yUUp$50?C*u;8?bh)`E6&t|;=B0X*5w4RN@L;pe7#Ugy^cXYY3d4fN#
zu+FFJILftCXK7)tLGc4i4@Lr}U%jfrrec-rVnj*ohRaw`k}lTJ!-4cbz6n<C)h`2U
zL8cY%myAP25mvVzjjYwMslCc>DM0ANW^EP0ChjVQ(Pp<G8iVISgIZhRm@E1zfaKBu
z-_8~N$?)sN;|UAha(UsNvDP<)BppS{yz1q`nsDU;SE0;betf(r1)pCI3uh+!5L*(9
z7D~YCtCzza-{Jw7#zwRs1-pv1nw@3!dWQBg|8r#(e8{5!0rVM2^BY!(!p8Qm3%)>d
zfjT8Wy6M_M?2T|Sor=jddAQheRA{Z2xtFYvWRnl(m3WR4+RTqspFM&6X&!a-NH2}#
zS4;b$#?=$h&8cFtY;q^I=SDq*_|6<lL-BY$=XbP+)YF)I=J19xk*4}`ala_jkCNXi
zKg^K)Ft292{3Ra=;Eloj*(~YufywFg?)LuO>HAyuejM6xc^2ZOWjnjwjjX<w;XP90
zd3*+A`g3ixK5cDEWoo^ApI(w3xh@_Wnp>iN`ehJ>mghD_Q)tMkd*_@58419T9?-H{
z9~~|3<(Q$tV<cc!XpVp+2pA)JM${vn=Jk*B6>db?pCJcmnlQcPs&qjAL~t6-m<U&f
z!08s%D-f&})m7?Hi%Ob%x~V9P2irK+ijTNOwdG7LDsJ{=>i0U(sNsg!N0eMutqcE(
zqG$fqQ{5FqW*z6#{sdOp<A`By9nU-2ZT8@=EtD%ot-&rF4>RXDsmPzPzA0#>AGI#_
z7;+(s{X9zD#J+=0BHVa0jdbAjZ%jz6b)w^@_}^{=_bYO^|KX4v?(>8+Lv`zKLfp!J
zLpn{}-&oEx+Q4!_h;PTrbv$!r2v3bQL5<6hB5^u=G{g&Aw$b}k^}elF2*$R;)UcLq
zkc$C@_uB8ZZ0nc$Zp*eJV&84+9c!(kxXi<U!e0&>TFArsglYR@c+%yc8y<{YkOA9Z
zZtvra!K*hQfpt5_)^3nOR8d6?`bBUvqZ!jG?=R4pok<%K!BKm<MojtftU8aEVQ`{@
z*)&%yRJL<IeXoy^1wJ^p;C~jr<8e!oXH-L*O~H+C_2Ir?Grb9dXMunlH_4xq0wMH=
zG|B@F(?8wqy0#;J8R<5*0DptGVs2_NwZ}sc#JCAMHzeWcLy@?hv&0B7CB`ZucI_j4
zbA8tsoC?9wy++6uo7+h3H!|3eDWYA?q>y}&E=su8tuD&6@JS(9`Uw#$FLX_16&SZM
zIJ*Tpx)(aiJmR=sW01H%B$$^GLo%Onp^KV%nSe_@Y6rm7ALI*ejJDq1XF8c>Me0rj
z4WQ#SNcLs}D~KoWo#NOJ%Jf9=|FHHh@KIG)-+uxD0!Alj(5O+<iWd4%C06?off^D*
zP(&vQNf3?N+Tw`XdYM7I1cI3X4u>FZwdHBGLQ!k0ZK>i@yoXB}uv95h1p$qU_KXuX
zid94{@AtR&Ig<<6zW>krr!{lVKKr`%+H0@9ZhO%;L_M+PZn-oV3l%&7hi;bawQSz>
zKXt5@%KknC&Ig4OTSRKh3Q{smH$6Dc_TVU(4de&-@lggBm&f@I*UY?hntkBH0RbMR
z*7GS+?DvEgbLhuq={Rs~9(8gkewP5xE%SYB#YZ!=rtJ;x)QPp;*Dv=67rW8I@YAdO
z&b9$eG(Cbhb2r^?if+vFE%-H#Y7(^<Zx5T%Uy4<gx>~s>^&2`wePI*6F>+l1qq>e7
zFET<f%1^aZIOtUBry9WdK{hlI-Z--Pq%-vdSp$C5@Xrdzwlg{f;!Eq|kI$9D(1fI~
z4@X|6o{Y9xh7~wfR16Dy&+Im1m24_{vQ;P4N8Tqh$mW|RaT)hc*kOCwnT93@s|R2n
zH7?4<Hm2LVnc#80LcC6O16IhBqH$fapMJyJ%6W$E*LSJ*b-~NmbXal6!HLI?NFU|f
zBa8G5C=KVv{)yjNc4;_2nxo6i-ErfC@>bbfg8m`T`|GbIpBMVCU`82zrQ1A=l}aV{
zM$)@a;r6u_CFvi1W)7T3^<M9-JatgkG@~KCD3Wt|_d&ZcY>9{)`vVh_1VvCTSXS*_
zxHrK2o593d?*L&`-4=O%P%%xOPvx~<=^1@>1%Z+da6kL4GBc_5R@`fHLE(MNeV@Lw
zdTz`uIZ*G_Si;D0M?FoO0FrVw*#Cu{BhyY=7af!!`=4T~OaI|Z_yalXxR;foupg2(
zr@ajI07%1}y;S3Vv(}sZGAM^aUfquwnVxJ0k~7Q-ODAm{Kq@&teNLvoT|&klRrNV!
zRksCI1!u~G`y1Fxj(4Ym!}NEw0M@;~U(fXSo|g{Q-(!MCrZ4f&h~4Fbwe~vG8ATZ@
zBBpA*v(~Dzl4aI-sLWUmCCl;!{bX5z{V^6{Xm!!#vb?bQ$#eSX%CId)$p9KhhJiRW
z3jXt}Vbc8p$@J?w7<BnlWQ-HEMh`@91!^~W+t?-O#^7pfrtn9E6|*RGm5DqW9cq;A
z+=VQ8n`}WbF8k5N0bx4Zx-tT$FZExd)R8b0PE&>plk%{;ucHuYXMH40|Fw%T0_h9k
zBhov2_TPkKhSx-m-VKJ%8k)H5{{s}czLk+52^e*|#=t1{ab-@nb3vJ?%NE(`s#!bk
zJsb{VuchCL#OWQtt@p;$Hw)b@77@P;zM=SoOr0!dmhtP(U#d6mDXFf<O6T{idjscC
zT(fT$$RS~U3JL<dC@$-Qb)N=zzBIF8|2iY+em8Hi=r>(OAdEEv*aq*T^@gVN{w?=U
zZR!JVoen0jT@xY=X|D;X_43NihM2bEjnlHSt(4`gyA8ojKMDo@lllO0s@`N*=^g$|
zKIqRRep9E~iCkg)xhy>%Xm8!+!rdPJT>-t0^%s?$z65bszneY+u@4NrYdaOPKSF%V
z^7JQHe{%Q(Deq>lME#8`E=P80==*X#87DHUze9l!$%o!=jUGl$=XOnq+OpGFXI#p<
z<u7T|OZW9_)=wek6X0NjHz~IpuO+(`!>kq{DnIT!l15)WHK5UF>l9N2V{uWUZCdoG
z8h275*L397)F0Sl*IEUDtMz{S@<8j?Mq)suW?%@bTc3=J*A7fwx)qCU(ga7!Xe~Wx
ziFq#OSu4nxfBYN)F&q!`L&ZjF5!7n(cKWj<$4Ku7%4@EsO~-wB1oqopoyYZiP7+<c
z*FaY;)gXp&brZMy*0t3%m_eA0`!?!zV^5*4`^4@Pl4edOk$b3@OFo;|vJW$%2lHc9
zt(9Bg!|S~X2M!l{mqn*fcPn3dQoG|RS)Ex~W3$SzoGhkn7f+MeIjf(^p{;AXaXNbv
z;>86zf&7Ehd*r(T2%6f6S8y`NFPv^OD$5yt8@wOG&=`0g$vx>kM{pWfJu%#U-oF?q
zLMiNY6SJ5&f;GHrcIxT(7&$X6-*@~omD+6X-sZ`)3D~>(ZLT`V#0M7sG<Zk!?}j{v
z0`wJaK<sFd=d}6&d8UFbuqgeSOHYrEVERE_<3EL{_~Y5P0H9|Cv|8_)zYi271)EL-
zo7QpJ%{OOfMgP)#bDy(ge|FaRg?0aqvmw1^MnAZTYA+6pZl-jV#V&B$;-#?{yq5+V
zx?nmPOWg{5KY=J8YQ0akaek4kBfu>0{_Q%^Xe=t}y$$2ZXRgai9cKa7^85ip)nouh
zo)5obDol+dLl1c@`=yNXz1MI37pBn0e_-0h!Fo0H;aw0N)8@@o2S4ak<a3<>*8e=^
z@wC-E<?^)AJi))EpV3oa9v(Y*|HnMRi_sQ6pHa|#j~?1<hc=8+vd2b^>*XGQP;6i)
zF(k9%2rS_LgTDFWF(K}vhuc_lZ@p#!<VQ*CX>TCA<H^vgm|;96+KPP)Dx734PC3@a
zKp4)tJlDS+nN7Aa_3>aB!Qg{~g{=}_CozM6oKc});%^QwF%Ia~eRBz0;gPX-*&Oms
zY??c*kLoAezp|kOgL;;v**PZLc*@6dOqrBN=<d84ucg*U)lfndRWfdZrc5YCAJ^aP
z3m}66E7tn=uha(lV+yR8_gx97VD-iX$?V6+>sWia@P$rA7Z}w$`wc$&b(lDER60NG
zJ^VM*tSAc3GSP3-K%OF~f0S<;#i$ujjgh4nw+r-1KV-_If*8v75%!+<h23qj9~+Z%
z(`)sk-h0$mkbatrTq-+LGK3U;Vg3yLA0d7=RtW!eIKUbxU`0cqZTAh-TrPqW9N^%w
zdDN`v58O*f!f=eWU+%1YaS7d((JV%cFGh<?>k0_#V9x90Kx=zi&_BGsNH$ylU%NuN
zAPm`RU~LQqbrAX@WQGl4iqYZbS=rad7B$c6b4_es^Q^vEv1UMH=A^D)kWU_k-~zpZ
zrsOx{rDANE-3cQB=U_YwBy7l6<FG9Xq-}JyLo_Rh9dQ*?`7pQpgyLB|Do&JpX>qN$
zH^*;5haoO3l4ZRf<xi+q;#+w@UJ>~#Qx88y$4hoXBT`Q(ui|T9+l*=HBy|9@S6O<F
zTFVtey0Ik`Uj@0->92sheRGlAQ<CJwJtUKe4uBXHW~5hl?}yq{seEBk*n7dMW>j#3
zTD^1x>mlD*iTPpl#S^(EHt2g8*5SSa>w({RP%g^3S_e?m(g)dHBTjtG?&5b<hdXEq
zZ!@yd#=jK#8zY`^V%Qt@GwmWpBvFH4_H18M1AxC-1sV(ZG^0;#robmZ?N&hXh!#`8
z#Diq`>2bmSH(BLcr)AevXG%WZy(IT_cvEasb3aSL>WAV>KqKcBCiq$PFr50mx-VB8
zvtYdkE({<X*L<f6_1VtnVLY1ols_T#Krw~#YQvE;86?x&;2j6cqnRyEy}=&iLw^!m
zPIXtM=K|)`IzA^W3!bN7YO~;8nHSm4%k+|+2zeU3zhTxR1o;K|y7Ob4*J4~*8RHTe
z|FmT}%uXr*lqui{GQB~fq_?qx^o0Po*8A1traH4rjkU!1AJ8YF6@|U}zxv}vtp{b1
zUJgrLK0;f>R8bf9)ySlDJXwehc6zs+VMr=l72V~GQ0u*5bELix%)0cwjj5_0@BVqr
z9B6b-I2L>n<%3-7j@d}n6*42Z!Z+Zs=BrX|&`RXT=37<p&C}92mvWHQt$Z@_#1w*a
ze|gAyB8<f*eo2!+p9?L<s!#=mm{CZb-p=Y?g%|c7$W&o2d!XgomKRtUQ1`=vI--5u
zSx{zkY3pmW<4!nVRp}C7u@s$v^|kG$Ck9j<UGhU0b4w=Ya2ad)9K?awBbR7soJPGJ
z2;=C#f6VeD`>PA4eU~E%UxU3#Ljk&WD5+6AGFcwpMYk3=c$e9{AjM(y6`@(;d@`8H
z^{OMgf(9d|!Q#{uK1P-WsWrA6fHZXhA2c@fR;HzSZ45FM*c2f`OFu%TGX{CHcbEY?
z1{8^Zg4B_M@A<>(W9v)3M{2+wnDY_w4!U4N9D`M-QhT@ayWt;<Oe-{fiCgGxq8AR5
z>e$|?utf*+GZ}s(%)sTw+4goh2a_9KHhoK0gjKy|IlAt99K*KvqPZ+<2q&e%Y@&zz
zAU14AaEiw&Ki3VPPnP%G25xR%&(j`Ql<e56@E^2yRHTdnGmQ=2;6gKxX-x1bGf_Ln
zUBWYCpcLH5dr5)GB<-1Of2UBz7`Hr(mPP>oA;bz|6C2=1Ob|8M68X{hb<pZ#oiUY7
z4#|;~q^9SggY)xJ(+R=$SC8+qT@vvhQKi9_Erwi#5(al|bJ~ijfRcp@W@eiC#d*PM
zidXWPd5%0c9m9^k*hx%tC$C3yQ;p^(TthhZ7w})<41hN(DxI!5HA)vk9jSJ1mZrnI
zwfd~lmiiv9$KtLWbq#&A(nPrpFxJidhwgFClm_q7i-}*;O+}EJ0UlX+d}KQMp>;Y`
z^&e51**lhgrj7<%1U0`lTtYXYlDEJ}oJt*5Ap9V+7WpfGsvEpfSNn6aQI*xxZMCye
zf}+OOOxgcc7nSY<>V~fNMUf)s(<_4q1L*?h9UHquYIeKfK1t8`M9x=G0tPEqLc^_^
z!u>4MOhdk@%53dF^QBH^ZjL2`Yc63Axn<$e=3<plyqz|It`>LMF#H$o(znn&N5xUO
zP0Po(&c&;@w!o<<CimP~x%rE0gkRi`$AeojOhXPSKkB+zdqX`j!(e#XL2n;#Tov_Q
z7aZt&T|0cmurM`3p1jv5SYO7!=_^sc8n;EheWlFn-3zBwdwVZ314=#0S9P*-J%jD!
zzb#=f=dOPW<i%i4>UkOu)Wv@_9p5N}&T!@u>*0f0|CO83=4|Z3vDDLQ)m&PrX|ML)
ztjgf+QKm-2%clnLY?|N5tz5wjU1=5}DrV*(VlZL8J~eo!UFBoKcHn+ID-o7nch~)F
zGgDFHh5X|zF-kO|ZYrWwjk<$d?_@lbYO5n#=#xQ)&yO+#O+Cz38QBKDrMB=SkKwvb
zxR07hagcMX&FQb^)CCr9z`4{eW;?atQ|Wppb(m8zZ0;>)7DI^;1M#OcB}bhe=S#Ey
z7Wvc-E{*e+CiOFhv@kyol~O<yXH7a+{MEwh>~YQei=&@3qiX!HdH<m3yUpkuJ>^@Y
zd@rPr)+hc9iVoJNysCxA;I7|~Qn9z3ef7gPGRfR`v{W!79(|4x0RYdNTkATj#b4k9
zV&QpVh{4p!07yFNGdO6}`A7nyO+fXum<zbf(v5!IK?Ejw<)j>F_0cl@(m{XRnX1n_
z6|Yb7ne&4<m3r^Km3AiO4fv3=&kQti474FQ!b8YEf{^!#y=MveKUhY9CBfaN2hy)}
z=f5zQ!sSLf6b#vul}2t2?|5-z>JOhDY%gH+8wyHLgNOmYLskS>E9DLf@^mRH7*L$X
z==dS*W@O|C<qQfg|Hp0pq~x|Qk8SCPW3Ab_7#Aa|^|t=Ojz~J7$8CAkN|E;Wwb|8C
zn2bJu7+kmg{jSDQWXX5R+icI1&V;bN_R5~up~Bsqe(70JAPVR%18}Ayr_g1p=F(b(
zMRDr)uLw3`05ntP{OCN-p3JeG*aRI+Y9*f8!nm)9WXa<vdbOR#<2Wrd4<kp{=i&=`
zly=M&!m$_Auh}nYzQo=(-hEHPm;`f2v}587K3}>q_8h%<kY4n#U?Zo2g}o!mgAajz
zbil<jut$k2B^-18fTm;m43c7!{Bj=CZWUcp>u2#JryiTh;(p61&of75Z#`%N3(?oq
z8j4>;8$r!}u{W~OMOUd#D%bF_t-@v1<f`M|y48%d!F!5ae5dA$yp&FzFzCP`v5orO
zZ>9Q@@+I<j>$&t1wSb(A&t{W8Q}#Zg_;Y+Q#$x%z>nab{(FxkZI&{i|5`?|q1s_6*
z7gbYTN4-^Iy3=xNBd0{n{0ezhuK_DX-CN9JfN|K03sYlW`bdMICBMrcXfz@i%OjRW
zyvgFGG5UOooSdKBrUK67Fio{w$2eT078NK)ELoZ7Ny|)g$#RQ(<#xf*X{-i1v_#>v
zGRxQu25AYWRC`I`c>2tO(~Zu+6_wgpbBDGvMD~CwI8y}Q9<usT|9rv<$Hb=*sSylK
zCoGCvMdv#<`;eP;iqi-eo|k`>@8xM&dVwax(u+QYSrzo4yB{b5VZX9xpADwr3}-Ey
z7ZTXb0hw2Wm!adlI;lLxfUlba=i474d8m!7r)KvojR&!7Fp9q)5<iOMY>n^+z%ony
zTjq4XU!C3C@IDRRyTpwY?i-cv?c#jIt(v=1{p%1O!hTea7Xd3~*w(O*(pOUg5qT#f
z^6fhRJc9|-Wx{tjL>TrH(pN{8058=ij^X`0OQtX8oEi-y^~#RDW~C2bK_sk=*jUgP
zmib@`CFVdfOujz}ageP=zSph3d#MjW2H>Kxl{!m?X2`7n7=KjO?pKU}-RNWi%tn{<
z?>4zdl;<z$6Z~UIuf48f;Zd2rF6?Y)ufupSb9Kb~Ul`%E!Sw0A|0k%qJscTIzk1<B
zE9WQ^+S3Pgd9El*Nt<_--ONla#SUlA$_@u3QbhL1d~>~@^BM3uo!-h1dD?DVIRqU{
zjx$PJw`rGbCOEr_gJ)BT?IJW}Cv&x(xgszN!nf={3(Pn=)4z!a^)Dmq=BWJ)Fn1+T
zn*HqnfhUIL4iovOz8I?q-`s(Qgc~2na#KG6l1nhB?mzm{oG279wwKU7i`X)q{^W9E
zyHb07=8UQ%8>uNJp*`)5;n}R_u7w=jsHrW@J?kU81ho2sjcxC9;GW?n<f0o6CB8@H
zsX_b!q(`e&{9ignwYPf%^tvH+Gjybm+;2rg3$va8R9W%1S%)bAZ_9HB8l5fc9xRLg
z^N+=k^og&DrnaOom5IJx9$yptD7~|bKNve5`a~5IW)2-&%w1H`u`|oZwjaa8nKN%0
zn_tMoe~ryQz|T-=;l@rM$m6j$m5#l<KM(n1JM}ZLW#7nHyXc2e&nX-Cc11s&Sur-u
zJxbBk*vs|v1_J%3#!hD=kG?$f$gywh;rX%C@g#_XIO*kM-&W;M@%YoRQmjY+$fG;<
zZF(4efX8Oyi)y^}&P%n<x@e)%|8Qok^%9nQ_W1|Q(2i|u={%5rze}FZMD}qYSud6x
zu#0IS@S47)dH>f4a>AoqKf=2gfU<$!$R6hQ^?qdEzVFr-@z!GB8r=F~-eUIcT(Po!
zJx+ouH=65-c)Q5H{kK~`jJHWaxucvd-UZAbu?@$%hh-<TH#&VSTPM{OMAo<SfO0m^
zIyNg-xS{OWYzzy&r_QOc;-e8YY8{fDgLA(_PLHFq3Z;M28qRi(Lb{w4TbMqS{(El6
z2q<64f!*x9iFR<TwKBE)p6xt1cWu+(R+&_7s7z%!i9I}}%SJz@-%!h~;(_kbbJZlr
z{JMAPZ9$(P$JfcRJE6L^pY_qzHCeXa(x+A9oa6169k1``*U7h6Qm?gtyuLCNFQyO+
zez6I%Q(4gZnB=p7bR7F0TjpY&y1B4*-<tg=eL~3Rt+8RY6F4UiUst*}bo-lR5NlAt
z7WCkaWHx<cDZBUVqAIsl9g1XS4J|`3RqYM=@bE0x40XrT@9|~2o6yfH(f;X9qJ!rh
zzti8H_ju-6U)_YBv$wSDn-f}`W;XEJYpr}I?EN<l+Wt^n{kfr`rnT-J+3a322cO%Z
zFI7H_Zr?>=pWiWXb??z67!#u73(Srdu!<HEDJ=Q1ue<qgaK_p`BN6Cb7ja2H-nE{M
z{$p;3bUeG!J5}cGzDM{K_KqAK>`IG2V9f$K%OeA|#BIvqKCO%mo`W$d<3O;=m9fmr
zM8dxDLoDaVl&{`371nwmoMiHeqj_=wtoikv!<@?aYIC7oU0mGorIdqRN>;Yfoh)Z^
zyKf1fv@xHOm7A5$k&$|Jh$eg1hRW^yw}by)$!eY4)>_xDT|@EXoXSNswqU9%C2o#&
z5-kpUqs}%XLtA>z63*%5x#LWer>#t`4MtY9K#X}AA$Tjdu+eybwwsVpYoO_4d-fW-
z$0s8z-^5Ci*;#dw=W<{rTl`Tau~mk(QF$>x^&V2;1qL{c+vsz)%5V~_&h@7F8LnYq
zrq~D-`?gI@3^0|gr+Wz7wottzJ+<g3F`O?^k;#SbU=CoMJ|?TuaVS-y72sQqH)9+d
z#blY&JK5c0gGd@@*mQ0_)1Ddj29psst<q%8Pyf-JKRIu_0`Am!C##w|^Q{la=0^h|
z%&TE=t0Nw{d^?|gaPd3d+ig_rJ2q*}!m()C-r45QEYqr~V_NOcX4yy`G_Be2+R4gA
zeB#>@{lvi?+(a4AB2L9$FZp=M!oC#?D*rJCqWlO|vAq6)QpT-}PY8P@R^wM1TQp~f
z-<j7Xh^X9XQG93Rwp~R3Wrg|);hi}{(M|8hz0EFs@4eR#&)QwL)RumA)AoM*M4;|c
zA#!;awnG)_a(Bg+A|e97iMHL156bf(E0oyJl!?GR%zqDty`eTM0>#~R%iQu2C0iHf
zvz2T3Ge)?vE%j)rsgj<1y7-WM&PHOPWp8)uHbOz*_y}E%42|6&w|t_5(?;cHU|hLO
z;BDSh+5Ayi?6B6HK|;NM03j^MCU4H($ZJAg7|l)F=@Z@+fNlw(8-`vp_7Bbj3kOsg
z_(dnkahdS0@vyh=2t!gz8<)&!H`5!h_SWyF&YYoM2ON>Yhh&p;TG;yn@2ws-D6shd
zgOn8Jg9!Sjw%<}4;!?nqoov0N@IZy?U66jj(lfY|tAhNn&9r_?SAHzEMjn{J1cvS?
zfC8qzr5)|#*{7pk6Z#gT`e<+P9zVw?RI#Jo#&%zxl)cw!Y-e#O+GMcGhI;SOlt40=
z$!Tud0Z2weN1yy2vyd7>PQ1ujj&>ohwRz(go3*EP9<4K<MtHyWtGSnQW==why=tdv
zW0gbbDHiTs9~&6Z)?!^1g(NY1EiohO+A($}!k=CJB|E7!_7L>oFa`pQh9{k-_6!Xp
z&AZmXW(oBy_=)PV^d@mGed@Ww%&vHzy4skR+D%rUpEtBbM8^A&E`dat@@ys`-e#kH
z?}E%W^EH&vDzcDKxJ{LN4$-BKHw@(nB{jBZuLHIgXm2tjyDJ~u_5EeL8&?V+S9Zfk
z9qi+av=M5yio9lOLLMga#Kljsc)hncFPmLw>8{Bu{iVfPV_ki+i**&-tQGa~oWs(i
zFW7Zf)-^R*(KGyYskKrtboV_G)}eRHJI2<?G6=g9O55?AWfc0w{;Z}O<;|Im0%JtU
z&V_}RNZIA)wbGLFf%A&L^o{`BthLn33^cN=i=v%M2q1cs`edI!n0)V1j;Q`%^6g;O
z9A+iJx{lQl)GgnX+mK=?>>`GOhRx<Pn$RY!IJfTMi!QBMfWGCyxo^TPBh$*(sOxg4
z1_S~curObWhFTM}lqw_J>5_L98?%<+T6*MUr}~RrXrmdX*~$aP!f<h`b{;P>-`l-D
zbl9KA35LS7KPd*#>|?3pHA|UFl4MmS?*ax}iS9);*;DTc1XdRFYoWiU7C*>P{C{{e
z!`{U98tfDVXIaSMBfzs_?;2ZmTo5)PYuUb`CGFl7d&#C{!Xim65~5k8nM8WMf!;+$
z9OocK7Y(v-J_9(LOe4Hg$z&(v`VpM_;<etHWP)^R(mtT?0^XYf-UxLrvm2(~wWD#X
z^SrIpp+Wx_{Y~9V2e@1Sh)m^v0oh0W#Ii#yFETCo1bCGh8}0O2{lt0@KD!yAt{9Qb
z0`~qum71i=J5^?@+VUBOzXPn2o#``|Sn&RdPvQrR9h{(1r=zZ2bmnH%SbH||5krLL
z2$<DFy|0@7MzMSf=04x1JRCrKg!eD1Va?~z)Nf2aLkT>S8ht0oSLD59Q;60_UB&9a
zdYiH#$dl(iVpCQ@u0jw2k*jqYF0_CGPUQj-vs03l3m95f$;WQpouze)qG!94?{piR
z-KGW3<V8+wNopKJ?Shal`qRNbv|trW&xcOpL7vmkjE*gdtuZ@&>}zhNXkh##rkwqB
z30q6!0_-bF0~R&jk1y$;;OV!B?-KSkhrMN)&xx5(h4d3v{#9R#J8wt6^CG92-Hn|)
z`sG4fc2{;<nvoqVSzW>|kA$V)>TmMEEZ2LdSevIz-tDjNuJa4@i@va<UtZ5DPFa1H
zsUj2~$P$AMtM}ft7CN-E{S=d1E$8<v_RZ-_R*w$a9vig%8(T7yyLa0KJu5k7^*Mgq
zEo}Uz?JK*rZE~ya!k)$c+wRA!D}(l{g7$|8?fWHqw_nt=qEl9%>$m?Ydx>fPAJ%5a
zjNRl``^7zr1?^uLv|k;x{~KF6Q=)hKLwi<q%IaFb{T~MHU)imFlUwbZvu4+<2kl=J
zw108X{_voEzeMl$hxKm1(Qp4P7J?nWHO?{PH@VgRh@QoQ_OA%q|9;T^Z*1vIiQesx
z>{-!QR$pnVh<?|!eRa3CO-{9~vvd!Pzcy&~he4~~3|jT`_H5M`oUEQf_VmwIU(Qbo
zwdH};^?JgC^T6u!_4EaFa&@_$Zq(B#J!x0zb^dJWxaQgM2)A@%+sd+x^?UX*Ntzqq
zZ;kz7L*@Hf>BD?}rgU$#c8B+B3Qpi`j^>lJkJl{`({RHZmJew9B{s*uT$MN7sl0o~
zwRi7qT)N}hU%Hh`clR3wpcdu~SkQM@(~=!+$P_%g<SS#p*-fzJMfLTZ^hXmY4w@aD
zr!)3}PNfHR#D)R}5k(w_(>*vQbIJ-y>Cm(be?E&RZj8u@p~bH;`7TjMiJR~aTC@&P
z#nz&A4xX!xoyctX;7;A=UiZ0sd(KGWWLI{C7VEMJGy$zSM9^(-z3uiKBE%&&%|6z;
z@JYC76dZ&vImNaWmMm-F<z46Rwba1*`vHFN>8SOZ@-t^{1!r4Wl{4mC{3WR=H2-xH
z#*DLeNhTOPVsEdg!|sCLB8$;KqK9beENgjRDi{0{iJMni*AYsb&17o`x98G%k>)R`
z4YO3Xg>G{E*&xxg*R|_{j?m)MDZ+IR_=C2Nxjls`t<<*u`O-vzYO^~1v`c)H8?Q$0
zi4fO&$R?(4wE2;iUawDz;j+a4^fBm0y7qUIKFd!hy48U(--(_$=BiNQc%B8V60C=J
zc^|XKi#0g0N9uK;s8SJ3o4iIus_cr_uMdiCq)IX$e(%>Kf8YRPFi(Qpa4*btXB9WN
z;UY{73n^n_;qLMt2EO7j?^6lR?*V=dm4_(sESm~cofn*NjuZ$do^7TN{fr;mPmn&1
zsbQzo<0bad-U4_bFGwwoCDC#0fYK7}!LR3{A{aBHl1uDik|Zbpm|uNu;Pcs;&jxLr
zy*{$0Pgnm;E`li**j$*-w={MD1TdJ?ON(v)WEozEit=yxdX1it6MKye1Tr-;^s~R_
zZ_?3CZtYMkbxYSqPee!aBxU}Df!;)P=QUg@cw{Euax?&Cpj&$B^d&%(<+ii3V|US7
zPzPShE8Ws`60&`R`%j-^J0O<?dl_QlGa#!8KuhC2Z=Fu5Br`j}xLkb<nT)lyE;luz
zK_s5!sR1*Q*hdv9$=rOXr~lAJuU4NQ2Fx-V_HO$b40~l>GO-#}H4sIcV_bQkmUQbU
zC|{h!D!yo<ex{RmC7yN3ezRB(%#=J|HuQ_~GSW#rMYd!=EfgVlGO^9CFqzn%dD``w
zZ6rMnO-gNzEa@(bW#PUPX&yU;<HL`ee8YoK;$-Sa6w(n^rnAY!^p8~!Lw8_Qg&*)p
zf~AK{bk^o?XIYy*V4j_HA5%}LKl@)8JW=?IXjkDm^QjW=4wB!t$u0ZJW*<xLYLoYG
zLE^N~;^j0(ZdfOBuMR$3K6?ncZOto!#9L<Hl<DhYn>hAaiqAeKllLY+S^BKm=Vo$W
z?kB(8GxxcEvXFfC@tNFb_{pD;99q1a*-adnUFhDU5#tSA>-}+rK>)`<AISUgE@?9`
z`YkX;_;OrpL7AJ-TsZN&G&xE0LY*2fj2`3Nh<JBFVjUkHE+JfKo+f&0ZIoVNLxZrv
zGypwJ#uM#i6-uQ4+ot-{0Ij^!d@FbCubHE6vvU~@F}2P*q$pQVJ*@sS3+{P=+SIIm
zCwh}idi0XiFdCh{q_yH%t|6LvT5H9<`aQL^MO3n7-_bLVZ*3W79#5Q^Kld|1X-;ly
z1;XorH~o-(2my6R_6s$(YuW$OINNXVo1gockZbk|h_G<6*6V+(kBhNCx3*+Ga^S$&
z`>V6EX0D$5*#NeS=*rfX*IrPoxijyl%t}*c>n%Z<A30BNr0=%Y&>h*Zv9{Zx`OSc-
z)O-ysswUmStIRRL9D4v}JG6K*Q>!id2BL3sPm5$C9BXDx^|D@MNgB=Xe7cJT;KM97
z{Jr;QVTi(d-tu`?)}>P;t4JlDA*rG_4JJ0qpP$o8!^7|HJ(l3$orw7&AQh=8BWO8F
z^!94*rttP7=0<z$y|F1P>$0it(;@+_2B#X3O@|-XL_-R^Um010Y+c;Pl&9XioJKg%
z%1mw=7k+u|*APj;lr-|cs3I41Q+XQ1gYNZ8ZWZFfHGHl0G2tg7t^NmPs%Y7eS9*^!
z&UwA%X^}5n52gv8cNvPcm55XH%aE_ISI9^}vw(zJ)CtXt0_P0+gywzUy!t2<npe-O
zMWfIi=joF{rO>=@^DJv<$@0KwAD@!p?0*FW%ehX|M1wv8EIz>Yn?bFIW@X5n)T!Oj
zD>P46{8$tV#a}WXeKZTrOWHats$H3>BYra|?;}*}AIRh0CDc<GVfP+A!9%--JZBSw
z=#F7Nh1dn;%ymB*61DAz21a8KOzuH+p7xXPzgL(k-9V<qul!G15d@&nr+~c9_dgZu
z(;YtoVJ!7tT#hIMgI|pz>@B}3fJFRTq^G_?6-%H57rh}$5K8=<_m<DbMWZdBeJA?E
zme0<O&S?4UDz2UgC{OG7MCXR)4n{dL+1x24przF5lD(KL3tl-7`n2HA#4f(kIXBi(
zoBc^Rwa*U2QvIDjumc}%`Z@)0rtYIRwuXgwi3(Cl`f+WP*7-U0Gr^e!O0b(y{Bt8|
ziTtlwibtH3*@K_ZGO5dhKYW@`?x1S#gA;>~@d5Od3c=CVd)k=`3BM+efNRcoXANzL
zWU(%5-RnlO?(4muBiUsA$e%d0SQi#qw1$(mtI~M|W+u-&3c(aOm%2td!UYmt$`vBg
zOzV;R)dkE>#Z-Bpo@2UCW@+B@L-98$VwnH~z-%MuF_x-R)velABqZUXH8Zkd0*PBU
zQq_2UZMP<(DFB?71lSH43en)a0&}L0-C~7EsTawH|Ex^o=KtBiJk_R>b$P6f4eB7C
zoPRwb1EUrC2ty8_%SO7ljBpa`nG5uzaErM&4Z_n_E_RedY}?o#4yUS3ZTaprxmUbX
z^0632DPQPqO#{r{;3G||VgX+Th^h_3axCjZj~W!2ItH6e>_qrr<mgV8vs(5IiNbIk
z9{n$8yL)jFl^<_D9T9!MW#3WJcUtxp#7^`-#oltK(tNC?ekZz^^*P2Llh~gXz&iFx
z8b@CR&>39;`*sVc2Ahd3g<;=bEXs^rE@q4qn7b9?HovaPw0d>xO#s)4x0rh#PAhkJ
z6_Z`ogw)A?;i&~F+4o~0m3o)oz@lIFgN)Rj$~b19EYq&C5$=yx0;ZBp;+Mx|hYPa9
zh1ubvmbT*39kKT_o{j!}0=~alp7SDHFBWyr!wP>Lc)(knJi71fac*BkZqAu&-M-HG
zYjeuv)R-Z>)X)5L9SQiIm1JW>c~qS7XymG>irn<GYua-lS~UlTEaC)hkTe=HpJ*hz
z&8f&q-|Y^OQkV^}j1w_AjcJwKg!7YCCT3T9Q8)kV-u~RMzH>W-7#xPp-3-q2>{>pn
z+%pQi2)$fe<Z~wGO$+{c{cepO?N%U3jpi^vM|KTyiAlvq)!rW5tj$|<AKg`2nHPK6
zttd(+qRbF=z+FdpN*ZOf-mSgtT}mvyOPQL^am}xL>xeaP^lQyKMjG4fmVHM==ghoT
zGD}m`eOh^4Q?AM}FSht?xYl;A){++fOd}J(2U>D#G07qq6(mQl2aGU8u7L*nv$xR}
z7;pwN$4Xm59+#utUAL(<Isanq#X*64=+Vaw!V6<yD30nYP<6U@8C7ukRCg93lP01l
zw`zB%sTpt_=h}J*=tHO^Sv!cMk3Vn98wsrK3@y5|COX$mWYtit-spUz7rK*%;RrSq
z!G+)Deq#*vBg;44$_4xkaa&FMb<OU$sfgXV(?$2Y*t<AtiyQ+kXV%1&0%N){U8MBy
zijdQHCCWGZz9(XQC1()^=C$Umbw_c%53_6GZ)Y|&QdxD;6e>*~70}K1Uv(;%n2QX}
zs1UMhZt&RjuWFcG;5022_4+^+*e*Y9z-}&C=LThoA;#a1Ez5P3WV9G)E*(7!XU!`H
ziry`CXJJejiet*nbQo~@dg%0F?i`#%2`nep4<p0a`=y`Y4=DqQ3ka<rZRbL5uzSbC
z?6dpCUL*`#wO3l`Q>N%Tx7Bo`T3L=WmvBe_V2Kgu-%Pf<kz#ZHU6lR_^xh0>m<D2J
z{Ar681@5y;n02RV8)IqBnUCzox<JJ*6;jm~lr}J&X*~M_5Dv>6#g!WmD1#A|Jb=yM
z7*(0k;k-_&i9Yv!RcUAJ9j9plBv<P%l$iQCJNs??p+~tl9cwS2+AO4=5cqk_dyvoW
z<aWo5GIbc8R`+9=A`exYd(|`RWjI?o(RnuH0Ex|_SKg7w1Yml~Ai`}-jgJTykvq_5
zg3z4S83q3lbj`=#vwq>@FE?jued(5i#n<bpEVpE9>B#80e);m!=WK}o(leLDK1`j<
zf}xMZgc`5Rs+@HK(PA%TVvO_P%|~Z;mXnle61Jv{QFO*JXk~5;6d1Gw<?F&`$7s#N
zkWgILTea*vG8BKE2X|(HP9+i;0V%hd@muB(^jX;FY*6?~KFL$U%kFCT*UD~z_&s50
z*r--N(j!3B-9n*w3wg|aY@3E;`ujuDQorX9V<du{E@%x}jeaH5qP#U58ffv3u99ad
zt8MYaT$)i|O{1fD3sCm5uKfL!zoJMK&X8qG=Ti5=3JM28#w;wD@lbrWSj1q&n?Or5
z;!sz8j|o*x`w0c{wqs1(OKR#>^T|S6j4%8}DE<xe0N97}08<q+nQ}!l5?85I9_h#%
z=}ayj(Ms9>Y0$TcdQE3uOL@ifl_8JQg*?S!?_2vaAT8o!>2(F6guHItTQMhXcb+!5
zV0M$#@2G~Nj<GDE0!>XAEYqyF3+sJ6*~YWMlfRe;hOpK=fG3YDn=!5eTL^$A60f`T
z41V3A2RuI9R&86Y+=675fVV>WGcy5fOFib`cnvJGa~W%m)FSby+IeFA(x*5Oyr!j)
zMR=^eZXL!f7Pya@Hi7BGJXo1$(*hB{Wg4U1ADR}K{b7MNhsjHvS>v^@HS7C?VhugU
zBPgD@R!No!+k#aE?vF&lAYV@O_FT8B(7vN7RMKrES%Ozy<bRmFNFUC>JvUWMWv#az
zQ|wqE0U?gB7cwLRDgvzYz*2O~LvASEY##cD;y0NGR(n0`J9QOr$T6Y+I)(cuYnTN9
zD67p$!`zCY&gA=iVAgGcR1Ly~hMNBhU*eml`EUrjPZ!P3qTsGYdda!n=y9V*0bjhO
zNGfFrp?CzG@b~x$$PU_EcKV4q++D}jgcHYbgPk*Zl^Y)AP8{#lJ?KnciH9Y{ow|n|
z03&>J>6tEF8{=G;Bej5BuuuFu5#$WxAcxDzt2GkprLugtZk01J#|d*;+k+S%I1@+d
zhD_?M+w4pn54$2l6ys2W-H^HR@(L^5sP=}35P2AOCRL~Jc5`y;7CChbtODJzWUj$@
zL@|b)65?YMy^TtIlJ_Q)CQ?Am0b@Yro|glCHT&dlvri5l9BcrDL@*mhvr22jh(77B
z2eY~U-s~4|<OkV*$?VzXaBh9-9Tv~%$xFF2mi5V9Il4F)^$eDLO`Bc*Uq#2F#o8cd
zABTYerlChcPD|QGpLu&IPPD+RGTdxFoD@o2i6w<9#!1sV^@!k>&012~T~iN$ZKeOh
z<CPN5hlU+YRxSgdv(f`fUye>-4NY`wiUNiuyK)&Vz1=HkKjhmcUty4MxbmT(0nVi_
z$KLQ)3=uTJucl=nPhS>BViOy)q8%;K3cHHMsh#|8HEx(U0*kAcmVunS01RMVYJu7%
z`G!7L-c8xW%jQwlBsQBOw+XTA0_9Gq9t+f8jlnXVY?djg>@QQlkiS^zsg`hRrfP+d
z-puugp+q}0D%J84W7`mlU&$JBKJg)Ur-57%@R(C13Uef@qx5NUXT*)wxT<m{#@=)d
zzlO#DM(ZWZXuV(%Xp=#pEk^_x@%SMat^0#r>o=KfKXxncgweV)?Z8tAmcu}v9&G0N
zR1rx%dBD^Lwh|vm20{>0f1)%?cXpp8!Z<QLes9JZf*`)La*>_9#KpqSapFe}5gb?O
zTK<k%`&mF8fiZYImqwjWl9d)x$M|e$NWk>r^b7GaVoCoKoE|*<Kfwu|OpP};lTC1f
zQ5T#n7H~0bxf#rDbFnDd?p!A$APW+P642`fBGx`)roL;pOUoPD9Wyl->kn6PvqSM?
zL=G)}ViN`)uNP8E<w=-anVe`T>Z+Ju3^D@Pfb13_-we<c%H`zUo}sg9J;>%`EuBjO
ze<7Q1QVf;Ol;=~<l95$escq~I@G7Z!+EeXDezOTLP@-*PF@L%!4m)tYzXca}lHG6w
z+Jd_?1xr8Ri=A0;#msC<T#vziXw4Ut3~0?019Q5LmwWhNjDq~`rb^Yd+9Gin_6TNq
z?f<5MlCAzBB~=G;@~M&GO?|9M)zc)`&u)qxmhtz&;I~}+{wH?Rj}Dfg2CLh<fqYi#
zceLhDVCmmtsnk8Z`;7FV<KrPN!3*n~_``f9{SC=OoDaeX*qnW`y7QiWpJB>UJeyF5
zL<5Sw-gWZlsLUo~LtOo@Ca9;pME9?l`!qvw-7+E?@d3Zq+&})7I2F-qeE)tPGmS`3
zZ<VA-uXXY+twU6&>mNu?R_@^e9PsQ<r+yG3ic={!=;sM3o3(Z)uw#0}z!_D`nmA#B
zzjSQ;VXp2PWWyTOkrkeC!WidM2JB846~<xdh4)NX*l=Fi!FAKM1v?r$P!VwIA*OL?
zz7)2E!HZtYA*#x3NufkORFT~rd!gUkVN4jWg>VB|jeNuJxm&p>kS(}XXVO3e{?3{*
zbA%ZwEeCh3l|xSfGe%gId&o1GPVA`cuqN3UjK&_9nzl!ePssFmgL`p-!+o*b4!S8O
zu_HCtcw^bzh1?dhGojC=m4NkHZ5sgGKrsG{xU4xj1)=#DD7{L8#)maXa!eh8cRzh0
z;)CfgNRXR8*YvXNOL{qsUS2T9>8y4>b?ZmfIInm&y&J%F!$EKz7`;vbqpv2SbaZ-a
z`KRIy=QWr)h0_Zq6tBqr<t{)a;nWH0paF6GW_{pJPjh)?s1+M_Ey;RsziS#R^V!Hb
zIm{da9)Da}KVV!sHlAr<o||53#sb9@#E0~Pc*q!{9R&4X8>4`H3ar(5Dh!?w)AwBZ
zu%lo54ajI4J5qlZ1?>;$Qzz@G${cRu+cfC{?3o4;LWvdhEp@*-sMLvR%vSg<OShZf
zQEt@;fuTvc<^;LMr`J*+q8MY6X{(NPrvAy^=jXqNCR6XL-OHu`xJ0YoU(<Wn;6tgU
zs?db_T5PI5Gz@Ow+d*@>A|1@>GbwXpwLz8?VL6EgZ^R6`vZ3Dl#f!!iH#xxwD*fe<
z>Y%4)eMmlw4ZkKMdQ5mmvF@?ketyq;>}+h5Ri^^EjQvFscMeR<U5JN&arF4sa$QPU
zfVY2a$T;Uhn;c7tp5YC-E1hoM|5eWQ6qh?#VjU0TkS&rkEO%1EBzf!Wn3l$NW2Bq@
z78QbrGmj8v5`y}q(Bfs3X^}6P*ftI!+3QSE1$uQTsx`KjEuW9G*S0QHB(By+vWih}
zeR=>v>de2+{nr;K@%!i2+o2%`#=<8_y=p#&ezw+r4gIX`D{JFhW2XY_SUcXEo!HT~
zS9=@T*pbH3M)r%&Wtq?~$*Mw8kS>y}-mX_~f4MfjngQ<WKEOApXn?!y08jG=I7mhM
zQDpWNE&IP3y`ty9R#K$<z@Gbm8d&-;H3mr4Kf*O6#sDOZbeBKUUB)8q;P^Q<J_M&S
z_qyDL#C0f+9%m=~C`~w_4|Yv}p)p@#Z!_P!(;cl%oldO1ra@ZocWUh@*7+6{D*#$+
z*|TWVL-Rfaet~-QZ9NCt_0T*SDYOO}c1@8{v4?(XrYIDbcYL7lyjnGOsm(+4eqlaZ
zMd2N$o<OfTe<FDUMfq*|WcB+~ef@qo(}S6nnbv2X?d$i?uu9pPUvK&BwCE`<pM8VS
zoS$75J>FJ0=eD_@{fR0=3E^lUe*;xF5IY_~yk6r2!e*Zx&**3eTpXzKw{#oF%yqu{
z|H&@(|H_Q||HWxRnY&ZkPWZ6Q*abY1`OrdIn@M{hNDC#dCNDI|>Ez;9bhS7Id)^@7
zw>(aq8#36P>D-J=**n*!=0b`XGAAyo!DIAqfjw3p^q{=hdC8gFfysAic~PkK$3Q{8
zofD)@&~4&*eWa>6zfX>HNuS*0_&#}L$l^C&zviGBieJF|u#KSYsUMO3V%WRnHFWye
z6jT&Yk9%p+MQh&dSChTY8&5jnG;Jbj+3R%43-?Kqu7Ok(wKR1c5iN5sC@N_i=Uh+}
zZ2xQ8`|I>SVFdDvjK&A`I_+{UaVCt&-sD_RZ1fbOU)Gecuk96v3t{hxTdhSyWv6AP
z5{`PWxcniAgloLDo!i@#c&QouoBdGtWaGKOErdA1KgWF+gy<w(O(*)tS_BXiiWuyg
z_I~u+9iPv(7D`kC-pEzjE31g(H$b*+TmK3qbd3<-&Ha7uQk`uo9P^VpiW11{s5RNV
zo^<%DEE9N*p*k-DQhG1|eItfE0_HJ3Ecu$fuEzVjN$v?waz8_|g=Xq^nt8d3dym`e
z<1n&I?bohlqJ7|>KZ@@9(LVfs5?-LkZN9n>+};GF=&Hfxl#->uT3l=!2%;ic0gA#B
z9x{G`E;z)z6o+H<>=n7rOEA05qlQJl8d*R$e8;+b38R;+FjSgR1Q-B_n5=71=l!0n
zHN+1y6G~c{4&8f&3AMQ;o0`wgiWZeSwYduir3<)lIg}{kQ)_uPYC|$C9K@Z>(E;W{
z=9}8%o1*FTn=G1d{Se(2{>y%yp~Nl<k^Wti-Wa4uM;+XT@Qrq2*B`o#J()IcHgydS
z>LLJ>`aFqaZ*wW(g2y?N*n-oAral<wgj|M+gR6e)i%9qYL&E9zR`t92)8V1`JTL}x
zh~qd6VHQ~-1xMl@(lTX^1HUZg&llxC&$gquJ}E=?->3909RX_#@ln_syCPHaSX=B!
z75jd-V$+vU@YOUSgoa1+BKZs}HI5m_8=@lD+~r+HpCM8m9N`G3Abv(RA>Af3vZrgh
zS3YO3HFXqKP$RN!#%*f#@!<|K5M?KWc|LBWWCs&jMMbG~JgKO;_}zl69@0hg&i3lZ
zMX=1ltiSDqxkLgp&UKl&EcEduU-Njvznw>b^#{aO&`k^KGenq!>FLH&g%YqV@Js%u
z*js>XSNeTWYPLaxL0<%@W^9V7!lFT;j|OJ0st-N=d+hY{@o_YAkfmP0J`o`bz)r1!
zU2NVzB3c?5qdB_AyaFX@LR9#$g9}3_+9koHbPL&Aug`XF%q6gfknfmoSTuNo(#2L7
zENV{+i++k2EQ5ouQF#V1-HTq-1r#A5MFGk@1C)P$7Od%u4-Jru{w+WZ_DE&l9eb)b
zn(Le__M}#cmsfOME_+wTMFLD5yfEl9lCQMDJx;(hdSk=mglmARa4PR`w!;hnowckp
zLFfCF>5j$kBxy#sYja&lkBE@A$FQUUI-(v_P_mo-ii%XxW_9BWrY-z9Cu6pQ%+jGr
zBl4%o5Bcu%CtdsZWDkbkAy9DAQi$%59^8$qw~#hOG!!4p3X>Bk6xCi}iXFEteu7W7
z&C$T%V6RGENx$E`e;CSWcB<z6XNM9|pGt91yE&V83<`DTO#F<2w2tdz#5x2_Vvgh2
zu`z1<JYv5;%`xH@MHU9hpV-S7)u)Fj{HVDxiu`u!=%OF&3>e$acBfBAbsK9ypYYP%
zi{y|k&ki*)gvCnYt2R-TQs-ZD5d3;5@n;$>Yx%4Xy$!`*<^`8H&uu8GejE*?p&%(&
zgA%>pUlvN}_84Z@gmI^g3Bc>@b7P%elWhP8Uhx4J<|EI0*l>{=n*u1ZB_ocn@#1~t
zJK2$;ZuFDUDc2Xu^%*L$U-N*opE^Q+I;tP%Ju93(pCed3rc)OdRC|}Mg~u=_9ZA*y
zM23=0?2Gmy$FI-?bvkQIZKL@JWmav(xQTU|+UkMHJFH#Xbm9|cG>9t~;6-<|igW|D
zMJq%?bwr`5^h!1%1oMsnwGE@>&s>%K>HQk%*KdO@ox=UKJP4;1w9{c}%v)?Z(LK%k
zFOIzk39>kJQ?B#j!g1N@A?#;k8lzW_`D*lpF<*;LDR&ysDaTQFjJY`Wc18MqKBU=n
z`v)IFcddz~<885*B3nQ;e^WV|P+$I0kj@1?qP~}U6^;HmothN;`S1^Gu}1f9G`lx4
zT8kKjZ=phs`L|5D4?mqIBygQrbS~<bo7cSF59_JcDcS97Ue9uG$Z;>p&2gsjlb!2C
zvvb@Va-C_pyyfwhi#e}?I~Ha0lINb`9LI-z=ge&P27*53^HRWveD{U|XIcSog}fEG
zHxxS43VAEyt<b%p$eE_6B7kc4lu-OvV5*(8)X#W~Oznch8SA>k!6ykmQ`cpM8^EUv
zbt*dzr3$Cov<u%!h3Vh*KvPyqRyg%5zJl!ak)p09p9Nie+%e$KLwc_NV4{HART=xH
zzapb&h98$i+sEA*qLG688P;x4Yxx}3a_T&F=OdBR<9Q9pslj)Z&^`2iVoZsKsHgt~
zJ;h&go%6i+D~K$d5PZ=04!L{vVxQQ(z!&(2+oFd#ACzom7hEZlBIY3W)u0B<7U;S~
z?b|?Y%r|&PW--9`Fl*j_TlAym{inls@&Q76di2Wh<0##<`vhB06?z1NVliAy4$0}t
z6y(s{i_hsQ-lHsQ>=tay4#SUQpVYmXc7*IcCSR(dOv)8|TA?C(IJ-N8a)RC6f^i1?
zsn4MJ0J#u`A|>;XlC9}ieCEv`cQ^Yx8?ViH$;Kraw;Iu2R^L*XMti3fVO02?k^|0X
zoQlku(%2dH&Q>7>Yp<flHm`RY<Tom_*049hhJ2|ion16%xk&Z}BRDB(cPG-&jFB@i
zX1}5op<6fJG*~DH%VSJDV|gvba?*!m2U_S20J;c<|5N<qVf4quKR%}dbLbmp8*=Ve
zAm8-6c`x-aVQ$69OwyttNkVfwn45#7QJJLaLDHB^Qf-h_mPslLlE!C}z7Zr%B<U!H
z%p-tg>KIZ3`H2EbYNPC>Ke@!IeAp=Z@6#UFfZ-Wn?QYy@)np&B(myY0vkShdZSO;<
z&*TH&^dP3FPQEh>J^y`f6Y70b{RIm{$;y>r44c*}`y(+EZ%^qb4y(5Y6n7g}6Q-nO
zYxcTy|0N60KQ6o6tz6Anu=UJ7(N1$5oSB0CkK)Vt@WPxkh`|z{3#&Hfwov?Lex2A;
zB|FDl9EvYzcO26gir=eWB%6xeKL$Ce?3vxBrzlNyjHkF@W?{}CHl^G#x5YLx%X>;=
zPjTBJHEF~nyUbaQ3NRkCBX*nCo8t<37<AM6WK}UR%1TxhX(*90+UP22MBMS|ltho{
z)~!rzO_mK)zGT@@`$L#AS>1o8;Ww?~6i<Z5RW3nS2Dwdb6mqJHa1E=Zx2qN3wN4Pq
z-V*j&_ZbEad)g{vM%T(Q187ll_=eV;GuW`5YB)N#>AnUx_F%o&biW!{Z>WY-H8d2z
zT`dw0FchD~Q_0qHH;;HMv3+VYJPcn!Lc?8ieb3-|>QbHR5T{oz+LyI(u#ZnVew=9O
z=P{z63A4vmA|mpo*|9fZCUzjgTy?4nR-~?n-b_ke&0nShR2jDrL&2@F3%LzQQq&qg
z7|R&T?<!BF^5jy@F67?Pmvw(E7&iH-*70Ze;iVj7m4*3bqM#)dCQmGtUWH^l`f!h|
z);@RgQ%I77{Mjb|*U&8PWOovoj~~tWn)iR5xnZ9aH)-yX1<k#2T+VCVca9R&0ZPCd
z^_1V%G5GU*nY}N+HH^7xCXOxIIVu|p=~Wd~Ml8T>Eqq$<o?GN>bS7_R@rD*lvdYvs
z8<AuM%HqpL_~B(BsvBAh`a0ZItgC3-aRufsP;`4baMYpXTNbSM%4L}CxKmEbanH}*
z<8puI`FcDl*9r5sg*x2vM|;lrlZ+mHqQ_eYpYupDzO)lNNNIQTPI7WiLb&NnZ0Eg`
z9QowPN6X|)>?GwQQVK{xdhIzAKO$uxDTSmIvbj4G_mT3s#ChkRR74_HYnz?(K6fW?
z9KMl1<67P+b|&+*r6pC&EujuQ<_1@ulcaAWh$7D#*<{?Lcj<ZZE;I?|p<P#)Dg{-c
zXC6G5aUM!50cA&Mkz{IynV13dty`;s{!f`oVC!C31Xj0>!vuHscThAL8?$t7xlHGu
zi(c3=>WJ9hmRZF|#JCV>eX`65zE~m6qfU>W0U?OI%R=#{eax-7Oy0#9C?bx$l~+xh
z<fpklpN5h{tEY1Pj<TE`?^*q)A2aD@_2|42?%<aFgIde~6}nTmL(R;I?~ESdUY~<i
z^8j}ohHTMlb3^S`4hh^u3zmYMCS^A%aSnC3mXVNW!_c<uA84aTqoJ^({g(ZQh2no8
z4;@X8(-J;MWTB&AN0s7DsjHFB-pjsH>j&4Bg?VD5Lh-YGLJFy9TJ2P>f`BK^5m#nz
z!%qB`K1KGyO}dr$!H${;q}Q(I0Avo|(wM)d3fL{!Gaiwwb%JAlyyPA#X<Vtp=?ltI
zxiZ+T-RffL#3!(U0Vqp+o;6oG1&(ZOx;QOd#62+_$e-~t9FiiaaOsv?p1V+CyW)57
zt}SCezx9@ZYvh9OA~arNS=+qZyUJdnvXk@WtKH_^!ucyzO-k!Uy7>wcp{uc2yUeOD
zf9XL0uTWo`+A8!JjZSeu01cVS%Qsh>Vo&1&IHz)@u?q#4YP}Ep1ahauOGqB7(c)QO
zJ#I6#G$Skml!*&FxeeQN&<bn}CH_bW;wRF%5}hOM__UMc>pbb3KP>x420ExrPy_g^
zYOy(w4MM;<lTA4~5Jpwkm6hkZv{CH~X5Y3u@oU<NUriB2=zyK;$@kGwK;QDeMp!6_
z?ZW}gPNyNrj1D`$YVSu#=X`#^tcI>hmW@3Q8A5b|jQJSa{7mX1h_W?dO_&>EtPzZE
z4R^0E#-KIPM~_;X!susH!!!Bgo~BS0h7yWK1+pirMA@H7<tP)wn<lYHmd?3->`<BR
zaYanKt?e9*WHx7*R2?%FDPnQ>2h{(0jDwlwYrs?y5dRL5$day1Q8G~jUjw>P$#TP6
zhlSQgHoHUTN{@A}vNkf6#aaNn=xqvE9*B(Zs_j&=7?`zrzj&SQo3#>`32*9`y|R9`
zs+&~JFLPyAnPn<7gEAW4g`}tClE!kyg|vu67)ZxnWERBrZ)MP>#^0?PawWvC629o+
z+dkq9`M<;(+2<RqsZKpY7fLpzcLwsZA|QaJ2r&flnvD*U*O*M=Vuzv42;jS;Jg?e4
zZ>U?FzoW5pMmB*ly|Gp}Vq*9Hy|v=Z*4i@P1IUkOKt27Pdd1+!x*#c`EZ#J78mr7#
z)bSQEq})eyzYQcjfjzGPT-5gheScEl8@zeJ_k7<RqOx=M>#w!%-XSXfIXr^Avv*vI
zLFtH=vyZr`$nAs4$$i*OxaB$ALM|kv9_^OM4^2?*_)nCe8=A#$|Bs4K$kFz&$ysZw
z{&;<MtakTy=V)>{XIR~sxr>L`LF5(Ho`4eqVGc~7<H!`6W4}?1UQmf^o3%jX4L}Sm
zBM>uIP0n-fAgmYjcZ{Q{prL*-kA{wL&PXqf45Jz#3ts+_Il_o&zfPT2dvqhUwN{K^
z5GKH9Fu3?M5yXmN8i_0hxY`JKSJ&XKeC-v!j7#5!e90&ePdz{>%kSC#*|Tu3KJH01
zm~8+ar^Boesa<(|$n*;Pz>d^19)n&bX6V#Yi}`X#YJsxUj?|+JPj+uliOtmZX8}1o
z*Ty(*h%_^NRB1jGQ>?oK&KVYOQnO4^=Lk6gPA=d|gsgf7$-u+jTlf+I^;DgyHqUr~
zdRwlygBN6?;|&=UU{omV)n08&oNP;gZ*sTHC$g04JIntnw}#e=Q5xHN=oZs)wM_Lk
z9!ULzwFJFp{cvAGA?t<9SN)3<;4yV^f>8r=Yr?TeCj$4uuK2>NH`%js5cmzi*Y3RB
zOr41!@l!ok<w;SDD0*vXae{=BkAuh@XL7;-k;l&`u!y(tU3(<i0G_hP3BOCLa%NAp
z603~ERHu0-AYN6zZnQG;SHF&0uRhz58e=uHn)N>%ReHTQlA77?oDIRzK0p17l8>PV
z!BvzTV+o=<-<OO(OCK}#G}32s{nSgP6*)~q+=?70+ER$}D@Ud6C7-Q1i82bHyhcST
z&9%8Mj+xr!&cc4@^VZu|7aE;eiH^D4a-AIH+?tzy)Mu=Fou7%J$yr;ps}wSJmUS*X
z4PU0d_?|-dZ_RCp>=8k@xWHUOHRTTw{l#K}K$~%nc?#&9xw!{XQrR%>YvDe}Tfwh4
zedZv_zQh$air_u=MyeaD(A>n>7s9%e<T}9WE~zmYE+j+GAm{)Pv~5xq-j9PSW4}u$
z=;DmBt^=$kQTt&fn9aw9NSJ+<w0(|IDzK<)cjxH@@BGyKtsUX?@sEYca&E8Xm}~D4
z081*6vRB~1@=q{|a_XM-S^k;o9woGE<*EBQv?EDCT~%UjBoQMJu?Oa#(}OQezBLqA
z!(*C4am8;1u`r?zzQ@`z2o|-uhI)xY+O%!>J_ShH)}UDI-cu=X3SYHK^~DY2{>0@x
zWit7te@gbA&^ojBg(px&rZ>CPDaKG*J0d#JVbEsuL}h2r<-g%JZVz<r)I52YG+AF~
z`C`u_IZRL86MZJEQPsjQ`a6cheQTUG8P6>m&*beYJHif)!4KcU05t1Fj`u$EIA0h@
zY8dBnI|~CS?>>M}p$z^2Y<!;1g~xzMK0G;UU##8=gO&(`m?Ci@>mCLn=LsSG5wnq+
zAv-2fTZ#cn;#0;Hxg<)-TMLXGjzdX+nUc37@yQv5q8aP_ou~8qfU1Q97OYLr=Lf0F
zKSR%KHNl=rw?yAINwLlaYf}<<>3GOgHs6xn6iPftN0_l~M*6X>#tc1+p_{quY-#I5
zi&lNa&{B#<Es!cdbAJbR3I|e0Qm5cHJV_u}A9_y{o3?iqIx%lc$-t0&o#}-z=QDYU
zTmy6<@xbQSY%vx#Wop&{#9SEUgDBNu=DDkVm-4~4Kl3dB_y~c`2Y3yY0@Wa!_&DY|
z%-v)Jf50E{S8rRoYN9Y2!(rAF7U=a}<PHOH7#gV6by|*c8Z>Ai9BpaZldUUCWq9dz
zm}5pe8FlMCxLDPtJ0O-8{+k&D-@~kBrS1ZIbnt2S{umUEJ?iI4<<Ln~N(8?$_~UiM
zpO)VSFk(>Pj#<M#sMZRcA*zo&ONq!v{`9(TAZTDIIel{e)YmkafIp<`xeVfF$olA(
zTl2D`H$l{i5zsdK9F6PzM+;jv^r`l~aS^KnzyJ05rJZx$o;drf<{D#n{G*6jqCMrw
z<S)H3XU?0}zq{8r4rI<}nQaG?1SdnB{bo1%@~JPWnoiJz*C)<iW_qALl9M*W9@qLn
z^z+rYm!6y1ne9W}^1F$`<h+&a*Zhtjr>QQt(HWvtd;j>dLw;AP`M&z{9}&lnE5>dA
z>Q=Y2GjxBSGU&TK-kVK*UHO;x%71sS_f@^#7xXIsV6X2F_xirF*ZZno@5_3Z@Aba2
z*ZY0F-tX*H-=bdc@m}wD_A0-m*Z0-E-k0`zxAWBnKRZ8N@Avh}|6tE|V=s(pLL14|
z-tSrmvY+L;Cv4$$+6w($t}kJ41z%8381cQ~<TL&W=r8j9Og{*Uw^L??{!I11eD9#*
znf2AJ{Aoe?PL<c6p#0E(U*0`Iy{z@#U1a)ykvl~1?g?41e<!PEh5mYP@F^HT5B)>8
z_J41SyC>vRVuk($?cdj}v>pDT`u~HVe6h;wPf-4Q|Gs?C|8Lj|GX3AeVyao8zus57
z)$nEgf6w)&ZyP06=ugo89=-&l|MLF-J}AFk<@F~hf8W0^AN2oPTS2D(yQrdOh5mZq
z?N-B=_5ZY>{gHy7{siq0?N<8B`~TiTfBfz0zy1W}_weQ4j6dlA?`#E`{_ipU*I(~f
z-D>!<{{KM5Pbj0`5Lo!|udtRNy(^UBFNBMGR`X>3hZD2X+q>fH+4bmWKGD<{KBzvW
z_*o9?RbTVAL)B;3Lyh-W#|O~m)UZN-EP%Smeb{@PJU*znKc+{276-+zqok!7EA%+E
zt9-S0bFcFCEU-M&Tb=o0s86fNVG^7Znkns^wS>Pw%tX%Q;`YYWS>y=(84fN#fUnAa
z!ZOOi{vPL?<uOIJ%1TV0O&uRBppIleeJLxf%1WF2b{G#KQ%z2G<fG|X*jr6?$$laj
z`bWi^QvJHM-z|TiP3yep__RWq(PP^CW%0N0=?w<4Xn|(IX#_(Kd(-H~a$!)?L~m0Q
z&ipu8mJ2_f`3v+oQec?BM2}i5&ip&|s0HZEU#Ul}WoP~>J&GDQ^Ox$e*c6km+VXt!
zxJ-{(=J7r~iiA4zAJk(zkH{dyt&{o5z1;ldHJhLOW%`-_J+fUlOC62yRBWEwGEdj>
z6ftSn@O1f@iCM`3&G3`X{D*m8uC2nEzetaQxHDhoU&}SI&U^u6x#r55f14hg&7(}3
zmtSWdS1a{$^Z1k=!{%|H9?N+A+?oG5&&KGkq-}0;JuiD7GLvYr#%)5&oIRiU_9nq1
zre^cU=VvtEdG3%cRI_{~eXNNrqSG*;;uAF2KBE$xr<Z5FK|j0rm*x3A-)((|tEzBh
zHC3Vb&s1gB3tMjw`d~Q6Sbu~jjq8>mC_(<W7cnpA<PPp&=k2W(vK%1f&x$y|D;Ag+
zNorOs;jyI6G2#JRE%>Wgs))up@a1!N9pwisS9zxoH4a#=Dx7R+&w%9;DmZ;v9|M-F
zBB#GDEeRNdV7$&-|G9qzjHm8bgKny4Y6h8+Geo^zp_T}Fudb@4#&zB48TK39JM1=L
zL-VD5R&{=#P51kwoA$duz`t{)H-E16xsvJS2*Uc*Y#-jnYqi&&FzcFU{Y&;!CjGOs
zzRKu>>zEcp65PX09h;)mVY7l{S>7({pvo1hF|v#4_TD&Jm)6S`q@X4uw2Hhhgz}Cn
zH0flH>{Y%e$Y;ERO4=CjZ^Myx<;{-CME$*Ej<DB;Y+84)JqY75QxYx06rVEg5TPVj
z$L3Hr?5(x!Z?gBJTKb%03*hi|#*FMp8Tq`UXo7AUhK(R{r;`>b(T7`Xc_Zt3y;}i|
z3%Q+NCiP#G_vL${Z^*GZ0BxOpG~+(LTd9X_ZI&+t?J?WzYAV#NsomWQ-PE(GHeS2g
z`_$K(>C|mLh*2KVgc0X%LSfiDeTW&8Rf503hh*0M(;%nU5n9j01Y-@67jFzCnRrDk
z*Q|xT?YBdLi-DngxFA{P4l!%GB6o!nozC*?jf{GQzB%U8=zfCxP2Z$0zl!^*f+Hu{
zM)%X4M<=(eD=a-hQyM*i{YEl9R@Tg{6)KtD;N8bTGNqV0^|g_o0(Q^~is91=Z#wEP
zXFIj|)=pj>3F(IcUX;9sPIXbJ^u0al$(O??RL~7RiZj+7K0@b1!)Nu}|7Z9lsG<ja
z&i@baiF3^F4xjF0_NsL9?+zY?xk>--OTe?tCkTQ3m01H<xg7E#V2OVYdw~{<zux`$
za|9~LZSdYc@(6AhT*;I%7tXrYS=ms_uL#{LjxG5Ze;K};FVL1DU4mb4gQjb{rp1|+
zXMqd`qJQoIVM~X=!)mXt*#|MmXYedQzJ2akA!GKID%!CqXc8<6&g^IKNh3N-xLofQ
zQIQ37>y3pzE><YE&ZUxIP0p>YML_fGqfEC;&k}xy5*2*1dtZHIrC?%rEU(=+G(VZ|
z-iy4X|5yCpe}W(6T)MJQyp8d;e1-`186NCnuy+Ht-ssJ})zi|9o{q|3BUN)x>i&aK
z+vn68$Pn0zOvtsPvR4BqE4*p<ON@r9Nv^DiGa(lT^gU}1us~&IAUb@l*{LTw=52+5
z3Tw;w@rRoYLmSiL_1pXJ!O%8~5B>rKwbmcpy_EF+^t_|jC+`8gVyMnIX_@<;QZkPd
zJ^(*!uLuQ#f*E~V0g4U@%b2C%tU~t$AsjpOH(M|Dm`lWnrG}`4;#qv2JKI7I>rQVm
z?R5F0s(x=0s?ap|clf(pa)JR6_pdhzG5#|!c9QR+sjXFoT>SU7d>_5pqIO1?E*H9#
zc822ew?q_4BXTjqente<1Cf(`HK_)yL}7$~%W`gofxby?pC!C@4>zQBUv}rX3_hEr
zgYbEX=BCCwpQ5c5G6N3;T;93p=~ExGY8^mG<CS^1PxxO`pF;`gSA$!dR}+pD%<N4q
zi@iZA{%xisI6s*E6h}8p4<HR;uinxGSVX)3!<co^2fLRRST#H(RR5A?7}I6J*aZ8n
z(H4J|*<(NKDZ672)oz%6%-VZ>iM?YE^hdhp1JSD?Iaj(D<``Rc#jxm9OQnCAc|2@G
zs5R%un0dA4%q_jHqh;#>XUjAbB7)h0B)#fv9KQW;UTZ-i+19l8>5IL5Sx0GS^oY_8
zH}-2i??8HW>$L1N;!_iAApKkJISp#)8n0c>1SM6>$tXdZpnem%r@0y!UNpMm{AoA9
zd6^B~tqr&4G`Hs54m(hqkCj_$N!{`#V*CkADk-6!d-Ky)9%jGmx%YP~&$8e3-0QnL
z#0uD$l@)qo*n^V&9_C3Knl5kc%@1<i<lb^=^S=tFFc$1}g-u<&&C8c$2kSq>xODNu
zDi4c+7ff!nvE|8anhw0ypTtok>p*mZRz>X;Ik_8i1#6Tsqc7oYjoR86qtrjpH_L4)
zriU%-!^sNync0rFs5W)nv`bZouE(!5%R8Kks3N^3gP-u&IspXQzO!0Bn=>1K<^$M|
z&M9-Yx7KH`+1I~hQ_IG-1^wYiob4~}YiU2HWn=S#KIJW`{x`qpY#H9^Q$4;fI8kS>
zEI&bJIe6R`={G-X&M?2eBdzJ_#?A%()4%uA@{EUB%f@!ne$GHJ$~}|S_{2bJtM#O}
zwpYa884%j1tUO))*Wsm32cW!`{d4BzEf{S2VE88oMe^j_##BKUJ@x0K4R`uxfe$3j
z%m(+L5D#{WhEUCY(Dr}EAZSKkCZyYxth?|3c1pgaqM&x~W@^%$yx`M&AK%QNus_sY
z*OwiHHWQ&j&ZH^CrH$p=n!>ifeXG0o@`V4pUSgZun9p^oho~vj&8;hJH=pmlKJ58I
z2hq0ZDeeLT(oL}ol4Vmw(38yu&jEkZKwF@N5S<O6Ya-V$!$AXn_h<A`|NW)lHQGiw
zhOIW$#D24BUBvBH$}iowXR%XFu`<}SuKg4G2<3;)!C<^?rrpNUb-CK1iZ%TRJAr%I
z`Ob!mN?)BCy8SO?aW4$J4HH`{vP-wjEJL$8Fj+NGV|t{Ip^tr~)>KvK+~LG^zGUCg
zA>&OFoi$DsW&snalQ6+m6H8x>j=S-k)|_9o7RdU*w-0g05AK-c<P7Gw(-}WFhu@F*
z&E<C=zi3$of6i}y%R2?7uio%C?&)aF`CmvgHxd`%Wt`(o$t4g@E<e2G@so!+5kL7f
zi^<;k!7j*9)LYrpQvviJ2Et`Kly&Xs{7^#c1A|jp8RR(Qh?$b>jLT*JcgCSw&3DG-
zrymn_$*9y*@^Iri`}>)TZrka*hthX}&<GcDXN<{|22;wMwU37Y1J?J>%X_)BF<D+D
z+(?#-%<*$34d4y#wrt_uDIZnlm?tQUv*qH;8rQ*Mwb6L3cQb94Yz6Y^H;uf+@=MF5
z7x6d6w%9~}8)Sbx!x*}F>%M1=Srpl)T&$F0px4$%M&6_w;2*>O#V<m|fGL1uxIXeW
zt#&_NsO4o0vB3+`W8Q>hZPDkPLaaU-yyGIaA(QwR;1z->Zj#{Xbv$RaqLMSzde3~v
zL=xdXH5!!?v==X6GL>ErcVwOLb~@!bCQCO>JyUvJu0j~#*piR^?sjs|U#0d8ZYEBr
zlNzrg!BAhlca`4-lPQ%?GCJZ&mVv|Xrf1+F2Cj>%G9^zBI^Tmo^7+*mL4b9C?hN;E
zO$B=WZ&9ehdxz-~kQ7m73@Mzpo$K=Jy${!*%ElSL6TZ+k<QujGM~yl3sM{&_5g!2>
zyjkonlt^zb+4RIzGCBK7c6vwYi1&onzs?uNFlZn%?4D&h^KtA-W8j5RG`LB$0k78Y
zmTtZwes~!_ijfxf&f8>XXab93n2Vjnggj?Le)blpzR;OaAav|BXLZZ}x7<3i|4c5@
z&7>0-I=3eBEZypbGpSpF^b)sXB&K!IS)Ax6<vww~ek*fJKK7=FEq_93MVYiRr7c$4
zD^zFmjZoT;!@PvuiZl7IEbL94Vli$*>Qb6e{*N;GKj&zasv;R!EzP99t<)0rr#n9y
ziZ2Fj(EJ{Rhlk=*UE?U!lXqow2bZlSEEwzBxI_&Uh!1G-x_!xM9f&42*!~;F*ENPF
zn-08gx1B@qSB85bLfYWey%1+JXWwEd)X8(bcQ!uAJhROAxbr?@KnM3|-ugo(PY@FH
z8qmDWAko3e6Am%X39`KGReZw1dV6<X`ypGOx95<_2VXwo&eQ5XxUG5dLnn_o<Ot>s
zv&nV}hQy6V#GMyDbmpmtP8Q>Ih>pM>EBQ#+3^SV?1_~ycId<n=?iax>jHC4zRerLh
z{S=Wx#hqHnvX@AjX>_*Z;`EL?@3#N&U0RSs^km7Qlb0Sk`R+p}FFSOywlA8r0F3{a
zA-ISM?2s)(3>F(*QV)5y&+kbBvKW(YZ+PJ#n0-4Pq4-fqfw-ci`KL<(&jmL^%=;Q_
zCdP~TG6M^YKOIepijkxzTSn3g{Y$oJp7jsRACekEX7QJ1c^reVjLbaOddK4hVJc*K
zU~F7r{kkfKs${aF!2T54pCXnO0aK>hw@d6#vHiK+{IrNmvrooRj>lw+&{O}U%X*q6
z>b9)sEm<*2iOGsH^`lKOhd#P3A1Sd#266hAG#1TzQjYI1q##EJX&Pa&MF(7&={YT)
z-WA;IfOB!qa#>0wE6hRLX(=G@a%0<35wT~?mOLey<77*r9(5e#aAhl%^2$6_=!v?w
z@E1@Hbo(aDCSJaHG7yg>TNaRd=8=DW$hr8MWW{xtA6`Wb(fqtBvPMsG50~)=e3yy%
z#0N6d-)8;rZ@G@A$(D`wjm<AVSutKOoH3IvoBiZui!nXojf08Ok}dl(pVURu%NAju
z{sFMe(^HwJZJ8%=Q+f$|-ywQrN!v6-QT<M*E(3I+#f)JYR?YDzBmgqgkWgqpcHf8D
znXo4NRF2WcpgJ?9V@yx%%w|w(giW-V)op^?l+M4dsZO?Na`n$nu6@$v>R;+SI_Xs)
zA$EdQl6VD-)&*3yM^|QgWNsv6K#^t&c8!U>CX{HSO!_&EwxH`v#mHm@_m&xSOYH1X
z>tJe4SM-8TMOm_9jF3+?o(vDs1((;cQ$8d_0$>fJ7?au^E~y^?+FniA)zZ>N=AfaM
z=vY@nv*fP*|LX*#{=rC$ys4xOMqvqH_15}^+MD^rLBEH5BR{eooXS8E+&|S>S8WnS
z)qnjtw}NwpSI9DIiMCk?BMsi6N!nuP>`~0}jm2_$596=(PKG71@7sFG;|+f~!ugAX
z^B+OPiN4C<1O6P=;sf_c{(j9Z*Man$(lyaSDhzvl9v0iY1zP9!ai$_)NdJZZk~j^z
z*A>D(e27scV?Fa`#`=;1t8P4y{>>7KI_KfL0Vn<XX0s<k1Cll-<5wB;>Q1_E!ghS_
zyy_(PJ`hSAOR{P$;~=oPc@)RZ|03myEGk|tX@)Ys?5x@Q035P15cT>zWf-Uo{ST4h
zeMqC~jA8w|83A?e@MLX++n?JJtGzKVGO81GM5`$9?%2wjK(^Z7nN{qT6->jw_AjK!
zM`N4DT~-W4F5>)??e-6QYyRkuC$!*QT9vmVo9#eiX1UiFxEB@Idlyn#;bdZ+*?)1H
zwhUkATw07B{1$FsAK=c)Z}3h8BsKv4ZQw1?#iUc5=-CZk%cG|D^fI|?o|}&sXlgX;
zcJ-%%7s911A6)UjsbnV4-+B8#oV^QRRMoZrpBEA!I01s9qDDo<7M1vpph98-1<^?&
z38J7?OH=w%nE`wNp_3qo(<rx<dfRGSYoBUc+iJx(4<(>pMSP)HrApf~4%!HoBDUrK
z`L2D=%p_p%{r!8d<jj7qz4qE`uf6tKYvcI!?^wsPu0>2^L8DhwZcZO$JsRuSVTFpG
zjCBN2q2jR6Ypy<Vy0GFEM6P}ZCnZj~il>>zp$Owz&2_ov`aK0d#Q{Nf(sq7q_Fg4I
z14&TPQM~G+KO%$84c>>rO_b_NMQj(OMjQHO+Phfoeb2R*`HRyRr#5gO3{udK%*fm&
z`P%)EV^&=$7}+}`eY}>GJ3r*~6-dA6a}f&4nfuQA!qf{y;XiopNr2KE)U65UF42^O
z#`~C6fGf561Ef!(=~>G;T$J3vVZnwm7&?Xm2DF_8Ny&p}mgxIQRPfvc?N}X=_pdtZ
z|EUKyZvGA#G;lQy<a){7AE@q$R`(B4T^=T&+sqU6m#YB+iD!*t9~av|7+$-p_5)UX
zey+9-r<pdgq}ORpfX~@SHU)oGJXbNe%4nJMmjqK?izJf2Xq#X3Wb((URmIFR4nmjE
zj-!>s>`SyVh%XA*a79nQhYqZ#)@}3?;=lE~>a(&bn6poxsT)TYCgz~7_`RmzZWLVg
zZmQT73Lw9&??+tvEBgMm`+ip6KX%_w>H9nG`vH9~bKgt&wo{?|xko?00?;nT#}dDG
zgk&Hc8wvBG&ucUy@wT5m;?AhG!_t?LCP6R9pPQSAzyvAnO7_#K)NYndI|3)O<F9To
zE_Q*6?Nt7Hcvazzj>mb=6)tnedhyP3$%&g1k7$vX+d>bfK)Lxht87a5LoL0Ix|#3x
zvfo&|{XS-1p00LfF&i}jk4)?Cqmn;}d?2_mQPCxx41O%jju2rRS+8AoQ2VCq|H6Bm
z^@Yc-A~&_FEpdiZ&mV@;->(5lxZTC!b`>Y^+GcU=*5wrI63c<!tG48tTKtZ@yS$CZ
zZspH8`iDq){M*%6O1`R1%MOCKy>lczt$ybKl-~Wq2(q!8ZzG=|0dj4QDQYTlT91r<
zXBDA;`g$*=FLKl3z4Y)?;G)q~*bFP^cK)hq5qZ_BhGjLyop;XUJI-ioitOJ){aX}o
z-A2XM74*^+oU%*ra93~{&{}#UwAqiQs<y;~O=&ohA&7Oc?1=R1kaOoZB>bMEkhZZU
z*YQb0B?*dc8(Z>umq3wo6yKI`wkApmmqigSV;%R?4mgp#caHu^jOyx(V4lTCjMA&$
zDKmW7H1I{x%zkUkiFWZj5>6NIQO#J#)wHED#kuAiNb2falGk8g@>jnzxL1Q^{ni*@
z+1B;wh~v-U1=D0x8PuWngecGT=afT5XR_-u|D$bH+z*pHL8>&bd-1>b(Br&oIXtn)
z#mgImIZqk8J4fkrwJ@Z_nYA1O{s^M;i{rsjU+7aXjpyT}Mf(Cx`IF1k)*2*=1GV8c
zm7TD@vxER{=q}W%%FS?mnawzCF%`s{afB<j&H7gMQ>`Jwte~a!=ZrXEP2oBZeeIkP
zt_khvhi02dE8O?K_B@e(P0F=$`Mm9&-%oFnCd(1aQqM{h3fGE1lMMu`u!RaD|7VAq
zw*d8ox8uQ_wOo|muF(Tg^~QP42o%#wC_aUq$^wyIdnF;maQi>Nw)(4J(*A{c7^pAz
znnMiKBXS4>0{>FS%u$Wm6XR7|jD_v9{&l|7r4!)qN}LUNXZSNm(EG`$C&U`|CXVwb
z6MU_+X6x9?=Y1y22oA{&&Pj#&>)Fn?PdMIjx~sCRaO}Y3jW|a4Pmc4K=%h8yvp-DW
zIA-oqNz}PE+c(W`aTUGw%LWml!y;0i!cNjZvC7J3L?OajQ*bQ=3DC3z2A7rNh_q=;
zZAI)GI^0%mS^84?N~VvGwYD2oty;R#>zGK=FUBQ4)3%4ZlFo)gZ^Z?q5Nu2?{lBGR
zcA>OC!!K}vd(8>!VPlI1R&8-iEZv_f;uGWZ_{VtTAH0@GdSMU#vE##D{G&Oz9ZzV#
zeni(2;Yt`#(_*!dh?vQ+v>wP}MvZlO-4Bly<0%MEe%D6Ka2fQn@-(q@^?a&B$CYda
zLdRsGL(!T#!l9){0<UjF&vDws{4AFp<aeqhoVIEejMiH*PADlfe&Bv^s~20+O=pWA
zSDv_b>}Hc$JM=ph^b;pOEM>U^d281`97m3IlxjWSse<W^60{nMycKbNEgMfPx8$+m
ze1ea7@B_|Oj6nmO%ovKij<8^MS~~2JBR7~Vi;T5*0aC~&!9TYVTVt!YmU#xA?;0uh
z?U%PgR$Qrf&g%y`2q;Ztp>KnZc%2({I9N8W*b+U>>*}AVISV=baa4~|x034Ee0g3f
zg|oa~2-GSyRM^%OPA~qdIL<TZ^!<##?fPQ&L3<>|4O0x=QSRc$MZb=<e;$a826L#n
zkfbbYAEdprFMK_m&+)|}gO7e|g29p4e3Vqw3jwI`HPgj(n*Puoc|~hBRXcTE7fn@K
zwgr)W2K+IUFR=LAmH2AJQLgrzCCkr9g)HJSlS%u>+GY9Y*Hn)4YAQ+MPq||i-ir~l
zs3}*_jl`G69!snyN<%jXwX_)FHw0e-5|D@M))?Lc4`V0Lkc-oyyS}k>@`JoiCY3Kc
zgditNpCnByrKUX7$;>ndCvgy@sSFQESmTX>o>}uR9N~{QCQ|?a9g7&NJ?)bGmR0)P
zj6yiG5$$+7O<%73n&II^8p9c$K9(eo+CpAq@Gw^f4&F*IVt}TntInjT4)K15r<+M~
zsOyt>%{p5Cxt<+;0712VLUe(Ue@R}+QbYSs`31TM`jfcI3VE3JWs~eLGfAd77-)o7
z*@GFejSy|AJpEgmuUggge`Iq5-rtAK-M>`>t<2n&#pV+z6*T5ahRyMX=_w3y@w;Lu
z-sU{!bf8MCF7hVf1qxBaDLSu*S-8p14zc5KYEv(d4_Fk0>E+P=+G4^eBDx;3tZ(Yw
zm<apbvVMBLe!L_61NyD)OclTy&ylIc+yR}bq5{C(T{usk^|mr?je6Zp!9#zv83S^A
z_9vfXZO5XEbmkL~0TNKtmugU-$l@Zl<P^Zq{90=|c}RY}2lDGJe%FMyPu$9$V0Z`Z
zxq+TWl79okNp+R5TyKDW$xpr8*TywCe_Y`pqouqyeGt&}))&d11_(j>qIwr$e_nr6
zTe|C=+8+}Af9?mJQMCWL?{;P*{eNeb3${<m*bmqA+ql8JZ*?2oW})o2d=edFe+_<r
z2Y!Fr0DkWZW95H08!I1q-Ku8%{ppu<DHvRIUSYw?U-?^Fy?^}UgVlSF^j=#1N!baX
z5Z^R$q8)K&7d5qh6H*SZCGSd{c4firqSUH!VRG<=w5YOj<&hnk2AbH@=Y&0r_q@os
z7anR2wCcODb$zZ4W-{U-@;J!9k4s#iy0MZYs6R0N7hR|(r1wFX{4$nnB{y-%&$kH{
zMObdH8>rg-+)62iWTIy|XLaW8F1UPi^TM$baRf>87Iyu^=&|=XuQP&|_6{+A3@!Uu
zTAvOP0Fm9^Y<G=i^&R2;9U^?aPJlA9@`rVes{}KVom@Ql2nviEc&n@4GPzuFQg-@P
zazlZ;x4e8;$+z$T$oXHG|53?Z!k|u#s}e_~J}FF0n{yoM<CBHNp)#!IS>n(M!#i9J
zWXG?$zaaHVaq_QF+_!q6z?Bu|Wu<51r_{v%Sc(Fz|FJ+XdndckKE1$Tl1<tnHWbFu
zU*i}h_+sAS$_F9tYC0ZwwDvOn<Xxb@9;M&cGktZB^<d4LJs#HjrQT2>ZU!C=`m6u#
zYcJ={C(<M&%kslpNJLH??5(ziP9UjRdmHsF*514;nDnOL?O&D@EE}R}Ugxc*@Htg`
zGs6|2_ZSWcCF=?+$1f|c+Pk!H{IaIPTJjH9w7xJ>{pRWq6Jtn!67i^j%;dZ43bDnH
z){<KJKHRsVa6Ea7r9HU<n#|k`l&Sj*Gk@_u%={8IrS-OW`({|Ow|4fx);&T^@bi02
zy;8M_!dG<G4y@W>W2vV6;*X!B?7WlO_Ix(cM40Nt%(gva64$rwK~h)-Buj4_IEqcD
zGhR5}+empkC+O0lvqS0Y+AW(t-u;DB;jAIXgV}hx^+Cn3Or^JRd}dYd_sOK6NE0V}
z8`-KdKMQ9qTmI}Y|7@4PWZASrDz|-dN@8f+C#NRP44XZcW-VO7vS~$apVTDAwtZ5c
znA-NqnTc5{_La6zPEWoZl^vfs&Wepsj8xfb$|fHQGtV2J=@))}c6?{N*xQ(nf#ERe
z?D3gQ_<8d9%+~O8%=pYJ;pg$=GtY#d$BfTBnYB+eXBzO1v(X05=XNrEEqY|0$L{Bs
z4dmu>+^}%HW%Z{#1^*JOqQ%=7w6X_UM5Vq}TiVVlNRC0R)e?NmHDVgC6KUqa<nc(0
z;)1!SC(yh_1QaeqUMO3QCapioIXz}r!8GBSeeB~D@7Eu98ZXns+$0eNE#QS8B~m%4
zPb@dQ9sEciNQQH&${W9}Cmr<tB#eb{D=mAIxFettYPKkGvx^#LS2RWzbDzD*%=99#
z!3SZ1;;p3%bb@pL=ZY3#GKW?v`oCbujaIR@|5{{!PB_Lcsl`|q%Pb73goSl=J1Z5M
z^aH*@-0V~Kn*SCnSPSf5D&1vac240lQwserz4+X{wXDM-OE<QyY#YmkX0lJ)p7WCD
zoHcc4;*_=pJ1Y}S_0`Gki(cj8fu~lcY*&1S?QufF<k{CPrMYE8yspgsR^zC3C1)1c
z*YV5hcAiz7JhfK#<!6C}P!p2JC`PNWMY2o0;R1cWB<Aou@K<f2o6yi8zb;`wTg5D%
zu4TYSTOba79iJ{Gb>;D(7K5X2X@|nVDceHku_#N=<fgw)*_?gaFb`w9b>3^UM`dr#
zM2Sw@&y7tNBh>aMMOm~9VkwpScORl_Dao02r~XawM33LHYWy*O1wnB8PeOHYxo=iy
z<)reJv!Vby>g!flfnV|9s;CYor`i^0sg4YzCPf*;u%GOzt)vc@Ohmlow%YD;J<Ou&
zwnqd<r0m@sFg$e}YySd+X2~V`6E%!GnVJ0Tsx4O&77}{aa(_VpZy&1Zsw>U-%R`fc
z^gJs$OeHfnuN(`CgDRGBSKW3?x~2E}7|wGLGkBh08}Ej(E4H?@G{u7-f)VW|U0rp7
zwgo{{!-q(!jDSpw!hA#g_sB53B*y@e_&{zd3Cyu2)**@)Szzyl{b8to0wilYb5FS6
zH*+>apH9<E<Mc~#i)bBZB58;c*%zeF(e_!m@K{aT>oiMmM9Si^rPkRDwWnBB8TVe7
zYvi6#?cUAbZNcxshV7L5083k;IiNpdyO!b>7te=~{#n|@eo)pJCxK<nbCx!|ZYo4m
z8QP14jrGWa`4F(w+tGlT_I2D@wocUyUBsb-`d~zplwJYZb9cxCDO(#_7g3<MY?VHm
z{+m2*UdtYyLo0C}b^!-ft6FbWa|N!s^r4g@j-UFG3GWWZZ-uPSE$;N4o=9hI|2BRJ
zJt%-IuPt&^Ph;Z}+1t+Lt~d0Xu^8VU5LOFv|0~Di`{*<tym7lN9@1VyB-|{pdA2@S
z8zsluKVoo*ZEum)9E|yqqcNkQx%5NMpUG(o{>#;1r4~^^w0EDTJ~ulHglvjeEL1}~
zeyE19P~P4;jD*&6EcKh{4V0?aj6?@hx33gSfbj>4kqMLZx~Apk6=JA@Isl%Flx^OG
z5_{S{IUwC%7(jmKeNrOyC3kygrxul!xcGLuWZVY&@<5v_4;m2Fq5IT`9uWGs3mt^$
z3m*7Rgr(Dg>|v!dEkXPd*-o_9XaM#6<8{Lsr=hx`IbO2SD(|+icOjOnt=6cmWIeMm
zjcPn)-w-rJ$%MS7QC;rT1&t3YKmG_pS3&D6b(7$q%<W_mLzu?x+L!Cr1ws5_%|pv0
zkWC2DMHEec32O4@m)h_<3d03}*B1eIr*^jlkGgf0{wo6qNDZthSjV%}M%dk;(M&x~
zCmReuoS=1Yhc?ls){iI~OqPnFF3@;^=0MlVQaZMwE^rMo1833r@0Gj|zrk5ia-v2L
zKFla>G6g`x!z$5wyZ+HI?U5~^TkSb?muhfU;D;*kP5NV+gn#RAV76g}j(Aw<uAa2M
zZkpDp-o*~iuBhHCw?)&ddWKBpwLGGid>r04sorqvF=u~LJ<ZvjdG*5iQeOO#vMiid
zZyQ(!0q?7x$mt7Fy;%En>0p6Xc@Ea%sP627^u1K<aXvBm@UGGLib3>6=C9rQF;#<Q
zuj}Zo^D+KC#%^gQ7&}ou+$ye_y!#5+FcJ?7BX?hF{9~BHGq1~wAxAq?ytNiPPA2Pb
zD^z^9cWTyrXS6Wt)t;65cTqypVJLX8re^mKzEkNeS_$Zx%~?5Mk;x6y@h{6fpSPcx
zJ)rHuBXC9JAh%NdBhYPv39Ee(CV}R#(1a!|qv7b_kUrayG`&`4d(FJmyM6O#I>oP5
zK>j{KeK$C-RjZ2szx-B<|9`~(tZ=gj;T*p3{|NCP`pe%Xtj2>E>+n$(;%yd^bMLx_
z@34z&maB`H>*B6)Oh;EAW$S+waW<6Fy;BzyT8mwMR8IfPoj%=EDlHydOMlb+f$F>=
zsHnF+cY_o|M}X+wx{>tPXgqJfD2qra@(f%X+$ByB_8kw3X}zmtgpt<CukDAl{Br~z
z4ET^-rMJ#EC?W<*M(b#R2|jq$8gLSyU4^-c)+CxggMzFk9_k!77ACT62uIzcz1K5+
zb$;Xk>pd%R_U}%3{XoJi&s!xcJOd!JSP4UFtrh|6vIpdV*F8>H-yClUhJDu-w;hSb
zV0L?#h^%T;ylR6T&6|T3qR@sO2CKZH1hzHZfF7Q5?0{}ublDKQ;(D}(AsN{@e4@`8
zs09Wa)Ajy_#D$!3#`~r@z=>u8$B(E-??da6&1_rrstp=~*D>+!mpRkqDepyp5S4a&
zg;Hmj?LwffK65Xg7}M#vr>s<-xeK@JsHB6()>8x#;2elRG|byPolv3|VyhE;%skWM
z`_|v3mqwCZHXfDngRz>c<e>cP#!%kttlNl;_meY2l9>Od{7agGR5-=!uy)(vFOX4N
z=Y;-<;EG7$_|nnd+IUM-b8rPkIj){IBADqaaid$Yu4GI>=36W0GDNn}(=qYOw9`f?
zjG1Lz`Wk4sx4sLvBj+)ElQ*@^o!GEsDDRy9Wa^Vc=9YEVNVgihc@dOWwQJUL?*)=$
zOIGqT%vz%R*UoR~YAUt+pxBZ-?I((AejX89BA0;0d;Y<{v0J~PtQw3g`pvx|wdbTn
zGPUPKJr{j>g6E>oPRxq)2Cv_Y{)C;}pW4Q#y&^F{?%E|l=lXD_3fVrcqO+(Eot0^k
zmp|>}>{xppA60hC?b=y-@kxF?YW4A{e_x&WOVy^OYZz?$7)s@>@8LW>O5{OgUYWwm
z73w+uf>3W~L-0i;H6ly`pR7w_?YEKjzpb}e``0Mdw&%oTf3BBLjI}qxrM>l?Q;GMf
zg90ZsJE{a0oEkB0tvZz;x{TM(Dia5}<*N(k#K5#n35}jux60k^az9k=c39XgkU>L$
z_gKM`18LjnCwZg{akjUvATJ&qL*A?>&Hq}Wrktr69q-A7%N93Ff#zU34t}rMFrjsq
z8r(ZDaT1LMW4DL866DA2@SvVr;kI)NxC7BZliLl@So?Bn8?dn@I+X)(tX;&F+B-DX
zu9y*>6LxZ|5nFPvAliFSto^Sf?yqroR_)m#OSQi^S*+tLEPBGV!e8w)o7|ey(#YF9
zS&Thc#Ao-1M2){YIPq_`iE@~`4Ep$VC{}>G+;KUb5;0krFwQct5CdWAR<y*Swm_)n
z5EUHm<SmFPeTX`kssK(Mt<0|GYAgRyXxb_6JP2#xH4eswP+s?DP=%aBJGpV0T6<YT
zkw~%+O>~Yg&I|}&2Kl=%JCP?oPE5Wpf;ur7c+aNR7R5Sv26k_H6aR$#i9xpBVI)%E
zi$p3M^$@}vzQ_52msx*m)b*!jq0ATSxPsoOhb(ZP)m%r`tS1Ncq`L<!>t4$m95!l^
zUkw@CL-d6tCu$P~2A6VbadfAkN^UI-cGP~Lh^IqOY-Wo0H-+i5sDVMr-`&QXLsZyD
z`b%W!O^ojN%7eg<Q*8y_2O{<|Z=GQuOd~&G|1#9X8>Ybfde~lY>tAeHq-T<lH($RP
zoi|@K<Z%j%dmp-22-v$uh8=WiIr86|{>0N7g2A~CjstFx(h{5$b}-Z>Q2a^xK<<O8
zwlUoEK1ZP^r7KDEjG4i+z4dX!`I(-kV@NcS68c%_u!(hKHwVKkdssMISjBDUAo~JY
zjlsW`s^-BiD=|_tl~oJa3W+#G34FjfMEV80co!9Iw$2~1CJqW)f86n)t(Nse%NiPH
z{n%yw*|OTnGOooH1)VO~9x7KHQPjIDX`OOmI<b!35J~z#9UCb-b$iv`+)9h)`Ydwu
z_&d{U`rcX;tmmc9DoV(o$cY&n;#HeW%xDT0GAjSVu>xd6@_@`y?0;GLB4^hM8;Oid
zz522I3N^i`lHcdr)MT?QK!&O9>s~hmaC>y4K7SC&;mDje_}*NCS+JI8z8fB2LjUzh
zzl!Q(K`F{JUp>H=6Ep0N;qxr*#AR)J#wIT7ta)<mA#)F8n;y#szE})^_nh-i2;*>2
zFrjX!fcw~c1JLB}XLz5#h{T+msJ3CJ$D-}z!+D2@;A3PBYvy_48#&1^l+qfiHnaq1
zXB=hJkInqbdmVWc>GV-S`3FJy2cR4ed`q;4J5ZNQ<1_Or-Sd8vKpZ}zYFCzXrfu)<
z<xfETJ3G;7F0&H&;%d$llCeWNg1H9&a!c1+8=g77N*S`F$c%Fff-U$Jm_aUQO6=ja
z@a#}{Bn{uK)~u!sDyyh#wybu>iTcH$E*>1@n$7%N_nXMKI-SMZ#e<iziHbj``9@?Y
z`BeGb?UXVqi?y$%FxNz}_DAfa(wTmRyXem>ja^iN*K(8NlVA5XBf3j=zl?3(D<Ot_
zaKkg9#JTWDp1Ugx?<Z=ALmg`yd&*_WzppDf<z#*)KScbN0ef@sLq?x{L(b%QLD4am
z`7wUW_h`-44&7mWQ*y}7jx)CzXO_6>rpsANVrMP2_@~gb4)MX`i1kKGXXX>??T8<?
ziarZidh>n9?82atb1=YpYqO-$v1Pv5`#CXBBgkfD{>o4IshmbMp_$jh@!Nd|iX!Rs
zPEDOv$Q`+zmXDx(JXly@OdkiT#K4;>bfe_Q$8x+l&<I@jODs|nYsx0d5@Uy7Q_B0M
zu`uYr;&Hk84{h@kRiO4nzxgzn&T;S+B!eUIYfS|MB@!P-Kypsf+`<$6`l({;8T%kc
zGh;1Q_1*AAyv?L9<G`R&em(or_bKStkL{Au1ARgXgX5=D<CSDaW%YN5hAq*AbU>L$
zL(jF$@A#0)EAvZlT50Ciea;7pS84c3_OZdjER(y!OJttO?PQs>R{jRK(feqlJd}q>
zjhES3dRW`ON3Lgk>Q8juiWCBUg6~Vz%&y_bPw%IAOImjgf#_*^cIp0(tZ3cttB)!3
zUf>i;uma|l>tXc3)%7E>^FBkKJCWSS{G=9^mCZ}zBm;)e0#-(WRlamrxZ?lt9waPN
zrq-9oTcwC<3NqMoljhfRNhW<_Q}8+|c)4t!&JDuAJCs{4{i512T~<rbvY&SD4%@k~
zqQUfWnLmt4cE>s{WsLsZ()3jQwKhzz)e;QJwL#C);57x8(?+J<6_er_khlLbA7p8Y
zn}V|_2E2}s9p7N;VlFiQi%T|_HpFixmY@{KoJ{ZemL>c3!zG5dAB<?1+Fg{SQ>jNy
zi`^9b8N(&&YR4{Zj%)Am4+vy&otAv+ATk|qOEA3$L{joL1wXUu4vEq+y5~%$2xaP|
zp(PmMYWdCZ%f?nIVl(Sqv!>5&35t6(Yue7svt66Mvn6=@7lKmCaLu17JX6^+Qk8<R
zM|+gXwPU~tHh{U^l?j0{1?XAKkJI*s7<tK|EuE%=p7d?{00LSd@yh^%M?vv0gVP+=
z*wlK>11ub^nr-fZ@rW{60lt(u+u4#It~Oj71AM#nD-dbx{rX2V5D&hL?<BWI+)s1O
z$6!I>eV~wf<Ii#R>`L!4(p5qCD=opgpSvth6p04uCF@5wG?0EFZA_a!8x6G*KbCwN
z+=JkB$xNvzMmzNzbq-X_6&`Up*S(>U7trG?-=t-LpMe=#{3z?i1-{Mc|FZteiNhi#
z8m4AV#4To(H(9(qNXs_WS<3?-5iGMc-yYoTe-xr&S0V;J2e5dJgASM*JzC3JzHBjc
zHoG6uC@1h0bUbC7->l`?!t;hx>YL;>G&C`>jlqt!16d_9Shv>t&Km-Qh3cEtQt%wP
zWbw!hURYAyI(C{KPQ#Rgyc(?BPx4#ItaKopBM^!l2<aQ3oTk~OKz5pvGp^yZ<e#S5
zeMmk@$uEb=7g(~!F+$0Yhsm;!a&7ll^3THLBeKZ_O1?Er?rX{F@*faRFh5L|fiH)E
z_eq1Vt+4^7w~*L0yDw$`tg;t`WqFi3Os-JNr-#YE$|et2@)2S3cSv^IJo}%ce_~V=
ztYgPE6~eDTAmXbuUoF9xj&zD+RG2(ZM-KGU6zqK1iH#!Bq$p|%*9Bi21<ya%t1p>0
zofpjUpZK3|_ba%3T60ryG0!XbzkfirbrF@gjw)TXSM!@qv(^5XOSk(npKWEOz5;vW
z|3Sc&@gjCr%|AUJ;?GgwZ07xO10yH?3Y1zRZp4Gdo^=*_jAu4RK%Ri1i2v;f6pr)P
zf_{z7Zj#KqJw1~oJ8x(4BdI4jh#fX!0iph2oNVm^wSA5>)h)q2C*fEzQ_%z=eo5}3
zDEnj5-5KKXNOOLv-%Lyy9%X#>W2eE@IpLUa?~ZjGAlAOH3?_dlU*62p&`vIMPgo>z
zs6TU<(}cG)wZ6m*hXF+Coc+OHIE<)3x{_ws)2y`w1DSX-VO$!p^jg{8R=YB=lz4E)
zQHDA@x10kB8fTi!1b5yL9s7>+<-Ue|WY?|3q*~Ap7koJ?5$lkG<>4f<i;jG&bb4=T
z9q|pw@E>p5Gw*ctN9YN7A}n>)m!VanmE?)Y{q9jOorYP#!$PCC#~3B&>(H7n{U*5z
zZd6}t?n?gQ$_SQFy(O&BpC03TU!s@v;mm5Jw@&yjzoqqqo-Im>fw2ZW$GM4}Gg4>|
zc`L-6*+JY7lpMl!W!w~$e#2o)I{r~0LR(}!xbpf){nGv&N^^;>p=lPfQZGNCXdegN
zsdN{VV>~TEB_6C>;?QD~Z#Kx<1MoTR_Rq0fm%X7ixO*SmKU~)`D9yCrcROUM82(Eo
zwszA=cdo*Kpegv0Ydn3k5bO5Hmf(T;(ZpUH8bFv0J_KqCd7=x~8XhCWXI2Q98biE{
zLKq4+R15o9cXu0%ocqNz(|Yg6-K)M4QGwm8e)xuA)OO_j{R4iqc>6!W6*}}4vdHl|
zOZb=NH#lEi@77<xXA<xE9V!(xyhhQEGAo)G(q)OXQh>cmtm90O-xL}E`kgA@5d7#H
z(F}ETP%dod8JclK!jk83_c<hYEtZoZWbP;yfrk7$3g3Y9c5u`;6+4Sdv7d5B8$Sdo
z)^7Psxg~@;qR`p$Bd0;1%hACZDf$m;%+0|+7l$w=W9jo5gMXgZ^OfQZi^>X<-MozI
zbyV7zW9?t(@Zqn}FWe?myHAPT`W^*c%D50v{3+2}e~YHPm%2KJQ&u?Y>KK;&Qs^+3
zRvvz3j>KUpS>bmoYrJQF!t<Ft=M&S#mv<k4{R!PId?~fNZ>;?#n&8xwlz*BIL%}=q
zG!k9})XAtrql*VeWJmXq|DYi7539$u+dh-`NKErr2t>`ptIR`|S^bnBzCo|%$6=8?
zXOSVwSk~}(*n|I|hEUjz*qn;;Lj+A4@i}i29%_j6Vj&Yu1E5EaQu9Zg61(L#zEDk`
z#~;rqDg6XX$o#8u^=k|&Y&4u)#&oEQ*eyFL8E?)X-1xREdC8vHyHg|a45G9iU5fO%
zdH6Uf8C7Y&n-baK)?p*!+cf(VfqUWzjr!7IO~HbN;i%0$TrAd~UjFc0NVTbT8<fgR
zNmearhpNQ_hX8}ae(<N4`83V}p>IhXAtHYiyh7w_dl5M`-Re-8uc-_}HMGQo8xmQV
z&m{+aty{FagV8K}<^!vf3}5M;`ne_~!`;DPes=8g)}rB7?koJ$Wnt??dv1w}Ql&NV
z?-Wf}?aCapJhfXvH=)J@Q;&;=3R5eLUR?x-*Hl=v*eCfaMq!3ot@U{D@|+OL#4A~>
z9wQ=h%jLQe7kbx?NdFY13$>GRd_2YG0(xb-qp^O?p&M3oYwE_~g-NeIv&1)`Vf~Z+
z2L)#403Biz=dg1ZCqKd(LO8oXOV>Ds!%k2Usm(ilW!WT&@)oX1Ujw0KSMfxzW`yal
zX>x_@Kt|LdG2q8#tG!eI3R_>xYpkp^xj8i-C^y*}VF_MtQ^k-%9-)Qk(6eGeh@Rw6
z;V-wGK{HibG6QBUudV)s&~p4_NwwcOO1O*&aacpJ@VW@AuZ3;m9wu1qK3VIRzJ~ML
zuR#JoA=Q(0iXP8o+I?d_LX)18{M11j5y-a56H^N@R@RR}iUlydHk;#~!*hJ*4>v`_
zyH~?|hz1y58Tthq-_QBI-|_w6+D{vwnHw-Z*#7IfU2iFM1K0J?^_Z}woA@U}Z|h~f
z){`TJs!h}$5UI-3FY)Dlm|Z<Pc5C&d9|u8I8*G13JZ@6%CB^Fwu2i>1T^&D$V$w_a
zr@>#L0XMe(s8@$V_1Qvo?J#4&t)<Kbk<D?9V5f?NsqaFR5p9ex$~zC3T!k6?nY<^}
zBF;+B?w#b}%QRR+*;}<}P}IgSul;e6%!H6+;`aQ>Z&;++HMmeK)<_1%!HdquJAz%I
z(wuNvS_}(ET;werk^UXy|39>^8||?D<mW?B+|sKlt=bfPFWdGVw4M2JM9*v@t%>~%
zawY=^{*InI8kH^R8yUJiGMit$W<S+$RP{gfu6~qetc5Jj7g_z9^Iw^9SDbS;{N!rU
zI>&XVB-iq=Oa2Y$a>k7fUXprsP3Jgn@&7gNn#R^A=)3i=aJ1Gds2)7`;J|`)eI_6T
z7OYf)IJn#pf-P@qU$GvNKbR%&=jFYiwp_}O>)3L)3dTA#hH$?RBR!km9vHh(jsTDB
zlo~gN_R#x`r%l4?r;cZn6e+I<#h*H!<x~&;`GCeV?>&u23EA-s(0E)A8V^GGQ;esF
zWvXR|15(LYhtBv;e*6#Pc_AE+^s8oWf;#x~C@Kfkl_w!2Z=>|f+2h1<<ghOgB9>Sh
zCLp$++@60_3D1kB$zF|5J^^D;I0XY(#?d^^y*Kmo;Os3><$u!(C_6%p(Qw${M~p0Y
z_R0KSA%)GoDc;a}5S`_`oHDoP^yi^|i|9l%h@8N&zTf7=<=nep8ZHuc{#}V_NC4Lo
zE_EW!<cqhUEp;ARcW%Zc;{NM-3F3)Ldx^<}*7P3sNq+)U=<Nv3{fHI1dvCHRclj1?
zYMr;=Hk0>d)+1_My>Diw6ULm=N9Eb0^$CV^Xh7BA50x^?P}9&D9L#j){6(aHVyyBN
zu3=Q?M!ews)R;o)^YP6He)>N)j-zcH(%`30Wf*h|7pfggfdnfyI}%gzyZHm+W&1)*
z%gLW*!uy0C@P6g>e0bvkJ3R#Uf#X=(;r+w^3h&d;^@caaUM_ey3EmHbr?}+%6nO9W
ze}VV0&A>ag)YiADCN4E__c@=*?!+_E*IVI^TsVj2#bV(Gr8_#yGzMqn<k~cQt#1|a
z(J72|4AAfSr8?F82r(nI2<iLQyGZmt+5hoG;)O7m6BaYWBoGdCV#GMlqzOBhAdVvo
z;;g-n@(bTc?H&+o|Af!f?y}suWYU+l$0Ie&DR1^WHI{~8NhH%I9}4A{!yqNkM49A0
zZZ{J{RzS(@R`z8ZnZT1kGJhEQZ6_YtndG=;BxbelPEm#HIg|V?o6j+16|xWf#8Bgh
zxTTMd7f4Uv#XmjH3u-AI{JS-jPh#x@)U>%FfXa?*fJIQS-3OOMy=4B|onLesyLh(M
z)cHm7bL<v{=ZelRuJOf@$Q<kVHJP5tU*3Z%p1zX=J8evGrwy*;z1?==2o8M~1R!pl
zB7khf!MybmY@9Th=n+6C^re{#7SuDn2vp*Z!$a^s_B}M#>qwoxjqNkL@qUVAY2iGg
z(__b9=qe{?O8=SZ@6OW8_~tBKoYYxbQ2j(jji`eI>Bna8<+OHe)?1L_x;&gDquP#1
z+RE!_q*=#?);}?r9=nflAy}G1;%fbM?-Jp1c&fZ=1Iop!P0|IVcVdJBBG!b6*v3zH
zTG9nh`rC*fu;ZBm#-Q#{5XJOo_=jUs3<6IKcEh_@qnW@m=$A~3BBYgVF|vW=`4MU(
zf^SEnZnCRm*TSQ?K+g&MJO&bcdsawl$)DF&?@azF_3x@h1N;eycn^-E*Lq%|V1Jw#
z?J0-QI0Dt*drd9K0NxP0_kZHB8*5j%hxC*DT#hW6{)5tY2aDfha4jY>R*|3iiOv%}
z<t299#Hq3_)pl(1O~mX+=rRX45QGyp*?P4Y3QKce$-Ef6@)8ZMbK7cD>%fj4`|49Y
z?}yk=xEmt&#FoT(9qghm&QG1oenQU}jRf1e@-{}>P~Q0(ra8;G>-F9U)^QjRcP?J8
zjnQo<j{i5f-g{FFO(%bvS!4cXJ@%8~0M5*CscS4c9$X4)HmvQ%pEc1k^Cy;2?6x)F
zp#-Cj0jZqwTK8KcoMm{6-EV!gEt=jpp~3qLBYl)VZ7kz{8b)e2=#Qaym%q&tsLJ>e
zS1UA+l{q(D*IXU7F$552R&a+oBTB*=G4gUh+|~IEUhb73zL&It3YZb?wTs{%W04@b
zw#KY*Z?o^rMqa_07Es>cvS@Ww8cHR%Ux)PKA8z(1TatZ(H(q2ez)xsc{>eeIGOsJ0
z9wGD*)|bm9SW-ifAwTaLd#avDaaSgCnS(4)vE$7Ju08y8K+Slu-g8mf%QFq}TBe>Y
z!NpgV6g-+U^*ode*?G1EW61dZfvgL$p3$n}%-rZx9xOrdJt)gxcp4?(L@>`qI^yGa
zgD_Xe4ee=pqS)6zKooNdhhK0K2u-W-=P<{aVB?iGKiIP#!1Sp<y?(%51uJMs`e*bF
zy%sB7zH{8lP7T<`-$$i9rnW5kXXaE26*(6!aV;_PFJ!mBi=|EZKSm=E{ugX(37%l@
zCAJnLo!JolmLII9=&>JO1&~#-KX)vPZXh>*BEZ;^;Y=-apbH;Y08GjpvL*QN^I+25
zqI37aERrKj$d=$W<-{D0JMJKdQ-Ta3TY|@xGbqgY205tjWe3?3+^w9!VNR=SP1brX
zfu|gKwS%dS3tf&3^;&|jE5|&o$We?9AdsD2OE6VA2ZwbIbvZJ>WB!$MP?%HTa%6qi
z5*$Si=?qp=@*Y{gADVuP-6mo{SLlFvrz07E;c$G&9LX?Y!PQTLCP=0jdq8aC`toS}
zFKB_)MR_?)>O#fc5nS@N_2Y?8Y=(S19h1{H2$YuA+xA_dnWao0%Kra)-_@%>E&Uas
z0;jSl;J)yRh|FXQBP4y7Y!EBUfR<oVHoI?_eFNEGN=5-K!DqACrD67^E?f2hEkRi}
zyI+_+)@92Spe1<!@~Cg!0juxBUAB2U1<z-*<@coQf3uO&w+umAg5PAb%fjrpUAAmI
zT7u=-Y)IW|E95ZCOV?v9!L=?MEPjzCCN!sir0Psd{c!zj>sgc2wbo4zmsT@CGuy|C
zcUk21rL0)h6JY02H9cPSTUrzQPD1*>$nsB*>u3$rd5>QWEv@HMu;*6tjLBlZBD)7a
zw2OVGZ<xYthF6q-8`Q%h?`%Rua`<d?oDu7py=-GJ#jx~?lopAFkAA!TEEw|)JF8wQ
z6jGXk%VyeyfRx|m+a!L0Qk-7BwPvyxH^WZ5aEq?nezJzHYR5W8d}-B|hTuxqUFKGW
zQOW)f{tolz;7vRM#rxB<HN2lHJLIzy+u8Mkstx0pRmiCEEs~NuDbRU-VWHO_hXp53
zP#?}Rw{L29Nup@R+Pn3@Jeh7hQ}62a-h9|!;s6@*;v=#JbLZ8Z{luC3e^)_LOHZ@-
z{YGao`}Ao4GHK=@C%+?&tq>O!?qS{AP4J1}#g|QwZGnV?d__#g^Crdx30;<^=9e6p
z+zCsq8I=W__RaoLo;{rFDKePnlGj$xsZ0<xkc<1nphtS*wt=pKNO;LVpNIN|1>t*T
z$N3XVh&G!zqIzCs;*g2xFea$!vZf|HM><2e=T%16=>FxS5HPlQb1HSGP+JxcbPZ2;
zbV`qZwc5!wndh?f+he{B;Ez!M>WQ{+K5g_Behpw8kQh3*9N9N<U~2ckM8B#HGraX{
zCno>lH;PQUc?au;lETOy&~F@8xEkxhjJG}?KRx>M<0Yv*2PDeo9+%qFFVTl!p~=7a
z<Amq3%-fs~9I9UdtU{rB`J}|3h)Vr*zI^t7XpgNW+n(%^{&Ra8Z}I>=bq0OhP*O3s
zf7PZL-bSNuuz(%S1MmfhKaDr>vfntIDmydJTKwYwy?*JE-t~E-*VRw$DUm#6F_vSu
zN?i%}YH#N+Pvfwz5;HlRCoa*w&BdLKh1?A$2WKWJtxjp<YDh_(?N1)g>EU31yj2;e
z>@mtdL%CJ{r4`V~si_-5>WSW~bh!xg0~JmF!N2jWSt%YCI^5fRtP}$#G~gWcETuT|
zhe3taVC6)@iCSo+BY6cas1Ygd-kaz;N7a&D1UZ(+WHOU^!><+6f2~r(DV5m_U6Qay
z2|8zIx^nZ0#3Bwf!wl<?*Y~sj20EfRAR-Dk6QMs^u6!ADQykGE1Q@M<x0(lto`Yg>
zDnfQ?5sw6<qs*xMFmJVtdvON)$JoNT#NQa0d^3!U^H*c2J>M^M^X>R$>V~qS#7BNn
zSB<vY0_R}XRl|LwLIK(NgZ^RFESE!JD5;=GAjDE17tS4$`nZIJ^>I<6Uv|9^T%B(g
z;{N#IL}I(9_7w9T4^k#!9rqOdXFjO)WHGN^V2=tf%wY@6hg8`;*ZYz3gU2qYrYwXW
zqsYV{&3lDkg#IVw4_!r<LCc_TlHQm5Goj=ApRm5Lrj+19z>Pg{Za#{9c7wd%#mvBr
zwY}|cp|FVIQec1kf$)cJm^X589jt&EE$rV_GeY7EFmb&{^re~+S$yBM6diYu_*TX*
z<{z$#gSz@CJFF`-->u(@-=x2;k&wJXe}oS9gJy4CQ(~f7>Lg1tL$NtP{?2=Z1wNax
zh_j!TN%@>XL$n7(^qJf54t4uopI`}#M0=XO4ucEk-ap};8SS^>enB?p(=CbfQALl_
zY8G)1o_nreTggP8>t7Q`?hkiRoiCe%<pWLNAa^p4y|y$5w^ld_q&Dm1tN7?wFv0uV
zco{@XaDfxjc(*j#fP{<M(md+AyT|&B?Bl#wtDhlyO>D&~J%hC=QR7MxIdUK^*(!7A
zmFAMpnon3G^9GQf<v)7{CAudihWK+U2!=x=m^nX1-8VC9{F$S{!e3x9-kN@U5+`%U
zTT!=@K^{Z|oPtDoLj#7KL#KvfR5E6o&4<F`$=B#4bZ3dygXY6~=^WgZ3LYuFxv?N|
z*us+^8O6sr2a%K*_{e=A=$wQ3P9CwG(Kj?U#b*}<*HtTCP^B%cb1GD_?;}r9GV|sm
zTlMFasC~sBvNI|Xhk~)L7C!f(yp+Y)3%*{i#lo9FNgEQ)m>&6kbyglyy>Y>j94(PP
zz2UF=e3sRE7q2eyj?7&ebe0TW{Z5Hj+}zxldx#HDSnR~RJ2rTwiLusJW+mXy9_AwM
zc&o{j(4hR!Vshp^U$rU>UD8z~iQR?U&7@Xd2{HodCz+m%zcQ|$$GD&A>-pQ0e=*+K
z<=Ln{Ow8e3w$geA^XVF=GXuc~R?b&*FC*8>9|8Hw(Yv>nM<S+lYh%yXlXupzB^J)x
z?w=|#{w`Xu^Ej`p6=U$#C9pA&G<F;sGU5*466H!pUWNW>^%BQ!@80BvetijU2KslH
zH<O3oySr*-p@K9G8!Gj%HzVeX;#ud1Gzf7h^jTblOow*_wKJ=rMvMFFO)KFUiem4G
z%&&y=vV44u^49GSBVKWOH2to;U-)>6V_3S6e%{VcJfIctCjAju3JE8-Uqtu<Rr|5G
z9L>r}v;O|<y~chyI5{x0#a~n*#R#T^1=WixW9_<A#@we6$!x-CXpkYjX*<p+pW1kK
z)OGuDR3}&slvS@uT*9+{jlu65q80Wz(>=X`2`S2s?%8NzrQO~fQ~|6Z$b~_orM_L`
zY!cKU4#%3@+bs|QDyTZf`h*U1ys>MXGTiTNzsRycR(`$Wkh6y-;eo7$!ZmQC>NVHR
z>b&mi>bkNy#hs@Wq&_ZA953;>7&es+n??MJV(#;9Eb-=)p0Jzwbo{4DG5t6BW8x>g
z#%sLi@}g*7l|zY<UAWsT&a8{jo@E~^pVvGM=cK4raer<->pqPqi)GJ!2JoJu`Om$u
z19A_7IPgtj1)xqU@J5Fl#L7Ra!DmsulHj7C<;BZ_i{`arO7^MH(KsV@J9KqGvSrC5
zBC-#cf+1YQ8%AxKK)`lsdfx^tuoHUYdlE2)u<d95$H2h4xduQo>!M$$@rxQc2fEC?
z5r2b!mgj*+L+7Fk8+wQQ{4rW~5PI=acQULk1Ht*d9!ak(IWQ6F4PBpGf>j)!GZ}}L
z2c!|s_U|6XQ9MDN$Jni_w$N=~f7)pvybScYND1UqCt`SRv0fsW)L9f&EM!C>X?Be>
z{s7d21<=~ovZYK){WR&_N{N3_rJrZ&=giYUH*Mm<=`_?U-`D&N08q1ucT^nlv*Eg9
zMgNJ9qtu=~nObTgr^pW&!Fy<Z)FJmx7lz9#)-HQi_WYs#<%}+=D-RbyAYH(cp(>Yx
zZ7iJLBaOA+;8OpeM?0;h$7nytPmL2!SU;L2G;?%%JU#o(C0?={nKTl?*{s}79$Rvx
zAlox2)_xEllVTkLL5qHxw(cu^1!!W^{+r3GBF4|PE%;kOqPC&IpSlh6?v^Rx;1i=!
zpW4jYfx<$gvhVMRd%Lj$4sOLX1;{4G+VyCI(W7?z<UQ5NZgx<0sF?Z}IO(Pig%UgK
zxhV6dY~u;O4=;#%VfT~fwy!(391bQWE=0YYknLp>y{Of36~??`?Pn?>UXqp(k-xA~
z%)gnW^pX6t@^mH=#=VE?>2eaH^%62Ol+hxFZlW6Y-sJ4iJUFo(4ss}JLeX4vP!oZh
zoFy3Iym;R2@I7}exK2C)o(Yy!;9m}slP6|oSbrdIIL!>>6->rHsId{H!tTl8z?0ux
zZqgBPa3oCaNWREpogm^Fi>v|7U28NK>-aq5%hBCZc;1)=-HB8E%Z1)iVQsh__U&|b
zm}{j1eMmg;qt0R-hY3q=?>SJPEhY9Ok^^mR`k%s)!me=SPJX>NITKgo|Hs1ZytoG`
zFXSgZxP|N2h?=L5PCFl}ZhyW_U_U^!XUL)ntj5wNEnloqUlPtA3ZPxd!Qq_&R_NIc
zWh&2Qan>H3c(*Ew*N1*n`qhlogGN0%9zV;0e`4}|8KqpSefC{MKG1nl$KHhrw9tMt
zf{$Nldv5aZ%x4`x!Tt`)wp_pDyKX~9<YhxXdQwErTg;&HHft{VTVa&gD<vzmQ^4`t
zv+-BHid#chi9(;iUlx6nDP3>~O?#(3JfW*ZA;$`AXMZSNui1j;W^Csr=eq7VO|n(G
z2H6pEJ8U0XB<$no#3YL_)QOzc|ETp~soSx5Nk1=S_LP5zv1j&tAbBd$rW70?j5gJ=
z3$adTZuYlBZ$V1e>$J_meT_D1j~I;Sv~i?^Xb0bQ2WEO8SdXhV?cE565bbWZ?SADI
zZdG0l9GM`zFC^q6dNjGUP?n15Doee1rR<d={=F}J7w-o?lbUNw2jt)@%ffe;fyXia
zKZ19y1Mg|fX)=M^-;k&OGkk2oWj%3sUQgJNV?mx&_+D-0e}qFDCznVo7dbG_6&UFr
z@>nFFhi@t+^kRI^&TIGAxg<NUc7%0~`~{N#Gamj+B=jUkI+^#v?t8}zaBn&#TK4Jx
zqMrSe&*0U6bFeUO?7-xD2aB8V{{t+i8Z23Qz-_LZCh<Rn4LINSo`6U~Ba#k9{>hRt
zN=8-U!lofz^i^F`QeP!~M@<}zT+%XoFB~&nf<u(OZ_Uk;c86W4e%O+xU}XLHMOkv^
zzIv!giYbL<?`H(8*oY@ly*XGM)h*5Za^(+&-^)ML618z;Ud+lX>WlRNbR1hvf7kQA
z+~ivg`WuWvgT5l4soX$Nr`cD?z4Et&PXO~$z9_a+QPlle4E0JQgs$3=tT`g0j?f?P
z(#qW1s+H90s=Ywd_Gz>d3VBc5%TUq@8d&)oN3~14A)B}DS8x;Gz?dI4D$~neA>!w{
zsPB*;jm9)CJ0>@gj{}KKqy*Lci9C?spbH>PZV)3GhV14h5M@#g0cr`OPZ@ERLxtQ0
z<t@QSPQ>w~LXEYbuL4sl*rBb!)QZO7rKkYtinaevc;Gz2A<UaO%9~T+&5_pUI>f($
ziG&oTiR(>k%7qON6V(p)rVZ<=weYdt%<})R<nxHc<b~$oJz}&>??4k^bU|!mm~~z$
zZzd3wXYTW+4d?2aUql?M9p=Y}drj!bodK>leHhu9r7Is3m3@pU&i?dEF5q6zi=Et5
zu`ojr($h4z*3_?QN*H7h$~uKbrKF#5rItn=ChyMt8VD`)u*>=?Sy6>TD&*F)3|4lb
zaH=0|XNg`R40Gh5+4yf}112L<$i_kxlMyY5S`9=9A?8Fj(<Es2T?Ph4yPQzO>|+WM
zWh|&@3H}&moCPovwNVLbjWgSLE3^V}xO>FfFXe}!3zH7F#kmdc6}Jddgmz1xNtx*2
z+KYd(yv^(rxMCd#L4SxI!?=c&u-O#6GCmY0VjahmM?ZO|DEOJM@EH;9f^IfuF|&fM
z2~HzE!Kqs&2s<RY<J1H@PKA5+ZYQaD7-DU)q^97{QIh;(Sq9Z&iq|0(x#JIH50<Xt
z{p^d%klfFVpu=kfYM9zhfSllWTnRfogz?o#ch^>1FeT)BlB)ib<EZic<kQ|;{t*CB
zYf^u5OXda1cYX_+=j3-XKM&CcnzXujE|O)CA9c;UVYHW1BA~cCAk)s1I6A#G2j7W$
ziM6k`dK{$R(Y)+6dpNUX&+=Qxf2y{i?;=FHsYgR$h5bJ`3?6N#{lJ}XbWlHq^EIlN
zZrKsBVT_D=OZ+KL6lIjN!O$oP`HvdO=i`c%9{d|65~D}#B}iZ-67}9+Wxs7##N3+@
zPm~+Z<gNx3K#l&y(gqrN*frw9hDP#HSrs9ew1O1gs5y90#7Re8#EY-6l)GID2(M80
zCRzSPKw#a4#6c|cm-FT83%sfKc~gGDU<b0h^|NcZf#4&j^W^l@Rd>IL%&)u8oh*-^
zwVcVU?uxZ<Ai2328>_POvV{Dgit2c{Mb|SM66gC<@AI##0OqsD%&knEZl`e6$-EDG
z-h5{ROMCTp!*-#rMu((!58~;&xvJ8)dTwR%omtD-CV$bQee!N8f+Rf>!Ihz^?Mb6$
zNs?BOn_QTs^jPIehn+km^ZVsy2=>KuBcdE==dn9%6v=lT*Sy28yMLTlcmLuA_oops
zW9_?*BTI(TQ#t5`{p9`4O`S8=w0;7O%|4|m_;))I72ifXo!&~>wnc?sjdh4Wwk<09
zN~}YhZrh^bg2d09hwp;>soT=}_ptKnuyT1?K6PHr=(NY*Uh+Do2u@Yac(rGWJ$)nu
zi*lT$s_lxg_P1QB|2c5(R1t}OZPg%H&n2P2(>+wI{b~I;OKQnStvp;Yc3a)f1V&@q
zq2HltZIR6XIF7RB(kaQxpTPCd-kUx!#s8mEi^}&V-(dmc7XxlKEAIMB{*+-%bzc@g
zf1V~rZ}s}bkj6$h!H%&Z(i6W{9aO#ZO1*MI37twjL-3_DZ`<|4SBrfW7sNWI@P%gc
zW_YWP2u1cHMsW}GDuWk?QGvG*De6L=14g&LS&;#b440oApPvbb4jIZ)U|?pfTi@~z
zC4_Z(b#29h9jO}`(srnU!(jed?~E+$FJN=R3yN{*P?k@GWdrRk!GoCi88vc^#dDdP
zytC{PJ{~Z{{G_=w=s=z41e^01lB-A)WwZa)6kMOJTd6@FigDB7Dx~Y6DQ{V6nojGS
zOj=V=olE<Bj!=5(r^lM|t1Pv(5H)4p#^k`B4>dvtjg{Wim8|u@usT!MqXPJ2czTTP
zB<i+-Q;hVs>W}wASKVVkz;6DOes|S9r$3KCB?YNH@atdNM^W<dw9+uHg`hg7qi{vj
zUBnvY3tdF@g0fh<+%Qf5{kl7Wf5DXBm-|g6fK%&Fd2Gz2iiO8ys>Poi1+y@{BCn~`
z6*<(ed#t*q;wGLK)>Q)J`g)gXUo)>+OGEvsk5$LZZ<6|3Ao~ajTp-SPY_d1wF?$EV
zPd<j~y&iEf`B<!7aSYgFyXsbHG+lM;`Il(2PeCTfGDm*A0=O#1G*%{Jodh)bm}gbT
z#oGVGh(Ly__)|7&JwB^}OQ%4@Eq!ujf>*Sz-o$-l?f3GPT3E67rtZ{2=<Gc?)<b8P
zuz<>{*Cq~vH#G&%R!7U^8D&yre5v19N|-Iw4(RIc&F0?&5zd7jb$3qP)`>1~%2v!_
zhW{BVd8!=v#tY+9)(fyP_Sx-EUGEoqMf_(1MaLn+P2DPQ!E@pW-)A6v`V$D75Nq$$
zu<D)yamPww($EtHyO3Gw;w=Ugp<qU!aSI)Oax0^~<zanZG{VBikHN9w2mHp=q^z@|
zpt@`=*CG5KSKXcbn<D})59q8kbD?G{F)=kC41F|aVk!CK%Df39&|ZnoI`nL|KVcMQ
z%F)SrUFn5NSX4ni3OTvVIg6Zk(#!eQ{UMWWG#EzJA}nW|X`EfaGpThe8~v%z1-DDt
z{Zu6*lJz0dF8yV00WL!ZJaOtOC}8LqR5D2vsqP)Ge{4Q#otIn%`>3-`<UHmI-&*mL
zGgCJ*%O4px`9R#HA><}QOmh^R8BOsin%}y|xb(=Z<5OJaF);_=YY0BS&8Cu(UQeDk
zWqrDa<*r`7hcaMF0E4aar*7q$q(cejM+kU^TGCz5dFTzRSe@Lu$P%%L%}VbfyZjJ-
z6trzcWc@2&p>D}9EA}oLk^YK$;jbRkg==JP6Oe`8gwg3WV6?Y=L8za&0MX-BZ_0fL
zb3N`4O}Y31puPu>8JyhK<TsQ`hPv1>J@G`eplsf<1&g)I_ma`CX)W`#v&Ms;EU>UL
zom1Du8woIUA~yGsH-ZQxtz|tva~0!mRDSDltJ4@<V|6M!r>u!9DAC912#;swcJ}vd
zXTMl0V9I^|)cYs-;{hP~d-`r{9UOLkyz4ykAOH%gI6EEp{3Fq20R*nD71UQZttD2Y
zA^7`EE(*>CWZ3=^$!nu@LA51W&fQg{B(Qw58G6rlaTJm!{Ps(};WxpYU#?!0+~~d4
zRre-CWu0wxe**W%m^1GfLLT#+g1=qQEv6O(1+iP+;mcp}Ca*MBZK{qXZeraHbz&!}
zofREwqPpzn#8u<Q)CJg+;e_zA-5*+zsN*4~>bh+U*+>K8&#r!_$Q#?=pYkTXc_o9$
z9EZ0nw-0s~(!M}TM(2fC`$Ga?VF^#hC_s<5&K?J+1;1pFS3e^20&q4Iu4>>$hI<E^
zZS<yY_NTs?e*=i45bY5<S!-c4|80eKvkFgmtQscTt)vC#C&?g9tqmE>9+}l52po@=
zNTsn}8B1IvU3J@}B~Gu0(5v6V>Zjf|t@A|`&0=^>)h{8+)R3CI0RN3frIl2#O$NkV
z6$8?W1Jc~$TCkPaz{pgGXz7UaL{Wn+uui&&WN%02SJj(i9dGfSd1&Pb2q&2Ewkw`%
z%Y~NN#CmfjjtxujvPsyRD{;U0-NI4ob3P4*%)5<Ig)~tl92iZ!XNhmJvb*Xw@?B6}
zYJ@R3qz7;6M&_cr>>G($Miqghio=kzZNDJ!;FO?x%C?15vt%JoSz?qiAxjzZHW2^x
z7Y)<(%xsXER^(qdju~$;()D}OyJ=N~L7&hD+;$^(M2&?T8hJql$X9PIilf?g$jzJm
zzX^fFyH%**eQD!2mb=xc&N&5(jhzkz`_jf&UFyEHq43!dSVSB0dJ7M1PYP*nJulvV
z2j8+!Mv}}wr7mYZ4^F&KfA*|*_U2XO_`m^<9J}_-x`!;U<14`Ay|u0{u7j<7>Rs^V
z-1^CobDCa#Z!$s4*NpB#%cW;tI&1!gc}8r>>k_H<5Z2_6+&buvuzdu%9G$v4uAwQ}
zlz9(c&DRr4Ah@o&HjO3o*;&im&O6x&&reKLMz(ZVq^m=fRG1;*4{-`R*Q)t2ziI<9
z_KhEs<xgqj;PutU#une|<1)9D#(XOh_ibFfb2Cq@vC?0mVK%n5<x0>ldA`9%(^3n{
z5<?5f)paEA?Itr~o_f8gjkYy9`ny%F-6^c$#-<J$g4wRW%q<3a36T3MRG{<X_<Ya4
zrd`rVtfP>;oOJ#N&<E!UA%9#g<%(z$*HFNF+s#$Fm~5CL0=}}!nFC}MeQpQ&blb?L
zvAp#HV4HnaJa~QXz=F=H%X!GFz*`}>yE^9cuOSz_)K~a3hkJ%^Nm4wr%XCQ1ssfn<
zBmKyw!x1n>+P1ONw+7UqiECEczjQc`@t%DrH~aQiB?i)-ze4TR5UAf~J3SKO26*vx
z0|=gWVmN}^L{MB~%~*~blp8@)a4;ia3T*^;Y6K!MM@u1fr5J1aMV32AL@$ENKs@;P
zq)^;J@>iW&5H_NEW2}8LzXaMy{Y8~2*Ho^gCzds!M`{dK=jt6mPI@^12usZomZ&0!
zBr}pOjfLVJro+xiT7vH&vd4Q<+;AOnHwwa&#WrUS3t<<!Gg{}IH-uQ6uw_lI%kVZ(
zvfV9>I$in~q(2hp3h|!cv6?o@3gLBaNj&^qPipWv%4MEjo`;7IPmILAA4NDwJW2cC
zVpq9^agXElT7wpILsTx-uIb8rpUucyp>@d6g{Q}W16NG5+VN{j7_r$V7NuS+K>T`N
z11An+!FYq4(TA&A13yF1H)jV<V}D}c2x&R|O=&A!jiovD)YnO3BZh`I@;HQ$2=WXe
z?;=3D9wsT(P-7XN0m;1yJv~&IZ<cj-d3q?t=t<q^xhRI>42b8wm)F&0d0ow?E6mSW
zR86f{k*-yhnnU0PmJ~>0{YWe`R55)syE<+HX<(ut)0bsI(g>!vZ*nKdZYssa2;#hK
zluZguG<By+@6Ej8TQw%;aDRo8v|i}aVbd5+`fnT<^63Zb9vbFmUUU;{@2Ali(gGH|
ztLRpIh_l~NKaVnA`)n478Etzr5AQpC4I-_$En1MqJ7-_j6x@8BlQzH1tgbu*garS3
zbw7M_?1-wpSs5jL5m8XAFv`*A!{QH$(S;VYgv-tqK02@PT@+3aiV}ivxw>JrIE#v$
z-bn-$KiQ_kt_Mu%4Vvv4ZNiD%7Sp=h_%!{vy%01AEe#^nrsR-_(eoF9!I_TLmSAx<
z?|oTPmYuMggOxWKZDA45_uyZDoPT3E%ETjeVn4NTozy*O4Ng5_Bi8|`8_S9lxZIXy
ze&G*^H*liuEa}f3{;X@+cZSHg_o?!AJYkV}lW0mT$5;GQy?>nWTJ`RE&vJxl49-=#
zrg92;a;#HP8plwrmb<;)`rPn-EAls4fVNAP<Vie`%?!8t!+FzfC;t(XdfnG#aQ>yv
znf>txa8JXN5Np?iC#E0oD-JnH1U0YZgb!06Up0?V^G!LS7?1T`iCXVW?{e3A7H{sp
zpP!-mZ3yPf{v5`NJBRnH-g#YV=G%o^s^6O1*|FvNUCzGlv6q>lY#rX0pV>dHU5dSc
zJH5z`j98P27x17iiTiyy5Pk7$1MyLfg`z3RhNIE$%|&nL;zcEUu`Gx!Ihlsk^IP)<
zNAIPm|Jag)$N+{N_6(!n!W6{Xi%7$YcHIfD0_g~zb}2cvhpix3p@cV~ys+EroBkJ+
z)!<)LBFl{BUuU*jaO5uW<kD!fHKCMZ6H3#sh~4!ZOZrjL^4_cBzSRV~{&rR~XK3iB
zDADcI*lEZ}s?IuZU1liy?-GB&vV-cERuqmy7sZ1mZ~^FPRsS)yrPuw*R5}5x0628g
zbx3Z(N!lLS%KT9EhX_KBXy0=72ktOfM)--M!~rwXlAwF|M`Z2Ulchjt_Rt334hLT*
zwV-_OP54;xDm<k8wtniFHw=##zMzHRyrb3e)biA-qQZ?pI`?!m6HURnSxAp{kp5~@
z1nKQyjgiNLM@Aa6^6JVn_xQz){$#b&5HH*q4-SS72vvdV5#gNOtT-N&kmS0;aJ1NK
za->ntaMN;dG4}}q1L|{#_u>hw$4n`YExAGy%W0(i1pVU`Yr#r|{Loiv45PlL5^R_X
z*A%V>tK1DYm3Wg&(+Y5B_9G5IGTk5SP&vTP)n!G={`en77!#6+QfwCp-(;~Fnp$-Y
zM%){AA`r8FOik(BqfBLUEZodZ;UI^Y+g^+ib3YZtQc9crLHGv=4>5z2aG2%P@u!s(
zzTsg$R<N$b#;rX?Bp6(Ce1u5?#K*pwJJNz2>A=JLne6>g7(ZQf@psr8llwu#Y!u_j
znL&vfeX4xJKK>u(KNs4^x_fN`zi~eJ1!E?D?$J%bhT{wj@tN<r#N(TS2Xcu&vc%T!
zvA;A2Z-NN-WcKU0EDl=USzFk)=jg=Aywc0FImzzo*AoYx@NB%Pp*c`c2|((qD^u0n
z<LTd}35u1+^~eD1)!x^lV0`ugt#?=_GV`NhPxH%#)=xu&Pi{*c5G}ND$uwTF(jl5M
zneSt@cehm?OV+gMWUbBiu8d4u?mng0`uZLPd#o?vo6UoZl})^ADRy}%?C#LG-&oQ(
zyRad+ezxtp?mkXec6TLCyOLv3W#-L1`r~LAYgec*sMVd)=FRb&Mt0VY!le5M=R|Uf
zKQ2zwpEbp9<Cao)Q<^xe0m^B#6;wMi9{keDgP2@p4q48^3Ky5MPIA%<S^ngacoWo)
zqC@V6xU`W668wadVqz&L!$ivQ|A_wc_?_FY^nU4f9tj4X{&oY~F@#MAI-NZ_t5k7k
zq%P9UG(#89S<{Rv!hc|AgSc4WT~mQc*TPC~ekCV$tdJOrsLRfZL<Ydn-!7f&#8Rg6
z*6EpUA*hVP-yj)b3q!mHr^m#4Ftk^OgO+4saE3Vc4k%-iAE7yA`#aii9>uS|Y3Vo!
zNn#qCf5<ALiTf-LXP9uFZsuT^_Uvm8hQcD+H4z}b;7`z`%(SHyu(UR8wTS`j^!Zw4
z3l#BqDLsXT4SCh$P3|?`U58to*@?-edb=YIE_54wMWqXNtCN#)(*XI?iGFHaFMtwJ
zWzVdY2lokHevTaxt&U=BQ?_*_L>!zP7M?IRy_s|@Q{08(xJm#%xTU25r=;ef-|HbE
zasLwbG$Y6vl1JtkI#X#ZiGx=DRE@8p$0$$E{NR;H7;5<-<mIVBBg7gH?%NzTp4<=)
zAuB9q9&-B^FZB}3&8;Ds*bE^81WW*`!Qh-n@H{pdWRk4E)u)uFxGR52ukvgLAeALT
z+k?HSYFlOTDNUbbMa@yJ*L|4Y=f%HeE40v4KP^Yt4_N8%`O`+RWn8G!(-(m?I&WJP
z>8j|S|HR6WS8555z+-Jp-PXi!(Zbsjjzzi2AJ|DCiJ+>h(ObYHN>9Gpt(RE)^&p>P
zHz@<$fxAO5vT+s<@8Eb#7}cj1#Ft5zYlR+p{u{!XSfaBB8A%SrPMll@H8lN4aG?A6
zlGNG~Rs0`*JHP;w__IewkmGBjM_;c2i`$x^nfR#2;FUf`nh2Atk}TJ4eta}I`5h&7
zDy<7z5UYNhE0g$doBTYhAQn1<aT?L+DK0?ONkDJl$dVnOu~>&<Sfp>{pC0&Cuvk=S
zJJQdQ6XAOG5fQ|HN>3)8z(F3}Vt;`IGX0X)wNPz5n9L9GcFCoz)bk?IWINhv^|n&I
zDW*8jRS6U+U<Em0rXAV3cMac%Y$AAOfcR}(9yj?DM`8cx;!_JRF&DRM>Nf0{h2Q>~
zLdC^yq30D*ITJ&)ap&mIh*jo<ME+;W3TC9gnCmaPAHd$Vmsw{^PqRu|>8dS3`(y@)
z@G%->#Wx3!9BXLO9$@x~%-eo=91Je9$bA~TVJE+7J%`;Oum4{5z`go6dtj78SP43N
z+reVfdeyu-3&4M{d&}!TG`Vez`p2Cm+SCG5%Su$v*#w6Zlf$RmuOjB_>_MgfVq)_Q
zW8Ge*dx(AQLD_WJs&FAJ@Zyzi=N^~1jJnOiMh4>S2)&w8Y?vm)WJ-yMw=(p}Q~(k#
z@<w`1IH>XO|IyBmw(FaN)ZsQwZ8sgTcTA$9r3J(ljL7RRbIZiW#!PzU%i_gn5K|`{
zVCKR7pD&~F>sl!>yVux7t|olskNqF^gmBNXk2%gvx|)KQ^I`GL2u|!Zf3s{h)9$?8
z&h%y5%W8R#Wq3Ha;&5<H!7<0=5AIiPaDUa{E?Jiw+;5>j*|*BJe}McBLnG5J6ymTi
z(+LECysT*K*@?H?S0%PoZK>7ok|F$fe(c%F4|#v1F?jH3w+IekipG-<K041IQi%N-
zV3-sMW4mi*$ujzX{b?4i3jP<Ra+f!*OY^U^ax9VGP|`g)_37~>(EsO!6<lt14ezse
zrd{9&0x5}*8iJjN7$AW0qGNV{@h`7r>QG~h0+vS_o6!$&#_<b`6O%N+zh*R4yes*m
z3<gT@oWu$WEh@#`c2-mfGrG3@(}#==7sx<t1TsyfT_X&gJ1A$)6)vm2BUY4y6qYBF
zp=nuI)-y*E8tcmQ!uKE|*$63shv{u2`q^dSU=r*6X(GU%^8iarut+R1ij47o=36v{
zj;$p)IBF`h*q=%9WMz5|MMXbWZvsD<B*ROrUFN5#(~6VtQXeUo_(<oPA9dy}Zzsx;
z>kgBuWQi<(QhWL&2U-*1`G@@vQ8V#5B-lZil3*aPHuIe8^U(BOaeo}{3CCE1<*C!v
zNz~D%NvsC?V-QkQ0Zis?yPvJz8EfydBDw|qbta|+1#hxQ4aqw#^h5GJGu_g709b1;
z$r#MkY`6nGE%mMPBYKx$u#5M+(71~VgO{uN6<k8>8caB<X&ogTPp<tYd<b$)$FBLr
zk3qzBua3F^ZIOR_sIN$T$%ZjF@%hy51Kk6jvY(sjHz6rI>rt@E$*-JEsCqhfI4APq
zPaal1y&T6eeb){T-E~>|2YBO$lK_Cl-b8GhhigHGCeGn`%*KnQ?5@Q3{dy7cnW18J
z+~|04H|{E+k*m&jN#&YK-3N>!nlACVa+$^IxZZZuMsSqZ!sl~^*3yFFrK^R}*24MO
zOmlNm_@cbrbvyt}=jO3zM=c)D1FO~3MkVUUOdB2RkgVM`ZnVZ^FV<8~AC)*ATrlGF
zZq2Uyl>aYDUQK!W9hXY{h_pgcc8#;6R_3?R0foI9v_8YrkCP)%SnwKZd~{<lCIsb^
zFe`*|;^>B;GR!)fac2kM5Y#8kQm^}6-($^D0egaH%~8xb+aP}{)LXOUzuQ)&_6$yJ
zl@GsPXZPBLhG_}(xJ4@RUb}EVrmigch#4ou+INBue}Rm&5<gGv;XR~BDNvC40ZgJ5
zCh@2acbVnf!O%uUb=|PgzIZ<3j2H~Dz+?%g>j}Gpyi|7wQ!Mn{g_YJ6tVn%x!WuI^
zjv-CemZkX8VK49s{62Q`&AN1AfzO4bT<15BM3nimftI*hLjU+U{Z2PY``G8A!}25m
zwi8>d{a?5~G@=k$II?OBOmfgm?%Y;CGW~iMjo<>1swY;)I%FxF*1ZpL>df_<_Y~yU
zNLS(Jnl*@9FFdd)4whno5!Hn7AFJC1uWmg%4zTuv;ljl6qNkV8E((abBtoozijoEV
z8X|GfZV5v>BCqZ#S;EHJFJbiF&aS$bRTBF;s6w!enOw;m#zLiw4dXXg5^i*UNky!E
zJ*m}kvi0HI5w>B-aFXL^+!ya2lE9L-BJnw^8|zp@%Z>@$!xy}(`mN+9854Eu*dv#B
z?HPNKau$@1xrjUFPY{y4^+EGvph`hams`=qRem8unc+9cVsE^^;JGn3R4hCybLOn&
zp}pRC+3Piwx&qkiJ(soD8xL_}uP1~SV6Ufku-AKTKlXZc&rS5|o^!shmsS{KkF_5T
zQZT&Prg^HX@anlY<rIZ&9e{Fk$Q(Ii*H-<WYIjSA^cQk){oJU6&!QkAgDWpk{sccl
zBl39AFgV=QVja&wNm#OmrZ?V{&7t*8W|Tc65-SCbyK%QYfDa!Vmc|M!S;S@kj%j{%
zBQvs{4}ZaC>B8ArHu#H1gVvY13Q(zbA%Di3Q2A(?)m$<<Q!JBMOsO{}z6?TSXX32=
z9v>9Klx#9nY8ou9uG=V+TBL7Ojdw%^5~uhxwo2#p1I`F+DOm0^OmKv1^3C9tM{QFx
zJ>v#$(PAC*C}x(u9bXikVJuX)*;}v`g9wY#Dq{kB7DG+GE1W3|W2}9ap-(G7$eh5k
z#fgg0Yd?9R6pWdFHUS<ta6FC{Y=y2Xg2ei)QsNkz0Kl9^B0Y!{(Q(IlqQI#YUQ;Dh
zS}|`DgiOGc|AzPY3*gOYnqL;*`XAwcJGVYrUuZ~>yY_AlW1S1OgBe^q)}XrPvU*&s
z<2%rT;<nn|W8HK9<k8~@!cq4e(Rg$`kF{@M7+Sju1V-!p@@Blu`JSm5=gSC^>nqWd
zJ9qz6m}4pPmbShok04U7{rrnCFT2HV*)3*R<<fo01T)d(->7wU0fP%sR|<i^tl(2$
zdOnLfA_bsr%%To=1M;i8B9)7Lck*6m;;K5<{xbtiLQntHjU(CK_W(YQURqzFJ}_K5
z?=bHyonPt_)qwizK0qy`F$dJk;5eMm{Q~uqb^8Yj6(_{oNmWL&BpM0UNf23!PRd`7
zD#qF+6Xm$~Gr%pKThmBNO{IJG6OLKwb5*LYB0D5g_Jj&SbQfAr0|46u3|d26EN!$!
zqkxetL@rJ9&ur-}N~l|}yp8%4z}Um<)9s3n=rg3=So?kavMuL#Pe&Bo{@+$O+IIFh
zr1>|FWU}sX8<POPj#A47dA*yAdIx#EIqHOvOF<0e3(<&Hv@`@4x*#7G>e5b{&1GKw
zNUynEOK%2Oui+|e)Mu8Ij)nU(Ypk*(=$%mrbF9L>`Kz$Gnfwo)ipJ0pqlw%qbb65A
z;X3b+lPqRTA>;WxIE!Vlk{h(c_2GiUEB6Z>`}W3{rWcXt?DubBxXymR-M)$ou+I~s
z>MDYDk3)K0TDlid9_v9H2g`xIRJ%I#ksZVIXWi8EoS3=!9qI%I2poL}WB5!o25j2%
zxd>8z7Skr131=s8Aq^`T%zIC}9Ll)Dg}dx7zOFx~fVqo!iU%uNJ2dF5@JB*NADrF^
zkdZz}dn8s8LV@kSA5iL{|Aijg-K<K~tE-3y^FvQe=?`wpr$rv;anyICtpt<F%&aC$
zeOHoU)OXt2Xy)24?6GX_L28iDW7K!VGY)r9pNwk4xxALo^f3L_s*JT)XfP&)3G)Z=
z%UJY_YqDMJ09hcH)0-ZuURmMR6X8IY<75uUGbsT*sirr}H!snz2Hcjg@NH_@yOHP0
z>$Xq31h!0#+5c?BusP^_NKCn0{mwSp(Dguivwa%#ov&%i!nT|4Y|>B9!M2Sw!8WtB
zDL5hr+5bezBb$Q0BpXGuc+!9Th!&>~1B~Fjm1efy4e5vCS$d?pc4&FjHXn@fjUa!;
zFGI^CtFvfPoLGkz&NoA{Ncn~;){o$T!iGDMXEOcy=vLW+e)x=y79;gS6{#K7RePHF
z@~p1fv+UoqB@*IV2oP}Qn8xm4`JBK))^xD^oL{yToRov*+oTB=h%7ibgoR6ln^e&)
z;rIAVzpn{f@RXL`G00qC!BdzpuWps?W=MuO0VQLZ@e#e_?2|YxwaDz(<>2!HyCU8^
zY-ZJ~P3&k0M)nJZ5~*6Y`%|9tF2a5tHdgnX_agtUvZ?;@gEn}LZxO3dCDGPz=MdYG
zzLNxZtRXq$hlBpCakXgBhx5zrf2*<+(9ba~8}!jmT+_{oo+1k27Zhc1iIO6B*P<+O
zpz|L#4g_ag$o`jpdPiuV%|qA9{xb?UrfE8PqSvWBOt~s3|AUdsYAu(h(ILgy5D*zi
zOh1eisyUcEvLX1k6U4;$uZQAnYPg}hDVLlCl&JI<a><M66PKS+H0bV6Ouspt$54<D
zhni{(C%9TJ5VkV3YVI5I1Eu?uxnha6moT^Cp#^qVI=8P`nq*#g0@QW{D0*%Rp69s&
z_r~Xw_WKF<d;z79QgNu}o#ug=dedoy{$g34x5dsl$rJoJc!?&C?wk_DJEv}!(AC@=
z{Oor&*W+UC&qLnkYxtHwX9NXLa|ec_`~?AVHV$>(AXSMkVD3<gC&-x7Rwo+ARqw`)
z8n-Du-7>?wQC3=o$#zqW>5nmn>)>Ckkp{6b$zch(IfmLhXI-tAlesy!BeM&Z;g=M`
zUeua%$Kyqs3vumY#<vDL(e0VF`;pu?FdD?Ya6G~0--e?xW3N!^Tk7UI(ib}O>$xO`
zgqPD#hxQp`W|R^4e@hsCn7RDBp?Pp3V{?|k2Hp+>=9UM;Z@|!(eQF5^lwfP>TiFdg
zA)1*|)({NBmwFn6FkK`b503t&78MLYA;rBK4oGMrIOwCVi4UiODQ{5XnEu9iiH_~%
z9DIrrwbj$g67lM3<%!y!nw?PpV-ZM<Lhiuzj`p1uHFm`vqqLcPiGNV0B-eQHQJKeS
z+>4jvB|*UCiI`Z03X3Pj>Z1FF;rOfCc0Pyw6Kg!#SGH!a#^<(5lZR!E?F@4FW*yJb
zHF0x8P(3kXH?z2ZcNbDHz5kE3cLA)bxc0b{5FudTM2#9P)~MK`q76POk*Il)1kuPz
zViH6V?ZZo{t*GY!R)OG2fXz0N`lPK@Y_+9oTdlT&S`Cj9P^y4bQBm=|HwQJo5YWo^
z`_Jrs&IxF5zwf*DUNUE9_RN|!Yu2n;v(}p50E0%3t~>T;w5%;&`5>ZAoIJ$ows$)z
zP2@sdK3KQcPSXX?&Ku1lG#B+wv)(x7>T8Lw4Oe{+rM;ekmc@7b=a3tWs`{f<)gOIJ
z7Kindvk^A$%g@c42(06AYI)Lpkl)et(d2Aujcic0s5g%)g0$PjE!vA-?0N@3mLAN5
zf|c0SZV~<%T!h1Z>YxJ`aGv9Zy|g{BFnL)Tlh~7`F?n5YOny)kU^3FC^M58bV<~KI
zkKJdm`4Lcm6*g~9W7FuHn6mgpS3X~{pGtc-6s#h_ziB<9F_QWtOu{1MTTvmT#hbP-
zcLR-i=U+rU*C1yvoSjD%i?c)Rj2K1mMZGYYF^NrKZ^qqMiplhPH25tu{4~<`2IJ<G
zp#9K1#uzV>gu9m9fPFqG&4gtc3dv)%hlFUg+w$Fr`Y6mI?Q)h2=BtxDX_d<HSl|%N
zff7X!W<+C*BB-vAw)VI3a%_^kdA9H=ovmb8NFl53F9ASip!(UQUr0fvGmGPWQ4Z}p
zb!6gML<6)moDNMFx&r5viCjzfXlNe3SKI(N*E$1|eW;zDC0wd?h<42$kZH|<TWqB5
zMb4qz60KXR)5-8I-4U%-J~s>u3;U~$s4*N|Ai>yc%B$Ptj2`S%phjCq%bd%d3ZgmY
zIae2-t~fj#l{p5VUSN{XD5>Z{JfXt3pyoKV5!$fy6s*x<Y>s;4mZUcL(@YOEoX6pU
zkrzhh=71+Vgw+}XDy=%Hv_=QsI{2H*=Lm+$burMbbFVhAu0SpZerLuyOa$d;GPTgC
zX*NoMzfFb4(>(qsi`GkwCh7vKusRcoNgA!glc#iRDzfmw?5)pQ`M>D1R(_Q}YbE-u
zmDYx&_f@5th*LTLnu$;lri_W0CRk^z!$ZrdB{0z@O%5DUdMBr4u=BGb|4Mctw`Qmc
z4i~bTHtR%NV^F!7o5p%?``=O+-cQ+}gJWgoP+tx;Zqr~1$4CCrNIN%4Qf)4=Votl3
zixb}hooZQFiv?aI;q)9wd7|3^8P}=jV`(?6X7wana`?i?x6dneZc0z`6hAZdBtV0z
zq!LxhI-CTV$rl(hbBcCjlm=>@%SIVci;*7(nE7r$Nf~wPFzl$?*j;VbjNdKwRQ1Yo
z5FK195dRhQt%iKt<<0NbDUkQRMwp4TDI|&fjApD0Ku>g+B#$tw*PN6VY0#7x1X7>;
zI@}pu?2Ns_b94y-@0r%S5NPdc@2)^g1x_lou=rz+{oNIX_Lqsz;Tp$zy}=&!8vE(K
zv`ajXC`1U$a)>k$Oo+dsvN}^%!NTuy`q=|mdxNIiV*54PwGRFNQVOv;ct1*^8H_yN
zV;uIkX3FyivjpqCasO6iU9<HXlYGhaD<#uE!Rj_1+b3yka=MMQ6_JGTN@G!k#^UyX
z@fuyrUBW&qkSp?vp-z3iQ(xeBD9;k-bxO|IEKXt?Y}#yWE6;y8MVwz6{2Jn{9qKnw
zKk!wvkAos_BKxeghm0uaNzv_T$UzqR_IfD7-@vg)fbQV0H2W9xcld7q3H}H+*uYtZ
zj$sqdjE(-CBKIZ{QPU>hp$^j~Hs(t#S3%QSe}9wQ=HD-Zt6tY#o+s|+Pf+%`;aT`a
zVLf#gmYZUD7H;l+7CtvT3(sC00^asb0mm}HT8`&*jf)A2aTb;Gzee*i$bQpZX~MJl
z&+?O~)4FhV@gwvOcvPw&1!I%h^MjNcGTVj;2|Zad^M9!}>frF}oU8MF)7y-V;+nO?
z{K1s5^!<Kj)&`5$<7~{_ErJ!$Rxj=AO7?hMs?omow9tQ%H|p;ioV2e)pi%#H4sPZ?
z)vZvZiMDUjC>Fic#J+BON-9xbQDnRtjE=CG^Inx6LXwld*(!Y36*Wf{6s2%y>Z4;U
zJZZ(K-=&(2sd^jh**{kU(EVhj?ZKd66;mIwjGH-@Nr6%`)FSRBb|Y~jx~&-MKVwgv
zQSYHXATGe?Q2!CKmt3a(=-J)gyn7ho^*U(Qme5Q4D|G1JLJjJR&(;oQKn}-fB1P2}
z_}8e!^4vfDUOcybC8+ifrGZO3%@hWZL<LDOS3~_#Atc8Lk`#c)3zC8Wk}vP3p^cm*
zIZ&PtwJs?O3f@-1V-zrPA)=lYYW?5o+?gpaEpy(+0v6sg-aL?y6Tc8bM)y~0%qn9C
zF+UA%MRC-tkjBN>>U?tz;r>JCo!98Xt>oxCJI72BA#Jc<ln0`Bd6*-sSu0N`b`-=v
z)E5=p8IKLi5iHa4n~BE<OXL((Fge>hc2n4G-!*<6#HGg4?;RL>lD+NsIZ*Z_j|IQh
zSG(E!{*Hj@#hd9q9X;N@<*>5eL>8Jf_<BWWnno|82OTwDBV_E6<VL+C!WLrprdu%Q
zZt5o6(|PuIDlJ@Z`(R!@>I%&FaT@*DtdFSe_c+t9F<20Wapcnz6Y<xrS#M^%W-LaT
zF9ZW&2=wgxLI!$HfCdb%d*ib}2S~n%ddI(#QCqJ&rDvw2*ZEEICRed6ss7yP|9~Zj
zdbPcQzeKQ<K=*wmS#Z;H2S(a{#E(Fp2I_<S=V6C|zDMH-!p}(Sz$KbYen-dO2}XXJ
z8Mz+X4l%w~L9gID*He!T0}HJNul?6%&#;W)6nYa0RfqP799!%W(3#OgE78gQCXJ$5
zRq)Qv4j4!5WEq^F6Xu_k%IBe~+)0hfkM}ft-w5*~?d8lMZG`qPm|-UGw!tfWvtf@G
zd027scq7}=-R9f#2wjHAl!9%7K+0&wtwLG}qy2Nzge;}7ZoeB81USsBt;hf<(IV{&
zDEDvUAN4&xKbdFwt2tSBqag#BE}diI_)1SIVL13DY!7MvSoebb<nv#RG{6h`^#?Ix
zR?I0vh7^s@d>S+mdy;HTmC1f2%#OEWjC&^8JgyL+$)C>-+iN`s_A0&Xy#VyUX&;~<
z;iNLoG&>adUp0u4wTpl9mwmEy-eY&Gg7+LfBAmrXz5e_20$!j6!0><9OYB?3KRmG?
z*=Pe+czJo&eCX$Vp1eP_G4uChGXMjV%e~JE>^luK5`WD9A%o83C)VCDP<iWVcDJ@T
zByQO$>fqPo9%k&zSra2wW1@_rN_9Tw(()<{j`CwiCw4@5z-UK7>>IMnIf$+sz0)_-
z*We-ErvwWH@0WIBCA&TTl&d#0V@DZU!UvNUMNcBfVfUqkrGv@tbZbXY^O&IK2P~1W
zW=^`MWaCi3TYGXweWL}?O)`|a;oelsih!M}uUpW3fQ@<&cn0Zit>(sNy%J`zy#`tL
zhFR=|LDsaP!G~q3tRL7c2Z_l%!Vyr*?$_^HwB-_WXprqL-6A}J82?`T%dI^*)WDHB
zk(r{3J8?wDW%8k6W?n|7+`htf8z^%2jL)ZNYLT`NHG4Ht8{C$8)wyB1$tzF6KJQ&S
zoSISHHRYfRaD#!K8<Y@7aOSY?no%k&eT^W^FEi<y?>dOHyT;fZY1;2#Z7@3B)M*?S
z4Qup{Gc|_kOQ&pzcde~~0FmnCYQW(mo>oj{O}*K)<JO26jtq!F&d(wSL^AKw#i_|v
zln|suDu(nWOYyMc+H^(jGM&5+N=<I_jfIG=E5n+<32Vl#acf3X=>$_LrZa^hsM%qK
zNc->jP6M1dIut&z6-w>85Vnx8U4cw`GI(JY@=uB!WHW9)G34+Qei?pe&{mc))1h+(
z*F!1K1pm9xL?CYn&6(u#VJ2mm`1NU7z`so2J^U@8&yYs~ejphm(sqPs1FtrzZsiY6
zu!cyRR%T+?fswXBCc%cdkE&G_8x8k<?(`^OkZiNqO*tQnL+rw4Z!P_VHq-|NBahiz
z&UNZ!WkILCsw_mw7aPymxlac~TZZu!HUPU0(5qjC@q=7rSE{JZ*o(><#WbKwgQyg^
zf>H5Ww<^6-kH66pk_k(G63k2XlE>+#t8YQ11<`0ji}#1$1+)}5@ik$|DMXw1-_m$z
zK^g13)XJNhxiQQ}Ox8GV<o-l%QOjaSay0)Y{nSLG^(|gS*biY?@u9N#G8SfIw8S-r
z3X>>|v@4W=e-i(MyUq`OZpcOUqk%Tq3_tngp7Dz$KLs<Y=TebydbkjR+au~gk^>1S
zM}SfU9I5<3rn3Y4zNQ}UxBoPlvS#M*t8BWgFLc_rb7UFh+F<<>`McM<C=RzHK|I0g
zZBg%(kHU@hB6hj>HjIIb>%Gf4STO0%e|CV9*+(oRerh8EK?8dfCWYR6NtC#m;YxWw
zzNOfB7+tv#!kH%P%?^fT9gLo_0)kUh=Ep%M_ONQldj!iC;J^ff^LdsH#K3^8-wg|v
zh3|X>=7V<<7O&CbwDXnH|65ybYk5d~Nd%Kv@A#6scZ<uPV9gB##6{12J_xGQfxn0U
zhltmIA{^yAtAOen4u?l9ve@B0XtPMt>lP9!#6FS$GtKoajb4#h2O{|`_zclf1Bhw#
z`UIJ+U%$T5z{0pM*DA1YKV4~M)J7wM-1uwTz0@zUF`%%;n|Oy=8Acd6I*^ZmzR|lC
zD!>5}AokepTC5OdDqUeoCAC<Ll#e|0fRTs9VZ{p4i;YnpY`XOVVYq5^_-%L9XeLTl
z-NvN5*ZJ=4l>e|ov4%q%5f1Ha=<bo*&Cuu(U6{^(hs#kcUT6+J=1jzxmTUPkAUPVE
z_*codk$0Hybo-~I+dnq5{gzbw2he`QB%O9>aY{yu8T1p#i;=cl&Dts+z8%2&xKpB`
zze}9($+5m>8BEGtd(mAMLL&?7GSWWN<=++ZFXOJ1$-h!>f>{ga-LH4L2O4=~L+o}?
z-MD)LQ!i2?UI&-VcfM)XMRI;<5Uuyw;3ozH=C-R3_5gfn2rrNI_!E`})|>2pt8sV_
zguoFStPohhk~3$;j8k6N9x7}d!D!;xuWI7c^|pzBLe&{fnE8-DtNbnF)_>T>^83WC
z99Fs-U#|*dyIi4*L*gYGD{la<_w-1EX=x21+KA*CEh>Eq@5{m1CT)oQ4P5|Ve{8<i
zr)#-$<ki9D$@li;uOW9e@!_6Ed%K6f1lN%YSrYT5`i;LS{mEQ2&+tbZj2Op5N&Wo)
zxrO!Keb`ipN7rZ`N~?-v`N$iMUg7n2u4@XNYY3Fh6+jFgSfr5I6R{i=jD3ia?OvtV
zIYtNKj4r)kFPvGifR`C0BS#-)IfLJ<3|+n1x9cbK)47TW+=G)#(Lfo$eEXjCgU+~N
zoGZ+F4e8%p(j08|Lw6iXu9NNJHV>i_ic-$GVf_?+ual4<SpreuZX-D$RNQA0>?|gp
zV(6Gt6iNr$-+6PvZtmv1kzOC>MVKCgOi7PMXec#9{4PqLv^?-NLc?%jCnYqDW|wA~
zDzsylAz%>X5K-eqyKx@}QVZF%o4xBT3)D2~*g|izj>z1CnMr^-20QOqjl7e2v))Gd
zW*(cpb5h@1D_Nl<Q>-CaM_O8$<(Ns|Yt_0{l7rJL{xi!UIo+8RfA)wlh#Krm0pT&Y
z-5#54`d=GXMg7&7>n|5AFovu0g5AX;#22v``O~g^|6d;lzs<qdoLFz1Cw))A8PeIu
z*;6O|_7Y6|arC4f75BO~zYfpK{b@@+d^`>*xorPl2WZQu-`BmrF(in+S^6}wA3*X&
zY<XfHQws5!hJBS*vSy6peG3q35n<o<fT0p2?M<Pwj07TWUCO-5ytmM5%Eg3mdvl(1
zaKNq{>`V5PfH=c7QB!W^vp#W5#L@rdjjYIvx0kMu&1MI$7>fJo{>TpF*x{SKJl2AH
zK>=O+#~2!u$*4m;KBQ`+_b!x!%7nEjRjTUgqK0DUZ2qsndD@rMjylSh%}3yJGhJ1x
z)NjN_4T~lpytH$4r2TnQ$LN2r)i5e0d0k?;ih9hW$0mHz=!czqd+hL$@%-3txMM0X
zHYUy9!nLe?GzwFsfn8ak;)Ic|;fKc?Z*<t&XTnX0m<GCRMot`)SKsLE#L~pHo%{`B
za;k=5#xk4=hJHf%2%l8FHz}`<mtzCkx6foh%gvt}YEd-hhyq`*QNr1_a?5T53GmEp
zvG}AhA}Nn5IiE2alfmp?1^Zm=XIMu_680|Ql1iXd4Gm0#yQ|DuG`Y~NDuAn+i+?|a
z7c{kUeTe?kGOyBA7PEw$)zL@sD&U?YrxZonn@Bqno<o3>ms<X&o@E}@mJEAN2_+f)
zFNjYOQ}9&DG>zVQZy8|^hk8%W8vq@wq`mhS)<^ig<TYKG_lfQ6e4JV?V6qQkWTB0k
zy!gA&8K`LXt`o?d!5`Iz!e5!|;$Oz*zN+{73r+_?AA9a!dP?j)x=q?e8GD_my}Ew=
zEz_X2ae>=h5JV!-E)+znt|<=0PM(&~CKfSx<|!hLl)Vkx6}*brvtJ7;*j?@fTY(25
zOi&)0HcReKjjb{-ew!UzgZDd;{53_i1+^Sw5PB2D>wK=(n+wdswezFr8osZItSL_3
zY${HsqI;29orM&9CBBU=7<Sq(m=ybfR$Ls)KBNaiJ_hZergRfqJ7!G9HjMHiHZu7B
z?v*<5?`uPW<tFz{EhA@@fno?!4#1kZtT3p}iTw{injIhR)#x4BW|7s5X?PLH=FtY;
z#3*zwDq@pm0z{t9_yQY;+Z<%^bE?TB*iHPAkOmYxSaUy>yB9}F2>&>~65+h)e54or
zCio-wydO!+w<-NSoQbWGXfg!tVaz@wh<e{!Epx5v{P75iQxo76{xDv)T2@3o(>U>D
z6Y*HS4%q}5HZJfVQ_Za2o0vi)e<g3{g%@)IYV_`S5jb_6OU^Z{SlrlntbT>Q5_;wQ
zvOTWnU&F@;(QiPnL_pY{&V)j^83ydFrC-M00rVE{_gF*9a|QfE!Og}T?IAEM{MWL3
zG&W-R^cxnCMuWsPZLmxeYKj~Lu9-z9_BYbj^uff7hllJ_I;9}i&-v2$d^%q`(+iCK
zn3-C<yztS9{mzi_B25ouY=R4ng=w7W^~t(mJXPE=LvfA0n4jp<$2Zbd)WgU>i@CF+
zg;Zq^a#`q3715hm>6X4V&YgBHCr<Ex%9RzkoH!J=avdA7KKq%yV>FSW((g|N@p^f0
z%-G~$eG&34FoYDoa+f{oDM&-?rG|#dxl!j;?}QKYxc4xo2*HOyGrte6%KHcFz3f}D
z`YPqbKb0ZM+1#cd^RdE)%-GW6MRJTDnjWyHYWB8#5-@PAeAqmdO*mYylum$$mP3$A
zKaL%&XgWRk8mpb|Y|{=4^y&Fk*&SzRmmL*pdz%RakYeZQvXQYv4GfX?6`Iwiyd`>h
z*Si>bAo&aDX=)`)pT?6&i)vHzF{`<9^%~y>`PG}ppARW=6L5F2Ir^BRF7aYY`bOH;
z2lAd^JUR`!R9~Xs&1fR?TD*~6hHUK3&G#9WVFT90!$gj^7A`C4TY(^EY-;g_2C{Rt
zc^5jqIepNta$fa+%|a;~8EHS3m1~^E=AWI@aaB(1PM$n?gH~F1j>NMOAUZ164c}1K
zf9k=$XgNIgSF9`RADMd>Im5eZ=B@51ym9^@LWHj4v-lew7iBxIikXa{laA`GW@VNh
zxO?}iQTuGo8b^+dF&XbEcIL$26>h?h@{ifyxoCD~Z1SrBu7wyd9K`Cqg*QpT(QQ7w
z{(bI;xFBY1y68jR4+c)~WA8gw`f;i^`SMC;qK2<oqIZ*>kG+THz#lgF6KFWGqR;$&
zfj2gW*Ax!mVdCLk4CK6=byYU|6h_Xt-|48hvuvMf1Jf1$kbI@1;>ogoB6AfdA)UV_
z`H$fns*KRZ%$bXE##kRx6>%vw#><$N&R~4sAcLy4y19lr{uTgUgG<IJP>+T@(sm?u
z2n}TY6u0{a@UyWoKuJ4#$ML*UB3xem9w;H2MSzmnB~n8P9mNuzS=}Ggy2XW_f%g8u
zrU)h)X^&+=PwkIU!M}%p$Szg3wK-F^7LkcK-D;oZ^M6Ms-d_G4{M}Q3AsK96h1l0|
zEzs8*Ijp3En=j+(bc&V3aJfVd!#`9qSm3)i`{%v&4522HA!KSP?)A;6*eQBz2x;fX
zf>x%#-+eQbo_fn|2C~e?CfLTb-nikFF2|fVj1CcYke56{hk$b4kAm&SKjsG!luRpu
ze^v61z_rR(e4sQxgd_cb-%nbWF$a6>C+3hJ>?fSOTD*p9EgrO=u#>Q#u&WGqX0nS6
z1{drn>@2~4lHY4T$xrVmwI)RBp8JX3F&auBj|H%QvHZC`z%y0BLVblKR8Kp#QG6tA
znSYjy;z7K2pufM~2g|jg7mR27d7ZS`eww}Kt=y2_drqN6HK*raf{my5{Sq2ww99!!
zEk-o>cBiQ=-Er(pXG$>&XHv(twBQfL8G5=sXQ1{qQ&#&GQzmFR3i6N-+xJJX(D%hG
zry|zwyC9^xml;I*x+S?bm{`4^n^p^^&mTs<m7)sk*zK_kxda2ICOq;m(p_~+9uapC
zx_+`Cg#2Y<zFk#J??ZV2zS&!e1O);@n2-ODFmsL2==~;aD*4dfkY(B{r1XiH({Dgd
z)M_+l+_4@b7-A-<aJPva{bS!s>=+n3BC%uN_`kp@i=e<RgsS4Gx4$?g5H3%ClSyD~
zoHucf4I-^IdLJ=$rW|?X7cA%QN;y?zIhDmMFeEp=K>47@UpV^e0Bj*qFc^feABc{E
zE~Q@9?Y-^o0V5qo+Ra4`FU=XCaC*A*E7n&b>`*XI$VWiABxpiZ@*Suoh3j!0y>NZl
zf5i3PxV4NdZC~?$gx?eQ#;@?fD~gD!%y$a^|0noenSo!;W`N&tM)$^VXiA|_GeqzZ
z!63+$>=E1UQSwd992sq<V%r6A?bzD1kF`@I6H)Vq<TdsU$$M^;sg_O<vfku)6lW>u
zZsimR%t#Hth4-kq_g&6G=G?;s!i^Qo&Tfv|!b`wj@ptUgs+_pP^~(UTPkANS8uF5J
zZ6LRuGgF2m$@Ss-9&BDaTN4{3X{HgvM&izn^$LZi5ESPV#c~Y0#y?WD_j2qNnf>l|
zt|{aR>34+yMX_p~@orY6?MqOhr^>h`lBe<lWD<?h1m7|d%-M*Dk1qXfwWmMcwhabc
zH8YfE$d-?^x!peA#kS=|Z$5XGA<-HRn43HxeL4(L^nnH73@y8{#k!x<?H>me)3TD$
zat-w`CH0s?q)h}!FkkG=F-r$b)%=oih6aa<u=bN@><F*~v7xaW5o*j$+HcnxcL>Y!
z`Px^2N#Y$;4FLyPekqN!P7iLdNF**bTZC}2!gz@pvqv76rc^O>%IWHRsR|2e$v!{w
zS}+G3Fsf3;SF0F1)7oNZmv{Xy*}|Z1DXA@P+2?CmXM#Qws0VZ<g=aWboSi`oi{w7e
zdTumP{yVFowU0{27RL@_R(RMNk4<K#-m4E7GOhnuUDj<&zS`NuA|RG5HwgI?{67QJ
z-ui%)eT+hN?2ezs+5ha}+k^E+xJJ%}Q*^rJtnhNI*u>cR9oRB65Ices>MJVb=AZKT
zmQ4Dd1&KZwF5EQT2ODfJ`?SFl9`p1B4Hg93XlOt>)DcqLfsr|X5z({c%hF5Uyo=tp
zo<j)FN}4BQ-5GD;0YQv6%ywq<IF-3*R-7w~ou3s3&J9n|O5ogZmy*`Gp|8#{UEGnw
zS{@czH%CQre;~;Qit@Al2Kd8_w?q)NdEu^gxoR3Ik}YeW*kHLe94rS1-K#fv6+G$?
zelyhAz{O5WMdms%jLfBLX1(HW%w#0@y=5&vR#-`pcU&UvAKU5FD$!0E_CJyS=`PaN
zEI>@SgJNhwrh#uENi4Gme36ozV(3IR`qHGZ<5q{?mYD=0TrMz;Xk#6bn6WK~cocPS
zIUjkCal&O3?Ohna#s~Q;gO;L33Y~)YO}vL<XL_OBG^}FL5scMu`DFsz$lFtpw~Y$j
z2rm9-+z=xyaZQfB3~B%^$A~KP)cA`MjnLd6$YpU}pq<cOyWP}aYDZk^RE{tfMHo*T
zV{bkB0Uo2?KXE-^pqi)3JbR=Fu3Ru`glJQ*fnF#I4lz$B0^xd=2OozP*#{c%ON75W
z!}d=H@^DT|eEAf*jl)DLOGzRY3G?1!jv`^DVIaW2okI4KeM+w?j$LEs*qxq-&~-Ro
zq#?8-0=E)3iUR+yR9|v2DD&P&DUM5|4oql0VZ`|yr6df!-5M^yYNjcf!+VK(;w%1H
zOPU{4xMny87ejpAmjje!q1yc9jRvm;hV|8`1fOu|qsQBJi>bzwF6J2sz4wX;pdAtQ
zR~_e9<ZGZw>#KBMN|_cf$6I1}9!oI?v9x?*`3p~68LQqwsrg+YH7&Clb+0+OMK?5X
z&0jlaTt+SNylbwCtOd*`Syo>`_$Wi@HuwG4gIwr(D3oh+i{1!whi2N)yb;!AN@Npd
z>)sx=TZToYwBi#W4E*zs3C@c$`nw#XztFK0k1ewVZSb)YDw`FxUtG|#vaWm^mD|*M
z_`$T7vAx1ej;_`l38Fsr;QTT~!Fnm%rVs8ex4KVmcWM+sjdwkNN1&_{rdv-{{rzud
zD9NW3H%o2BA5L<20nT)vT2)4smmaiLe(%)e<Ev+kBQ9l1nfK&P>Gyi&A))xd0Xqh&
zDGU?0I+$&YJ0l!chLQPWtE}`;dRDw`8iApce=25heYuL|b`~9-^BUw_f(CF<;NI%d
zfYXEd@-S)PVdWB~fObvbp6X2KNun@Gi9WQEe4O>y?7hsQ(+At!CPay1X@JKK8+Sf2
z0hhgH`uDE^$!U6%eYoCI$J)>6tL=@NmU7LAsMleY%I0MDhP9H@l_6JkomO9fySX)q
zv(x|U=K|@g%-X=&+__;cPHN{kRp%fB87XI|QEP}r&cPue5ORW3Kbf)tjCun!psHcx
z&j*EP{6zFIOiPesyD|8)J$xF_IS(3J)tRJkl-4hKij>+*eCp>Pq%s9f)&dWO%t)K8
z%ai_|`?=QR@C__S_$L*N{ekxXYWDvR0Bz6u!To+(U%F0A0UweKDV2qJ^V^yFQdolX
zTK2O>ZR+i`fv-zHk0cNdv!oo2w5=v3Z%NZypi502cxh)<>1&ZW)7WlpwV#kG`&Qh~
z)PPEd^p9=fDR?NlKs2DGpG_UepVn)#QH55p36(xO?c0pYYCbO|9HB@+pS}b*fDg{Y
z5zNm<XL?jT-`8DyRq5xkZlls&RyH#Jq4cC%8E{HZdfYncNjHUh(rW`hR`Xz3peWUw
zDq(M5ycz;}mX;oPCtk=bL%3pMk+uyPl_$Q0W~>Iyn3TUNd=Y@Sv%`g_-pldqSJfK{
zL}8vzqp5%1o6*!<nnDi?r48Z_n}M3x*JN%~a%#|8^~R|8@VjAa2GUJwvm@zTr$HI5
z*W^r(v}><H|H!P&?L$k$*9_law2jl6)9S=^Rm0bmzBct;qm7Jjp#kl9C-Eh(I#h2(
zB7X;3G%D5c9Zg%$2Ylw?jc^J%a8T91kbk&O-&==ySD?d`i(<OdHA#m#A2NTC(f`T-
z)xx#^@C`_Yg*VPyT~qp*6ur}U-Z4Y3dchS&Z8(lKqy5EvAG^$IP*)}K9*rGh750Mh
zqOHN~McV()+6X80+ph%K1QRz=$J*s)hQ++RV9XTXG9y6mI=_t~C%(>!Z}fl85W(L?
z*(P9JkSQMyg3*p1$~k&VgZFeY?6U29LQA!2IiQ>~f@V<}MB0v{L=fpl;OI>dbzEcv
z3zC%jAPB*R3HROxZ?$FA{w{W21^FDx1VB3<z60}V+H6S8sm$-LG@4wZtp8IGucHXJ
zV9QlL)DI*NMUXSI9BKcAB<fd*WhuXAvzUEzA8)n%^XPF;`tq+L(@u#|?>=?8X{cMB
zPFUwRQQG@{Hl@Fi4H$RkU!kvE{om+o*IyGZMQa!KHTv3J&zY%%A@0S%uaIn3!2iR>
zk6Qa*s%-DI?WMjnTHAZ9=~}2x`(L%TzY1V65ifh4k1#X~ShVO|3-21%2_VWQ47G_C
z{rvqpD(@^iWa|DMl~0x(5}A7|d4c>=5teN?Wm7-ssMKA8*Sc$B?9J9)$H!i6-E~6j
z#nxS?5#7!zVk-H1cvl-e$pRgZK!!%pS~h{pIf9D>*{;QV+Vv#t?9X>Yijf=sC_WU=
z;~|IE)6YYJmN+!H!;0LzoR=m}4eNDKuOpH5m)*Nhzo$McYw9;=f8MVoD=T(TN8+_-
zX?{muWbT8i6X@%!d$LzWTO=EPxL?rw>88g8_XxW3ClfmknfhW!)t&mgz9Ui2!cXit
zXzHqt#88v`=G4b#f3D|vW<AtVwGJ)g)cX>jpMZ+_^V4E?B|bkM%fQbk#%>GXTkwDx
zlU~BaNW?@9XupRah=xJD$8c8xv#q;|V>>!3KP$_g`eEy?fsyt&tED3O&iwl93YC3k
z%X%n_CH=(|8tg~rNIqi*kTy-?_(<D%CUF8ciY9Sdq+JGl{^|Ua_`Eo_Uq{tvNS9Ol
zCqAbeR+P?4(d_39Vm1{7h_Pds`HXR5^BYwwo)=^u?O#M&oycH~*{jTFcZHt?_^b%}
z+8p$?k-lQjc2o(&kvUgUYOx%d^FK<5n2yYm=~D{Zk=vGAbVu&!I%2t>O&N^S(!}LO
zAx*RoG2f)fATs9wGAt=X+WMKokR0ahfOXKu1BR}SOSiFwe80qYu*eh+N*AuMA9b1h
z?FXkizE2+=#YdpVKO7WUqKMqqC9$Q0QmBIvk0x;%tIZ^sp({;-Ir|X_i_}?1&i-7K
z0%;^i;iY9EbW)w&+?Bi+z%6W7rn1|=O$+2(*v6;wZ#E!Ee)LZRKx<#L_xd*uAgT5L
zDgB3QeBWUG%M1Mf!@^fA3%l@dBbB-Erw$4zELiw|&sg}s+GF9*KPbet7QTJ)HK4&^
z84DkU4xNNEZua*S1DK=!S(QN$ozIyDDQyi||EJ}*9jtxr@;j2bHfv4+hTwOR_Cv|>
zH}WerN6#D>z#cDxk=glqG|Y>%%>amub$9W=04u=)(qo4I_Y7$wP+BsBA&KwCPf0T)
z|2@DLgBTbr+I?8G@z*j|`D6J3kii^mFzSUgUl`(_NfQ|#%nv^ZMy0i)9=@6_sQ-{H
zysmVbEo?A9117u&TX+*9H}nnaTg?(}EDXt}{TJrL4Bj9;OGqi#n!*%s_z6F0!>+tY
zx{W6C{d@RF%X};-4EB?z%=M&Lx#(G$HtZU;pW^Q#t>B*PsTmUg@7GhL?PM(pl&N?V
zPN6xwrp^>~u$gj&n5WJ3$bEx}v1_XBLIXy?t|JRxppCsbe~l`ox5QTm1Z|kPn)z%B
zoBJFPV$<xtC3f;7H(W)l8H;f0!NKku$=H33BCxKfA^RD#P5i7^ACU#W)HweCY`e#6
z+npG@J%DM!y)+mQ_&hdc;y{~08VRGD6_=*=|FrhUFxOwZ_J2lU*xgLE9?uK+HQg$N
z1l(8YGy#9cS6{cU{a$69FZQ0IIvUBCqLKZ3ufJy)gkfan_E!w4{T*@q+xZ8%q2v5)
zBg;kRzRJ)!@rJZ`gyHQ|54G~!0el!6B>AmB@>`_+2EMLHK6k17<L!FtvtLL7?cXuu
z$XHL`H0Y4n#jT1dOs%Ir{7kK<C#_$tM7^Y79BB&|nFafsbm21;@{#42^V9i%(?=)r
zk$8D~9}wgJmMksF2L9UJYR<vr8$7(q(ZHB~WuWhiewh>=Suib4eLt|%Hub{PlufPw
zn(0CS{cgAf#;S!30raq72^^TQ1dK#u>|0T3*Jr<K7Qz+1K$$f@SOl*GVEii$##1RU
zral?So{t2w=bt5e-Yc>59xZ}J7OGi44HiJB-v`7XN@x<%A4O7=h=v1V%$UUQkr6UQ
zxjLl5pHs`v)Fkd2lxpKU<QsJwg?18ONf&A%q&B^Or1N(%fBsLH8a@(Kjo#u^;myna
zyTa)mqRIXzzk1tG?9FfIm<1T}+u8gIX*`r)#Do7!ejBja^ZCNES=~xzvf0P>2?!`)
zv${J??S7F3tzXGzPgkWho1GT6u_v3oV_=9|!)6f&?O|weZ#Em5djuI~zssPfBYL$O
zSx_&?|1TNqB{Uc^)<AH3;lJjmx>EUCekw(WS+X~h@ay>}<gSu|GPo-eQi{9E2OzaZ
zB6B|CtJFH#Lp)Fze@jMt^Vid9CSz`1hOL-0sfA!>Z~oeuT1p@98%|aGbklRjQqp-Q
zTuK+1!W2I|ho7mX^yhRNCzJ2D*+RRNZcG;*Z1cO!YWZ0@f47#%l@uC&sPmb>jV$rQ
zKkzpMVH4?$)vQN&{cj0*>^Gr305|`9h8BJ@hg99HtchKWCZ^H5X-9q*-j_X0IPY}u
z!&!w+!zh99n<9TgK}T8Nj@q1&)rGSvINIkoV;A&8Dz3^s=`{Q^J4T(9jeix&hI%x6
z=cr)R;n}*QW9JHtmT1Q|(n+7F7Q=UC(ObpuU-E^nu1>lLUGqP=e^_qf(GXLry=&%o
zJ4Wwz#>fxp1h=xp9X0O@T}f6Bb;p!+<j!^rwB57eZ-~iLvLSU>zh*^urMae0KG(!W
z<lBw$Jf5F3>&X~wpCn!AhUrNheY@fZC*Mr$?9U@HI|pL$Q(jd1+^h|#OrLQ_=O%XY
zNK94fb8#>EBmqnxlf9tfPe!v6lak!2EF0c6p;tT_>8JEY8@F7sKD*0LHlW3E<+K08
zVu1hU)KA{G5wTAH^Iqu80biH_Vd=EDzTHOW30kV3G=x}G_PfbkHk-C4=S<#LUaqFG
z`L?k&cD$+i=c=5GnGNX7WC)URTkabFm=7TQQM7D~HcovoWwfyq{6fz^P?5Fl@D2$}
zWBZ9drYoQ@u7o34$ytq!liF1ET+CiSd?3}z^Awp^c`zlV8W%~u<5^xUlX%<<%~hS^
zml#k+)5!f{Bk@DYHel#p6LsZ{VM**U05rXF$K_oUW=G6}mK6P70IBF=Tg0sys*%KN
zIAq4>j*Z;#2EZ*H+n1LOT1+#O9^eE2uX_)?INh}Tko+b5!+=fu8gN#syiG>R_T7|;
zP+WHWe79U)NDbl8G=TMg4)7B{jGoQVc<sJ?h&zr**AIt<v2U`;n$b}h<?+m4h9!~q
zQ|V=C6v%^7PTHuUVp;K#7lR2HcY;s`wmKeZN|v5$zfhx-uIHcR+P&{ziNOWMJY8>Q
zqQU#&-wfB(RYKUH<+nB-$ssL`W&q7zSy(atf?03qoSVIAkC?A}f0>Fml)9gb)v{D3
zk51WZ(AybYFHRmU1G^QUz?x3#uChV)s;~l(*^tb(LhGR**tTIjf#clLoeU3b$UZsg
z2mH{iPZ`+}@Cub^5X$4t#|(^aA98y8U2|dk6?w8zwJ!fl@6+m)4mlkO!7SyVKjW{&
z?PI<#*8=X$i)5#8(a`pnXMJRX7Vg>Kxp3#1-{6@s_%|`c+}wrqwU1W;ORp-uC~sEM
zm_5aY8at<%M+|?N=R|NJGSzy6PW8fBZ_>uz1E|pede^qi?wMD<S3Nx2-5`jIJRf(z
z9(V<1?l(BSIZf+yE%6cyUTWwK{9Ss$0$BY*XwzPHZ9>eM-*@RD<j$+c6=t2Y$@`f~
z2>=%>f~pUv1pk!#Q=CMqYMyD~U#>Iwph1sL*Z$Saon!5L26L4t#k_1<>KcuX-%%{>
zErMn&h1{lVkZD_4euVCx#ufxNX|4olBDJRk-~SSbmyQD}3+z83EWUQIcGLaP6BpR-
z%uQY`UAg9|)??kXN5~i_kB_;w7B;@Y2>3AFes@hVV^UtT_d*Hxe#8dE2XXLmd2)^1
z5>({g+icB|wm;H(>x_?&;^8O$WT7?hzixihX7fUkvDjHgYtpCbuTEr3`RmH+A#%f?
zNWy~^kD<2onxT;!6oVL)Rh788OH4Ql@8tUel*e8Xp0_nj`hY<%Er)g3ksn}<mRZxm
zd-KfJQD(Mw@<ahZ29N2e>jt<E_R5ons)>qJ6YJ!Kl?vTe7P$8CY4Q&s)ZfZi44{3S
zMb%`=+k#7ZgWuc0rtG--1HAJYh*K=vZBcLMLw&NkYmAvhcZ~_Z>GX9Qx$M;)Z#N;4
zRbQS8mX+A|IW#A)(NSq*UZi6e33d#(vB0hKG`%NZ$7Ano_nRH8)z8hPo7C4u)Xhpy
zV}=zPK{kpQu=gY2p=U$!?SmwobsKzeQMa@KWVB40PBn|wzspgZKDq8)V`-3wcvCcJ
zh-1Jpy(ogJ={|L(JgJ7(h(g}9ZfP~Gdy{E$k4k#xb+j*ETlx}V{#paB^IA)@BJHbz
zP|IhVne6DK$5X%+)6zsY?xp>4{C`s!sIV!j_bQr1wVOn>-!;jN=Z`07Eka@U*z_vg
z#LBjdE8~vY`f;><->xQIZ>Pp=!Z`|_EoL~;NtdMH>D<l$W*B4<t43gC!lvI7wxn6I
zUvFV$(+~+vE=ZG8mG~p}GWlja9l85+564w?t|F^uu`CLh-|Itr5M9K#ze-!qrltFK
znu+t8fds~WCu_pr${@l5*x5*m{O8GI3{1GDq$OhvYcUfBY)v?~w0{Z^kokVIulLi<
zgxI<8r|~<}z9q27#Ge>#@5`|XjOBbBG~E)XNdjLTLjPHAV@XHl7dZA!J%gt3hYjth
z8eHD4Yxb%=(P**ZyVypF=i4x~f&AsvmIuf5z?Z<j&WHd1R!iJ^>*P%s$jHi)*eSAW
z8mP|JCp^ptbEd9gH90R4os}nXhX`lYJxeRWL?99Pt3Ck>SB(JD!R{DXW$Zu`T;R{Y
zGmRsp&!g$&V)v?(snX9Kb26T?uec^a!A)+1+{v%Un6BQN8GaCZ)^A|DH2y5jjhOem
zj21PfibH6<7+?pxQ*sku4#MU8ON4)7yF;gEzG#+8GDj;)TiXf_3dYCT$`i@#4Ev~V
zYac~ZjWj!!X3w@UZ$|MaZ4Y~Zj1&>cqP!|tgy_i(9c@;OF@f6A=#2+XO@CMHb%ccV
z*j*84@cB%S%>eVg>|ZZ*o^`4hIZd}~`F;kOx=oA3!z5z3)we^VCNz=s)yqs4l8!Zl
z=j`I<m}kv&dP?l*M<6RW>F7xNLRB1->(o80M&(zoAlZ={T1j<RFXmtV+;9Ippg+m8
z+zI!iZf$#;1{jpH)2&{_t0=d7vb{7WG51Hk^Z&u*Hr>w{-Qc}~>iga52g;r52i)q1
z-MR-#^JZe2qm+v=ec?RN`5LE`1E$^OR>}+h94IE}->qKUTZ(i?_&Feu*>%eYI|^kU
z+i1>s&oIu=lvpPmB9gQ0@n|%qIBBq4Fj8C_m>juh6)TJ}ageLK2o0?H)AbhHWGaID
z68$zNt5*;7e^1)TXHyHumVSQi4)%u9Y9eKtt)p&jX&vdGYrC)8M4*$x$Q;SvZr$xL
z#6}K(4c>Fln`t+eXNQ)~=pjZX)v=at_ICW80hvga&a1MR>4E#<4mX=Ovf!_7^%6@i
zK)<E5sb>ZexnZi2b~!*3C)TN3Y<ycS)nHV@<6rKC+nXonG}e0)=v9$&SB)EwJ?R2<
zL@B4ZvkJ>;)u~&pQ)1Wj)y|6HvQqJfsL?BBwtJ*sYqzcH`>|AOTVcSLZ6726>pGS~
z8)7}Sf8@Hs{4zn5@HH$@+7L(6?a)WFH%SZ(n*fo76adbI#mT>kEE@(pO?Qim2dS|f
z(Oxd8VD5*%JbZg6%cs(9y4$t~wa{el1K?+o_Xe#(a*dw9+<=zstNEcHx#1J8q3-UQ
z(&4k7^q0cA`Jpw)#{_!c8Md&97KDTqPW56wSrzn~T*)g~km2o+VJ{+IgdDH>)r+0#
z`~73oZqp`tHskbfW_uHW-99-7Tl=>+s!#%mgUcc#9H|P5e)o9kj!4@f{1S`bh{(E&
zgNS%W)8o{Je4M(?i5XqlGkG<!%UM0fJN5%%q)WtT9w69MTD=zIK7P`>+mH|SYC_{1
z%iS4|i}Os_(p_y&f6rMESyg6kvZr3^#zPpJy$S=P9yb)2n14bG>k>0oW=C$AYCc>E
zp^cGgc$Rn1`vRgzX>Iv&;;FABo#juVrXk|*;{!-LeyKjKl-Svpq=MR;ImoSB8GO(&
zDqF-6^*(N~$VB_JRzzD~=v1%v|IL(OvxGftv$tQ+q9@`2FADbmxC!pP+T6-oP<098
zHmw}v<rokRRDkH4ue4S0?j>;0i&?L8l&<S)Y-CApxh|Yfrb-oWV1ikiu`!yP#mvn`
zkE(GqjZKUF%XN<9Awo^Eo(9RXmOapee;!2=#!&9e4_aO2AIVw@TN>5Hw?-mW^`oh7
z!JlFl@k$4O-u-qHx2WrwWlmj}32GqcS=u`-1*P9a<-PSqMjp79t$dAh%eB<tgy1}*
z;q+y?Fj{Dr7Y|Hn|47>>q_jnB6Ba5*cUQNOU`AVEqgUhIo7gclvfvjSvfY*vwUE89
zlEX@u&pJ+0Qthw|DXF$3LrOA%vD@bAOIqP^?!mf{=SN943%@n$owpdn`<9_jA1ue6
zb%ysewc!|zTJC##Q}rWfhf{aGclvv~caO$xryt**TUh!`EbjE!7pV7FWS(97Wkf*i
zN8lyc!zl<FJG@*z6jMA<JeV(EjEzJl*4x$bRmtZWD2QPK+QQwWv?qQ*vgp#z(q*ir
zefUOg#UF+Y;RIXVmb}uY>mwaks<rCt-MZ_SZOL)!=CJ^M^L|U+Jhy2f-3}Zi^mU5S
zS9dyNk)tB>e#1#k+$O#-JY-I|o0S2mMrN(MJ1y+GO^ez5ta!XQeW-xFY5l~RKQ&an
zD5I!_eXOnAscv(t=kaGA8&RSwcVv@bi`=k`Pbh$+zv$v`!Q-R3dW{x-#SE`<mYV}P
zaPPxnF<j5mggKG3XH${{kxup9R4;07Hs^8PANzG6mqprqX0^NeW-$WyR1x?6ER#p>
z2^Nw8`&P!Ul0{|_d5@yP5re5-=vFV(u=IY2TU(9*<5YvTo1GS+tzG6%X0!{5XL*kO
z2CWUwDVm<q#s_SWl1-awox$Z6;LA|&?3nZgjCyH}&OSfg3h>1Hc>Wva`|j#aO}j5E
zDnljb!b_nJ{}q@NecAKc(tE5(t4$!%{-O9uOP+tL{?^@%zE7vzdhdYSO)bVQ!dA^M
zRHK%db3kNIxdtM)`tB$|>Fn#h>Qkk9v1UI!1!YXL8SUM@=GH%4jgCbo+fuqd(y@uI
zmc0(;@h&XEnKn7?IDG7O2N!Tg5o!i&x{2DqAu{jhni0Y$)oqk8m*AI{d~AlQtrQt|
zm`~X(a`)4d08<LO%L}N*+b58`75}8VL^>oBvHM!*qv30$JcgebErZ)ol)VfS^W<4G
zFLrM+t<`N}Dsl%bJsadR8I!XZ_{N_z@VBk8GGQ*<37cvXD{^^hz?r~CwWYK+FS6hS
zjlwW1cg$$P`#tzR#P>c{$$m5GOB1uovLcQQ2oXhclSR&}?nNkw*fM#Csn+fcELfe^
zwT*fk;gT1*6E-$_^D!ONM%1c46b>%Z{-Th2wxOWOq6azGLAmY}#ZM{l^M%E!$UKp@
z?Tj6_g>1qJ>D}R&7wVJs8ezdNgJmFx4Xd(7MJ^rf_FtqHh{Cuj2uq~xb~S6Q_um0O
zg0x@M`y3M0axkQQwJMWeJIbjV#hQqE!+wi-c~!YvTZUva3v?t_7U@y5gE?9jU^MEE
z<t!ArLDbHNjo$T1^6W|<oHx#mjHgHBkE7SwUaC;b*fsDCp`#z3@=c4~(WBY@jw}z?
zrLS{1{0lO0s<g)iD{Sc~O>02Z3q{m-Yi|1+s0w_kH9J8*-m?dQHcXUJ;JeWw*8MSI
z=ZIZf)HPBRShudbB3B9;Gmm)Oe`l$Il1Ug~you0HrRI4Z^E~lMTh2WD4@$1kd-ajF
z;db?cll1`Qz4(zp-h|`BxPUE`59WQ0TXVA9v0603wk7`D{elRH{`-tL#EeW3apPRW
zVV>ExdU<>0aQMR1v~H$PUq*?B;1)%_s!_7IUQED%X75ze_;V1s)LVN-h*kK#w2o<o
z1ZzqeX>E$-hwVL@*1C|X<r$R$i%EfKjc&(V_%;=)%^m{VSt6yw3jVS8Tau-28_Y>z
z@DPqe-sXb@)>?5K$XVMvl27Z1EDSkd%O=1=<OW^ONV-lAtV*oPEuB~xxnYH!mRi)x
zC9JZwygzqaNbN5%U$ujIw&UcIX79MCEM--9S+Wy8n!4C#cp^^Ur4%`!mo~HfEol9;
z5!DtzeC$Sb3oY9=<20HP?~%7mo8g4~i7zA&cz41+{ZFJKYZ9ZWEm(S1iXshq`rimW
zUTwej7l?GjO;2=ks77qPAR;7T<;~D<)Z2829fDbcpF)|8A?htBlD|l0RbmGc((`=K
zYxcbFz4j#=<Kqf`y>>FKRN|Sa`qfL+7cW~t;7i>894W=n^u!TjscT;OvG)e+UDJU`
z!28$TOcRICiu~@}AwrY)<~gFshn40?O2b+tD<`$`8~=%OOkZ?#gHhd8uN2y&1r6R{
zqPo)$XX|lpWdZLK+o<r!(yFX8J=1(fN4c>MJ|KaiG0~w9$M#l&p=30A>EZvoIO9bh
z1c4KJvR|e50F=`B>Y1b62@iDC^<;k>tw$pD=D+o&VPMOxvBTXRty!>^(|1EuQ~%O&
zT~;wa{(U$<?%@YTrz4SOVLqGeaGO@6TdrHl^CCdH;V%XqzJids)vJ%;Y_vKtV|AaI
zweX*ST99DY2GlZ|nV<AC@gL_64u0S!>Ro<(u9W4yiH_!W`#(kthq3`#?k@(9&Fpv0
z-bC9aV}tKz`M=aQ5b`=bb#8f`p{$|m>2P{V-T|t+YlktvS>3fm`L~xU(F(pdh}H9=
z(K_^6nwjdyquyWs^(BIY!c|F<&Z0(XOX0O=89ADrETwI%9n6{uwT%je5^0-jnk#ZA
z79(~xbN`-Ep;#3zRfUN>P(66rn>l(_iay5{JB39kII^E^@ZPb)iqnS$UrwwQ1JjbI
z_fxD{0m!d_{SDvlEASHc<<*_ggS|-Dmj4-=<j%$;mOD+I-gm@!BzSC=$WfCo4G&w`
z>NTuS9QCU^H8|+#NfxZ%AI;{aov8&FNEhAZ#lV{7CoN{WYm0=)Ol7PcvZN|OSzE-A
zK}e|iuVuWkpMgjJ31*A->sp6zXmoZo)*E%Txux)?Z3*~?k@Ecm>1$~ZLLuQqc6j$v
z7|8$r=O3FH2S^Apw_xcQO?ot+_9ji#gr7j&RLn8|F3_{|X7Wut-=oZbDA)nwOPakS
zp8In51#aEr^<FnA|0-&SbN@GGC;));hbBHR0px=Cyhbeh)U7W@@_!$l6ytlBKi-LK
zW615V8pX)T?HgvTU$Y|6XIjtLeBQWM=sFW3G@;;o@4F@{(YtiZdzla`^I=?L|D}*h
zRmD;7uwOEunsOO?G<zklsYa38NEimE$6NLxW$?i11B~b4%s#YFOU>ShH%&{)8)g3>
z_?c?V8CY*DtuU}{+JBe(PUE@zzrdH137<?(P!ZLP0!r>Ch@XpWg{2CxqMe@mYA-;G
z(ttLDm^7dZY?Dc+*L^ndC_o3d0T5@L!09`%;gE9Ipy}oBn!$nfcbo|YVN6RYfBh1M
zXU59{MwW#ua%+E|8FQxoJ&liNzY-tjJU*JO!l_&0ywKqN;!L}-nC+%<02EhV9B3PX
zVgPKfyQ&!SXQzJL9j%L?8aKXV**iII?r<uU@=OzdPJ~DDN6(6o3bt9-Dvic)7#gI4
z^4zGm)e0@*rV<dZDU=p*rA|d%gCrZQ)S^W;_&3*KFyr~z+6iR+5Ga{UKasZYXlcZ|
zRI`<&(QU9z@Sf@#JDlou=rhEOD*IE+Wyd-^_E$H1TkTWcMmLLMj6yhcVnqMQoP)GS
zR<A`7uU0SDuf8;J!w;2eS~7h1vNv*^rY%I!=otKWgOJ=q)j=8M98C%%b5B&waw+E)
z-qc|9v5I_G#Wa8kDG>EKh3Ki?`~D4~?ACsi%Ih9S_lJp5?eOgY+w^$HV2v3q2)HY9
znd})WTf7s(kBIc84@_Bk9viaQoE!s~qngqwd9xl<hjpvl*SJ@f#qx+PxjM(GEc1SH
z3|sk#7myUpY>(II)zBy>Q6Qd;em!=o8;!E|OWd1ei%4oeCaS^v=sfM@MhTc><}&Ie
zR3Yl+H5-g8d=yQUC06HhHhAtpkg_u01Xx>H?>&5EC?T|+#UYu9TaDhu#q^kvNMZSO
z+hv;5L?MmRfgm>NMsF^bfNoWOQ0oyPxhjt;jJwg>`V9LRgEc}4yTz4dk+v=~V~@Kt
zmMnWW2c?z4;s|GS9wOdZqq#p`+2Fl#eK-MaSLoOtUqUN2Bd^SxQ61nuIY|8caUBm!
zugIHu0`rnWx>g@M{IA1CV$TZ(O;$g5N>Pn7rAVs<!L!7bUwUwTF>{!-TbCQIjslBI
zA68*}8(Pth>TUJWNl|xHR)e=N&)`a5k1s(?Z{W6!%4gHND%TMvSK*uW7L7MJ1R##?
z%Uq(>;zr&#m3t5kx7dc=s}PUNY}=Z^2_SFaD~8+HXo$bjF^d@nvFqK+QPSPkj*>>Y
zg+w02&&_XY-_yq0_AiTPwN^RI9m7^W%&jyJ&Q+E;wI%i5zi$@Xe4Oh#+7b7!g;&h{
zHo+9mDsU(A-cU!OA@dqe{Z8%ycym?~+6o{_ugt?xq)xy<Qci7|S=&zx7ld8TGWN~i
z=wu0w%hfK8ev79iCKhxQc4*mDxVZ;(n`577mKiyh87Uo;H|sS`VQmS`2Evk4QR3DP
zb1H^)*Our@L@E7g@iuHWsPV6t*q+6b-o}!aymtlcAvVCUh6Qg^NL#+F$jo`i(g;jK
zYcq$vTg-6MCe8s%>oo1vk9$AbM1#$Ox;yt!^;KJXMr6Ss)Xju0-CixAF@b5AtU-X0
zGY6N{YrIf%f!EHN!iYF)$0P6HSWRoHS-mdmIh%7Nb%s2c5^%@59uCFw=UC!Ee#f1#
zveApW!3u~S1d_H_o{<|LNb}n(#^*-b%tKQEQN4tS)-w(^<0(Oz03qT=UW5{Uo;{gp
z9oR!vFZ-^qM#L8&!k6W2uVN|644xiVF|tWmyo7Eo-f}y`I=4_qXgu--#kYm4dkbIA
z$wIfXGC0bfj~pM`D41u`L!GKYL!@o-SD<%r35CuwcX~eVEsulXy8~&Us=x?#sp&v~
zwW#0%H4q{F1OSWAiQ_IYJYb$XI=|k{iF$twH=A|-PdO61Cic8NZspu+=u4DnjmR3k
z!=HkcLG!GWE6U7thN#sf+DBv$1?vpRhzx|^qZaYXQ5dNP3+;-s<SJ}3A=OD|iC)E#
zm^S$Li3{vfHz6w9KA;&5N@QB%jzjy4qDj`(=1MqXo&rLKL($aI(r8?QuS8EH$mGD!
z6GMD2hGV27biCL<&Q0;tEwn=+dN1PR{3;wKhwQXwIeA;J@j<U$M$TH>X<9)d@Fz>}
z08UfOfUz)7IUJeMr~TbR!~8T`!M4GB;AZoIFkyz>jRuMT{1#h5zUHaZzh4|=ii@B6
zZF^KUdy)S$CTi)KqB0mTgx3FGbd_nI<zLN_za@?2M(_EK05_Y2n*#Q887Xb#3jf06
ztu%rGnGIuv-BF`=ki^~$10&&rNV93^<cDCVN8cR<#Y!`_#OhwmS_q6bfbWovrgLAB
zNYoHQPSB8{esgC<ezVs)%v4m1Uob}9-pIDI*?YI#f^UF)U33bQsnE97ejdO4EBS}{
z%%Jb3=a@YVDRfdaSdTYy+vLaDLKOZ%Ge7(n7Os1NYmcvGbplbQ$Izs!DhsZjOVwaA
z786&(XwoOe=*f1>sE^_cs0M!b3tY|oFJPYpf;9RXgC)ffdEEQ=1`ETJG%AW@yC~-m
zbN=SHQc`bhGFM~YY4pnHSlXMgQ6rZ(4`@s4$NcvoNHY*S4dK$#W%#7&T5NQ9ebAw<
zpO+Q`u!Z9vWcwFdAetWE^ZS)-(82fT1mDl5uTK6$-bc(&>^OYtKC<iXWFIQNxxu=U
zPFTVD3yJ6LSSeijl=*qBJB#Ck%FSQ=y8kBPZ(9?KkR3a$eBOY{`FU+?;vcTc$tqor
z1DPpTM9T>)!f&Yk%&MGXDiVa=l+!=w1#3uBIUl#JAH^zLcbyeGy>-|0*of9$<6<Wn
zH>hd<<GiH%?aKKB6b|E%soOh<lyS(^51e(!Y$Bx4%qX7mGfxU^^9X}-e7swMl1<%y
zrtY)@otHZ2kLgosGe5Nryx+Fwf>6V+c%wE_z>Uejj-L6KHWXRXMYQfbK7P;q@!1_$
zX5*$rJmoo`GITuT2qrK`9*np+4d1OFdL^`@_HzJ=%yCF3cK3<2{}1c6jeWOFO?`fR
zq`jGpn)wF>&hCFuTMA4t75^T_6q(BrZMXBG@$gYLp$W)ls81jBapH3xu26)fj;ha{
zXG}jwsGrYs362L%$O3XB#kjsj+TSNbK66*#GpDEqmA$)pmg2AJhSn9Q>1uV?{(I^r
zhuZm?Uz45iN)%FBJ}&cXa)MvlqdLy*GrzeHzGTg&_bI9nc<g14PR?V_i+hdkm=`-L
z4C3a>%$rsU)Jkyo;vY?(xzsmqfd=Y%&)MO8V$t)S^XxI7C3YiP>`({KBz6P3U@$M)
z%s+@1Y^;9>_ED?cg;B7E>^s429Zjlq-L;%GXO87`U5uP}hf0mSHM+u?V=Aog&P{;V
ztoVD<L9Ekxy1rr3BG$@X5AdQRBFbVc=G<FVS=$&#!&wg!>?Eul`qwI681~NbzQh7^
z)~#?WhSKlH9nsxRJ(t0;!+9v!9o6}TQ!&J?FQK#}_qx#ULo2DfVu+wfzVWr~jYzdO
z!nRj#+dJ8<M@SyAS9>S_=k{hlPB~5X2*jV89~)xFxwBW2Z5o~}J0bVy=C`T5XAh==
z>EuP}bC$WS+xP`zc$;RwYnoLCz@F&N{)7}pbRD^!&TNmgJ6mP$&y^oE%;F$COW@yP
zzp!<a8))BJYCCVsOxw=4(MRMuFO+tUU~bThw3hStd_zcXr{>FfE|JWcKGJQ~w0E4W
z8*X$4J*8zOu@gFSZ_!UT4gz{Q@=KBtx1z^+KH=vjw&s=Y;7TKzbM?02UA8@$T4T)O
zjyfne=)nHq1|r^(G~*9m<HJOuD^|~->ri-{<t`jT*9b|4-3UIM64<~1B``kZ>Amdu
zJMMI1WES%DDo#SBFJAe4>-61a@qWo+t)*qLZ=Y5A;#J#|%RBL`co>>=PZ3eFPm3ra
z$FL=5Ku3Kxn$yykt~z{vPT3i;)62dcD=0fMR#BNu3SX_KeLMC^W$8;-Ztti^_nBY1
zJaV1XUaeQ}J|o6?YK$^2QpRa##6NNl^2eF<k+CPuN69r`W1oRsx6Q#69NAz9BSa;9
zgPZ^Zi#6WIc)F@|f;aPc0-<4jjephr+yQM}(@V+@pY~SSfLMOnz*rt!r(MzZ(b22&
ztmjnOL{c+zY1ZrTHS?A^tB>9S_D=8OAEKP{FF8HR*<x}O+mW0d%29Tt{m=YMt2&5J
z@UFcNV_@vj=AYLud-fYLG;-EC&mY}IBGJ_vX}?aDtG5l`K!qHNn%)Y_;*-PtKF+#S
zW)r6QiP!rjww#%G=geiV?~mF3vUl<mZ=BixLrRuy>D!;krEih!zijqSbvNtEjtbpZ
zMCQot20yJxo8oRKb_VwrZ5#OYS+B7h;Bx>za=pyRMS?T7%^!7Iwoz+4t3qJ7KGQH>
zKiq)QxBrK>$C)>D%+6vW%`HY`j$H7_C=PBiB6BXW8B{qvxXtimR5!i$F}=qAbFb%8
zdw3TB<uKGVFsG88cs*i(;e-ZW`huqZANom}3#}Q`GyK_0nE3krDa+JHBEPVdO1fL`
zXJ|CIySx0n%Sm>(Y9nN>QJD>)#vsm9&$BkV%k%Yztv-W4@a!V58$B!f{Ba-Xa}BS@
zmKX6=Z}$)cwia(*o0a2ging!F#?e4@JjbZ{>1+E6cAzz6xpOAbclR8roA{Z9+A5LE
zbxiK|6?r^8Xo?caJW3pswx1+c=Y_S{>lF_u$WP{=v+AxX(2#5mqzdPnbcGeI`K{e^
zbe*5Bvb`IVhRLeacXm?w-E-FQz5eSiAARu+bwTT`YqP^%3FdeXA9UAf01T*{m-A|3
z`eOTvVx^}j?LML6M6w|9Y=L9as+sThO(e^ifw1}k$|&wGAE%7&@(WFVH(h+n*X|7#
zN0+H1{%ieb0YDZoJX5f}yPT(aZ&e+)Z|gJVl$EQIAE>Tl^0#*v#}2gkp|qGL))oij
z=+4V1;iT5OHo)s=D}*3aoMtZgj9&xwkNr@^IlYQ=RGgDhoZG87SH(n6HqGhlye#}T
zQ;p}T7$vmHaOVtVG@>g#m%)8Gt}pOseN~VZE3ya?NCjE5*XUo136&SC+zeXf#aXkT
z(!UlBDlhK^RJnRB4|?sMQ$(-)AC3~?R$%2h+u+%Wr?M>xn>rS=5OVveoUJSg3+4VO
z{j?4wklws@Q!0AXf1<SZTTPZIOu5@v6hzt|HXlt=75_z3tm#&<uV*#Ptxo7TOFU-9
zOO>TE@fas^pxJvrL4JGQ?d;)uXGLkJ#Df`S?oCEaNJva@UH$8v+-Wm|4Lp0blaN5s
zQJL)|R5>k~VcC~Za~YSCrXggy;9ipX%5zL!@|I>|ZSj8BUr?poWPp%)<TCH@>~)E!
zcCX)In@Zjl%4cLMBqt{vu4E86PjC}m^i`UWC^e(RHGkckBtGGG<1Fte&vqUXlXgr=
z8p?;iMP}BrEq%~!y9w3r1>ZrA$+N9zcR8k)<RTemHhRB%5CzUtQm-Wc6abcae}&QT
zykSfTT<>c4ff7<3mHU+T%+h;T=9MT|<^BVN9-~Z+qGm}WCgvpc?W6y5>7|!OqfXCf
zTi5S$dY0`t{FvoZ>AH#YDD4GmrDO7(ht!kPLnp!Q)TGUfDy0Jk=|%8c+x+BV8Ts);
z>hT0_^q$2JKJkow*(zw|iBoC9w%?sl`}*yl%&w4m-c+-JKg0IcA5p6~)@%;~yjq1Q
zc$Rxxl-xiRBvLs0PHFy$Xjo{C3tCBoqkB3EOOl0dWe;bKt$7H9BdfRJT0{+rgzpCH
z>$Y=f2r;kRU7#jG@pnhwHkwrA28XKdT%~Py^n+`RlYgBPyDm4;mE)MQaJ>R^_gpo`
z4O&*WDI$?Id1wkT&Ro+&SNvWAkD_6I;Lo7PC_U_ls-Ap6vO%3EU*6rN=bXqIKc7_c
z7rK`>&1b9v(_XKs+t>EtSM!ZXtHnE;PFyocC$$h*1*R!F_fHq<*=W=BX5{gF*6@rx
zqEqmG02AFmv1Fsbi=#QuZD?#Uj^6y04ry|B^W;A8N|Vm=e%WB0$5UuoVz&Kwck;d7
z`}qpzSt0<)`@dSYr(+Y3nI7osG4lm(JNT_Pp2w@6rW^j69&#Ggo3TB{+G7~KbtirR
z+Vvk!>tVl*U;Uj0k`F(wH((~8-D|zcAGf^=hJZh9IBF+)9`oC1{o5I{?H*9F(*wWD
zwrE^!6RA=6d}aGwzZnmp344vYMzpU{hmcyl_Ay<Bqy8>kxrt&%&4^P0eB%SU6T+d8
zVWHsO{VUrE+xFgzS}d%~c<(rv|6qO;s7>>8@mE2r`KjlLMT3N3etJWCJsr3Y?ExwF
zbZJOa6ZX{&r9iC=Kz-IO+%&xg{?q?EJ_8ChE%t`;ow5IK@VR$8DIkAMLrh6BjZdAU
zGq#r_-Nq5by)Iooqv@`^8|%@;5&yNSoZV0x-&H3&RU^_{3d?ePVlva27uRDtk7{C<
zZbCNZu{AG;g=_bW?u1z|ViPNZ{palRUV8vhSIg-&yNlkPs<LF87*M14o%>ST&irsc
zOud)<EW3_bpDh2Mx<*#VTw$!+hdCEVm_7ZnKR@x_tFbz+eYWAVXL$k7ahyG+*}dvA
zgAx`<E*&*vOPM&Ag<54K!;Dqh87%hr;^a1SK6J~kO+FxJyRf;`qNkzof8KX#OlV$`
z;s5rm{NGl{kBTS5IVQ~2DhR=zVEpJW?XH%HkrjX*@9R#v)`@%WRk?2Yc@BHV)U4*_
zhWemu?52A#2is<P&Bh~-k;uBv<9)F@(|<_1A;<bay~Ka%R^<jAp`;*A$9?hz<S9AZ
zQdWaqlG!b4G5nwRecNR6zOUmKU9s<n!%6eVvn{u%pLD=2=_njQo4rZA5AFYVEaN{k
zmV)-L96&SyPop1B#V^<|gfD(Uchz~vf@t>Di<r!YNhhShtGDq+`b<97Ak?<#{m`}t
zpZSIb@;@*&yFJ8jPinpxfBmF`Qmqq$Bzb4RAS4UOJ}6`LP37kHO1E)XY2(lthq+Zl
z-NurXP<ItE(ubzko}6wo-ASr4-ANSKKmMeZ-L|5Bm5=dX{>Vn#I4r%(T5+>#Sn^&{
zsfPEKmo2|F(Qx7gL|I5hsnLEZAKI>&zSl;eYuRkXwm^YgyI?MLNq>85rPu`QmD~f)
z`UC43-6rnnv6C=+76P0R3eY{apx(PAfur_#o~)4Tkwnc~%t!YE_wbkXyPe-H-lMr3
zm9WOSG0Zpm*}e7$NeA(KZ`;G6Ey?wChNbiw-HGrl6J@)iJ&s<q4oDMZD(Fq7ch`NG
z+R9xMJ1k?sQwiWrc#M8Mu(C%CKQJKOwlD8Y+!TJYA^uMqTjL~@k^a~W=9T-y!TbSR
z>2nNSc%y%3(2~4$PkXWNz%swqUW|)k4%zNQIu9o8mF=_Qmn#dn@5Au-d`Q4|&7q^a
zYAB$<-iDYz=J=wN*ia9RbQ`sYJ>R%hycavd)T=t#R@X_xrgW~*e~eF#0d05iF~^B!
z@2^LgW2hROFQ}@Dx~mE^YfcPny6Ku{tERzH@Ir0atnQFavlpc+>j@b*v4u9f%_o_S
zD^!N5e?q$c6Xdyxw@iI~rT@bA=ZE#bEKY%~IL};vcbiXw$`-3Try6o({yM5g2Y2B-
zyTIJ=kbqT7R2j8IV20LRb+Nv;yPi!wpg;Tv*Pxp~AhfBCra(nTNbIf}Why3Chxv)M
zsnn)0Rdt@Nv?I(&NT{+6%BRJan)?ot-HFFjc^iXN)cfcT_(9@Aep~7vOb~SwrG(9}
z?<a(WFlB0qayM}?6~Q0&VJvR%?T=MKd8rEOmkJhV2W~Qy=qB1sZt5ZAjzlXN)<s+<
zg9A^4Pje@1u+B*#e05S9MCH3%Xg_@`@9Wyq<Uiay{|)p4%0Ig(qw=CKvoIs`5@`_3
zNnViq1NpfJKMwev4PJUZ;2Iw1Ru}QU*9W5Th2#awMfF+NQ}6w-kL7hH(8f5*DQNM=
zqJMC2Ge2P^+^juoS}Rl|N7+hx6VGeuXTP4SQJF8B?zWr~j%wp<m?sc<JT>F1Ww<IZ
zHBMEobCT>;&xMB`Hd8#bvBkTaD{%^2XMB*w6WhF+zJ2C-ZmraqbuOU9YI&pB9m5x&
z^96QrTxrz~(P0NmmvII4$2?~q{$r+-hr!!whcq@vUG$*XogZpGC=SE`&>|3ZuD9<R
z@1^ggM%26I@;*G{TI9xyaQE1BWop&k&Ufau<R739>1Cf2wBK!TLai+SP3FE6erm|t
zXzbya-Br1!a3_V@k2K&&n?i9XW)$>^+;ASLC?Q%3nmH>rdjBTShHzHh<5y5}X(uw&
z@GkH%59*)L1LF1#0r9V7ft&d)a&|mgOfU6Ie+<Jm{xSwsKS~XEZWl$=>&PwdZF)Ud
z6AyCQ2N)Q%*Icy7?#0{x-N#;$1B*Yv_QQL|nYo|vQMe!E-L-J*B{UV!S+l|$FfK34
zJ8;97yS<Bvb>sb*mFRto_3Bmpv0s)q_<#84vl}SA?$n$tucL@6OK$vfclSPOLjR>U
zlu-UaIu6>8sr@nf<ZW8GOLsq~mlxG$#ZHHAO1%eY$9r1Et1joC{g&}hKD)7ZFx2mT
zkI0YSd&(O<22tAd2Lk91<Zz(<-iZ>)3X)5DpO5r@nj|!Pg|8qQjo!2$_OZ`t&cu*~
zZ)|j^jQf6SDV_sP-`n`k>xU>{go+;{pcT1^N%R}2OO4s6GpB$Y$e_B1SNMK3z|w%E
zl~KsgEfW79-jT8n(q)d>O)lQf^v*GB(#Qvw3AhxG(#~$)(ON;f+gKjeJ-m;XZl;Z9
zc(uOSJ4DUg5jKNAEzKCFaWQCfZw(7J#Qz9De{f8P$-4|9&QOgf!Wz3H?LUK7wBAIU
zwx%!ZfHYu|^rpi+hHn>X>2i&-X77ioENNbP>r<?@lv6apMu0hMf`6N6?_r}a%#@#}
zb+?WJkDAoz<UW(ySPX7pV*3xXk)mrGLFwduCe6zz`$Je(rm`WEIy1^TD05wX1h`J3
zoCG4*q3%tp%d(VMh9zkFePJup9z?vj6kS+A)8}pY_v~$AECeQa!Rfe|0n^IC?!1lU
z(fYtZ`C%Q~6T5#JnIqDAVheC}F8blGiLKRsm9W&VJ1RoOQm8%eir?pFx$SC>t~Cjd
zAd)msx{wb#{;Cg5P5kZ`=W8^wlw3p&&9?c<x#qm6JuT9lYv8gctv=?Y73xlQoykGy
zrecGVl<s81S7{_Pjk|~Z-2;Fp`rd|R;+X*PMDgvUPEl%-@{UvLT&0ds>NcegR%(e-
z1C_dQA*nt}J)x9X=@Xlk`ar3Ze?jVPrRFL1vQiH#wO*;*Uy|xpYN%3wS8DXHNIj&~
zWlACR?|x#4Qg<q~QuS_8s`*w@u2T03=GjU;uGBQ8zF<21pD0zVdf!*-Or_3OYLZf8
zm71$mwNh{E+mT9Tff9eXQbRP#Z!7hd>K&%kVS@eurM3wc-3LBVqAwIb^ob?v_fw@_
z7R(CF{Dh}gURUZ*!pjRvU949AsnlkrRwz}V(xpm`P)hGXKGC5*?on!|+WVEMCrE#;
zRGU(Bm71i~45facZ{-g2#LfCb?;$*KyIPs3R6q6Bq|~o9qO+BXs<c9><@!RmE>Aq9
z(&Lp{t<+IUjZz<nkZPVZP6O6`Oo~1;h||z(pxEoJ2DtF_UYZ4K-=&B__Q{;>twtRb
zX}_CAV>ar<V-f++kBzn0tYc@-$eVTR!mP-g>!{&Y4H>TBp#$;7!<+b+kKEBivY+Bk
zgHN)TcjVrf-Bnthcjb6z)9^Kqp3eu~U_>g@u2lZ)kN8tpvZm2l4RNm+J$#LAEFV9R
zW7gwKo4wxoXxY}ovp;elQk&~{Wq;U_>vR-0(D3rB7GK&agRcoIX775p4<2_P2_D<T
z6w}0q?vx?fAKGv2m-$(xPel@!u~^)M;9%D$1j3vP$Uu|wkn}z2-Rw$^@Z7`Coa_#4
z!<+)Eoo_dKr)`!ABL1P0zZ-{$ja3%RC(uOfDC;IJZr2c<boZUG*MTy_Kza?#Fp^!I
z8udO!gO`wUUVLcg0UCQbO(dVxctXu;qc;VhsA5`8F1Filil2jNx4r=9^<&nZ-pYi`
z8pso?$1I<{OFw278BdG-XHU;9UNJf=)<015#iDGYRYMF2Q7=oX`)~vxejlt<V*8l>
zQ($iXQvl{Hd091jn^|nYlzcJRUzYxjVH(9DD#J4|D$Gz8-elz;i%&(O7{Fa0Q7MF=
zy9`3RVq@g)Wg@Z`6T^!g;}93`Wn)s+FljYybEpWA=i+kLloxd?hnCw4lh*exuggP>
zuJ?YV*bYS9kOh3ORq!5N=MZKa8NU4*&3%-px`oKk$E-eG5nm$<eyCi$&~9gZX4_5g
zpTT*e8VhL*4S32@gg;?$qgz*m5pE%*@Y!e9Ai$g+^lXQB3j4Knfq9FcSOs0EWvapG
zgoMv)E7|Fbn?7pyF0#_Q)rv)C7n(iGYC(BlXiAGq?8leyWEZQpzACZ4q&Pp|7&EvY
z#mhvipJ6ITL!ta8mIX*i>oB0NJ@h}sET`M#-R67}dtFdg7Y%<oy1PkHagy@0#s2$O
zq1NMJd-2u`|CbKunN-2AsMzei`jJ6IvLn+zBfuXouj3{s>;4&qeIg51FdZ3(Fcg`)
zqu#5ZW+3u5YIxgzLr=zT_%Qb3?$*o5<p0pTcJVKrey!Nvwwik8Vu3OB`#Q|`6Xq3W
zA&vR7z%XN<eT~69@7YjVKY2={dvJp{;SN(~PLvk=wYk9&YJaL(^hLdzopv1Q1K}v*
zY0#*pi78YKzWTzB!W^<5$g_g2;;-`15tY&h!`vys!O%5sDViKr`lC>x(_y6TH%gil
z;@ReeSRI}aU*uDBJmi?Dw@S?kQ3u4r`UXhSTNByigt&v#0m1RCzTCWS8R5bcHD8PO
zM|-XnMR941xvYe8UT5Z2Fz=Glsk51m`IcX0od0wp>g=9trVm(?cT4^W&wu-~{`A|@
zW21X`qxa$M2G{-qz7yHCc&~AQk$^m{htp`;5O3@+pi80E|1qD#v$nwyII27n)Ei4Z
zmDW+p)U<ft<O370kplbSiR#y!Oj7ZAExiWzY8?6>1=xUHMcS|DhneMVQE$r4c21=r
z{RweSm0yX=<n(cXr?7U3Rr}CeukhcoS*x;&SCwZUy=qj+zen=Vm&N?En`@1xo{n;^
z%bPrROdbcCkAIcV=5!KXL{lCbmE}y#cP17%(~9KGY*%!Ef9?x#Q3@F1$%`@>rg`CN
zX+C*>$@YHx2|L{G<Ue@O)LJmyhygE1#N#Q{+9cUe*<Z}~izW|9!7V~NLnPaTCm`>j
zn%%0vS})I)P|o>@vCk8GZt$MsFh>F?ZOzsZyuYCcthN?oKLJLIziwu|M_JrbPs}ee
z2G-Lqf0F$?Yl(7U61wqDo@D5;V_J4;yl2*toYpXM;K*jqZ8XgSPunE?K(n{Q`3zG+
z0fzIoAS=o2G2PkJ`<z`guqwAeAVS)Pu!Bhs7<TnGKoBkMQDeroz^USbi#QY15fpo5
zCx`W~s$O58+?>WQzJ=Skpsw3CzdCPTQ_{U+$h_*UsJHj!&O8JGk8?&yG~?r{d#1nZ
z{(LPUVDhqVMvn8GaSv--B%q)=>2>!1ksMun#<_jX&o?LA)wsNM#@4LZl*HDY(&uJ0
zac=F%-8b2{s=V~MSnd3}<cPfZ$EL>d&dw2|u`-=sw{^tmocOB@)SX$--KtLY-~U6|
zxxiOd9FIRC0Rje3R8-VdqaqK{mZ+@+q9%k(5P9T55=7&p#Ye4=iuVQt0~hYSfs@-1
zv_5KUtybGwtJT&=2~v$<38+=1w2eYFS|8^$w2fjhU~B&0nLX#+n?U>d{Xc#r=kD3F
zJ3BKwJ3Bi&V|R}4C8T*~r(4gIvG?Q3zgs?dru&bK0;uhKrK%6Ry+67?Gq$6z+fLSw
za+d_N%;+!3L45KmoaH}B(?AZPeOzWN>$p-I?c*}G;t-+x%|om&oEKmLGb|+T@?+IM
zzX5md4RZzlUgrVsQF{kx%o-n3@Hc?huY%VpB_{8hQFYFNM}e_i^*m`D+Va}x%5`}D
z(^rw{>nvs7h6zz}n2d>%zT{-w{pAv-B=6ml&Au?zt*2j*<a;`oE~!!!>RB-c`ebh7
z2BzF`>4CMKbhb7s0$_=UY)Hh-no9@u)j9J8!a9X;W?u7g_S^VoCB6a5ldDzf!GtA|
z)9kIu1-aup&-)bkR~(D}<0(JOCtJ@J+Iw9j0r70Kc&}7p2062ly?!f^;{?Go@`w@U
zeYs)_RjwoMfsc7jw`Kf7&Tjca?$5{oROK-zqdJ2E)SH^as7bj;8CQKx56X|7FK5L~
zkAeB*^D-znovW^iqmU5E+R<oojLqKajm~O)pDN9n#itO$jT*&ct%PJ40b{k!=_pBC
zLjN2~mqPl5{lwfQ)Urce1V8G~&hqH6uur+FBP6OEgm)J5XL9{Nt-CfAwy)`ou8$Va
z!*k`U$=O}W(EITnTe34VOzubRZv%n7WY{%5$xxSlw+z8&J@jMlIgt1H{Sxs2u6e(x
z##vFkveBu)op1SweNARF7Jq`#fJzZ~1Y{DV(o}!W_`2exi@?OZDqnLcQ3m_YBFyOh
z$^p9~M+%nGRo>-S#hw>f`oh<<5(;9D0MO(dWuwZx=HrElju9qm(k5V{9Qmai4$+yH
z*ODXkVxOUwbB$KEBEmV#YnqQ&I|Jh*&ccOznY5;_$er|LU^h(BMMFlccKJx*i(~o1
z?>1rq6FZ&m+j;Rkx3DxV0~67`Rd_RCSF1Ib-_-fOS7%0^GC)F%0y@4z4pJcmv_Hii
zL|p{K8T8I4tI?C)OZ0OJCs62wDe4Gy@d)Mv*o0wgo%zjQNL=VH?;4y}O=z5|*;dE0
zyWvJYr~R?gzW7tf;Y+PEitnlIeWxi+)8(0-cmKic#JR$<0F1^C6j<>NeK_BW%h6cu
zz*n%^^T6d7%|H3MKAT*W|I}y6<!LqjRV!a^;?l=R>lc4ROUT$L3UZ9>SaFGQx$?ko
z02Z4X&n>G;0G2GFR@1}!(@#>@beH}VMmTRMQ^jhEYe9zKxc4TjNkaCutXjt=Kh`^f
zJf8Y<B|p!L=1cV&E%@{ud5?elbp83F|MOh)H9yZIqYBl>XhFtK3jT>gU^N}B1%0nm
z@C6}ht)^^KV<-i$XG_6eM$xh=4{V<|LLq!l3t)8dT_2HQ-EBg>xUW-w^*Zjs@pr`%
zt`aF4#a8R1^b!3sK*hcKGeAW%KUW_3jDM}x<??E(CQogU1Xedo0;}s|tN_<Y8r83x
z+&e24dfA4myj?!?1Ep1xMpZet5D^Kc;E>>)mQ)(6hOu7ut&@U;Hw`2C#^m$6!2c%P
ztTq*Y>uwV6ob11iyvG+N+0KZd?6tyncQJH4*k51(|B1Om`L7UE#}2@Ma$>FgCq(j*
zm8H)HiGq|EncL$3&<A+#13^%VtNx@v15|eC&or(Qg*=Uopfo?z*ywI82-rwmaj5R|
zO~cZbRRPa5+|aTr;FpFgc;oX*Lv<RTG)(8sKpyG-n$I5>82)G|FvD#a6%2;7>#Mwh
zES`Jyx)dGEuEL{qK<4lK*e5gj(1H|84O=}jx2MSbOm~i9uNCCuy_}11lKW4x9vFMj
z4+h$UqE|oxb|NQNRbRW^na0L$`|q;2sGpSbO6Lz-bT34Oe)f2gNak>u`hOgFD4b@v
zPub_?l#$JRXk@H0Co?>VJ87Yj5P)?v&#uW$u9W^bA+C2bUd{^gG3B%QH+HV*q|?GU
z78@-aA8lELrV`n-VJ1?#+DSghwgl6{*(cM=7TtI0w6GFCrlM?gN726D)D$Z&%z@NC
zP9W%XHhu(4KiD_=u8qiFiUl%?e<H=r$?7YxHx7?28^@i9TVej@icInlTk#us)?CC^
z)7N>FT*Yy5i<NW?SM%2;IGL;$66cTB>S)a^GDSz4qG?hjNvM+N>2<)`Yp(<VHV2;Z
z%ALwP9pIy!AttkQOyOC{k}IG{sIsz_@UB&T8fmw~bN3<$8%q+lqi-_Wl}mIV7%sFA
z06;C8EN4^I&JXv{Dmz@<Qgn9*jH3)dPkjhLVx~_LjY6W*BW~qT1sK}a$=Y<H)~j`1
z{-bH)o79ah%g+oSo-CV>7$PkGrTqDle6UD9INtl<UhjiR(s<dmz<)-v?A!b~P3u)`
zIDv|I5Xw?Ff>;#5=Q-xNgZbp(O5Zb;y5Fp=<?j0TSASvRTEB>;!;pTBnCX*GsUETq
zHMF|FDzjoJDEX_zl{BtfIAKeDtg2Y0QC5-5Su3uKt(Z8NtkK?^lDz1oVk;qOgQ80^
zFR&8V>C>PkR^keM%DRDjy84uTy_J~7Q**^&Nm|XuR}xy2S8{}vIEQkj>iZ?27D9-b
zzIo7^P*3yJ%r&8po2T;pN%PdK+BKoQL^iLzF1x~+bgm}@toSu>MP(&~ocCST3EWx=
z4rPxxL*|c+Ti{NcKLCGn<m2d)L6=0jqf4^NA|FJTWKWB{6J0X6H1cM2$&h)GKSY-d
zEsgv>x+Le4NJml~Q)2DIY<-|TdFHD5)B=4dprkpY_%thC!*VJqpYe^tRYYc~oG#)W
z&c>wLiDOA&ymp61!LwR1d61mXi?Y`zQTF=$D0_=|<%2%lijzPgBe|$xy1l4C)OPmq
zTj?LEV8uV@m2|L&4o>wt2<`TIn8C}KGYm#<I6Bt2dqmjcU%!vT`}e__dcQvQr26Ra
z`f%vuh3~Of&mJxMyuGF0K42fU?9ld(P^Y}?2<_xw{&dM7SDZLnrt4S_k9{!$Z^<uC
zvetf$(pX<T4pbtaLOWyagNe8;>U^h~<VScmcq@LbKo{y1bzZ_c@{hzBNV8uMPSNxq
zYwY1pjS4(M)`qs*2iA<tEG5P*`$cv@>;%Lh6Y45q&k}3wI&1kk$>(&I^hJ&tI7_Ux
zj|hbR6p;;sui$!o1#t+3l#yIoP;M_Z#BoxHlN6FIHS9mCs+}fIn3IjWg#jYF?Jb=A
zffsA-M@;XQCRR~YEtYtzX^$x=pg=+*T1~r5fmvt?i`eus1q4PFeC^4Vos(g;p|n@o
zR`4KV=K>y?->1Ie#bXG}Rqki#m4xyY6mHMlif6!z+W@O(Ctzg~zi+22@)IVhw-VRO
z(--HnEtdXjw)5GR?BQvhr7@@&n$sCH4F?|!dN9_9$0olkEWv8>rDVlIaSi&hylUK;
zjBKx{t4&^%UD>w-I2aV8OLJc;6PTywcT6pyenyEsHQ#0C8yO<`f%ry4FEipJM1s%a
zWlJ;-rN5?umepx@Gaobs0ZQ*_cbh0;CGar!^Dh5XMzHF>DEp((?lUt0z$4Qp0ZNLx
zC^Ce4!Y`uQdH$WxJ19hxF$Y+ijP(=aVC!FKQl;SYUMSL6DKJuOz*vXVf{~YahJbU1
zs{+Tp!*Ajh<1*rYY6?==o4-I@%6CIz!O`a&HEBaX@am5ffcqmh({$FB4I5pT;r<%Y
zoGh6p*37Gf3zS$@5bKicYF&BVITRZQg^1V9oqjjxc-?#<jV$%)$2`f`)8zF1o7zu_
zCzYcYwpCu|`1+2D>rW8ZXGZoQuFvFFHxA|HlaMu-D3dG2YcSTHoxDTjt*t)^)<{Xm
zN+}sEr39obM_6a$bZghVYL^$V&qa7X2z5nX&*HDN^?eltyCSDx_o>TeYc6&lYwb{Z
zT`m?J*{WM>NmWFC*^W><O(PIqGV)H~Ach1IK^!^k*Ce{;-tM7SuWPQ(EG=u9y2F0E
zxU%7smZ@FExeeXX1H*_WIJZFJckqeq59~K50N(74q~>9OnM|3AWJv{oE+qDg1c?2N
zu_QxViNnHN<q~yQ31O9rLN8fOKa)2S8LB;VdsSt!E{_wo58|A9VP7HCCp&m%E}1)4
zHf|Nc+K>mT{d4Phc!(MO($Uz<o3n}m=S3E<VidZcF(d)zUJo&+({yrfE&)Wg8r-yg
zO3mclk>lT3xnC?CD<ox#)BGM3pPdtH69N!j?Op|3i90v1`3QnkM8ZVah~ApXmik6%
zp}c@VWd+U0xLbtH%JWN0I?8pr+vWN4!SL|k)Tu(wJ9s@k?RE70;o&{qFSSh1j4sa{
zj^2SRRf6ZIRce_tsJV8K;Qn%}sg6FtzZDneO|F;(+U&-i!sMM$R=Cg)EpYt6Q%^I#
zN8jZ;!nNRACEiZI;8*}0i#wJTM;<f#8MoDn<6UZjXVGKj^B3QHq$4<PDe(zlcTj$`
zl*}zCg(q0x!80@l+4A<Zh$TW%P5`>ZFeHI~WyRN$FMFMv7*I`g?DcNLwf}YTKUR8!
zu(t;NmkX2o{qOm2{a=ylUo2`s^h=EQGI+K$>Z=P55)Xg_Aa1Msu}F~(X95&;o$nF{
znn+;nsgO^U61~e_Cw$@_hU{r6^K^vIMMwA?9ibfFiG9u%dV)MO?mja@I;Jxt7Q(v1
zYxncFNOT);c1_N{Rh|(rS2&xXmZDZLORm-yL_Juo49QGtw?AH!n};qyhMRQtpp&A`
zSYzi|4d)4(Rx1CuqeoY&9=$Yge6OB@qepLbe((<Lz}dOEU<OAsd=DG_X}m)xi$`Op
zKaR;M0kkc%o!VM%xNs^`!yz7sWj`@X(BvJ)N6r+ML<w9fw%cBB7Iw-&t45B0dF6rB
zEX)Qh+T#eG`yO@9VAEa_?W2CTz1i4Ti1*AKX!)+Jme_Sv1HlinuO*hYTsE45V7Y7(
z)qqJuFv~63IaqWwkn^c&-!vS<kD&fN?Gi8a27wV=*6d7{jxMU06h5+TH2kq)fk(xk
zysFC+^QzWq<1~`G3}5A7fsup9CGS-YViyL^#`dbJI^zD->M|tLgV>2FJ?9}=bIS8Q
zAyU$EOQr~tvP^djYh?7+LGY8DrZWhcvu^={&an2j?}+{+j3wOdyxXDE4N#`*R8cAA
z&Y=xi4~*&7YCS@JQ@a}NLrC?catlcWdRYoNv`NkwiG%U@H{DM89eN3=+%hY3VFhu&
z>7~80zaFdUNCZz?ZBTscX!lgULS%-&h2W2ET4>j3BySDzx5k7jkuiuEl@I8D_C_LH
zEg4Nh2=^oLiDo7~;}47Xoc0bg<8n`h>@x7#?P>ZJ!OZ(K8dNLMvzP}jb@Si}Z?g;v
zk6EqzsmBZFzTNyavTSai`&UXmg{RJW16McYVX`y{?;D9jt+k@J0oPQ4OXLGUg}11>
z+U^~H@SWQ$DugHcKEOwXZiFY0nye$4Zizrpv%RQpQuye$`O=gylXD4j#_LKZ&Q{7|
zo3d<uP}Lv{i-4yRkX)vKGP8gCEi57WfGw=Shz1E_W$U8+#}-2#f2}+Sbw8zDFFd4N
zF@PnBc9vX}#*)Oo4OkLP1p?w^hLw_gN69bnI1)`z!1jcV6>pMhhJ*%REgm8o+x^2+
zYI1&B>3p$>slqU8B!IssNneyRKSZUK_yFEPTw00U%6jc^RbrPM+gkBS!0b(YlVZO0
z>_7lpO;w@@evS%op+3mE<$g`xH-MRTaSA#C-ZAEz#r`~-ZZFPvPtn=%66lcK+Do$4
zc&P%YgQI4XY6M<&Z}Nbey_LO49oZW`zDaf?TN#P$Mz*@wP$AHs<F?OCt(Sut;fuzc
zI;ZhXp5c{?yfRso+OY9}AmJ4e*pSyx#Go99W_yj97%9%@;4KGrnfQ=5Yd7u{)SwMg
z07&SQ<b`Zc#Mb1VZTe};5aA`PtCHe3n++6;Wb~K&2r08K&vzf!dD3t9u+lH;3U&`S
z`bFuxhe|2z-`YEHLciV3Gg8o$Caxbg1!>~fwGI39JGl#A0SUaI(w-9QW|(?yJ7q2n
z6aEe%jVHXMNj=;B7=|FB48Vl48smEzA;W}miP;Pbs@CnEkM9JcTq1VVIt!>Es2jmo
zLN*ccTmDQ1bvP599~NK67d}n*i)D%r{x0KBJFhxZXu?!+yZFll{k1P?N6HJlEGkBd
z8|2IGr>3WV1F3et?h)zt)P|8$_F3J3oB>?@&r5g9dFfu++aBV)^d-v8dFi`6$$9B&
zED(%<{A`H5Eume9J}=EwLA~7^mW}|&Ej74gki2XmRy=!ib7+@Zt0k-8&V{^Aos|(E
zTl8OV<!-H%34D;g)B+Gi^`v{d9;jN%(R_A_L1pKF^U;Y^!-61FRILF!A?5&siez4v
zO;$f!iFdMztz^LAsI|5pc)UYPE548)KICeV`MYpa&Gt3<$Cm4-M(dT8B)On~GyF2l
zCJPFDvlf%UvzygAvyg+rSer$)lz@G~Ip<eBx&-I)*4o4QF#Xhi`4MUSvvwA5*ZKJV
zG$Ht=WnUF~g0_uBY)Q&|@)aU{VER_>H=BG+?V=n7ldB2!7na<<C3_P1+->U-xI0q8
zC#d}P%-#y;gl{oFYDZ^w&=<l;)cwRzq-S!bzbP)YXXb;0z;cwJeVGik&ObjgGvS|f
z!?EZ@F(jLVVJjhymoj6NaOQA$JNPt*!`uD+GhZFxG|)$ymxM|g+T9_*r_HZ3P@AaV
z{1=MJQ{<lqpG2`jbFvY^@b)S0DW>ja)YYvSU>HOyDr$C{bNl7x2V=Bhrokq`71J;&
zT4H!2YW*1u0U%D}#F94sVR)Qwu_)mW$<9FXkwmsDSj}r>4HW6@*S33TNKd8TeoaoL
z6)$P63EBc9lbA`k&k2=+ifX4bz7r`B^lZBACgeWgHPLQA<dgD3xKzCryms7Tp>hq(
zF&W<XFrpU~%&GQNy5t+b_Tkh<EcyOqw~0LRoe>T(-?(3vns531P(w35q1?ZTc~hoC
zvwsOwbkAFJ>3OTu=iYZIW$u+R?UL*`XXa(TXtS~K49idR)>y7N?^u<Zf$<v<3$ea$
zSgj9HgA{2!&N8I2XiEF!&2N`5iiIm?CAH@glYUH%vhiiSktSDH%d8lD?ZLA`4wVL2
zq^^{r{~>iGO;p+_<pMSP2hXTBg^wv{$-clQqhLRC_0L4QC2pev09DmhB=wp7>@CKH
z^7o9+v&a39-ZhY@Hy_oAlLDose0WhP+BkJ(V|0M*J%+B6p{U5-s01aBR(YNGQ<Azw
zk||Jvy~wvsoi+JGQ#1_U_TT6iUh32Ca4gNjmz$MT+ut^%I)TPLQdzAh2#V9m<(5z)
z_bat~A=dn>2NEk1A3!LfyMI5N{8oPj^Q_<zN@0;D+xh9sEiTIH)G-+MoSpOsI9KVV
zKm55I%z=X)a+Y~*h6}L8;JjPwoD@BX^W8Z}s*a$2Gbq1tVB3wLNs-O1pth-_f~+4X
z)cz&4-2|F2&p(#uTNxoIj`y$ZQ!)?pT#&+7DXU{*KjR#HTeTSw(!Y1(95dw_{Jzu=
ztgTU$O3wvmG}{=>S}LBrwa(Gh5@8Vx#1%)}eqVe-mYuZs>L8qwC;4^<cRRQ<+k6B^
z^0?p;JC`7{*6KTi)i2I$KFSoIq{W=qYXDq~Z<mL2W&b%edf>~E!B?*<>;7YW$MSF5
zZ;yX%<rf}nul6i1>tO8)3>d4$pjqKO=nh4NAQR!}WUFq&KtM%7=Es?z*z@!33gk|w
ztuI7;yu&9H_>`evtj-KEaHb=lkncukt^J8~fH3JHtLo{?J)*~Y3pk|~-tJ|GFFxb3
zUYvfe;lbX7<6Wi4{<ZQ3-+=gR9y&t1h41{Ms&zcGlH(m%f(tjX)x9M<E~-UxCf1vo
z1(`j*q9V3lAB=}El;~8$W)n*ONOjX)Xi9ZzGfLf@SbLdt|AJ>6eVP9J7OtcP4;<A@
z(7ou2gR0LN*Lze{OW2$Gz_?^p(<GJq-!jws1%1P~#2bVi;6iJyxG1h{>>5BPhxY+q
zeFzujjqfpcJJvoa-x~-ys;(RD0R=*Q1?Ce`9TxZs42wv<`yoZX-77^$(7qJYj^11|
z-isG4R6Mzskpp$k@OO-`c!~la)?xb$PlZdkHPTfnEL78lSK;{W70KTSchx#&9}N|0
z0fV_Oi89jb93dS|W5hfUmS;)H*_H?<Rj>0pMg|W?x0R35)?1uT12dbIAWs-;c207U
z%$Rh>8_tV?Gw5N^#SAj*g+GtRnt6o(iv*HBPUg`_nMYRiz~u07nM^q<FUz`r&wOe~
zn@{3<9T+h`!B#0#3gFhuxQQS3;ZOn1Hu@xLS^={u`F)vSOs%~(zx9VCHu(;E0W-?G
zdZ2Tv8vFo)6`#q2HmjW47wI?5>-dmPVjDa*Jy#myG`_Z?%Gt1#)j&-#_GSYoPIp78
zp!08pJ~02X^#MNp9I4P!@+0*YdtOjgW}Ken-j6uy#DA_2fb@X8jg<hHy3$F8(w11@
z^t4KU22M{6k(QX}H`j1oOKc@VS$*aj>RV!;z9UU!HdIlCM|F;C2%&HKj&Ti>T4E_D
zrwP14C0B>Ih7((2fiqmg5rK}1Bi!mjMj|L{?9r0}vx#{}tjV5W==BA|vlN=0hHiIP
z<9aE)x=B&A(?`)OJP_%n_bZXBT=CzR{au-Kz-Hj}v@Xhp8;u7*ut|uwQRsCcMvu|`
zy13czLXOT=3SKVld#;Z|U?k(8Wi`p!r18YFnvC}u6#0Ncb$t}s7$d59{15to>!S!P
z-}O<cxhkNS+#?TsyR4=M^k+aXtEp8B0@uf={`5&0N%L20xVB}LPr~|^RWAnAOmkTa
z;eM7z%`}&_3A{<8X3Dh@YQjU%S=|~}6MqT*LrAi%(V5_%`y4ay+{aoQ279Ub5S~!D
z%bmwp_IBsK4)d|Dt?s)RfS@sZl-~2hgN3pa3*~x3aQWvtJQpv-fMxf>5B_2Y$(?z$
z<J!W+=J;s5(5pmdO2fpKvLDIcalzbZ_);)08jf7~xwsFmU|V!KU4A|}(sB@weqF#H
z$fHHlLk)Af3RjtG=dTUkhS=Y@%c?UTPSI7TKp&XR$MWFYApR(Pq_eqUfd?Zq&f|xM
z@)V549*pPU?~jvh!x`f9IaYi=PZ6lUBtD;`{8rzGF2?WEN~maP>{@8GX44l-0lpkv
zGCY<dPD0FfIzCz64P2Wa7vR*mLj4LSo8kG(^F`9a|Dg5*(q5YMD}vN!k*;z!Mr4uh
z0^=FFNN0W~%X8w-RPl5`oc(<H9sU~6{;i(jk>Nxj$Ef-d&5!SuT?b%9jjj~wGOJmK
zI}594+jsm$iz<bE&av$<$JxBNdYydZp9cAinznSyDO@_}%UR`o-R33X^F{umjXx3A
zN%(cZI=(>%t4_An&f&NEo>vLREw+ze!=XQ^<OHCJb-d4bVOsI|`tlt#VzNqDO&6Lr
zjMMGQOM*5EDR(pYNB7Q9<#6nPP{lo4=8YILC_C^cQ+5IMC~ziYfOJ<dGvvpa@<X>Q
z{3wtg)l?(#xHtt@IG3gR5@(lw@P0^v5AR$0GJy9Le!3g^=jwGn6k!jFuYvUe7&@9F
zzuIiC+EaWypqe;;%%~pU3!R&V$d%5zw|ydCgM|{Hjo<Ol7Y7K+gIt)rjqma8sq$U{
z@IGD!_sw#-5u`^=L|Ww<)R6;a*76B>#Po4st8qfU?)!gECO&kir$g9RH3JjSgQ`0>
z;qdvYj=$PDmw*J6wVU%^bDi{$!dZIpIyz}`7=w9_J<<L`WSeOtco+E@$f<T7l4A(g
zJkG_#ceULPLsx8&#Y6lYWk(bHg;2DIDh3)?w*ObJYkO5#U)5r%S%>|YisIn<V-ZmN
zooO1DO~ZQHlh)X0o%1c}F88{=ieyr-ZFf{U1%EO4-Yi)L0LnW(p-Th(+Zy_z?ePFM
z@{y|-=0}g3E^p%0NyZ=-7CCPL><Z_V>v&f@TKwO{>c;De>-uW_xFC=3_Pabdd2^5b
zwl`EPDw^%5PEQxy3mCb!u0Ne`(u4H6rTZtT`){N4xMR-0%qy&+<d?}PUJ|~bcz$>a
zn)T#r=ZKShkLBar=07C(7BhzASQkg2qZkvd3c)%}Fd^9{WZ<6?J#a%9PtDnp^(26a
z?!TTN`)5UdLE~3Mmt|#y%hyL~t#F^}t9noR+%I`OMV_3V%zoz6wkjN{Bk#A3(_Twx
zmOR@sBIoaqYp?DChKNy4UZI_rKL<N6qKK{|KcLIV-O^L!?zTNbeXrK-zogbIY8}eI
zlX%33;{OGCTxk-!^76%mEb{g+Wy!^(lb7W+AI2TLZ$f%fQp_nRD=o3-6lmFu=DbO7
zguCNAB4eWa&u70&ejZZb;I+Cq&%P{AUDW-xI=X*ExLbJ1*<@x1*U%#GX_f9>&3WA$
z7~Yx}m`hPQ;`gHm-xo0VWud3;4bdXUgo`%h05h@ndYuUyz|;<UXj=z1?cORqig6x>
ze1+RQ0&Z0TDm`$JIyLel4pK|3_!?QaR_j(<f+5R8Qv6lPG>K&o7pOtl`Ru8l|I=}-
z|8m~BiS;(v4N@<)%YKRmqD8ojS5lSy-|gQ0^X_@U{#8Qqkvvc~xp~dzitFNflLVqA
z`v)zTP8G9oUtUH-7P%)BZM)>i(!YGCt*fzZdS=VFGh@9Ymp>c8^8FMnE7pRU!skJ2
z0xrT?MYt%l4GE$>M<-1QpHR5Ve#@0Lj#opdDz9edxl@Gmc9EmT;A2ri$@Bm<CHT~W
z8&C6SdJp`uWblFd`Ehw6<p|Mm6hC-nzlHjUBj)M_^aP3Rx8z_#uKmf(GK8_;?7rQn
zLsrmPtUb%8LsmK+w$ZE5K^-Dj>u#)_-B=nO+Nq(K>fs@s4qv-^o!x1${bE;k%cX-3
z!uAcEXQpF2ycAa{57TEPf1|za>)+c?!EQib;h_QaZTODtBfdDwy8p%E!3}enQ$uC1
zJGkLeNQ0Y)kml;&q>;u-TnTy#cfo@8n|N>*7~GTun4v6BW8knKr@8h0$Mkb|EEMTq
zw#_|C%6gqIZA3=Q;W;=czQmZ-p~~7v0mkEk6IeS7x4DvbjI#v$O?B@-53ux@`y72Z
z$yz;u2lpB3Dyx3`H5~<$4tn8n@ETtS{p`I?6-wffe9P-Y6c+t%(tz(y<OQ(ajMVe0
zewh+sN^e4Gpd0=4ab|x&FZU`sEZpT++UU2xreCG4fP3(Hrku0Jmdm}3y+T5{sEA)k
zDU-DOSb8e2b*kjJT}owq@`6iCxawPXZWiR+9r|Z{SLBZpUM}*wq=A1~6b(-PHD0?k
zytavkjR|&e<k;?IMoLSc{#D7r8pVV7cQR3@`!|B~xWf4+7eUzx6xg92=}*1XrOW7n
z(;^a3vDWz%0}g=6rOHyst6}aE=kkO-93A>ho@BzAOZ|Xfi16j6Vn(;5P-KwL7|61$
zxXfo6XJ7K-JaM=z2p?x|Bpk_&gh;5Y`6vJ?DCb4wBYX`b|43Hmmrd;`l`T((U70WM
zBVG2z_}!@|Z>7^KhZlPBvs~Nk-ppIO*Iy#M<!a+tzBlo18Ijrn*!am=pdehfF1Lh_
zc#aYV;w9;ZjL7qF#6_N88Tl&?uQx{i!u^DWkw0@k;mXJx+)ubZ@(TA8Zi@Vl`w2Hj
zUWhIkc2%S;*<_^ta9bZ#>JRs&4G;b;1>ENZx%a%128V{?xkSrffRzG5MJJtSC8i+x
z_0{Mb(7p&IAxdaa1r21Z@sS}T(qyLp$%3*T9hCF+r<h9;gDaRa?Z$}B?eyEV&32>&
zxaf}QuT40Xc`aAuH4l&OzcCz&?!T2?)6&eVtoTsKp$B_&=)?4oK@WT(w~aI8>arLq
z0OAw{!g-IaiYq6!e1B8qCAo-QQ4o7^P;Aqn<o$v!dq!St^B@e-_9mLJwM<-rJR~i8
zxgU}WcX8r)Z!nfmITHbP5i?(r1=IsW)BNag_9BP+564oIZQ77z-#TDOX9Bd}mUtBi
zpKEgu8?okY2mjHfgKn`BawsepcIFr0-;`XdBdTCTS+N(h?D^iHv^Z^0Kje@g;K1gL
z=Y+?_Kkv6RR$1wJs*eiB);iksuk~sj>sf_P_*Zc5;<KRGwGv;Y-v2j-^ZElL7`75a
z(m7@=j^`eh?*>vIGw!?Ev0y=jqTg|rAR<NDtp7^dd$t}L3*rtLQ20o{?-gsHfQNw*
z&-BNDY<ziJxU1Ir<mvveWOacXFH&wa3_JHpSn_a$y7$Qo13r;BW(VtwwOlYY^5dif
zX>dm;T@^k8rH3;Uq#(h;RG&wF+^F*78!A6;N|PVoRQYkE%8zRzze7kEu8Fnh#9qwt
zrA3ZySSgShR$Md!(NMkzw*U(A0~Z>Px8+_KazZcj$g6)N8%0ip)2o>2IhM~wUi^vX
z0$EYG%PD$7mUnY<hABl@USbJ~dm_Ym4lTIax#|di$8mXbx}=%<GJvG~>+H)$xqA&M
zIRC}UpT^^^tRKQT>`}-HUPAot$m@1b+g2LhfF&ct8TVtUK&z2QyPu)UP1@xrdH!~)
zg|h!>+1q{@S$g<VKe7@x(}A7@Dsm1W<pcwFY-CuQ)6g_Fd|^sDO_R-y@VW{BVG^g1
zA}$%9>5t=AUPBiSZ0MB8Z?va%MxMGa@I}D3mweryGOZPUOLa&UrjaWe3bVXd$8uya
zmiRdyhAPgG5R|l?=A_NKO=yq#XRyD__v{qmBQ#v-gO_Me?ozl`>hx&1SdAQ8?L2&+
z3`RPw=XF2*g!u3HHi!oiyweaKAtAQB1@P*1@b6WTzq9@=Vl`fpbxY)3*1vB?cCr55
zggUZh$c>TL{nc)0+G;n{=U*QD)h@gor;_=Kst+(4q>%!SeH)bPtC>hUq1UGLDu!d%
zP=|bf73tiXd<?=}1j6tQ6ytf7<6hxme1$}7sC8UsIRo!*(qG~~m(Gpf<WqgI1NkET
zZeSH0z$fRV_#|Jt+wBwbe(#&6f!~}Gc~u*2G(yXLlrLz+2p{IyA2Fin?N<Ct4E~uA
zMpSN!Z61sS?I;l~xG(nNV6zgkIwnilGY<CfNith5&HRJ4PO`j~^H;XXdAd!uR?lZ{
zr_TQuW2TUy=@}oE3~}Dl*r0IfNe|0>{#ULyxv(AbDMxHf&i<j4?aM|cFB_e_Nbigk
zggLKfLvF2Z_v!W?!Vomamd`7&;!jE=#J!Lt$>E8CrZ>iDdMBajg^!OOxWI}Z4&ZI)
z0mFt;8sZp#!u`<4bF{JILQzHJ)1Oj&*=QL>5sYD%og<I;OR0v}pl9+y(%{$WxtQ~=
zrThisMW)rO*shz3&4bVzF0r{VqGH<J^^Gqud!WLKG7CuPH@9Z;{g3&uA7FR<5Rx4!
zl_a6z!w{z}D-G^j<h6L~la%tosWuTvq@zz#9WA0GBUA@PhDE0oa+A~yuI*H5=6VIR
z+WGu@ibfM1WT0DLYY!cOq-RB1z0b3mdiGmlR7k0sDFZ`l@)?I|KpGW@ruKSYG_94h
zYH!^NUO$+6{Yzep$VSV^aqmQcpu=$)QGDK#cdM$qX^^cC_RA`HQ<(351W;S3h!;D7
zv~oe94!B~&l{8AeEis1G{=f`6E=@0!rX8NTAEKEnsKtmMmS%3FP`Tl14DhK*oa63i
z4NqaZmpQ7{{>eiiWq@4F%=%(Xzwb?WS+idI{$6JgaV{#`al59I`>L!(Up4%b7C`2N
z=;Y$?cwn4qV9WqUf71cTM__APXFj4LTZW~XUx~btyfx30mmPzIYW%#oz|aoum(7yR
z&zD6-wBjeo>}IO|6*wddRQvK%Ii$#|NH&S3wZc%O!WlI(n7nss%}$x$@AI*#=tmq9
z588N{)TkZJg|*}YHNl~$OU+Pcx5cthRw5=iZi!J%&2ax<w>2!fpX1=esKyBnBOB_H
zdn>ftij#5(my+H7d_9ySY6}hd&PMUK;R7YW2R%^6#Ojglp%Dul!;cWl=Sgxoohc}u
z8DRH9gWVthly4h%XNG6s5F!KYmXS#AOswtG&q2-{mMoccS|8_iL~ls06%=vDm&3FT
zvjkgqPhE9o+ojAk=iIw#3Z;1nA03@6S;C*glXvS?0&c>}F)D*Rat$Ch<_gZn3ZK`o
zqB@ODu;D2Ai7e{0>${Sd=oNiq<g{9U!7HjAgLs!3`d<AWWPPm{yG2X(anVT(t_bK^
zBk|?nfuOy77%2Q>F=hcDgKQm4xnk^8Bp7Axr_6!oJeNh%lwa~&y7Kq1>;Ycoy<82g
z@AObmo6WdQXa*PT2zZNW%SBls8WKMF1tn8${;K#Wu`4}h<P`zUtc0A#dLp6HS$nZj
zF~Sr!UzFLhEK_(zOc2nd`!M*Yyrh}*q2U$EJD*7WiERKRX56Dw>l5@vh9)FDF@7W-
z3hbqM?o(1y-#MkehpgQ^``D47#XMI)JPnuJGVQobkmpX8G2AVbW>h!Bl`x}wBbBi@
z#9(O<b)Gi4yZI>hCI&C(H74Ip5Q|`>YCG`RB$|<&5Je9IFfkP(ABq__(uLY{L*y;g
zp6eq!n`dB*F9_%AGTXrOh)BB$NnpPrYjY|n0qe9e^7;!l>A;!NNvJJ3&b#SMY#(1T
ztbdHK{t<2Kf(511IprRuaJAF+cgDp*OC{?b9AIuXUMkG5V=(FL3k*cZi9LLzuBB~{
z(HN&jZ^7(xQyGnL(Zp(J3TE<T^*kEVpg3EALnc!vf2mUKTtsi29q}F|L~eUt5WYrd
z<3rQ{OS+(TIwK#_R?!)obK=_~huii3g4%p33o7*fyO<I6<;UIc1{^et`<}E-mutnG
zZBD5mlPqkq@J8<QcaLfqc*-{nY)Kggw9E)dad8j<xst!$@|6PdX0{RTLWnMAvI1Fm
z+QG=LuL37q?&8%5igd`M#C~^?4q1ee%K+qssz%N$hpBL7IjA1({>HqicJ4wLd01ji
z%+pxk!NPfMtv|-rYv?0|n#)Cm36g&*7Pz$A<CCb?fBoSK-67-6=;ve6^o1i{e=Ch6
z?hVi>=J%t;8YfY!kEK|SC)}?;=ymQQU6RkO7Y52I7lzVjWMFMlqq)reFVS4Yr<9Ys
zh9DqILup&~Pvl%HEnv!bzN;X0lnH|p;G1uV+WDM9)ApgT_cR}%(mNH0eq@-NH8M;w
zl2aqY!~|EuD7QZ4ej#X23+-~U3GH$`$k1pkL1>rfTlJ&v=)pl+_TJ$Ewvhfa+)DsV
z!?kpmdf{4*^gFcHh#F_Yt>{k7J7p!@ipWn94d%j?p7JD)&@u_PGE|==+{%Aw;85XK
zKJfV`^0`72TZXcnc%9Nz*l9P9pXvAU&HjK)lfLWo6r)tw+b5LfdUsC6^`isZAT$-t
zv$#4uuDHUAzeYjYb`JT>r~T?hI#Ek5M!YQ@R2|tFU79s7@>+Chb||tnx^(dD$R@Ka
zprXXuhr~7y@s!L`PO*lFqQbf%Q$|JGc$5JVZ5jMMShP)qQ+yr2TxcO%v$q|FiXK1Y
zRYixnRWchi!no6c9jX3{`<befDe~+oOEYV%#5lq9(m_+L#EJTpHOoqj)TitV$#<ep
zgUc+vx#4MBz-ts_1G@k&W3o#NQX`0hMH#_x{vJGninI|VZudrz?~Pz28oA7+ED@%1
z8A$cD@a3M?42BA<cn*M>ZBvtQh;BPR<)Q7{X-%I_)2=8=x_?VWCB!wHLNIcxC>L`^
zySe=IdBRGp656Apr^mNk{!J0!1>qyjB6GNOnApRD*qv2s-t?L`AItKyCwc&D&_Y^`
z9yrBHh!>}eBulOS>neS@w$|@Wh2I+nu9MYlBM@}2sjBj9^OySHa4cgs5P9x9w5;U+
z(bGB-@TN3ypZ8xh4R|5C3M^4>SmJxwGF;hvXd}asYcws5C^TjMi;o}Z|KeI&5BxRq
zy;B@d%qDdc^Wrcu;4Z;{J1o{Q%&y3@mw0wteQ(yB6NO12@+N=*fNJNs4<QTExb%;P
z1vJ|C5!B+X{hYY$vA_O6-sR%6d0i%fd&bB{#9zvPOAQiv@qv7i<P7tvE}m`8NmcD^
z;8Q=|R-PKohWo)=h|_1n;e=237SfF3OTs6z13esUohOZSI@ihGO5pr>o|4bsp_uuE
z*Nd^5JT=!RZtED>RKIxQM+&BUwD9fIV`vYbubx^i*80J|+-1C?jEEQsS;Tav>bIM*
zaiuSD+aOEZeZuFm007t2wN!tTQUl0<`+piQ6%G2$WObfwvr-XAmJ%@P6DI#0B9JW2
znv0gUG<zOe+EM~WA;t(8g%}%pp@^}Zxgy4f%@Hx?9ps)!(9dPL-d+9Wd1RaOZ;r2(
z<7W8K+t9WTk8K*R@(nRD+}qrirU{Gt83rd+5t(3|xQche97bO2413=QwZcCbB8R#}
zCfqEodow^jS!QNlSZ3Z$ZF|xL!1xvrBg%=qdc19G+N;Cml{k9``qaNU>V}g<pDIl2
z!M&RA6`Co(f)1&jmU|&DD%eGKT{pSHx$)nc6N$C|OUcHrwoyM#^HO1BUgzAfTF0O*
z73wV#<zalFov&k2Mt0jB&M02U{s!L$GJZ`uKeB}2%ty4%pfz9O*L=qV=lUv?k0A<i
z_|)Y6y64(OD2I}KfH)FPVna|zT=&bom^O!U6%us*-H3{m$=TgS30z+&+|}cRF{5;E
z;`c=Jdm+Ew^;F^ABvyJ6plS{iigh4R(nZL4;Y!2rzCA$ov6#n1er&2B@`SZk-guKS
zl3Tb>^qu~GSYslt&Wmp$5Jg%X^@iaNl@?=IGR+J|ce4^bz^s+eH`3EY-pY#{NnxF{
zpF==Tctq|=K4lcS=_FkTgu;EGv7DfBzm||SN68&{f2!)f;m%F5Wx1IIV~m^v@1E#2
zY$e386yxj&3WpV4l5NGe2s3GH!`K0Kz^B7C61#94kR_*2Bp{s?mwT151G(V^UU<IM
zqW=J4+pM2K_!9;1opsKHCLO2yH^C|KbUU5>B9QzrUb1$$at8@giK>duy3hFyTNd3B
z$9e}@alO{nJA?o@R7*~u@knN594wIdp8k}_xY(Dt#aCS6+_&H3Xe+*iLIG!_fFr_7
zz_~ABz(IrVr&3;HRLU#lgNKE2kM}<KmifSs0C=itw9dI@G8c)qKnD+@VCT+F?s~7!
zc4;EtYhs+&=SPNTP5YuV3qZe!GpM9)znI3`B6n+iu64<h5(sEZT#bwT%kH9px2=(u
zjR*x(|5*d3<m!aL?eOZ?Uy??jrBOh0BfP1oASmI#5_(o(Z_!*t;@Cb=-V*S?#<6F=
zzjA*R$d;e)MI;L6tlXcGL&2H!kZgRv?KZ*Yxm2lRCf(1-4jC+-%C%0$I}A-txia55
zLRuqij-Z&C7cClR#b@A^uN8;Brr-)Ce>VgZ{&j<}ZQ*+Ql~E=yVQ7!M+RiIu%95Ml
z8io&f>V-)3uFCu#9oX1`<1}7;x)r}i{!Xysukx3;;~i78VcU%VWwF|u&HF|PykF~_
z_clY&wL^vg(|smGP>VCMqY1ra!jW68TPfFgNTK%&ca>}j?ZpVy<^D{%(gCOY4~?R(
zB4E1AAn9hv?*jz<lHLOZeEC>|05#Y@E?t`yBttCS5*}DaDDmE8glF=XbQCf?ZFJ>d
zfZYft;VdgLkyiqH=}0ySEPMN@X|26aN_EpP-irT-HUewi9n$a_DD>1QzKx?`en%Vk
zW^iAoaWB8$^qmpzA<COLdy;}$>9+V71zU*L#kWHG5P$6@BZ>53&nM-}NV@|Z-S)r8
z@SZ=8w%r5RNDfm{Y?Rnw=3H{YB;s`fiEJnmd}F_bgE~xl9Fss6s?E+#l*+XDOVB_X
zSz1Lur1}EvF0Mq*H2OE|gec>|xX-W>5@J9x{G*G^xU;-*uQ)mwcPF@!af|Ts#@%5?
z&bZIeY-id&9l9dz<X}Pghu?3C!A6<J&8L)-4k-bU8iAWE-W9o=3*x;77KxuIh;)B#
zkO2Jw4tL&c1uf70gn<An<+3}hb@t3ueZhSzD2LxD-|3ZaqC9=i;ax%>{3C?`K5>ty
z2EtlI0HEcvTOmo!$SL)E!j{}pT}~8`y1(lRMHDAtfe+a0qH&OFB6%4X8z!5Vp4f0Z
zczeh(o#DPsPjs;jV~y~AMV@=|zoj?pu6ERd;jC9fB&o=<k;&=TA}q<N;S`ll3LoG0
zZ)8-3hM&>%1^iw^tCaFeH5YgI)M~F&$!0Jzl{N{dPp}ea2~Y<5@9;|U6->>JIfK+q
ztr!gRvZF+z=typ)>v06VAUk|~_cyLyM?L$`e$8^4i%rfZ#$ugN%t~wI1YQwyiU5qi
zCw<uIMluPBx^V~xZR88|I?ZAcJgz;~)29xL**b(VG6a&Ar0%RxtP>!YH!=a@Z!&_}
z@0aRD<6}9RgHfdXdMQsA3P&<j_cN)`<6M3xFB|u`nUv9BVS96EZ`)Qy=2SqV#^Wm#
zkI+D~in_<ab}+-&%-cRxdXi~Kc)T98LwAVqtL9b#S%xpKpJDiK89g#WdO;!^)~xhi
zUBRn1(39cGYQ1*bui%mNb`AfI^gfpOOo~7&zQfeAU!-&CAy$-a9BY!5LXE=$YBZb%
zUrP*3A{%q#-6M2Ew*5x;EA|^66y5Fq!w#9(6W~pF-ik})1>t*HuP$d%68UntnIaxm
zT$Fa7+u!Wv*$mi~sb=mRcbsmJ@*Hmm`kUy$?GHHU-~^)HokbOI!z5>RL3{#nNC`GM
zrQQma%5^X<I{DP_SJA&9R*28=a@gfm0GJx)()`b%@x@qYOapu*+o;S6*+va2i)>=U
zH7&A{4OeO8SvFkrB2Tj6Dvdm9Y%KQ6v3B1FK&&i7{p}MEx^dD&Em=Wj{~VXeA&cLe
zf1<zVRe@%mVrjoz=Egy5ESt3;LxZ*U9O|&pvt;d|y<)TpNw&i(6@QYy;-tAp(BpeZ
zpCIk^U-$mXYqRdLl*wsvu<l*xL-s<5Y1SxrBIFb(!3Pz=8uwkYPVvHA#`sWPv2*to
zmj>@;c`h?K3;7RA+Kqcieq=8Ze~wz`eT)S%A9H`F6Uvq}RaX2bw4<+o$LsWI8ZTxg
zU<~d|{#GgwwPXZ3-0Mg6gF@lneyc<Mp6)v!=$dur+r#;mpGEiTPm$%abOvVYU*V1-
zL*>*-j6e#<<Hn$>w|aEF;-;M(=-^y3?GaBAb(Sor!Nxr(nkwKg{)psMyJQ~x$jl8~
zjb(O}O8K@8=P*W~_(QV}++9YU;_+&RJUy}l9D=d2>9{=oaMF7rDFiZ36s))$M%%;|
znlqY(XQ;QbC6`}|BtDJAX0il)Ntb{syQfN50loS#^)~HL7(oqz!ma+Hxp3<spIdqG
zxz%$${7g(tsWUdXH}MiHQGmI{=LeX3jB>@?EyzN_!4D`9!c~BLeer1j#@rrh>AFl$
zg(x0j*vc$EVu%)i>-Q+9YC6qevD1+rYO$NYOuN?J{ykMd%MIG!oom`xj_H$SPBqHt
zq|@1U8nGYf3hnxBp4&<Jx<l=UYp|b;?qI$#la@@v{1%-wE^Iamxot~?KSTu9vFAID
zy-VyhK}c$6to#I!)lMB9negaBWw|{iCtGRx4VPamAA7d0-|9CH?ErRjP9^=G8X1CN
zz9L*?A21TL^LbeqoP3VExSK7#+$>*&#71FHN<jf|*CGeI@5h>7CO0>baL;krR~mT+
zAE$YdC-8A9jr?49QLQX4&&yJxx4pZ6jy(141A#q}Yb4xmnGQ(B;UmcxnG&!%UVuC~
z;?P$p@*aK7itMJZP~=baH9NAMzCw|g@h6@Wc?o~wd6DP2C*xgR*gQ-Eobz)IUbDkI
zXZ`7UT$-^zRtvl`Yn?OmM+|draGE9d?Dqj#Y)<_T8y^t@mC9&(ooALRch)(xFiS{k
zx-cFRf+=IXI*UPjIg-R(e2m)%(S7>WIjfU&8Kjt^2JT!`h^-ixx#I1%Pt*FD?f3Kk
zc0MuJPUMs@x<BNZ-S?N81Lf%cap8IRI7N;~mS4dc|8QxI=#aGAcInSO*5cakD}7Gy
zt>_weGF1Yr^M@P^3oBt2lOPyA=<a7!!UkI<_Af$Jd<EGfgOm*6bxx&#<c~tnzCQ*z
z+U?qp<Vh;shuG>SE`8=4g6}h>q2$E`-{;A@(6Rt?VHRG$!EFjr+ccII_A#*_dt`d(
zhv^8=6;W>4JqNfM?)BPo=4>mGXZolxj<|5lJQFhtuAyHs1^PEz2B-CS(BX5c-w6lz
z8<l=p^D<mHjL>0*UQdHg{S`z-mJ3npj^P~5#$RPMPAVV~|HEWCBL1>>jRG{3vcQ|+
z;v%0IttT=X+SftWITf~|-(60xfh?Vns(r0jTR^LGPVs7s7iH0(urJ;zT(E$5@bAAC
zdw}O6ij&6*?RSJ{CpEht%u~jtU)B|ZTFde>w4-DspP|I}2qRQiBo`AWvT8KH4b#NS
zMQG0$DVyeE9(5mPhO5VY?pO+$P*!{*164z=)pQz<dcblR5AL!2)3()LA`PEb0HnLe
z2-!NP3e!!%ZX6+BLYr;*GNz+-Ov2eG$`>2>BK<rtbzg0+B$kR!9%m(F<KkZ*vf>g^
zrN08CMC~bNZ@}EX7Hfn2EqF%pZyX9Lq=ouDWVt=Yy&V92d;bZd?M5kJ3s;tn-S_49
zeVg%LH;Cz>((bKn+X>uqi}WwdiTMj^{g5*!-lx|u(^Q)}=Wm?#rN*r)+hq`1RJjl6
z#_mN&IGYFOSM1r)n-HL?pE876=geoZx@}JDVdD?H9>PbX4V<D!5#c$|iu-N$sO}c|
zD!3WS;NGTyVOBeT_yx&g4wdJy-xq2wx9j)NntMJ_rl$<E)~W?ErIfa=fi+>qPLwA1
zHhpF+WiplzRt_9Xopa@sftxrT`&m-|8R~n`rJ*2gy^(O6NO_<BH}#{x$gM-sAE~JH
zf5p&$-G(&!A0N;^r~9@fR1Y`!6z_b`r}#&0#gEF?TIjA<N^70&MSXpj%&$$hnmg5J
zeBY;sIQrH(|9<%(YJXd)9ck3}mjV+bWZw0obLeRmBuv(YB%Wg~AIBe*WP4EeBmD@}
zeXne6xkGw;f6~bLYTACG_3wr>=b@G9Z3PIUCk4IE%&3YEu}?V9|NOr&McYWmZOpFR
zC%uI=;8i7-oGv&yv~UPwJ<B_D-$)J_Be|;7pcl*un@mB4On6y+hUkq_hB{6>k+#d-
z0ft!ZytoZAaZ)f0&`rJJG>A0oEZh;)WF?x*E^Nu5d67q19ZDk)vog$!pv?@vF!DY0
ziMf$GRG;`x%1tRJ%}puoo`Lbxma}|aqN<$?EMaMWF)aLFRiSqo1oVVnHIE|nG<=OJ
z6KzYt6iU@M;ETc??szH$hgEaW_Ev)B!%^MzxVHOo9cw5?SH3of^VU6S`lj*M0)PJT
z%jEzC<EQ)|R!n9qSQf4>zR>vX7NblY13wqfiCAo3XJc08m+C8aBsa|;ryrB7*Z|o1
z98{U+rOC+Sd_E10Z0Vp<G&1pycwTqE>pg6;hwz=gWDhae-$U@=?;))C3N%sK@sd<I
zLk?*&x+Bu872m}VeM(#fni!J!By3W*P@dJ#DTd>dHf0-ED9<xg?l{Rdq?HzerL%_}
zpjp6L7gMf?-Gd;}G_*Ry^kND<qP)oU42Fd|;p$TsjuY?bQ}#S7{vqwlxvG_TMau^B
z_C<Xf60#EF2E`d`wUv0BCm-${F0SDB?8BXND7gOs3Iy&K`5VAJDFrw4&%k|-z>UFQ
z?I~r#aOOPDfc!NDAZxCbI76SZFS6oaRb=v%7^P){0rYTv8p3e1dGY}rDyE4Ppq_Q2
zKZ1vPfIc9S&QBTAIx#@79AzkilT7~gLp?yhPcMpXcb)b;s0vRZeaZrwBlIbIx{2BX
zdZ*(lgr4yK!%N}{EC_ss9s{^O`$_<pIMpd!dshGogHQwxqGv5V^SgAH=6EJ2q8M@j
z&Z91<8bDojX_U>fFE)hHA+B+t@u+NEBgC0sfNM|Z$^|Ll9`U)dR)FJFNrAfx7!*?X
z5(5o<C7kG!Ylyh%q{!vD?DQvBmWP(Vq@$(l%K=(`=c8r!aypZpA@jlQ7Bz0^U=(Qy
z^pPUN5KlnLNa@au)OQt9BbKy>Fa5HB1Yy6g71t=D!_v=Sub&wG1T|;+HLccv8eOp3
znJ%>%f<jdz>w+u*QEcn!#1bA>*xj?JqOH4<Hb&XcJ<<Q{!U3PX&u7}+!~rj^^}9cI
zz>8CuZ%Q6_n_uPAb^T%Kl73}=x<B=+yfL84NFSi}175rdveV?d7w;JZXUS+n9P8~*
z**&LRKExUK6Afyele8bB(~hY83%8L+Wp{Foao!nZ>qD}Chy^>ie#Ac5OzQY{zLZEn
z8^q|C=p$7e%0JOo7fBk29(Ae1+L#K(yLJp50}5HktDOVSndLa7UiQ5-DYjWJ`jK28
zSt8d*I02I{(t>=OTQ?2xL=c3iInTRy9Uku`2RT`MKJuljNM~E8=p3aCvX&m4_i*We
zY31GQ9J_vJVPB<l|BI;GEwg(TP=TE5PaqASUnp210Z12rg`fO5PE#4{!4ay()*Abq
z)5LFr6ZFd#f>dv@nu-)dT~qBElb5SPu)k8#)gIyaP|PzErsjD^h*7DX7E)i#?JN7d
z<TgR{B`aPEQhdNP4)rbcP7Vr<Lrn)79$pi$tdJLn2t_To2~6lG`m1oBpP)0`_zfNf
z*9vM^d0?L7QMF%UWj*aoOU_{lYOh%qtS=ywlBz1Od8OaDhrzYaGm%<S@hGgO*G)kI
z0V+&DYOh9yM68gg6iu=|8cbNL6EddRJHhsr?4k@Sem7VXYKA)74*La^{tEPBKbqt8
zE(|D5Jn&%m0ttd7KJPNOB*L|c@BRmV1@h%@;{&NTiixH@fU3V@BoUdHO&N-PXs5>g
z9g&CnJv+xl!w%4&SP9twBOvxt8Mj%F{pNRygAdJL&a2FQ+CeR#r{x)tt0}}ccYgu^
z!3@yJl2}cV`$xW%^RpneQ|q?{3h=Q;H-bTkFe_0fFG%I#2biD8Z&JTJAa)?hi0A`#
zfhcn(ti8@pu1EX_X~lr|tu!%G6W`)fj|iX1bPI@Z%QrLuhL3-m@nTAw{5V(84tt0%
zLo)$!F#BH3z$`yH(Oul%Q$ZW{TM+D=PGM2a_VB2-`=m25UdRXM;wCN=3<A*2|5=<p
z1V&kI&6OS)Uo&L<Nzfal#n>vpN@mFh{I~KryR(`+70D_uSEu`k7Lr#%vR9PA46gX7
z3KTWlr&Np%TL#cl0CjFh0C`Y)dA<fEmm)L^VjY7_sxPi^psyl;iQ{54f|EQDU!?)L
zykj+qr;(6fft92A<OX#D<J?CKCmyg8l`vVq6L@Q@)4+Ajk|I;4Kec{$Wq)c(0tAf!
zZYIdD_tTuD-VvX+i!FE_2xe=AW?4zx+o=%Dphw08Gw3HCdq{4J2OA8F-%eR@+4Qzl
z-Fz@76qkHK5wEUb)91!tVZh=gd=TWpz*r@(E1kRKU4Ksf9q$+@HqG%!hYF{PYg&9O
zq}<3W=Pa~lP~@F8ua+}W6HX)7couSzYD6Tftov^j*A2aP3Qbfy|NM(K(Q?sHc9F*z
z58(9Lr<Hd9O;Q4}m{hiv@d@D(H`EL5pJ6r#17oOXzsGf5taN?<#fMm~aB(HNxipis
zVjR*xK50|<D0^>Na~3}yn6xSKFS~PmPj|Mxx3FDPc6|?{uKlJuQ#DsgLR;?FXpT}d
zgwk%8J80*K``Kn;iyG)yn_QI-BjN9b`#wmuSISQg)B<Vg-a}oLL)T^KSSoZRjLmVr
zu7i;V7f}fUq)bHa6_oV%kCJ@Sto-KG)jxzdS2nQbf=qFEroeo<f%#NH`*F01{$?bx
z?-uxb^$(Ji#L)xA!~wW9^8!6AsdiSQAc5WPA9LSYN{{8=lW}9cl{9;=MQ_bIGu)Y!
z@3hsI_Zd>KzeZmA=MTB|pOYA}$#ge$#+0ek!i$qJ2f|@hxFJcz(aiAGvEDDjS2BD^
ze`;de@{<a;2|Udsiv}XRxU}fw$VbWQb1=J1OqTIM_!uIiFU=vWTgywnUFP~3;iEhp
zWEK~Pk0>4y9wFz;?Y<p{22iLH`@(YpyUK}$y-5|G#qSEIY_az{@@lf|91Q~y9;I)_
z`){l}O{(+m$7oa4V>JX87qczDmAjNb>%M&*-^P|?XNLchoIegrrT2wq2G{+*!OzM)
zmx|aiCNnR}QnECkyKi<v4*l)B9_HVO_yP2H>v|uJ#h8(dvy>}7XdzB@*)~gy7w1{e
zo^AIO7g+HyRf~s*ui;lQuKsKZ?H)SN{2|fx85^oHGQxT5$_m@3HfMRiBOi0!PLlkE
zPbjXB+|W{%$>rDj@Kml_l*#Ri%{1QKmb^K?Y<h<m|K{fW=oCq@_rZWt0pk-%&G(T8
z?u#xPbbe&LnyAi~`Fqt3Oq}x3geDHi!%fq-#&5C{kLmcI<X>DM*4{(yB;vt}N9F0;
z(~7=5!;067)~Yq-q$zdzyO?rlM!22iUD8gnMcR>AbIvzpW*KpHt9(5)Suz7o8kM|D
zswAJ0>XlWs$+@0)qZ%{wF@V^2DMb=O5fk@nsFj!wv(pQ>!qzm3_5{a;6c&#mDk^`2
zC}rcJN%H1g5i#D~m~PQdD@Trh%ge_$6ccUaX1{R`_Qe1q-77I$rfXWlag+%{hv8o*
zua!-b$|iPcK4c3zoI9Yy<);h7bZUCa6=%`cHq??J0Qt#K!Pi^52M+}6?Qe_B;)IIB
zsrL$Wf^az1%UHv3TdbGCev5~~eH{sr_fRMZ{<@Y?9<1K$xz*<+^?gN@P1U()^0el@
zufD+d(^q~mf##M^*b>*@N_nor{>ZpxbAL#_(x`pVK>SsRJ*GXE*!m~-TLI&&<>v<D
z^TU^?1y~o?$RL1OBaNhh7p%)Y)8STJoC`g^$9m61B<U2hQQmTG@^ip6(PQhJZ6~D=
zLta9VlK2cLkTg~O#xX58{+TR1`f<x$GG=AYEga-}%=xKo;5_C$(p0G=1aF<EA<5~-
zHna|Z4<Ozv{q_KI;7>tn4<HBr6a;$!O}H1ABn3dxb_J^{hiJo~T(xug0%bfP@v%@X
z(3shOFcuOerja`5YBWr~a=$_WQ>Ls0TN@I<)r408_gSs#`bd07j*)x{VG4r;X<X=j
zpp69gAX@WLQeoR8<)c>JOK}V~QUDWb8Q)QN4;Ym718z+STB|dADx4RxlrouH+=u9+
zADW`3AcdxzOhJIArpqXB&!s5@bBB?33@hLL2jyU{&bc{i1}!(B1%8hGmt@v+DUaV6
zzzG^4N0FX%maovyMffq6t2s(^|HC-f4djH4_){q-u+$kY;2fH759S1SFW=MFWJIYe
zZjscln8q4;tcQYH&Ooy(`gSCT3PCHT6;&WPpBLn=mZdm02^Ck;5_e=U$UgUB9@TXI
z9H@kOPpC*HL^Se8WTR>9PvBfytNd@0G5#T6yJLkKdfs5xkm2D)%_V*ApDC76kuw;<
z`-}?S7HPbS5cWQYr$M)b`W|#Q@W^0iUr!5jN4q)b$40tXO&fUDFnzz$2hB#Oj3$P%
z{1S=b6;RN9R6w{{mYPrOyY8cFS!9;*VR9()T-KRy$&ZQ|Qz|fs%MhSYvPEjzpD<T5
zo#Q|AC}bt%wLhLCO{MC}+Cz=x7#j6Pa+tJ#v(Hk~?VI!62ZbpA7wUb%R7k^**z3Gj
z-{(>FIgry0gyKH<AiM<i1a=hE71?!~LfdVoSfFP4v*L~NLlGg1pPV~ymx+8e#r^b^
zb;7us1}1qH>w$fjI2+LF50~(_+WFlv9OZ2yOpR7?hAdMYrP7T^R~rPGBJwq&0f}`g
zE33(W1^3Y-;aUmCo%ttOYidm^70ykxD(^OTk1_d)NN&GHm!qJ{EWZj_hgLM;Vr>8z
z3|P|VwX#gnXZQtK#!POZpZEPoTFva}enR${$rc$xrL!ZGi?=2Ni)Z6Vflu}RxmjMI
z-HbK$t6fn9;E+Ql5&8yo4wXdcn}=x<q3+X_UWwaiK@;~JJh+>V_QoHK>r8|olPB!u
z4=VR!iXUZ$?cI^E;$n4AdP#(2&k=<Uq@Vs4kS~O(wcL<}#h%qZEwRsvFFZ`Sm-EUr
zVe;Mx_3erMapJ*Z^@9cFQT<ZviAn%e_Q}83O`qwwe+#K(9L_Y^;O)tE#U7GYd?v*y
zvS`eRbQ&IRm?^CW9+SQ#>gS(&TXMGCZW*4oKL~k|rtxb<ihjr+j@*bdaxY5_E`yQW
zHJhi)^1D&=2gwif6c2@cYcBoDYNAV?SS~LUXUIzuV6B}j4=_gV1$K*|o*b%a30WVd
zO*5T@E$bkUFkyu=dzkWuwDc<MgZ)XlQw((4<$owNMdH*fX*bN5X2fD@m1=q)nE^H*
z6W?Jo-vlTV2G;(w1ZV9%&T4v&y2NGGX9-&nlZ-k))dz<5Lmq&v2j0mcsP%_OdW`60
zACT48%RbQHMfSh3C5Y_*jUckWb<ZXf+TXgr{p3v?*v|0v7V(m0LH@NDF23O_CiHrE
zY)i}wyWXH?=TL526cxop{Fcq~w<=V$5T-VP4|$YZJAxABVkZ1riJ7QdGj8v1UNdi8
zQ*-XbmT40+SH3ISDIeIcvm}Wl%~{ke`k|1<S}V`cp|%!*^!=BWKi&6bN!51A#bss>
zWYSsWQLCRhF-{YnfV@j+xh8*dz!h;hA5{9CDeOq@FKwsskKOlc=__;<>sx3gp5(#Z
z!apf`rX`;`z>Dbl8CF6blA22mAJd~`fqF)|Oj!-Ytq@OkMhtH1+4`S`zKsxbExsgq
zq;@adlGeIJ?!=o`HXmY_GO@;6wwdq#{BLhP@G#c;Lm3h5ea;E=n#R~~(5OKJ_^hf9
z7&|<~FgBZ7_fCOI`Px3PX5?{YBsr7dRN)o6H=W8QlA35s+3=z*jc=;yR_8`P>uvaE
z(?|DuV5oA+J(8&hgDlr7(T(Y4{sPP~Vom(y^Z$4e=Y}(ws;ZWn)pb?QW9$Y5F~6hC
zgK2AG+m`I(K=XU7sqP1$rMkL%gNRX0X!<Da%s1Hg0>+y-c283qlbs|Q;C>r9)M*xu
z<Px4JxG^%>B*aPIoytFQuo1+6)$^uV&7lG)wI=ig-B`~?Mp@4`<|FAZ$MNM7y}Q3;
zo)`&N^@6-u@3`f8UJjt}-19Qn>93dpCaygLCJe}7hc?O*cv>#lo}Gstn)!-dzqM%d
z;;$CAlLlI{b9WEz2yLW67K@GkMjS2mVlByWUZ{r?O@;2ia1y~O1khDDf94!pM;Cs^
z{=^e3HBT085C7EO?@hGXPZw<s-_u<4g#UUyuU98$k1Xtqy*sEQ)GnZQgkF-)?b(m$
zR#Nu*v0ipp|Ky$795(VqX6rTCBnD*{R+F2#simAO*SS+d?G0xpXScUpI&5LlE7mFz
zs0@l3jG#@k^4}qXHnh>MZx>hW(ALH5wl#hS^jE)2hLaNv=dV*jPln%~5_&rPW>IK;
zc&BdWzRA?0XWSG{CHpgSYhP$2LiG}gAB=ZhiA~E&JViGw8o74Op6FzD#q%%;bcDpp
z3{;#{iFAndUTnpWq#|ngVFGUbtFoMMxWXpkRa8!U`-{#=ncI`MivWA0mkp;rN%rQY
z6Ng{{k&mdUmZkW`P+d5peq^#)n4;9yKee^uT}}|Q<cx8ZRZi{*1HtXeH!l^;v_mi1
z`op-{eaJj+9wJuzXBnBIdU81^E(*0TI$?VE`;|iSjgsYW(LP@pSY+mYa`vnC0i6`i
zkjvq4W%tA+X~v_=o7U<h`6*LpV|9Ps;{ZdPZV2OwOik82A}Xug&<T)QB29^L3%rK*
z=)RjUpZ<v*V~=eRyn@w@{7FW-#Da>-gaNiISs9?SCg+Xb<o5-qnVXZP<7|DDnQ^tY
zuNYh>=$UHkpJYu}3W+nvaq`x2n2aeW`QMQEpiF6V{$y||hdKRmITT!qzQ-(;TYw(k
zUSooJc#}(wX?S}Jcn*cPO_Y0h>;A4_>~0E#<q~sfpn2w?mIdT!AlUy{FcsZD1<N0M
z`<7C&j9IH6q)OqA!hJ->G6n0TpuJ_}9c#9>%&XW=PFsn^Kgj-5S@U6h9O-1Oq>wJ`
zP_DJQm^QI0W4>)5TGNQ|VFZ~vaFW#|$$jlNz<#2dC!k79!`uiLF-xr`@is_?n5h{H
zi#A)aT7Cw?wB9gPGV~Hu*0W?yUGHViNH%Vii!PTVSp{#Ajj0vR6H9KH_pbh>>cG_Q
zi4|AmJgk>n@!*q8(`zdp<Jh9_=toRe4)@0p&Ah3)b~h?U>J^h+Eg48c@d<&&ooD7F
zxhDvpP8}z#vzYl^TicwWE0#Y)D)#=TPfsrWk=p?0*6~lWlq>3k@d<+C^bWabWNqyL
zv;l-^57p9xgbJfqkf&uAP-fTXa-DBauAgzcvh5Lob)KG~oa5dDyO*?Z%O<o(;GF#l
zU+7(mpQ&Y-Spy54E~0`=LFP)k<J2iWJ%kx=N9gP40eVR3CGkR&B}m5u8wSD4uM%)-
z_Qsa-%;W+&G1`)CjUl#K%e3>a5=l%Rqjq85d9}#q?L{wJtBwaQ<=?9Q^IklEnD%7b
zwL|TN+Y<YhA1`aq$js)f(y}$vj?Ki@{|}DBGCvkiikjVYYX7->OZM<7?i9GQWol+>
zuvdKS5BAKo!R}Ql84ULG+W#_G70&KuG}=5ft7So!PL^HJRcFY_FTR(JGX&FuqzMD2
z1&+a>NT*OkXG`giiU%(qk*fal?$=vN$#-C_&ZDtZ`L^!gw5-Cs#8Ld8BtMcQ6`~+z
zf!bgSsA9iyo=GAh9yaceg&tqkm4+F14zzT}T+4RbID9-SYzzl>@jujh>@$_pM!3HR
zDs-x$!f(Dr83yKE^B035KgAW^Mlj*P1VL8o0gnscTmTS%=ZDBIZ~7lD(|?#u{<Vt%
zh`t^E??iq6#X8juVvRdVowi&Wmi14~cAW7UPYohHdTCg!wSx>WvGsE9$z(6#H_6TU
zp<f0*0P*vsEk7f%gL_QBjKpX2R(6;I259)|aI<0A#OYFn>P;R5qwF`t4TH-(X)rXK
zg&=@Ic6co{j-sxr!V!;G4<u6bVG5X?Gv(&dR^nO#{j$6%myNVyYk4-3(puXI)moZ`
z)GPNJTJM&UbXvb+3aDc!-L!!MQ@i2Rw3-da@FS?DrrU(A3x6leh)hw8TjR`?rz+?2
zdL6Yp788^2FCW@jB3=$^Yn$pP_aYQtzWXd)N(+LopL|QXLxWsUUt|e>PfyCCIo;Mj
z66wcWl1xfeHj_ye3r=#8XEWkz4u}anLiP$yXLrdqRrbj|iV$?NW$`$^?LLvkCQch&
zNyyc|h7<yR0aHhboR4J;lu&L?FV=uF(#7U?Fu=Gca|8*I1#qJkb1P3`87S+?7)tDw
z@+V0U5-VOHPbCBtw&LgUh{~9(^sMW4=v65mBQ<2b7oOC3BM<8kUX{^YY93Xj6LsVQ
z2v5`zEB<}T&G;6}acf%;b%Y^RJ5QJD@OW|1pmzO>8Nbz8gj9AvVXpIhwLD+v&Fqa;
zqJHfqP8PhE+2KA65`0<R3=P|IA5U9H4y*F0+F9YuC8`MDxW|45er9)7Cy$neFnM84
z<+Tn-B#O7c7(U7(<u99;Yx_n#?lU}6?TjRUH%%D?X*hrPe%>)QV|2>162}Q*YI3Gj
zWk=dUYL$~W)dcwnz3Tpwx@u2k4MJAy>UL!%gZz?MLqj=jON6M?c;jrCCM7Ir!Gd%o
z<ZUtYNp%scb%%&bRYa_&k9kHKS#d`n)cpHLd4#paKW=G_V&0Wg6A|t1IKc*8<^)}q
zr*&z@UH+-oi7m;`<ou~(KKJ6!PnKMYG&xsjyXXO+J>HC?+UdN&^iTr9QUnHDK9wq=
zuwix+2aw){<$I>m30f=_r!J(i4EGCQ<fV2?_CC7hc9nD^U0VscM<Lw@0b!_H?Og12
z|G>fBo53vI3tSSpMwCjl_GINa(H!SWeTidp4G(C%#Z}HfeyvoNIq;CzR}ig6`}+I&
zW~k@ziPBTRnF#;!*2_e7d<hpYaFnTZw$C^0_dSp)cyV4wD5RL^`wZ4q(+6z?0cy0H
zCa;^{8#<;U)actB@2wnOpqV76PIN`b6i`ga8Lc(dt7Y@*;Qe-Pb7-VYajbfwz3jC|
zHP`18_@IP?k763Cb+Qx{xrIB{yj5i%FuT~Q!X3>ud#jQ)c~uyxMQ)zgBlsxr_s&<Z
z<EgMc?f$y&4>8NGdD<jqv_tFd*-r`qgq+D4a&@5j_%-z}L_a?zJSO`2*zn0rlCknG
zwB9M6BNMZoU;Iq@GDOz5EXd@v)_$j>NrY4`{}=sX5g{kmbJ%PmMZ>ImC&BlMoPauF
zzXRAp-iP&rTdru%niP5=d~q?M+KY#Ub2<9Y;Yd3{DF2Ky`yHBm+iP;YE}$&X%?P|?
z&H5ns?>P1s$(f^Rxiq(^Cp>g~PfKx@{W-w#^#jpmeFfY&;2ZmGw?#e$LLGCO8$;{A
zzYxA(@7##+qHUT3DVj36=nqzG5}zrY#FXK&m>tJy{AJU+hD382a^!xr{N-4B1b@ru
zce}I#B0S$qD}ID5nzPpj%hMtTn7oklLxFk7_@2y;%*}SEoPYP8Cyt`{+eX%V+1jo6
z@2L$Ws~T9-{ns_?gDlMFaS^7u=7q^e5mpTVl94B2qhZOKCp!kQlHjo6C7?M4(I;73
z@@2U7V!JY7HidfC&bx!Z=-U$7HI^B|n{-dzP`i-qK7eS6kjcK5fmAwGoL8_$ht^Xc
zj5ddMaqvHh70G3{>ZvQlD5hzCZ5R1cxX;s2T5EvvU`;L?U}Fcs;^$PBhJBrE7u8ob
z?)DsLL+gWchRYbZaIy%N*a7J9Z)$2B-wFDFR6a!?I8Z-MABI`+JbBQg|0!@Jx_+|0
z9Wx-QTX&0-T>J1Tq3zb{S@JHlo&$ck#XFP#z7Wwnjjrj*+>R@}S_KxEy1qh-nknv;
zY4^3Qwel$zpSn7-*{-j4j^?0%2YVA}6Z~<3N0FC!OGuN(CtWOR5c4o(g&2)*7Pg77
zD{0@7T?kVO&)vWTm=uzO0UiV!*#3N7u$8>69;U6PKAv@@+NTdES*?HPp>2sQ-+U^=
zbvB-d9@r@Q;tFf^b<$htX(7H|jgLH?tlw>)=zhX#?dx~_f=IM}LqsCYoHiHPDm!ib
zPI}!7k=FLxMW0(uiz%8DT`qHS8q}8A^=HW8&92!z4wMAzDU%t+W^6sP1@n<VskjMU
zI&wm(FJAJgn2tHw{g@dxCG-*qta)ktc9~_FTfBK@haU6iQW{J3fD)N%Vs%^D_?R~r
z(<YmQ-D(cKFgeRgd{+k8Grl(&d0I?AmC|G6X}huA9)jT_+4v+3A_jy_Y~YfiCp*Bg
zAT%XL)8KD?8>Eu3xqCL4+rhJ-@oj#1@<;@Qr7^$8;|(%WWt{s24Htc3t^PUma-ZNI
zv~>{?M(b|_yfj_jYI?*J1p0i_JruYtPzR|@Y<LKLC!vHmet|Yz=g1M0%AaIb>U4Qo
zFkHVo8G-rE#v@A}cgMC2?;gTl+OFST6xnXY#Kyz!8f(k&qRz!5<vg#k9Yb|s6OHT;
z^FE`iaNgmJL%3h$i?P0FRp0s&+3Br3g52dOYKSE~JUs>0duP7)7eM^QFp}OQsxWmU
z>ua5ho=_C3H)V2_D&vWLwmw*K*|jAvo0i#W3S!H}%-OEPT%Rn{<M`v5xB{^LmzkVC
zj&P;tqM@?tvagY;@ehb<ca(R}X7QTOA~sJ%N=>`{+M4X)(_5wwFA8nH<;(yj)@r$m
zDQF3`_cu*^K)FGr9ob#pT;3;E(HH5yctqr3kdAQLl0Brr-ZH)W=e$aI0qezEC~>tg
z%&q>Rez|>XzPmv9>8<ex?3%~ivt<HqcUmuk+?~+e@YM5+KEpl9<F!Td@?!ac_+e#G
zPhnXZDxD5<V$I@kiu*2fK#3he#p>!R1|i0htrgB6y8c76;zEqwxMsKeD_Bz|KeNnz
zTDycNjvOvi>)$|gC<Mrf7i@%FEZheo5Q^?9S`kV%uCH@e)(h72+&hHn5gaE&g>`5T
z2t1x-RkrvmtMX9!&1%qxrY#ckGyaw#Sct=UOLlWs_sei!x|(v7@5bZZ-&iJWk)~q&
zPNpq7!T)Wsmi?W;w~}6)voy7AbV@-a=6;(38BERkD(6lU?nS)W0Q3$z5LS8!76{fL
z&KH<RVdl{mYt>dzC~m&}=aLnFl5%01$ac2E;H+kM=JvvU@T)UO2!e}w2RO4Ece|HB
zIB(9lh3sfJw=PJLZzMs8)5&*=$0bvB5-gFemA^L1xd*fyHeAj<CMsM9GxI19E+MBU
zF~*cZ*81J<4ye;sFN@ANhE3?38Rw=TyN9icNWS;6FS<(v9q6jt(v%rOE7Um+k7E;z
zsOB+eG{bjW;0aIXaDS)_?JeZ}fQ|7+Oa?XWY&`>kgv$-(X6C_rX5J@Cga@XNBl|7Z
zR^3_3s@seb!?fle&~A4);}CMr!N0xcrvOwdTPb#^cFk6iB!q9Bj<J@dr*?)c%Vy&)
z+6KpaV@hS`z>SqZ+q1h`!g+_qI{M4eUr7JpIe%^u#~9lf-@#KR^1AyZFVcj5!-;7E
zzu^de1j2sxQG)mTeY^{jU;ipdKD-|}q<B5WKBo-TjVLQac!KC1q4wx)Ls-2NOW|ev
z#mtYpt>)4%cyl2xzlp0T?3=wivIhZiG0%)&Gu{f8xS+MqliXm*r_~m*oK%i<KV*xT
z;t2ubY=Lcu?#@%B^wyQl)~fZqIT#^U`~k{6Qi}1my>K74+c8_F4bME4e+He+KUtIb
zCwoe4(_o?EG$2Uz>})(IHTJ{$0p&c%E4PI9*&dA%i2#&e!mQ%HDubAfac22A^7z(o
zg}*Xi1}B)5*GxMmlZA3?(d<_vA8@e4@tKInE_w8To1)D0TlikkB+KG_&euiIg{56Z
zI&z;e43RMmkueOBF$`f0TL!aMfbHdcj@(Y(D+^p*oxfaFR60qF)JPoGDpoAB0CJ_F
zWPIoUW9(f3vnr1N?*sw_jXqIPQBkAD3yM`*+Zu_Q3n3^(pClwf6tyk2l-kzn^C(_`
zz>@$chXD27R;%`B@7C68)!>bb`k<vP;-zV|l`85vhFa_exv0FK@9a6xlOX-~#Wv45
zyL)zLXJ=<;W@l#$S9WgjCa@Q%IFGDw1Os^~8C?E<kp|9`n=mo6wvZwQSHELB@!%<3
z46e7%SQ?4?;n_f9hT4Jq%Qtv+OZ@3eyq3jYLx<n8L=x|#+Jp7mEez+4a-;C-?m*P`
zTAsFGLD@QO)Pv@m<JH}-E|X^`W%wy|=Tob4XHylTrsJ2aSUyeJ-SdP_I%+o;cJ!)z
zfQqFLqd(x_F4y;#CEoPM<+^-MnFk^pp7!b<^195qqizY3dvG*9re596V$-+o%V+7w
z!OQ4>X=iu(5-rcfXgarq!#<-Sfa1}FW@rxf)iD-dnk(Ze`TY^3OBJX00|e)#w<)8V
zwc&B>>J{tpv4H1f>+Ti?vUT^mpZna;uk=H|AYbprF0P5?eC6H<E$ur_Npx)EJ5;O6
z!mAbDKE=&JER25_1FKt-Q>ZxiVpzI>D|yyt>jI|jE~m6->o!^K)3>0$+q(FzQas0<
zxBm|SlI;&_3P!Ypjc0|74k-x?=z>e>rV_qM<)8*FadV^Jax+dCK`UCAMbv=?Rb;X&
zLPg2oT|#R64NE|fUu{mT+}GIg6T}|s==rzU)o37UMG>RfzmL)Myj>vb12D;6&ZP2j
z)g_6}KS~)yQvA8Z@VeX8&I6QVYk<eaJB46@SqYe|s2%%|Fs_b>h22t{5PGXc4AbxB
zy19z!cg#5+pEnx3?*wz?Tl}Ivhpwo>5$p;PuL!n*#7+MEDZKg(cY7li`*rvFE%#P?
zr!Ddt?#7bnH{9-xzpV&3yvetf6t42?Hf6`(2G;nVtjV{PdeiTP!Qu<?D=MLuCI7Dt
zixbg5=y)z-v?A+^o*<j*lJvDq4xLGWB($Y$B=ISbsZ$EkwNj7-7M5cihHVJGvQRvN
z`MFj|J-58#f^zg_3K+u7@bXDwxZlv+E7W($c^L&qD4zf}{kpq(TzVyQ(c8(u3GIfT
zB8sF&__f+o--q!<0FH$H37It`#-;C0zZlI9CS`hM;a~lhhdibht1>c9<0#Ggx+NS1
z$;>8dcgFz;8R5$;-uMmu0ubC)X$J@xH7OguK)Rc;YbFwoQDZXr&S7?D$E#be%!~&1
zROn{uwLHNlvvohw&_uRV4ygJUa1xPSbC}m=f4-4VFDIp#a22cF!Dc^w@7R@{Tj%W;
zPNhl0UR2cGn^-!T=ZaB_(*GDYWl>Q&^x2<iSze`W3V88KtbZG6tzxfvcR(;gSC_`V
z?q2REN$z^|ck9-z`{0dL?+)soawF?hyFcZwB7&K3NF5}q+&U_rec~Hl>aOC>SLfFG
zC3lTo*+(>oAr))pe!ik)QTpHdOwBt36o!O1DpHGz)2}rVoTzcdZ)vgT)CXieT@u^~
zr8E4H|G4Sx>1DXXDs>4hfjahd;a*#eBp~n(Z!a+Hjnt_{ZVbC3Ma}#A3+$K#IQ@^x
zIdV7)`6MET&+usEAo~9QO%8ePuQ{q|!{lP^u4uVq4&e=#1bZFpX6WxED=_TTexofZ
zJvKvIgkC=JUhzgP(rHXg`<jg{n<bNdU6Y4Oet4KZzSk>yM0fNyywrVVp;n@z+hEfq
zQbaa!Gzyh(`N@PDFMY4q@)L_54jnfJ_YzomD#en)p&7b4s+|41?uJdO``UL6u^uex
z)zo;uVH5J~nc%I$IMduu!yoX})5Rp|;nlV76ygWfI4inKQs#opuKjpVZ;@N(EI0k>
zhO^x<{srSQrvq1_Q-=^}(Qhx|6_V-<A=0t0;uSXO{wAVP9myUML#&*4nZ5G<>ERPP
zkeAHDACuzF>_5Wv>iNd6;K0>JnoEN3<AM<0O)`?}xN7!XUS;yhNbn-Rj^}o+<*{dp
zz5)nC?l$E6a28)-1_#O6qDROm0MX%%rtcW59%?lNe#`Ccm4oQZRtH%Arq^&2DU4a?
zLbX5rJ}CZk{<o7f;?K8bdh&v8+8?`F4UJe}Q4jm}^=r0d-ZhK!4Ww6BG~735GZ)P>
zEWbWP)x5+7o)v4kTaR3q{<C9@o|gR-7()d<BMMGyC1p`Zry(o*=ZsV{IF8`N=QrHE
z;!qZ|#-7LNadYr@H;KYtV~F>0L*eH&Aj=KRc7a)O(SmJwn9<wafvkY5{E>7Aq+5RW
z5s)p*$0^R|V}_xZ$ly*JI#B2UUHX4YpMD===6&I9Rt9<=2g)0Pmd(8H==phO2Nr;C
zo*jn`t3ao!nRO!BL+PiBRNNWxRnqOJ-=6droB+(pAl*6)-nb6pu|R;Y8Shv3AmRbt
z^XZ=GYCL4Rdk4jC$B^zih{Ws=UO{*bzk$jUce(S8Y^*oj$D#_ib1pfz=hq2nl@^o1
zL-VX7TCW(Fe@KXbNwUKDi01yyKtzH<_%f=9zMFn~b8z47(H2k;z9$W(E@1k#!_*U<
z9dulCIkzT-SCXR1QVdqjW_9z5=cqr~2nanF!8e2HjDcWi*b=^J_*6HRp3an|rWIeg
z?6S++{JNij&U-(2_XV7;?p?L*NDqEgckk%c?Bm>5xWT*S1_@tUuS6avnQQE-je`a+
z5Y6!AeMwGy*WH}-YdB2vO6KWP!+WBUYq$NoB`nzC=aIUZ=11E!Kb=SlZkn6fwwbjr
zVC}oTDLCu<gNReMCTQJXV2@DWURU4fTyxI}e7xd|5&m8}&N>#ZB-^p1Vui8%GOtxl
zqk9!G^7cZucsJka@M%6j+JW^}2e<EMh-?l%`19TZ#3K&*^xG31b$o2&*Ka(%>9>a`
zlOC<Q;g$i^Ctl_V@ZZhD;2n|@35hc9*T(N6jT*US{kZQ)Ur%)WRkpjjCF6djWjfJO
z#A{|waJUQSK{+@uGWPoRGZ^o7iZn`7YVFzfOS--`>biH7bsaHH_>s(QKtptA&k@BS
z@AYcTCze+<BKus0h8*sK0Bt|g36SAa8V@5D8@i&qlK$koiW+-9giBCEaI9-1tX6kj
zI3?l@a3O{&hM+4@J=N00^6-6Wfli$Ljy(#jj-@>Aj?3`cJtdwEdC8MRo+-B{gK>8Z
zD!71<fioK!?&hH6=7?5OpD`K?=x&z(!~6aM%NX6u;8n$=Z56!X1~t5fY!2gJVAVWx
zQ;y^oK?Ekkx~f2OL3kr&?VLozlExtXy;E;LN20pWvc4&(tF<tB&UI{IT!UN2QhVtN
zkVHoV$&_yn*6weG#WS9RzoG=(Wc)Rw2{bMx{yLhc-Pw<XehJGFe<gs<dJV;j!!`Z-
zvmX@n`$7ex8n?hv)%!eiQb+&wT+yFYE<VyoC0tJdCzga?g{v^4M^X&)9sWq%8o{8d
z1G=s^@{aAP>R-*lQ8gX~=;8n38-fF#&~P)8dWo;t6~-3282z4y`ZK|Qz@5U!*&^;)
zOLI*|;jSCOy+=664>HI%d+!Ssmy}c9yv21Q{ekL!V=@E8`Pzc&_&iTG4AuKZ!@vYw
z7f-;=47bg=&es^;93s{wgCBf5hlo|mitsrA5&K3^?V^A?zvsR07Kx|Tm4IZMv5dnV
z{So-e;jT9mwTyuiIN}OskmGAJ#MdqZE_Lz4XyO%Un6wSCzGpIXGTFLfMpWX&sIG5=
znW)4GuEdw35;LO`*HdEL1CA9n^y|`QH5hY~aZ%wh6hP_*@^xfm2eJm4lS_g}M>*(!
zgfwJm>A6ourmtI}7O|}^3H}omSw@lQVB<jh%9!~6wsdhW(xoOKR~~Ctz%=hEzOk{O
zVxipauihuOvwVZbb?$g%>&|~#X$_!=b#G-XR24qHwjU=thO3$_!K9I(nCs;@d(p5N
zyNEw^l)T=^+3!8;2C<-@6w^dnm!7V=4rb;OFuFB(QXjXT=1-U@M&7axDR^IhLJ4I$
zkD+?Whj!6NS79Zl4Cx5Ex;)_5!tC}eX3e!LESlSb1t7LHShuhK9+W`3*%Ew{AOBYM
zH}mw!am1BDR#?xO{w=}F`;a5&s?;#+ZF+Lfrers1_)|;ZwWI&+SB)xsUN<-|6dt(i
zTA=+0q-UO21LqwK73$d9uk}`?w=KL0=$cZ0S_y=QVQsB+yqZy79pe8wbUgV5zC@(h
z<<A@Ai(Ah5uk_vwy#Tbj7F<ZToKFROTgyRQ+zmUC<AqTL2a^8sJATI{F@8L4VBr0_
z7LWPv3702>)n6FQiYbl$C>YvWzizEJVTN53NU#VF2mef8SmgJ7-1q+;D(rFK(|(lC
zufJ4#w`ehk{g)e~e?oR^Fdv-Lp+5`tHYk^9NUmoUX3zA`K}`u!L%&Xe9ty;rB;FAQ
zh_b3`k6#0>$~!l{fw{(n&yHuo6y(<$$lyfxa^yBzJ+koa(GA+yO!OBTs0`u{`N}9D
z(ShT_E=Thw#qW9a<Z@iM$!mEjJd@%wr9Fr#?V9^nG*D5`L;VPG`=KJiTDsF3bn}-k
zz0FU5Ld3`fuZW3p;@;4W7K3QzZwe-``$A9bK58x1h~heq>gKLLXZ`4HkVbRx%>`;>
zG?gQ~g`a{xa&dQxTn*61GMq5Aig4f5DMmoy<T&AM35@x;{ozSM1i^o08)@@f;~+?c
zkU^Mn=Lur}A*APG7m{A;-tR;O*qpv)*3{TM_$yM~`2$%f9ldJ%tw#eEUvPGd#^Ks>
zrR$Waw&{xbt`WZ899;aELG0gTHm42g>&&QHiZ8|JwPu5ycWB=wnd?s|oO`e>K}UcC
zihw#_cW4!)-pmC>9p$Y(sm5IgJ1}<L&uP_rq2jvo)Mfsar3P<jE2xY~5Owb>u3GBs
z`&s+k!c!8RXZ9=5HK9<~P083n=25B3D~}?|-P}PZCpvWc%mDi`BDx0j(|lKPWoh~r
zueWC-G-J~|ct^@f#+YQkdSiaj9AvRC>uZG{2b|kKXT7wuzO-{;dTIOI!L{kd?Q@I9
zrx&!(9a5dJBWmq)hfYa!euFC8=ME!HCwtoG7GId?oW_&EHK*3W^<5ic{Hdw_+LNi?
z1~ZJ}FEs~gcFhHWj@r=J$?mFOtK!{>mX)_YgbjP3mr<gZmXWA}cob|%6?439gti52
z&lyxlw*fA9=W8&IAtB9vgNWLhZTnpF=UwHU#lLRSdXU*R90Q)j_-#1z+{S}{;RvMo
zN33XJ`gOmyO#He|TU0-g!#?-b@Qtlzh`n=4+wie#4W4!jsF!_`waCo9*MJi~^Q)3#
zsM^GLQM#$8gpMYIu}LT2sLrIf=mgQc%2!h2e7}AqKLc%;+CN2}t>N0e&m#4C^&=^N
z@snk$dSYc`aK$ZFp_<zP%4{d|!<TI4vv1Tgg7^Ywif3*M4wCjI(fBp54Oh)zD+9xD
zu&!X0pF)oHqAfUr6~$AK_Lz8uCA$ca07ZBS>hMW$$R-Fr>(`BFUsq<8jIg->mOzyw
zLK=e=VV}gcq4EdT5_<wbU68rH2&30m)$?m+vYRr@Kc8(3E^fMQ1ZkP)i#>Z#$FD15
zd_JXA#in>hsvfhFEA+MnQ-^|Sg?Z6U%*^|LP_rBuG=u#5(}a(^c;s+ShmPQ}z1G4H
zA3lX?FI!*23+1L5>45Y>90h6F=rzL@MrLb9Dpyrx1ZB&}Y}F{Gc!T1g_Eij2`k%rk
z9Sm;x=Et(r@$~7ttf%w}%|}B_)q7=am{oyw<4NMh(T#ADxOYAGSW*@H_@bN^1!wXH
zC4=wYiYr&$NQybVsqX<g&?*qN1s_YGK7`^N-a94zPQGVvDMPM0)=c(4v_~^q&GB4r
z3$`8z8BE_4j{=CS+oZ5g=@bwC6_~5jb$u6VJ~hsQqnB_<;6;u+aj^+5=%jGHOdN9l
zF-vEhIlZ_UkRD?&=;;~$=djt1j7dKI2(|DTCT>dhy@d6}ZyMpr29wTY7l~EL&=~$l
zh-iqaYA@vl^$-=Y?^oK{zgpsV-N;CP^u!k8^<$LxBGik&V7s;@yg%p&>ByV|qjs<C
z7-?czfu^`TkJx~$D|S`Mpp<qtmFD1G)Wc~PK&tN}Og^S-BSD?pin@=vEi192#(1-f
z{Dqpcbk@!1FHDZ+^G0XY@+`Y;*5H{Pw;)yq-!>hz#9Jtde%6qgi%IpruPWe&ah~i7
zv&v^KSKd<PH3k=u=Pi_`2wee-zkDLkog3z!GWJ#Y+eT;o>n_rn_5z}T_>)VE{1Jl?
z6V8^r+Oo0YyZT@rNZ;t=N)>RXVko)$$u34xO{q7b)L$@@GTuV{^%s=dv;O)uCJ(+z
z&;4YHH-VtB2-X_JXeW=8)K#!jR2|(p^aRmPgf7mdxQ#kevsE_3vQ?!5Fqv$!lApo7
z{*tLYA{sZh1~U$Dz}WfU?1Y&rTIHWR(_5(V^cNUEU<#Nwut>#Qs3a7|&N6{{o!w-0
zpdJaK%FJ1CInUlg{dGGv-olIQSyG+1P=8y4xoByU=#sjn#xW1)nwIFiONCpD{RyXy
zt0_tCXDoyJIJN{`Xn4xFxCFB4Tq)=#OmT(<-3ZKLbcEW!4lZ@d_n5l$&~8)W7D2_-
zPr|e|`U@Xb^<DbQhTXyrem#2wZ{`uND%j8)nl&P#k%Fwj@16v`{<Q`-JdIyXdK2J7
z(FuLku&FWloI9kXb+Ff*wKHpr9m4D`#>aF3I-iN}=h#=JdRK|@)Rg$MX}g&41E;6p
z@*6X&FJ~t>_Q!<Yk~8V#af}=5<dF&=42iIBG;xercV?bgx-en#Mz(&00QKjMB<}BO
z;jN~G+rk`4gnwWP+rDk6=!@QjqEIe`-ukv7?Nrc~>|UtfBwp`@#=vx%SFFzQ_?QoF
z3AP>yyE~6ea0U+gqpdZ#U=1jOzd0jGH_#YzH(A5UU@vrD@(dO-W*&JjcGp|DD}qEM
zbh>uBxRs3q`PrI_s;I)NNhX84&cSGCH8U}CYVj7b3&Kstt3C<MZwc!aZB=szNv{8m
z0)E<zCPHP@y~g_f*x-Vr*0}lZO`Q?`hU}QTZwZE}yO+Q!^YIAB;OJA=>k;mDPRR*#
zkCyJXiaDF(fDiF9e@;mOTrRQf$C}LuPh38nW2Y?Vd$)|>7C-Svcl0jHBRwAb+>_#h
zZAcJ^QNgT8(lLvyY-V0<k(eUq36OA%b7YKjEYbw^GWzS+&-7|%a<PzCd#PVP-m4w&
z*H83nC;Ii1z1qosebTF?-)xO;6z)Lz!Myo<dxN1v{Fg`=iqC`BT!c6|?QmPw+&KN+
z-Cl!)CWg~z{o>@9lat0|tKC>tkMV0x^{P*moK?-Zy;IM)HT3$`6OAaiH%ju@--t0U
zNrPdpnV4s58jiQQ3R&sqkg!E0iK|@0YmLFzzr%7r&DQr4mW=Q3%P2PVdXtK|CaT{J
zTh1HVCxj)_zlzXby3l!<j&O0;dZGiXIXKrU;$_6{^0IGp@ajLQves0PSiWhcxa6BD
z*4@_#$tV`3E9gzG=?&gti2SRF1)1o)L)fqFFWV4OV}zeE{&So0pVglIBBC>Y5Aku5
zxJ}x4;c9j$PpU4#4SkW`{fxMj_>;E27#~Ju2o%a7)yjp(tDorCPWI|2`?X20KAEkZ
zsIkn}PIf;@{WJ&bo-#kcY|R);t~pgd-iY!b;~R?eqPx@Yo{U+QyWN}klQ|qlP9r}9
znyx{M>$Y^&6fUlNzpIAle|FUj=G+SbUeNoBlEK!m$C7d9A^~regzZeKY`bVx|FTuK
z=wz!d1+4|ycG0c=g<q0P5_Ok7^}Xrqf9c#mo)o8f%>>D8mFr=Z>tRuOa1V#s1_;xV
zul$CQNPY0$FN*=-*xLvP9|@E63c+t;`9LWXZ>SnuOhb#f@?QbD3_uJDh&Gh-w!MT%
zqzK~Oi;SsuXB=-mx54q&6Uh{BP0fq>YH#p;Ob_9A=sy`}CpxFv)1cWL#<!=zU*{ye
zJr!M^=sbg`t|ns0mZgT7htM@5i{@Z^+GKUR$aXms_^aYxx`ht~r8)2sfphd7{+;AJ
z9UrOY4^;#5DETvaeZScKzE1Bg7tcO#pL8Y~94iMzw8w2b#fSn?YjE3qgGhHtrd~rZ
zg%Q5&S53r}=GU9J^G6X$+o_oyLy6?5XY<7F+zZOc?BJl;EX_Q(hF@G%@h><pcjVex
z`44)JT9etq3ivg)Fs<x9dcf6a3R04(=iZiC1&>XIvVtRv4UVX$hTf{tYl+3fJgPqd
z$PRTkte<g1WY>mS*PF*2e|HiTLPv6`c<csmyQ&Pnz^pfZ2C885l1{$NFG2_XEA#75
zoyghL#KN;2JWWA0^cZ1{&-_a!a$VD~Z2d%$Kgx(0>UY%7p?X><Ea;B(M91}dJkQ+C
z?D1A}%V6_vDHOzJ;Q7Ukd0WqQqyc2t)Ir#bE{*~0_>z*JETAS(^$xALz)MRv(6)}G
zWp>O?bPOUrvtue3xlpcq`rFBwNlBV}!Dm<6#-9W2VCsrME74;P9-@2gYHMruua2X>
z{hb8=62-0UctelYGuuj^EemzW@07UEx&xboQ#qqX?{yjh_`5%WEz&<~PW_+q=DY;(
z8`LC()9@0(P5fJpqpr2!CiZL>MK7*<``Nm8B23C1(pMlu!o2G7Nox=LxXvqf*S+05
zt1#)GN0inLYDkl6t4Zbir*01y>w^il*>jX0FFs9uu{{>uw3g`D1g0`iKEz+5F}%SK
zbhNjB-U)D+r7vh@U-%M<e%lzv1jcS}V>cv4LBUbXwupXo+opd>iC<qDsmJJ6+4@oj
z2eL|kKHSWM<IjzaO>Mzf@UxgY4fLFr3@+rETE<P^nCN(hVz_4u#ua+39ht2)aWGpu
zl6Q6uUgIWCsRNvk#$L>K(i~E&br_p734^(Q>iahElcItD;gdG-p~5UUo_sdAs(8QO
z^jig`i_kmfYkufhXt|px17~3HgCgs$BLed;apW!k5>CAfXyG_~RPXiU0f@;l9_%5B
z7wgBKilV3R+Z5xLUl&{`_%aGMDE8A^xNmo%^(_1*C7PSno#tQ&k+A6Pv*U-nUEm)i
zT4+==O-2?I^tjZ>0`=x}-rAtO97!Cn?DNM<_0bJC|F0oE4;3~V()V{z^b$n&^w@A5
za(*Pwn>xm@-Rm?4Z*|2bxPrVz-~0<@UF$%FWYZ`bq_bE{;z4@F2I(mqq@K*q!xEiI
zk(Q&w`+<@ECxh2I?Td)dgtrRzTP5R=TSLet&t4#bM*sZN_<vPnQ?vI^f8XF3cDQv0
zW{qze;6$eghU@8u5IcPf@xEQ%;X&$}l_ICgZ#%)2Rd_eToNozw|6y3zy{b-C70s1S
z#UIu%l<|wLsW8!bkZ?QAl)SxpyewODMqxq7xjK+vBIG}!X1NfQyT+M$jdY$52PZlt
zVZ`-z=n@LZM#R!L*kd~j<Hm&3xJq7nVdF@=jj@2d<DE~)(UD~H@)vk7>UH=vs=sWx
z`dVMy^Gz)tI*_d`oQZ?1KjAr)NY2_da|xMFKS>5-K7(l6R>B}TV1C9o7}Y9XNbQxm
zR?yv}N|I0l6m?o-Fvd;S@C31w+`s^w8yM93OHOO{FR5y7YP4ZlBF6zMcdkaqeL>)-
zPMyJts2>o&i~~qGcN=BD9}RY`#>HN2u^RtgTo0h0>+0!y*sCcH&x7E+>f*3Xzw4tZ
z2kz>&aIZ6v*O#FxY{9+;-)C*(bL@1?&cAwXdZL_$<7Bo&`v}fX4kl{`&AV<yJbml7
zfP;c?FN);tN3tiUW%)hXHyPZ;Aj{ab6{*oK2HDZ**h8~;7>UkH_O2^UA35O0S?tNX
ztJc?}N2mVGD2{!u85N7qg3(MVO(IDjEB#U?5Y|Qo$(Fr~l1{TZfKYlW<uscqTF9Gq
zhXOiGq}K4c6c^KI4jjj@Hy85(Ykk6sjq&no&%~%~GWhWNJt{fUWeTxYr~<I3a9_G(
zRLNaS`l&c=!DEFCT&=Z4K^?U9>WdM2u?~^!)s)47x)YspTyu6=(|IC!{Uc_?f05U<
zk-0_k`h+j$<n@npm6)njrPtab`LeyhqgP+#*Urov5WV`De(emeeui&)r)N5-8_+8M
z{F&Y&QKMg5>eWkr=~xXce(e=r{S|&~%BxQ~b7gi>hlZGc+4>voXHmO;_?NAptsl_o
zY<^!q-P!yyCs32K;Wy<Bes`au%o1<W>14(RKQjO)gN`__QhAZVFUp%qp0}t<uw~4O
zwaBbknTxCq{q-}K+Oz)pnUVHvf4OD!XPX$HNZ+2})y`l97}cC{{0+dD^0<j#>8<qx
zmB($t&!odj{7YZ$UowUDV$g$y;zDS8!}8|q>>|OTf7wNXLjT%=_a68!+T9Q57;S~?
z;Sx~#WwQ2}#XhGEFFl+|8omh|!WOkP)g9?VC_+eSseO0TgI<mGpfAEDvh`P}`D}ek
zKNi#48HxVHYpl#{3tnLFBOFe7r_3m@5VzZ*%-m;BQf3r0i+kcwW^U&xQf5lsaR=wt
z-cCB$XbX<v0PoakHdp=H5y{{fjwM91=OW6;GX+DEI$3pUG8mG}?L3Rzo}0zbzYcgH
z<EPl^jsHp?^yU?XCsKm$d*>I23IV}}ds{H$F)$mCWT==Rv6{3k*v5u!cq-`AFrlF)
zU`lPl7ZEX-m!H%_54pjO#dx<yTj9?-c_ciQG$+{Q<2Q02#|XG1lu(>m%YH5wW1z4x
zDDMX!KM$q$5<d=r<J%$+V#9Q|!|AdH%Et<`PSqHGO1Z1}A;OgT&C!;ywg(k_KDLY;
z%LnqI>lmyr<C>$RHQPa3VyS$~;Rx)EN;NfyEV}P_=c2TYg;zVmT0M{<5Doc$BvaXi
zy}2FZ;~@z?%^O{^wayY?EQDsT$B1p{Uvn_&Z<J<rjrW^F2?S<OaQ5TR0kP)SVR4@i
z@T=H@GJfGtiZ5SiF2SK6mFa#Fz5H^(VxzV@oMi%MB&D29O1Oqx#+n5{s4fwz4O`(R
zGQ>!?nc-u*89sJk_-I^Qx3jx$n;AYnx+r3#>1(2|e#lpj?6n)j6`PQ~ns8*_qdJ`q
zzqgTnV$ob020h%5da>*I^;60c9k`<lY3T1$EY)1CwVw(J#-kcy9CJ$kj~;~<CmA0i
z?#0n0$J4SmIAbq5DJ@EKHou3}8yuw!0c6_$kvxPc@Dd5GdHR&CdS!a(*p<`QT(+FZ
z2&{nr%GMQYxW+y=cEj{=>SKHIH%N0Lox_#oS?wn1xKsNX$D~emrdb&Yeju`lcN|#e
zVETy;EneQRyy<*7xUXzVbja&Kx1pX%e&vL84;Vft{UF$#sw+*oaQ?^KdpJIQPwWsg
z)HCN3ENpwY@laR7COWbrBqY-B^DCRmz{}*H76YlKRfMgXgckwtkBLNDgB?w7Kt2!r
z+;4N;ATFEK4lKYl5}L!Fidqt#NNA+#qEW06JPmD1bjtOJi$?iEt^w`W6_3Z0pC|v?
z$Xh0p9iCY^+~bw&Qk-+on&I?9x2Hr`rG7(jGXb<d<nAPY=5f<^K;bf}P=c1#8)zRl
zXA@_n68{6<hD7Jp*7{&>VZYp-iY6yIzi3Z_m#{m67bs=&2VS5Y&l7O?x2~mH?#s-q
z?ssLTB_e7I&<M&OQcO_Z#Ba_`=ExYzdGiFJ2E8>nG=gv#EkIwbQ+hUmd(i$qo9v;v
zZZ^-{LD9zGb(plR0dtRw{e(g}yHHtcaP*Ntc%IDx9ia+M(@;i_rZgUJEYelVNbrTV
z9p3CFS!?k25ftg?SX0A@83My^#YNWaR^(c0VLrzDqm`0xuPR4h(b>o0P_XR_E$1Z0
zQR(-&&Y?Qp$9=|A(r?*)#;<dq@#OTMxX<{U^o!hQ+?@Vh`|RQ=>1=dq=lh}pyQ!2K
z^~?_9gfe?5BSj~~AmQgRHHn1h@cT&;E`2a2;ojhf+l_?r4@koKxP*De*+#{L<IuD_
zjtW3xb8tA>ZapwOCpwR0khI{Oi|mgRkJr%a#LQ(!LSNwy{y3J}UjqFDsXErU+ljT$
z#*I9B{;pk@pqox@Yz{UrjNn)Y97}Z@i92s81@OyztX=lAJ=FepW~X&w8nsXDuG>5f
zGr%{r1UpqAvGgiF%*<J*fLwK(Suuv;>i&y2P;#R6kATfgoqnB-1Zv&2EEoE-QpbOy
zPhQ-oO{i6TDk3|#w4wp=`CqEc9G`8^H(nb%rzyRvOlUt}kAy{L0~2@Pb^NYv<KgM1
z#+b*K`5Db;piSXZMuZ!-5Gpgf2B$us*)=HjX(y+us-0F9Cs&_tYs8x%y(uRx{Y^P>
zEuYGN@sY6G5Pjj2iAR<HPQhFpqIUC=d8}LzVNhGor2M2XvRbL^dDpQ|)Z1Qx|L3Wc
z&#mWgAX@oWMYN&EzU2YC$ukzn8HvFulFh**l@XDwRaZv~uz1Wm=17=xtGZe5oO=2U
zvlD7a29J-i!-C;MB(S_Uz>D1ohofD}IHkDnf269K%fqvn{gge*l?_jEulw`bhaXrl
zoQH6_OZ;e<tIzry!f1B&?9jBM$C4(V97MJe+io}%l#z;asDscD3G=|S^C_sd;+52)
zJ>?H6%HcHXN_xHWJq{XJH=r>i^!FV%43|^fH|0gx5!;FbSw7AAjv@Aea<Fq3G|l2{
zkSSB#2YR$qpD?c4;ew}gIrWyq5U%&<yo5DieX`B>ZM_Lby^$j<U8aOzQdLpKutfL6
z^tijhLSC*V;&D3Ptj-hQ<&yMok`C7tyn9sC>_*q@+FY~iEe8`Nw~JVC%I>1}?xIEB
z#A5C3YoGA`8EPH#O#oD{<vzTP5B-BVB?D>*M%+E(Hm|0%aIHV-QVc=TLrZ8GSEG^O
z(;rsl4YQk)v2{31%-SpX?E6llHN6jHb&5>Q{XE!lr!6|RqjK5uo=<Cd$GhP@pV0{S
zla(kw0&?bW;&pgw3vG(9Y|T-aSiDz(n(h*!IG%66;AA&Ihl)gGgL;uXteqrhtJvXu
z*mFfcPW~zvoriybQt?Q<BTf&VA=Q}%JAX`Gct3y4KcFYs58k`<?M-AwZdc(ym;)f0
zVD?4N$n7fGKhRIA(neQ1CPl!e;}$J1ap7cRlcP4`|FE;*PK0~1+fgWrXit|M@}9WE
zA@6$8=$xmqra?)fgT~;EBTaN>Q;6_lv|SJ`1G4^ua`!)?K@sU`P|7LL_anp8romL`
zwrvf;A7KjvBWrUQdGMdY2z)-#IUnSP3gajA_nQEh0>N1A0$_bN(?2!Ox_sAx9WKJN
z<_w;jyS%LPV#-z(Ndh#Fac^s0K92XtWVFW|UmOj3LFLi7zQd~syK}svw*7}^wJ;+W
zVP7pAO`V!(4~nbusZ*2orYf1HI1Yb?`)n+?<m`HcL#mi?w6xvy;77Z<T3(I9<3CFj
zhZ%gM&a|wX|FJ@DCzd6svU`HX+uk?xu>$UXOu*eSq*kQY5o?Z_nd8d`sVtWz*S(Zj
zda^PsWYl{Css)E{i=Z#X6Bb1<wrxtUDI*SS8BVxR9#Og0dptFjcJ0-^9ob|ob#$=b
z-FLW+*J<K}@isfEXL_jIfakp#ul8xTZyznW0o9waijMy5*G59-8_;<);}N?t6Q=DG
zny_|XIMjgEy*c<6A6nR`2pvn`7qu^x*IpE0YpY8rBf;Hw{FY0g$eHfG<CjRF|IZek
zk;ha$J%cCWsYm#?g2i=j5^3wOP<}7SgOFTzvJelht}1rR$x2;A%<1+yZyuXU@b|d%
zU-imW0I8R$K(VNMgWg+3WGo2S`4n(FC6tX_*;V&u&*ioPw22yegMz;sFIQ!pUnLFG
zr`DDHq_gh}5}nu5M^*5uVvgx773$!zu9B0SGD8PASe!d5nb)}Fc~Q4s5o1@~ic;BJ
z?(R}{<K9^;d<+Z&{2`N)ts>ZjPD-#(hfmY`f$@3z)O6i?cRO$0YZbNSiOvk4h4)Y$
z9eYF;8tp9_sazoARZJ>fdxbJ2QRqe$GNJylUg~29;Uj$k6(u_1Ytne9x-L%K37gwU
z65}EFss4fdmOTI;ptkYU7Sn#`onjF0@PX|IGzYgm^wF-1FL4K)W(|VzA*c?%Pn3Y+
zzYJfr4XF!w77+}}V~%-#ba<H942OW4gVkKvIyJnRTD@LiD+ji*uLk#_)Z{<WIKSHO
zh;*9Lq)~BxXu?ZLR7e=k4^ZV;#T&FE0mk2B{o|A8hy07ny+8TQsNDnfk?Tw!L2E@H
zxo+@z=p)w^O-a8lO%;9Qx}j6hN3I)oLHc+8LX-1WrjPK}``4Ec*Ye*G62ADgxvTY-
zZb$s>r@I!T7)p0-ER%W|Yv5ci8Eb`ODUVjzk#Rh&HTZ?|XBQ*9fHc&!IBo;C;pw8p
zPdNd*HF)sTphm13zZi~ykPNZay)^5LWH9?8TPK)6hg(uXPr+~GF}dP*;9MIz*D$tx
z3uaq`arqXXQ;Tf8n$IJ_L(BqU%eFg&VjO%Ih2Y*DAMk7D^FmGneeQw?7;}qKd=48m
zB$Ud%+^WWOW+$Jmj7Zd1gn6joB2nm;;78j4NLJ1#{xp<G6{2Uc?%YY321f^+N2!78
zV#QR#VMmF0vq<Enp4aH5O>6b>Cf7$>@=_D&mH;prU-sSOeFfddOJVv;+OgMOr|xNE
zH+Td4*ELuh;n)t<)Q~4W^HhsYargF5mb<<?-2GbrWZN6kIu3~W^w5O#en`C!N)l4<
z6}!fXh%Ncn;BV|m*$5j_@9&4yces64Ifm350Mn3a9$67WTRw;odU@|q6^+dU(%O#x
zq-uPJFjwuyq6-5I(6$CgRS&@Rd6A|e^o@zPi_=H@@<-?7)STA{9w61tM50-Pn*6z3
zkOxxBobN`57E$*3gxO*Ag`>7JY1N;7dRx#oH6mEDRBA4pSc#6mi5$<z$urUMRX#w#
z#X+S2ir!*WJqQ%N_ctM;ETWij9f+=YF|}V$$;0$VdIE&70*k5j=Y?N7*(;<}&reuL
z;vU~liSXOTsLZg^6fFE%EVeHDGU@jD0yq_z45wH@6l&Vv7k^$GqF!z5r%sHWE7D~S
zEr)Ql8kGU31!JCtZ84=`v@lG_>o>+k)#=<<)|SJ>aIzvyT&u_WF+$xRgcOtzP|#~<
zD`ypQ4)JZmq8c7v)65CwPSJB}zcGC{pod41YG4A~2%tTLdYYQr{ELg4W8z0R+(oI1
ztBVqyg`kPi1oqb8*0&tNtqxx!o4(t<-lbdP-c#FjtGX>m7!3{s6Z|>oy=uoWP?U4k
zVbC0~2Ma9ee`$FXPH}^F3z|ecs#}qj<HGOqY@;zAD_M>abQOdTOD}j+gF4>Tu!i{`
z9!RPcfB6^4KBtuj4QCn1FjY`$GPFXD_B_{*8oKx}%D2#rd~cK*ypN$wgY8C6UYSV3
zRp#*-UJQeR)}GX6<$2}dHnw`PbdBd^8NHLW3!}F^4W5EOqdgUoW)Zh-UEt=Il|!N>
zLZ=pops^uP+Cv#qrdhbsBdjwzZ`aSVCyUo@K=a9I{a8N|co1J^`}*870TonSIfhye
zqC;{+z#F5V3&;Y!HCa&eYk1@{$PM+<&Ag<|Z1jZOyqf|JbN<?!y_)jyB~r{03~hrU
z%Ma}1s3D=uP*M3Dc5m9ZKXw&BGLKzRfb*OABZ!SjEYbO#-o$^n0#lC-a0puEb~2IN
ztRZ<~3%^f3ZPAUMR$=8r8qhLP@;7TXrnN4LiBM<WMxnOg_oWV~`Z3`gVBmD(V$xfK
ztxFv%`HklP9%_9UX-m99E+1`ek+pU#_7tIe<=o?Ab{tLwz5Uv|INzS81y#2Odm)wg
zH`gA>CkS$ReJi@ZJ~jcRo276?e!r$a%soRgPrb=Uel6=>`VhbN1bmiKmrb0zuS!d}
zs7%#Tty8yPGH7mWyvcuZv;eRwwg2^`b|8*QjjudA{UGo)2ZzoEP%gLsq1A8p-4#&$
zg#-@n4gN9~Ka`(axk1<=Y27f8z8wJi7O;g>S(iHJn!_tkPJOzP`EW6Ex)uISXqAQy
zBvhW4=;SgBm+^Ru%OG~4OE^ivIY70xu-J^MoSZsDAB>3e`^>MWG(<mkADlSTeE=aM
z-^TJ{3EnzYW}GOfyfAfK<yp3xo+&cy4Tf!DIMvssKeZu@t=XjI@zoq$;c}&g=^$q1
z^wc*ZkvjEDiu%`;<Bwdy?8Dxy{R91OriXoren&tLgY!`XU1HV~oF?^V#k1*Oa=bJB
zGxYh%TG+(8f~&AqxS{JRsN|O9bL0NK`x96lHGh$oD4>e42o!{)DG>K}{^k$Wvs>8j
z!#A+p>%=$B+>v(T?Mu7<l_dnpD=3xHd?QH;l4oTwX$60JftGL47uim%Gg7TN@^T-4
zs}k;3nQmqJ7qFS1I>3KIFPW#b6^fJGch$h1md~!D;*A%i&oI?@zrIgPU$lxd*Ks8F
z7~#ySY7B<Ro?{TGKT!npg47HCe&Sw#6a=nP+a^U1)Rr)-k~GI;aPU`b`4XRaRYCEr
zBGqD!234iWpye_wX4W(jY-vHkaZCMcOGd9L+(}@jueo0Mc5n=RHnU^D#3K9_cI_&^
z<?=_7VsbUcJ3i?$L2t>);I<*4!+N5+?FybQllxy86$75ltfLe9=NnRE5|e-S1tUkV
zAHBvlBiZ2E^a$<Q#Um(6x^E;`vkP%7ccD<bF>tF*kc+>ME-4`jkd<}lWt-6kO!M51
zyY@r%iEQKzKsAoxiH<c`U{pxRI^oM8%h2tv@3Da#jr%^g3Cb6FDU_$pF``YvR)|`&
zkIDMTsS%=rhc`2vZome+86;e)9qkC(1~wZ8JgUju_AYx994DOlkPvXVIz^PPJ#@+t
zFdOLwD`bbto~g1J1*~jLMA>#xtd*VY%1))M-E4-SZbhFk$^}>X^Mdlwq}nmN7qz}H
zxOsLEZiRtQ!ZA!8dO{No!~O}5#{6HKDv2?xcYknV0UbMvD5w}@3wP3n8&m%~<C*Jt
zMRr~%vUQEbjsP6AMPq-QP81%pGP98|dBZ$AgB>a|7>MhcPTmUrnRS*M(BKH^S%@&5
z<qqA8w;x2k)=&QyrJ4UoY4G;%KV~#$msD6mTwB3Y1UfT=2%67&9F=b@O>)`YofG&D
z&dW3W-2N8o@1W$&5loGl+Ny32F1ksMv?I{kXP!>#tl{z8*tt+FwJgs{!kvKcV2X6#
zNcfxNKQ&Q8*At^?5RpfmL=2=d(fQ_qJpaa!yfuA%j66d!E~U@H$2hqwPH`7?6OA;Z
zK=Ba)`kMhzO2$pYDdupoC?GA06LM~XN28kHNX%a#77eYt;kE9Tjmaqeou7hm(E6-<
z&xIu&ODi&2E)jT+DOS&fD^)O6`1!QoSd6}Tl3#rqZ{-}SNgwI0^)Hx_S$R1ZD<p$I
z96`tng9s;o>c3=$Ye3gAoLlOGioD3gR8WyK_p=GwvqUSzIe^cV-lE^2t2bty$>1B$
z$Irn5zZEHrh>#HNhcVK8$<-q*8<CW}TPj5ox2+U1zGt}aJe`z^+eCGV?hA!iV<`R;
zD#=w~3zXyE_%wgL(-w3WRr%kZsxf=uQBsHk=2ez*A?Gcs#Y-0Xw~XRp^o!n9t~Aq^
z+$&`j7_J;Ulea{6zJ`+j6@-e1oY~1jlF^J15teriUEGNgV;6A@yj#k6Xn#Vlm0T5@
zE>+x>Z{nMw2nRO`RYxUm={%ThMgMvP#zex+E6diWqKF6Yk3f))zVB#ec4Dy{p4nNP
zSULk)&gBr|VJp~nUDr~T=(vv0+z4mq$BbNNug2iQYmGL-^J$#*4QcRkG3C#SCvpAa
z9(a;^96q|u=CG@?F}P(c0}-<>Te-w6o0yg{Q@-hv|G|{+1#>y3oZi2EI~e(hw%WHJ
z#g&jb{^G33j*p2uax{CdtnDu9jrBh#3k2(*gPNiVBW4<Yh&W6WClNw*@dHxXEfdM=
zHsOSMw<IBBMQ+vIg}0EyqSuKw!a??$avx&`Ys}LZJB_nbf}XCqd|!%hw@Ud>=x=o<
zJLuWY&+t^>DN4yM?+NxHcl90T-=gd;%j%v~czV&HiH-`a3f^xkx>Z?X;aupU{R#Ut
z{er8rtLPA&<UgEp+NL1-x!GfO>32HUsM0uf^*x5JUc5W+j~Dhly@or`jH9XgE77f(
zz@yY*lzSLMtAQxRBre_U%OW{l6H`}07w^=hH8--@c@2^==e4V%V<n8Zb2}?NAKzL-
zG0dTpZ7GgZuFB8JK`@n^D_WQ2FLAloq4}6nHE1@g&Xp#gm$r^)i#MWfCkvSfpp%+0
zwH-VCe^A@!94R;vAfmP_APJ+kA2I+AaOla~21U6gRuq<9q`9uA;EF8tWovKv1Elzf
zg9?^gRwp`t%h*J{e@Y!;NmylQ*E+`i^5>U#CkOYP=vT8VQ(fjt*7}RqQnbpm9|obS
z;zeTcauSC&d1Wsr{d=NkXRFJE7d{--_e?}(A=}Hlx^V?Il1wbztY!KMQC@rHxT6xC
zuj$=<o1m2TO2rsa{4+<6?Kd2t1W6^`wS&i56;~b@j-r*?TtXtFeOX74?Ujd|oZb}I
zf8@#OURQT}<;b(r>$)cm4#!Xz_hU^ebnsznS8KK9t*uGs(8SWlpq)X|?(nmwy_NV=
zOYIVJeC!KGznBcZ^<hjttoqINm1f>|&4sTF{DrUm8*t+Wjt}iZ%}IrB8eRRRT+a%b
zA?2FbHZilECx8>7uluxdU9E){yZKH{x!oOL6hhU1LZv6vd-m(QZ+jyIt#Wh7yIt&K
zH@Vm?ZVhN=u28mJh4e2x?_bm#3*w26@3F4S$ZpQp_F2BHlLC$7PT;G&6f&^2%+A4y
zrC$OYnzw9mZPKqcwBE7@oFd=02M&S0(_OcT(119Vzt7PK0y{YHlEMDV**=QJZ>KMX
zzx^kC>&5V0SxfE|-RcBP4f9NV;Yf{Vx21BLYCpZX#r8&<%dB4?34zHO5^VOR4>YCH
z$!MZ*uy!`lV!j32u%lgnP-)bO>eA8cIsGwub$GsdG$5tw6J=Iv*>J1!ceIqVHD1L+
z?oS@M&7U&z-w@LcBR|Br=eil(!O|Yf6k5uSGbNT*F@Gm|8Kr39dXvS_ze!SpKYqc7
zUPjVE1hqAlEm}ZIK{#B>JCVwIgL{!&!gl623V@v7nu0g*R&%v4J1)``jCXQ>;3kuD
z&9TkzG^uc9`dC<3&sluA;%xrp;4N``hyb;CBb-tE%}68})O>}W#7k~Yq`R0Ab3`Kw
z&$h>cNuH#_kGAk(KM4l%D+mJ;ZOQ$BH!;D^cc}?G30z?>8paonrvfqOI}PGj9mFS7
ze1-nxWcX?5POjgJrzx&do^6-0hvyn5KX)_ReeVOYU4BF9{-RWi;QSxx`Fmfku~j7l
z&~waXdqU6IYRoh%czr+gguy>39;-qBWh~nBjZKLf`%Mu9-5Nan<vlgFfeyIFtY^8g
z2(MRTQ)g&0Jt%_iu?d5R)(`c@Ep_;Qf2+h>KYB}M8<O3_kocp&L@MjP@`De1G+bWx
zUq4E8%4P^<8`E@@;9tRHdJ*h~3&^wc)NcKqr(M^tL#^SNhE;)`nXSYNU@PGXBsw?u
z>M+I17)c+Aj>BZxv{{{9kmFxF0N=&5J4qANDGu|sa4E8#Jz%5Jb7Ujt!ED3@mFy7i
zK$J6fCy~ye^B0YWSdj)!_lG%|U^YMd`ga*xK+;YXHB$GxM*+Eu_%ix=V!jLsW<3Fm
zb$n~ZeZasvdjS9ve0lwo<T&Z4M>88eG%u+~8mSRp_~zduTJQK4>qKS;!3dTLS*04N
zhy;mQ1(YIZ1G+6(^(8VLdi(3(PC(G?i}*}rnk-0<H9Jyq-{=g(;mk+TTz(dNY_2Nl
zxJkBw3sQgdyQMEwOyqii5t3K$)VTRhi#`RIyC!n^J8{rPo8*Ey|76-_s-B;)_>Q=)
z)^bm)r47NbFaHu;SUH_G#GZ!XP^`QEaAn1L_<eyKE2&4*QLN%(NI72A&Mr+fv)iG<
z2w-fCi?kt1jgfG~15Yuzv<1ayLu}0WSPWVL<W7-qKmEc)$1>Gri11ct+f@~k6EXla
zaEkw3M+50&{VHjuNBCVE$!zpjY~rWQ|MhG9wEEMcEh0DC-rDSZRil5wVe%_7yg8jg
z^FG|s7t?!YM{#1AHj2V>pt@{1fhM;Fe|#Ed{vdM#B<z7F&vsk4@MO<UP)D_k)e7?P
z&zm)aq{I~@Ix1nKu6K?VNOBCXqkZ3<dHxf0*6fzi#yr6w=y0kl=@!O^DU$D5jMw0A
z*r44Pv13HXrL^p0v5JvsD7?un$9WV!wh<WG{0D`?R^Jy2a}KPfZdAQ(Zcxc82zq5+
zjtB1}KzGuxFqt3b@JH_&zIG>?N!r)3Q*_=*%%<=OzDL>Zd=S2q*;$lWdY^C+ttniN
zlarc_7sNV7d_blxJ|N>H4b(BV24)YM&9Rr+oZRSW=5q$k=^x8$5Fj0Az&ODXQ#6i5
zXO|e>ch&kQDg6656h*)u3OR(Oz(%pQAT2qrEwXxJtey<TbQkUKEm{c@@O&zInO_8)
zMNjKzz-3pn5SOCSo3GrqHh=y~ex00>^gT%}m_Pg7kEQEVqj6ZI-0*W?4mcbgC4(P-
z+eC}-_4i;7uOvDTW>s@}{em9;^N)aR)5;MZ<hUz5n?Z6*`C!Rw16J2hF6GOdpd#U8
z8FVWMjNi2dEg0$|*4l3=7e%_I9H9Fx<$0S!*dDl^T<135OT$tVGbCJSGwOdq^wFE~
z04@GVoH`HD8axU<3DNmEh>TkEcA9PP7#w?;-QUeM;avre!V;>0k#Yu3K@Pf-7SLnB
z891Nxevth1MEVgc-I;53I%v4G568UOe7S05=T^VwG_Q74qGLU9IiwoBAMV@Htb_bz
zHff(r>sY0qqk1#FYtPjl`j4&<9v(xdau|#__&73h9Q;X4)DZ{&Y%~zj3iR}2^Z~hH
zB635_yE^Y?4k!R-qVraJ8q8|4#GZ;+YZlm(1;ex_3x;V=77Wv#EEpzFQ5U~ent66O
zM`fIvi;b2O5}7r_bLwvH*o^HYw*?=|4xgWP5*x12+~`NvC~gJeiEqdJ+*t#?^#q?N
zT>rwhc!I_lNCvNRLPQ-sU98fm*}qNGGP~$e{_0=2zoZ&BS~smEAzxcYuYJE#X!W+>
z+tlRLf7N&QTegiXGIQVs-@+Q}*pENRZD(i-GMPGh05{r1xSvN2v7(C0!za9xgy5iu
zKi<{1X8uks=Uh~y;s&Z+f)v@n-*|-ZISM+p_$={E#}H*xIoXdCu=FvJ^7Re{h?w96
zHPkMxF4fWM;(*QR4@c0J<kIKWoefy>cC%2_e9}VkXR}cJfDcgJ_GqD)zw;z@WSK2{
zu{hOvxfp-$!sc2^m@^c6a8yO`_=S@w5O(w8BBBlvGnS%z9ZBG<dqNQ{N6JT!xL1Vu
z-q&MRfHz^aG3}|PnZ6=#YH4nEVAxJ9mQSXTAI*VwZQ|LuGZ0Q%kml{Ii#EYdgzcMj
z_&Y!d|GCLFTb#Q0FWV=;%#~Pn9P4$zYQtA-(uE0<6~CY{I35?KTtnK9#ebq8d`Dzw
z!|X&z2CX1mN*g+Mj>WsF)xRW?bHev>B<i4JQWS(=q%8Hb0$1`HlYH>pU*k#dZHJeI
z<0$6jV7O92I7Tg;pW8JFpMe700&kW6;SHU*jda?5^PQZHs-jLB-8BV8Q76A34W`Ci
zfsRFYphPmbz0&!G*NzPLBh9T4nhSYzM);#Q`OXoj0zJj+er#KmkwDXfzG;SqQv|d%
zoiz%wo_tYtIH~G5STcTdhE2_vD@t4a^WzvY!^zB@aU0i}Q`7h7dv(daY752^^jkA>
zCm6{4k3T9xh=MF}i=F7G<6`lo7DD+=0rY(`E5y4oy4Ne&9THwD%_OrO-Q?3G%Fa1i
zj9*cB=k8As1issw0I^~YNit%m$~j!zxQQ=G2=s&7+0xTA+tUhW)-l>1iOFdGfJf=g
zyk!*sy_%rqe9_#TWGkjI7;!EqlershLisf8Y>H^;?ARYF^qYeY8Hw<I&*7iZsxzZa
z5|>hw{VD-hhhh1#|6^Z(;Dg&go$~>E5LkQU$HtjcZTbwt(XV3F)q_T_8rM*I6<4a4
zdJUzcf8R%-2BLeEb5SaN<^S-Xy&8k%L0r+|^Mnm<@!N@oowyL2iM8P1yKkb~8Ygs{
zglogH&RUN&{Xp>^%pCt&y1`f}n5VFqo;!a|psS>>N&6PE@EiV|fL-^m2#%Ib{srZO
zn@jKsZU|0l*fhJ5LGmqzer6W|uGWbYkz)R|nQcRe1Id_Wb``rorxrrzGD{hr=(tu7
z1h4D3j;}cAg_piQS7^ZE;FQ-P$hu-~WV4&q>s`QJ^<i2$z6WFQ_I2L50(IU#er?I<
z)$?~mS76r_Z*8||8<GD2kXJkUGIIg+^^Pb4GSCeX;FROLg;^^1z&a;+=al+gqB>}1
z**Yj*U7Ao1S)di$Dzrg6zZTQxK0RGuBBw@qcmtNG`c^$&H9{@;JaX*5Dfpepg(m8@
zXe;Cj5fagTN9cgVpfPTwSdfkeDWgBeFMSLC<$zs|GK1xI;{-ltK47z-z!f^wdD(Jv
z7U_BTE@Dhp{|>I$Qk-8Z!(w=ZRWK!XH_+u2#lau{LOK*@SPg$jMajllXEg;+r7ao~
zv#3*Xwz#L$<EPc~{x6?*vCC7D%$$uN@?)c5n|<HaW19G%HmOpdauezdNKd48Woc{h
zJOO?IO1;2SVj8{}CAx!vM(<i<WMfl(+b(=Nw(Xnf_%nlJagfBKg6Zq%qxmme<`ZOA
zrADcb;(Gm$#y7^A4i`+=2V$6@XY5KssWMWXIEBJ#bC|(bEXkIs=)k7479!nL75<7p
z%sPUtwBJy=Yab%Hl5lS1LFl!Vx)?+@OkzK{_v~_=W|6{2!?BN->ulVewVsjZd>7XG
zzi6kt&{^x(Y(m+xTJom)e^@N!vhZ$dawBwjDmOy97n>1!haZ<$n9qCM<*A6vd+Vy)
zce)OZ@8p{3@}A4*b+|mcG0hlncES|lEo(u{Kz2dMArmqG)naCNIKyR1d@d9&|5VJ2
zI!^*Wu)BxkHxrkD?G1`cq`uPgkZRH`RUL>*ght)9LZhpx{#<aK_OO}a=D-pjA#~#G
zHoIi>4qO38uQxggUjzzP)u+@(e_xqL8>vT&&fX5p6}tg32QOu^P1>QR&MWC$I1k0C
z-~9nme2U;Gwx<YEu}>VN!ui)Vi??siIpghql(Pgzj5&LVwod<F5h`NGu^$k`Ok|U0
z%DadP7N_DnVo5H1#nJQjjay4}yhO2nQ7Ux11@p?O>wk0WiuYfmR1}EU#_lD@X*$G_
zF!pe==mr&*Puz;B6zqQ|Y@dcIA7CRo!t{GmfsEky0zIyHK!}acI^Z3{?b*oC#8D`=
zJ{F;?{|wFrx2VOHI&~N%We(+XqaJ!<j@o{#RZSOkVj0zAvs^A({c|t!*6KFknv00v
z!{<XY&kgs^y~xkZ06gA@`!yG3)?!$_Xsg9!8k9PkZ^o|7JXb`qaBs+tVcb_N)kVjU
zA#v==P;n|EA&UIpYX{TiyU+m&|ME4y<*3Qm6P;hMC#k+|Jna?-<3h(1n}eRi;G<Xp
zEDnaw63DAh>#{W5=HR;hEZeSbwDUT7$+|iC#qCT^vuDagF1NtF+pGdsb?U_Xj$_O8
z*p;CRyX=Gx2eR0qXf^N#p^8p+AY=BdaUi3po^DSvdw$BEWcDn#Cz(ADwI`W9OL+oZ
zXEdWJoPpY;!N;zNW~018M6tVJ%`B29__2NM2;bkx=Z*eN64{z|H>~9-_i~t&*X!D&
zU_mhZF9@2kt0wag2!^x*K`ubZ*FkFDA35)E_77_6N6C^ymd+vVe?>w0;NW<v?$8ZR
z7I*Z3RR549pC{S)1w`_kwzdM8od&g*pyt78CKzXHrF$2I3gAPrABgXntvfuFuSr?1
z52YvY+>y_fdpRU1j!DL(XDFmtN3f}E?F_52fyOMz$wnSR4pBuk!u-=G!Aq2m_(11n
zd>S4?Ik$h2_m};x_eV)8&juI#TzoJ!3h?psV$&1CVg{Aa?bcxPl}`NM#eT!Z63T{Q
zcO~~iO1B30%Oo{H(c_RQ_wpBN*PYDc{fjyJSCXAz2p~&V8sd4*w7T-g#W+Mk@TQfi
z7s=*+ug@6T`kvvfEy$c=EP!CqeK%{PChsq8=Tk=^Rr%8u_>PFw65Q*!-w5HhOd`e{
zlhj{L??qE%S6bi-LPY7#h1THJ6(8fVEzzruxS*@mh)%$*Or6D65gopsadrqe8;Oqh
zM;SIQ-XZpXowoN`#Dge6`<6)R3V#fak)FRz1FG0Ue)eT}YYxV6GX~X#T8Pw*9R4MU
zMDULQW_4i>!sfO6=3!QO;C|2GJ_fj_PSdHm?-<af2K0t(mEoA%YJl}A3~~<k6K(LG
z!UPgQ?ae{Q&?P?PdpW@0gLDkc&L<4az6Jf@QxK>A_(iEQ%myr)pTul)FrU~v2tb&A
zT7yo4iL0e&LF`LHY;$mQ4!Dy+Ebjn^>tuh##_;vVh*j8N>-}4gJNOpo;hPSw(Vz^(
zIRxU{15B;K-x)n%;+8w^XL!`=0HRk6JNG<15IZ^4jNKrT31840&$qYd@k;-<@w$qZ
ziE-K*eD{m-puB7Zb>eQ##+}X$$_3&GyPwBKK9$O(h>$G=e&i!=w6XEPF>+<<t6-gb
z&42$?9_{A@rI+JLF4Asc1X`29-OjW}LX(Za-9(Acjer<So<edXunx|_tRK!OwAs#S
zo;+<}CKI25f$me_`qtnq-n2*^G{gGbx1k^YbiUNVuL~i3hHT}v`{iqk__s`l$>8Cr
z9|E3;WJcma_1AR%nUrz5n<*K*a7B#R(``Ioc*w?69oaLr7tj~L<UH&O2lRY<^LW#N
znlF6G>I-KwRX>4$kS}Z#^3k6@5)B<TUkLi#Y&(=mX3a8T-lt364kMuDaL0Zfd{{-G
zr`BeFIu(^9F*&N9ujcAGWMDnpM2OQZY-jhEw~3KWU(=5sEglu;%%@AC?>8ao6#jRQ
z$H2Wku+kW~e`y0eAMYnRKk?XFVAOrS$+FC<!CZ;#O)Sl12Ybmf|BBOf_PEruBAi)Z
ztGbW{M>gk2Vo~RQG}7F%+<wM61Q@117PCwEVP%?&ZtWIi9hsk$6C)4hNG{I$(UDwS
zT;e0Sa}N|cb>3KZdc*1&)In7TNK-V=bse(!Q^mJVPaWP<)WfMCJ2==D1sK`<OT$Af
z1#pmeaAxIT4+nw=)z!?igXLU?vyr{V=Xw)#2*=T48n@LWXAL_!S`Jsv+hnwJ@@lKT
z?-iY@;e_Qrd{|kZ=o}6W5t@pFEW216kQNcW{$o!?gw5)+ry&SeoL)jo7bM>EitOb=
zB<(TEmtp*6#2;b&R(=hDN*AyNI>bn7qSz#|z*n=wcnQ1z_jKT^%Dg!X@q?eE{A3X_
z^r8OjQEg2#*J4^2aKwPB5XEl?ll`6P)j&peJ1tZukZNhjxCLJxre@P4f2>BuiK94P
z7xWz||I6cIWn-VKZH`d{6@Br^B;(7`HAr15Q<+$MIe?eS%Jdouvgv2Q<b~;{>K&pq
ze0el6eCQyYvx~;j5oUv-DgC`@+!}*)%qtR04=0cI!|NHM%a-RxwmDZ~+1PkhJb$H)
zZdev4EPWB8ix2l;lJ1Q&(z|86t+hkzH=rYH@8A_8n4IWT9D7cv6HiS=6yy!hLwizu
zvJE`BUi#P4r(u~aX98?WiX?`4*Ot*;?|JCe_49PlB-{-X?!?(n9zq2%fJP21oc+k*
zBczCk91<PvWI2*3b0l#H*G(oJN$fWEplRYBD1!NSZE4rR@^<?XgWbM^v6iDlZXB1B
zio*`>v0g*q3`w{VvVB6jix;@?Df^Jiy2KwX4A^Ydpx(T`7KRPs<)(QYedA%rN0jG|
zAVtwPDzaQi&$zOxRaBR|^JvTknfqZG1$16@ooVv{V_r&&+jC5aYKgRm`i-NSl5Rru
zKXO7Vm?EyA`vXi7)I^R&z%*b#?c^JaN8COSpUTdyn&$Hc5dmp4PkoDw9_C3i<Cv*(
z*f<=)6QHG8DndO&@O-JTr%(=GKFibj8N8l5KNf8;`3!o`<{QGMJ2E26<d3O>&cMvn
znM3lO`Q%Wp+-)eMuGl4k!u!GaW~gr&z^=IRbRsv2u?~#fbkomlZdlhp@3>-k6Zp(c
zs6l9DRD$BZtSMf2KX$89SWSY{M`$`E*rQvQPgy^3dhJiK|JMEi{n~#d+Os^GigJ4~
z3y^-I_WuUz4A8kz`@*j!Jn@HtEy`+U8B<(IftQ1RxeDiE85M-z1-y7Y*8PHv<KGeP
zTr@D5AXh=i%tkgCEZAIRNx4_4+T%`iJiudn1x6K}Mn-p(mE&B^$}7ew`*<E5D`kFj
zHOi%wvI;q#xNrM*zB@t{Y(F-2VEcAOr>p*;vheER?c1?p{#-@POvAZF1Ox*iz8O<i
zTyKlj@M9kN824Hptb)YCM=XsgdA~id(!b7w;brnOAc$#an{rxt<0*NJOgwqclM9H$
zMrG$@2%8g-2|MP&rC7Z-BZDi1EHq+{Hx_q1m!27~wwe#BEy@y@ofl|s5POhlj`pOv
z^EI9*TY*DfsAtVD1M<h;bdnrK0-Y++*%8Ic;iyQ5tipMY@E)R9+^T(fICD^xKgw18
zo;U_wHIIaIOSyA_&uuKtmQc-G7hc3$x~lCenQFUArh33tGCv;{+Y&l|0umiLgv0m}
z7eV}dhT4<tN(wyFey!|EGD5XqE4xw<PmN8b2ACO<IyaEo&*F0i!1@iP?17djz(Uab
zg6sY&_p!4c{%gG@dS+}ZiO;>?L=pB7bt<|!*x2a4dl!(9sGEZ$k%*%)J-0M$rfffX
z-UT#IjD6K4G!v7MCxh>C&y-2&ZzJ5oh}@mLyN8P__O34ShJtc*IL>!II~12q9&Ns+
zEP8~(nYuIMI=BRlXl^K6s^3u3OjN=6c39iu?~rd9@-+4eQ$kgEaj6PpppK4G+Z9R`
zN|ONtnS@6G=of6rZjsK`%Bi2pCecRiW@}I2p}?yx@oKqGE_NMrSiSQP4y$XTr~?1i
zr!J;|dZyjHnVaC9%|R`LrtN{+Q^_Dyk+NEYCtx95a;AQ7NR79vr-?!_?bNKh=tyQ6
zjGq7_5WpsJt?kiH&D$-KO~JKCqxU#di)N-_J&HO{|5^jD)eY+uhV_%VUvs%yLB>*m
zFUG!_$4RI#y599gAua>3_E|+u!JmuFExt7<{DQ0ZKC<At?qvNP=R-0rQHSzSjD3~z
z5ggiV>#tuK6=>J9m;+bA_sD&2P5*pn?_tMjj_tsm!MFsU<th}5pw;mivCIESY3%+q
zJ@Bz^Gsie_yVJ-W<=jejrkDR3dxX(nVzI7>Vw9kg&M)clzYzwKWR5T#mF!L*bAC6F
zKCYm;h(3%i@_&-SQOr<B9&Q@U;QTM7V}DwMo6y%BrC>7S&OrY>yHsKc5P-m@;Ht9!
zHx*>27$p5BtLdWyC&=6-|0~k|YlC8T)-fHnV{t^bUF--!Y`#D3COW>Tlz#Nf?ma03
zX*fKSq$I;%%6#}mRF(E6Sy7??{xsAU{N-m(SN{#n2rPvss{uI~3@Fzc+!E#QV|7Qg
zS<v7<+D7HztSwkZZK~xR5|+DvEhxF|kAqZ}skb^;&MWfPPG8eKahKPnM0Wp=%`S)?
zq5Q6=Npoi=yNl-g(e0r6!e3xn;}?JES@FIXBl|{+x5{7sG*sZdrHJ1122p#>E^oe)
zSf$Id^H=huf4-&p-_~~f^zI@eM=n@%*>d;JYv$b%q<B`m@5N8dm*RVV@~)J=^mW-G
zkMg8{=9-Z$>Wts3GTUaP|KalQ&Nk6yyY{PlM7Q1|`K+d>I<p#vnf_0Ab)ol%?oq$d
z=UgI1w6~%&uoxA-kg4pvmk$aOx77VBy<c{ST2?16xX@OG%*S7x_ilHQm6_lTuF0$^
zYM=A3g7j^DPsZ^K7!6JtK58i5mHM2wZQ|^)W4CHOw@o(ml1iB0{=P5N6C<R#sL{ED
zdA$>Ya~QpfkJB&53%LV4wijz0o7onhUfh>peWEiZ^S6IQHLOevHWoA&RP<i?ZpE4_
z_vtP==R)w@skAj1TNoJHZ@H)B#zqDUBAf0VsOL2U>nDp{-4;#8j$7#U*40&PH5F#w
zt;$wSp&7<;Cdrw#RoUv4-aUKYy1FbiTE)t;Ra2Fmt-iv3sxHz`{85=Jje@oKpDHxp
zOwc@SeU^Rs!Bp%Q&VN_f&dy)25BZm^nt18bhNz16b%k+*eDIdC=WAu-e+B1$fXr7|
zfHRSSL_NIiqd)EwWfu>~E>?DNt_wvBiR<0FMVYll`LD_bd{w5e%Hpq{E#p*U++Z2P
z=enqq+4+|XD*k!vLH<L>=`pH*b$dy>>%59YJpu(5GtYHh8CzGAbeLGo{IaO7P=4l|
zL7MKZU*qgu)5B|6q;m7|EyZ79EqIkxBy~>aF&Q!nFnBssMC#L`&E_d=r5CVz<o+8(
zcp9vb?mf6{GkC2v8(@ZDsEWM8XM6r8t|A!AN0jbc9}$!kVP_v?F0hM%*VC)1NqYi_
zn=Pj#aoaF(k{Gx7Zy-P~vx%Dr2<xG2hd3+j@uM6>ckz`V`U8lH=a2VRX0znDWBtX#
z3>@%02%AN>An!JvZC92M4kJF3o^#6fF-5F%|GD5<gJ%tzRhUC!@EO+@h%zsgUFn}b
zr}3G2e7_H)3U>Q)J9L_Px{BhOpR%WVulUQ?(!95(!g%WqmE4O|^6MelcBN_~4PW#|
zEGfJ-b{DPpeKA!|!6oy4<z7Z<babNciy8Yj>AkzigUk8{d6|{Gd8LS*I``g61m9vV
z0#qE|)>7{16>ogr%jiRp?X4HO;gP)oY9xN5eed@3Kal;Gl`YY+7%T?g`w=R}gD3Ez
z@h6c@aQtLjsCaG;PU?!plJq7&^KYR&k~C_|c|kpditL|c+Fw#*mQ!R1SebxSyr;6Y
zrz<;Kdz$^&5kB`6FJtt1l(fz1d~AmF;?)*&P8FU*8XgSMHEeOoBjS>OU6m`jmr7<H
zvZh9=fw=IW=$cjgK)$d-ko%d9Dr}$hFaPbh{QP|RIaYp?mDgAL7uSDIT)r`1{<A7y
zTb#}46aAyGyMSl%!Liw*yLMu<LyO2Slx1rjBd#?L94P=O-TK~XTkh#s`r#k*i)P50
z!H;{=G|)dbYL(z!czL$=ic9yYCm~f@qMz}WZ8kmkv`#<#%kOt*Yp1w`ZI+=dtKJHk
za>7$GXgV87+rnf!adDJ?U^~%di1(HZF1vXUUtJ^^_(#5r&kPn0ZiQVWgE}j4X}&<j
zA|Scw+)FN$YWScNm!jSKe7gJ~RNmL1Gm+G~q^V<~^hqQ8CH@VuUWF%(=$EMLbFxOL
z0yETZUu;idvxWP$5cpG7Y=Kt#ZQOg7sxg<#O7F$Ky-?ziBk0hl8XMW#>Ll)<p&|V?
zV!*FTOz>cvg>Ata6MJIez;Dwv#&20guMeo`g{CGdsvKBRk*la}6dyfeA3ZSOqyMwk
zhvh%|)gZR3O|tIJ^K<Q-qM~d~oesdKp^#GB$yVF(18O_OK<F9TuP@tvRVZH4fB#48
z71go*M{UQmMjV4gv^PP@mqWyk7WQkuemJN3Scozk2R+A0!!?EkTbQDSFVEjizv7g+
z_oC<n&<=2pm1XSc&n~yPh4~90YP$wkmZi2=4p05Z*wbrlm3Z}IwCVS^5>pL`DYOk`
z@@7V~yXs@K?rXTa4o5O7-y1hCDVoBJ#U*^Q$rxRBp$J^Wh-<CkWx2a8-18?A?>x1D
z9Vy9I*U&+Z2i25v&)(?XWMlB&F~bVD6TW<!yzIDNJ629+qe_>{H_siUKmKroEd0C>
zB&K@x{*e}wYBkn0bayzyt0>xYGi%Wbd7OD$6tEWUbow?!ao^oN<MVmivm~$D<%OTp
zr<W_cEca=1a7>hYD7jj=V*Gb*U<LD@ZT4PF)nhw-nD3f`hhq{*ea2grSv4#*rYkv2
z=kKG7az|70NlG>cOI%5B73dwNAcJS74vOZo+ke=xPih0H>36j*ZRu_lIfXJhIV#Q1
zH@7B@U=%R<$iH>C9<`}-T&k+4<Z<BgdYe`h(<gOz?A9QO;SG8NqdljRy~0l3_O_Dq
zBb@^vc0GG{?jB}LcgLhxbX5(i<et`jskoABT8F9uV}&{k>-IVJcrLcMefv1pB8qoc
zuOGX$a`@E;gn!T*VoLS;%HfGcU*HYruFWNj*LIJ1xVbx(Tp!$XAq+D1QtDD2=@+~Y
zZ2T9J1$^@@uK2ujy6Y8FJh4y;EOEsX9kupwWMY|2YoP?no|T|GY2LW;-35(wa_m;B
z$@x>P>0YG8H;Tsnv5>r|0LQW@8aGGPl|T_x-b6uS;cFy>Y|uq}KKY$3VPUWbohyPQ
z4|Y0OJxC?TZtXkH`{&q|tKKN0uc<-ntwX<=wtHVwCm3q3ezCjyuF4_ToZSDLpY}aJ
zcI#L!Ri<frfPni!b8sb9&>2&PyQ`n#o3s0W^IYGp-UnW9;|d-5XzbYpI*jTk>F{NY
zWrBStIuU4y%FiF--Kp3L9qEkb&*8b!-Ury$to+p~uc<wDSKs$@^oUdV9K3`2N+x91
zl+6FwG`15k6R@N=6W2d@voPY4slRp?U2W_=Qr<2RyNvyQOg==KhWQR@KkJ*R1QD;C
zH0<cVeQx15(tQ}0M%>xHPqX7ni{q-(#kHB8`={URd*0Y*-!uL7)vRgQx`PurX&zl<
zWDa3JvCSXM`kJfaunC!uXQ1&oy_xmsFL~g+KhJ+xs`jcKgZ!dfq(d`{H+GM@MTvd;
zn*PhxiMGx?2jk;**ktf7e*TOTCEuhb1I!kwppXN(hR5C3AIIP2bKsWLS5uAP5l6Mw
z;QP6{`uPu#<^3}_fB`}4KhD2Ucfcn4UU#+HEw8B!m|EL{yD8!z2?s#3=l112q+!50
zOf~M)carr_x5lQ*8aY%^%+0_Jxhl1e=R23j+3xpwJO24fv$rOFT3_vQ41E_sPhjWN
z0j2|%NHZSf5Aq_MCpaJK-y}I0ec_pyE{r_FFL9*Q>5FjZdp7<aW-DK{^uB$gYW<?W
zD1k=U8DvP>2$$jzv5BlrWJPruy`Y~Eo3hM%g_99;&(3TcK6jdL=jJMIlEGun4ZaEG
zzQxlZ>Xx^<yQ<K8P++-;8{*uiQ2-B&|01#C;LVTYHs>I!YJbT1J^5cCzcpBs%fHdJ
zMk&Gs6u3rj@MAH6L%Nxjr1v|dn|WIAxf8djHN49h+N?<`t>$eG)Q;T{eu;O#wk$k>
z-@HB@$rEe5SGKl)6~0`S9&Sbykk{X#;xg;Ts2EJCH)j9g+NAer4<7{AksTjJ9Zj!}
zI#0ahT-yCn2))G8E$*Xk>-{si0^NLctED{<rzJYm08IKFmj0c5`gGDW*Ov`XEK^tW
z08P{Kva9b@`3v}l4jTpkv{PGyY5C8O;G_Bqi|LnGs{MuT)1Ck-a2tK39{EM5CWB++
zk5c!CL=D)rLf8PYn2XJ?JkjwXseTm#quaakClw)q%v3QK>O6dv0`%c))`yorjH#g-
z_y;AHiT|z;rBJD&7HKkYu~xp)EA=?32yMW+5><MUtMp2%v^}mg{c{?cZE2V1(rzPd
zj-^e_rDaH4U}@vyG`CHsJtj*ZlS}W=UYhNeuMk>*Q@gSb&X)zT>-_V2#NG#-Di)mr
zeTY<}cdZv*wzV1WSk^HKm+c_jf5ayBRstmKBbyyEWa?4jP74at_s+Gyv*~+@Nq@I<
z*;F)rSNu?*YzuzKzD)c)nzrKSlLexJaGYY`rA`oB`o^6>Hiku2uq)%qdA2o>oAs0b
zqN8#nW$~F)GV9U-*R_0)zIbbrvo4kY;(pb80~)nwYZZ|bW%6|X@-s$1-i2j3b+*K%
zpXz>2b3c{tN0tV@DR*yG?#F4RVj^Tsb|o&lo44UxQl+hJMt0nv?JfhND_*a4Z^cgx
zrNJLL!Q2<b<AJFZ+m-ji@Kve(JRY!|h6ge;EFWjIwS2^Vi(B}a9*WF&TQ7`XPUJA0
z++2`o%Tk|nH>#e3&vW_)ynQSn7{R~f`(t8bRnAMMtF&W7>c|Ovm42S5Q`>j!#nlf3
zBZ55*mFiGxV{kEs7IyS$2((V<D(%a{c3f7iv%zrw@BmkW++T|mBhXHlb#Fp*aLOIn
zZgLI*rF~vrKDdGX%qw(#URScPyXL9NL#{@2zpL_)YrZ!2x$f!9`%aDduM)35q`L+&
z_G<2!J0rDE`;L=S#qB#TNgoHlUp(TF>df{TIHyq6ltNe6HP3a|lr1i@ob=nRjs7x?
zYBT+L#OyIK`B6z~`Ph}zn%>;EC>|f<&o>ZNj01@rtSy$XC-9IH54q+-_H*Yf@2fIk
zuRhAbb*SJvP;fCEm!$S?-|?yR1UG7nM~nj(wXMNtlFnwea|Qu1(c%>H+&X^ELk8@)
zzCX5aza({c`}Q+Z-vg%YpGqItcjNM8bDRI9pl=KAd3XTuuKrjatd#J;>>fi=*#)py
z9i>N{AF-tAvLAN9r6caGM|?FKMsQVjU1{MCuVuZzU*UQ#+Nh{2B}AL-R1KT}+~_r|
zBg|=GX4|~P!i|u_nNmv=3*Xe^>v~-DW$N<Q5L=wzg3Oyo%F6dFR}A`fFOA+(QP)dw
zWoxY$hEP9tLsw&=xBl3bD!Z~h(J3d3?r#ku(7)gCbm6ML110ZJ>Y#j~^tBVbUhl<K
z8;54zJbU<>ir=SS&+MF+Smg0(#q^PmnPqk!m%2W)vodvcX6IR{Z*dhyMcw+uLOa#i
zvT^aDHM$Qxy{;ntQexq0g82QgoayH92Vab-!Foc)1>tF0+!{8rYcYB|IP!Sp8sNSB
zmUW|7<F<_C-m>ohqwVeEqpFU_|0IMEAg}==21SXAN)(k?tRO){mJNuan}j5Yg0`iU
zQrlYD1yq8;O(2(R0PACIeQa&5`e|*o)qoEHEDMSfkqQd6;N!h6Y7|8jYrgN9bMNjZ
zVEg+0@#DoSd+$9@bLPyMGiT168L>B>vf1jBXd_-7SDvTK`q4;f0;E}?T@1QCV^_8F
zyRm(_@VMIwZ4|aQAuCH@yYW|&k1Ai>ka;pEdmDrN*@Z#DV#yuam?_>+H}n`Av}Wvf
ziBi!y?qdop7@!a`KHxgwt^|;A;%#fe)%snyQ|#?t?gHT$Q{JhbbM!N8LAbiRwzO|X
zOXwY{1TG_!gy`F5M!EPv@e9}sSee`wu=2UyBRd|8xL<x^VoymM>RELEy9rls3M5{#
zqq`xY;&1F3n=Kxv<kQ3A7p;72#%8&8P_x;}S2St7AAcf0eF^|3?fXaQnY4-2MqPru
zOraIbo}uFX<mB?NP_cTogIJAuF|2d2otybW=D)3)9b@XD*N>$XCrolxm|@-q$>u1@
zie%xDtV9p+NcIRJfc35X6@sm>4nU}D1Iiy*1k1*JF~3wuup&i+k)smDd@kztIT}c(
z%nPEsAj}0d;HgXqf2q3c7V0C`7*LJ*BCt#kdxiJ!E+)=izV#_L`qFTp=q2>ug&s>b
zxzic_YNwX#>Pld@31X522F*CZF&=@nCkc$^<?41CfwlVtcC6%{(w_NZ8iCD75?BDt
z_~a#)w}!kf=c`X#FY=WRpr9vohS0-~;uqZSQb8AryX4$-imM`7hOed|4pgFth)W|G
zu56)1QCGjan0v=!>S9N?!FY-{2<SXA<CtXI%#`cn;#dXZOx!3W>8|C)+kfc(LCvJp
zxv5xZN&L0t{4x!zou?)zH~&}XTc0H4)_1k@K<euxd=0mRzi9X>bAE1VzeslJ(D~V=
zr$l$~VZrgmpM=Ae#3TBOW4|H8xDWJW3JR|MwT==yONTDl-g+DpF1%W#4POOvF>W4I
z1(JBBb+o3QmX<owPZb4;o<J#Jy;FdtfxGX5WGB+V&7<+$(xHK+mEf}Ugy=SRk_<+7
z`Dw}CM`^cYC)|0vcb>%Q>YbvgXRCP{{t1~7nUS;NSu!zv_sflK3x8CyvsttSo<K8u
zl^HtAzyGk_%R9K?V8)`KM~lZ!E|@2m_gW{>TUB_iDWXQSe~-Vdo8fpbX(90_>z{cn
z*}1$hakp(;K5QVZvT|;pTIcz3isY2$v$7J)lob>7tF>M)A;@y0wsV-5iIwl;RGnO2
z%r$(^vQVwj<YIkETh;RMJzDOb36{i(_jq;aJzgDpXR_e|YR{p!eU981E^2MpVG|`M
z;WR|dypE2bJvETYj<IB?=?VH8$YOb+i{*W%XlaRrDikgb5CTmn$)ot}4>XF3Q*S16
zvr)X*&!Gw8BYxsZ*@4C{sQ`<idD67=Lh8HBNd&O#_4{8_-??nt*)lEHdVTo-BTJoN
z#FJx;cv2veNkAl%J|d{#fauI<kMW7EV_pw5uApe~>ri;L^U4<rfHC_KrIU&&BV-rP
zh^C@D@tJpP`iN@h;;)nETiMKM-7UN^R>w#KHP1%6GRR&IcH4m4!|v(d)%)1)-87T5
zNbML8i6a_K7Cfd8u6r`smb~2wvaKB_?dE5k`~iCY#yMPI5VkHKV7G{Z5;f;rL)X5Q
zgXFUN{NDIOkYWqQAtIy0oF9mx@a+@(YG~m0Hsbj8!aM1)>|dlquPV`69aT!VPSzeJ
zSXb<dTW-vtX4PBHe~FhOUL=Cx{5D=l8mIcoJK7SDwv5lRn#70)(&C21lq5YiVLy+?
z?<CoVkCQ)<X>l=22XgyvEigbJ53GGFZ+Q=eT*y=Ufb`RQoysJhTn_bxo%LmkEHDMW
z(pyd3gpp)MbZ~m++tV{IdHVp(E;%Sb1e#u_d(u*m6r^HP9hVqZidBKC7wK!?8rTi2
zyx!|{3MFA&#W1xt3U%tKfHz?-*liFwl4?`-k-q-2H~PzAv2QMqsPeL*K$VvpKJ?~7
zbWcn6eihJAUP@vY<)!d{-BNm+#5}V}M2QyQAevAOk<laDVqayYj%QZc6%u1e?q8O1
zwdiLI6h?<~HSD)6vC7rW&Xj|-QK`IF=hiyq<eh#gIWK^1lM`whjIQ*v*zW&a7HiAq
zMx30_OXU^Rtaj_`IeRJ4hI&%ilIx6O`R56oZkURE`F#jFFx_uRpqf)#GoBSBPG$)F
zrKHEdm9&$kJu@2)4$h3WOH9tmMYdi&imlDUb$Dz;7U4Oq$wlTq654|k_5ni3!T*DV
z3Wz+#r$3{n@~nuBL$biKdudXFsGZY#yn=8+8VC(<l3lN~&<WVWP_HakETR{AVjlgk
zb|wau1=ukmG&tT0nWuKtLCYaZhFYg0;cFBwFq!b3D|wMXj|Edir+HE<`ldX&=t+zh
z+Ic5&x7_S)R4Zp@@zSZ}cPI0QZox@Z2jaZ<floj8p<4<$s=^`OK=QL?bXPd6nG|R)
zVqvgD@04`5jB0{LI}`mT#y-j(TmMd=u_sBsc1jde)D?D`{c3Qq8FHL2KM=%n>qpdc
zR;Ys-)fHx_BUR%tqu`<n=LNEl3GEHsw3+OtA%b>3$IBrN4NW%GmY9eK8p-gKWNe+v
z;MA?YNE+lm^DZUGF8W-f%|$U(TbncmbI#wPmV~Ab?aDK*kEroNxhBP_0}Ez|A0cji
zkLZJm8^JDz8<nkNXn1Z$l{W4CoQ7c!9E$u1=4P)E*cfJX{I$*xk~JS|s)b-?=@@bT
zUg0N3rX>?6DuJLaE>0$n(k=}$)@=a_+t+7vE~;Vo^6B`N?ZQ%>Is7OaaCZYZG$cID
z$CaW=$IVAq>rU-mqDjOgfBuaS`#P0}I-`A!P{YN8)D1U`(T|UQ+Hh^w>CwIL*VCi#
z+3E(ENJ1jvZ!GRGCJ<sw;|I<xFDTwPPQt<mR&0dRdq;VD^WYX~r+L}_ITjB^X~BYx
z`R;`jB)~1bJd5KrP9D*l$eANCd5@Jky_menImF~$>uY-^=bHw^^L$KtCI6`7BRO88
zj?gZ@l7FyxrdP5zb8T7)s=Z|+Ma$Xi=tB!+5N&sUPd%2zAeMUB|Igybl|AaJL&Far
zK?|{Oh~V)%oo3r`KPWq-6?5g4`_=^1X&R@`Y$)2T1I^ie*s*T|Om6cqo#Z}wIh#8o
z<<jY!B&XMDM95_4GB*kujj~IC)F*oU^=EoabFoxMZ?4N@sFIOQ(+22rsn?5if4D%y
zr;sl7?r<KaMxsGl(OuStB_{CliX6Cxi8S1Dy9x)LuQBRNh3hZ*%7hvgnT{+;VPUDL
zwNaGN=MCAJ8IP$1dk_>txS{sB8Ldw!|2>^AG}`lZi5`(2CRUURw}@2lUMh2MipFiP
z%iM^QrKj+$&i0I8MQr(Nwz(K~)6x!!*t<h&-ytoe&M!nH6%R%h5qs5UrGD4xfu<@7
z#X5Nq^HK6s;fCydMsjH2o;LRqdZzlaZoz@)kl7PFs+^+HMiRsut_WCFPT(B#L6q<G
zn<`mEH)IdUnBS9Q<>+sf=l4PKw|f}&LwJWUe51duR)?Y)xCKCkQ>CLqwHDm~Ia83*
zHE{8ExWeiNunImyaKaP@k0PZ@rK|5U*^ZNJgr*0Nw&MCj^xoQ)3EwqKT=g(_7^S5*
zX}s2z>o{rp#3g&xFOI4dp~C4xg*y(zCgw3$WVUxW6L4!<(#b|AMu(e!Gp+}XOkC3W
zK68HY@pg`FyyE{%sCH&{xTQ(b>%!F~o$B(}kLAmJp}3K$8^$nw{wlB2i-OklBAE`%
zu6tyDXRZxe@C<#9FZCIQfn+s8g0;RS_=VNfA-zY4?jJiS!Nm^}T>Lkb7Tw#=y{W7Q
z>>fOs2dbgQQ<1MhU}jtm*$pgd*S%KG0#!+p`S5I&YRwivAa1&t<Zc5gk{B|uoR1^@
z5P?zNZ<kdZvy7$|AX*;IGP>0Tv1bJ6E+9Wo2E@D5HK6Ay_U*#NINv<h!>MeAlL)md
zJU5q~%*H|G1PF3)%WZ=2%DO7#%#u#;&}AuPjn%*n{FwdMjqZDf^zEg(Y&&nhEz2!;
zITU)VI>LU+C{01C!j3}`ViMp3+m#RKQs3eHXB#8HdMn#DcJBS{6~m<4n*vRzQVPm6
zMkXDtpHZsXIgjkJU1O6_o<Fv{AQ0<evei1j9b@Jq?yU_)U-KRFVUf%n^@6B3vfV67
zAlUl$IKJyb)**FBFA(R;B67tr`@($LfQrH%Wj;#t1@l{ek-2=3`E-)mnjUBNq(?Qd
z9Yvpiy6E%I6@C60(HxqoNNj1`x_FYcFI@a$b)~&bRNrCe_xExEY8{RkWhUY^Zc>r`
zq|)u{nQvN?iY$Gx+WkS2x|^ih23w=8aI&h7@-})m48`P9i2H!^FHX3Lh<Bif_%(ct
z9bldMvpx`4>GwR0lig!rWs6MAvgcw42G7rH3Es<ZVA+L|?;s^Vk`?YCCEw*C9@<R_
zj2(yzszv3_Kub`I)|#U8FK&sI$v7MsG(Xr9lhfhYf#c?nUUE>>xi^e#3AS?zK7V-Z
z;2Dt<V+T)<92YxyMPzX7;JJ|kzt#{<EjcKvuIP_3pa`rynr7^}VHGm1XP}<#$Xt*1
zSSNk4Buy?F&u&2c&8<|-tsieqC-R#=*Dd{Okg}2EDn&}9KL}x>A7GN54wP`rFxtPc
z@gQ5=j=yR%J~{Wu_{iWS$H3472DZpRUn(MYLs;HKuXeJ}VxnK6lzCyk`wx<mI0-Bj
z3z;Nd0!#1U)!-(u(iU<(ctxP`MtwNf_!cbL%Fv4q0GqI66ZdmZUFOO_a{6>YBv@bp
zPX<RN`!m;rFb`2p+a>4pA@OqIB^fZuA+9JqQMojXo62;$<h%amo~CBLx5P63%HID$
zltY1~qIO?$u-8bQ8)X%3iT!(vjB9RSsds4nnAXuZRmTLfxkvE_c-Rgza4L`(Y@NgR
zBwKuKB-k>3jJaqy#3UJ*)|{P$>F0{YG?=(7l!OTjzI2$_q2Z$5RCJ#Lc1^0HM@XdY
zHvK+5_5Btp^aX!Pwt8gl?&Yo9`J`{(U_T~=hQnq{A0+&!=QyKxY+Y|0XW%u1rTA3z
zY5a(<L8LulC&#eJ@nwK0+O8jFFA((;iiVu9bMi1%8^sP(<KjUoKM)Qy{))j8b1jOz
z`4&a=S}d{CBS)_uN1jUdEv@-&o;lXjGAL@3SMA(4DkW*;s{v*o-x*irRFnvEDU%Rp
zp4~1>hI~lf{qwnvJ*7j|{yJ};rT&=!w<0s_%s<hC7vEtb5}1xuWQCo}{gmoJ)A^|s
zOry&E6g-celu9As&Tu~kPY8WeDLunZe?MgkVHkv<F7f?$tj)nR*t#S?wk{{OA;+HR
zJMyS2GDpWJo1^2QY^u4&UizG<9maz-U+r+y%Ze{tjC48;Xv9FW<?w@_88qxP)q1&>
zsYoj`&6F|1qz;|nV(tkZF7WLzg@P$ug#DEAK+|_pDd6I}ehQu;2B%WM#SlN`0$hkd
zgI;amBFj&~uf)5gc-yX|^N@+y4(3=B^X-Y)4)Rb0QVxfU#zSz?@RElMXZ~)V&hRrq
zJhgw*dx>w~z;El*6s%h<ihke8%0yGJq_cGwX|<~-l2+?EU^y*W>G54Ejr75glT!@w
zL=4gkaLsOQa0_{B&8HF*27HHSHu&CVh0GPr9hj(g{sHe}B0%XlS%nw}HMciB)lfQB
zxYPg9dc#+zMEkh+ny1J-Epv0K%p@r@AXz5*MxtJ`{4AA4s<l2{-oJUHS8?Qc&2nKX
zOIT{@lgtqPcf*$_M8_0=O6<o(FWEAyzIgf`4p!n~Ae~Q9AV$n@5>rt3W&V`3C0@5a
z0o=&Tda|Ok`L`fIjVnKT(e(QPa&|orAHn&3gDh^W{e4B~ludK`etu!*`O!~}D^>ft
zBH0lyRd&^uCE~e0Qw9+YWg1&c<3p82mz6Z%qQKz=_%F$U^!^%qbv9eV%wCaQx{B05
zf?Co*g0OHN31BRJ$G=_*JSPQIK3op|nh^zxxSQdy3TFnE{aosw(M}Wl{zaE%tH8uO
zit}eS<FX5vqu|~AW_bEIUtSRL02#iU^e$)QD!EiqZ_7kB=Gy`*?%^Y=d>MKT+}oZ-
zG;j4}4ETc-`~ooGFX}7gc-Cvt-^{DH5o&K9(rcpMU3MON<s^OQfwn@iTqZjYed@mR
zC__K0rx8tZ!YFmIM1JeuX`q08kBY-P4+p7S22_MO4ys-Y@AxX8tq>8Nm7EqlyJYcT
z%ZDOQ$B)H>`9PL&#x8j)AJ~DeJ`+4|$R3T8Y&_;o*<p25wqC+Q<J4_ZvSf7a`u5a<
zAt6WA6|cW?An%HgtM<$T?31$cnX<LRaKQ}OiR(%>KO%i}+x$EypV-`QWoIv&dENJS
z-OS6V%4S|f2w<pk?l{FrLjU4JQl_|ZxcMl0h~&qgnveeKUQC**TbtoK!fSMG@VYuu
zx_Z?{GXq5dsBN9*wI$(!>6)NNsCk7<uJP*0wy1m}H^QuiMRty*pM~o2Y{DMSY{ddi
zc#Y!R>>^2clE*rGMte1_ro0-cOJJXV{K;A-Dj-iclp|$DShSzjO5rKSxKAs+h6FQa
zX;sePBi5T8&T#2dx{iT?V?@l@xvLRWT7OF4SD!(btPbyX!w=#H5hBlNEpPF`?aiAf
z9(A>Uz&b=uEA#?46COUbKYBzLUlC87ET6$0`_1>%7X0Msn}Aj8IHz$DzQg$iDgps3
zE?rfz)|;o1%LU^S0%~mZWLn6w#0II(X?w*KfXzg1*P8C3CaOp@w?0IN!mE#>MLo6Q
z!1k9LG`E-!$rjxjTe8!gA@lHJjW4Dy$V61V;ZBcwDxEV~tZ14VX+6=<YEfyG9H>no
zpEB%mR9do=4DLXxg8qH|>k#<0#;2F-6k=?xvi$5-?C?(vG_IjMQHj+L0WL?F03FmJ
zmoO@zb-I%yE~lfD!Af70!Md|wW47u~RL;$u^CE!Q>JbCg$+QV*(mKLU<u-3K&WrBz
zCGeTwa_p-c=Kp}RL#+7&OE=Rz&+v<Y?kBDG)*L>qb@F1n1F?;}n?oP00gjB8`VXx3
zR~^p7VjCNpv&RNwZqBtICQejb|J7UQ*U4}lL+@h;Zdg#(Tw{uEm~iX|vT|JXngKu1
zctHATq7mrDh|mWdQ`r}LK?r;}#|eZBqHCR;l1;JQLt`7;(trWKhlA%9tG#3sC6f8w
z^JIWKoGt(K8^2x}7gYxVQ+TZNaX8ZtATgb<a6{TY12iZ)lDKdeNp<b5d5R-W4SU5l
zb^w;UokDA!ftrx|DjJ?c?&ptY`E0J)9uIX;Nk-ZtDIiT_#;{`RS|^L1U9&^n$zvBW
z0Gq}k=hkeG9Mw?2JtK-^t@9#zX%~a~Zy@4yXqS&Yk$OLD_=<qXswbn$H!(h8-E(G*
z*|4~nCsCU27CtLG-(6k#>;tlB4jBm~5;Hio!&&(zJ>h!S4GWHH?h$0v?dXnLXN<>a
zYw4#MuItl>t4A<xj3@=ke3V$vc>{ERBb~$WTnH4ct@E7hk$_K$A3TWqPi&-q&aW&k
z|Hh8S03Q#mJW)Olf{p{r)>BRM5kYrba?l2K8?+ulcRt{C8yvn~$ye!!G~e-p;UCh&
zz|y;^RJ#*cb}>!;uPzCEX~+$%m<TYK{$zGy@ly?V-;IBsT~$e|dKu^O)N2sziu7-$
z<AM=g$@g&hb3b4?Vh9qJKW%0CIb_<BVLgg~%$+CzDm6sPA!Gb3<ywY7jl0}G1Hy(L
zCkI`Wtop!xlZNv$qQ|(RGV|oE<vA6!%jZDjY`%6ImBlD#{tHP(s!dag*27ON#^bjD
zamdu-yKsv`M=#1(hHmvs@IR+=tr^PtU7kqd#hn*+othG=As1pkf$UxmcN2?wSNXcs
z+Ta@!;j^4I3fCo^ed#(?8X1TH0g`BYw?EaC2cB^f3&c{jQN4Yn(5K340D$$WRkI6?
z=3zw4hvBs_r|+Z7v_hMurCVr;MMo^|?fT7i&KH|A;Q^bmJSATr_^iBiIIGx)+V{w*
zEG>8<4a?bzx@@sBnj=TiWaPYr;^d&_rXI9qFO?!*{z-wR;U>G@O_1!CpFJ|$WW@&h
zat!Bt2ghh*i!T8-&As$_DzdZh3_CT+GH*!O^w#FJv>n>Kx(H6jg6o|09H1_hBk(f8
zhCTrSD9T7YM0(GyG8j8}Mc?l$TE&@Je_>(08{{PXGZHlzaY7$ZV4e+wGD4F5tO&*u
zpQW>_D)iT6k@{Z+xhhDAE|(9tA}fd#fq$n^yENM{dK~;nD%5?=iWcgV+XAumSz~5!
zoLA4gT<+rJF8i*qGwVeUr;#^TpGxsc5sr^sC;PTK=bUF{h}s3`Th+LT<CE02XIdX5
zt%u$jqmrHR7TP+J!YWJ%QdF4ect-h=0%V7t$GysnA__FrznBrNgrSJJbB91YWt%*T
zdMsAIBQvn#hdk+mJ$sdbmttK#aG74+uqTax5w*$okQ6u?q3T|X#c8i##*3|!7{Rd5
z1xOVxvi<%?ze6?w*}ft-7FWLpBN=p}30YG*FgfM4e9je=!v5+7A7y_><0uzhtDR^3
zZ-GV$%0u1-n)gBfd-Nfi!>l85pTZYtJl_lvXUt<ly8<_zLDNXiB!Y0OwAq^4oQ;Ku
zwb7cgL&6+S*%r^v)m}`<h0Zxn6fxOEXI%@L+<SO!{R`yURgjB3t+-E|+Q`|%Wb%}<
zr7f4=Gl`{meI{?Cc+*)w`goNxg`B44b3eKtww8fg*NVAi9)9iAeo-90l@<jWMVCWD
zVCjAy5)XK`Vb#vIW6W*^D|%Du+eIn_@0B^ObP6>YWz0%2Aj+7J=(<Yc4}Bq=qh03r
z`4n$GNN>Wci|MQ{>;8U?_C_6<!V6{5-zAIwF7bgOd#o<Y(ys)?HSFa^(1N9m4F2Wb
zMi&?$xm3i|4m;o5=(CkZabu?Q{&Jc3^=964Y1%oRhV6S~-Unsg>ytO{-DV24?uK)(
z7V=46vHohc!b&dTu<oyrOA&{eG{WEA+v%X;eh;vVF%IIsmaUj~Rf<QMAGj{0(ki=t
z8+)tG)hbrXd~`j}k8`Ib@7d5b;knO{U#MlN@a;hY&<g23D}=nbcM4*&6|oa|_YphA
z0Gk*b)A&dn;J$^QE~SbSh9;>3+a50<Vj4SZB_r%C`VaTdJlXYo<@onx>B<a8HYLZ%
zBPa45&JO8#9<N&O3&;JZbM+~TG3QU%DF|LUzE&D(7!6%)BCYjZ1$B5Ds1LMiUU!H;
zRwHGs(s=X|GIZzB$+ZGhWVl-Z6bg_FGF8qAgAK)w=c58vB7mJh8XzBe2w*2fMzwA^
z1gL%<P|Fx)+{DOg$9ZqH3H3J&NVVqe=7`n(9=Vj_XA7t^+Cfv(J$!Tj=qF5(giyOT
zYBH`XNTL!xLgb#R+aJ_xNb7!|H0}Iv+As_JPkD!ByKkD^x{W75%%Ot$r-k+|eBZu9
zc2CxZG41tP_@U_`ZT^8T(k5{Pot>|9bQIb<&F-PEkM2~9QiN_#^dA%5z4&5yoXp<)
zC`Z)3v7z1dy)h1HD9tI2{Frru1^6WK%^q@=7xX_jKQaQXVSgj9U_EkfL2l&evaz9e
zqMufbjqYCbS75cC6sTM|YUR|@LV=%GyfGDwHZygMbzvd*3f!NQv0>3jY=BnrgAtHL
zdku?9B<|?-q+xCcyg~#m6+M72urdKRFfg7TZEjeUlX-e{2|wbqRwQjxfczQmk9a*~
z|3kEfcbaS7wrk#59?ET=@|ImStU0s?e6!8%g6wPZ?DG8Lj)e(($~)LF-7Ni5T)!&z
zQfh_#1aSH2zG_Df)7Y^#OtUi;;bY%02w&S!zX!IkNb<T_V_pojyhKeUNFBP!Z3ykl
zNc5e(Du~hWiib%-kSJ^kW{=reKS1wq!1YUy!{h2!(y-)bsVrEYeO&1Ykr}0@5GgIR
z7yaS7*{ejkyNfK#LvN4HJ}&y0X|+kd)Vwu%>UT1ucP|g^89m`US<zdi19WN!hnA@b
zu*Ey<$$6O@-Gktl{Vky;kRisDY;9f_cs8_e%)02^K@VggT`7C6zV&+pO=2QVWis@?
z(xG2t$~TAhdF!)#Jb4@H-^z$A^FRqS_2-itmG6s=6W^*Qnnww0UuYhM0Q&KWz%cu{
z%nUb^=ayg(?v&hAOAFwH3~_l{^qou|pEi#|24a>&F)RlDz>~Ls0D#QcE1j-xz$X{F
zvnA>8peG~gFU31wi(9W*FE(vjd`!uv<pm|O$IUZmIoNmii(WH+%<Iwj%|WdgPDV;`
z7e2$*Af=4W8Auo+|Aw74YrRz}dbGcI>E+N`=YBsWawbB&8rZ2)#-2DTwlEuSX`=nH
z%ZAI0mK(`r@`8zA)2{OGO0jyVbfzUMy2PF+zOp7kjp$!Y5CqZiM!u`zOe1Fk)(r?a
z_~%cSkvp@$60s^cD(w89|Cvb7U>Z;;yi}`uD^*>zz^#*Uz`oDEY=|rtlVpgl&(4i}
zOx|i|De6kr1>q?bq~MugfQNs)5uDAfB&oaLZyDTF$KFtU0XVm``O?`g)m<U`_JjU#
zfI$9Tj1uxf_T5q<Y;M=qI#(u(ysrL1Q}%|QJ&<>MLTm^*4LOWGPzXs;bk;kZQOG$Z
z`>k~)#1Cbb{Y0jz=q)Zn77;yICBN)-!FOQAWhAzwS*)MPOOdC|o<E3}3}2Id2R87S
z*pQz?%-EM$;=Rdp^Q~u#bxXyPZ{DZ<#e>uelOSBGNM*3cl85tZEb2T<#2cgnPw^V+
zKue#rM4Xti&=WPkTIIz$XDtqjD*s!J@o*0DUyboj5CHV_V~2AL+dWHkYE7c17occo
z<7wr2he4+ZQpuPKhl%<12<Zmh|KLCkO%AAT60t6}Mvjtr`9SDgZxRHS3QOTOL7)*Y
z_&kVRoZLeBtGsaoMl5i|Axv+IIDdPLkBC=)B#{spYCXiLo&lO=`iR|!9g}^QbVO8M
zvK&s5B(atAtc_~Lv17@8tc~a<wRz}o!V0nbDS>SKlak1toGd^$G%p~Bjj>o}M->i&
zTE6&N5;8Zq0ci*Ob?qsHHHax7x}`?}W<#SAgmE@m;Tz*cOIw~1I<Y>nzM?PRM;Z};
z9}wtm?F(B2xuNa#g@{SDb+#YX%-0K0avJiR<PmkFM)!5^F;ae&^RNC!i2BI?u-W@?
zc6tY&447PHd}Mw6UCQ^f-wFd#<*f3`J}f}*aQ3vNHTylftCxztMc%nceWc(74s|O#
zaBIfX!d5PkH+6)&Vw-3`%tgjc@~DE&b3A#HFF|GqC_62`+S#;CR$OGHM@1-|B9RdB
z`-J)_zsiR5t;PtDApsZ7L-UD)d5~PycKxGu;;l)_zy2yq_)H-Hpx_=ad)wPWZMa_;
zChH;E0duToUs&WFV+Qlbmsz|8rGS7vLbMzTU_MXaMkRrgt?Feun2#0_*KKhDqBC%7
zXl-<ILw#FDWCC*QPagqiD?~qnqr>m`T|3pzNyV6iAs=nH`4LjH?}yssuhh8WalucJ
z-5QIp%ot(L<|G!6s{;bdrZD|Ghc%7-2TWg~yu^cYVSb%sze4Y;IrXqF%(L2y<yviV
zJk|-@Ywm{-F|fI2pR9#_buA1mTSigf*4Xg1_`xN#0^3~aPoU{hp8Q~%>@Du*RikR&
zD&H%Tkuh7pex9wk`mma9;*C;a<o|R+gKpDv2q7b`2L(K2sC%E*jg*sJ-`tGE#@3rs
zFKb#amlxgE`5UES-RcAE^!kEOcI(Jw6)KaoW~bhN2nu7JtjR|SE;WR0QOTz8>hq|E
zYiszG<V5E_v*{4Z(tExg&SIFSkkYd<qFiT5^+43~1k}*uN;S`Fy=uLW1@{Y}@z1ma
zP5%(Q(e|xt1C2iv)OkZIzh(G+-(m>T3OxZw5_cTF&0`tYa1Et5zK;&Vfc+iyeIIU>
zvsJlpr;xvg&9%_G@cCxZD^PdCqO7b8c7(h!9=D<$#A_}~<C!`qpYU`?jY0S?U34>r
zg9wJM6cDTPmru?VU(WkVDRKhX?lO|@tFVaHr|5B&I_GqInpPG+OVdh{53w=|c?(G%
zc=@m-iK1yel<c*_HY0HBy5*N<HXJ-YaBEvpJD2geO%P~24FEZ{=-qJe{6OOtfJ0d8
zEs=m%TnNZXu!JDoQo!O8#;pJ*cyWJ5j@I4088UOl;0t7If5r#%Ljdr>tUNrJ%$$q+
zm=SC|58N%!0yU+jpayswzBIr#hhB;hUl@a10r>(S<SzmFK|pS(e~F=J7tBLVpaoX5
zjyvzzf0SeF^z(1}$Uw&qOb9gItZn56R=!J*+&Oee=p?_}v>gL_=}7-%N1mr{saUp*
z%`Y9osPx3|EIT}c&A=eY><N4=>Y3hFJ4Z<j4^w3$VNF=fsu+VlFec!7v?^3EMA(u)
zpOFMI+?Ql;>?<yQ$%{Q!ln~AGbcuR2u9wG&!mJx*vuxKD2#fg<kCl~N6?+quTcO8<
z&%@-);Q8$)+;N?A#N)c}qNKG5;&0s|VsGl&9Mg5cAGy{d7f<Pc`*X9`uX2vL)E8YF
z@1+CE$r>*vHOa{$XTrrI118}NzhWwV%7|Cw@mHe-bO{l>INRK$N%3yCr&JWom+f%7
zeSKkZ-2D>ug;@p~>en*Jf2VJz(MNe=jHW+G5pPKdG~L0+B+8ca(sgMFG|rcAWr*zv
zv644!iEyX$q4hCEgy7%jjkynb_j^Euzn~iqE_RwIAR8^fc85@U6*F5G1_6E};16L&
zbpNI?=DX!vO*c1$K7}_uM$65iPv}|OQvyCjLo|706XJ)|e8Oq6*nAs{@07txigCK1
zNC!<Q_T^Oimm->XZw5d$q_~<-%7%W%13ZDqKZj=vQAQ58)=mEb91+qV6SkGpbwpDG
z2Re;kxud978fyB0ndM5T%+&OP#<#%7^t^Ke4|ad_&*NAvA!%wiE9TOAna?8DMtA@V
ztDhuiP7(wAx?q6HQ%ERFVF6i#spQ^-<~6w*d5clCw;B!n7)%&B=lchglFHs7w?6@C
zJj1<+^1>IJz7lZ1Wm((wQL>`JrlK!iPphcERMaCKkZ#MOl`8)_+350<>E)FZtltkH
zUvi|fliIw|y$=xWnG-k*7%UT<FdCDP<%Si%kog92qQvP4VKF<L7qB+6?~$Ew85Sw<
zHIcw#X8EXg_CBw`TcM|9M(mb_h`Qt?n_Jp}#_#e$&vfc}SbYJN=s`*cb7U^Z10VfP
zt_A7k0tuo1@n8Hss)$~-&J`tug6nW5-KTBX6(V3a9sz~4puO&Jb~AI`Y$2HXEm(NR
zL0%I5aQJljV?Ck+V~sTiT9EBR;pu$-d5_O8JCNk_O@EV2HO~WwBx1`s*H0wW+nrq!
zG3T7(Ct|dDeV0TmI!F46Q;AsBB@vV0Bm6{6Y{z#=>=kzQf8hZ{#NJ_D64}we?k8eS
z+e;FC`szlgKi-?9uU60i;*R39EQu*4)ZZeYnEOy>=C2~7F8s-Cj9-Skh-@5bi2E@6
zb|Hx>XY6CX5Y%)KB3mxvD=Z<jo<Whd_k_^;=9+cQp_gF+EanaM>obrX>bJ1+PS^LB
z#TmPZ3qxpAlIac9)lk2VUEJNWrfI(hw~{+!bs53}Jvf_7s1QT513+oBw!^ucS?N9l
zAfCJq{O(whDJw+Na&+qi5jMI=u5%wy^eDky+)EcHDReW}jTNjWnsCeEe+EBY7MBnt
z*JTB`N@#GYZXO|3J-iyP+rpS|_!YuMxqOLX91xm*ov5+Q!>doHcPi;-&OOihJKghm
zOAgJ`;Q|bgl4GGm)`9sHUxcbhqmA3ct2)3n4WLVbd|Az-hi#xH)xd*tue!r|{2yrz
zD9>4`4dl)dM_zNpsh4Wps+~)JtVptgBi!@oZo@+9(Et7S4!!FpJ9M^bFPPq*@~ENG
z-gr?OG}QpTdnJDk*#rD0S&>yHD1BcFh1!ePV~6;d+)E1ESLC~Qe8N}RSw`7KaPX%y
z!sFZ1lQlFyOkuj-yiJHm6a@$*8SV{WT(*twi^6o3PjKn{vi#*iM8R2~C0T^IHdOPp
zs4+yWY~n=E!^R+4wUulQ_Px=Sr9*~yyOYGmDF%eIVWVjvd<~9_)>K(r<4JTiIr=ga
zQ#9{79i-K4Ofjmp`#ca~R8_+Fl8G>?-}#9!s<XQ!!l;({i7=|dE{QOzxqc#y>L4ge
zRSTn<;wQqW-t3YHqZ;Wa!l>4gs1et^`H4asnScpO_eHQ(N+@Ue%n|M;xVwG(MiN+4
zV(YTx=-0dwz;s=fxrCuI4ptlzLnIHmH7VaPwt08a-fobr^ZRE#u-^zhWu{i+BT{+j
zsfLBUG6IeF$cqR|-%`=~Us2JuWLkYZ+(}olH@#JC_&qwDZWgI#7=o-9=YE<RhS#76
zFNHBE@>3Xtr&B2mK#rfn0EqK+uMF7V`-xW@*cW3~F9p<Z^;1B-?5DgG@cxva0^W%Z
z<Wc0I`|3&WQOZa%cfvkfhbWIMqMItg&N+g2CwRBcm0g~t{&a>&_0t}67M8SntYOY~
zA~6VazL3fog4bUIbEkUweS68mIXf8Y)FG|fZd?P4#~q?3iJe8~$I|J%<on0GJ8xWL
z4t(_L7R@wXLMb{urvVUB70LyV#`kC=tO*22b{?a6JbPF{mwXf1RRtQcc91&a6XirT
zBR+A2?mH$9GjCFYkA>!Eh*Ik^;TQ66?(kHj6U(Hsd;Q8rOL}}_DO*N<M#)=x?q$#O
zK?;bstN1d}VaUJuvNrx|89nYW-!Q<@fAM9{C!aW=*MHVI;kj4O+0CA@);aiLpN#u&
z-Tl1`qIy}&3dzwjaZ-FDTQq?oPfElmqL-5&*?!PmGk-@7eCZME`m5p-O*n&zCY-^<
z2`1wl{aLnAe)yL<XpAo#;=_<V%(?eX)yA^N@f}Fsi4M%U^ViJoZrwB0hzOxizN^bp
z^QNdu2ErI&KI&iyb?>Zmj$~R}J0MzrKebv~Drs{@&{pCNeRGPW-Q<XBC1ykuttLY!
zwIpJz7n-7<@P>`>c?_>f-Yv;1JVw>+{%9Tt2;xy)<AZxn&}BY2*m-nne7yGowb~g{
zXQ*|(jPrxQAmLo9olt3(dgF>G&#Yx*-X!VbeB!+^IGzmU>7<O@Lq+zn&5Z7xHG<Ad
zAIjvy3H$K8u+wvIpNy6Xy)v!rVH&;LI6wL^UASNJT0QQ6PJV*f_pRr*Ihc!@Hm|Y@
zzkZO3^#-%^vipH|$gm_F?g$FgVy#o+d~KY6xr6!Sp~0WO(*OD)&NJf)w;{IKv&vQL
zYuZPQ&u|8^cQZa9zT)+gNH3JKu-85*msslZF;Z#gj1$uBZozcOj8>EQTd4~Nq?J0U
z@x+mr=p$-tgQ*;ztO|lB6biQG#)hCSR2X(X4;k>5J^_mPIJY!4Y2|3wxS0I9q^&hT
z28=cKJ;IT1yeykH0xp@^Q<i7m%<L&s$|u$t%@CBuBn>w|Bh8OeY`jeQh5{8i(g!HJ
z2Ax~YUf{OMvuV#7D#m9Q;_h(z(>WQ_rb7gK&JiLg(5@}6GiTBw;ef;o#9TZQBsv>s
z%hk>~&!|F4EZ1>UXZCUV#V;ZORaM&gRn94wXUVp#T2=6(fvTkqoP(inkE_kSbU|h<
zzE8P<8doey7u;9aw<110FLd|H9Ufs6zW23|Ov(Nv(InQ<uWIv3sP*)eha|=6IZpAP
zxGPCNdL9uaQeui*nDqoAS?oI7SWER}RqU4Y2x(G_e_S($EEN$Ecks_j;8(#QygqWG
zH(1u_aJZKHgO$#JHG;_6YUj@HYD}2KZCYshyO6b*@Z&%wWxo$STkEau9P;-|AwtfR
z<fQlg-(_aZlntuz2EV}_T&Uc}e%TI=p!set##CyobMASRsTv$%l@4=$`$uI2#LkF}
z)O!FAe5}C77EdjT-qiX57!I#40_VEs);X`<rcJp&Gt;rodEn1l0c~y7duL~v^6nIw
zoay)5C4Pu_V;TjC^isV?wAePWRy`{v+^F>vH)=!Y_tcOfm?#j^$_@V#8G!>xyG<rp
zc|M1bJ<5k!<FU{fBCdFYqpVEzv~~`Bo&%`-n-#>w12S;k_+u#-u$g<FL!R3?ndHR7
z^DxwA+hWZLBC%gow=7MYteWSsos}cmF4wbOm3&^Lu2H5Fat#izOL~UWwz&70P+Ooy
zd~y4!>>rndM&N4zzHhzt>hUw&_o|{oj)2Vtf6oH|IJ!b`bZ+z(s_Kaf&oHw;B5n9S
z<<T*Ld}rgmot@a(&f(eml+2T0siuqWv3&DR4eFfy`;%MczsW#{bt8@b{l4UPF-ivu
z;?tHGz&WDU9ROsdCu0Z&FQRf=jyyuokI|#(=mG{sxYv=i(`9eFL(d&n++v7mKhxN=
zC(;ptfa;tjsb=K_n7W^1?UHp!>>wGv)Xgt<Bwuv@OD=bf-#zi$FqRZ=+^)fn$Ga<k
z5??*r$0}#Xr(b*cV94D*B++$aWcCb6^0APQRQ;#NMRJS`0thur@`o9x27u<_bQ6!<
zPUc`n0{&jlco=m;j})y08Xp!!2HAQ?2H7BUGBiA__~pzELdwy1FgT^Pj#sEt{qUEW
zb7DC!{v8GBd#y9@uZlZP0R+MOg~IS8Ez#^tQEbW9UQ9+~{CavVu4x;+R;@FLndEtf
znhxhW3W<<jQcsiE9@z6H&{EU!JOagJ*2zPtG;QuoXSugEl7J;gnpRDl`?Vm$za}14
z-s{}Lg*B2BPf+EP?5*AHWKxSp@2af?hC(ZUy*FtG8hW6iYNyVW{Z=L+W{j^<@4W}V
z1ymDy!TIwaQlKX1xBxteJ`(vHHHF@jGiDUYm@s(f<{1Vvo*T_P6v+`)^y0)7!q!kj
z?r`=4v@1mw+)2lx7Tn>K++>LR|NQT(K8McKQ8B}Q22ZlHBd{H{C3kgLAP~~QsK2S>
zLz{{hQ-RV-pm83LrpcHzIg8g;+2)0H*Qb}tYn{=nOvB<k0D#aB%8mHR?|3`336Y|P
z#i9=oGwp`Oq8*VZTD#;4>O3D@c%|4S7WkzuiN4@{Wrz69+g@G4=o8*oc88Atb!t>(
zLTQ(s;a30arO{^ZE4#v{{jahsggJOA><S<7Q)E|2im~B0n?AYIZMJ(;S1QCGJ_~B#
z%GW@5VqdE)sp+TCL2?E*Ev7?mA8L}ba5<=^r~ll^w;Hms-s8M~FP?F8omB`l&Wm5>
z=$#)i_)%eoJ8<%-H!0#3Mw(hG`xgGIuK8=3GO{!07(<s@7>k~d`NtS`h01$jszIQ=
zOSmsOXo)_PftjsTE~U%O0oqvq04-VqPLisE#EE7;5KFvCB5_jD{V)K2=C0G9pjYj*
z{D!d@(!5Nb<-yF-<D)M%TrX#e6M@noS=2=1-tvhd(DYlwQ5Y^!3!Lbupq;T&DGYjV
zKP4EQ=heiZ@7v?mG&MTI`^upI%l~?5bfWi_L67@i!`eA%kpcgU|1}gnhW;G=47-|v
zrRPUa=jEBdXy=x$)t@U+v<vFw>SbxP-|}+l-#;6!%Q`)BC7FvvxtYSOtYN;!M3k!%
zfG=s>yMO5%5Rx4|25*w2iPOrkGZfcYh7YP^!r0<GbwR1FgBz~HDcxOa!qRZP%$Ywk
z_gt|9I^@#!%8!^%*yx!h<hs3P33;85t=Sv8t9Na<gxdbmu;-<iuKduFnF!6co=l0=
zBIYM=!d~j}l?_yAuwj=K6myRq9rbVI+dYqw{W1I(Mb2vueFm1AL!Wa_+#K4^K|yoq
zi<Z!5I00rvS6ZIP7HIqd1yyW&1o0D4T=8eJJS*`mt~?LXuzq2p8;gc@2M92f+1-9}
zgS7?c(_sP>)jG9w=Q3~dOk*(#f$loz>IZ#^@obeiGiX{h#v^nPzC~vJz(^@Hj#)k;
zWPgg#Rkm;04CHibu65Lm9hcZM#T}>@n_TbLFTILU=c!P$eT*YRMZ2#Lz<zdT<Q+R0
z9=min8KbYq^%rzzBwnJ39pYZ=k9`2Li67wa7lyDC;>xjwd0wc{!aO^Kg|TCYieN0_
zj2t8Cozb))N4P)vRAKlDqlw`;71vceD@Mr{qDVIu=Mmb2wfQG(W(+#c*YWwusj}-r
zLdYeQ1u%-WvA0p{@RSYeq8=>YED+D=sP5cO1&J7M?Dt3NCdIu5+7hwYho7$D*T}$M
z0L;>bdO{;z+n-83vs1|r+#f02kFzpOn=ZNnOM%W;ptl;J|89tg@i<k1{(CXO!40?;
zL7*@t*9*qUz-4Lyqwp;{(`>}7?)!PgFJPtcD^U#vv)ooV3}%T}0)%WhHRO7fFzp~g
zcVgSPXU|?~U=qgDp+4S$5exTp#QI?R-nd<E7|2Rh>-_T!17>pyf7~}02kQzVUiJ?M
zQ>|0KTwzij%bruU4v_SkBI)MgU6CZWP!&TZTV>np-p@Lgq_=MyFV*)PZoGQX^0evI
zwa)TwK0*CcXWh}=n)N%Kq^4rpJ=A_)>BWpkfzmrv54{f|h>Q|@B<hqQl_yF2@siXC
zT;SZs`Hm9Ir3?l>Nt@pGfvVNPXgVd0%4Pbcs606sa^~*|rZRn$%2%bRRmbV{)6F<J
z`Zkm|afI^4Kee^Q)>OO{@X1^;{eh++eunVc0jcUddUSqr<~N-ps#ZHUr}b#NbK<|)
zbD~9yjAaVYqsQO!do-HSt#%&AkcufFed#g<lHFN{WTH@BJHo&$6PEeUo4_12FuQZT
ziQ8>I+l3wkeqlR>&NF9xBbG9?&NiACdQu3T_d3w-h}b!x%2UjSo$v3^g}ghANmuml
z@c@{HU&HlN^iP9Kf%<&s0@@4{pv}2DA;iwMB64)9R>IG~Pz*)OeV!DCb^n&Cj}QoG
z%b4%=%qpEvOlFU=op(?FMsDKlaCTu_Km+gi4FCo9++UJa=gd!~1!Lad%|8TgUGAe2
zxrK(mKo%-zEi~!#h|xx!HJ%?v!9LDHbytAuuGV=`&Yc$LTF1pJWK|ZfqT_U8qn4&S
z7V?5PtJY>U?G96htch0-wSOhPwMJ*imHiJY!%G=qf=fSfvQ!T~G+wi_Z^Sp^kuV?%
zsRN?ErUm#hCBedLA2OXp%e04>5g46ZqTaT;Ub!?~Np&PkfSQ>bm*YB2n7VYPHb#9$
zeeK6h2s^KQrUj%IZ=~}BfnQW$a8<?Q1>NB1Bar3Ha2psapf(-rM!%(AOln!u5a`9q
zE0af0w-RXF43PHq6PWLV(EMQ0Z%-ap+<{lx&^xka*8OrDl5ldrEK;rPmw(N#4#HdJ
z9NpZ)J<2qLE&K9J*)EHtKiMvePWI64^7}VZv3g%t#iz3}xn2HHz>@7U`#Dh#;U+xK
zzHV6Y#>@jU2?eqa(MxepJG8sD7C!Ln7nLtSCrTx$ZSsdeS?yf)ewXA`t)*!aqfwe%
z3N#FYUxPV_oCwm5Coa4#d0v%t8w*UbX~m-wz@_gr*=DlYOzt#e^+=qvspZi9q_adD
zR9}4x<d6F61~*I*0MV;L`u)$ItkN0j-*5w4+g#l!uT0!Ws=;5KbK0Hk!RHOLLQfmz
z2^CnOHlj;myO)@~%Gaof;_UfA%fDotJWWCdHYU76?h_Z&S)=!mpy5(`Xrp(%j=HJR
zzBqr(ly>&Zvbzekja7AAVC5{?g5gRw)P9%?krTbDRO3?X+;|5%!O%tnkOW=2#Zw9z
zH}F_497Z2F0|1jWD-+oVo-Nt&y!z_A$>cNYyd#bGPA+C%A@|JB4K#@-V>)@(t!7RK
z8s&T<rP6zYWao2an@Q~QB&(?OqAfI~0IClePo*bVan9u?IT#V;&R?KbPphX%LsLn&
z3n7E(t39pWHklA;^-krKmHPkI>gm_Us1N)=V~6C|2AQf&E^vtUX?%hGi<FY>Rla(f
zv`S~*zY*?z6uM85r2M|N){l!>v$4uqaZ?i39CE1hMp{1#?PlU;&7aiFok)E`d@IOD
zmIAhhaG4_wSv0u_YCb6uz1v_$jJ%U-fyS@tfhgu81C(~>Ax%hq$1qA#ADTWlAOkpW
z7{uiMNh&nD%o}-BU8b7pSiX<Ab&E{}vXinyPXkO}WmthGIhK_0X@}my-6JWIH_(`n
z_Jxq2PTdoAU*lt!Tfc?_)S0Fd{b#RI*v~Q2lL1v+#ER#FG$p#~$L#uzqPE;3+7R*M
zPDxKQG;*u242WD|G(+!zDWe(M%@gQ28|LX|@Jv7Ki&0Ami)$AaSCL|I;z?yUEbgfd
zIy8Xe_B7bM{W^*t!L!#WdWJQxc#U2XwY{(GNFVgSVtVk4RDSdfwx2RJ&{UU7LD%pL
zKLyi+aj6va4RwABN+!8l=(WRIKh94<$<&*aE;a>8CDX@?wDZl6%Gk@?fIy6fiG!UK
zDK!z7u+tTvTB2dPoG}Aq^EUDAWwNd6@=w=u?&*eSA&PBXeC3$xE9;N7gIC(sbCRJ~
z=Ur|Euas3DhpViY*#qqh=UBm6sR*g~a=3{TNuaTUbJ)#3$F;slX?4c^k8!RJ`8-5o
z$ySmRt#mnFHcJlc(@*xL6x_LbmbwyRPF+dqM4O&Bt+mUpM6`NWF8#KIJFUtq*<=s3
z$Ir1Rtoqs-f4N;b#~y!WOZJU+zByI2+BuRNe>qKLB;GRe3R2iT`EV_E)92X1A{r~^
z+z+1-c~zCQT(7Df1#nb*1o{gS#q6A)o(-eV#HczbB{}XhYL|tX=SBC<j+dXCnUQ!$
z<@IU_@OYzE-$o#kNy89$axa_Fxku!o%Y4BrC0`&vrNL8U2Zz&^Xr=5a!|j@3Kvh&_
z*9_seklzA+xhN#3&_1Lif%GT?DMsc3X>WmaptSejpp|qZ&q_S6m<Mq`d(sFX&XMK6
zbB_@f$=C(nv<~*SCygX~FG!(t&+Ju75nb=A(!Z|xNBy__azpoB3ecx4J8Q=JL*-HG
z6NxQ~SE){E&Yo7rIDX3Y&dlguyLzOAKinEGn;-)oxNU9I{>8_a>~Gu@Ii|uM$YOBY
z+A-0*8;;_`QC4_@s<skOaRc-t<=^<D*kM=8HG%@kmYdkgo$<WLKkceQR@8l5EWfF{
zyl$Y$0h$@>SJ~k*%I=F@mz^2OE@=b0$%39f)+EyuAF8DGcl@>wr3bHjQX$mRt-{1!
zd(s3dJj1>;o7mftL9v5bQOB+Xy2u{C&P3eqO`ZXMqlqUko8eZ$Mzrnd4tnumN`C(z
z@QVww$mbqD6<vUwIxkHduR?or8O;Xlayd83vew3~O=1Bl??6`Mv)F;`$j5f&h>|uc
z?MpS_6@*0(*p))XudT8N%IlXj@r1v>_#f~II-;K=*YfjGY+-&@#IYx314l0pSiAWl
zD4}W74Ij_8%g>z=+nxC>@Sh0$0Je$yYubZjh_okA_lq4E2sbL9grLfRluw#brhlcH
z8q@zNxfCn3D`oHlwwSEa|8?n9FhZdL#!v0?kuz9PZ)-bAuIu_8_2*X?e3oMmMSWE=
z1X)%)*RBW7H&j)Y%?-Jm;EG-+SEcY3tItI(3@v)|+k1~~JYl`^r{sI4dGCf_Y+j+?
z`n;@2<$@A^Go$aCO<UAnULZVklSkO1r+guPqkKa$#dv52^--Wl<ShPXNB?B@sCDsj
zWtch{)G<KV)<Ut3*_J+NitY=GFclHz8ZQ^^w^nHy;KjU^&q+P19f=m!Y97i)O)RUZ
zlU6VM?OXeI&VpfH|FmQN0KIOP&q*I3?b2ZF(i(OvP=Gc!W37`Vv_yQT8SB&co7x`R
zz_J1zJaLW%^^^_KX(Qlz4CFcKi4WhQ`HK#pAFsO}d+g=SGa<<`zt$Q}S8|+c=<pId
zOen1067;Npr049|q;qrZo5gUf+|nOAELP6_6DKLX*i|zAgN1UV`)0=`pPQv$q91wm
zMPuV3%IL#BeRY8+Tj-uFlQA8Rd=a}gHzV>%ygV#pX^#g@N`KwPL#E6=TQAs{DKikO
zcbyu3eq9WhlTv$691ci_1-BSy$U5*LQ-<z)`~p)5G!o()!CobF7a`EaRX~#$X5A>i
zI^6jROFN6JXKllax00JtG2_AV+O*Yf(DFyv&27L>6}|1Ut5LtQ&PnIf`IG2J{9OH#
zxn%xX=szfu_=BH6ZGI22%X5Xl93xzDxam_)Y~h^D$mv2RW;~WR(D)221w5pzw|{x7
ze%YG(QZ_5qf9qYATTvCtq}>X>f>&8t0MEnKR;Gv_25_I>sQv~`HO6@RqXU4>M~BJA
z%9^l)L%_BiPlcUDg{u6sgE9c-(;o|r>TX`PJ#QMpJ%d*QAA-ja{b7G5FJ<OO7v*GN
z?o#tnLJo_dB5!iAk1&orD-9Ib4RX%GQy(ix-R>16IfavQG7=vr$E&uwWG507I*wle
z;+*HHC25>S$sdYEtb7!m=!ef^!Wz7ixBt%oTJy3!7@a#N>cJ2oi4?55u5eg|+c`U6
z$)1EO^6kI<`5pD;1LX?)geKe$EOAL!{hG)--!UXU#Dq>isd8>-*e;(Ib{;C#=FqvZ
zUMl57i9-3WNqj{<r^{P1ACom6A=*Q~n(rm6NzZR`3&V)AvTRy!*09f$YZx%G{6&un
z&+VM^6`iv$m{#cw@~c`k36IhXa9J!&uB~b=SNn3q_IQBaH`WKbJG}{X|Es;oDO&NH
zrsC}yLo?D&{igEU{mNI_<=DGL{w~lJj`N^f=%>p1oQ91Qe#O!~h2KeO`Tr+=(?bo;
z&^X&qWy9U-3q2L(k}Y!b9<NXuv-D!Mf55jhaxB|Xn(ni|A`f31M=&?+iacxPkl4md
zt0K?7c&hlRdrd#<k$fgqa|4+J@!xGnBVJKxhetzJR&9|TF12uo9gbMF!|m`wt9FDP
zo?z9EjF*khf4G7WuCtKX!jDv7d^ySdlwQqut9DepEOH-D@v?<QnmnsPempH}na+%g
z3G&m#JvDJU2h6e=5xd9!ztlmMquiwtO=6Y?n(pnI%egt3YuT@vzEV1r9~KQP$1N3@
zlg>V#!-fhq@3txm;uXpWI9Rl2YPj;fTHiELJ77789!Hq~D%aCU7}Fk+)6uXqz8sXy
z6#Gs)CK;>>uEPBez^%uHamQnY{N+DSa;j>cMkSw~;Hjr{6B8$`Z|&y)aEU@HkbhMB
zMLYxi2bxOB8DIJv^PL-_VgnmrDnh0F6DY4Ehkg5_^0syHIg?EmOF!7zt7t*acen>V
zqL-J=<e&|9D%q=~nj1EK5f=^^=>@q^9g46zdvQUXGdGK)rWtC+x-)Wu;BrbqrL%3R
z;+U!f9N!RT5`S}^T0>>5BPH_WG&y+gYs<lNpixW#JsKq_tFPWQV=HbYs#fG=Tq;f|
zIC=Mm>A9i8*^6|Dbg&pHFp}X;RZYt@87_wZa(UAskalhtT=)ax&Lz#@PW!|(ogmY+
zV%n0A1-W78#dEYH*3$c=;(N)is45sJCbwdjJSkqGD+v=s^%Y!o&#rc+dgsK~q1rGP
ze<;qVJSIQ<bAL)rmV)8FM;@)Tvma!aJxtP_eFf&c&x9O#olk;V!Q<e+t9nR|q5_Tk
zNKiR8(D+9$&lGH9n}!>xgBVM9SUsw$s<~fN>Abm8OlEPX#|VADuP%!oal80H6d>l#
za@<=@*@~%xJTddur2`#F5vcJOkBzGB6GT&LP6KTx7d1=mb(-Erk&}=MmNL1Vc}r9^
ziK)6fNN^sMfyz*AD~q}dFrCi7%dm4+oG@~39iO0&J=B0bdp_teZSFRZ(y_49lKL!W
zgI&%eIThk$wZjtM$9Z;5p*;g5CkLx`J6goz)E63~Mstdwt}Z`<tZMdFaWB5YARp>I
z-jcE$%ywAOLaV;OszK47>yf7`&glU0Z`#SdVKvc5l<K;E8Gl$vm3rFVA;3hjb%25D
z`KS+rDP<d{o8s1i`IrP_yJw>=&;ZJeLMvKe$>DtxlpcU$))TKik+6t$FWASECkucb
z#nqIaZzr3a4?l=}BsK?C&NYZRGU3}I|B@rXRB!XF8Oc`eKFoQb*dudvN!__rtOm!r
zenvjgkz2kXGvm_f;J->3gG^vz3e3o@b}D5r1W&~@xy%0KaP{dC7=g}3M!MFBcmTRv
z@GhOq=gI?hqC5RsZfrhZl-TIYv&sFHh^(BC82v|5p7+Fue(_MQNDnjI7Z+z{=-R%;
ztnC|-7*rbiD+%fQga1}v<XEkOD3&63{L_dBFKabFp&BC;JWHD*6U=by_?Ci~eE?2(
z7``Y+k%7khnI?91K|FYsOc-n4)pl0AY??gB%NC9ND{Eu<)vMOZf;qLFA3L}(ULFba
zWZ7+GqWvQE4HI_SxTDX(ZuOiiDMdc~Kj;_Mr<+X95-;cP*BRzB1Mj+dnp<-yxrtiQ
z?TP0QmH$0yJOyApcr|rpD3Dj@PZS{K9U!mlCvQ_b`cL$L%+KRPtWA>n2cXA#%^&3f
z%6t?kM|XqL_OfN9Ln&3bHIUTd_7Ca!RLkM&0_(!7lDJ$a*z>_WEH1l%d1CdPkrbJ;
zia*?&{IkI-z*aA;a%_D~q4caSnWwD98bPrt@EW``=~9S&lnfqD&HgIrk9-OQAI16c
z@@WRe2DjykTjVD}ESO8f=s*6H1X3{ip1!7lY*CE5mxI1T^_j{~hOlD|?Jn6#7^`SU
ztu5yib<QQNdIr(dws6sy^^3(i%R9SYaxeqqy~s!7I`P4`c<35=drJNw3t)BbDc^w)
zKS_x{wM@&jb|l`>{$lngns~dPsN&Jniz;5YQfK6TCc9^`uFk@&1HO=ez34^Eqr?k_
z|G__CDy$j#^Sslr$cYV$3Omn@3~7OT@33kPI499lbNsXx#_Y_NJGR1y#6BolzWo|4
z&kka-RParD1#-f(8fh=X(h5%UD^Pj9kal46R?XLr_)}ahdrXt>KU|q)L&U~AwZDz+
zP0N3i<d>z<<bUZf`PJUmv>@hEHJ>@MQgS1t;wmtDGD2)7S7fg?C)2D>V#aWYHlY$O
z0M4+-pezVZyq30K#h$lI{Ss0wz5c9fd;ZmE_hn$drT(yA|0CV%m;Ik|c-5K|*yW=D
zdN6c>?fS}v=6b%2gg1>bQ?SR2V&zEHe7?gA1I2vV<Q{)5oOC)-2s0PIjn2}(=*|O)
zH^4vqQ*Z9|O*8edgJsn5k!fbQX+{k`cCs_8wJ&7P_}1wNAESm@>r=O$+KfI@>@#FL
zYxbXIQq$*HSpo2y3l!k=^@}A?RUEQmKH2oHFW{o!{>731!T$^Wxinj`wy_hnM-O}a
z5R@KXKN5aF-b&NonDtQZBKC=G>a;eR6*iRDH<Taw2r>hl-mLR+p++MM@;)U$E&{Er
z8~`%HEJQe=MGK9x4}MsdZDk@6m23i*M@VK7MF(hQCGIh}!n>&?ZjBrb`GlP(3bdyH
zz`0g0s<$#rHfiI5#ve18C}fuvi9|Y0-i&WRxw-^oR+cMXEOmY}KAwM2Zev+5gVlau
z%%92Fk8%JK`Z$7qJo>(MpmzrX93H%+Bg)S>%3CCh;sbn%2N!A&gOPYpnKy_yLV<m9
zR!>qRk_w3;&8Ry6u7>)L*)9E&uhzVUlo15k)mPESqo}<LpT6yn!Y^TvZRC-9!<s{u
zLi8Ob5mi#Gfn@m?k2RVH+Rc@LaEs}&0@G)WR;Bm2#Gb>%##8+f(bLG~+kezKKWF9>
zKO=aROf0lZX&}`)*ZiRyNcQy$WtIUF_hk)8G+66=`IDYpN{c|t&YwVp9gJvo##N(&
zRQHHhWeG}+y#$}_3nP_I{SSJ2Vz!4r_j}CWbbeKW{!(OF2riT>eV*ZB0LkDQH45V^
zlthLp@W0%Wtur*nP`ds(NzakVN{`WTfS4S+gWvBmb~@_)?dnC0(uv-Pd&7;>24NI-
zUr2h8FL`SJ?r7EiCAOqj{J^(Yyx6Ol!d~3~R_Tm<IEALjJ%&=!$0Y3htoxXF0|K#x
zoh2smzmv%rpG@9HO~W|3a%!KB@3i^ynziM>&zFwgSWPisz5`|3u{#+Y&}x(i*}bzN
zQu!qRl(apWuh6z-gD<n{1AgNw=}9I#)~xT6D*uvoZS2{DY?3Jdq%JeVOduvR%U&P_
z8n@O+D^>BBR3h`OC7dmH)6VW|Q0oCnNfN_G9;%*G^t?>70nf6<_UFRUep;I3mGP8H
zsmVz?$bMW}t22`V|F$Mw20&EO@{idmi>oW%m6cR(+R{VOE`}CncHT{rH#^13#%(cK
zxt|IO?dxT3vT}5GnVs;*ClwaztaT=>WEv}eWDZUz!k$4TC51tj`fa!OGDui!`SN!?
z4Oc0ODxHCSx}vD*U#6VBMlfIJlxO$Im}%S6<J4eOI%{60L%LB;jiig_$TQ<4DfQh9
z3l(Iz4||(xTPm+~-tCd9#UE&QDS2uRGykXY{lCorF(e;${^Q)8#*_yHnrwOOO0(gd
zZ==})`xd3yt&#Iny|Hf*NM*E>6uVVbaaGPBx|2duNt@8D@D8>A!7s{7N(70=dG~j)
za21Y1y8`rF&u;^$&<BVB0sxT))VEEdSXMen00il<p5kAXMuf(aRN*=GN>RoEk8YBa
zr-3HnJTh$zL7;y_IE7;g$+3i|EhJ_hg`M?JbelXr>rz_e9@F16{cw|Ktxv$0Y&Mgp
zpJ8H#%2^*X)4Rq!NuklObG+p4PMLB6NP6zk-A^g%=Sk9CC3({5%aiXSQ^k;Ce`E^6
z2#7<8VOLMX{P*EP4LGdQU5S0mW3-LZ^ZR3Nd6cL6)9jf1+P8?3G-)xU-x3nvJNAMc
zFeNRAteBKfSq|ATDTfX$wS_s`(r=01(+%TIS~$$y{FFLO)8U@y8)%fp+h?n-QCN37
z1o4%9j!BlWZ(r*S&1?sjR}L5m)Cs?Th9kyCz8dZYRl{8%i-u~Q{=57Oh+*g2t5lRz
z1npAsH#jZqyp5C5ZsPA+v!61;Z;q$$Q1REC4~?XvwDx+7+E$H@?0IDjOozFjn?)q1
z#n}TF?7`n9HUYEPb#P}avCXa+&H`N_;wy)W**!R33Zik0j8-6@SfENsx$7UC8g@>a
zjANhRRKbm?yi^A<ej)nxu$a9Nns2z?&p~^6T7#$gq^@Wirdgu2>|)p@vtO-EWSIqi
zwZBfu_o^WJJgFe!q<P?i_fQi7`(pxoxu}CSxxYncZ<h}T;7$5|i@q1|ek2|U?W(*g
z<YD3fU*YW#!hD=8RO<BhKY8s#&niy=ZyE|Gl_A!25DXBx-xWiZ=-c-Ak*puLiQU^N
zSPboq9A6=J>U<gV=?#N<A8d409)2=`2)m*88+S&x+v7(7+5P0}mFQnF<~2DhMgbZ9
zEYVU0U{~kW+LsnpJ3qrgE7%dKFak*-;eAb)*`cTGY5v!F9QZoY$JgldAXLuW%DpqU
z8;W#nHm#TAuwzKHE2mXCKTiKTP`=9fT($pIm1Tj(1}0Ti*c_rs`r{|2)z!l<b!@7X
zXx=U`nzwS%P*&w~4k3qw*QS>|$uIf#P_I4?@#g$T23lHq$^S|p4A{w2yubQMp1L=A
zKf*uV^!AHtbM(1q3&E~_yqs4?3PeFTzc(WCCifxu8|DXyvg4Tz(HA*bHT^6Hf(yGg
z1HG#JY%I)t5!hIm`82y8Q?nx%yln@CW^a`a2Dw{eHqCo~%;8@sSCP*O=<YJ_igtP5
z%sUfM+jpMh1#hK75t|~naR9K2%EHbL`FvU4^h?o{YkuaFM=m-LQct6)R}m@i5h)X7
zOo$37qE;C_^~_;}C)JQV{Zg;~g<5~E)_)bxGG7Y}IqGmpeZ%<f%^x+!i~9UY(Y>!b
zx&w;t!JvDF+p6dmzSEzXJHvf_4xo+CO?;Zv$Hw`R+Rvo+D`(l&Sc63SV&2*A$q&lo
zh&}{$!o-eT5MW~s*7t%a-S5J~1@-Nl*00VZPh!LBzVh?jYB4EIJf+_E6MtEqD{l|4
z7XNgK->#O!&ctt4%jsX@Hq{0tRxl{oclXr!sR|{*Ulgp6U|&{N?PL+p4@^N;gSW=k
z^>@X3UNuziC4%sv8o2dWr5E-bfhO5`tQK!L?wLGU?QSVQY4_t)hmy}?>~GGEK2k6c
zam}5LlVIs$ATmfOdWc@r#;7mo87;<@xko?7n(t}*`il^m%j~-0vfFN%IAY8?y`D-u
zMK7igIix4^bCI8aq+@PP9Bv0M@~cyq;@mc>fR|iXROeKqO`*G1@S?=)hubfy4k#j$
z0Rv4m9++CRpUQWBf6OZN5sQ<WLMGmqyG;3NL=bi+a1%l3zAYNE=Z|1Dds9-m>9jbv
z&N;<Tlmm0&Gx(s$mp~jC7dU<V#OM$0`Gpv*Yybf^vPxZ@&MM;LUJhe6d^XyH`+jz?
z%)WXgIg7QEW=%YT9X3@W50cwJa-{uTxsfC1CPcT{VbHrn&BCmC6Wn3x<HsSFSez7@
z{^J0)%!^k9w0$K!N`&CuiENQ~llZ95GqF7DoY~_Ia@A|wZfJyKDKxXf`zoDcA0Vzt
zRg~G&MxsH&1Y7W&UsY8Xc5?j;(O=lduzbDEz<Qcn4zIK?ksJAj3?qZD;<$$Q)api1
z-OF;gEO*<Vxy<XlwBTWyFuPzHrg5L280~Fe#$DU!CUpU1&79!3rnh8`-5jU$o&mi_
zbNU%z+^>ZnOvy|3?*hNt$VdT5+;T?;YOr^fL0xbgMFO_N*kDCJwkiy{yML2!f)6@?
zk2u~uijjVNKHcv}f76d638}!0=x+f3C#FLp37fH;Il-O7i?1&;@(JVs99>k9tY;!(
z4DPRk1^VAI>;EP<hwXGy9!&AC3bvOeTglkN1~xf%k8o2g0_k%8w{?InfHb08kzlqr
zJfMgJK$w`_PeyA~=N@H!DgNl`^Wqp3TCa*(ni@NVoIvABDCho$556ZtO4D*7Bh^Np
zMl2R-+P<2Jg|~LL{<YOmdRvWdIV7|A9`N`LSdR3v4mdZ8QX`0*7CDZ~tfH=1KqfIR
z2s!xK@S%^)QYYv5oL#+;5<gfx5=u)~f17(__ut3)g0N6gUXsIT%iYU(vu|8PK`U5j
z-6aq9T~bfb(jR}WP{N*<i`?#Uuf%d+UmYx9P^98=sVZE?{e8KNH;Olr3#;?!Xs;SG
zy|{50Xgrz}5p(4@`)Awb&eUGya8t7#-7C`tBz-2-71}#?T5h1pk!Mb|gSl3DUc6k^
zjto~W3kiLSwR@oPAG|3}ubS%Pv{B+Y=@E}7uo(N!Cax;fS{te(M;d%jFSI%wF1vPG
zZ!n{980K4UcK1)veY`suZ$X#ZV+9&N=Q(zucc4-1SYik8*DcX&R@w6kHHJlB$yzOA
zdt~fD&q)55=>>ttzwt31ly%Z4o5(<KpcqdXMmch@FU*!uK#j#x@s~#g8jJLS^5$0J
z@Rpz~FBfPgxw5619?}Og-K!5hBco}16j+xrkeg}YFbC8fmCg(Oy?GF5?8j%*TI4D!
ziTo(`WkKZo*2dVEJtE(YeVH36v8zSTf2voFxgS=gLm5j|a~CZ#+Z4Yn&ylg%Cs96~
zEMe6(ET+~zcPFT~gYcZl9pnf*zy8u(2D&giu~f!aJorb}$5vkrY(KbRwS8lR2Z+_a
zQNEN}cj>#nu%bNT6Rh4D2sFMa1AD-c%VBiP-NLVsGAzm?xL~%h#9C-l;B)@PZ7e?c
zwMgFT;T{7O%#hcs@@=#{?)j#^D(Bq;3bkLZ%l^UR7q6nKl$mj&Ai1A%3EWK`D{sLv
zy3blN=gJ+T2%NS@nJ1!_XQxT3G3|VFvQc8p8);uZA|9LoqBF*P5g7_Pj{(+N=U;dv
zi3dl@chSY2@jb&TJ0r(ww?}Y~N^^|R9Jq1IGdT=ta_&RCUOHw6N7H7v`@qVJx_=YP
zz3$&eCE<P9gfp^(lMa(DoXpm1h?1a;K$64ws7x}h*F0RCSc@BZ^W@<qzmN9v_Xmp5
zPvQRE3|&!+sa{uNVuYRc9kR(*gSD`bb$|Q9FoOSyp6$tgg6>3405jOzPWH@aE#45v
z*K=X(1R$Vv;*~i&dS_(JnQ(q}#+)#J>|;gKK}Ymfm2SQzqM*NiAb@yV8WA`n7as;l
z(WihL1LSFk2l5;bNMj3}Bd{jBubunBUfF=iUS^UN<mR4&J$n^^<L+7kf5yX~p-(ly
zko))m)falgKMGWt?kK~q=GsH_V-cpJuH36cEmP<8t@gz=%!TqTESH02s<Y5_#~m^K
zKjJt|B&k~G-&H9=Fw6RaoGML4PfYwODNo@F;VH5KH?1Ej@>HO4A^1ZA+^L!5M^q9X
zfw+B;zPije<DW^fd!#B`8Q37=;AcYfRNCd7RQtp=75YTvUp(EY)a%roleS{16T2y&
z(PbkL7W(i-5ZXL}@OaaKf~qPy@I|H9fk4yEw5dYjzwyz?4E5Mf=ripgQA!NwNy#1>
z;a#e&`3z~;o>Wxn3^%(VNMenO+??N*RXSTyLsN;hKJf>7SzGG?cfH?s^h{qKD+@dS
zFi}dZ^%@WnK<vw~NZMkgG`@ZhFr-lx{*H9z&ahcEjr{k5(7KWTq^yYjw<ODoW21C^
zH~Jls#c?6U!Ju6c0q!G|B=aY6)Kw9YVE}NuLJT$r+A|l)5WfT;j8~Wg&ZS*Wa?br2
z?W%tA3ogBhC(0JuD@5}x>wmoz*YA?aUMjj&a+tHAT<lll`biR{X|*aP-Eh@uxTe;x
zqU+>qFljn^GEoI{jBO}k!;=Nh$x@Xo@x>pd#0_r>PSgrDHH>z}Mak^Bb4>jg%Pow#
z*jkQVA|fNAkTCyBVLhNBENGArj`8s-;n+*=GvJ(I-~1bS+PYXdf=59W!nfiLl1Ki<
z8zhhX!<IQK&?IkWgW8QdtHE=Q7(7RRN>HsNkgtAUd9YnEhfm$hOiO0Fe2`|dqPa#q
zHoCV?F<J~eXa3FT$FG4R^uss5QQf{Pyiz~B^uErFM3bOwW<j;{n^n4Sx?u>=>Tq5X
zms}SYxCbZ@ub3wNF~n#Tt!eg-+%c%n73Yp?Kq9quy=NfGUOYlTfT`OCwayK<a@)Xo
zu83F6k;>y0v&_$x@?$L?f;p;uakkAh{ZymS#&)lb29i>GZsVqH7iq>OeAORO(5g+i
zG2j0G!7RL@3<!XFg8WRw5?sx|d(ATIr<j2sB!NXi@GG&f_WmH5wCp~T<a<pX)|P7f
z9V`?-_#!flCJnKQ1+!G1Fe$|LR&ba{_u>tO{N+DSC|SKH-(cH%OwGF?JIyf4%V73J
zDLZY<!BghI@uW*$*tq9h+sNYvbTQto{9aDRbkqfP#sK=l!b<1aPh}<*DVz#1;AYdR
zs(iG(SR>at8+xdm<nDuv{8NN(H$j$x2~XO%%vfK|EZM2oMN(E+dc8$3R)I?XuUF(`
zT#?v(nCch@(tk<%G<$KOw--nJD%qKoX51s8@2=}DI&gdjwMA+;$iakJMuq*qqw_=E
z?o6tzM7hwH)tZ^ErxzE)g8?V@LZ%hw@N5WcRbf~hA~~PGEV+sVna1aF$^O){IXC)H
zI)VYr{_4&e5epJq1q065cg&1@KDmEZ{XE9H>FcDi&)wodC!S;8@&pjG$kaMNz;0UL
z#7Z0Un=*xyTNFXyEC9~@Fi@x)q{)CPzG47Y4^M!i*7@7p28tEvdsQ9*PE<LFBfgiI
z^}AD;ISX}3wetz~);?xVO}2=kF($GYr&m`hW_G^R4Kv#7kk_80_w$kxWTZ$_;}>GW
zi#0VHB+mM|*^QyC-emNwcMqd~D-i$Tc;u;bUO@2j5iwi=os<UXd;!$lF5yBzgSX<S
zDWMrS0H|{YeUO>KWdnQ;ix^}tlWf=t?L&GgB&uFUWQ)QXFtV4W>H7Ui`EIDr63vq*
zB#H0hYA5`bLGmxV!cXt%Wp0%-Qe+Wt2<1wLjv6{ZVHMTRFE=Y9jc?`j`*z;`hC?at
z(nR~~iQ;E+qKH!??2qL@HX*gu5>^xEdik`{S%;On(|(!Zv7wHHT#twwf8_QwOsmb_
zHnun)4-~R1rF@-J#0;}*O964oI=SLHrhVSn*m*qyjdzj*I;<EnCnKLHC*Em>K*AH=
z+QwC{`i`u~kJx-Qe-0ugde@bHottNNuk#vlONqbg%So77%3_o${vD*faHaDS^H@PB
zG9WayS+%%oIgc*U1Gh{tD5axR3!GysN~3q8#)#*rNn}NSV!0;QN~;&+QyNd&#V<NP
zlD29~GuvqmRMXB6O*@%y2)C=1O;(>Y4CTnKx<+pOG^%V0C7~XflxNlEqwZo?DbcDK
z2h*%xy+{WFtTbIp4r)Y{6DI!&Z*B#DxGxN<{<LIqX(y`k`41|z56$p#RNOvJ5V4>I
z<pJaIL+vCLG+!$Sm|0qkQD%WPv(&wcchfp!*fY>5%6YBpa;ZytUi_kX5&tP9pgqTi
zlL6$m$4@x<h&>PK*Eu7}EA&`V3f0KrfY3!iT9UgoN+m1djvn2p%;4Fx;x8Oh6o&+t
zim{=d;eKkAal}Uup{-MF;L6C<8`{%5fH+PlL_YiUDM%xO8~f#>#|9@Y`Xn~CM`SO%
zrXy$x!{0vgzKg07Pf~lFb%xA$b=iL;xrv<7Oqcd`JNh}^lh{9fWM3#^;JZ{QG7nY0
zL3(1lzduacKfz?91Jd2e8+{5_&Lgh#F0O&aGgb8D#I9?Oi8(!>hy_P52WAe(PWj29
zDsaj)SCu^8H00nSGs+=!p7Sf3wbr8pt#ek8F+Es9qMbpqhsNbx23EGkb44oquM~XR
zzr&u#scV8P>s5Lh`zk9kB=%L0$T^dvuRF6Ltuowpuo}o=)=|_q2N^nT*PMQ0&6p=1
zwAJm#J#6%}$S{Ipr>~!dC8!5;xk`<<2~>_@Cq@$#WTsSe9N0fn$D%`^RXF#LjnS&L
z!TIxN2%CHJFzqD?rY8Qi5>E@SC@ND0l|42t6O{#Z>g9?VXLG_=?0BZ$l&^Mb{VEfW
z@Ltkc>kRYq|HkA`yqv<9^2b7ruTkynGRwJ4x?j-{YBJP9&L992=Q!-ZL`@zoahH-P
z{jIFDk3hk;H|)H1ED)j7S$&y->?~TcZzz;LcSfemaXT8-I_LWNByVt@-}kkDwTgaf
zkLm0;2+Pvh=tF>A>-^lS>V1L}&isG0y$gI))z$EwgaHBuPk?~IMvN9KR8&%FWeCz-
zNQfdfAtvA@Xw~|pw0&x222e=|&IC9)45k+^wHIw`uWD;swUl~EfD%yKBHn_4#un{4
z4z)ooAX@YN*V^aIBmw(A&-Z>``;(m6*R|JPd+oK?UTbZq;Q+FMyN7Su>?b``9H6i>
ztxFICbKOLN0eg$DUQOKx`};u`GXr}OR`p3P&7!9`3s<lejCa<?X-5#SpTFTP1`)wV
z<t)!b`EW4S+?W}~(OEB0)l|w{ptev2XwZLOEKeBt7pUj+1NHRfmvQz!i*Hcs%*{i)
zDIq3rxQ-W;s<UGqUq-%az=4wV)3%{R2N5`@-*BB37i7yA>v{uK-&_d<>s3IfT?#G*
zGEyK`UZ-<~`;FYrB`UwnyCvGLD6dcJv<X*=PP_6tXKuEaMH7?*8V=11+zWoL2cjw~
zegYZJ+7{X^vGtE9alE98C@K4&r_=i@_YKZQIXbG+`9vOhl5OnB7<}RMBg<%?F~$JV
z|5?v`QlMu(k%1dMvys1jW%J(wO!dgG=m&b_7x+LKYLv}YD4SVm=!h>79WlD+p^?k!
zv|bDaxvyI2E<J)}t*l3@RbtBvddnvVT36Mi8h%DQCrCTPXeWA7yQ8XLOXs-V4^uTS
zWK_`Siwc@MX*n>TB^~K5G&0>$OkkCc2C8?31kV>8^rv*J!5v0wJ|(;iT6HFb6X>45
zGYhDSNApwk&-J2z?h5qJPy8qSbE?7eP}1?&KRqsRf6B|jW=*M3q-ochc%MNX{u;^M
zyZdzmz+Z(7dfi)qNA=7p`8>70N>H>NfMR5PXUY;AXO`HB&hK=Ip@R877zw&C^Q-IY
zfUd7ML~0O^Eh{d!1xTjyDG~(`5@)-r-x7PC9~8d~vyv-VM}L%`SBbl!v-CPR?SX1R
zdZL`Aa8XlMhO95d&q90Yb<*Sy{CR;v`PvJ!zN%ymuv+Hk)z+BxakjA`hKrZ7M)XQ)
zz#0(|mEN4i*RiBgk6n_@@~f$KUs$OJzSFjV4tw!+-dnO8h#)2p7=n5|mYh*7JxNE-
z+!fVs(X+<z@E$={vR#(m?@YDE|3;7NUe>DKKAwa>IR1LX8RdZew4nd9VipjnBoTr{
zwRO<BL#JU^^zXbh-*5oyktcp^mOn0X8(QeK)Yd=AZ3z1i^pmkwu)W_qb73&O)rq-Z
zmizFw5r$=T$}n(j#2s?(bz)JrzW;t$p!fe){GYVy+(Kl8IecV@endQGxpKaRKs;Z?
zo+EjIVIBhV*vL$|jQX?&>)|PAsk^kwo>x-oM^>=;^^}x%$1=+0pS-@E#ZW|BA)qYF
zXOQRft~AP36D%TCa+$fM4=9gaPKhhJi-IaKy>9&a&+}uU%#HDYOPMpT%HDh-&Dry+
zC>R2q<gG&2-|~N{C86Jh_XVa!gt5En1yM{_7S@}72XXZ3fcH0NENi><7C2DX5dM+a
zgcrUeVwbgU6dfSQIX6$2ICpvclIDgnx}g{wl*!F2&+O&^k6KPx@x4Q6#Y7wHDzBok
zjILV)C5Uqi8s;8NtJrV;xblZtJ;7OyS%ejTiRzA{sysB7JHZ2))18ILO5E=4K){V1
z<#z9W{ea<))enT{9a8a@lGv)yXmp08vep2ufa>|qToLSexCI*;BL-S)s`z#sk#bvi
zG@tKV!te-nDDugoLkkulWmFrxPABwGwfoc_m9klGHPovN|5kOH-LYG;Lp-U-f^gKD
z9E?ejWqz%fhFR4U%wnl_tL)&;)sKl{YYi2oy(0)b^5ApH47+YW^oLg+Udi@OWY_tg
znudRPV&ufwha<T0{BRTsa{<0)I&?OI$O1!)tMj5)#C~r?_65wIbI{D5ypku)?G)ZU
zU4E!(<hh8~PF+v9W=51?Li<CJ->Tj^@_=(gDE8sd$bH!B4T(C=&H0E~aqK6gOpz(`
zN#az=Ms~XFN2kQzI}!AjSJ^L>*z{8_Bq<c+5%;^#SwVd(j=_BfEr5S{)yC{hBjqxI
zC$ME4`Zx`^+Hj>zVQtBwvYDaC@G4u=3AJSk(7fNaJlI71M?qOkShD=uB)^tk4F$F8
zqcJxY2r=C!a%6J|8Q^Zd4pq)X=i4r6BG<iybGwH5d_rFQgmRE&mP#{!xKA4Gi+)nB
zz1S#k!20OsHVVfi<8t#X%VjNZtb*^1S*x2C#cJJ8uw-aNW_<&C9?ls;L)zLxcgjz>
zM$=9NC09#73q#&C0Y)&<`nurj1_{m4D)$P9N@kL%@1{69#vRseo23XV$Shv3i#~$=
zvv`Qrx>c}O;ifM0WZz&3M@j+&M?VwbD>~J=<!VNFh6s2oI0qEaUslvy1Uy*?q!3@X
z`(vJWWkAX=SWp>Wjp%5C108TMdl}v=5(hGZd044ht%o(e#6e+N;=L(9ScQ59v(}z0
zdN9G++YqXcv&*H(EhXNE@)su&E`q_N#7QSU8nn_R<Kt4R=>V(ZGhVJ_2v7Jp>4~y`
z%K~3>P)J<%Yu%(PAh+-lUT+t&s}3Ot#EuS)K9w$jg})f+!7%RPE8KLzic1Vx**i<}
zDW3eTq1#=$j6|aH>GpL=NYSmv!yQbwWqFKSMsSr(o2;1;R=k$)*n8vXMnABBD3x3d
zj?2aTd5%BX(J4;t)trM*Cp@NHTMOw%<r%qpw@^-_5}kJVzZ7-OEx|VMIs29>LEtZO
z`Zo<hfEU`@r1u-aYHf-40BCc{uN1)cP_B4Ij@7!04;rk0P>NKQ$=*_1<+V^Fpf3Vz
zS@DsA8bK~wn$`Lv0bCHpOdYT{W8tVQR&J$YM@C1!1~#M5+JN(40?u!Rhykb4)-Uhl
z0?u5Os^*f<t$vH#3d^0@tAvX-B+>dcfaOB*UddvEDdBw=3Otc6P%WdOkDmpjimU^|
za5aNkDFR8iyZQnCR2=ZW!cS-3)%b6m!@D-%`n2R3iqD;LVibJ-j^!%@(txBOo$H^O
zS&==ohj(yoi97dg@@4p;Ae`-|N%7v4nS@I$pIq-g{22tkg_H5p=ys2o#pB)e9@T1d
zIqGAs%y;Z45#N^cL77XLLQlSH-S>XOO9I{le9Mc)jbdTVBEVmavk}-}vB?UQY0GD<
z-q~^m#B|;+jKrKhZvcSv06=_%4>;A6X+Pq_;0bzyalHC2^<N^zFrG=$LKPmMR_g>l
z4db!+^4ggr8u=Vc)RP2fp`4gzgKuYUjx3u9;ut1efa2Z8KlVY-1%4G`P~9A*?zO+*
zx6B;(EIANE^3Ud~R26cfP_p9Ud0Effeey^pC(E5SZFBjkov_gFOnyfjwBilHAly;X
zs;+WBOR(TcOcI)KvZU2%^22m+2A_05`HO-+_@NYLmq94+GfXdoLIQ6u-(QkJKvbtf
zGO6=KtvqcPg86atKb84JSVVbqI+x7osa7$mk(o}Z$a=EunJq?Tq8zG80ruTuYrOmv
zD1}U<D0IcwGyBw+(MnAm7D`1Ln+R%0L_SM1?5n}rW@nZ81R@m}Xaf$E!6SU?-;oj>
zV?l<U67sxTsC2CVzVE-mfK>mC(vA3u5{L3s6AYt3V~1k6TV2vsk{(UN7V-FKP^#~z
z&!d@?i*;l!Cqt0JlZqzHnD@A_3ibXNrgpVwYwQqp*SH2^yuLlWv_!Sv#Pi`d2mx1-
zH~p&*Uo_(c5sGYMO=d<rlFtnY|10`T9S<hG84W)Ylaei6L*-9N{@e`4C;4?~>a%|&
zRwoSgL|Y9{0xP!uh5hq_6n>b(+^_uT0sc}HMN@zOe7s#{M<|3Lh@9yxD8Lh;16DOi
zOGo^G8p&+je%!qN=aVnnb?x^2^+LdULwQ3k8r<+J)|zp!-nQ{AM@M4xc#wA-qbJ!1
zFAP6z#Xf`z+D1!8uRQOV<crYeB=QT5H6Mx6zL-~?9Nm^HrB0So<Ep~jBcbq?8<QrH
z2M<R@hm^GC+J~of#gP<$r47*1PlA?Y!6u?Vg0sEDw67am-d2+t-xa-n+mH+nw(IK~
zUuJOCeRb_jp52Sg{fV}^AH@lAoX9yp(eQS1WVkyrwk?;GQ7wdZ9I`E=uq3=a>TSzd
zysZSLIe&evX`{xp5gdvPeGBBbmkQ{&+1*omV@Ez`tyv*t-C`fKw|k$Fg$i)*D3>Rp
zND}(T+c9^SP=Rr&5(EEr5M|1L%o(?6<TV@s3D8XR!Ht*lg9-2N-{P+q-`{CnoC$%(
zdxy60alClHs(%oBYYBpbC@Pz$Xy&u{E8E2-*)?u-hG^mT6aD-0YPV5;xLlKR-F$`q
zI3Rb|)$S$wqt|IJT(r<Fl^<QmK_D8k8)Sn}e!Mi{N`uRB33W_b;jwAM>{|-$A!38b
z;gq0nsHVBPz?!vknq58(Gk2Q^-j$Q>^2tHURJ(kt!%Ipym+*W<c`kdA*dcNrFE3zH
zgGY4Ir_q4^^@2_9k(xQ0LqW^U0d6ql|KE=AgWr#WvYGf--?`t9J|%32OSu8`6Y!VO
zPP@!J0c)rQBZ&@GGEpi}w~<dld8zmiqlBoCII?!g)ncPil{=aOOx>XPhkBo}`oJ?Z
zYHzb|pG6@%F@t|aVF5R=;Pyg2&xzc5NuD#zPRK2q(;OmhyxlrSzUy=CgzAbar^yjR
zEH0Q(Utpan6%*2K5dkKwc(MF$mETS^*4}8JBtbZt6?gfxZ<l+QuGWkBSBC27Z{=}t
zL}ha(uoV-fx4#P;Ux5QG&|p`w#|5B?%TI9>GCW@jO5qMLik!yBN`y~52MS`33$)0U
zqv_9zEdpK&APMeD6>(Yx2LjW7`^)BWNm%I4J3EjOH)Ke?+a<YWWo{olOO!kK0??P?
zNz#||xC|9oFTo1Te%Wc2(Yf+$p_7myvXrNrFLr9_?|x~uM&4b5sb>KFLWS9{Emd5R
zTg^ywqBj~VqAxjEAN5_k>RP6|+WpB?1v1>#B)4|?I(#1_R*tS;-j?Iwfs5qri)nIO
zC>O3+Ice3QL{;Xt_)tk(ye&RT{$_};$O0Wwy@HbBkZeoU22t9Bm%^SmjCw|Ytf-cl
z(E7n)@rQ6fGa)^uylKGz)%p#|Z9G7Z_b{LBhH{)0#M>n92Evw5%)3fLLWb1~lpsL4
znb|HyuaHfefV}5Kf)wwS#$<|6RPO<s)g9A0MRsgrnRzEu)ByKFdN92t9=G9}rD0tT
zLfDrBubCCj&-3}=C=Fv0D25<8jU$8-6@eaaPLZo?plY(%g>Se;ha@TX?J~z$`q{11
z<>TUYM{MHu3#C}`Z0S+yq;>xX(uN>GsD{Ux)19Nb?yGUM5*<TKMgs6V-%73-<2$-@
z3YB^yr<=qN(}}z+<|k&SvGF8{5F_40<4CMA1Nwy|>JmC7UGnx+^)u3mEvdv$rW3!E
zYV%L&HtQu(r|n)6&HDCAQ`O7U)u*Nsf09l-DV6w8Ix#DiSe#D$hnxs?L=7bRBkGn!
z@jz;vPNG?Z-WC!Kmgc3a|58fo*uRoa{C28jb2>4eO8j~{@vBl@JGz@hza!B|@HjlI
zAj2$B@4tXNJ>6e{4t!ce->Xb-bY!ym$c>z8K0?@6YStK8e!>{X5{rYHELvSWDi?Y(
zp@W&Ohsostd#K5b5P5*hEzD?St@cG^duY8~mRiMLS#i!djgeK;co&4uMV+iE%=PXd
zD{Yg<y}uQ|lcXmkJ<&u!w;llNOBR`3FTAZeJ6zEdSuRg3MW*rocRltpY47%{>@BN5
zlqg=S>VRmW-PB6~xBe@76+i^}%^5d67Tb0m_5pP{!j)%odZT#)06G^=vghx0z82zu
zy;$U+hP}1!gGT6A!w}_HCM<Dnqv2&b1{v+(s8UAemuoPmVsEuO-kf#=#z-!wU{plS
zce0M1OWTjwb$hvTf?o#qQwE<O@{l;qi~3^2>B9FF=nnxpPkzapkcwJ%)6>#JF#ALS
zC4NwKfI|fsRheB4+c7l0AN>3F?Oj8qg#1ssK@vD-HX;p!XX3124$A#Gz-D^D9GsP!
z1Ax*ws9_Fved(AvfWQ8)@Hrl2GSn1WpER=*pjGf^2E@<<s`Dgdk<3HW-i7Wfs6`m4
zC-yR_Nw7A&AU{(R;ceq*O8)lkIoNO2S``J4;2njJUC|9JC!m)WA$l6={$wcabl19H
zGo7W#{;~f|_L1ubBl;Zh6X1I8N6`DZDO{s5P0{=HOOD0$!=I38{$Js{T<N#F+N~D_
zRMTFe^uEa1k{aDx@3y0Uxy%gjipFi}(JfM%Ki%k@gURWt=$8I{9C>dD%2{+ZvJ9*Z
z>Y!LU&6(dVYfu+NxA$Ah1nVKV9~0};f%uoVDXjRp1My$iy}&()#sr81gU{^%$o1t%
zah=E)2BZI6p{M_M_<y7E{}%s3Z4u%Cfa&gf_eC%bKN9?-<B`<)du!ZW2DnHCl*<+U
z{^$()e?%3^e+2sfJ`nw?zaNZ#m9GN)Pjwm!Ma<V|#G~$ob;p_}Wm?~=cuugt4(!L8
z3XquF%@?;`Ys?oa#g*m@Yc~QEO1W$+-e|r~vf_*RQcm`~(1+|9I3(kRBdQIwG14g}
zAsIgqm4{uC>wQ*g!l`yLpYETgD1+qKIiHi<^Y(n!q!m8}$<>KYmUVfXem?J$-Rf;}
zD5iG3`*BvMQ!&Yz4`mUN89qH3blE4`i$iv^o@`D-<PuajOs;jm;P=C8So1kVPP6d^
z!1+P4E2a^DH^>Hv=|M)r^ji1qAfv#UKLb%-Yt+qH;N}GxgnpdmRFpV%-D38-c#_ST
zwVw8;uKrL?WfACCk7xC6si9|ZC1czUveXST7u|;JxWP=fG(DHWse}m*QsgP!I$Um^
z7uk4@2$B_Zq=`o<BbXe>^VNs?L9+g!J8-lr*nx|6J#1;tVgI$_4kd&qU761wT#M0k
zY7e&JUzNPB)$hwbY~A*G`4yEQoO2`y=Tl!8nZZWPcEeu$P;AR}$tRgPtYj;4tlN#n
zC%Twr@s8+qtDABpUZ|lPen==*EB*zhkRKABmFRuuheQyy;`7XpjVo&S@r3yydNwQm
zYkpKO)LmPwVvPm0w*$xwp$V0J70kptB5lqn;So*))I=y@6hqN$U1Sg++Zp8EdL3Je
zCy_6&Z)YLO0+5i{aJ`~k&LV;qV<d%NBG>a@iyg^}T#L!Aq(<LVwQqE<Q@2+Lr>xK+
zmb^RiOhdwuRwWt)t5q%p9obx<UipMF#Q)feujZFjlv>Xl$-u76^_GxaMnKZLWqvNY
z>FX#97%e^xjc>9<YTe(Tp%;M^C1)%-$vd2eZbp3jX11^SlLh|ANPa@-E#S}H2z_ES
zz9hqb&#8Of?seZLv}Zpu6Mz<qWVqSr&FAsGdc~K2^~673!Jd{MPRU9sbDn%&6hZ}I
z&(HPbEj=*n7{f5JIp_8Z#n#82DqJB7?fFyf3hV(VdsSqKB%LcqqiS!t$Y}HADAfFd
zgL-Gqx+Bu~>862XCj)ZI6-hf82^g{)kQA)=W`03U#TeSlokC<hj&yb1CHe-7UDpi?
z@cC{2EJawkB3qP;9uVy74TL&`I~7yWfS2l0?^YbKA8uA7JG)}4_bViE>g;Cg(x^B0
zCVvwE!`-#Sm5e+9Fv*{4)zwW?MQdTTuAo}-enAC+yR3K|yvV}Eh5y1!p*vOt*H*&r
zY;uB05fu&>@n=XA(zkkjUATzy{p}Sso(nDH%Qb+QOjS!DYne*<zgmMY$wCW(84c(S
z(%mtlG}v0bLmU9a{iM3F7xD?RO}QaUvXa{xt+I5wpHIdy4R&%_5!+gFj6R9@u}0|$
zKP*gC<Swu)KG0b<+G%&n=XLWmVP}63nSM=1tfNHL<H={+HJ+PlFflPsG`UZFwXQb9
z?rqCEVaoQ>whVpeCi4h}X6tgJ?mjUR%rl1U{(a%Tq4y&2?tW|cj(xAa+OuzW%l?YG
zmUm0+*Q0s+x;M7anA+Fw?$~#V6g*ac`h#|o<+Z#>NaAz5_cJH^PRad7O~$^V4-Iab
zmLnzmPRZBYj^pK?x9^liq;G7Oo=>H%uA$O_EZ~NHr?l|7WnZ@|;YfG)>>DQ?B!2~<
z>!f%u97q6_hLgWD=c8c1&cnY7F;!m6aj|j|W=ISV@gHq-ZlLnv?zR>|og%F5(xL9U
zou_S|(TTbJ>EB#Idim<VigxX^Z6jWay`LT3PDIi}k&$Tc{AacTyw*A6uBLnYb-NRt
zV~!Z~5`VljWY_RK5%OyQPmWkSN51SVB9?4(1;(_)oq~tpk|fI2DSrlPQ)Ri$3*pM+
z2Q1)srSBL46ACX6t$N%Ue!N<~`%XVj<*Q3m_N`+7toCG8!nq<t-9=#6fHKro-HMv$
z40YuUY}`VJx~ghX9rjRnGU>pR21hT_eEdtiL7Q!i3!f_dX!7i`srGhxe8|Y(brKSn
zCxt|?k=wc)jamC~tXeW*f@+dw*_)I948M%mtNe@}^dF3}w_}RlUTSYY+-;Zfx)F8+
z(HD}>9D9GJt3y0OWVhNCxshe|-{GfxE54gUS&^?49U`2|O?)ja>L}V1ekyVk`c;XE
zGs=GjZ)mutAlkf9hz3OJ0wS~n6hK7Y0}ggTrE;~74Vc^!RO}B|V4fgSp3}4++l}X`
zBcUjbO_%+W5+9?GE~5z^lDaTYn+`t}T^rtJwTfjb%(_*MvQ+gI@!^_$E8a;GmQ647
z$Mh*oeT4KBJy6t_JfS`OwiUmWt_VY0nKu`dyk(&BZ8Qp{Xalc>yR?vz9Nr$@9l1fQ
zsofH>EfyQI=mD;=S|uV~ag)39gyckS1k`k(mr_-flH{aZ-|BGrwQ8(4oZ`kF6Evuu
z!RI97prA)_<B8P_kP9BTf;7=q^xda};V$NaWaDphFxfNDYCV<qh^fq`Z0E`6*F<==
zN62ScVR31p)%tI09Nu&ImGC>(`fK^NHYE8s`6K(!MSWg21(`BplaL1DBI|{qaGa3`
z1J5>Q5gL3c+-b$npp1#8c2IW^`#B#y>Tc)UNY^(#<6H(XH~rD{9)0}qD~I=hruFj9
zZu76aPtxB&ev^+c%!@KP5>rCtOnKd-s3ZJb<XX)6$1M9VZfd%WWnB^bnNEkuD`Ne;
zMnbK~#=PGIaAt_{Z6bWX$B{uOCDzBsUqx^&4}sIGND415K;O%UPo()uq{w3$M684z
zit8O#;TaGLCnvcZVy47)XD=JQ66}d`G>}bS2sS@Wuv`kPm-_PxxF8wsZKYrH^r97S
z6&OkjsPYep_(^`rRoh5GGYdd6D?>z_Z*cvgdZ&OWezLrrEApNMTm&o}_OMMFqH`;j
zDUoXgBmIpI&FQ$l0FFA`tC9Zo=|gkb!Xx9_|AM^VYyV>Tqed`1Si(+dD6KwEb%S=V
z{h}wbJci#)iY=NA=Ms_lY>6m~$W&YjZHWi?;g=8ZhD)q}fbUha<ucrAy;I7Vnj-D`
zHPNr7YDy5Gpr&{YTN{Knh2Xy^f4M{1ATc(~Ld*5elW$}DFqzMAZ}gy7EFX*WBTtz*
z5*qpvBM~Afl;ZPcp^xN7IX;@75|GYc=Q^4GI+tTz_?^faL~D*K;5Q>_>G}-6XvM|A
z1~Ijwhc(}$hO1FG{H)bFjP{C~dIqie9@czMxT$AV(rM^56hom^mbVq!Zx;iWV7>RS
z-k~lfE$=7fvfnx4_F}CQZx-fa3W?#rM8;X`iJ;TxNf3S`Sc)N?u74{o?gHToH~NNG
zM41b%4JYx3Mw#SXPrOHcgk|s<-U7nDPlYF;-3+gVq~Gh;At_fXUE4SDDI~|u=+gnQ
z-63-FJVUS^p((kNGt}cfE~O8`LWD|WQN{14Ec0Q-KSPQ>0&7eo&T-0RJIeJYlCJy%
z6IZFU4Vacu$$r^Ky}mkxwBEYorl*~H2=At?hSH*s9o~KTWl+DqlJd>J)SDN7V@%sG
zxIaTSjve_hl6AQISozD>$IY=To<YE|>pJX;om~~GJ8&v?+Vi)bRRJe?{$q7pS+oZ;
ziw=o@dB%umt@vqtP=w4_$A__9ec`&TRzkF-j?~!7W2DafXJWgMtb0ho+O@MM%egc=
z<b*O^F;)h-8|L(D1Jc}2GfqQK(X&O}BRVl>q~`o*q*_CE(V^IuzSxU>iCNjn39*Wv
z%vjxidg>7_*Io2>tSdBPGh6)J51f-+*-ctIR_%78J?x;dZGEwq`oc|HS6#buXgJ!j
z^hz347@u((wkATWo%syfO@tm1IybL!vzK8w)S2mIIAdbZF@%TNyi7wjqQC*C;$a&J
z-HmmGVsD0wOc;KDWmof;0pE%4KdYhRW6`b9Z*1!vY|7qNZYunF)rfFKhjr_2nRAgR
zb#(Ke0j<J(5|`$FkXV^5>T3kLG45=N5pRDJr()+MC(|Boj}}+qIevrTgVwDzj5XO7
z%tL^~sNk@71iRCh$yYQTgU8(DDIbAHXjN({F8=^Q1HucQJOG}KH*m2%zoY1oUGbP*
zw^25{t%AGax(+KQ8%Tnuu49`;pJ5+NgyhZwQRcDOvwfKaC`Wqeue!7w9<rkk+jT#)
z=RY9l{~o6%<Yc<#+OM@?hEPb|V+=v0EDmwb$&jl3vU|EIuufzd?s+SoadSy2>Qm_m
z+KT^Fdac;V`4pAQ0f7OB(xw9<r_6uMiL$52**3#^;KR&k*)R;r=lwcaY{iXMT4-QO
z?}VeVqZ!uvBT{sO$G>)Tr`_~CuNQ1HRfj}(j%|8g+RXd4fMK&1V@EQYHnLkBJ*#5p
z$5<doGgf}u+93VeQ5U;b-U>JJYiwI)?4=B!_OuPGDV}jFXoKDMwRWfOXU_ZwhSYVB
zoxeBymsOKihQco{pNI$+)Za|lauAEvMl2Z$|7GP{&1HhF`Onxnzll|J;{~T{pl&ax
zJ_wbi*v(oQQt=S1-EP`Hw(enBx3|Tiw5HQzTQ62h4ZpbTC&`U+O|texrriMP-N2_%
z?^=0pBq%C{*3^^Zoz6dr%1nAs6x>P`XDlO=!N}P>wndI6p2u;0puNr}=9lA+EQa|x
z4c>Q|L;ryBBpGtvN%@b8F9P14Xb}6o4>E*iC0@-Ko>e|>L?-0=L1&>s;p_&VXH?$j
zyw3wnQui#x^fTobSK`eRxf$mqI6Sd1#AbU!GT+IHZRRsFsyzI3^zA@Hh(Dk}bPm-n
z4DYtHo5v+Cy(c8=-^nVs%UBzs@a|RbbcJq{F$T3nN#Lp<T!kngooqTwK6VU0_u*?&
zdn1(E;ZvJuCqiPjmEkN$E!pdYh5@$(RUX5U$hy$B!cRBlA%-U|ofaAdfJ9&)2tb=o
zZZ1tFIgf*X;veYg>I#G3a&aMPKAXtG@;-KD_`GIf{bb`hL7xYu&!~8}SMvU$X()W&
zs#i&%jPLBk&}0TQnxHZK<LUWSJQF;~O+30%MR+kMt|Fq&<oIYP4^O1OO8UENK!4@c
z?z4~%ZHFhWdey`m@f#gHzf1~MM;HL~v0Ry$^nPjbB`k<teFK3#?dnLs^JZWlWb&`n
z{Hu?XpS^qNy`1|Sw(NdukbN291@={B@2fkquV9k<U9^Cg7wx(XNnrf$xAs*WdD(ll
z2PI0&2PLQmigvBrEU{xjbO4`Nt{HR09JPP-^#_3!6Z56;r{dv?6C3Xr%Y(tlRwXD|
zj*E}M<@KSMaa7Zj><C`rJ2DDC@3MT{w^hTq6Crura&d-2zV8<KzAOhc$a<BdGGSLS
znd0avZ`<IS9(flq7AZ--X}n7;w3xB?Mq}o<6W5aHi_R6;DMtPz_T|V$sC?yF=+TjX
z%CpdK(u@IH5ATtmat`{jbCLL`zh!Sv-mR|Wk#A~?SrI4p-WWvJvYg~<V-IRh?h-r`
zX!JqWe^E0>^wAO!SWT%)gg^CYr&*B~V@JnCo(<l2R^RR*zOY1n0-qc}#L%C|+@-U>
z!MnmEBdD%<T&FIl0X*Sl53aQT|5bgY3vkYnBqGnLpNJ2Gyv*I--!6^c;Sz{Ah2giU
zGt(bHjtpS9A{za;dIG&*&e!VOZ-s|M{%HLB-?E=dZbC!yC^%I7jbRltE-`rhp}jM?
z8H^|28Q8xFE|3)g*8Kh@_(0@sYJ3T*fD_x#>Zwk7(20>7?WZVQVW#fS&Jc|D>0NbI
z9ZC_KwARDUMTNyxh0zC4pp3<A^*-g73h%eWo1=u#E=c}P$OEl@^l-8jeHNxU>h8OY
zT}2$@Y^NsAlZc)iYf1`|YXkm;Z6*L8it-+f3GMGJ7Kjf5aiRA8cjqEbr;$(MSbGyr
zG7af&{z5n8Ncxz_W>H2w#g$TW2Scn8SJ+>f@%$uQKRGfi`2%z?-{X04`w}!ta;|*T
zjM~;x(bv>O+u)`{!z3KDUQ_hNY#snRnb9}&mLyGB#aWT(oRX=m2-p_&ML*5WF9X~W
zDFLEcv6&;5o!R*DF!2PYl@o<;2LBjcaK9jY*eaX-h~;}J1)ylaJwcyXR`UCold%Ia
z%I7azFcQ~Sl)74GX6#6(mgej!soGbTn`T=(((ist%=BaRX%cPJelGbb?LQH+6M28s
zy^CjMH*+uYGSkOq5j)ZsxiJxHNfe}Vw=fm4_xj*P#V16!rEA(dhg4?AW}FaxEVd$N
zSoG1@itN7VL*hyl{Y7j=UPkmj^n$UY!y@M{pM?4TjSg&(Fr(sSf!M^c<~@8HmeOr<
zZM(!f#re`|mH0NMoVY$=4UH2s?^(-ysWCXV6T(?7CdWaglo=VR<54SnyGB`!KR>3t
zyfC>EJU4h>%+V0+tM$i~{O}pFk#}_e!v%pjwyMUhcFt=()I5{zHecFP8DaSty@5L3
z-YZ)zd+#5OflRRX&dVO4`AutDgDo<>zx0#0(9bY*#7lH46S>!kOo$yB9=S@a^CN>~
zC?gu2&Z6!bLi9(`1Mk!LIjNmqgtk89SzY#>I*fbq#v@-u9Tf&l5l6Lp_h^a5Q`HwU
z`E?cf^uQdEP-$sN!jpLu#02}J$Sd}?)dxh@28yqW?o3VsiSJFL<buX^puJHpdu!eH
z?92?JeYo9NY>QB`rk!Ntq-?_D<?!1?(epJ!;|PhUf%B@JH7#UT_wAyhk3^k+*55(^
zH2nmZJtn*ucREXQf+XI7IQXi_E7idiJgoL4)NTAJAiCxKf%2{gc1=&$*RR2Ceoxyh
zQ68x9K(D})yJT9*Bn+gSW^ewzjO_!2iI?8FAAzAOE1TbTSpk9Vn~<(IbqWlk$12*D
zOb*2FLIm=hfem6clWGw2YVx~=i02C}^WF&hWkGLwK0_t885Y-@UZVM;J?<rRko1nF
zfBVH+9?xr$X#(5=wpw`GaD6xrPsXZT{Uv5u(GvQqcLhBf9LnzY(dmp%l=nHDLkMqD
z3Q-C)_3m5Dcz;k>?9S*ag3a`&|Nj}jq(QqZKfsp^$Xz7|&|~n`ko-lz_Kke|AI5ju
zfbpH18ef{wWMrcml@q#EUjWarZxGZ9>uP5>$ItQQXQ2lP2+C`~*#qZr!N56eJ!FuE
z<F8=&;o)h_1p(@Oe$@C+8T&VnQy`dTv87CQ8G1~Ozcw|$7n=E<ZXQNFJD57gkpe<2
zck119`}JWQj<yUy)=64w0>mJbyv2~4KgYi$&p_%83x<;1C;a@_`9AA7>q9v}YCE*c
zvV)oLmC?6y#Fd$EuS<<@0R3`yJU;z?RzVi|MQu3jo&D)oW-{+qZZ7;yxGPJbpl=x&
z0maOGC%Xr&Pcy&rfbgJYI%(jzy0S#qX<wde-<Zc4)DKa%X~Y}`^f0&A49L~-Kr!Op
z(v-t>dax)zp`L`npeCDn7_GL_#O7jAoviasU`)FyN0bVBHv)Y^y#a-4_c!F)E6km;
z4CA=-aXfydYJ;*+FbjnObRRe5$F4uUpL`BJlAi*e*jD{`$Y|!E*1gq`joE3^t4RA<
zB#(~jF)X!y>}^YOQan|!KflP0hzSaWQX2>Ut`gx9c#sHd&1jzGD|tAe(;ugCHnF(a
zeF<xn6X|RT(9`unr<YaK@y`ABQl4%<5U2*87%44P^iJkavSZUsMqAY3T8!6MZ6$YU
zqIv(i|6OX3{~N<)1NgZ=mSFu+OCD`9A@Oy-L>i7Jfo6qD<~IWBlKeEF66x>@W|024
z{Agpo=U`V!o(z_ukKvDz3dFpW_uq$@Rmag?pNcT44MA!S%CgxS&%*BZmM|4X9h)we
zIX&x$e0vK?3g|=V8#_K?>PBubQrH)r#qy@=l;Vkz|3)AaS>1|%OCT8L)XVA5&bhV3
z<_H&zRfaV=J*+Ofk{K|8k3Qg0V^&2sUP6^2`Aj~z=~{v02Z$@}G=PYwN;1XQ>i1XO
zaaYEw>k^@T6wO#jn61Ux1FUy9JC}rLK68hCNyxj3VK}n|rp!da<5DB@Ir}M%2WAgR
z%*_-Sb*v0uJDp0Wa{W_oP!bV9^8K`PNlVQqIvUYe?TIV|EwxT@YhUv?0x)o8_^Igd
z<oxjTTO(B^;Um#QNMH~u^LP_}+Yz~$0#_zPeYQP)qX01^jVJ@fPY@^jjhs*aQh9Zs
z4BxtKH6uYb3jJG#RPCs|nKEFDY?8BOapo@Q+^!8J*AK$JQh)sic9&uvsz)R##<oh3
zuMZYLM~OUxt<5+@@jCt6uGrOci9FY4wb;d;*cpH`#m^COmj`F!DWveTRQ8Mib(n->
z&m;bR*pS_CK?^a6ZqD8o5PSc%43@)##$YHY@?}IS9Yu<IRAo6q>Ci3^A_RGUOj4m|
zC5A-E3~s0WvZ(KdxW*Nu*UnOsNY^k6|BySL(Ig)Y*g&?7m;KQgcW_Zcytr@wANTw7
z2k!SYU_^JG$W)%Uw4mOV*#63&LIOj#lKrOJg!$}ozk#th`vd#uvGU+&j?=a@O56Nv
z#KK$qwH=6s%GdU|=S$O`kr#Y<g`jd~#b1o_590kC@H#|aTgj9PgklX-6q}vdJXP<f
z2IvbXVECpQL*g8Ts@>m<IvUI0j+_1}qe5;%BIR@@kddH!6((WE9wD{9aMmLj3HRUa
z+bM^b|1oD|S`3}+T-0wvxg6jYy07^IL=FjXcYS-6N^Y$pnwkJSK1w1l%Nn^+oF%R%
zu+5mr<xUw=xz5ClbOTbK#$^K?)WAYlt~<?SAs0JEdyaR8Q5`;UbQie4WrLTyBu+1e
z{ipT^)%O}+aw*_cbL<M2=QZ&FPo7g-ka{z5DccregD;3&@YymeV^vXS&k%W$WnKa2
z&Gh=8;ne2i6bb{V&F5O7-xG`Nn;sBq>Tu^^K3qgNq-+c9rlg=ve-eH-xqlvEo*vbi
z8eo59G}QhpMB^QFwjtF&6V<WS*cWlglr6jt#t@K{$TSTSbmKfk8_dI}J8NWaS%OUT
z6;71Md(raNJu5C`v$hxI*^Bb+MTPdF0(;S<G=nsCs4&6pMRn1oO$dPLB4F5Omw&j9
zjO0ViVE^4mtea-1*<UZbqbyHKc9rFuKLzGbq4}c`x$Qd?*1BG=7Fvb%?G;r0TWp#M
z+meF96Jwr1@}aKRg4FIu?_U9;|Gb~)%aGXCRSuEw40}tX7^kP2F+xlcIvRwSL=IsI
zI$s-tFeBc!IRL>15-js~3<s$O*rc~<L<NA)5x`S&3vUC!!~V>%DZT!-5MD-K43AvQ
zzE)ftT6NCqqb<Dz+qf+bIEm00Ado#s%%9kUh9F=0BxuVeQ3)HLGuEC34=zVN6OcWZ
zI!I;-sYCz$WHPDqS#}}Gv6p5eb<Gh#zawV5VAyc7<VL-2<n3nW^+{$y%Pco#lHb`>
zAXOUupX<$dL_Z-EkQN{5={$SOad(<S&AFHp>~iJ(A0HTlM}&WE9ZsB0`@tzXjjtEs
zQRmU}d}pI_tiDLOC<f2LkbzW*M_uhsd_!3V-|44}0>qeQ=47ECyn#{p`-v2FU;2ku
z3rZSw^-s0M2TnE`n{TU;)S!zu=PIN$LMA~rOh)nC{FNs;SK)$T#ffHWk|tS+D}<hR
zXrPu4VQD2;VUeN|9zk>{7%RpMMy_iyWEna)T<l*!ZDd&K3#hrgC-pZ4GhDpt)er2$
zs-PfNh8#LFkgpfZo~FFtxk|kv&JAEFSlQx<NxE|t@|5rECEylX>(x?S?+X@SW^KhU
zkYchSMVBEtPhK@ej3}+R*qfp}ES{U!bdn6k8Lsk52?4~Y;N2uUg9JkS{(gnfkHPQ#
zlXOcxYLR%18Mw%OB8i*#`V__9U$v4aW|Qq*!$jR??{v2$ArKSG-}@=;Y?PJiCO{yT
zWOLc=tX4_({!PjUiVOR&2)SNPs<4ErlETo3)q1lO-bspSXpWzU&eLjLEO`&7@+SLv
zB0{&8N#0$lyd23BoU{rBd!iv3%)bMD#Gu3KB?Dy$R7v(y!V-k+A@2F?;1XxAkQqN8
z{yo82)4^!@C8r9zj9@zNKBD0^nc_ffxeFpjy}SoJai91G1<^FJ-o+pmEnvUk^vNCl
z^fmrwF^T>Exg}RDaKG~w1Srx&B&UBcV&d%M*3ukgM*l`aNv->pRKl)>3zy8Sb*~H(
ztkyRLWL#=Wgjnil`D56HaBgjo7u<mmW|mE<eq0GT$BIh;QG!NecDCU#*-rh8q8%I#
zNzIU;a@dfD#OR8Ukg{`K+I55oaNK(#F57c%3zd-=>&!xo4p+`v^=u+fnIAk*m{?cn
zB>v^kaQTBQzEEQZ*WJVGz_TV{JCU*=b{bsdV0FNm@7B2GF<tmo`hG7##ftVUa8Lcd
zrg`EIC?kEEzl>BCP6wYYD>7$Vtsz+v@-~@!HOE;!NnfWHHpG<3x8=b&j&fv!js@;1
z59_pgVh>idOWCd`+`&KP0xxP&337a&=^B7_f86wIGyD5InSE~#)i>=lNl%fahIE0v
z`4RUiy)*vD_bKnD`K8{c_*W<5rLw@i8B-J`pg^m$W6Pe>|9FL>S2K}E2HwX6^1a*#
ztA~PI*hyHo1#bSaJ*4mN29zHzI|7^GjxEaPXH}vbe-HvN_eKT$JkGrloE`6z9mzPR
zf7MP|Znb;nYg}SqMk8|J1GJLuEg&&{|HdjkCpJ4v9~7u}Ro@kw<Tf8*#-~rRx43b_
zy4tUR7unr<MYWZZ$VIW~T}sLR=YRaa(5YGRtq{FL#VL&BB+3rY%3Nk5+>|EYw4Y9t
z?QA)EP9%HQ2y5*oA!=h3+H&-46TMf`WiQ(OR#8Xkx}8P4V(zpB-J|Z~+P=DN^s7@R
z(Lii#_A8yUMl9Q>`#jB=0HST9?WbFge!+_0OS>&cD~yk|SSZ=MlOZDJ5W=P~a@c@m
z;`QM7#6!>fVH{bzdyqD>4!=^rC&UvrA?yGeGcqQXEXml{(CyCr)(D}GeHEy(-+g6=
z?ofan`NY1V;@J>vTCAtmztZ`>?t$rTwV9>9nIhnO`7Dm|wz1N{^rF6&qi0$1`=~`$
z(IFZCeDaNJLL&5Nc_LD_vu!MyjM&rII^}9)+cq}&CkB<cEK~EA-&%A?kXE^Fr$HBp
zOI%r$S>1N&iJ6RvLb0tO#arRt>HjKRP@6Gp#4DZFT5%8q8q>icZ<8$R563n?!V|7v
zcz5?(I#wD!<bBf=ROxl^(7TusFF}&hQ-gO{b`f)5GU&aE33zE;2iexTvA?JIw3;-l
z^nZOj-hW@z{A+{!Xb)-st!bZ2rSYsu<1$Sv4$^|<nta6Hz>cv`N<BE{%#*v=w~cP<
zE6!*F1KB&nm*+%Y!wq2%8iBm!cwLF%#J%)^&Qu*IHp@OAeImI@5=!!t533~rcB>I?
zF}Vl6j|;(;8HJI%39ONzUbTDA8~zxhYv_XWS+WJ=IboP`D~3RlXRZArUo1)bdRO|&
zlKrEOH15>O@;sS-wczE}Sc6l}k_7FCZH8~~Y5F=Z=*wyyFJ*`ige_i4o;Ol{WvczP
zk#EKPLp&uu(%wSes-rR&*ec(Pepb(KY5eKKkZ(&XJBWIIk=*|5N2!;${1tG+P^#uK
zluR)5XT{l51Pm_COK#yG(#}?FJ?dlYfz$}T_IiM=yHe06Z*#Itpn&xKp~@q8v8sv@
z`A@<C%kFh6tU{(_m{`7Z_HVw$x4Q>Ur^%H)s}v^egf_DGHa8*`VkwqeT-OsFoBV8f
zal?VgrJ{z&yNe{4p(t8Ctn+jP*tzyNS;d*rm(W#|;$c>Xbl$N)AYuIRXg{Z1?2s$m
zaMr5zBG|wt(OekS=P9T@zvQ<TDK%=(rXD@*3`@#&YyShMYEW(nPMjhIQq$LVDmYI%
z<9X;92_aE%C#Db??jPACi4IlKivr90Dl_iuJ<H|5wGRYw;3D>W>cqt~l%VwFtdZGa
zSBAW6sKV*!yUd$=8S-oY=XgkeP|`~WrEBS;L+%vP)5DdaWVjV<2QW!})~fZtpeIkf
zHw-=L{Q3G}4*lZdJ;IREp!c6Ea&@pc;N&nHnbE&Fv(cJffOI&tJp5|&beXOGW@eNN
z=SKGvF__nf@%1Cn;X?Oge+#JUY-cuMFcym<`ik(YXo@Pc10C-c%*5aZZnG<B4D`IR
zNR0w@)t7wLX)W=Ch!@r$k7$cS&TMoimDzTEDEae2bLlG{XQ$QH&TM}wHBz@x;J!}K
z4^fF`n0Zh&>9c;?0WilLsJi)aKdqazKpyh(*`)eq!WFQUPZ6y#jxZLhfOiaxmU%?-
z3gY{rXTDV8y&dwoWJ>qpSVenUcdQzoJW!6s;@=4`4svw@{u$mzY`yWwFRvHpMql&s
zTgeJ|;<aD}JPidXA6J?`RzBxK1-nqu4C<9dhWqh14TTtG4s){5krRE5bBja*xCnx%
zudk_f3qS~jM9%rDGcU4_VrntGGW;PI&|}e_zu0tw9L7Qqg)4F*WA(XVUe|~su4uKJ
zUcjqCsM9D%<vtPnECpp3F(XAqNW4Ii&BhgVT-ZEBr6b&+v#)5-ASl!`hCGA#4;)3{
zyw;KPO@p3LBlSwfyt>U$<rSeyV<GZc>_dv}UdVRD_3h<&ZJgs^m=*4B9ws=>yNg!=
zs6l*p=F|-J<$=gdO;Nw~lg}dSfm&seDGHYx6&n{W+0G0g`!A<TE;X-auz<qrP->2d
zwon6wU&unLu#bSsk%G#ZvL|HW8n>-!gnX7|<E;p%tH>b;{I}W74P4JlQZGs4ja~v3
zEfG!yy=K<^`$7NyM^OY{UJ3URl<)$0WT}Db%Z5vw8Vuk70M|Lg%}6eWU;()TtM*a=
z%&shs_A>j!6+FdR8n%CPbFHvNcMEJ1v;OAS{iK_=fiDcoW%i8{xgY*=c$$JZ#M>l7
zeN%QgcjbAjkBW-ax~-aR1Z7nXY_TR0+KI+=FzY1X0%e4K4ucs;ECm>GsKvgrlYNr?
zN4_uZ#NsPgziGj~GCRkfCFL9POl~e7DbBFgU8Y`MWMyLRJJ|6o|0;gWA_9mznKMy1
zTvL9c;5&(e?&>9dsD<}_cPK_t`A%K_W&YbA44>VgLM#$-I)kNsLkg3ygt$iXLebB)
z3ISaT7Nwm<sd7nnvY<WIcS2-6KN|8Ap>G&S^PPqQ04^Y*Yffh&fFO=?^CfuXQd_n(
zo-xqO0?ACi=!`c%RSBsoY<Qx*v(r5_bLX>1K;)+FY#?ZnKitFIJk^(cIDOvn&+i3t
zez*U^AWmWKCqN$yTx_KE_7#ixBYn|a<##a2fZW7orkaAa?(nEzaBoRO9=EJ@KOLm>
z@L<u?tO>#Cc5dg51Kg+CPbK9Wnj%~&SD9DxNBBPEp2?Vg>YNBc4X=Sn7Pw~`MHQy`
zQprS=(E6uJ{bBy$7V71OSPng>ldNF8;*Vg9)RXrHNv(F*E#(oZx*lD+F4AD@HPTF7
zuYdl51*y?wSW;<IEDo*sWRY$vy2BOweJ36%MY!x-NuR&Jlvlg$`TMQ7-0<l!##(no
zvN-M45vDVH`TfXc-Asd6i$zfYfabf@%e~e;f2HCNR1K+$tO63m8*nm~cET0i%_q=^
zS}d`CbXW^-lmYZIfaF*$Euch(0z&k5`3=w#v>P=&4n7KidQfW7Nx=j6;*Q_D0Db_M
zfAJQhh`1SUZzii%LZ`@*?qwDbMyuT)a$eP?ZrPVp?6|ilrDQN%M7?kw@13jiMKGAp
zU`v5Sz#Jj(o3~0p7)mC4Vn?%q{OItgXk2UEm0wdx7&#gmR5hlu)%tVF3;YZ6s3r69
z9mVs3@MdDb$mari79sKn#6K|CVWOZfdmwqQtOThM$wh`4w|q2EFcBZ<dQcBI6hqXP
znMQ8)Ho<It3`m>{Fi;r^FmSJI{zP+%kRfp;dtrVU%=Ws6QBxWv9uc(rJc(tYgSqFc
z!&r4vWjjg!WG}hdpKNR0I!aertrBNL`&9izt=mX7T@F&ykDs5Ohm(CMcq7J~_oynH
z4DZ&7^)B4On6xwGDT?y!<tOu)&C;P&(O0i;H?fSnRi1k%xwD;sA<^wg&sZ3Ba)ubU
z{14^~acLF$!1<Ved#iXjszwehBa-)+`gi&D+tofu_Zxk1a<rOPkFeqxBJn!Km}O(q
z*bUf5-=y0gplPCYvOV@-)5P*+rJ=0$%O=W+U~erS$uu32f;Y)Ve`ecBM7=mI)^q^R
z*DVxpo100<mKEk~P7`#9a<7-e0rNj0_Wp?x-h2zi-XDz}dnb`EZkn9j$oj!0EH3i7
ziBLV1BFP?HYlUlwTfSshr?THjz6wVd-XUsfiP>w#&yuf_OpRk;I`8bs7N<B_cEK14
z1j~H<+51pL3Sl`vZq@)EfHqOLJ?~X=iaOTqgr=qbW<d8|5*lBoF>?PXpY<V6yo8Ud
z4^GK*ybQ(AMGyZ6p<<3&ocpW||KNwu7n2Re=dJq8>JN=2f~el*Q1UMdWK<*V4Gg72
z1RdUV32{}Fc}PrbhH#f8b~ib<mT<n2m#T6~<-w|^1K}CghP6_<iTzie6>>uDMu6z1
z0j>sZM&AEa)ulIJR{Q}f`O>&t<rzDM<n0_7z}Y+%l-x(ys8rQi<d2A8+)X)&95J}f
z_&@~C<=Nbw*<J7aSStWqT~3#fktl$CVN?3gaA&@%t5#aW<sW<|_XQ`ae?HG7>`7NJ
zC#pT}OQfe$gL7Hupwa{6{{mgW(fMW+pE9HPCl{XR`k3|c!NjzV)m<g0OF)I`q}~8B
zz$RWXz-pz}#B3dbW`r{Ylp~IH1qW(S9(6n4$O7wjbiWgthMPIPG$Db><gb^e>*RQi
zAjt`PZ?qu!c|%5e&i<-2TxyQmdn0pM%ww>kkM5OIOLQOS>|uJ&=7izg%n@!8H-^gj
zBb_?g`+=37yF$4#hI)6!4h0(4OLhq=Wq=ExZ`~$p6fc*5q`S-H+;<I76`#CnmN^|;
zw>?aK|9o6uPuLiW4KNO};t$DCFx}zS6q4Lw<I`Z^<fJ0l+3RHTBDPwNWa@dYAJK7t
ztzaW5TJabS4Ls3vUfb*6*y_N4g&-=t^t0Rx*zY^TI{%i1@zL9^x0?|V&uWN$q{PnB
zmw5vM`sFTBt;-ce|EV;`_-}l49+Frjo$IMHHDinh1TJf?GW!E@p_B{afW*}!{3Gmh
zrrPtLfdX=zY<X#I0#9s2@{Z-b*SE7PxXwr^Gn6v;zM!O9fI@mdkL*zY8D|=&rEQej
z?3_&G6#PnQmPb<9i|bs@Q_jtJ&>fKA2?v~<TRBGM+-b!{3@Z!29DTb4r$4mq+{-*7
zIO%sUBN4X<k0iujr}UGB+j9SW7477G9J(sn^8wC%P0x3}mSuN?0a`=_L;r&-LG*~~
z+Ndi;IXGX1#Baj!ls5O$D($_NrMK?D5g<sEejDBeV2o($_WRaG_<76nsoUv<a@}!U
zz2GQohc-z|8B#t*vqgJ~4*88F&sKgQH%XzpDH;xK;#eox<4GO^L3wOjD4cI?n9WZK
zTOuQ(htM?lQH=PgX$LiV0D*u^p^Y-U%cU~@&Y`>I*HnJ#AzQL}|M^*6n&;v1ThSZ&
z4$zARv-vDF@=^P#y62racYnat4vcq0NxQooP1!5{fSS+LI?~he%kvD5mKQu%JkQk0
z#o!_db7?+#5VG5MoZz(ElRh1Jw;-v2B_L-WQhVg485g3|`to0Nhm@#;rkN|8`Oo{#
z7?*Qc@cUsM`*`-wR%r>@mY05ox76*Q>tyk^&28dO85BCgw?7|B7@#?4T8;btJ%}<y
zL*vjMx?2M}Q(XoWOmww-ix!cPGEBDKqfsP)K1)Ll7|4IayVOB<-$uMMsoy1a0EYTO
zzBE;8Sx~AwjmPKHhr^)RGAew;ddD;GfIVLh5u%$x-yzcPm>3TVj7r;X$oX5sg+>l=
z)a__~gYBU$z$4c!H((!-%k&E>zscmx4bN`gtVdWiw{t@I?kN~HhAVobyGfQ|g^0+1
z*~=yv85?TkiwMYi>Yx4>e~*Yx*A}BoVfSKFp7y0l-eY$bbr_kctu!+bn>@MfN*AOy
zC=-yrLb{5<>J*La!JUJc($~0Me-1XJZ|XtHYL$aWau;3xIo(o9g#L#TgMS|)w}BF#
zaDn^v-GNL-RC>6$w7tVizQmS<A|<VFLjR6)u<YU*+|2#GzzccE_zUT-+Fgq}W?w^Z
z|Ce#OPT5z{yJL&Fe3D-cy_)b5^Eu0|*lrU;VtxlwF*2N-5<ek6MW@jNy;r-pJ}vad
z)uoOdtfz!ch0S72I9pRKPpZj9KXDss+<8>HJo&iBb0CcD0B*lWG*tw+i@MOrpOwKv
zCVxZ?A;U^rE-4p_Cxj76bOMDz)JfI`qDsP?wmKEtM{M@v1^AHy{9-n~_5+q!d$s#B
z=7THQeRbX9;k)U#f=*Gov~E)l;q%wu@Ix*Plb<IFgwya$=KK3XZ%Z}mtf9{3tsR#|
zXFBt@(?8<-?H!y7Z{N(B;7SqGe^2dwL%1Xq$GbyYD*~rGxtkCni8%EYZe^@1J3Os<
z4*ZOiyFh?ot>GD`EIadkRGQVUScAaCneKggy~)+rx3g?=wB6l1l8vmd;QKDqY5}7+
zd~PR#&`#YpcZPGV+YalPnaOAT6@Qfz?WlJjM0A4V@dCz=j1c90oPtipV}g!a2(8~3
zhV~nScRqQ_agZe@KZTqnW-7pwvTx$1l@l#SPM8%4$zb>K4$|;cgjgY7wUZDO%iZU|
z%i)pbTn@h?PmEkEm`qSeiVWAw+T~YNSIfgA)%EV@pHoWIgWp-45r__2;~w~>nz6Gq
zPSCSpR;2i%NHM*q4X8|yesgz}C;us3{hZU?kM$z9F!DWfEqq7v4Gl#T>14xO=za=`
z3CNSb70LWqeWJM`%PmsD-OpwjJ4-oFMLbUNsM0f0ht$iX!nsc6N+`Xi%C21L%(^xC
z^pk~z%nRed@rG=!!>Zl;IP}_;E2vJNywBNHDQZ+U{>VK}hN@8R6s6o|X@Fv(b_nRL
zWK7y-u<6Z@1~}MOu8_*=;c@Kx7yg37`|j7j^J<U11@i7pj&Sc=%`NxeG707BJ65Fm
z5za|z|M-<sju>XUF37-NGlJG{2OjmlpZsq!p?th#(fIv6xDQSlcgh(eJJvVBS|hs7
zCnxX^Yjy`lE^?VSK^8X8oS4wG5}B1@4PD3IYIo6hAkoFJmjkvVM~$wSr03|DI29m|
zAsC=HalgNdR_b%?*u5k<Cz3X$Q%=fv$L05}kMXY%W7`9K*tc%vUs(9p61Pfw_HG_P
zaBgjp&(txANC;~m0z^^O$nl~bs2r@rxd7+5T-|svGQ|>9f>U;?w#7IW5{TwN^#Iqx
zJANv(R2^_oX=Ii*ve0iq!&f>4kyS53;_Do!U6SLp3BWa2=%zXidJNnSlN*kmU-9R~
zs^mH7aEvp)ZDf4MiqXclxu~Np3wsW+=HRm|^NbGKk9D*}m#ltGq9NMb&*<UL1@e!v
zpfC@}7wu>piC*coQ>oMW+OSy9XGe6deotyFyEw5r1H4?&_aZ+|<wqeu{(UMx#_)rz
z3oxO}u<q=DQGS}x04-fZsD?&hNnXACD%?)>RX$LO(!*>h%erIljfy-Md+${1j*es(
zQCi30?-msGis??E&q_i60C0;=?E?8HGPP@nbP>R8QL^*39EDj2%~xm7uo0c!Od4AK
z+7ZgGeotyztylX^4+)y)9Sf3-<6Y3;@V2rcov)1<)L_mCWDUAXwJs<Be*AHzeftWU
zN?`J}&6Rj9xJMo-^y5h%nQg__vH)U7&b8vr`f-I7kLpJQA%paz#EM_5AD=Wb`UQf2
z>$U?7Hc|3q?8t;=vlHd_$luQ-VkPtyJ2HORS&5jKCB}|STvoXHebJBdBK!MSq3V5H
zz(LV9BKAH;Un6Ka(X_Tp-|nMSMsk{?-|Ma%y0*mDPiLatoB5oKV4^F}zQrD2NfX!F
zTddp86u{nRIMab9_CCWoOFtOS>3k3=Sz-MZ|0c>6*6Vy&uS~;QlZLg@hm{fSM7mh^
znb`a1;7;)V*#rj%`ZJwYg`VJ+Kp)8u+Ft`FSpEL*q_5Ur=qasNqOZq`fRpz?1l-z0
z$l{&zKYsXrpL4q;WJ;)JTR+i_c_)$7pQmHn(Q?71V!u-0t5KsrPsB2Q17ZKT1}gvV
z>i36FgX+GOh`lODizC^~Y%Cle(mJ0D>R7E`qg{P1YqesndW*~*dlydu2^6ewF6Jv*
z*sRwXA2c@P_z%e^^tS?+s94Ku%L`p+ghr1|o@MkaW>o76!lky3j{}c0Ui|j$@ywJf
zPkY!~0{n<!!2h54|2gmm`2SOSY#k%R6)jEYu5M~E!<GqhDq75dk>^{g2kHdxC!b++
z;UJTDGUzd*toA1_``=8Sjy6*toz_qDl6|#5TQ3;1XOU`_Q@`JgS!={O*~}UXNi+SK
zv)0VxCsMzey|1U+IFEEs&Uo;x;q~sBoX&|bind&y)*;QRcgLpEp47C)dzAz(PB-%3
zq(e>}nm#?9UQfEA0-1BM$mNiuR8h^OSG!+)iZvx7l=lVGvLVQ~Cj@%^Rynr~7-A6#
z!4TyU#uRZ{YsT|aA9`h+2E?DI8=9v>^g;Z3I$h%$DoEQfMD_Mbld1EKI-{b09U%un
z-CUd#IaC~M8=WY-XV!$}b(pD%jTzs|PEV9Q$)ArIi?h6zqgO>Nv4tDia&%?{Q^9kh
zL&}r8;=7uQ5c;-XAoQ|)1|m|8d+iR0Vj_45_6lw2K55||smwFm7%FP?DzQ(DABFHI
z*3`&!t-wFeT#H;O(`^7x%Qycg_;2V3f1!bYf`NaG^v<h#*fcVT=rH(wdGdJ?UO(P)
zbarH7%h7Wq6Iza55n-SWGSHba&=MKwC!=S`2qTUTPTWIeiYKZ{(ez<U<8d8T(JmR%
zuc0ux|ERAuif4F+{i404+MU6uq_+6240ndK%$OM&A@$TF*&Z(`8Id9A)2UJGihbBX
z-)3Lo|0K&!<ayuz3(Y&iQ6+Nbd04U)mrrdP+f|WslB~^!>_wPMoW@z5_z^jHL)@{M
zHXG2?<y=8Vm7W}PL_m{r@BNEsG_a}&^w$I0{~YZXAHV%h>Ph=Lr|x;FE~L%ZIf7_=
zfE4uebtz9~5K!s3<GCi?-^y|tcdDyecde+Ysadcmu>ExJN_7QRMIQE+(VfAP-=C%y
z(jlYvv7$+%NKy&fq@M^1H2q)i`tT0M@3HXAIR>8WW8is%!`rd&wA0BTc$!G+2hXSg
zo-g!+hvyTRxCXCA(tyv{TVv^`_j?!+ixpq<JH@3_n?J>yTDFAQX+D*pISx?;?b2L%
ztgRF?hg+RobITxSg09kB`pQWDb;(JMNn9e-g1N>`Kz!Ksa;*BXfuH^Y`#ud)#l6yQ
z>QzO?`<V7+X79J}Fl6*g<x@+-<$2b6;~^``sA@;=xVerV5uKwXE{9dSOD0dFNL9q3
z|B~j}VkC=7nIfFEE33u0H}MwunH%EV{)%iR;c2U0N#@h@3BUj<gU&xg=eyq`ZU+=2
z`haB}ko02A+8ef0zg*62_R*m5h-XA`60DRU^_{mBe*b4WUUuqy6xH!_6ta&$epBD6
zWc-!5u>?ItQ$T*55^_GNch8573rHNgF-lsT6PuA0nM6*tn|Kz?Z00@N{ZH_5RF3T3
z?jqK!(<ImXga#l$Kmc+}7a;q#K6EDzEaa*;cz=720qgm?st6iCU6V@q9~=|}>71>s
z<?&t)tP^8A?mU%UGqcu}sL!O*H5o%CW2~WInE-9z57L0xFr~B+=uY*Fs&0pa=siJc
zpPi-r5#jG#b_h4K;(w!AkTRhva<&hp&a&)UUJZ4H-=IfuZ~vpbT+9To+@`1uhA`RD
z80omWistK6qWO}BQsklyWz!IeKC3kQmG=$~b<nTU=bh}I_?!jwIawm>VVuToN3K(5
zo-59C$|eEmDDfF7&vEM>6U{7Nn>4t`^_#>J81VK1r%!(bJJjCWgg2Od*qlH5k6*57
zKXUv)m>U1qVEl9-fcjJTKN~*{9XtMi_8Y%QrRnjXt>Zs47{3HH%3eNSUu_=aEXZz|
zSx5v6kWl@H0Z8~ficv*EH^2@;LM!W1_Xi&n7}#*fu^=b;yW^afaRV^6ibnY)bRsH>
zs>rxwXyj~0kzzqV78(_L@B=fY+0aco%@2tTk{;$r8K%{$s)%4BzqipJLmp#LJm=WK
zM0T?Lg83M_#h;G@d{9nx%>dfE5LV}pG1w0W65}m!xML>cdSQG0$Zgrj1;6*Q&!~g$
zS~^*DxvWnKpG<eg{qCadmM~|$&(fu#&QBZDk8?yDfrvIOq+zfyP_D!hJ=@7BuFj53
zWnmXc>)&9g=61F`hY$-fX3xu{DS)#;q<5z<EinVz-C=~G&B?8Sze;NTzOD0um4|W|
zpW^TON54r?s{}JCq8l;`6&s)t2J<>GCm~5ODz#RQqcX~1$&2DrwlA$<Y<#3rTucsP
zGYJ;{3&~VQ6u(Ey$-Lhyx#A8O7nK$05LKOF;h02~A#5B`!D4GDwRt4Vfqvi|y(G>w
zMl3yMs{SB(W;vTC_GHNp^e*VT{4zMeo=zFO?mz+ItYgh`geb=vVM#{v`Q2|NZ|%>o
zl^-D5U1@mPS7S4>qf-<weF)0T-VFs^C2Hv>(^hO403aAQpd}|X-p5X$`#JO>qV*x1
zZ*@Sjh4`>88QFMmPz*Kj?OKlP<fHv_;IBajZO8_byyH0XInQZm#M4>>ah;jeGlcsV
z0?(~MN44(R{hAYyl5$~E>wbb{8Cb}V0V4yu#;myXz(zJUryJUja0|ErRJ&8}Tlo96
z#A~W||7=R>)y!1cWlyI&{I3ufg}%B(qxrIXgyqCO>MM~Yi0t1%!r4J*^+kPd)HH<3
z?!~T3gNQ#Fc{zw*L<G7MP){R=uROtCI@L#WJL1&~fp}Hxo@1IxzS4ibk+01A#-hc&
zy@Vwv1mxReV`<5X=B!>tIC?p<>pPhXokyfxy_>ijL8rCj3afP{nJ9Yo;mp+2G7=T_
zTU+ozArtD9cE984*jWXwi%G?JTwfv%p4@crH~HExPYFxEhh^yuEH#dP7q@m?Wwnl`
zOdLknh(2fc<Cg%{^-in&c{t~KTOXJ;FztTuViNa!uZn+nKPUy9+vQu9pDE#oM8p${
zXKVadIWWd7r{RR&eIy=VKm~jAwpRH&Z3=;=ud!}BnS3sal3&vKV164vCl|@*p_^55
zH@47{zDUwPHZXl(xA&f5Y>n4Q_6P8%e$}eAG1KvqYZtl|@2Ps7*0xnVlCjYJ)8OLL
zNAfQ<+E}tndc9tn{jn*hudw_0cy0I4pP{A>9s&~0yu}kfB<(X-R1)Ae$n_)Kwyp=;
z=~R7VK`ygeze2h{!EYZ?5RX3>A2kbb*A4Pu-tXl^H09Za5ZD}WT<?5O=&Ux;@O(|<
z*BHo>f?Bs!J1Dd_CvwKxPhHfOHEUYry;<j2e$cJV&25>b>$1vFC?B$Sb931lO0@TV
z_~D1K-oDc|ul{Qb|BJYXH@CE8WJHH`zL|?}ZN{$H?jcilCrY{JytaA7wu;YWY`hjo
z4B`=_7P`s9IxJ6Ke>jF{w*~g^R(yr%U=-<I1x2@&^ksPS`A9T8x}dR9hHwgg$28Vf
z_b3xBH(KA8o*q%!+KrQUZ=&ImR6LZ@aChVn>vBu*=HsgGpuKs@+g>YOKsPVZ>b~x3
za5HdmEIDz>xW+H}$jVc&K^6;cgZT5dtQ`70evsnNo5&fG%xNp_yKoi>5<BoBUNR7;
z^WV#cJLOqVUbpax{)m@Pue#qF{}SIOfV)Cu(`gV|zvy&o+osoiAIJ%!OWoIDh*%C0
zDSO6<WheBryKpivtb7=7Dd1EV5O<_sCfk&_9~5wV;=YztU*drU<j#omT7CWkx0CxC
z;i~$keQ+)jdjPp+mIihr`NFUno5T^NX#b9uWHhb=i2nYwWK$?;Y14ADx!t_zL6J%1
zLLkHYG{kw#ekA7|n+p^Ko3q(QPjO;sZ$zpdEBE19ky*<>Ru!r6s{#B1S8y)i$gu^}
z*hmE-JEN~-+G?)byyXw2x<TIc6U%<ByLg!n?O({Vv>-<}JrzCj8<S}qe&swz>7Wb$
z05nMd0jLEgu4i?1jZ?d5f!iJ?@M-xX8EH^e{bd6GzsSkx2-~O46(P6Uy+%vxsXi!e
z&KLgqkM>XEP)Fg()$XUY@Z|nYr_TH7@>MC+4Ry<JX8^KSUj)u23g{30ze{8e^v2H)
zO>!?@MK0o?1}OF6=zC2uYxc|3d0J&g$diW&k;-KMHO>r7R4<Qr?`5{D-G6WsNGqFq
z_=T{x+bN$x{tRd7EX>l1@J1OzN@A8;mpLKH8(&j{W?Eg&++Ug6RGe5DUOH>lb5N9A
zB9<>o-ynLQJc~D@%V#*D;hg2Xh>S*0u8ClNjQ)cMp0e9Uw~O)+?WlN8qcj{99an0f
zsQ%Q^H+6hmTklOK)$jQQ_^DGlsfdROqD#;yB5JdjuN}r6`|z0i`B`I@e@v~0S$_9j
zRLh<E%;?CLn{e@uUql&9JGs}S0gl$u>zs*gW3_$yr+4dHowG8zeT(miE{4xuE|6SN
zZc`{J{ucG_AKx_eC>n-*sAMP|EOhU=U$H5B|8%-=hPCAam!<DXCO1$qZE_T>I>xg;
z`C|cm>kzs3AH^}hXvezFWS+s2^!%|zIqoO|Vn4fpH>i0a`FhLI$++h*60xWr3P$`l
zTJWvlemXEo#+wr^mWMb7yrT}aY$XekzE;b33zhN&Av41@b0OEp<vD(c9LUEwv*(*B
z!LfZ*bWD0m#6BbPYVs{-Sj&tnqT^W)#y<ZP89YgmUTLtdTMiduAtLJ|_5ZQhFkl?U
z;$4UWCbqROzzO<h<_XXCBZwX#y(Uw}eTL4Dfdi#7A(6#cTPKC==o<!Kz_Tm)CUb4I
zzAfAx%;9!AtmT$Wt_|f?9i6^mMhH`@jMir<S6eHJ^3V0?tPaGT_aynS*?Bn&@uGp<
z9^k+I{O49LIf11B{CBFnn}VP1v!MsitQ$~su(*UA?w}2n@nh@V<g0!k{n75pa~HL>
zjWd*t7IFH%9R12=6FS(_V?9GL@og;EtP9BUn|uT000gbar?GW8W|>4L8VsGJ7|JFi
zHCu0pnHBiiofONiPicGq_?fonF9ue^M(=Mx%{9%5n*S&A?JbKgZ#+qVK9MR;=fW^X
zaR&G05`d)H$y)9XQ%+#J4634eFrVQq;+rz}Xqg*RZHZP^kQ64{yN>QDvr@}kLYd3J
z#1%d!MhYfknsr{#MPxY5%UMSpt2HY>$g<*lz$@9JBKPD?CR)Bx%e?#3VBnk{w0C(h
z%X<UO4D(R0Wp+}g|2*KY=QdugS&x|NGQbt4i)`s)Ip4D4)q6=P?Yl;DGWI{~WXjAk
z9>`>}<22Mq-zsr><G?}UvMeF}EFt~zW=^?485PY<QT&_C<!i}ar?POt0$v@&Z^~a<
znM+14Il;}+Ewj-32F)r1VeArCV4-{DC;r$E2+%Ty2l*Qi(16ZT#N&77M{>X|WVjU<
zhpm>QQ*g|YX8Iyx@tWpv#FxpIqutTH$07LOC8_lWIR7WnCYi1MLMy&Gn^#5wCJ=6#
z;Z1;=6XjX<uw*x5k+2F2-KnXuP(tT%I#k3IO0<N9?x<Aua6fw-*^svcU0CS8g$j%1
zL}${c(BL6vFg*;EK(K`wW&~ap`YZ(ywwZw}jqCX*XpQ2DQlRpOZZ1ae6BUc>6yMpe
z!#AwvT2h5EmRPMT`7H4l1`S2{srJK_a$-l3f`@_MpmQQ18aDhN=Z38yItAXD;+XwQ
zpFWsuV8slrVUI%ReTDAzp2_ZYr=YkcXsBq{>IGh(vGi{(cQ9Q*2GIvW3GRe~92*}&
zm%mJ7kNLCT{5c?hygO(%jbt;v%vli9_rd<G)6KKKv(B_y;dU81BKu`5SQAx;Ti(lD
zmOX1!BsA;PWhc!#GcuM3o!v5fJa#=MGnsr%%H&Wcd)BGe8hNg8%FDPM*Se=6t)P+^
z1~&Z*!C_|iKjU~qJY(<>W#)TmjWL-Q{x%;G(%jD?$ngH9Tx-dYdiR8vg-GZl`NLx%
zPeFAVWFzCO;V&cT=|6(MCvojvl2z|^?)F<!%PU`==DtYcwTY~B3}+Y&G1sr`p@7Gv
zehbZrKdG;h5(pFhCw1On5`nYS)C}S*!{97GQypv}t<IKKeYs?wVN!EoQjv1Hj^3P@
zm&v|+Ze$iBTy16`&kU6BHl=~?C*Q%@9#CkwCYzTf)wBHZ%b@$oheiRMYU2%&NA@QF
z>1&6KAaO3wXaqvU$p%OSDddOOp|;eRMV{K1?ESxDyMi1CB{H&%w~ofm`9S5{S<G2J
zGUg!oqvKKl43uvtS@9EDNh;onSf>~6)|#WtUCYrkt@uIxfP`e3sW@DYK27%?8^KSf
zKA)|P>vk)?TvN`8j`6<27XuwSK%#uhAm#5eb8jSYROodd>E@Wxg@sn+i?JiKBiCV>
z6}if{xO$q7jK!6;=CFLvy$7o+YfVzV*NQ#^%PVWmUi~>)e@?X4{E45d`$W}c-PXx>
ztnVrw|I`m8@?3TzHVin@(=RGV3S`0m3~bBMNs*fsM-y3wiHml&yf?yH^Fe@;*Y)E}
zMCz8Kr(55`SebY2rQj`@_H6rTTY11zQVa7u_5m1=nr|IvVXD0QACLz;R=k7hVl1J0
zx9<g69>Tpva*vLK9{%%qlpk5GebA2ZB+3t>7v4l=OvlhWBO&CG#7}yd&Iy%*yUP!i
zD%Q)?gOs%o^0E7^RQGrkO&lCzYV5!eQ_ra|V!x{G)JQuLVCwH|#TsDh6+T2GU#U03
z*Ku4$*1zg<;TN??B3Lb}I5K2Oj=TIxgNMSlvHFy)5ZW2og+!+Yd(Iz6rv(t-Qu$?I
z?M;m|iJ&9HBFI!q*gY45Ze+YVDA|q!K0c73gJ=!&GL;VrMhCC~xiLxg6R-hD1OK35
zEQPjxq7xM<=}eiH%0doP1Q~~}5i^86F2LT`m%K)~>z_ys^_Y%Mg1A!4-R}tfSZfu>
zH|ed{ohW@7*R6jcumt1j&!y+2K=nm3-{{A^5v7(-KTon7iI~BTDn}l()!+D>E-a0O
zC`+alMXlLf{R7qjq^xI|42G3M85_#ipaei&>Wc=R16E|q9nF?IYSyXCM{t(P^7;T_
z%2CWp7P>#b@0fj8&b#kZ!afT5xGTO7xQmfu<yo8^;4+|{5VTYLxPYA($U<f{d7I6C
zJKU42WDzCY-+qr?w&?EOmX|MT$L~R)r~qXvI@N2JADn*}Yq?~$@SB)ujAt2NGF7h|
zE~tk1yX62GzfyC+R4pIc$;5|cezqGKV%CrhD?Y=|GR{=^Ww6?XR^}tOn)5$h+{Prx
zW(uJQ!K6;W8B0dES3D-;<JA2>+|XNFz&DbXOh#m>J&Xa_oysNposZ2)VF0D<P4==*
z&Q95%i8Weae|Ankv#b-C+dH`~5`cVi`Y|{LRT0~}hp+$Z9rBBR&=J$mxqd&%J5)1a
z#gj<bMmv#Z#b4nEq?_+aXlT`7pd^7TyDFYx(IcW35{klv@)a+uouo05(ER5>x6JWe
zLHjL4^7l*O*WzBxQP3aO&slaV;y{H}!P!aF6PCMe6FuUIIIN7RvFmn<9*2hCq4$=f
zQ%wYcM3wN9YSm5nENfhUmKAy15ERO)QIR)+)@y`i=mr&GK!lasq5F`CMiSr-(?sBv
z8*+KLdS5r{f=q8Ct1PidM0(TFfHnF!nS<BpM{jM5m^+a<tNDAJtt~NE?UFAyyZN#O
zshxb;+{9Xc7hg8Z?BJ`WC+4bM^3+)0IgvACeP?s=*LM|9v-F8Ia$g@aVcoWpVXW@^
zoqV_M19Re>lQPZS?=INMS`rZhCPgk{h82HQKUgsj^5M6$;Tq7!c~7i97rGz(Q<dbX
z9v(`pO`9SAXmy{OA%7>aHZVh$(0XFXy3pMo)UniT+M7#*Ogt-*1qruGtE95sXSk&o
z@$JikC3v&EMUL0$4xaJIkMBTmGH)Uz^1iWdyE8j+Y4y%FD^V)(31342oOSr+v>jbz
z5JPdJd#Fq=SN2tGd}W8%#km0wsFoSmTCJkFL2vO6N`-3o>N`P$oJOA!QkK)G+(~#6
zvi5(o=xS>jS$}PSh^6oTPR5mQhMmqNIO&p+?n|0k=$!#wrbLM~8xZcj3gKgm3+0-j
z2lmXL=lO5vl8h9iKGD64>LTV87VT;&&WKD<noN!f<oW*~FL_7lW3D~B&1!j%AehC9
z?3VY=vRc=}<ut>Sxco&scC)7omOrsC^e2hm_{w|9QM&KTd^oe)PBPj54`pWq9#wTT
z{saO92yT!dK~YgbK~ag?N&qz<EJQK7AtnJdsI^l3tkqq`N+6nD&CO*YRid<o7F%q6
zE4A7}i><VQPy%XgL~6r_8WrtbH)=$*NO{ZuH*@aY-Gtb_e|Vnkz2}~fnK?6a=A1KU
zPUl;jV-;wXx-W+<`CHyz$sx6zn%8UsL)NzyVkp(`3GB@nBOY%V@uyu6_ki={M;>d9
zNoB1OE^GM`tmS*;vd?Ma=x7cP9KDp`fewN|{l~ZCkMIY^Av%%kOiodoft)a6m#!Lp
z`$_#K=_SZ+$`n{8r48A!S52y{GrFg9ufKIb>^IUHivo#Lz}L(AqC4Wa1LE`KnV~0&
zg_^Na1xX#8;r~t-G58<0c73p`oad71H;}IPQ+WP}S&XIb9CMV>W5dy7p%V(N!8%Zd
zK1{5)?u~yab7S2xic7BGaCOfiN%ZviLsqMJ2aoWIdMDfdCfYI{WBv5+2VkIkxIe`g
zk?E>!n&`Idb%j?t<e5F~&KfCJEOtW)UPCEjJizI<flq^BNi(Y6Vo>;o0C!{U;YFdF
zD2MRdcV+1eH>K=AX9t5kcLl@FJGfggcv6uytYJ`MJ^srfp|G4p>uZx*`=y-ID`dCg
zz7Nn2tjB}XG6gmM2vIXoQ)ja$!lL^bSmbBXXb<5`yS4AF{hTUVq&;uWL$=DwZZe$4
zRc-y8iQTiQe3|~@FimHcQ-GwnWR#N*y^-;nUdT95ip^Btte;6Sp(r83lS5+Ft^J+#
zzv)KM8w^3`2tjAd-V0kK-wb}U_V68{o3Tv39lE~u{yyIf&7m?;?i`C|jjS(3bGx?N
zIJOXdoPaA~7YCm(bi@U0G;so?0;nF}MD@1>Js-^$nz=W0K$;O=^O}i2(cNFg(5Ed)
zpNEt_zTf6qT~kK~M@Fa1hSTx93<+IFv+jq`Kddf>%DwSUnDkMPOra7bQQppmiqBH0
zG|M_nA1!5LQW?*yd!DJgO6m^E-*bE`{GSE0rk<NbLNMG(^hRy%B!hO!{?9{-xkozJ
z)(|?uZ(8JW19E(sw|{N$O_OoXh*c@n@fh|5W!QUBxkExXDRaZdh}8~RO$Jd3itF-&
z__Zjq>~kbgts)o=(_80Bwp>+CR1SRMr=Y1;?R!|9ld0Zp{nvgu6_n$~MXdHqhWV&|
zo@&;eB_$#Y(9yfoYrmU*i7&E-7h2Ut(5~k$ahHOpUgGUEgm+l2!T#2T)`5oO5UW#w
z{6r(9tgp~&<YEx-O-A2!WpoEyfMn4!8ugIYYHQ-+zs8PNkRx;H07JXNQ}Ks+CdF)B
z8W_8G9m-F0n&PpWsJe&$k?D^clKdw=-d=~M&hC1X&+*Cr_=%wm@|kL~R^Hmz$zcmU
zMd4j<<P*_^>1q#O5=2r@3(b$Rm3DvnC825%wua$WwlItLG|^#w^1k>A@w^{=lqZ>G
zgp%U9((vi`s7hl|Q<ss@-+OvY=3A<tIFKp&sY?(s3(GS1^cD_N@vlhOv!0soa$b;P
zSE+uANHN*(=!QSqJKY)fD{_euVs=T(4FRqc0?e#Ed}FATrN}!&Gio0|EfrEnbY@@c
zIACrlXNEXBc(Ui_pj*#6e+qY-Kkd=^(^_NOtoBee@wg0rgp_iIKr0u;*#8HLZzNHa
zGvd9X*vFapY&R6IFetLtIwV+Bd-&U-X`py_=u$<FMN>si_m5JvZRmSRtla&;H{+e?
zl3yCkerATN^X+>_%aP+s0w4acZt9jSZ2KKYtE@d}u#~~_cxM&fA}K?cp@;M~>zxak
zI(4$0JVT_4y?tp<XQ~G9|G2+@ZE!f2dH+i154xV3@KQ<L-x$gIn5n9low2uAFyj8Z
z8M;uzIQ$*mnHEnavpn{!ERa-(e!!_}w#IK%lBa4p#d4_g;yT68KEW6RBW0z2Q2cmR
zGcupkNRe{NIK>oj)r_~cwHsS3-arF*eWj>TZ6MpZ)-(`bZS1Lp{UzQ)92uAUfI@>)
zqCm3G_G#^9X@nT5oQ($#_W=dRLhdK^+6aP`IzPbemv%TSX-}UWaBLh1>7e+ZOb!k>
z__MiX+-2a{1frQyoJqie5#~ZXj@ZwJUO$gFB;;56Q_c{C2yrUmi_f%+uM@|IvZ_kE
z{DxUa+pu1F_bP2sH`UM}+Hmg~!mslHnThY<UU<5NZzgJ3>=$f7Nk_Wp6}sIAFv2d9
zhK}cWI03!N>{)JOJ6goih9I)DoNMU>n&&b^^(slyF9~mm!`q&~3M6*%T~wN_&<8!}
ziNjSqj^tfdO|}(+N**?`%Yiwm&jmhnq97#a!*We!xj+al61AaGjn6W0R+j61umI_8
zOZ4LZqVy$%v$RZv)*QTc1_Lu4uMtQA`%~lmTLc4~N`I(hQWe2|%OUH%KJ8==NxHw)
zpCg`2Rz(kFMh!Imo#ymma0ez!e8oe*h(DU3pPYa4XEV!_Ra^~)QU#6O`?<T(_rJj_
z^dy8eSCio;Q9~rj9>Dx{7_LDID@yNJSnm>M(U@|T!(CXZG4w1x(n)?X=e7P5yl^ik
zW-=Gtb?=O{1z$1|D|a~50@GwI2(*xtK2wsgZ#Aj$0g_}sUhb@Mld>n2q%9bzxuR}T
z+u0;#Ytnb!q`S@|X{087%S}qVhq~lm?Q-WDH>q(eNuxAZp__C=kfhT!={z^7`4s9p
zOOsA=liC)NYl0?ax=9o7Bk5vI`W(F`2zA|0(iBa4*G+1ZTm_o+S2yW~)2aR{O?uHy
zs%<9MJWZ0&pHf$wK!39)iTjEqJ-3;pJ2k1!O}gtO>I!PoU2f9ob4hwYld9dM+VLb=
znskMibS6nnnq<yv(H&z+`mrXBadUN?LDF-YG}KMHD+CbDnk4rz30yY_sB)Wmxf6Gj
z3Pw|KtLADaX~D!%ytnbb;9r_3_cfvy%~2`_CQtw9`OoYHvILU|$RiW>2I0__S^5FF
za9)3TAQ~vsyO67IYq7cpwif3IFSi!wnx9enlQBkqoaM)h!{G#Zwu;BK7EhF?*5ZrI
z&usHkV1C3s7;nxJ`4M+O18=tRe{A`E|10&<!_{?+Ej{nUHu0z>UbinSc!-B6Vdhw8
zlb6|gxzu_djchf*)1n8AD-nJzh@|?Q9*;pY%h}8Lfuok@V5D4p6A^-jQ8F24YQ~hB
zF780{XXbs8KZzjUoP4=RLUyqK#VlOBhd5x=8E{TBcdH`7&4KcA#@#aKWAxVSxs~Ee
z<@~xq;ULELvz3+h$ugdqOffQ%Lm@yjd3xEqkR>GrwUE?L27fe6nmvO9oWAfXL2Up>
zIk~)^;N(Np9+_U(GA{q(#b*(N+iFj5Gof=otecdjarNZuEN3Ark+hzF@si!3MQs7+
z^DA^og{X|ExE_(-X5^A)?lW6lY@+MReOEoQSv9T`r>nGa;uP3^nGA3@S;k))beDpF
zz+6S&qdEF!+c;u`V(xV15AZD$t3={dewNNSETHVDo01j!omAvJTdSDFf9s7DDgLg#
zR<2iCP2eaG^~hyD0q2<_Vj;75!a8Mv^0<(scr@{{R6MiAIkozT@lV}x^d0(x(UM^7
z{!FK!N!Wp!^mKN+gkf=(0xp9d%V)&gs&r~r7-rl?u03i%IX^f^4l(~j_ln7u7Aln%
z=Z$WiKAH|C9A-WU0}g}n)AFSPhvUa>vj|t5&E0H^nWEtLxUeCbQ_Gr6G^dS8ZpLC3
zyh4<`b-;qR^4;@1mCi@FHgExuBd!6|sdqI|X{EEvO(>#>87UL~tFj3S@Hk-m_~;oT
zu0GlPPKL*li!6UQI&El&guR@d$x?+CT4hzQw1Y#B*w+m`L`YzZJ5{o+(sgzzAJ$kE
zPv@7eT{O_QtRG7#cJ)fDeafl6M~;)1B^h?bTB~M#e#I&id)BUg+77Kuf6FcnABkS{
zyj{A6xQlkpdK1r5KCbIaTmCh}LaQiR*Nhi&ecjHZ=`B`h>CiXwL+gCYA4gVvQ3)b~
zGO+#ik_iL8VyWftAZs*(rA-;82~8P}PBrn#k!*YviF}TmY_ZK6acQ{D-*L3AV*gP)
z<3VdcUCYtBH;&eQl0gfLcKViIKpXkhPx~GjFM^pY9CYnByL4SXVZEa(_{`GFFA;pZ
zVtpO=eAQKSQsqO|fcP_uh=sH!zjURqt{)V)tHZYcX}ff#p!-grXhxmfS#52@8$W?}
zh2mYhHhs^~Pub70N_XX#f-yUjf-!ALyp45KBQfFp&8_~8f@-T@=Benz7lqDCn|WSB
z(;KDfhh?IcAKK+xDvqs72Ig0{`5u0jM=0P@DxFYi>n(qy?cd1haLd2K=DBnQhg{R0
zgLe{rh9e7S3K>cp>sr$5-rx!u2<C52udCP!ZFbeQX5{;~E~;I8w<oT)e`UUZjqj09
z7`&7l9zMVmkv%Q{D;x#Y>tuhjRreZ1<H;%@*XLQM#$G0y>N}vbGrn({gOuL`Hl^=I
z8htTM=^K*?Kf7P~70tefWDUt{UGx$7!<H2tzK7(}J-c+hb`Tgph{Kxp|31aFom+;|
zoZ}SB#W@L<sA#wQSOa1o$l&YsX(=&fN!v+Ue#O(iI+3E-?bNP(lCE!>--WSah1T&p
zIi3t&^o_JCJM>Cjb3x^TT*kzJbD(7)*Ts#2u4&F<p1p~E%6VuadKr~8%c?jSz~FYi
z_DN>i?+Yk0Uc%wj9qwP#@AvHN;!<)LwQ5%!^!>8!^$)+;JX#`tF_V0C^T++_K1jDd
ztNSed_4i)?fQynpt=obo>#BPVhCF!Mfzx&me2Mrib?x5i#e{vW=h2qp@KRTkb=iF*
zh&aqRM?|^@zaytkJz`f?wMK&MWB>%bkY#U>7b|iXe>pWIKjqH(&<68|sZqk+u2b@t
zaXe#Z-VV{Z>u#si>Zhgb->p5H51-1t15N9AwIh;f>$4SUmJCf>`8#`V-6r{tTm;x4
zow7+1eapnf+-?#WY=t53a9&qy#F32rYmIcePu7Mmo~%s=`8#k6yNysWV0{S&)&bG+
z&Pf1dM-`c-SIA^H2`=LgSds1gj{MSU+Q_dJeUZP{&bA{0OaA6XIlkq;q$)cqQ0Kqo
zdxQ%B0Z4M?YduSHeM_I#98x|%Dz*6@dR%kKvmKSztPO|woBoEi>4>~FrLh+`^shY;
zv!WTK3;69gJ9Gp8y4xrgX_E?-4p!4Hp2v5YDy+zJyp23;HLd4&jvW=~ug!mH(J8)V
zPY5X8h%R|ePFwTmYh6pG_@dWHUMA@#tS@FsRPx$Q(ylY`4r$yZNHYc;1Bl6DM+GQr
zLnc@Vu37wAP1z~9TARXBp`u{xb6!{8VJn&=IXBeuO|b6^7=*;)jjh}?)gJ`C;+6YO
zb4W5TeSG2hGA2dk3*(*jsuf+qqa7Y1Y-O()A}nM@>NV}W4tZ%>Dle<f6FBV^=k1rD
zrQ-!X`19}SuMT~C$|lLO<kUr(Q#MG+dxqz~zG$d#`6`;q=jyf<{9^Cf8>CfxlQejh
zwP6iE(G3oN)BkO4Sj%th6F^^*Wh(JKBsW;+YwNz{zk#P0W#ubizPhJ)6Z;{ebyPS6
z{i66RYjd<o>J#2QAL`gqsnsrY?6S`E!gjl`YiQX%tFXf^Jc#D73isQEhb+Dp5*nm)
zeq-GxsSbLH&#1jxUQ7)$>tflKzFS&jf|fEu68?ycn>#Y>75$o}$kKjF!zQ7G6*a``
zr^H*@PpC#drD3>VhrB5rtiMmUlseY7Btd;qS%uAiospQ|MVUg%aXf)}6f4|xViMy^
zq&64hLw4DbbTHG(hn95;x>~;m4f93AVmKVIqY5z8y75+lMBh}2#9m}C*|+RY;gu9k
zV$_aNL9Vu0E<Wq=U*>OEN%QyKX;_eAY4aQHrh@`fq>H~(nnX-}Q6H>mQtS;P&?b)+
zk<#`i$&=n?HLa32RXjrv=e=gsPF~x<%{U)YK7W&ZU$Ua6K`2q`lqG2Jf;8-0B%ZDj
zsXblWwzch{3XOqJ1{_F&E@z>tsa9JH%U?)wCMyE=hP!w>M}^DY6y*6N6+A1_&a>6D
zkH1q?_0FEV=!7M({nMn}i{_VKTfa=%B)NRc`U?#?I2e&;tWPEOOq0~&e1th|ZO{re
zt6?M}p$RW(XQ50KxaoFOptBke@z<12*AG_x5lM+kOID*QNRzW(DCzdxYQ@Z`kEj5V
zw<mAA;RX~(<PG}I)f9`%To^Wq6ahvw<U~gefXdckCVrWQ<D6Y$<tx{h*yTrz?AgVK
z(u<v;<(+l$Y#Eh}>RCecTLQ}Z!aD(nY68y2Kd8myjhs`I=X`agY^KL<!*Vcvo!=yM
z^gVpGBuj{F!}6w|wUc#xnkj&Ugt_ggFqysDFq~m5A%V=KD}@oZ58WeZC_h-r36;(S
z154~{LaT1tej}AxI$*`70YZ26E+6ft?fiAl7G8;%gcqfZ4vdx#a<Pe&6u3i9WlS7-
z8huMgBE3_z%YBbHpcTs`!M9v4O_`z$>wEZZ+1<ZMD52v>epFP3ukNoxi6((XNt2HO
zD_(su@%ooWDx6vB*e=gCPIR?&;0rPmun$1bMYU1qL}CNk5gA<UCK*1`i*tvTkCMxI
zC6ke!FJz})fiZHEK0SA6CFfv;%yebsYk(Z<L-jHr)%8c2R}bZ=VKyfX3C8?q#E-l?
zTKLX-p1Gefc!6G_Hi7W{tb~s(S!}Mfc|olrCd)bzm0+ejVxgy8``3*-t%peOs`27|
zx$&mY22<|;qC7_}xdisqrJO+iKgO9(`sWM$6#~(PdYkR;j|m|qx0cVwJY8_fh}7F`
z?IF)~+?YoA^`}kH!}*OSel;bExKIedSJ{A21mboP;l)TeN3^PYrR`-v+G{+Q5WW<0
zzinUle%twEl;8w+-V17azwO$)czO$xvL<Z;TNp<uXC_%lwzkFJch~=AIcXHz5yUH9
zZ@$SK{@l7reS>Ex!7{0xBKYuGd)};eoXm%4&F{FY-ES6T$M+NOp#)!Vjha#EJYwnr
z#sO}$2V!)zseR#1mL*s&Mx)5u+i)BW60_(VZrqcU7)`65h8)~TW&)VVbPbSZIb&-G
zC#-#VZM|j??3<bI&z-|6!_R9#zFID;FzXbq<~aHe<BN$ewWx|}DxHs671k&gLJ|Bp
zjt1|lyR5HnxKuf^9!a&#51jebOf;z$c^<@Sk@dC|=oU=sLfXV$@#32#qfG7jd2)v3
z_Q43M(-yPhoA4yZKh4Q-lUn0XyUP!W`3&8YlZ@~r-poB>P%Wed+lw2vhVN!4;S}k?
z^To}u+=+k-sWb|u`^kqBAdnlVMTO-;0TX*Gkb^{W9QvLrHzar|Qd*pyNPqcf3VTWL
zYu(d-W6}#aFJ7DtPb8x(nAi)UlizHY`sIwcX&Ol}A+R=5lyU9tLOkl4(M%eW{PnX~
zf1R2AW?}a3n!~%B+uz;&(tO*0SfXP15AD9=(BA5UyYFD~c2HftnAPPFy~6~42%fro
zb9=vyM1pXGl?VH`_gf=@A?9Sq9)OwoJT~QXsDJxd_p>xd&<Hn_hQ`qlPl6|FJ8w+0
zhllw~csOFh#V#V%m7nhYBMY)U`llV`l;|HhuykzyypIO|&;9cll|a8Fof19rKWF~`
zQcB{Rm|h8vO7;_hFhb+sY)_CXp21zuCSG=r4jTY0P@7ub+%2WXriR%#SP&ZVX8SP|
zi~p9|=48izb<BLdJN>pCOTU$CQ|R|huk?EggXBNcubfJHr{67Op<j76TKNCUX({wO
z-eVV~!<%!nQ>Z5V(Sve-`RUQ4hS}n;chiR^-p)Ln97HjofXxj%s(<SluNiDPh=KC8
z7lG+KmE^sInw!!$cpgsF>6Ok;aPCZe=qDeB^I>qMGlw>*)H9zXnz@r?aQmKY`+=O$
zc~8n^-}dn9gvHBq*fsR>Q^}x8C#QQQ4DDD`PN1sNIeU!peZ4k2zRHbf<&7uHacD@O
z^AH`U=)54Ngc(b^oEMQtd%CNbRAZfM(0LuC6CYG#<rs7te&V7d(csX?2LYrj;Izy#
zk$i%A_Ep)b$f&%=+g!FY*i7$U$8@9KW@i(xiE8vFgcsiQcO_**q~%~ia2WD1ovYHj
z_AShQb9Q#@J{cKJT%fuq6)e>2WdPvnkz^nt3eQhgC(QC~gd~?J`S$Qp{B_mJnN-+Y
z@goJnv$_{Aq<FR#&q)@STL4K<=}M!mWMgpm$F4T?MVfhyZ%#>&;3+ZI^4$2VUjO}7
zeHYBl9P_pB{#T|+Uf-p$HJa!m?YlgJnZt@Bw1-ni8)7I3E56E>tFof@oydpKvP5X<
zS`!RcaNEzi=j*<op0roaKL)<)RQPVV{}}iTZ{3F_ngCpRE0>WO_|EIzt_$CS6!;AP
z^zWYUtKeJyjH0W1B8GmOK2M=v^THG`4E+pze^)Geq2IC}_eQ^hW8j<LJzsbD(6_FA
zov#}wnAzeZfHDz#K_Do1Dg=V=_5wXKxZKGyHR~`g{g)Vpimx_;!_{mvdy&6ayITv9
zA1NXwA<f-W4B~6L=dLoj3y2|U^mMnlPKeeSyE{<5vH5VYw0?|Sl=8uq)4i*;Wp*h?
zO4efr_S2<~Vm80bc5i`h_r|hF?WV6KG_k+S`fJ_f%zMw_VmKUsidX`5I`5^pc{%L7
z%?oPOy*^LN>rA0mW(qHzl$NH^demrMFp2}~>;%e0A#X1-5?@!BpLyR?cDjT&A-}vm
zp>NyWH%s3-dE=ZKTexM;ukL1j7i~yr!+`TB6J2=;IGO*WD2t&>Je_%HxyK=hXgPDy
zkL-Bb*OR;?k$g7zvWI(BPMKYqJ<EAxmFX^D_**Q4u$d<nO~*>yWIhydY|MO+s%G$E
zZKA|Ie4whUsj7;q>_my1`S2#%bVhd4;F5T2&3Sw4TVlUJB`x?9G}1UxG+CG%VA2$D
zPMojnFjh<K5whSQqldrOv$#GNZ088-PcUUQs1ITKfTvo43+|7u6g=4M<WL@kHKsaY
ziZs^IV4T4{57hh_nI0Uc3mgv#99K(oMLArl2OyyM<aIQe-!jL`d58)4g3Bf6Sjkz|
zOSN2_=b|SYHbfP+=Tcc=b|C&d^S>#DiO=i!49*@kD}U(HKk_|3=rMqp#ZwAhFEm*S
zd=ZJm9^aejq<C}UG2jeI<SLO|8xsC}6Rd57&tu;#vXi*M+?b?SAB~U@ghZq4VC-g>
zqQkQZY_7Pg*v}Mrzus#1R^se@d<6Si=n|$D9dvJ6BZq=!;5ER7^xnN-SsTloZB2$F
zWup0}nl?^3!pjy{rSsvp>9SE{-18B$Wjty9lq7a-FJq!$ZDDfZ+Coe2fr$7S*sNqY
zTQJn!zD2Lf2^?g6BDM~}kCO~0k@2vh<*dKJmx7a-cJ<5;Lxv}jKmKa!{tjcI-k0t=
z9aQO!#^0kpK2$j?F^^?^WSg^$r-T8tgYQg<FUjBL3(K)qP8kwo_bwsvZTMMp-`GOA
zZ|olHQ+AsUIkH9yqpoPyAV(;h_-QhK!r5|<^Du%gBT<#Jh}8`DYz7S>0A3fl_Ky24
z<%4Nzh%}YSH41N8Eta13I@8OlEsUWBY3qP<qC6$*MIB|A66{RB{Tr!^(FsQv1aX8(
zDzellWPs(?9A8VEGjr&;-Kl#NB7qdgxX>n=8W2v%4uJc7m{aKH@6w2Wc6o-1s9yP=
zkWqvw5t^ne<_8K>_W`#5zqU+kkDX7dAz3+~x^Tq)hI}U1b4)xqjljuKPGJghC-8;C
zra#M_?byDe>{(*iWXxa_S@n04S5JTB=ZCnS`Eu#hiY_BMmC~<e_6gFjHwdx0ma0o)
z-+F$LzsA62J%V7d2b|xsS|j~gPCS)gJfXNtMyw=mCr`buqtR68lL`mXwiW7PLq+><
zEcxIMt#3Z{@dPl=wLB*4YNY!nN%xtLm+~?G@PbpjbsmQ?dMsPT|A(g7Zw%yGUCv95
zP@^^eI775a%#qV13-Mg4a-M}}rQcfBnVuVj+-{qUtCHJSz?5Gkdd{$QYfR?X)QtyW
zm$P`O)UB6sAxV1Vqte-3t(C?;q}LMqiu={YeHN9)!Rpd|7FU@cb+7KzFvUi5rCvsB
z<hSm!f%l%iV8V&1+?uzy2fxO5*aINc4MHe?JJI*J9!WStnM3bs6GwGVUMf089mtJ`
zU3OMunG=IRLIhE6mmB4F?~Sf<8zS3_o^ms%qZ^)M7?D-0Pj8iS;Ixk!O$P}9_{psZ
zV@0;9I}6}Lp15bS-r$4j!RlB=yK@ibyIAIjom+THuo)91gTQ{E*(sOIEq=w_Og8pN
zLN9Z9ra*sA3iPrL%=zt&H@MJW4TK5kuT|ANp_3#%<-O%sE*|51;!!Vx<j!jK!Xajk
zj0fO?7mAbL$G03i>1ZsEKPUr#JE*^Zi|h`I?*9Yxs=0HRXYM4a8+r1)YGWhd4Dq)r
zZI|md6T?*OljX4YkjB)1-ufep)8dk=AfRXVOHk}IkzXVGa+@=~TJF5^V@26&b++&%
zSm3&3)V{diZ6cpN0vY#(cS(`M1I_htZj|N4?Bk#Zxa&wC`UcM_E5luQ0H~Pw(;t1P
z)jKzPm1BeZA{hb*wf6Oew^3_ZSyj37I-`~;^MYF@&n?p`Wy0dSV}$>f+g14CgzI@y
zwc=DfCfZM(2f%^ZI}D=A#T5BE8RLHwd*02InnQ=FvqhbarMvK*CS-375=<;oaSpIc
z_b0e5R(-_u1U^J${nTwGHXn7Iuo*`d)1w%l!AV|Ys<VELXb3ciou_%ySYq@*z}Yj0
zDyNQdcJe##`q+6#$>!NbuNIlALK}1x2{3gobH<yIWj49y8e?>Xq--`^2l{ki@^-^3
z<rHv}^j%GtM7;m<Xz<*@rCpp1rlC~x^oy<CE)1N(XUTj4NYGtrdifC{PDfGC(cp)2
zBk=oL&xk}lTy!SicF4DB`t4sZu4%)Yn|peZ``FY+O@Nvx?VPFwUP=_;zQmUWWMAX~
z8i+q9Rr?~}mgm3GfE$$X&-4z~ky)yaT|?<!<>A53QQ*J?VRj~09PTA_j&y9nXe*LK
zg)*QG^F1sFUS<W%l;ygs60;Qu+B!o+I=4o$$xW`b*su6Q?^QWVG54*=MAC)t0;6Ow
zZjzgZB0Jq!)r@1u6F)GrY&a^lV44(fEhv#6&hZmQnbQbSfdcQo&F^w&H1>D;9!K0~
z?IvlD%b@gEn>*ReF7&FHOxkj;L)736g@D_oqBjfo$j$)ja0ugN5@z<eq!m{#Q2+Jd
zNENtq%`UN;MoWX08REsadW<~Jo@Og`I4W*MN09<_c1dRXOV}?z13^pcQxDS6_hnXH
z<$MBk%#KX!%h~t>h<b(lX6$k+k}LJnqG?PkwX*FdY0jEG%?gxoUdJlQF!Znv(XzCu
z^tgx?@o|-^iHtD7r{uRcNsU#`6O~H-B(5<Z=|=z4TmY;}>|D88v|t)ITK@VZYB(Au
z@p=`zECnxLWE0IA+=iv#W}@-dEzCqMK1B{i@u44379TPiEM0@kot0}>*IOkeidhDj
zCE84Bu$l&wXnifqpv4`@PD@2koTdl~QqgJl&{>+O+A3X}Qo95(u_BI^qc41skEJ;Q
zaIIa@EC4S3Zveh1RkUa?`y#)R;u3?Cka-gMNCe=AtoYC?L}%Y%8p=xl%vvq1<`m4;
zOAo4?e||&r#O{~!MHw19T(@&qCmEmZPB{ILGc&cpODT}IBY^9bbx607-W*M{TeH*K
zO)tgHauG^&ahpezRVg%CpF)#3CY%*Hn4}4}6C0YW$7fJzvg*Il<Y}p5n@f`)YH<;_
zfpwGMhp!V25{?;M<!oNsvj^`duM+KXLy#1PohQ{4Wh7HXGmKBw40fR*(AkQB5ZHxa
zq!cx(B+u@JqF>6w`F(mi{bS17+Bx{m>aSra=VnZxSU`w!3=HCRtct)8(K?j=lJhgF
z>?S8oQn3d^FX}8LFkG!?Aa9kd-8368xVkb{B_C6He7o15D^mJ%T}pqR)Dx6JR8hA$
z^Js9Ua{4;EV!QO}im&X|+2~ssZzuB=7sOV9wmXQ1>zfH`#H7|2K5wu*;5qhneZZz!
zEoH<{-WQfjfYoNPNMqp@&G`O1`c*ZfFTBsq5RvQWVmE2Y6gBmVhx5u5oS#d<S?;gH
zZ6nFUC%9FVK1Ylg!FJ_WV(V(~{f7iasRD<Z>oZMf%E<V#kilU4(Lfj5m<T)AMkJhz
zGVs_Bc)-8>=aM_MzqWd?H>SY;bPDXZ(XbWiOu|0bt)ld4E@l?k8^02Ex2MJl?1q_6
zmcmU^TY8(pLD%g#`bkLmE>;NbtFs8Yz1>-lI-PSZBjj!K4CEhaC0R*<vkNoqkp!=@
z%SyQa#Hwz$DmL14rimP$)|(vuL>AepU57zy&NRDvBWp6&oDz$Q@Dt_;!%)$=-<5_`
zG>Ek-&ne>J$#kXEMT=XMWp`P*G78Gs3}0l56wx+33}Y8aQcpR()xIJVJIWXS7(c*h
zMy;m_{;Zb9wVBpxY+xMFhgp#h$W`YI6-Iuz3m3_{O_FjvT#dJ=={5#>74%JC^bmA$
z2o>q_h2@DAPZ^G%lt;LLiKN~yAqExkRrgZ3gh2=9RHnHBBb_q@@Qpni^s=ngQvoTm
zR|aV2xwTeQte&LVG)&B<#W))GFq=YQu8ywK^+`IwuCAp<Yfc7iEDStIX<17`Y@j^$
zB-AOrDYU;ain$7H`Y4g%-{B{u9_d)<3(TU3B)3U2EXG>x48Hv6&&o{FPjY`Gb|Mr^
zvAJT82>lK@4^QHwcB1r#6`3Gi!4=c+)+wp{;8}muli<wAftmB$eM|qr6pPvIc)Mzp
zedR+(BwqF|lA<{e<?V<cXBQo+`!GX5lz0_|`MX0OabnlnEGb{7kL@a^@VDD@7g&*T
z+IX&2w1DX2R?+R4kCj=os*b)UUDzaFt=S8#!0mREfC==IeyCW+eh*Z~kaK)*<a`*(
zbIEDAI3z`lb`0_;BW2_^Ns|lSeBm41v}INDAhV+NdrX@`iDTOAMl(-_j!(2{_%lmN
z&d8RTD!h0D9S1Ld1JO}l+|?)$UL&LsQOmNTjDQ~R;eIdu<Xms-DJd&*o#fN&g$3Gn
zC~U8m{NlgmTee-^uSS)8lO!n^KgZT*5)14m$!O_&Yay~JA|@GG7g+W^DQU85HaQ6q
z$&!j$Zdt7lIl0z$t1QE5nax;&|2!YdQDbZ8kO{4VTcJ!Ldh3Mr&&bk!6f+X?G_+76
z{FU_sIp1brEVrXx(^<Il7d_@i-3cBqf}k`AIIq;3)V)k=pxPd1FSNm*AF!repY4nE
z<w5JdN9q=R=Da`-87tI0oRup{_x?x*M$mW@toW9cjaUUx2i#fMb{44IJtKDtmf*>?
zD@~<mk{xXq%~3rUyOhBnex8@hhD=tObLSS#MJGk>fgNJk9^qZA)~0t&@qZi;GLA9}
zf?94tJ&h(k+GuweT^9Qz8MWkIM@w2;VuPtMnqk?|+rc@SvAJ&2@k|(GBrY%}?(;kg
zZ1U+iUql@kW{(mb^@QXq$&z4cOSOP(*@PeDkziVKls4cDyOK`QxqPIQ;n!#jpEu`9
zA=rGWV1w9$<>}kR*s%1)`G#}=>k1!6`OX=YvP_ivz}Kvj%xmXC`J1XpM&K*<Il0#w
zV(eiX0<u}#?IsZnCyjKnfVRCsB*4|oXk%V@E0Lc{=az^2rN!2Gg7pB+0k<n#vqxF0
zGswl^wn6qug8Bo90G0Mo>6Mvo<q4}H#blV&rL?zNs+^PE+KFcwH1prNX8tPxgH@E7
zAOojMxT6$w$4+m;@C8ZHQI;JsoksG084V|8`68c#f}Rxgg+CN*WTomI9>m#8-K)Cq
zvTT#=#@sIDxO$gLwmXTr_e_wy&$Frs3l$PbT>U55sQ!~QSO2+b%c^*2m36wb*p)ou
ze-H7af?S#NJWDd&Wo5k7&`Z~U3o1$1e_{)Wxs;~s@iIM4dVk(r=yY=hX)3=bp-8AT
z_U0%2ifHV4%Ot!)0-_;|IS{iKaaEDJc9niME<Ar=WC@ffhQrJLWWH^d!Reb6vaT9!
z%^MS2!q}*F|M6{8_g!9Nr5z^WdM{xrAah&~TA4l!KPQ4G<odZMfg{PnM`oqsG#Sh$
zv?8_}3~`bzewM>oAZ6{ID`jRmi*GVni!*GU@}+MJ80nB3gKmVZDghnN39}6t?H}_i
zL>Ru$B($0Y92n0i1F*;>p=D$$e}TXj<7Zic7)_%6FCtZ#AmtMF>5a<xO6XsUz^#@{
z`6$ZpwJ70a87eT<+N&3l!yPE{bA8KR5_vJ#o2$9B`Q1Jo`ymhgX|L9Yj1$G=%s5dl
zvI`DmSqm!kvC?gYNc!&sph7DaW}wCe03nXk=PE^l@AZ4lcl`!)l#~mk0!OhO6<jeM
zEPc1rO}bSy&6<mu{2#}k2RkX*ef%-Tz+6yLDqn3uQ#oH<<%EkoXu=x5sY%)e=BQ%G
zXqdr9vXVdG%uYaVtwwlJ(JTk0#lFY0U6z5d|Ah9HU>Y0CA1}j5o@tlPe7LS3L>0wk
z#&+q<K2T!W|DsGex5fu*lx{V-?A4OA`Mo}j%hu{lp6!fWTQ!@k`Sms5t-@)=4Aquq
zwzU?kumpGpC_M0(>;P9e4zDS+>&*c4$G?JhoeXeFyJ7W8Fe?(E+PX;td=ZVjGaG0)
zhJ8n??gA?k_>o5!2*^40c2sc2VzQ$KiA?*7ab@-uW6JEnXu{BqDsu)u+S{=Iw^~iL
zwblYlf6PmM-zBR>ikbut=P%b#{c6D!YasZIBmtEg9$T{`vX;(@J&IniS4%-d<^a0H
z0Hz(T@cf~{gXjAxW{BUw6OSk@20TJXs;yB<`*ddfVNL(!VX65dslO=0oW|~)tQlhV
z5q^~yzWX4&uv(UE&2@Cb3u@L~?U{8YR3Ma$Pf1GiewC4h22nJm>}UwLNIiB$N+gk8
zmZ@f*B$^Cr<{gooV&>_Cu#=WG>?C;;?4$*?PQy+c;eSg*fhs$F|7t2qiehi<^o1i$
zXH%)Sn(R)Nt^jT&)z%1g8d3c6QYDcn4z&jjPEi4qtO7E!=sfnAZim@=g&+3%V(liq
zq(m#cM=CV--z-D&eS+`?=?%ODvc<}fXXgiehIG7Fgq^6o2sep|;hF>%&PwtM2BLml
zyTiGg;ZSYJ?;CYM9kC2EM%Wu9W2Lj4AGW2#WlpF-VMsBXJ`$2tj+!Ndms#`gN?Mx<
zGxL&Vrkra9Zln-OX?kwnUNZsw<wpH(ZH^5zW1JnGNYiCb#xV^pk_L@+C0U%Gh!#-m
zs#m+p-f*SjFu0~)nl4=Yx>WPqQEJxluOuTjPT(=dtJu5?CbFdO+OF)S4Xko5S=bZr
z&;KEKXCy2aU1lfB9`=@N#H1f^&Sd|%+p5q8DP`=J^*ri;{EVcPWXM>*Mjp#JGvW(3
z$s^bFab&PT9;ZEYq%~a(8mmw2eiC}!pRrztXV~cftKGNm(BR<Q`^GVZU5A@UmotTx
zCb(O;aXYoty_~Z5%l<~)p{(F#ay#%&n=9jVDwI)cSB{R3(g^|FN*D>LH1v$w4=B&5
zJA5=$oVs%^VJ40Sa}lOW=g1U8+?K?ipM<6iI5`-WM8U)CX!o{Im|wF)AuA<a(VW+u
zN8k4VjWE*dvh|(-(Z<plZ_ZQ;-ZM*uIjNNUnjSKZiI0UZd>YB@eakhZlYr+m7|q`W
zNVj+(u`DMZ54Rxiv46VKSkqPIEX0@-$XeoWvcVN^H#_Hv_zv8+@dnO;VzGs?H4>Nc
zPF1f-yJR%s!(w)U8hXEg!Z>zeRh=T9JOGL30{76SI~m{5HlT3mPxj2wcA@M7)W1P~
zGR~CgXJIA*p*1$eIADu^pTg17gOqOdA0(R`0{PR8T1f#u%>IM)@NXe`xwHEUsMQPt
zG1`!AF#9{iGKuEA;as*~zQkq<VJZ#+RfOuCTafn{e69L>Tq4K~_YP9!7=TO0uz~Ev
zr!k(6CT>maWT}kno7)i;E*lif!5MLhR+bD26Mw;*f*wlQ2;44Ij>(n~jF*hJ<K4%5
zGj2Qr-$)tlB>+gFt>H&ZD3vpQuejTNt$V~i^T`!1gXT9DSbZfX$RQJK^>jJS)SkCf
zt}`#99TS4B-Kl&Ipd}J!A}*Jyx(z{G{4(K?BRdyvg%jaNVa0#s(*eI!e)s$V@aM{s
z4gD>G@88c5HO6&d=<%1~CSjg!uJi-j&C2no3!&W0W<mp01cUbyZRETuiE~g(mY|N!
z%!ew7Ni(>S#nwYkE2^tlIs6WC@CnZQfQVotH0^Si5=oyc_?%|n4RC?j)$B=LB8SQd
znC~7ci|^24r<<y95Q#S}IE{Q7fKLA|7~{c2INJ1EQ(~bz`%X%LD6+M+z?0r%{G$wg
z-V*x!4%}zWGW2=Ij4mnkF@ZppMiRftbF}t_->0mGcnKblZU7@L{MCv5$9zy6<}EhF
z#<6H`{5U;70lkWy$6;~JaEZxa=*8Ng5@tkI`GOTfm>zCR>?uZex<ox_1|kZ02vQ$!
z0q46g16|<uQ~b4_wEM$kw?B`e-I^1>f_4Oiz6*GIcon%V#6*w5Cx7wkt#qntQbCA`
zNuLtmR^&%Ko$L@Xa6-o+0uptvx<&by;BdPy){_r&7rrlX?W&2NB>GF`!;2RSuHvuU
zX_Y!M25k^)jNpm>E?N>N!*B&DPRD3YI^D$qkb<Ae-;%|HTKnC=gN#npka9t)6sacJ
zYSF7vj}SEP?a!W(JU#S{FD$`Vq^(5UtYdYKbx)Q>IM@obnsfVMl!N#<Iq=6Q`+;mv
zD5<>Mxs*v4?hJI7)yFQ*!H~b2a8-j4s;(K%cP>{ZDR*+o<p~wu9FR^lyQ%VOesmgq
zg0X6<7Ie~6?jjn6><0*|#l~XDL7ALRTQctnj->T~6M)bZCs!*JVQCqE89uZYkCwM`
zr}4LZA0nh9%jK3nr7)a5Tn~emEoi32Sw?)Nf#MtmwiP3oXf?~vp-VJ!k*Z)u`0vwf
z-rks)hdp`oM30A#;mwR(p+SM$#af?G(0J8)HD9JR(|T+Pl^cDSx5Ij0n5}|wiTHeJ
zY1OffNO1~3)^(1FmL4$yR$Bc>1Zu{v$3)cq9PV=!M^gW*f8_-0b#WSQwMyHtFM?lZ
z@SdUO!Ci6;l<jNAGd+X)GU&5;1yCG^l?A}P00F-(dtDfbxf*N&2gtSF10?0XES3;A
zcVL`30*SgWbXx2$onYY$RyEqj9<S)ctd~efZDtlL*PXgf&8`0ZQp}Z2{4rTusc6%P
zJG->#E_)PW$ITQ{Iqrt@GOX#-Y`=J~;aRiasw}B{K$jJCEaRFu)k(gv1SXUD8oVs4
z3F|L$dD2%et~Q{L!+w?XzeQkM(P<o44>`xN9pbq=1i!8%Zgb|GD{97I2VVYt7A_k7
zTc@kd-#WcSWEi$g=rxSIKf|+EkY-%$y7Fga2XA&!GzjvcgD3I58>Gc$fO!&N$%@Ph
zuIi9^@^nT@3yKJmh90dMYA=L-t`hmm+0r-zM>ZuxKO_zRXN(VVhAd*AFU$GC1jRi5
zu=1DMtRo6l$YXLDpNClz0dG0N2Vh!X3H1q+;>vT>jMoo#t^!2sb-WBXbrHQzP?(i%
z&&;uO69R+PYWgOLmQL&~UCgx0N7+|pF&bG-cgd&HjiAiopY-54;*U`2<lPQ5I&GwG
z5n)?jJi5C6qhgo-?mmH^ZGTD_O~buOEa%aynuKAxG2oQd>qkqc_M$OI$X@uS8z?j6
z-Vt_1ExDW*>BVHDaXeMzJKjfQ0@z==sUXlGi{@ut;OrT^J(qp$4Ann&X{~*EhE*Dt
zX~rkOz%0=o#LKdG<)u6mY4e5qQ<@=HETD`>S#Kv+6?4zDI)~j6HaT1Q-0ELxS`f<e
zwnl!4TJC4%4*Kf^KhoUlua|WE=T6(w>R&3)gfX)#Hn#d3<waz?V!az7IW7srqpGNv
z6_wJBc1EKt#Q7VA81J!po?Hp!3J#-x5ShxO73)O&vB!Pk3uJju$v|(NW;bb9i%K4z
z-{K4B@U?c6g2zpGtQe}U$1W(%w1;936H^ANke<jiffZTPudLEY!MaVtDE;pHy4h!f
z^4CFm(@nTlRzXGcGSC-}KqmwN|AsE0SAKS<UViGZ;fNAcR`4v=yl9-=MGns}b7*Cf
zC4?#()mlgm;9WRMe&~O=z<EJ*fPblA`>a4$)5r(}e=N<fXbk$00Ji+go%hBmH<2uC
z(}d<OD`WEW;-wUZwEp!%vcinm4AH}C2ra0b=y^F$B6McTo=u`dW1>9FxU^t(BDWkx
za>pkTyOByIVN2+t_aP|{Lys;Yj?g0_@kz}_5BQI>i^m8yvTH7vH)Il2gwkcRoOu^e
zKsRl|EmFe2M)Jw+p9Gm)>5Du|B0}VE<aXVMCV8?|zerfQbg8g-8Ro+*i4ELn*DMWG
z9j$my@b)joM3UW;g;HxxJzO`#;-{iMpO8X#K$4h*Gn4u70~ss@PM2)DS19d=1URk?
z#{*3?!>oYwTYQUMI8P$0h6yzCZ#OL<i)_5N!+X>=-1mqa{9$$t>jZlU?YfS0R9e?u
zHzO@pc0{zDVF3TS8&bYp-0e%7k#H?@GGAN{^@Yoo7lmEvi0Ql}YpYFag;?xgqEbXq
zl-Ck1rk$729I-$5$g{5P$|RuTzm;0Sy5^b5k9N<GX{E`JclP+`Av=0Ovgs=%PXeel
zDP)+~?aRao$$C%dQSZ7N&P{$4|1CCJFE~j}+4?WZYos!AE7Y_7E2NLti)6txX?T3|
zzU=SPXEm$Dy1ZLHm9DV-Ygru^<K!}XI`?>(wF_d_K*)eie3YEmtS&<NRXOASshlYV
zbm1lP3#p-cEeyC!!<I=DzqP)l5@F6Jnq85&vHHR-@_Ln+D^}@?`0bZv*aNMKW)@>O
zz<_s(>gDYMq}V;nB*Gont(ra*=W^cK%#YY2fZT{14ci?kR}MkgQ`J;{jZ(J%MVsi6
zfoY7}Mb<(za+_V+hSyNt5-b%0oXXs*pSWQ5vHe?xI&X-UE!`?}-Z>fgr++OWdO{p*
z(DzS(T(}>#aN}F0Gh?!Q*2czntjn4G5gkC(5&tWWY;-fk`{j<w)4r=6;mVOLg<v)j
z@Gy8Pb`vl<&6m)OjHlnCl!~!@4!z@U=lC0)d1J)%wQE>?6^*zxzY^;tUCFvtYFJDS
zcIk_@znOj7)<VWoc&kv98mq$@mUqF~az+5L;X;aLqn$1s@HgQTqjo<feM+?x@Xn|N
zVypOQ?3H$BcdlWqKeK`v`w4uL+yIH4dkDyDUZHoHJE`j0k5WF1DW&ayMKPECwq16`
zN-VBj`4zhs_4h54yB6(=M)u{TLtu~A3>6gPg+Z6(PY2Bl0jkx%RlC~XPH{{>%CzTa
z`j)4OQhJX+ut2Sh2cfADiotrL^FW^Nq7V<j=+ETn9h(5(>WWFLe}z=r>Q5c(T>~IC
z2$axfQ*;l*7q*y|)NK-_$9C^=kf82RhA+}jXmJUG2TU*%ldDEi!eXe0=SU{qI`A1j
z;!EsINqis!AGw#PKh}q$=JgM}qVkJn`%1KLz{#JGP`*DBSk$DV;>c6f;SMcZ<k2_?
zi2qnj4pW)&*cG;O!PWQ{2uP=j#L6D_2|U<l(P6Nrft180l0EF20|Xd3paDj@cHhyp
zw_@e)I}YsiuS{-ha~LopPFpI}#)si`Sc`Tbr3~?|*@Pr>M#8^>Q%-q1>$k*yM;Uio
z<c)4?=_Vr?^^ZVdB9jW7&kA^kC%;d{G7@Tx_N9TuKo@HgxUt548XSxTH7OX9f@;^w
z{Qg^sH^epIIA<paTB;4`sCxwsm{E5Ui5wu_SdL1XMUw&N%o!eZRv7XU#7B1!#XZk7
z-7i_s$$)R_=>knLeamIW6aTIDhhc>N7ixXPN|k=>N4^xc+$t0`rqHwb!VI?#t8~_4
zZ$O`vY<C_c<q&9ZOSb(kL^o{*rILz`Ot^|N0(yYVjMtn^LQnjRofONzHFg1F4Mgl;
zpQ6>rmdgmC+|5W3StqzAhNjVTl7m(gjd$nL$Hpg!dgya1NpR^=fkX|U$lH8~jSz6n
z1~nRO>8T{mm87T)EOIuZOOJ0i&Vs9)zjP^F?A=e#j1{Vea)*O6rA)<A>0XiAURgsp
zSrzIDw@K!$(89Fr45wMh8T&O=vX<}<#1DlRy3{IN>RRrx-%GE!9W53UjNle-hgfpX
zEHm~ik@)Gv-C7%4%cBC3PGsaHcS=7X?_Q;MrFM(5*2^eqW&DK~8m5m7R+TE$5D|*~
z0#fJg^&lA_EtX2ZvO6E&<R-_rDw^ltYOwkk=@(VXB99D;xI3UybvY%8#4wPMuZ5X<
zeA?Y}nH2l6Xp)LX7htPmX-uwK>s?JMd>^uhMnztM(xtJ!!W<so$4&r|ZtLIf`Uj`b
zGl|jqGHX#+U|`fuJ|2~RZyD1|B1?72VXWA<U!iLC{|}xe>->I(cR5pHb>UM!i;oPk
z#^eak20e3LOKk$%-{#FzHNwCv7^2kVS`3&U!P9zHXzg~c2UIyy;%{S}bOTdkRQU#G
z#G&VqV4nX+me1Eh>VPxt*Gg(`^29@pGl9GA)7`~NXUYZo!EH$o19xxujGhfU^{nwQ
zMU-YS*(VDSxFiANxMQ+bOIC9)@bQwbx(&zt>NX&7HwDcR{%)8a+u(?94XXddS2fuA
z60OL(u`lu@<EvfMmfmXBNP~FOIP)gDSo@9oj)lpithnDKcw~_9#!`l>SoTv;?6W`#
z>sB@gY^pL?iKTDd<2&kb-bHV`h8)P!r?Dx|&>Eyi%(;n2kPWGkC8umy+`=aq-NBKd
zicYcgunwxkflc<><WvyHkajyuM2v;dyM)kEzv*LL^|(g@deDE@cI&_2kV#II9G0y)
z)-;!XOd;YgbEc$=4vXnBp9#ixr*w!eHOQ3Ya-FKqa!z_q>!Trfh_h4N7BH>xh}AcC
z8JUz+_s<tR_mM;OfG>QHd=VEW#Mxx2lq}+S$r2v=+@6_H=Ip$bwBiiBVJe+%=L;(8
zoc91j3l<ht<@>u94`6p?{9sZlb`cqZa|;!1u?}>6@_rZVeU-=CB`So-V`;q%NwOm7
z31y@2VcGf<sdV1lE`Y>jX+&Y)bTjY%jkIPLjFOvz0itxf%Zp5XhhPz#<7}^BrS@>*
zGdwo}<pH0IWb28QE@vT)q{}vHrBhA)RPLT%L(WzqUSczB#H?&PPp~$-q+G_M`;)2r
zw4x7G`g6-v`iUcw5d6lZCb3KF9i6W)&SZ_{Xy`@56u%R}|FsePXGHLS21Eg8=CcY>
zd?g)WDlGCm>GQB4P@R}Rgt2fvOzWl&JKh)mnV2-HY*~2azTsA(qRZG<NGC554|&!-
zkTvy?zgQljr5v?>&UKHMi>FIiNTn4Mou_fOj0})RFBx|g(M-4pH-}2+*DRBouX0cv
zXm!%1P8B@~J|GpI-%IY&dXME<%3c{)l%u0^V?Q=k8N^RNrsw{+Ed{afNM6&&r>i1M
zp}DhyoUUHEoP2D$Cso+w|J=x&)JC#;ZDgSg5r>`gr4e(J+J59%8xghj^K;xe!LkX8
zS!_FB>D|1&mCiYkO-Q;yw8N|nMe$KMQ~0H{Ub}C*2#^RY`zXFhgJjg9!YHQ6jEbUr
zN*h)8a2(Msy2nxL>MHb)EZs!Pyn?>)1h7zv7cHlZ|IKem8!M7ZVW5{q<~o|CP_nel
zW<oy~J~2vR6QhTx6rKl5vCNU0`Jx{xmV#G)#XeOEIRi+kX6<ZWdP{5v2zlES83Y4w
zQP<>|0-x)ed>PL=ec%(W$#RXaZCsPb%A=WioTvqK2h+!6!Zmr}sh(*V>697g3?n$c
z@L_2ehiBIrTTj**UHS)*G`jS8o;+Rp*I#JgKosDTWmJ@@_=!Y4lAMRb0NNcq#Y>;l
z|HSLhl<`LHm{^bUOKPTpHtVt+v<*$|p_M9j>74$avw?v1aeo`N$uh0!ZJ7v@CM%1N
z@kmD?AQzuy;JS*-tX3s9Qgr<|KGiOL1w}Ymq?!A;_rYFrtAWgDSHdaoEYtR{lE$)K
zCoqQF<s*fUfYIMErH?Plg-}e2IC9t_4xJUveFK@?3IJGrdU|pCSIPuP4&tLHWdc(n
zsw&_Vv339|e5@DGKT)D9Q4{uf0D?@FS$N@qX%S;*2ea!AeypMrSAdUI(ywnZ0;MwW
zHu_C@@|V}Emlt+frSnd%*I-yZ)hgE0W@)qRnuv3ze^tQwV*(~iVvu-7u39AOnfbp^
z*7C26U4=gMzN(s}=jnes->zB7V#pA22V3bZMxLRgyzFwmBQG)@t+OjuS)RkV>l@Z;
zywRQO*nL(<p1N^fAI3&`?DY0LYEbg2{p-Aq%>|8OSD6g-{2g<QpQH5rnpXeQ5SA`o
zD?jwS|3%Cd)AKJn?}|A3*J{r%)1KFCtocgMvj&c6=+549jk~~DnubA~?|<4C<su=O
z5i^$RMjZ1Pu-|HD=mBznJC1*REf7~yGI6IzVF?Wh7yOVK2?u3YtW_4c>~yb3>KpY7
z*<gWsh-{qTWqdrgtDWYQuFe4#?dmPnY_rb|SpF9)oi8x*4R3|fE6{8^t7igbPNt}z
z-`%c62GxM`hf3r4_ck=d)pgXF(!pzEvee;qu$WI$g^Oh$mGn{4)oZ=3Uh6#O%4fw!
zYI#^*rt8Ur(lxG(ckk#j=RifjwCm@B?)Pa@rBRp40~xWGylLVm*Ga=dE7RYfWSjn;
zZTg$_QO*OBHqWl!Rqm9*-)4ZdOa;u#^7fWF`G)Uf_mGNl%akjcaQK%+)Y&p1Fh1>Z
zJ~;sLo*hsm*<~E@h4ZC8F#sn@nsJ#ME04xy?nHSsE^|J4OmUfmROrJmnPn#ZRXl&A
zYwD&9ymxfo7xZ4avtoqlF}$`ky0E%PEIE<d`m%2SO$??5e?Gz6E|Cq8RObze{8Mf!
zV0qvZHd9<5i+LkySX`3CAA_xqV&aSyX9t}5t{Jy2{t&Hm*>0J0lVKTaTMXt9J!;>R
zQRxhMO2Hzvl2oRR>~ALGOHah>Yx2N*`|L3BrI!kjE58y*_|XM!N9^9y5g<3h^sPLj
zh>8HM2+&@J+sI0tZoui6hC>85;Pm3P2}1VRzc=wo|2Wrx%hnuGDa1UyQjkH7woWO|
z4d%dRti(IWmrQG+G2x5ctJ31{5hMC0c5h6KXaXJGXez_cVkeRyZXxj<iTFNQxC*?^
zCfYSZfm6A=R*oPqr(&{;kCJu3R3AHuE>NR)y^yD3;8*scRB#m)0IdS|d+A4=b|0c^
zC8<r}WhZDBF_5Jjf9xKQ*cPvq4!fHW*{gC4zT0BAy4@&a&Gesosn<w1s%4(=FLdKA
zO0;X%pqHuA3tnCl%rUWHiD_WMAU|I!>$xV5v&N?`cdnXa>XqX>-07R;yeV2l!q%`U
zcw|THk0>~j1vqgs_;v|jw@AKz$fU^!x|;Pdvcg}c%|z(sOK3ACB(rpa<{m4s$b7={
zkCOo5kbW3<+VlyY$Qm7!l{7LLYAWH(`s?%wb<KV9r{~m2^w|-W&R#eqB@>`lI!~zC
z(%~6<!Q<;DWdw(ipLjnni|*mnp5(iFHdy%gIZs@uI@D_2=I<K2&HtG$Ge0VWgv<|f
z8?uSv5`KvH=<M`p(VwC-k4_!wdw7l{6#ZBpuhPf1sRMlv7xTz<^}ev!t+j`*_l5KH
z;XGe>oIae!a<M)v_J!qsY;HgIg@@?FS-!A@=BYhA&KLd{q^dnU-WNWg4`Xri72^3j
zSl{8Y^eMjZZvAjRhhp{NGGDk=A13?4f7FKpJhAlQOka4NK3w7p|5P8&@r8e&4`X~`
zi7Quoc!Don&qIA%vy%ZHkL=~8u6bg;|I>!@qeKAf@JXPd<-&S(@A{%ed^r%U=nCB0
zcUF~iX1)?IUfIyM-oK~LDV*Bx-rNRxx{;^j^l75hIu-V9C{C~U?@eUl$<4%*W<p$!
z(pR{zygEtiZ5UQ8QFI<O!$y@eVtl_e_>hsX2CX+&f?MUVKO#r2I?v)XftZH-oXvPy
zrgDZreKAmLD7U(19zTsy$`hwVJanDE3qOiPeG#lF37+W2jYo)8pucqmrPiMbDQIg#
z0o=G~iVigr<1`~!ZaD2mtnma3vLuoboa_cf*Ac>0HHxZ^jp^QB8Zc7s#*0yY{c(lx
zD~mkD_GcX@>w3;{mpk{LbVTqpF~pku?*+L+qze=IN_=D*`m`DcB<@11!IkZ}8GN&9
z_BUksNV$z#HB4H-nL3vs)uo-X{L_-x+>kMp==aW9BvNyJOK^MM-rAb?(n4n`Z5`)k
zQ4Fe#_oCjx2aVxT$2tYNqcJKv+2ogN7^x!8^=O^M3Tnt06ei~2mZ|5mcQJ4akvLzE
z|Ez~TQ~FQ!=ug-zF@_KI4d(Rdg?G?KjnKcYxi3B7Tly13$Miy~yzf1nl=th=p1Q<o
zR))Iih2Ny)yIAwF_|i*0J0+h_^KEsi&Nupl1xKun24M?!=R|1|Pjqq)Ydvhy`L{v`
zdv>mfNIS%zUsZ+o)^@ujmw1)<Yw%U(5+d&T{$0N1Pw-G&ThpF)|6dyX?PHsHy+r;5
z`^IyM+iq^Z|F`s0Urn!Tt_^nL6uM8=WqNq;3K-RG_;-x;Wajc=uFQ0d(lDlN_#=#Q
zrDm&RBNE!l+nrkPQI_Yt-o1@P415q&>=t1!@YQM+%+c4fy+XW=;hLN!KF(A>;A={s
z*tvW^mf1(nFr~_!w+Yci2sZI*qtt5`nNs3v@3!8O7{8P9iI=9_?J$LgQR%Nt?<Vx{
zhmKw%C(nylm}-p~LtP5Ib&}@xgm`j_5KlKkyy{R-AwHK6gDahzx;I23gV9yp6B!R7
zf2H$}GU2-pI^UUau3;6W*MoE?N1AHPmGfEVF7kfd#~$ii9RE-TqK09F{5m~;f!xu4
zR&C8^X`vgSFX#2vn<1;AJRQ{-JYKFvAE4#$+eNw2@egRY%K7*V`jxqqMBtd^Asssr
zXi$}#PghX1vpbx}klNUvA$1_?|BN8FRZf{{LcoYOr1)p5e5Ty5aW!&BbdqD_v(WF!
zr;OLWrCbEti+oP`XHq`@6c9Rf_9}P7Qt~~a`5fo%a||)f`3<prWES2jjA^TyM6aEg
z;Ll(Yi6RcObICORZROt=*?8nSA--I%lDLj{Sa5v1))2@|f4$t6Gal0}(56(Hy2_m<
zXy+03OB@Mx3~IzwoUOU%pOz%8<4ii)6)7(&UhGU#jMh6=90pBGvU`eub@GM|-&fH4
zwPK-nvD!z)(EBy$ftiVTB=upr^D?_n2rP({J6B&V^zI^)DxYroewvc+EXmjE+;z4g
zx16o05K4C`rDvez{+4UVEQaJzdq!^A_$_jp=eRtNYL(76pou-x@Zz@Plw{>jwb+qF
z-u>EWLokicmx*4&$Yl8Pl+G8(X?J>w8@d@m_Z0O;uL<JQ9?GoySNh^R>i*St$yFTh
zhaOx`P%R<$0rN}^5hP1DT#<rdxaIpPlFrg2K2S}3q=Rs)OiLNEZ=pf#f^*&BDCNu5
z=F2emiwEJP6bMb*zo7cyNTXq{NNx9fd<ZS2b69Uin<j%1w>t+ATe>NBDN0l`e6L%E
z4(By8c%tJA!$r(_GklRcpx692N`C(?7B}gzwL@IFfH=X^<&KlOtr^f}x3jzXO@D{+
zN#Gg*U-*33?ag-S?)?F~x})3~j~+GrGE3(;C=h4(VAo%8shNhVQrYDZ;9?+?dtxe`
z($7+1T!Xq%7@y!FRt3b3w7t*Y?%vUI^{4+fmnA&0yXIq@Cq7o^iB5s<j?TT+&h9%t
zwyT|TfH&8%2nzlV6Y4NMlwK@AOR&@SfD<fGpi4rxSzj_uTDBRgM8&X8e@*V6J#^}6
z=*avp7x%Fajc==BiH8w;b}sidWE(oEv*-{YG$Bj-Wx2~-tHk{A0<KE;^dZli)g3XJ
zXQZ@$@G@<`Ab5@3k3qm_?=G35Zm0=f6^a*E$R+UFy#vf#w0sfN>e0d&_2H2dW9;Nc
zhP)jbiP+5VUH!~G$}%Gi)`)J-?ZJ{yQQXX@Jbi%$tGYrh*fL?wa_7gNiXghmK`mH9
zY8r7!%HLe7B2}h*O#ZwspGK<8@7#CUePVpatR)DfS7WMLx`?JApJv-gHlFnim$o_*
zZ9o*`E+z)@blCZTr`UHuo&0DU?$c&oE|!D5*jHguT}0Fn!=!l>$=m5%2#4x%w+}IY
zv_3vNtGy~cxR;s)U9XD2)QkS@ot_m)<$tH=)m{GwdJdwhW9fPDl3wV!oD(TuLC^i4
zB<Z<84zBb<&o#)Zq37c~DLvs>kAi&?6ugK`W&!Wxfi4lBV&yhL#Mxdw9ua4lguI>c
zzj*U|iDxc8v~0_XuOWJw6Bj(_p;mX`sjL*!@$3ZT#CyiX?*=(z3!LD!^ESda)2i-@
zpN|#^Rj@!NfuV}whkl4H!N9HZTx)tRB1_DhUz3@-j+S->=cl$RiV1t_V~<`{&Lp>0
zIk5RNX>gAdqOdmY+{Tk91T_hEub7$~g!n3JF7fx|xKuLB-Pm95{WS=tEO#`AzA5*U
z$&okor5Mmk5wm0Szd|LsitO;$>14f%Ox&U8&S7UEV72W<VRvT8tz>7@Cv#;AJd_5I
zKydVKC6h(Sqwg?QEiMV3;DV*Ym99=cIR&1z-T5m)L}XA52_enhWf!1YWIIgAd2ga+
z)2`JfEkBp(w)_NZxL_bXwZ~n#oR*W|;`maN*5ZzLA4%p^rGl?Za*S2b`U9GKm)T4j
zG4o5RcPl@O_LA$duD*l6(0B0H8Yq{<*W;DnOs0&)w`aaSBd2BrZK}#jcF_08(Fn<_
zoQsVaZ)VhCajuuytKL{}mBcB&TwY<RU&Vz)ge~WV+o~r{;#H5_R|0fpB{p=8Px;2B
zj4@coqkvqfL@l!GF@w>BDw*0#=M{--%$*uadx3YTrUFwdQ<R;A&~`4O9pYai3AFnA
ziv<YW7O-IhPSz>B5gM898T#eFh2iP`A(X64%*DlSb0dAr37W3_>?J=I1S&e6Wg^z{
z=s1rJprV@8dHwSkZBR|t@c0n>DFa-peyq?d3s@-ok>OnM`ZhXOP&f9u7$VX?5AbUb
z5N2bOL{ODslBuF|15--@xS3e?1FV*r3nxV{iX1`9#|O`>`#7WSUlOZ#K;F*$mYTs7
zwR0xsS7Zf;$%c%-E8sj2(Y5&fuL-3>UEIGH1)rKOf#Hxxa^87#7msB=Y0f_)k9&hR
zN#qGx2^F|1p<IF8pC{&pl5nAr(fI*&3V9!ux(8D=G3a+J?k7jbnCE9D<?9^?1Z%77
zt;@Lc21(bu7bbe^pXG86s~VRe&I97^!l}er@-kfO?Zd7ll~!k7TODhpLbd{`TXbMe
ztXIi>MN)wsVu(GmlstM&6Uf|FWxFM1{?-lO!8BNH>jju!f$uM*M)3U!zlv?$l=Q{@
z1zmBbNWr)8)MN0y6Ww$SzTM!xvKM#{oze|ncYT}g8LQoMs_C9wu;#uXDQ}dXELdOi
zfRIR6oJ~~r3XYCS4|8CrI*X`$8M2eYA$-vOd?SL*{5#Y){$a82w-<6Pdso9yT@Nc9
zzr|_`?XnIq``#aar8~VjA;=xQ`7Z@epqEBQc2Is;VMCvy$?2iN;pWgmt(I#QnyXt>
zKImU*+%ClvB{&T<PNVUY8~SMf;}dgyA*(@|4Mpiil>VePe{!%N2XL!ftnKJ4mOdv3
z(nB8?0Lf=svwSIaIpR))!*eun`QiVFZyuh*4e5oT-O$*<)rD4<BHmCdFZ!q?*sLUY
zE&f6Z|DbQd#V{P4pOODrXrP=JW-o?#S&(*b@PHxh7m(&3)3vF-Q20`}sYAUs^~cMD
zf3OaN=Bx4FfOv9$h%;9Wr3{auOwJ@vdMWs2fh@>}J{JOu{6by`o6Yq)!NGaW1+`PN
z(?VaS&|lzH>7c6-3GccjGoM7p89ILp9j(^c?1sMG(3jr0#M%@0Y5%ZT9W75M>1+ks
zdL6QzV5l_tA)!_1P3m_vmikr!^40h%&X%uCp_e%`Hl!h2i4xwqaDZ}Pb;}o93W8re
zKl-^o;n#wlZ872`2LDkIel2v69{wVUzc4QxQ`j&xZ!c>-S=2Cu7uJ13f{S3<P?+v5
z1cpYMu=!To*bdnH68Xabu(?nC6=HWJ^7l#PkCC%Wa>^eLEN<=_|H*^z9^&P}!;%!*
zF7+oC8bdGCZO(|-rr-y8Su4l3`y%)q`u;mMaYGl6%G=R!TzJR*r^)>!K5CerfG{|+
zwJ-Ii!73t*t+E@RW^I>eYkLaN=ePD{<u^?#Vx#h%Q>kL}JN@fAE*rSn+RlZ0x;{>y
zKJQjkceqdRDQPK*+v8N2#O=J+zS6K)p^u!K-^tPn6+oUgcl4LqW8a1$^nQdg9v*y0
zsqv-M<cnNJieyhv#HZmzTl<Q?fminczHff#_#Sm<4cx5or8Lx^+6*S{ex96<7Jikz
zygyT8L&o5#M5<VHLZLo|zVMWQDJA~@URO7hJ$Q}RogMNvuUk(pr1fbd6CDv+pzld?
z&DQq>VxbbcS}!#1QEnpa6uZgLA+<hkq@w<0eVH&*3{wtz!KU7Lm%=X>6HxU+i>qJa
zS*{u*a%%7-k?-JeRNnnvX*=)lERYBtUr0>V4;shg$t)Z%f8G5<SHI$V)Q>IJ>Xyjf
zg%`~fW8u?=LE#<2aYeA<CoqDL$6G-kR+P5m{yl)305<p$VLz-kYBd`>N%?c_OL&|R
z73}XvjxNmSzK{#R%W4Tki_<yXUvIWKFcQwTT4$9LHQ|iQ2BvMxI5o{Wqyw><e(1;4
z%XXqO(#r!2no%O=KxN+1<QYmYij0{*$?z4zzRG5_8RF_%Pk$}^1c2gVt27LSZ0{7J
zezJ=5KMPLO_ty%Aj4(wi`Y#qj*S(;h;Dz8v@t?~r4y8n=#8bQ<$a(#h*k9(HdhiTT
zJk_qqksSaQ>YY&q>>E{NZJT!DQJHV+$csGcuh&2B{lXPe{!CQ$=}~_Um+WG;an(KX
zXQ0$qRgqZl*Y#%AF;~#P(;54_5nclA2B)$Mv3K#PhW-czDmyeJKDx0X<AQqGa|#YG
z%HI?EbX&$qdc-pYQ#-?*Zrpz1zmDdKofF@0@R#v4;W2TN3^IePHs#2}<J&kQJIi4Y
zT?!DHAZ0&0G2abd1iTY_!V9$HtZhU=taJ`f6-GIQ5jcfW^1hIPO1<`F+9UxGc5=7`
zXA^;}yFKFZr)g5`{nEOBr3FhC-OYG*WtFp=EeuR>V)k=jpZIr2hc7kUs`Hy5ZdL5e
zb)|1tw!Ix_WOl<8;_tMzjl=j!YuTzc=AN0yFx~VfX<r96fovCBjILr%$`2D0F_`RX
zEc=i#Z6Z4s{u8o%#;`UrZ>NZNR{R5{H_yR+MFsgUg+7<Z*Q80m7{4;zkoB$q-XHgq
z6JQekA-zZQ672!@BSaA`<})T*FHv6+JsLVZ{v{^Uv&sU_FTJt|!jAZ(sq-6<2+1ZZ
zd=DX+xYvtBac~nV-vZHZwyQfuX)l*lE{$_;{HGWd(Ts@@zksEuWTYe(7J?=0jghO|
zIXqc5S+gpm8B>^dahxhf0uvggey&o#J;nclAS?dFvct!K>$1mhINeH5iVXW@4Z!8`
z*lqvIG=<(|PLM2DNutpo0Y}c|SledDM4!3#YBlFv@Q7pe5bN%>5LOjx)#MlZZbz`o
z*mpaF|Db2a!!oJ%it;1t@2W5N28*E2rLx45ewgI~7NF;NJD}t8zKEw!N0ICbZ~@Un
zMvNfMFx~cCc!HZRw6E?}nJ~NJ&~r2NUEK_Q9c7jnxPqP7>_&~FKa=x^k>$?qVC$+b
z;a>=4R8~z^`p9Nhg5zDs=zp27h`EcYF;FHm^oHCEjIkHQFAyK4g`X=0;eig>uj9T`
ze^x_Uz5kz9dwdW(bZ9D4M_DbCEB+b!L|U&zb3STV4Vl;%e;S>=RwpbK`EAzw%q*IN
zCo`b+jgKj6$SjyVh?&KXZZiwmwwf(;HA-8Ml;q1X@WcO9*Vif;hZZ^-%3RP<nHs!F
z!#MRRyLI?1)iY?CaXbGFVFCz{>o1lQSg^mBG7Emnve2!=lX0M&k6&|3rt$;Sn-y4)
zU6pK<1NQvyv*5{|<)7`nJnf&CQry7Vhe%VYZQt#cHH@0nKMX&C1;zih`~_cCUiq2B
z7#$p=mPNW;>{U4?_o)av;X(AkclZl=o5e}#PWiTvH#slsIOovKl!`n>N@6vq!!AM@
z67WF^4YEr2U%s#g*9*p@i<)%7!#9Hkk0~|#S*qk{Pf@l#YGU3_hR?osIhxFI{)Pb4
zsk^;I*1kHOW)j^d_%?x{)4YjsjoUKA?nxX7u97=JvnH}FQpPFD%)rr|NPuhsCgWBK
z*qu($)TJ|IpuZehiCw}U!l^t2DY=wNeqwCjc}cN<gXzZWNOk1mR2Pu=Q^)XQf}TQw
zX8=zK_P&5A#N02bAIh5$(~)m&ya`nMowp#45cB(_c$a%AeZV(_I`y#M5xg5@?V-`{
z9?h@mS~AxoYj)$+&{dLV^hVeHPK`FujjpW8jZ&LP{CPHp1;3vwaXJA4McwIsZ?Uhy
zFTN}Ou<7>;$?aa<B@kB#0fmbA;}`-e9b;pXNii0OB>s%@>(jL336{t2eY)}cL$7*L
zsuQ6kzZ-iX593sr5o(H08KS?yVfK?^s=~p1zz=du?UXcbivSyL>m=+-mt>6JpyP2v
z|EW`rQ(;|AXJ6lnmZ_Jzx6+k%a_C~k=BYTBy+YBcr~ASZkOeQV@F41)I>;9uE5Ad0
z;R1eLHmL7Y#5`^~2HBlNZ1Q)F|5u$eD8FU#6FjFk!-=vO*p*_W2m%)>oY9<Ig(h-0
zbTWhOip?%mXvd83-r$ql`kc9~DE;<rMSX(Xiuz8Wsk$v0v=(}FTb~p|Cd@c3^AeN&
zTV8hZ#^#Y6-W$pc@9>4MPGq@}EO$`jUE7K>rqpferze0V%Y;Oh?~o-#mT!}V#`}@2
ze~g9dqmoVRY17ylWLrqKe6OaD5EjYuF2CKg6na_YRyJVD0n2O<P7e;^FGt<wTJ`Ql
zrg=qVM|I<Fm<UJMr(xHm5x23`q&`Y&EJn7T`qCZ0S+wFRJ`;)Z#Ja^qb~uA;KV~_<
zhfS0Ag~aJJGg7nu6RqC&0w>ebju5czDcdiLxdZv(Pz7$CJm79g2%cF^uzM}spv)I+
zZZqHEf_S+14OO_oi|qobX1x7C4yMF-G~kqB!3*tS=r`-4Mtq{JtVVlSku}UUd0I#!
zf2Ba?fU64c!7o8H>v-`L#{sUQQx2{t3}JFFv~b8J3`b`bQJ$EFxh67S=2^u#tQoUw
zX+4k?m+RDSEik4WMYyS=0Bp^>T`s#CWQS_wC^<&r*8Tm3Y%+ZIj9s4de75y>9w=3u
zC5bWi3#4N<_L=QM`R{*`(EI$;+zYveV&<SwxK<t|ejVY6W@hCzAKCm)AAs8&>!WRe
zo$GsN=+;}NoMa|SnpK(BVm&uOXin-ULZ@tHC1ZHv%f@NBMAei^?kjlY7mP-D7%gJ*
z;WF5tq%8fLGXKAuA?;4x`wD&+|Fy}K;?ndo=Yt=orOhUt`xWK&@A5i#L6LkGzv))q
z#d6bCd7pTrN$T?^m3pr7GX97p<xXW-*;;DZcorX>_p!~f<;*$)CH!8?x0_1hKXtpo
zwI3x|RB!|t16nmk-)Auu1I#yQZx)<oT1J*@Gz+0U+q^7Z+z&G=?%uzwI_vzhU<@rB
z=dheDBV3aPcCgxZwDgSE>#pzWid+6$p#f%%zXjuSF2p>|t{h_*kICN>I)znomgk|7
z+Woq%_KAa1K$qeO4~w2ngP+=0WMR*rswd8Z@8O$Xl8JwM<}9a$yig7NR>#+4^~WDi
z&WFwHfSExbZ!P_wS}m1+tb=$K@o8zcI#xq1z3LZ<HvGEvS4tFeo(xm>toS6QAM-Ss
z4Xk)cXOuL5hJ9@gn2jRx9=V6p*K*l<X1TFlz~Pm=W{>q!=WFi#!xxT$u<Sd%!!O;l
zRJup5kbjUXO`(+{8Jq+w+XeLNGhU}H9*aIG9%J8?RcT)h6V4(#Ot{P|Uc@_P$#hSq
z$uZI7P&SnYMr#hD_p(zSurIE3-hNM!Qf9gUpM<Ls4%)T0B_)b}43w9f`Z@^2fOAwr
z+Bg8HoGo>4<y(@o&FYfSZ{z*I=k#YrlBCMUMoIhiK}m~$*t>qYoukVBl~yUijDmxp
zbN{;UW~2v)Z(Juue@9VRz@xH#_r%B-p_5{Nf}nt3?o`dsP<i~iY-j(EN#!sq@whxD
zTKt~ScRE7xz~h?NL|<!y8RY}_tz7734dS-5V2@C_Z@@YCA1)ULA1C!KH+4iJwN^^c
z<ffT}UXm|z3nFCqb&7B`Qs`c|SzFw=Ur<>`DtLg6&Z#-G*XkEz9dok7{OmVBj`>j|
z&owJG>>Baj_#(S<a&%n0I^~?peh!AZ;cmoY6<0*6#?y)ej8Jqar`}qN@R6gPB02FT
zjCk@Ka4cPE7t)=d<Bf06aCz}kK}vY>R1c}egb?JjBx<#kXraWl^9(z3r0xnh^f{8?
zNZcT1a30XD`G+QvVs#5g6IpJTkbDV!J9*=10C4vHKg!MqKC0sC|9Jy~1UG0<)F?sG
zLPbj~R-(}cViJ4-H(8S)8u6{TQf*as1w}A4iE_CHY1LNS`dX{Dwbi!TMyxh~O+c+u
zw1`3x6(8@qs8JLV(fq%^nR|CP0sB0E`zg6QXI{^oIdkUBIcGkGCp@XIAM*uX62m1r
zJS$|~KuY3S{T!eSdI}`L<uxjY=$6x_NGWy2Bi1C)hL^bmD;(#m?y7qkV3vFSc$RGm
zYe;6mH6>xM;toUp3aqz58F-H-zQw(!2x3CI7v-JnRuMZUem0%&9<Y``r~0pZz$>Y*
z4XLk9sjn@mudV*qausza6?;pWZ3&S3(lM@4?x>BHOqqgy>)|?Y&Tj{>#Z)~U_69#}
zZ4XTk4iesK39rXJHMb9%TrSCT9K!y9G$QEGp^guPjr%_WFXn4HUl}w-l-Vw%4ccux
zNTg^S9vNH_&n%0z_O3N72Nw@8OLLf~(ABp=u8k5VUuOB1;5nym$d5z>0UEu1-|?42
zsO=dFgK2<Si9hjeySEz2z2g#fFPBaw<o?WLU0^4xlOfZzQ`IS)oX7@m`c|SCjjhut
z8EW~I>fD**n7Hvmgn8Dbuz`NprurQVnXsdsVK3{~7IEkD>UVst9|&!-uvUWr7HU0P
zgAh7l+ys>4SA#pfh<9uz`3Fy-=v&G(7a9n)Dk7PCK8?qV5^{(UKXX-isP!xQ1zul-
zVS>r`f*u_9faw7w^J<XveVdf*vfGYHW|Ggg$p%%7+WFj_T#Q{$JB%`MtI(&%B>zgI
zT43R5^XZUDytBbO6XFP-BkLjb8_yYZ)_Ut1IV)cCxGr`882;wDtYs~DR_0hN_kr+e
z3&28By#ukCV62Nj7s^Fu@#_OJi(ROItHepeIT+W*tq>X!*MEYltm73;V>#APiA9L&
zW}SrE6mLL}AEY{2#Y8;x5VrkX(Vs;Jr<-mcZ>J`KBUEq4X>`upj)4<3Po!r0Tdn?z
zFzN5LKc!cD@Sb12<&)aNqZ=B;d!`p?1-YleXlf`CY=!=yCy>OTVN-M24XJrXVZ<9r
z;*4`FazsruR-neJeksgBAqvncwBb)29?@M<r2D>v>?Z7DHM3CPS?6^<n4X2%J2glR
zJM7P?G--xtv87@LOLzET&HP{~$q8vvuKOBNKK}kRDTi7g79p|~u8I8vqB{qbAw;*F
z7<VkqR;=QQxgTmB%wIpe-BbDumiZ%gnJ0hlcj<SUyZ~6(mj~FjBszQizH|rTYZKQ{
zD9vRDF~498*I*&-hM+Yh#!%~(T5o2J%;M`A3GdxikMl2o9?_qKwPJpRF=atHkw*8d
zl3MTapQJ^Ri@gI_22kaUuSHaa8G%;JNzjquQyt<{Z^AVQi>39wlFxuo&D!D<Pka!a
zQOl<MXw+COU3ps2-6S%=$Dr|u_t0iPd#Ej9w->2MBHk^jbYsqJo<Q$Ax1~FLw)4EO
zZ2fOyoIfKF(AruaS+4VD+-rFRQ#Kw5XIMi#l{VR*K{z8b{;WI6Fs^;UA_lO)%#O?C
z9oOI;{<_6jm$06f%5P4tt3h6M;wFmK))GGEudP<bsd_<qZzrz=5i7@~1Ueh_#>E3j
zXJ2Z7MN&aPDuhDi7guDf-E)c}4CRi@y`$|AfDv=lh#oUTa>VLd?}ERZ9zv_XsiXH2
z7Fc!JVeit{Qj?8tjgoXH?5(iaHBW`ernvd~+^>$c@sgOCHfoJ{PybIaGp!d<j!-p+
zkh3p=xid!-Fj%Cfi9HW8V9`9wb_P=5Zrax?(uCD-Ga>5Y9nQZjGhX(d%7j|C8lp<^
z=macKgf$1_tDyl!qzP;8I96j@GtDPf^G~`ZF4r=*E%bwT=yb$h`wbf67p8mWxAVEz
zMjPxq2iflK2OFy%4U_#_*gNEIyD+P<x3p53^PfG4`<fBR?NcekSU>hwv-N5mSAi;<
zwmB#}HC6U`AWEH{AMs8|r9J^BwOo>q82-aKkRx6FW2~<>nTet{+mEOfAa;lwe?;S6
zMD9AX8yLw(J-!oG0)yo1Tlbj0Cq{AF?KoB2$?uV}6GL?e5_aQvG(;sRc~Q)gVK0f-
zO*+?g6diq+E&5H=m_n6g6!6r<>Q4-jB6KkHVdVS7XQo*68zMu(EPAiKo}!se>^9Ek
z#IO0I=p{jpzov8iNjaL<CVs?UqH_$Xe}o{4!kZ+(!uKy^(2@X)QePudU&X1flGN8|
z|7*F5YO2c_Fmuti;VUy{ZJPplF%cDG?lkFk4XN|R>8^d#bnV&1y9jd~$7#5aB9A8)
zB7=0?EM#7wpPihIpyBQTJ-+bSJ>Zkn*Ur?}?$lRSs<V0i7u3I8rM)-&&g#xU91MBY
zq?=dp=<NRL?CdNnO@Dl|zo>nZ(I{J(nZ$ei6NyB{LXlry^Ctrv>r7=$;;+y|gU>sj
zbx#{zi!}e;jufAWO-N@qwx#U1g}*Q~;XB+X=8CGq!b>AuA~B1f=`tNX0-R#mN8)s4
z9VanloKiSsJjNO^vKh42@pDUS`E;Bb`ZLOo#j0w%6@3#5e@G^`vFJ%LKC5j(#`=|=
zP{#zEZ5z+rC0?;veGQfE>LY$N9Tv7nTYpnqH~E=vO}8cLPPKJ{-<Gz5w%<V>i6{8S
z@0F-Lm2+s&tF_8HOIhdePapd>tFM<nggmVW!2Hau&P)^@fmS7Cv>w=K`+~EpSCocd
zQ(apdy%wz2MJJw@zAi9H{tesx{cqUL{0p}R&q4ZOPAq;zg5J@$pGSH1@Mo}-(shqz
z8?igK318i|IIA(8*PV}zb!-z#*zRhh4D7BRA%^Ajc%@`?R?3^k8<~6tPWTtA*?Y8Q
zVG+Xhhh(F_-I6>T3hTU_n~lWiR!UVm&iWUe!iuu4q)BosTyQlq;|7=d%hP%gw_3Y&
zn;i7nsNPY9%JxUHsqb3W<@80^9M50d{FyfQuY%ky<R&M4P@!Q}{wh-F4T*GUFn6k<
zHn}SJtv$^rtu3c~a@lfWy<-eW^A35N7M|-($a26Y7b!W<PyT5t`2&i0?@OvC_YEXF
zE6igB*TGT)w3&E+ww7$w@{FH7Om>5)P^;pMFNa35ykRUQi!8}`Le?~7^WWiqoI+NB
zj$<f9=bxbqiM4z;Hd-~93S374>Rv9{+k4tlzN(EakYZJcnVwmtu&Y}G`1w6lXEK~X
z2Bqshf@a=RGnd)#70R=)u+iJ!&r?8pheN72${*YuM7NF?loIk&E>y~cO8N3li?6ek
za*0xo_Vb)fioKt<>&LAxkxvDJ=%dWE1oVga+p+-CyUFFtttvqx65aej=?l*!9L#C@
zLZ3gbk7-7z^+iyD?*7Rk{B_<S2O9ONV&~fqPKj85@R}(X85lrUmFNnf(kuY~0h-w(
zQgw;`B#3wOfBvmNe$pS#fcjHl|L7ioUuG#emBlWWQI#cA5SSWtdJG{+A$E$C7t2gi
zET*c2_%Dn2=0G3@v{-(g<Xgwu(K@w8LvGaws&I%CyDq*w+1+tL6S%uaM7gct$-ChS
z(N9QmJ}&L_UVDSo7km5IA9Y-%{6Dn$yDN*;%O~%p7;#ZHL~j=Geu~lTxim{xl6tP=
z$$LzW($44v<!DyLfaK3;K+&xbb#h6^v;3h&ZzjhC^F%<$<9>?XqcviF$A73ndA_jC
ze4;Jp&|awE?>^uy3)m<?9sqmZH}|I?sTdtK0vzr@Rj7-r3i*ElwsuuhvT8j=r^C46
zFB(*E-$W5?Sh?lz(G1JVhvSy#E+}&2cng=H5V^LkbKWG`NJPAv+bsHZDbT<!)_^IG
zhlsunNvsEZ5PH+{Yzg^CWO&5A)tr?zYnkU>_eF2AqvOo;LC{Es0B#~)7celDp+xF9
zRvEt9jPpaH;|P5pN9N>z(*2DWi^yMK3{=t0$;LdBbN%J1uGugkn5en+Bj{Kf4N|dt
zFS8D9C$FNsxj?!1U3+X{@h?0fNc`P9d7R-J!`|VqG2a8FW*9+l-F@jV2jn9~a$GK8
z{B7<B%y2%t0Yb^Nd+d0e5wyJ2>mAB^PQK7_hyU|1#%D_WgAyW@KX!cI2UTk5_jfGv
ze{O{^lD96?{h)fr<z!VsU9|aoQ?igB&NPJsdli2_CB9F~Jc7wwf`QbLb>5%<rSTfA
zgC@RxPBxtC6>4wvHazr2?~-ako!61Dhm{{5i<Tc5n^0Lzs%-MhUXSfN_T`2MkxnlE
zjS-QMuWZ?0QkH^X!Qz0dg<)sI*tKCYf7fOX&mI{4k7?;x5-OdKDNvpKmBCk^{GoLI
z^(OyUJeA<*Hxa!!T{e23+gw4Dd+77AADFE-EW)#MyrGZFNT6g5lVh))z+c)NK32-H
z<(QU*;|E-GAoobii)XT{9mqz&MOpF*(?7R*Jn^f}24L5Vf8E4JK9n@<KN&wab@?-}
zXu9&Zn4ncp@Ug5*d$Mh3AQA7=2bFEwgc%sTmC=8+M;{o#CID{3#B-+CMZ6L_Fno-9
zfSILZuB|%AlWOpHDljd7x@zjptm!8LaHg_zyn;E#0}Fq5P)J(xH`K7zG<g{rgDyW!
z4e2ibf<mb-Pd3?Xmv5w!RF}uv@)I@WD*(9FR%WmPM=3wRU?wM{Ke4cJJw3|~PyraU
zPpUhKCs~KV_hB}Dx6-8ra~sCMVaLL*67TYpstxE`lg+(m42}o8?eG%az@;x`e&tTY
zLsGD@dT!u`_<*#1i0n(OcnE=P`=d`FY5K71C%E&#=9W|a-@pv(&Nm@x4Xm9B`N1s1
zG<_SApODRY1D~=djS0yyvzEzRgq=T2W+M0MFJ>Zt)?ds*p5w3VL29yVSa#>YJDv4o
zyV|SwDO-Kb(e1^9%bpMYNb_jU2|bzD_4byjy=c6eer?I1^78mktsz9(^rJ?mA5<KF
z2-6Sh4%Um!*T?4LIuPoQ-$M5=_n1x&3)-uhM_CFi^Nv!?JH8zlVjKpj<2ES5^TQWu
zi?FI7AH`5-M)x`{SKfMN%?BqcsG*-d9sDoaeCd>|I<MfItSrO$((`NmtK#{y&+H?L
z{1!~|zQ*h`;S65=Fl<b#$J4Y^IiBUqt^Y9K>}PrqDD2(-is6<La;hh!Qf~-SC%DxU
zQ>m8)sS{ZVsnkf2I>xF%Y`rH3siWQMid5cj1gRCU7i(YHu^cp%ZuHKC_>+k~=OtNV
zR^><6&KB=4Xb5<}&);|$0S@PI$7F=}3Ig=ePOf{UE~5C_r)B=BTz5RH(XxO382aS|
z0HBB^O8m7&W)GC?Cem{&HF^tLlm>MfkWgSjv(ljF4M=0Npfl2-wFV><S<v`2=-&n;
z^^pY)PlH|uq&+fq4eYaE%a6;Z7lqos4TYF#JJu@t5{Hvu;Up_Ope@X3EPHG_nhc2(
zZ87(Z2`TtQAAXeJ#|Q9<DR_ksA0@asT&ezw6x`>8ZN-AC5!3#d6x?UeZ3hajMg*@M
zowh?s3?tD_h`d(Q06P=?(=-MB(}er}X+nDcG^0MhpM}<^9ph!$hu$DIN)K#G+zT!4
z#XrRCx8C-%wGdPGOT0%&q$!8k-S$x(9ZVD&&VO--3PadL4Gm0qiA+i__GGU_ona%~
z;t(OXn>(WJs#nBVZ9qENpDsh^?R+Jsc?m(I=1d@vX7<LirdL8Y&0rfhjB{;Y#%b>7
zrfz93$2~;VHoelk3k$!;sjPVy%z6l&Y~BU8KAeyC$y>^2hHgw6AO?MJnUBFX_8f6F
z7{*{i6NOsW03bx$;)nTb!x-(OkVV8Y8hOnLSRzbKEMAKd?*(WnhSYlZ3>}=cq$&X|
zDY#I3eL_-~rPsxSYJ5+~PYE_sxs1UxZZqIE8PjzQf|suic=;^GPbX}gJJ%}F#pfuZ
z(#`X-M{yn`p=;1lT{YMR)?gP{lY3H2cU}_fv=>x#4dW!Husf+-zw~&+;sa|`I@tml
z*n*b^1xcrDW#W5u#mYwp38$I12{44wsoK3Zd%iWhw8bx^_!YE!WmgT>gWUrR<=gQp
zyRkX+_aD>nn&x>q$AsEyXry^wE?+0})zA?A9G)2VF0+y>1_<h~mU>y$7PQaxTbAU2
zKIbd0KE}QXMVwUi$~E6G6me41D_5UcSBGl14>iOlLI#!ygt4icDzIlLo4O_bXX58M
zFE7byS(UqZ5c9FPCVR=`oW(UcE#0~1WZ!WKQ|UcwReri^33fE`I7#vulZ5=epw>HN
zh>0bqE=!hq>?pdLCf>eXy-%UhOr>cvy!Lcg>$gnSg9jRK`GWXgotL`?EvT$XnD++^
zIkYL_dGoHnhi=pfzj@aip&M7wt>#@HhHlc0In#tk;aj1nq(@ot)<E1R<*B!_wA1{^
zF+UdV>IE9Q<pKVMq|HNytN3may)QQ(BSW|Rk&h0n3$m6^5Jnb!0{0SK#SYMVK0;}y
z{gbqM#ZYr56TO<Imt+%UE8#DPu(xcV%;kX2tu-4?!?MU&42cg=j{5x``4nqAv)_p@
zM9}`DEdD*YcYRjYHHYz|gdbmy<i{|60D^`>S)rTGB2yi8M`zHt*+c5Q{ra^Y+qZAa
zZhTAj_C$>4J02z^$nq?W>2?e&`j7L%7yg%VK0LVpI1i%MzO5w&lGMEGv(QZsGKc<v
z2R$X-$=6MkKWn*W))G||>)0R}Y8aQA!Fw62QKFdjTAzM@wkdJeE`*Dr)=}L5x86RL
z>OWE2lo&@AyHZo}R*gS{cWXt!@7W*ZE7KXzlSi^!F`n7~)c*OPDfyzmuruYez#Tcp
zONQgfeXv^r^NH<GjGJFFJ$&MYXZ;)9N~*K|)g%zV!sP66J|=_lQtjV=|NV&(4)3c@
z-R5*>NP*Vo>LeC`(^Y5Xz^Q}eYlI0qYAhoGc2`aT)mcb|GMQV+C%$3f*}Vkg{P7KW
z+)n0;juDvF5qN=-&+a8~!(1RHc><?$4FpJmfi(G$>WL^+fP`5UIFHwQr><n*RZZhi
zClBDwuZ2}oH=?NVo?PvN#&lPLWcJL;(e}@&`UCIxbzC~{blYd;yDP^Cmi#A`*M;fq
z)`fnT#w4Fqo6^g4u0fEN+D>DjGrAGs2lf*HGWu@~zYP#kc!>|Jo@nfKI~GI#r8~So
z%NXiPtvf4trsp@M&(~u->+sjys4j1?`T?5#(5)!(ofr5u(5(ogZ)*8s;N11Sqwji{
z+TChV!&RJZ=r&)^7`%W|{^p0B*YxJpHg7)&U7eN^>Tcc^VV+POHbfe+mp$F^U;u5r
zX1~#U7p|0;OJCV9t3^)_;42Xh>&oYsQ%zQ<dVKO0YGn>cyeUX5H>LW~zwxIsGSOUj
zx=e-6pkKxO-zwV(zrX=>YN7X$-$BKMD|V(Axs@f(<Pz6JnHrD12VXo{>O=~iwQ2j=
z<sJy=*arsZm2!82b*u#{Tcp7MvHV#w&FUD8e#7KRKAm|!>UVx+zKikP#d*)2T7)VL
zWYgzE?aB)jH^vXc*c(+c8$AqWTez;4Ct5yY3cQElNtR@Co#`ck@L~Ch?_U<+LpE<;
zgO4|1>YA|sKYUbN7~o@+EO_>gk76<ze0=%7^7O?=%Kr^E5)@yOTYhQm;%km5zdUwB
z`Bm|E(dI9r4)i%sn@%q8ytS6oV0>-zh4KsIt5HzQGvF`(X2Dq&{6|z0*BiiAA8>&M
z+>yM^QVk{JCc`Q}!@WOI#i6!2kfRAzPL8Whj{E!^6@HFd<v3j{%xG#;{5L~?HObB*
z{1d7+{PR5cHJ>T|*)o4jHvCmwG`7FZrch$Xn{4sdmN{`{P3W}*vjfz(Psv5axGNOt
z$~vm6BKwH0ikx{1zY_=p_rqjbI`fDFJtbKvdLhgB6}$4LDCB|jua-AMEuV+xzSldt
zeHmkFpN{3*!aSlC{HrVXB-{YII0Bs8w2DI2$u<02mDKmC$*1|ZGWl2jot*q5|4vH&
zj(^LNzvkbG$$R+sgyfz4`<>*i{Cj+|oqs1JZ{pu?Cl~SWaS7?1`6xAe0=*@S<-$V#
zBE#HJ*wQ)B_#U-%4oFNQqtZiJH{`c;4oZ~ryQMQfF;<Ai-;c}LAf$$Ltj^?^cD3~S
z+5=8dflRnv4~8pEu#Ox3&s`&!3I$~idoNvPm=E9S)2+3U&y4@!^HcG;vrUawlO+Cp
z@?&VC8oke+LR2_j-&&<RVtG(*>F)OV<DLW!S*4xZf5)-GQjt5nW6OnjoZ*#HS<<pP
z50)9M=jG*O=2EWmN@wkgT_ZpH+^M`AP53wQ%9}IJja=#M3_ZHCwyr&IATJuzR$Wcl
zJGnO>9l_-^TekCtjqVv&h8|tfb!zUoEFLnejET<c!E1MAY}vI_vdkRpxnFC2IxnAm
zEl0iO2VWG)iXF1>Tg%r%J||yCQf%n*Z<BcPe7@s{DLz$gT_ikvkayhOMssKIb@Dvr
z9JD+^spO{RITT3#JK#?if6OIr`-;K_BOKxG!&aO9M)qn%5%}Fn@t&)X6s*2r>=(L&
zIv8*5v6~%U2nev_Z*yf|%z1Um0UQ})-!sR>o57hmF4~hH$Hi-|YTmU^?DFPagJYNK
zNZ3IRdnDXfM?%hvBSSZSA|Yhw*bOZ^2Q0j)+K*VW!CSbS9eP#b3elq7R&A!-(9-is
z>&iWf6?A!5C8xN`+>@$XR^=IbUc7&GrP-WkElcG;HkJR<KKZ3zu$l5gO9!ViT}Y-Y
zsPxJ%o+hQ@0SOP5U^DI$TDpZF=0MRv$2m~U<;2%Bwr5IcX_vCCB`Qn<XNZx+4{3Re
zlSE5bj%67)%n8m8htifgI~19Zk)gXg6D<aNABJw!85OB_?gCRS(XK;Fukb5w*)oW_
zgNm)NTWyah{trpMnAHtlX`5Wwj=)bF<|q)l@z>NtLU0@i-FTZ#NF51&)~O@MLQ*?K
zgQaWmO!yvqReN=|*~#<AJ`X+A7mi&E0XaFc-gp<V-_xAX(pCIQp&+!Ep0;%54qll^
z(n2_F-o1!UfkM$sJj^np8J17-whqy-Y21SfNKGyhKeGOizP@^pSN@By(O1jcQNq$p
zjPCg}y)pVj+8~gz=fGv?tUE`_r)=^pJc;lM^T(O>F}BBzTwb=ewvou6YgyzhaTJAw
zyo;#R8JDYIWOVk6*)rNL>$%~je(RyW4gVeVjW4@bj))Di1`qhl`#L(wTi7bZKVaF`
zdCOK>nN+d<VuyO8Ue3#M1eRl+f}=M7B@bpLWOUBzm_NY5yVu*q!3B&b{~&f(4bPna
zyS%K9s~DQ68v;Pezbwt4efdA_U$YMl$eUw7o^<nXsocrZXnn-ayM&6|$y7V~2`ZCR
z9Df~wd|=BBV{&3whNDXj4ja6xsNvMs`lG5gx=iT<8@yvkCqy8QS`A+5Y?G%kdY50Q
z5Fo0&8Ru9tf=L_A@Pkf-qd!x=0S%sasVSKJhp|E68I5l+GA{f4`wZ>(CSKyk*nZ16
zzP;}Bc*CJ@<3I3Wa8L^5Z!;fw)HpB4hC@FXt`Pw8BX28JngSn~0vY?u3VCU~)09|A
z4*ZAA{zj9=!OHn~@as6@ZzNhnIC?MLjd)-D*+*2Yz*y(_GY$M%1K$|H<697pJd@U)
zO2b!){poqct-_0Cp7r|_<WJOas!6*um3B92^GsS>kQTU-C2z9(neKZed&URSaqeI(
z^=~)MR}~lf{&w7>oA?E>;ZRY;<9tQL2X2;(|B)^){fKmSy_s+aihY|!c};HE8~B?%
zeHDeho4fKja}~g@_*0}mzW1BYuj!B3Z)C~9h60(*qN$Zj2BP9So%+l7i8bl&=SE7(
zRrr_s%bk$oFw4_;wf>@pd{ckXLhj-(>}m1-@ZI+Fvz^VVDgI>H$K1%SuWjIx^|w4O
z4&?@91%wOO9(w`1)WX8E2SgtOkF?+DT}K)<Q3OiboP4xTfu?kUzfd5#wh#2X78;qI
z7yX-{e-hN`skM!bvd}tidshg0Tc5JILCty5)j-WdrhPKJ^=~tdFqQvP8S0p&J{eX7
z83shxDT5?8h27d1+gI^TPAiu|w(J}!wO<MaE~S<XWVGd|!|oAQ-w54w4A^u~cga8c
zt&u2J*g?R_V4T0VaP%Vbm(_jgrY_jO*70rjuQlca-B%|crEAQl!S>*lq76jKV9Jf|
zYXg1srY<L~zCg&HTwc1ay~<m1fOiMS(e|lcgV8D^Ux5p5c3vk-qJ+*<p*8|lxCQgO
z{uS<iaxWFu*b1elNE|{P8T;RVQ-xK4Kziimt9X?cF&c|==?|*K_TmG43Q6ce!txL2
z9-Bf~$YKk$1u8?cAA>vT6WQsWRv*sKE=P+ce~nbZL3=Nlszn<)wMf}TEpsWFx=)az
z0z|UM5e3SPYuA_nCsAM_?7P?4jYT5zVHl%ufQ@)pOO`T`5&fl+7{40I4-6IhtylI7
zcSeEpDn`)Z<kg5}@yX)av$LabGmpH_%Vq@!Kv}ZnF)_dbjLq06^TV~?SU^f>Q0{lg
zUFRKOk_xRAAr7g$m6;p=t$W58x3Pp;Ya0o3vyPpO3}BfyHwFE&`>C@&5^8M*4aDGv
zzOQYW$98mGt-l>byuZMiC}?jMk1%#!v0`(@{>a6G6hz;p9|~c8v&|W1F!>;*-3KQG
z&f)$ZuuPh~Pe8WHZS%{WZOi%G-5SR&gTRxnkGNpJN$K0VoL6UGpSp3iy0&EuLF$Cr
z*UM~Z%l3TrnrZtM)5d<kT%^{cq)umYQEZ+`J@~JpaHTqv3%e)Bs6ysl+tD}es4U5g
z<+i+(=gcqpOdb?j@sZBX*3N4Oq5smlW#$7!`rQPed>Md_4;Z5N0Bg&?U{0=aJ}O-&
ziNpKBcCEM`?>jUWK!4{Szf<u>jXt5ikd^6uCF&N{9gNz@IOa;7Hs*(BcAQEHVuSo}
zoJJ9~`6Dp+LBI37tq&`!BJU4DeK;het5F;H=}YV7ZLj{iN*!CNJuk5TX!GW*17r4N
zENS|OkASsk_J%xZ*9xX{u^PytDxY9&>uu#E?N6_@AEK@^`c^^|y{=8ObYtrNm8$+@
zW~%2tQ&sXMWw2oLeqHhzHkvejWZ>&XNy@?(vHw%(a=vzCkM?AsD}{gmJg1Xff%ms_
zzpynPhGR>_J9Lv4y~0jIKf$_Ry*9n>gZ<eA3#0t?sq%GoAfo9Rh^>G5#s8&zd8&ME
zE#?3D)LzO@`7h;n&*;<tljrZHeE#0bBUQYrOVt68w=R{w6qSox*cY>EqXREtiSHBf
zmNZF<sWBExOJ|a)Ca_S_j#e8TrhGVITx9c2Am)Ig3EWDfVhC0Oj(C+8jMa|;#|*g8
ztr@SzAEc&m^hni|8}UYv)onCa-E{Cxb*!dD+5XOF**sp_l0pmPp6==~d}Qg}?uO9>
zrEnXHrM9mw#&^)^>8@6Am|kz}5o9KUSM?YZn61YlZ*_4vI#$iW!+vv~SsB5?cWWl9
zt&1pH8$H+z&P49<^&d53fVSxt$gLTtPdyajo;6y+gUndm#&XcwrsH!sdW4F@MXPNS
z$zLo}uw|iVg5j5pza;T(Q&)+(?oaJk#rA!@Q0t-0kMV=XQJQUFe|y8+va=}Engd9W
zinSihzS*)9sc;w{Y!N$F7KYk}o5cOB|Gs-hiG1(m1JiOX*XG7Dd&kO>P@A#0XyhIA
zZQhp3-IxxPI5vh*lj`Di^cuLUTUQQZt#gu|xZ)lTEii+B8Lr9db>mwbysLhcm(^AE
zUbfR^m~?!=GvgROnsQpcttt^}yOqpt)t0WRWR@GoJeP+hX=6u?+^U;xMI7S@N4XVq
z%Psgj$3#LU%?lC)4QyVJ%nG%&ldXBdds(QT=o-dLlgop7v-8vPRz=9f6K&bKZ>Y6H
zweB1O<(Q99sCAq9;IZ3X=3^L=w80avm7Hu+2H{m{KJt08&VUAlT2Du$;En~tGbvc(
ze-|06WhdCZL&8?g7^i9zZ((0WzJ}<zX4biTtM#VN02;(d7;87$!_7sF#%HJ^*lW2b
zZ14^xKiDIVL?quL;Se&p5m_3cbkp<cGuT_)Ibz6#dSubtXD7eqKo#$4nJ*XXne@>&
zc0XI)<tWOHDBTR`(X{ku44<e}MPj@U0aeHLt92V=+AiqZZPqS`(+hx8sDp|(F*-b1
zvCGY?aB4<7JMm)ho*(HaF3g)kqI>)!=p^XeKDNvXgOLk_ksO1OlW6yAF>>s=>Qo9N
z>c|k=Pw{&hB$G1OWGb}dI?>c`*BN*J5pUyk>aW_w(43kvi8t6VAP~Jysr#eEU1aa`
zdtYoDphx2{3L($VO3bH-8|QilKgX^3ugy1`ln7h?V#feY?4w!({hBwJ2}xY4Qo>@W
zRS^Rh&Cf4fT9*}SJp)>5aA)$Sof-Yf^#<#S8fA}fqgE_hdc?#M&mnITbe(x@P24RF
zPDZz@Q8<I_ROHP>{b7u9N|Bh(-z2As5dO&h24l&l4~}kJ60h-(Ojt~WFXDB4Zcg5b
z=lx_X7UXXIO+Wc@lKl}JM5n{iQafov`HhV<7s)^8d`puznK`t!N{G;gz)DOR%k9lH
z)lr67(8P@)FwmApFYHfcbV9o3aW+@tJL$e&hqpsLL`~tuNOfxd7~Q27@!1ePK}C55
zowfB5B#KBqh8;zH{FsRs?UXA=u1R{y5^(~nF3>lI1(d%e$63z-_@HpKLisorQ1l@`
z-yg~6yqp|TsUX&&R_$-)P4SOx4D0fyP^-cUkl`(}EJAJf(Iwbd9)3T3Sv-7BmT<Hw
zJ;Kwe9CHv6WaF5`G@1yTGlBeLY5Qn_&&WT2Cid@J>b!COD0B|+a}4%-w?9P#)-k|j
zD@^oS!r+>8Sb~tfyhl+tLX34T-`X#{TpaV~zSmu2Hp;{WB$sVQOF*$mbgDWz*x>Tl
z(B<?QP&_^QjhT{yXro1>X6{CxY?o24As`IR!4)be9hIGfAK2M6m}o0vi{rv<r*{X>
zJR}ANzn19N|7Zne5O@`WbNl?9=J`3NgxVB<H0<{d3mVg@JktYKz}TJ!f4(so(|r5g
z6!(0CB<HIoxuTqts3fz62seAiNs0~)QWrj8ET(&(<IS4DbB{Ky%F{G>tEs*)F$6$+
z%{aUO8b`Y|s5*_Jv(YL#g|69t#skP`>idoA`&<L$ehYa~@l$;hhnSdnfp;L(UD|2P
zPSHB?myBt7*Xn;bPfljj-QZ4}=QhL~7Atx<w%(~87qEB)dB>HrTTk6UbO^Kxu>+;a
z<jNq#n9WVO&!0FgiYI+4DPrmd=L=_2xluyYkg%h=q#|~KB)%b9ym~fp1N`6`!|>XA
z<NHcpn#=~k`>JFhJ3c>>M>vcrtD=2*UtG;0?EFGdj%sdWtl6c@Q@1#$r}ky_Y9Gpu
zxAL20eecExZ5tayw^wauao<+;M)QKrS+QZw3*KOt?_}Wx=P%10-DxGxb30bBk$JT5
zyt?AUyq0&-y|78&V~6IRgC-|_RPq#~-~30uR$(xm+lcp52Lk-lGVhUAkERKt8pZ!*
zvfs#QF8PwCK^;(_wH|Yp>G8&GV<9O#4f12mX_zOB6Ki6UhUW*8wqtt&dQ1G4e`aSV
zHuFcgQ*0<-Dy$=@nUxCN2CNqh%Xj{@V<l1OBq|!~s11yyW#<8*)|WI!scAP`ht|ci
z$)ga-yqZ_CXrZ|d!w{T=MGNQYZY*RXTXa{?)3}U}nlG<bZE&ZTGskTM)TxRyoi9wd
zlFy(|rh@(T$LNm;$GU+TB$8BOvjrGZxM!Z3CUX{VO9FUG5?w+U@w`_JU9@?8nx0Ou
zJ#}6cEWi;onYf$;Nr)n?&?MtaAc8ub-r%A;WkRhRo>=GoBSAgg_9ZboGO9Z<mJE&2
zi^YRb&k+tdr<TFjn{G}v61tQF;)lGts>m3JKWjQGI*POBZEz>E8^_1jMO#!yAp&dI
zdnRo6r09c|w<+znq%kMr84u9cDe*VM(c1(bW{SABNb-49$x7wok3w-$XHI7oY;&hz
zjq~6t({^$(ck#+Jz+?*BqKV6x;9!@pU|8MNF*8e(__pWCMcZ@_$Z1_6%E8WG_yuu-
zwSv-(?!0oY6r>Yu^x9D*(^E4et;<vfTan4K#9iFZFE}GU_M^3uIr48g-;CD019oZq
zUAp4-H7P%Ri)+`ZMby-`h8hB;xKn?d6JO?3-Rmq^>}>GkF?mnobA*R>%X1~p28S>T
z^#xu7ypI0x9^DzHiGb<MTE-W%Za9#)<y4$I(78<>ZGzng_Yr<P>H2(KO4ZhRJhLMn
zXyvJZUlwX8SlXL`ylQe}mai%_Fl*7{{WSwl>qe#Iqtu-8L0<_X=}@<t6V%{XF=r(h
zropEyeaszDFoZsM`oWuNJUQ{(Qg~V*BpDaC#XgqMF#UK-A3R|t@h!F()67xUpeWTw
z2EYHB{zm9;W1qgfwS~UmRTsa_sbY4V1-y;(OXeKLaIgM&!_+=8$Ubga%^B_vdh{rw
zon9(^=(IkwWV&>#((LWmyL;?EKJtiPxg$O_V@h=&S6;f&X_MiWP7G8P_I6rsZWJ@u
z<6?!8Tb&mvGi@4A*r)pp<RCi`5ntz?NHtY6!ZcpX-Z10Rs6MvidR5Y)rtifm{RieQ
zEGIy_AGxu+x?Gs)Hg)RDS_*4*W$d@qltF6>DzzrVUL%8;{532CfCVPt(oFcTxj_iE
zeovn=5x`0+zgrDtb+c!(j5&6%*Iz_f{WbmW`n6fcTIy#}&|ooVf<>5oQd_@4YWrO=
zuv}+#pIbL;_Kmi;6a1zqu^vkNr4zqd%k>Vm=PYRT25lC`ZUbXvb*gTI6dpkLN;3`K
z_tBPdscNv#t+nk@*xULCyA2dNBk=9wqH6mi@>`4`-`p#*E^u=6&S+DO9j2HN^FJz}
zXbCuCQz7HIK%69F4g;ABAvs(bueaFfSPpyiE`_56C53%CNnadv0NI8<G$yWN@bHtW
z9x&`+{Kyu@-8Ee)v{eNabo^FT7G+dPaH{%zqmSMEA2#LbRFrwYi@yQ7Qo}zCm$5uX
zu_277pU;TW@|ekwMV=I@nEd(r)VH;-$un^8`QcBQ9O{W6cfjAQ$!m<KUSc6{5aI_h
z3piIRVkQ3VYn-+H{A<Ud4_YtDeuz%@(gdOR8KmRA^gdrfYDPEozWG2mwAFl|pV)3b
z(1q+YALv4Uq8b`UwCoHy^{<3lZ!?vk5qZaCKqC_8kSr65)=~pPBl5BNK-iLkgUbz!
z^YK(R8j)3|6oT1fq!>lWS`;DQL){QbDMDVsUKMr|co!0bR-WWBs|a}|?44kCk@T^j
zq$10*I6ZRjfDL}c+mB3cLxv)xmMQ0o_&KKE1WUZ{cFl;$a)`Ou2(><<E-4_I4Jgi_
zQ5qvtqpabYNUMc#-1g5l`=>{Ll83nXeX|PhU~EV?JG}>SlD3yISj-vFAHWEWf3C(+
z)p(;*jj!U;*_Z`Xns|fWJ}Jm=aK=bJifCZE*wmwbIn=`&tor<$dOLLsPm~;27d`HK
zh!I1K)HE0-hy2O6x736e2yR&nG+Dz$pvPG#)z9HfPfE+fvjE;d(@?ZL#=R`1<pKPM
zQ%zxOc5%8pb4<&EwN!KNKw3;IdffW8&Q1=mIK+G9ynAavR^8*w9OE8pG(H;@R9S@&
zG*cgFe3<&v=)>1eeYu(E)YLC{rO`Xc_8IAL8nIOCU#asB^fUQt9u4dhtMr$=VUIf;
zCQ*VIB~J$m8Pfe<GuS@Tzjh<1Dn2OB(@JnVhM!<B*?~4WLp^XnT0KBpi)~xUTQhV6
zGr)9T-9RTPMmM0ELai6Wb)emohoA<E4LR9rgFevwxHY)5(gETNRT}i0VAyV5hI(iH
z5WTA0;9gzW;5}yp1SIxTg@*XrTHq#DGgs(VNONbSZPbd%z)p3`_{n*x9p=PTZfiAo
zCvL`~7(eIFPcuJ>%^;E=N@i@069ZIep;5d%3W-Kihkhn>UX>30@>w>cxK{JK&}f5t
zV@E`MjlVmUoYQPhsc1B_XW5x;NGX88!O>))H;He<f4M?ozTL@e2WPY5lw2&9Z~HNf
z&qzuEMD0CLFa0nIAZq%^OjB9`MAD1oP%Y~j4a;(eRx93o-Zek=S%r13<q6b;)Ju5q
zXuG~#pY?<%%@;<_=NI-SxhzQR6@!9t?u()WNJH0XVo)6sKzQIlvm70#70f|^b59N3
zFn13dycb|v(puPiQUe|9ck)w&YBxf_iBQ}9d{X~c>aS+AYgwwlKcRA`X<OnFvT#ji
z;#|ZJO5B2|DKQS_9NXVl0?jAQY!$h2FL30zRB6U&iuVVLPO2`6&Ete&Ur&7!cGrh{
z++ykTj8NNCw1!rP<^3F)@ZRs#&^5*LnLq9bz_O6l1k~uLK>mexX2a3kSzsd1F!7Up
zivPYHV6|#FpUb0nZt({g=aDwU%S@E|gt>+Bd3<$|8-~*^53<JoO~1`$Mf~8z6`)1q
zcR8yoYV20^W;%(W@eH-Xb-`pXd40Mxkgy=q@_za=y9ji*_%{IO0*H7Y2AK(lLRGAo
zw4H78c5@y{>+%@!%*o(lTK>7x<-xWtI91eFVD9u2oQ1w#kEF$MIE6*4oy?GQbca(Q
zt)m0e*<_H8PMHVzRR_wiR~o#xCfV}uQNGV|T>~Ivxjtv6pdc|9x)xsyxaLan$v_3S
zpXMi11;^+XnFdlSI8uISQ&K88dT|~}feP*wdSV_ICF|M##Gk3Olwt<J(WZ{V#Lb*l
zjB^EHWf1R~gSDc5vB?pB*;1uPzhr8(t^j;kVTXLDn3aOZg<4O808KD%mLZ>K@Sae1
zKdOGxFV#qkeY$cl0K1!sn%R+ysMqTLxY%gCyrQ4-j~-m%*QJ<Y=!MjSt4%LYQ7;FX
z^?jPEt>2P33BWRBhCw1a*o&fszfZh!yL8$J*sW0y5fq-n<09TmY3L&s8uH7El>eB9
zF1678Gs@nYhF%GjC3~=6_H-CvJPoY_3V$1!QMNG+onUJ|GNawH6ts0Rr;5ZdviKX*
zdkC_O!AM2oTl=Q7PSRPl$xA$<EdIr)nZ$2?*G!`2E^D&-a+gD)jx=}q3DAJM<XXDv
z!(HAuC0$k9Jo;7}P@0zG3JXol1i*l!8j`SlnH$VO>pu-4X(Mb~sm})P3tGGj%R`}?
z{={$dS`gtp@?mIlbj?cC3O$)5d7j_MCG6IHh^rDnAL5b;=6@%yLccB<{z5lT(BV4o
zsU@l2j-*SFY1@JP4M(2>oX7*qX*Ol7DH6Xo%g}Ja<lmW{$H<uc3l)mg>b%)Oh4DWF
zyq`3Q++HM={7aG_4wB1L$!&>yAbMc;05b|6zC}feMvXlj{e`~I;G3qF@LlKiIzivf
ztvPwxNjJ@HO@nlF1oRU?Ntcf{)sri1!QcDn%TVq#6?<ck+}*3w^({;Y3KFfsRz9_W
zf6CwXC+4X_9itn(yI#^U+St=o-6li*s$X)dMh~%IS?WmLwAiV-*Xi+Aya)v>xC3;y
zyj0>WxPx<O#5;4GufmKS#3gNbLY-SN5&O=6n}N0L%(^}&z8~jAiXVqMCXh~T%6Kc6
z8hQ08v9ZJj8r9=R(aQ{dgm0gMmZ3>cfO)5lW_&whRTw$Te)b!N#*MP&IBRO0H#9b0
zKpu3;B0Q)k8%B<%8L^WdJb?zR+QXNZl@s|0F&6fdd?oXI?AxF6h*><}d*KKg-xxcV
z4tx_#%q~e=Xlaj)m)PU??f)`^MWGZ(<H6@{cfnRdfuWDr{;5D<Tb(NlQ}MglRyl?F
zLA~_Nj}iLQ;MLxZN`e>JP&;(}T%SGX%+wsd#*gVUu$S^3=1_J@56CXA+uoLENATJR
z?*jgbY($&h>bq8}nqIDdk;BHWWz50U?CDQ}1%mNLJC#}EOmH&Y#(vM*Dj8ks(WC^8
zLvXZRfcduUpIe?Sa#l5XgYLCx9l(3O&qD-(IaG>%sX*_u=$z2PSlxLe+AGE}z~ljJ
z#~Zvs*ew~yt6FohAG=6D;#==C2d&PS5s>2lmSZXMBJMM_{>Eg@?;E{WechYtdg?=4
zSNw4!uLK;i(fbpbs9w9zj`-aHI_&z&=%2fn{x$x`?_Y!M-|T+<GkR9Nva>T^zNv%a
zYx?x{hRMF8K%;j|Mo+W-TI0VB7-yq5G_#X;$}G&MUng)jX!H^j&5B4amjhbR|9odX
z_{4+Pou^4We#yb5or^cL7iF#3GGOf5>~0=A8YO<h!FJb*w+5{6a<kWlo_RTYZD}_~
zy^B{>b4mO*{);<Tyq8On_JW+!&$;hn!F>}7T9Sh~_Nc{rVrRAUT;K95GRi;atfoBc
zNL3W)ls?ZgIvNGxl5EN!zIX)?G`X**EBF^3SfvV9m=4G%bwla8&#po-G~*nzwDzP|
zlyk0LQYdiuY3hA*Pq@!dMAQD$Q!+BPCgUi|q@D}4{#w&~T^@XN>CgG}{cC-VXYx>8
zbkyfp=<1P|6+02Idq^sqoVW0YZVuL#?Zt)e9CV_w_0j~M<X)MNl@qeG>}&PDgfVA9
z6?jIT-VLI|@`ElZyE-4+Yu%0ZxcS-75z8yz`GQ-#r|_lK8$<z1{%pgjRXpqc4#(>^
z0|LmrFThy7(5c$ZI^<c@c3wuM&gl3*D89{ZvnutNrDe03{&~5a2=)?>#K)I?LU@Dl
zGIfNGh5yuNfUi#ds8eA6rBCo#8eH(8I|4!7BR~}x(#XofI7<Ck*|XY<Cz^4^Hqur1
z+u(=T_gMED4&uG}BQX$R4YsA&a0l=b1yYn)jQ4B`cnaHAP*Qxa2>XQ;aFj*+!F|wP
z9H5=WUgB(Lxi=>owDSbI6T36Wx=#CRQ{pp_7U0Xb&o%GI>iu55pPMRp4Qg%tv2j(H
ziqpU@cD?I$s>rKoFaC#Wa|dRx!aP9zUE@yEOF7@<O~-*Q7KgEtvUz#&PvNm;;r#gf
zxJH$Q3*zr!l9IevjwZ1?>gpPW8*j~`059)?E%954mVZvA{!6Ju=Tm&^yHcr7fr&(9
zZ~LpckC&!CrOQ2#Yzpya`Lhq7YVN17&+dOel|dh|@hm>r%UB-;(vxrS<{=ac2jvzA
zxz1PFT~eyET@GPe46qk0t|9I~2fLrn*xS5l%TSoqX?eBYy5?ZmZ!l<yy%Nj*mP%dY
z4_i)652jN8Y{Z#Zk-7Je4Mj$2$kU1wpGRfXU0tYop|P>>7UtsuQA&LeUC2qlL<NGU
z;OLJUKMZEz=H&0^g=(IT>YoN%i9Jk(>8L}=JKcdK9_sGzbnVW5)jVys{nvf7{Me6#
zn_LWkhyJX7-o~F~jtoX>y%uQF#s@O+LM8h;cF^)Y1GVM-`N4UnH;z$4fNuXj-0bNI
zt-qN@RLs_ak@rR!?c&wJ{?NLny?8{7fT&F8e__w)hBvTtz`omKIVUnprJI-V@Li0c
zF@^s6aR@chm%VpkPPBMMrP*ITc6!(u*do{*AfeLj;Oaz{g1^74V1N0q?F(qjpIUfg
zDYy8t7-xeT@qevA1F#ho(1GI8*K7xh|F0XIcE5B7R=7m^G#x1UKURRj%<9kP=DCB~
zi|X2o|1H|gUS)QYP^+%TlVi<l52P*c{RRG_h#&3GC#-^?&t$Cy|HO6H^$aWG*&t)=
zKgqulUbF=E;MNy6aNqo!6lkS*#HKGH@p=el$v$ZUXrC~`Xe1?1XoXab@M#TBXF0N3
zsrA|^+~0o3<hT4qg;HGRLX-Eu?9X~1ovnBaCrh1YWDcVJMiw}+^BN?tpE4n()xFC=
zCEFY-M!<S7S;OAJ={#46w()h@5j#}j(2Gz@<)de=^LBhYRnHF%{TDgAFr+AC$1?93
zlP`mb=ZJ}GcaKkVHlr<MTQiY>TPN8*K)DWH`VIL`HJHk0Ig?J;N7$&UJc;Hs6i#xc
zu*Bf&InK9(C8?UGXjiz_&1H;5tlzTvSlKS7I5sJy5j#`~*H9s7?H3&QugcbCf*`=>
z>I=<o>HU0uz&8&TV%Qkuf!7+OhT49mULWGGPj`s6_6Mm+0ifsPHFz_EoH*PZl6*rO
zR3tytcDXnqn^dGA)TUz_#02h#sucFzz4gUnuvH@nXbjstgbcVt;Yp+c)_OlJGx#>q
zrrW9^Rxl78kQi5^_q|rMBh`7+HId$Q^MkWr(ey^|41Q2Gs7>5U!C+H-{5pS>q1Lxa
z_DMh+<ImHOH9o}O9GlY+MVfY}7K3^{cO?lVJ&5`dypb0vOf-;ZSulLLH-pTwN``;6
z`7UP0UhXse<g<8?8B#P9687%l2@dt$9Ln3ShW^bt-sDm^UC|Nm=LESV@wHv4T>lAL
z;4K+G8QuImW~Z>h;@P}7WY@o0pF+Hy>b`a%Qc$out$362|1j|nS;y?NEC&#-H40z2
z%H;l<^*K%st&)F2tsz#7*5@Ft9JA=OJ|hv<=iTE|>*|?YpeANdus*3kd-ZkcJad(2
zDptI)Lzx8=Vc4RiA)V(KQ%}bFJXk(PJTG2)E=zR9mfY+f-w^m%=-OH3Uu^QQ3wchH
z0h+zWoKMhgJW7ceRN%}<E*;TL#T1ATxyY<nxI~U~m`Y7T(4UmwvS3So=tg-ux*R{Y
zJMm2`-p+0LVo+%5L8LAEBCA5ty@m>2<}BDMjAW??JrMMYEqU1++9w$K2eCr&PQetU
zfTo43;^V=bv(ov<yzglr+$7-Ybb6?eY)kdtuG_TLzne`S;1WnWzNw;R6~_**Ebeh=
z7V3>y`8F=qT<O60wb;BbKk|`dBn^uoXJz)s&gR{`9r|mHZdiAok%6WsAJUvEPPlzW
z*&XlW4n}uSa+1Hl5I^sLN}Qsbw#3G>nXi}B`kqz=QtMkxUfGm_`0E+VIW2HFU1ba5
zUA}=wAKn#vkthx4LfOkWEw~F5H?D{C6bCEbR_2fuYWo8?FdNBMUzjqE?J34Np4qy@
z>GC_A47uM?;5&C;x(PK!YHJ%M_jyaN33%aVpF>E7oR>-^FpVKQ(d9*{)ITN0!N2VI
zQ*DUxR3nX_6l4pvD*j|fwWHFI0w2O6KOd#ppfu!T2A%jP|M>jZaKB4$fcu%K@H4{R
z4D%x&R>;X_DnG<QDhm>)!5Ewq6L(XVbyZdkPgZCK@#F@W(w%%KV*C?u7qc?4-?!VL
zqeD}u?N6-n#Izt+q3zyIyBqp!>if!aG+AoJz#*7gHq3wfSqSYNYD3@Hn;1+ER9n6f
z?=0Y8yv;>PwVF-qu*8u-&3VF&uXYC!_WJ~hDIrpwrqyo!YG=KBdcJ$GyRd*mq@mnO
z^fcOYi|nC+_3)~jKRx>;_bm8BykoZ^Xs~68IJ-NKCBP!6TAd+m|H8cAY2{}oHV~d!
z7`zYpMIZTD@`-syo_s)u8)%07OvopABj@QYTG(f3MGj)@#wOlv%;S}^;OGlWT>5*u
z(p|MxJqnDZtWLnJ(I5KncqfO=T86E|v><rb##p_Z%aS%1CmdOf#z03FNpZdPTbOva
z#)w2WnxSs%uJlhY@eVLC&A*JJN^+(ujZ4MoHuYG3v6Z`B?*7Ue^A-+i+p%zvJIK80
zrll3~HG@Gjeo&pCpJ+EN#y?bcWd54#ebdfo<z5a$gmc^DfMl=J6@rqs(sN{j!UoGY
z1K;u|Z0lWk5t&Oj&Mr!6S*iF`Us>wR%kveb&Z_pj8_3z0!)l#Kj5>0+^O4gHTUFp5
z@7$A6omNWS>4#AJySQ}nXB6+_bGbRSpZez~9)sAy+q@E0tR=-N>n#611VdqW3TM<)
z7#@rr%Uz}lJyPsSqZ3(p*&h0%rfr-zD=Es|b<2to=+Jma8r8_cQ(U%&p7sfa_Evhm
z%f-4Fjf}!j6ghcBI%cPq70@+#4UNub?=tSuP-LJddKnh3WuEWUC^m=R&HnqnjpvN8
z5r@m&%n}r$R?%67RCait7JaFi@|2?1M6$B~)ZaJ${R^|4cgTL0JM;p5ubwh*ytBG=
z9h=;MW)dcMR~WOQ?ut*$0;t$&|LoSE7O$}Ex%j5;0V-<J2dF~*XZ&O9-Qj)%>*9m3
z{BqVdt-4Qnv6<^>5A)j@uAem4-K^I1Uw3nB>T7Z8>t_Ee`IHnHf&H30w1RX7utoz2
z>pOD*SAOt+9e|3O#s{cE{nxb0=Qk6X1%%;9^NHuhjtvu=b5ppkclemwOgyQI*h#b8
zs<(^__>oy)>SRd{@ewk0o3*U@y6p4fFEn45^WAt?^L4rB#XF6Y26{fLuPa?=Y~j-W
zz<R$qGhUVnBBCUpe*6C>AQh7rLG6lJz{@L=`HKrp3+^OzbdyH#XY%3^B<pv}t~`?B
zNkWXJ;{Ce@{hR`K?R&#yw9Zq}<>qypNz4WZ&SFgp!lbiUbHW+QS*$5RGH@1aM%pK5
z|LOw%YGPUMOmP#&ed+racet68{`CvTwtmf!sXt~usDGaMp#JOmQ2nNcudV-qEoS}+
zILY#B`jz>Kd7;HGNz0pGnUduvH|_CWwmbaczU9r&KIIEPro2twvwZ*gGWtYz7IV2(
z=oX?Jdzn4l&B^X6`|RrBrR#`?0yc+{=D@*>&bzEBf6o6HtIj3a<>j$s%1?>alphtl
zSb<QkXA%g4KdJ1+xtPo4k6r1k9=kL7x3bsge5B0rm-Uzg){G0^>KEXi==RAq%L3@L
zdxo`7{*L*w@Vtc&>^-o3@}?jI5vz{snoPXAe(~#N2bQ@WO}v?=UzM;pL=W}%=_`YN
ziT~!TBBGf&D~}G(9u~cT+vbS3ilAOFuJ*_<1dL&Dt~#$7IYf-NY4;l9(&tC7HW`0z
zGdi!6Z$o<|Kl!rH5Ci?Lm^Xn(2S(?UANyXLzpWE5-A;4E-OnG%&p#;oBa{Ec|1H1W
zKd@Id5mdchYjzPWht9CErFS8WDu;m?lF`L&gS+x{;5K(zF*FY+DQK_$%DBYb$?Ud#
zl^eT`tL(3`V{=e9KSh5Uy$SI&AO8(HSG}@KWp~@khG$lmZ!5dz2dZe$v``z;sJSHf
z&KhW~ek9ek>QGPB{-%hV47NCDl7@ti?2CU1zIOi35npP;&#<ErEws*C{ACKl`IRCj
zP#ykMb>5eGsTSh*C(tbH5iggiPrQ3D0S4@PwE9nTB%PfzJKwwctgngJWiN-ZMMtGF
z1OzCE7-$^n#0#AT1>F6*Lq%C&TuZ1o;HMg)H<$MOp~Makb7kB++)!chXs0V>Jg>R3
zZy|LoVd4qdDhwq(zoWta;>S;l9biHW^5T-7t^a8=12V^M1vl(Re-IxtHBb=b!3te?
z*mz6L#GGaPzWgzjv+E6onKYwiWOteb!<fy3X8uDO<{hWjW@u%%v+Bvg{Dtd$w*7ZH
zoal-K0r!D6J7l@T#b#4n2Y+wjJU>+`wi8Lc@0Un?*`3%=2KliSN24`@q4zoiyQ}Se
zb+xXu;SD}^R|OjEmpgtXRBiN*ha3}=DMOv58`GNggq*$l;e+@V*fA9P*Vy!R%4FZh
zARYw&;1<~r0}|k;7#XnYoxeXrb9K=t`FD0G?A`QeKCysy%Z@K=`-7pMtqlF7lX;%F
zGCoQO%k~C7mY+4Fz5bnZh#xa?)IbqIFoZOxIp;F7v@EAV7sPseU7Pwl+SEteO+C3f
zoMJd*ZGOXW{w0R<LMFd6oncaU8!^mun9viewm%p@Tz$&&uBOvGa@@%n!rre+`gE$%
zXMgB(qu_1MFggtF9F1fOgG?&se}i`|_B<v%woQhK)C0bQem>EV>gOV=a5mc-o@t+x
zpM28F-{!vG(^Zj?3h{TzxUV-W5j_F+1n=dVMFT5~4e~~t>}uaG7-xgQB?icQ(7TCW
zqT9q+)aoqur&!qg(RGRhRwP2As5R%c2D%%p?Jl=4G&O|G?*8`Cb9+Lv#Vbv5a~`6&
z)_c=#dth19`=;3vg8MA9o<=Z+OydpYUpxV5dpGI^W1Yd0d4u!9^DV|kLJ@WF31}fl
zW8>^x{4=g4eZe-hH5WBlY%2YV-W$U2Xbo{6l&nX~W8cReuc2XfcCGjEER#%JYz?uy
z(kvOPbn;)ogh>a~$EW{@Tk^$@RZO9`9jhh(6p>s{ThLzM)l+4R^^={XX88K}slV;V
zpCo^zXF%(~C>9jYj!x5Kyj%;>JvoKCybBABs0{ncn_8eo!i5<WggG`xd)7?J^6u68
zepYwOFs6VX_Gxe45vDz6Tbc>m9^NgyW!L=ql)&u8pR5%B|N8mT4RrtcIt1)<n)2uC
zc5=`p@f+qE>`#gPKs(|NjybWj0oWNkaFHov`lG-}7l~1BQ>@36zxV$!X@(y!*w$TR
zh&cJ2|GN$ZVY3(Z#@jv^PafLda|Zuxr#c^_wP336{Tlu2h)i~Gh*wwYyPd9p-9x*y
zk>cMI*nt=yCts#`uDTTV?!~itCIWn|cOy>A1}eTkIkVjEAQXGi*AOmqPCVKY8rR<H
z?~wjFPCjq>{|@hX&Zx;ZsJL{8FHq22@<q-|edr@*=#h&VugKEU|4xs7e5SS?Hw@9<
z=(8#to={;jIf2xA3aYB{>6EMc8pcwxYD$)q>n}q>6-k@!{ozJ~2XZ|@(LVZs2kb7@
zx4&t6zN8;LueJ1C!Jq#0Z1hoVYd`+Z0QO~8OFw<QR;THyeIc4BTFpvtM^T+O+I!&W
zfmuA7ms<V(*QfK&qHPZ|8TVbuiHU*a;6TNDe&)XBHcgWG3VTO9qTpeg@4+okUk|o(
zV&Ci@pfhU8dY0mVaeQt0x4yJ>6l|Num#WkuY|Sd0bIYqi&I`<!ay~}szV>r)i~DqZ
zvz_r~&{p)y9aCT$`e)f^{4<`(@Uk%njNbbJKRfl$1)mDq1;9gz-EB_UY8+KZUw=fy
z&4#N5&HB37vF50d;xzlfIGKA|x12_;qBk1PAA>vZ96FSIK2zRARx}-66CdE6r0zEF
zrB`+IihB2)KaF>Mdc3ot3_IQm4Yg+{|CsUq5v#UnvqssYf3AF<e=3BCJ7n(mY)N$O
zT2h)f@Xx*a$Kc|66{^tBu>QGH|6Cv>T?`<73^zy;|3N;AEZUaGo@4qX46)HY0v^qy
zz;naVUhX|2?RV`);~DY3d@!H*FJELiuesSREArZx^?vo$SGb{%TDj=0X8wzLpRH_e
zCN}ikEN-e>HYl`2*{ZAePaf~%uX)#bv4SaOtLBVeQrNufTijQ!ibc8%6J|LrLz>h&
zT#4d9`-;gE+oVFTV%eHSHzVF6`amW*0LETbXOb&DX|_%5_7(3Hwyek@NO{|rbT}*d
z(4PEJ^pGBGe{y)LA311J`jCU(dPzQ?(s!if??cU;qP0$dJh&!W==}oaZaPe!(N#IC
z&X~6qwMhG8&Co$|@EI*16cUXjw$`ogVNkjeV*j)<48OPN_k#S!-iA+v9CQ48!Q|mk
zJH+;v3lVb8*Yya26flD;l%+zRyG+Uzr<M;XSDf1XMIF++h?qicmq5E65{Zq_xf_wk
z=|&E2)iF->H*Je}%MUUVCOSt5!$0sklSd@RkcVyGJ6iXTL;V6%x2<?PueSGAwMAF0
z6|&u^gZ<te>g!i<q?g7#mdjx)csx+?`1;8s%U`E|9GZwY$~kCFY+nblLuaNx-Jj3<
zrpqP2@|)DA#62YKIp0l*kq_i&oEQD`wvO01&uCL3_})zaJ<(b`R{0;dBKgt8mq=^5
z4{=85p5E3wBeo8lwC8;nejA*lv|l{Koi2CR4M;hrz&gnD{I<@SahdJ(*&=SU^0R5b
z$eu^BKCT{a5Uev9k5Z+!NFNQHR8IrBc6#5WcUL!h6%6xSj{7qX+Bo~7Mz55gEpO+L
za8TzA*5WxwX0ZYX6K|xdC+zM2D;or|bKbtjB;u+fzd19(J$?uKJjUDayk+qP_PNic
zAKsHplG%Sw?AQ$Qu^RejgI>P8kAAT8WE_bRdk;vD$jH|nTPc!!sYA0$$pIa9{+L|u
z@q&QSiS_p~VP@M4&TpE1zx}eH{Ue2W@5H?{J8z$Kv#MDgPgOol1$G4VD1E|blLutb
zhwMYSh+Y>XlJz{EVH;b+bMXpx?DNZ}M9oG2E&rNt_04bJ50pR^A`04``+<*NRs+E-
z)**oY{1rF|>iT+fMR2}*dK6wViyP`GXB#hyMe{Cy^qKcJ$7W&1$}Bb#_`(n^gxjc(
zNOb5xg3e%%$I~<o-kOP0iG;z3A@i2y;_fm-<N_jof9Vclpm&-Vo|1o>wM?x{H^2N=
z;y-t<yk5>*b{R7toc~M|;E*vw8N6s-p7x;F;Iwe1t^6Z;7WNK399%qGc(R;|Lbtpi
z&X_C0L#DhRkkiF0r^j5X$ke$!aYjz<K8hoi%66`;!7PtsO`T6#nOiw^_gCjf@2LB=
z(JHx>;{=gojICpQgZJ4e(+kxRYOQBEVZlKc`<dgJ<71JUu)>os`_U=V8oZA$G#%vL
zH9b&MO}s7~-3B>Bp<!<v#A!=JybJE!)oWc!6gr*#>o_yggJ8RMq-_V#mxMY*3z+Ih
zPawnWk*1<w{Y1klF;~l`{i}oa$0d%S1PASCi0tO9{TG-pRVEk9{>q--6sLLeqAxZM
z;6aYVOU1e%YPO}Yn|FJ~578Y!C$(Nv`B%hr)(P&`(b`CMm7xMLN=<BtSEBFrR^5#U
zh$i$YuY=E)i9=%tcz-ZoL*fTMwVC?ORYmfySx^0EfW3_PiPvs2433AMdP5mxI+3`R
zUVAYEC<O4P0Q}#2b$I6*z&-%p7GRJ7x()Ou8^CA)TLsXu*l2~ku?8>-z&ip+jg=U#
z5`_jZ48Z>gu#W(;YxX|7O9R*!z`FwAG@O-?HITR201g4*2~Z%wa{~Os0P+C5Cjim!
zvJ$*t+v`1I00#g_3c$HOD{+Saw;I3z0NVtR!Xa^k0M{A7Z~*TMFie110$gYSBLI9L
zz<vTu6<~@1j0EtZ06d14l~5c^?^_0N6o8Ke7%spe0vuof2Lkw5fCB``5#Y;TYUKL^
z*e<|<0wf?BZ>s_10Qf|J5dy3g;CTbc2k@x?2MO?30sdqF-vF>ffP)3NTYx(apa8&U
z0vsYhn*hxQPz+$F0L20*%#nAg0gM6gxd4X>5D{RS0Tcn)CBR_<$SvDD-T=k|_(A|;
zDP|=`2~cbR2Lbp}fKdYE3y^C70|9&`z~KUX$VGtn-Y<lbYyiCi93jAZ0sdtGB>=Ku
zqsvDN@U#FO25>llYyplG-~j>dF@VDW<Opz-0ImQx8o;3das|K@DJ!8k+1?cfkP9GB
zfH4A`Bf!}PuwSg;sZI2%bX|fNqrFcJRHkn#(*%C@+n-t5yrPxwWdni<q&Aq~{vz1F
ztw}oaBd;erpF2HXGoJEhBfm~D<aN72{OYq!C9L-<9(^%a80f!KiQ_TfL#l{)F*-wI
zPIuXM!$*BNf+X#{Ca!?lFP+yr2GMzs8hT56%eKc~?h8jm802g>ntroU)4hW3Dx>@I
zH>_kqzwxHWgUi)|e96NKN&n|4d(3BDS(J^R!})|8^PS#ZxW${T<7nQck9bQ7$fsUc
z^^|>Ox}DZE(|WK&a%oay?*#mmL<8mgUfh_4s={eeW7>GO@f@Ajy<?iEVye%mO3EZ&
zBWomfWkWO!yN;Onqh#`r2FaVy<eUK@xv`J_QImz%w$S)P1rjRqqg#y~A$LH=CH;Er
zVd!i;5|N+RAM1>A0;jsr&Cf7BanI&zu$}~GxeMj4(t49-PJ8pHC=qKg8&&k0<BjsM
zfT)`T!@aKxMToZZE>?^?fp7ewshW^_*&Ced5hg;HsV-KojYaWjUcM9^*)+;cul3$F
zJG5#$pe|k8a8nyuC)(PQkCkprK2o}_W3UM1+bq`Z>SBE-_7SnH>&RF7A*6!@K>C^Z
z5M1w-9)dR~LajG5Ks-1&D@Z*|ykd%IRxr@ljgNNyKtaqSx0OZi99e<yZ*X$xC10mx
zo>Og6U=(CFbI--f9H^AtN?CZ0q?(qOdeh6n`AP(DFNT;u^(dvAK>*&8h6eMm{hMj2
z_&O0~h)Wclg$H^cz0bHZt1}z98OHzEAt$$_{JV<3j-D14(~E?a=-#qk5F1S$Kf1^#
zr<~YxBya#L-B{~Aej8j<>mKs>3-P0gr1^-X<<9t^?yABq&vIC<+QbB~N3%k>ud<;M
z_T`GjP$SWTNmqU67e>6zV33O2>$la_womP;#e#*%2qlPVi*>)iLXyNbg-_$p0qyLj
z1im4BU1Y_;lkZ{gojbT}!M0HA7h04EHVxjd&oZ4?MQ>SpH*|cgE#na6uWH-aZmhKy
zE!dz6Zorr*v{cfydw!lw&kob4?fZZH3Z|iU97^+O#R!*&-8@U>Wq+xJ7T-gzV7WA2
zZfRxOi0s##X(QyGPKZCk$~F~bzuaDwt%&FKo7AG-i#@4oQ>e9q4`HR6+sJKU@88hj
z6x9tw+4+soEsB=N$SyG>Uwv6>aK~t(d9LTrEjzyqwMzO4*3H}UY)-G6L1YB9kCxPG
z>5r?6^_}=o%ZqlWp#>dpW_-`V&BM(GJ^;=ae&4ig-ut$_CH^H{rKe^dLN^uC1teWv
zbeIywwy%kuwC~+B8{4YtqQsYeqauNg7k(`XgvsWUKoy?>34BfoO9C^^Y=EQ<3CZ1V
z)24)cy!Xl<pnqeJ93R?;rMlBF>W*(K-PqPUFX1cI6Tf6G{qv5&4HN%~T@A+iu4iob
zq6J=>Y{~<&iB0iI=93JPdHn+62dsMiNoFeL0+JaGYQSQ^VHKpY%FABS){9GKXzA<J
z$F&Q{$X@Ai{j#8EQExNe?h9FTJ^Jv?a+fQgwg#-+`7{~;UEG?f_{g$dfNgTo3g+)%
zJ2JbD2As5@C-y_TpImsR=@R*!9m+2Xd!LVh!WQWsF->7IJP#=8e`fA|%=4N8N}Ax)
z#SkrX!m~&V%JAfk;&*p)y1NQ~8Fcsi%)VI|UP5;D-Wlv-qA3wxK;ZB0NE5iC;OO9<
zKJVM}5%-Jne3p)3nud4Bd3#g(?)TJ`d}3DLVt5^vWv`<Xz!5Xz{a%#IL2FIMdDxdn
z{Qdf+3<JRQe!XZxftJJ#Lt7RU<i(gZ^D`LJyM{zkXWuYLD5$WLwkdVkUA);Rs)fXR
z{`L8cx?6t3_Q?FcCVpx`1UqK7T={Eb6oVkJbfuvPh84$kGUB{pDB-V^CX0FU$B;{G
zUO0leGCTbX1ctG7wv~cW(?gO!WkS!LIXfGE)Zk6DTcPpJSiIEl)wCk_{E}Ml1u~*5
zq>Aj9$F6eDFG*OEnblD+&^zl>YJ5q&r$D^tWzC<9<e~YKtw%>3L5K|AQJc*KvT0-`
zeorp!2-dQ-5Mhm6=A6Y;4-qfh{Yg-zekPj99MI>RDUgvIz6Z#+zeDdRlL~7;xMr0*
zMLghRqPe1e8Mr1fhMXF>qJ3X~uE7Tf=$$$7my&B!`Y047(t=#OZ+Zha_j!g4h9Zrm
z)1|sHO(aYhe~dmW%o24N9uJSl3kk24?@lj@c+>30LEoN1JE}gM4)2*~CL0%iB4DFp
zc=A-c0?=m6JIBv9xyYSS685H%v%PpE*dL2?8!iGRi6$@x_g+xgD1EB}WF=tY{=I&v
z^%Nm=8vl4XP#Rgd-%MP}ZzFy2AlxtHK7j@6i@n_yRs_?M&D5Vk|IVsK+X|R1))TTg
zrYeX9fxc~(TR8&1ytW>ej+^Vw&(CH%Y2YIIW~=OH#f@@r7u5Oo*j>0$j$NO<)}hRt
z;<Rr7sA#_{i+O2?J_e0MZ`MD0)Dd}_-kW_5!NGamOL9x39dVJ}1?+s;-eF>O`!?DU
zdz2Hh92sPZ?aByyGc^KO+9GB?6Ydaddkh#1u5?Go@lk-dvb;zN&)Q?$(L=cVc2&k3
z05}c|I9eK}60HBtIKhxa%~R-h*gGhMqH85{(%w9gben^Uh&^?2=%#<@L;9ur4<5j_
zM#U-dkn_v?tQgl+2{{?{UAlq3>4DmOP62WPZdqqq%Mfw<S7`!=Qr=$!ffeyL65pU3
zetu%@=S8A1#%G7qe%EddD%wm+^i2I@vHSpc0tUfWglN;1TWY9=kuZq5=mu3(lNXL|
z=R>zfROYq`PvPhT>Dn4hZR0r{8iC}5zO{*CFa=a7FDviPbD&oog7tlcU5?HwoW{OS
zHk976iDa}bmF@^f3)G62CXXZ$RrK0diKUU}d%ZQ>gqd*3E%S>9&E4N<lt9jLbh3hY
zk!n1WN5V(1P;!GCDe~Usi{k?k4V|vBs}k>%GsXXxXI*CQCv+uo3xNLj56cIn;Xm99
z+}s~o`s6Sx`?Ov}l)mf(-&<YF-6nUytvJGN!7~31<6p3}TXT!w!5sN~=nB}bGo4bb
zdUW|eUwGk#&)!<`Ud~C8;;Rb{9n_#HV5m2$Y`a#TgyvfBpu^170EGK@yVy`{9!u{V
zqG$4Nv_St@YWV5tnbbgUy%_Eo_+-`O*^=St&C30V{`o<=-1&XVdEcc_Vt<H{8j>s6
zzff04ywljdSuGsfcZ8fznU3Ux+7P*dmv{RW-?H}?m3hfGbe|&o06373LCkt^IzxUx
zhGh(0%q~b@))>qPEx*?ie?sFXhxNJaYp53S1{eaxi;zQDsI{E}?KKcvJ`b$f_3E55
z`_y#R#=t^NhG(Cupfj@;=Vx{2>KdjyZ?yiTvr5YxYTZvYRu;^j7#%emm9LcbAI;9k
zYVs4V@3qckV%cWS6jrtG#gFA)zcP>dq)ZL;{pN3eR6$2(kBnYRUG7PZCS>35=mJqB
zTAr;yWQ>e(_s7zAgA*zCS?%O}%RUGZ$ENoUC#C!l(z3iyUx)Uq{X9&D$rgXjYhtCA
z?r?gNYkmHKO`qY*-o<YibT&p$r4!L_=pRcfvpK$H@aHo)wX%5Q%zDS?P=<HndXu2L
zNETf&)pQJ_w0F2o*Ii`CT4fw&6Lc`_cwY%wBse{0JyWAD;?4f<%VQ^-D|!?jvT!%2
zU!r;N$pE=~<Nc)`YoBK3P8Xm?%Uw<IrKL2Fy;+4JL+0Ujs}bjgfn4X~w$8=%+hb!0
zh-I^#o66SueQI}l7FTUg4t|DDF3PuOv#=C-hi&`*Rk>VLZsUf```O=fecLc8WNOuR
zRpAto*H5cHp3Boc+qs-Qg(~g~>(aJs+Pq73TYQI1+mlCW0O*~1Bjz@^n=0C7k=O2b
z(^`^+xc<k!<5qHZ_OFt+rLU3~&F_(&KzzA`OeAduXYa6zL#LZ#q+fSnJJ!75WAm1f
zIy5!2L)WA`bfhVS8A?Wn-eLGgpAqz@I-@_j%9e;q|F#7EdCK=l7N*9e`t!KA=|8Yu
z$yA}XN?1YWeJ#xrUkblb210GZpVK1@G6RW9sKK0=wt1ib8!|ChKN2O?Sp}xre}kD`
zqyH>)#$#gk7*-bC^vmKxnTVlpcVgdE(Z4<GhafX{Hu+~?O;tx6MH+V|Dpmpa?#BC|
zS*{1jHjZ|dU@JHM%lFPn^-sQfL4|WND;%T>`}I-srM<Xj{35l0fD$!SLz?sP6iC&l
zs>E?5ieI`zt$#v<NcM0`bJrOgd@h&pX1;Lh(*=7|{<%$w$CwA?r}X`$f@Y@F%NhQ`
zviT*Z!~nyYWtR~r{?3|J%Wq{Nm3Dg56AbIQ-egkkoBJsQaM7M`YkUUEaWQ<U90Lp9
z($3{~i3=1{);HzN(2wQIYKy+(1WdzE?6%i?{mMV2@|(PV<>fQPkn9m4CdYuVcVMeI
z=#{SH1ufI@$85*%p|J5WQm_;M{xelx79K<e86KN(5l$r~WvgRHv`?<!PjT75Vq>Tm
zJ?M{8^&YBv8NW$?sKq~6&O6Zh>nwlLHh8RUFu88I--AO*C|#FanJI7k=U32&IG~_7
z-->WDz&$bS9cCM30tW7=EGUT&!A?5#D2`~{@GV~{e7u0pKRERU_CM$w!6WFTu2Jj;
zhbpu|?d)vg9@zTK%nb9V0g2fETK>H4^*rjt0m<Iir|p-G?J{c@)8){8!ct3T30J2w
zwP5b^Q>MxXmD440gLo;qTe^mEeAp5DH)gcisOM#8CgNa2WO8;UpJv1V*c(8T{CLb%
zWIZ{;-deT*vWi`F#+SEr<tLv==|71drhRu2d}+7onC)j5of~R87c9!!RKFHcUHg1%
zLLEDyE@c;enMt?a*|Cvfu1;PC4-v1Hbmt8_l7ja60}Z{Rp4atpqnG<!FiP1b_>MY~
zyEq92W0VQVAg3pBCCi;*?(z=P^+iu+*gMvbwZGOKuwh;q_wMn0v)wd!-+4N1d%eYz
z?u|YWX)SfM!1y$EpAS71nsv0S*^p)bb@;mI<~AZ}`_t~L*HY_W^r$Eo%;3TiHk^p5
z?vEMO5w^<^;WF0sTdMEW|5~5r53p%tecE%wUi<Z)>e;<D)i2|KSnsUh+)kJjoY)o~
zDTlyX8C8tLUCljp*=}c2fm@3cTVZ?NkK95D&urOvf^|>Qoo`n1Ez6$>zDq!^2~0<S
z8v$Jv^iAt$O5R`oH?B&1*FVLMHx?Aui2ZHmQ^dO$%Y=R{SVZ=jKlK-8aJs3lZ};|A
zp|zCnn{RK81oHKN^B*++Eatu3Jma5&r&|6bM{&Xe`yFdIlh(h<e#Bb$8+F@-hH_#v
z_~RCyRA00pg5AbWq8{ABgv>o_O1#n-y|k^nVR&LNB8XfDH&nXA%2tM!eohu08^Uhv
z&fN{siYuXr=f2}FG~ykr%49AqTP7Q8<!gXvTWmgo_=%up;z#(~kV2kdU%|FnB)3-z
za=t$o^|ZuKej$=m)00N5Q%{mV@bRzS^i-=i3(tikBgLHk*lrtGWm2jmuanCimY8cB
zFtwY_Ppv9gDMK&~(<si|g>~L~lW1BUmO#KXIglRmeoS8`JB7w7ges`FJ8zkWJ=qzS
zIFO9cua$p^m&gt1OWNT7A8GFcUv*jj|8Fp0>hw$nojPqADH_^Vln|(6V*^F>Y;zlb
z1T>8nS)!f;_y<JKroMeUoh4>zrDbO6$IP;1W+E5^wL~CACB^d3`*g4-8X}teK3~`U
zexGwTu+R7V`|0Ds-sk>%-Pe8H*L~gBb=}u(uQ$&jcB{V+`a5);L!Np2^Jj5%UO2Am
zWkI7C!iu$Ww@F%Uk@q+M7q-qnn6%!e2DnO);(4+>FQQ|g?yT+eo<2!;cNadI`CZkz
z$e{VaK>iTILkI^wISM9t41{OeF>rAh?GMjHgQujG*TdM@86d|}IAjFb{6Q@tNEo~e
zf?nRB$OFmv?XepL*G31|uQR`_+7Q8YPb5ElB7Tbg-|#c2AAZj356u5He!}xB{F!}A
z9$-5XV;?N!YWwH?`qA*Pqy0IfSlXYmrF{sG6-niB@+Enj2-KX|*RJtKdsx*vP<Q?C
z!ezTExEfgV{)EDXLzeB@H(5Dx+y}|mGaJ!wXogpm>f}LaWUsevik8l+kX`?{8DYVl
zT6eDC6)O1Ks9@%X-T7UJ-xru$j2AH9R)6Mbh7jj%<6-`+k$jFP0Op|NyY<{rTuLZA
z6?zkRiUkj3PHd&g#qqY^(-rg=OwnqXW$)X*ocyEYUT03N+L8Ot%4b>ne*qh6Gm=2!
zY*E@522k3GSbR1l8bEua^Y{cGjrh$P<!fd+#<!3Y_!toKi0s&RMPKha`g$z0qH0G-
zUuZlZ3gx@DUI4d-?BC42{p=5Rzq+LfhPR-|FY~K&t8r}AI$)Y6nA+aUYr-wZ!Q5{I
zs)i;!O@n`zhEUlBs$*a5oY?2R=z#it<`I1Q7+vzWz|(f%MftE8RQ+1I&swU6L5e+^
zyo5Y3zdEb20D~jERV!rXw)ive-iLGc5($*Y({%7zm<|$ZCbu6+9gK#XaIGts){m<#
zU2-_8JHM&S8*{a{s<XP#yQIVdEQB1HkUaj>GK_m1w{j}s6VSV%1TNg*H4V=^4obK(
zQUnO|OS6EHE!eQ&XTH}x9#~Kx{6K`cA@gH{jo+R2JGyS-=j#WO7D580?$2pf=kUAu
zYilmljLjMCEvo35JQCW+8#8f&FVDgRkIA>KJmORo1i!jJ+_5W_+}PSyd61I7A12SK
z%&XKARl1^ICE9Y8z8WS^9vQ9SXn#>Nv5pJDvhgpnL)kIhU&TMzQQ;lP?>iDzP|$e4
zW|BXr+~eWAdO2Ga@O+;J(Z~)tR3N^8A41cda`(tcIP+nDVA|_laXQ$X*S*&uDD6HD
zfgw*Y3fX<VyTg<_KJaQE7{XJ({#4>u-$XyiG<NXG?f-i!AD^P~bN{c)SJ$ch=k{3M
z_>bM+%TxX#{U@%(Vm6e&QyC=plTpTdgCi4KqSg}kRU(mf>O=8<yrsT>qK$*|yBH2=
z;0P1VPkm936mr-Ol8;d>yamOtKZgFJ*+*#Ig5f;8^FvUI%|1MTxp*5~H!RMQHb8!s
z&{S#{m4xUX^Fu=MH(G-E5imJFRHJro(f){rGwFf*Z%dPGRg$<&Q=^z|*Fa8EXW3yT
zahMHq18MyBhDug~!8)<csYj(A%<%^SZ1~M*60vsOrQ<qr#3;C6##<va?bVKAS%Dbk
zc(tSbrDIwHQ}@-5;dwL%gT@vQZge7(S33bzf&`bkI7%fT*w}39SEAIh_6$N;_Vg&V
zQd70rrYb_uGSnA)xR0&Duu<rcU;%LvhzO30jb~@Pt(PU;82oO#S=<zVBhojgww*3b
zGi<|N71s&xwGGa>%nq6slS{hQSi1?S_V&5GCypGZljuf}(SS`kICQk(UHV>m?D=}K
zCNaak_|(|hylVdEz2^H7&J?R|DWOs|N2bk^<p@ifKY26}1Brk7SvP-m4~|RTpEzLr
zCB=47$({L9OCBst%tdk8&gxbz1@phd)uPLTaog~eqmDYF<m3tL%Li&-o;=!nNmZ2J
z)}?~P5Br}TS?=KUV_@Ax5w}K6-?8En3U}{I8>R^jX6zhLhlVgT{>_pzzYP~wj$b%=
zqROcO6X!ay=xa_aI!C@xiJ_^>MiwQ`e_Tv%ihsr!uYR;bLls@c5znn2x0JF)FQbvp
z;nh$44Hx*HNqd{S;nK4@C++_puioda@r4D}W-g@*l{&2~w{v!5@P~Vx=1IzlldP!Q
zKyF&dVqz!@VZHM0By2Wq7*3#bd;jL|V}{@_H-_0vi@8T4S)Qb|60`-UV*sQ~=4T;V
zvhqEmq7)r{i6yky5|m$vx_`C;^&h)B^<foZrd<Fp1&Hv6*?Fpp&)BtB3P(vT`Ig|V
zZxt65_EM*(;M4KiN#JVYSreI8S*JT*R?W#goW{du|KZzSFZ-)~a5(z~&6rpd4eP_A
zrSC4gqO$LV#5QZ&&$V4~!U-p=VIHz5P?N)5lgXR?))JpbBRKOF#;*CCQ3+~2MTnP6
zhr-ZT(-hmwv9h72c2&i0`myTnDq4EAb;#?@VqF^0LA!UFo*89+@J&-A%<CztJf*-C
z#7<u09pqfjs1REn8;~5x_a{rp7(?svpx`*VS-Ce*j9VSMK{p*acup<@(uH7OklvbW
z=*y-=K9hyH?%4clXHgC5RxIE<bb;K{5}ZhNT1{U~LO*mUa-if=Lq{RG>ZFQJ`k_PD
zML<XF#tSJCqQvf-3MGRn9nNty52heCe7$)=7A40Pr1zt`B|n=>{%k?|kSO_)T=H?w
zuiQ%CMe@KN-f+gXmZ06$0p}H0R4{N3<f&bQ6Z@nV7ZoNBP3;<#7{NViH^2&20u6dm
zettnlK`UB<+FS#pvkep_AJ44i;o!dk8h@UNdOK(jpv)wbiOlg6>8rer%xYps_1Q&<
zZ(X&k4+O?;x*BA6);yltdC0=Ach>w!f6wid6$r!MK?_?tuO4NeM=YFr)voucab<01
z4Uuy8S~x!S;R%T^r9M19QI+~|Zen!m!!IX}x#~mLYA3B;^`SzqCJrP7!|={pwY=!y
za6KEdG>uNUZPywAL1(Qsy;TjqtOlP~`_HMTXTs*5>`X<#t>{cez&+5JDhAGz6m4_i
zU7e`{;b!NB3vcaAb;+)>bKix2XX+|GPg;g>7`x^&N_VE-dsTU?z;D>kC!(Kc+s`h3
zp7be361!%qB@|#0Kj~ixKCx@QYzckOlJN1*lmNNYU;#FZlb%I%iCt4>38jNb&@K?W
zhAfpRAfc~s--6h!&cK#_kLhH8T6WS|s8d&6k@ZB<d$yE+i1I(>RpZz-y03lJhr=rQ
zZtu3tSLt7-j%)7YCp+1L*2dCY8(M7XCYO1qWuBYMT<FqQTKcKE^f{zsT0EOS1Nd*b
zw^6bFHY92~m-OlaU_tQQB?{cbfwgcoRD9LPn*S?Dq&}`l?AuxYzSJ#4QXlV|930QA
z_qG$mFId3TASfOIUySs@*3fk{L<?bCuIwaN_7$2-#v82IxfH|Is!%?tsht&xG$cLQ
zTcwr{veJor2vq}MV^wgP_&kpP0JydA>EJyGfWFmU;z6uy;myv7Mf3N;Lffwf%KJKR
zATG^LD>7y7JXNmuBZQA5!AC<YN7mqpi@}G$A-G`BF4{9Cf1c)|v;2rggYZ_04jge~
z2;m-pGtFY><KWlX{|%mtAu59>yS|%jeNT(l_x`!{eQdbCkIb#_gR<*8cJ1*h>Gb2f
zug@QeF|a-#*WbMLnOlud=T_s&{MGpD+!DMuZwW5EJ-hrCc2VS2$Xsh}VG5ehtuu|U
zGnKc_q_6C^&f=Dkx6V#+C3ah9NSqNpvsAR)cz>99B{o5^4)KqE%T4baM9WS3%Fa}F
zxozQRro=JC*iC=t7aR*}f@Q^SS+&=CyGxdSRFxuqu*q}%=p}CSa`S>bdeJ?nJ<*F>
zYV#;MkY0{Lx(_KjdAeI6r%<fl3URArvs)cMb8Q{Ehqj)_LpoX=zu5x;=IQgZ>)|M{
z_6h63jqg_%=8f+xVEE+mT|?1<<Esf_+5<TG>mjvkZ|{wT#YVU2bNWUuFS;1j$Wyb^
zJSN|#zo)XW^!FlAY`+0KXI~7*gGzd~?t|KS$JSSNe2DAdCL51R$CY=vUOPM8`-7bR
zx!gRZxt9I9H*ITb=g?UDDpqT1=iZ4nJ-Nuu_-&9lvSv1<O-qaH@{PguUkNc2Yrl*l
zsl}Cp6VGu7>Ej2wc}i_<YHMRmK9NwHUk{G^2d-!?m<_FgwTOoyoXNt>Lxz`)ZVluR
z;1J%fq#7x04t9OU14ZVw%vi^Hd~!~iR?@KI5H>5k_8Z&EFX4Vpm+4=SNt747evH*X
zs~Gkzflk4yt}pX?!og+Eo7c5wC=P?%nR*?4k-NaDg7Vj~fgO!@8xCoMi??mjr~s}m
z2+qRp9kvW$yuMR?-4VQX^un?aD-xgUtd&Z4)UprvO?;ZH&v+jz`4*SlspRYGuRo&w
z<z$e)LLkj7tjRnn$g|#s{V^2+aWLb>O%EW_I==ukcAdh+As}B_hRr2gQCX>k0-X0$
z+u=s88(cvP)}NEbVm-N;9>lJ!Jq=@ZzQ46pY42dPX2(!;Xgdkt8Lf%LFe6_S)wP<Y
z1ET_0Mg@|u8WASA#!(7%nyC4_Jj{d_x3w@?!H6I{V`gp&8F^0r%NqZO+7u7~#gC5y
zj`tgQoU8)dH`80k_`&;>#NQZoPxVOVOE<S|Jal5pE``*Zy_$+U{pv{?jxB=B_hEH;
z{2{uJi~c1!j985_#nUF`xBIo#{K?Rm4gXivG$LeJ(h(>WW9Hd``){b<<_RCpkwuE2
z482e~@fpEY&2_jy6sGf;9zm`dWe2!hwUT5fU~w33qqAsJaOh_uN>;spP*5bCsd4-o
z`sJ3rt(b~<AOd&mq<se+wBu;^9Dj49S?Or-Skd4}Wj{o=BhQCj)&t7=c}Sj_JB>D_
zsP}8YNv!>B^&rQd)W{I5ZAv~T0&7AJpwn<Sm%cXy=;II|Ii%+R8n{+2alou_z&s>i
z{wD(FZsvCnYlZd=Wf5Otd9Kh~nSPu{(OabwX$zn^mP_zMtlHp;8a*{eGwBxvAS;hh
z8d>9ezt$QWxJCH7AFpT()<@(W>u9E0zkZsmpL@f8zO-9EBdO5pz=90orHxe^{KX}$
zZHcf(0y}ws$ktP%`=v1ZtN2p@Mo8)Q{%>}_20r|47y=Q$&<qfla^<X?{<B&u`E8Hz
zt=voDUQ?Yshj!eWx8F-$SZXxt;%!9H;%wLQr;qNb({&lC*k9|cdyh~O*a#bfPk$V4
zfi!=z_={inUL5bx+i4p6LY<u7$m(yz2GgOwD?h%R7?)H}rCi`Ro9fggoctwFn(fzu
zui6x($-U%pZi-H=@C}JxD$xlcH)XQ?8;O36_Pc%DgB~4s0XIy?jL4cG|B}%y!CuiK
zNt|u`Q*pLvARat;WJs)u?-TC!`u#D_C5tE8-^5ODbvsYn%VKxH#On^My?+1p4as-b
z3@%9PKo%9E$ct+RSCE@|&Uj<29gkXsdj(@_YS0s@@xT+wnW(+Y1*T7~ng4mPsy9$i
z;u&Pii?#1h#c^w5?GvnllJOIHuD+6Qpv}3Ur;i{dJefLqJLEs7vlZ)pYQ96B*xmqy
z*#kQ-!@v9E?P!*BPu+u>cBe3FcQ>4d!-6S$nLJ_jps3B1*8iiFv={zvGGvw!U#}uB
zd$Go#S9~T^B!|`LPvQgbMc$0tkFN`At}C3V_jQun*A&v<C^cBGk)jZdb=dfqlyN(z
zHMsF0Ym@>Va79)GyNe<duhIi;b;T_WD-K}cx0NT@Vjg-;eacP{t#zG<!p`aXsx^fb
zbnCX#diJqc`?D0FIffX`)n7jfM*%j#iEbct45#Px-4wNLL<(TL6@?a9Bo<uu6{iE1
zhj9B6wK#jYZtt8ix*@nRY7QDbAw=-FCHG?_Yc3ssnNtYoLIBE7S`DOstX2eK;%ORd
z)XN-`qL#9NC4ZawpPYP)wK{xn6T`%O*6u>z%wt!kF6Vj88R#XO8|^*%R*~cmL{B3-
zbnMlmLS<ig>W|o}qcXSSAL8D!x4PX?-Q<(-=iHT$u>70~I!{~Y$<(|qe`+O9cv#3<
zv@IKD&vdLOE3Y#Bp}bo0ojiF}OpXgZD--9^-fVyIsK~C{mpD_=JbPgtH+_)fNrOCj
zv60#uZ2q=mNjhQEK!275dgNr7Q^RKl<*%8XK3CR%S?~^!)nw<8i_4Ij7bYYzUzkOa
z?thcHH{L7t6S!|B5-5RgG?R*&qAQZMqx0oivudUmk1R}fBPe}LS!z~o;Bpye|DA1H
zM9IM`HanO)X`&!=vu~zLOtMU%-&)Z`!C>Tj(F|f*9D^)Vn!X4+?b6e8vG#d<B5q?i
zvl_HMN|pZgZdfU~Idvr<Y>2v8XFq=%{rn&5)=!{*Wjy!>v}kyYb<}AI+C_IHwW9qJ
zwT$2(ZM-cLw7t0z+^Z4jz8ID4Mj7cV5+t${Su_%m=S+6#t*`1`Xa9@|4e_8T*Uc+@
zX6_!K-zkwk1OFN3QyYPzd6jBC=Fc4uzmTo?{`}dCKhDbFPu3RE!WO~lfUncJy}{~q
z)Y1^l&+)b7uidIU4(*KJTHGXa(9~Quq+m^VTGL_=nXCOdqd^wl5lz9wTuD5@4Od#i
zBWTIwNyWtgDRSpa{+22s_7Ifuuc+JBHarRDwrz2k(+No9%h4l?ftmfR@QtWBWwc(#
z5%+^BvNS?w)&3)(V*5#5Iuf0}NHEL;NSv><B_cUo%K7U%5kmpQqsG;h^2QyzR=m=m
zSUGN0VjkOmV-RCcvbj&TP@n9H)Ti^sm90TjUj5@$e^h?`Qmg+g76Yr#20eA8_`nxL
z@VUqimYVp9ydVH?h0Ge<Y-nsNS_r+Mswxh)ylhQ`i{Gv(_!o`h%-t@B%hbt5v5rFx
z)v$`>(dqs4y%49JSo_}kJV<)@jy@<Vx(O^g8#^fZ68GKx#T)`+?Ft6uABgJPtzC;`
z8*9G+SSXk{GW``nHA``-f0`Okp|^x$J&%!Cu9muVp43M0S}Yo^UUcLsv1%T5s%5Im
z8iGG&^B#6N)K20@WjI~&K0WYWJoB&JmQla?QvRqjSN#_RJ=(8m`bQc}yb?QS$KRp1
z5N~-Xx3gubb!n)+gI*n~FY4ct#3mgzWPThPfgfv^Pki3+*!hKYn`PX2)w_+H@r`lg
zJGHo>t&L7xmu`GR`*)@L#NI3EIDhiM1FGr8O>JX@7I3oR#eAHk52CO;|2h2?%-Sw%
z#oA|UzMOq`GM~IL#J{rFU+$m5W|TP8Zy5zM{K`MIONe8CNOtP)L;={ES~_Y_Vy<HX
z(~Pes>NVI(@zQwEM_fI(9xBCWldr=iS15i$9Hp>c_*h!m+IGbv2k%k98@_Ku9h3^u
zu7QLlug4QH0wz8W6DZIkuAks-rz6fT=Ro@!@833u<J}5)1%fQrfhxw34{x5#w(=|{
zTDQKIdaD#REZ7&s%Ckyg3JRAl<N<hgprsR9+wP{-6@%zW>g(d*-!E9rw1iI99xQl;
zZU?D+TZI;%m7427NXrk+pKFdUiU=5vDt}0=oEmxsCvHv?{mJk>u5?l~V(*{HLOQu>
z9k8wp&eL=P<G37*0Ud{ruWNsATlV1;!aqzvWe$j^Ax?ejdO=;0J{+iZbnh+PJSBGH
zH2TpPiW_Wz+Kt*qGYM`Cw}&G=hEk4Rq>pyTi@f{hIyIsHa3}vo??-qYj)NaLFUZ&$
zUOUSCiG7hY4#}?csZr_VhRg#IzeXRxE=0VT+<U2}uaZn7`Dpqi{^$UMU%$_jhRD~$
zvT|gCw^50tS82mF?}EhX?0&Fb<`&s!TfA-SF{ct%<ALY6iirvG8Voy*FeTfB5~X<w
zWv*&lNl}(nQ?T-88&+mZt_<K&FFgZ<X3v)fd4fQDy?-v^jg$fUniX11ITt5L)<1N7
zO_2*Xw^nW{_&_uTPyVT>plTg$dut<yrbyrHPM-!=JUHE*|Ip?9=4jCm_zUw3jz1OG
zsL`LC4|T+Yl26QEj|)>g*tXopyr=f#%713}eECC5JJv5gG50`sB>u^<ai6-f#G8IC
zVHHK=kBH>iY~(!xR`aemDp$G~Qk@tQc|KH|cY}`1+@C%EK-TMEp8s>p_y9`lEx=#|
z=|UctT<xgqGB~q-bU>I<#NH8aBAnnqZm|^gH;rjj3(ch~-eUn&t!(U8pqF6L^Yp?!
zx4F-;ZeG@eYxDGLD=cQ~U_Ty5K*2(E(|29tYrNW#X&tz_*M`jOFSJnga(Ww!$h>#N
zL!NMHo87|7>GPa_h{IuNzE5cWc@&@HKIp%8lF4MTb~D2h(-i+4*?on}+#^zU`?7th
zOP9qA%)JZi@+Rw|j6<Eh!!6}UtmAIb4%&Jq+Z_VlR^o@yQVsro{{TvVtlrZ~XJLt$
z&g&OXUE>CATfy~IwY7K4Q<3?leZ0deoce;rIL?Uv;a{Kri&euT176Voh~eweuK{WF
zU$rB5)JrQOPy`km>}ME_=6iBU&t#*I^b~r<7<3L)-c~UB)Pi7;TjO@eWKtX)5Y7p1
z5d4GFj-ept)i_9-f-gNyNEVB~i$;BFTz<2^c7zVPz1m6Xo9P~qR#fLkM42<OZizb3
zrT2B0lci~XiNvZM=`ZF_{Ti2cBx$?rLqqiv`jux4hX(P9dyb#9JEHb@?*T!0H~RWt
z_-pk*{`!?cj=$<s5BwD#wZ1*XT%s6JaQu>zgqB%!GBnPZ`7yqeFd|CVKqv58r!_R*
z+B4bI?G`E{&)+$^Pr(U%c-0Pi8|*KT{J@u<vYlowCS%-<Akt29vgAmz^h$P1a7dKJ
z?g7>EEO=H^DddEYx=Aa>9YK}gQTl9&%&#JLo8_nBdbIO&xY`J$%iQ+*i{lc2759Qj
z5SQr6=HP{&3d6mvxB~(}W(f&i3hML;8^ks=X)zsbi4YasE}G+<-Iq8EQIQ-CqBS_{
z_jcon-&YcEBAa|tHn|1Jo4j|kfCEU!BHD_iq;NlQZ4Ovp*5KnbkW-9h9(4Pc;iD`M
zAGcXbaW2K)+pX$L527>EpJ=}!s6O;BeGp?A;2#VAuG(fn%(xAJgQ0dnmLD>|*O8zR
zao(RQ4cT_4yy-u~o1Wg1WuWA+NB#^FSI8mtBmZF)b^)E`gd%S-b`D)qW|@TtI&)J*
ziFH{KPeT=37TAup*ID~c+Zk)WT)*5C#tZoDTq38$#}?B(A~$j{$I;;LXMRX$z{!C8
z>41ecQPteLexFgb<}Ru&zk+Jar8^x4_fw4;>~4(oRp1tk3Rppi5VHy(c0PhFOl6E?
z>O?p0VKu@@x2|;jf`M+1;|wsVyh`?@@=APDcMk^oJA_A=cQhf3i}p=UK?;9N_-kzw
zMuQ}?2MEwre+vri4nMrP92@?kVrN9fl5-<5ChObb=!H$~WSV{CIn7g%7D95F%~6M(
zOfo-aQakIqybcY}zqmO42C0msvu>5wA%vqFwRep<R_j21AxU`5yhLj{DC=1GRAC5e
zBtY7|Aj74J$&b@wlOD%D7aN(OHGMxxIeF;6@2AsBIntzM3D}_hv^reja&TgWi*_{E
zEP}iTT-|<pq)QL?)1Po&&hDq)T<O>M7F}vfP1e(Xw4Ju*Z>Qh<nKW=E+EMFDAwF$L
zGj0e6y!dOXRx=6_q#$j|quMyl>VbFybn}2HdY=hgz1N_#8(-!wrn*)aF@u7e9742Z
zRa=bNaK}VN5WLIz)K$#<5jbi0c*CjK?58QWqEN@GI9H+3858W8GHoA=Ca!<lDuNL<
z<lyvO_A7l4DDU24(^ee3^(Wi%zO6J}s-SML(WS}E>L@4lcggDCnQr(4_})hy^J~Fq
zt)1;)S!?Ov{AFRPfNXmHv@+4ltNLs%!%!f}=Q;h-d*`wC<M_-v8>0kniU<3j?v|!4
zyQ`p8RdiOmZ@^*NMqEmm1dKyc4mAWD-*EUbG4(g(kDDzo<hgEn=8RwJ>@g8b3kn=r
zF@sZI)e$dLe<#0?>*ZZq;h-fgaN8YpwnA^Xdb@<3FFs{;Xh*Y|S~{ACgRd4IT1J^-
zWub;s^B?nQ8%#5JMX>LXnA)|Mi;d>$>=Fj*%IsD3So>&xK@D}~oQy}|Ie=_j92^ID
z{_F>jbPpCeC*B;4|E5!i37&W*juS@N(M`b`tZgC|A)^BcT1(iu9DLdetNv*vgbtE&
z{CnBL1UYc)J;L*I4g>I)cv~eH0G<^i3<<#()<H8X>BOQn`P1#RJXq9{<v32EP!W!Z
zT|0Q-Ke{#~s_9TbWK$|^%?;*pVNfs$1#OR94$7r%a4283*2WZC71F<_J}oaPUm-eZ
z^%st6v5?6+P8bH|d!gI;zlikrvG%x|q4ZbO_na{yVBoA8F8|}dTKla2W75}9&{2IJ
z@b3U}2z*A<CXGlQ@TM8g0$&dB-mVpTdt8$^1mHy*io0rNr}VpMtHQ?TR5k^-<QiAB
zq8v^(s;e_9-CVVueg!!BD2tN^divqyA=jqVH?zx|g6dqG=l5&#JN?=$y^J=c4RLs$
z*}u)>sM%sflU-`}{w<HXmZKMqsEgpP{AzTi<H541TzY{D%`W3Qb$Kpq!V}v=geR7Q
zn)HkP8akO@SyDw`06%yKgBJ+&)})Ul)4`;zFX90EN8O3M4)52R2I0WcDv1YgW}8xs
zW_pii<t(b1`UR1qZ8L<G9;Su>PjQf$$?n5Q41UXW;+OeNmlsvu$0|!2G5RfHuF~Ua
zA085=T>x36Uw3JmCUvt+<)p5mT$FYebCUj=BXO|<mhWkm4Z+7wkEj947bT(+4Afb|
zyG64phZHxPH~g_5h3HXk8y}A0ZEYIgvHgMGO!ds;D2@i4KTek(okJ`<{8CX5izYr=
zJbaFRNn7BYB&6YOFy`J!hBkuJRKNn7wV$HTiBd3K=<b)abxxBgH|_ogwC_jO=kfdD
zDk?(;uYtgX2wX>SC#(+YSgZAQxS|n*N_>+NV)rBHef*5wIX+C?HT5+uM_v$iWK*hp
zD?)AK=*HkX`3*L!%X&75GH>!Ib=fj1aQe+~n{Y3!IUZgpP(!}IobQP5UqWZb_vOxM
ze1D0y3)?HcO%kjBOl)pt#=8UteBvaugu5~O>Pk)cccF%PT{-UR_!BgP7>;ORoYLrN
zEA*tcZeHDQ>d(|RAk$gGII?v0sCdf>&JZ%Suc&}yYEDgWnqD<2p4wKrlxFFRmQU>8
z^08E8Frr=Qa@OIl88&IViPBwzVlr`)R?C)T8~ewqeqcV7<IQ5^ZgU^%6tkM^(O?zE
zyMOvM8k-l||Ni38IjzjzA`d1<5G1y0=_)8AFT;}=MQpkC-`1zv`x8}FNFHMhLc0e5
z2Srg6v5vD0qDn~52*x3r_11P9gK(yVqx+BHD79sX17Em3Xzg5tXU2tp%@J+K9kzhO
zZTVA8&_aV-JZ#DJ*@A4zm)M%MeHReuZ~+^=ME(cEiN5!VXe(YvQT+J~ag2rC@9ek3
zktUKF<pmUQ<~yNw0WiJ1B@d?GiJ^s}0vA*HW%~}y_cu|ov<zt)P=kyv?H&3xc_ho(
zHQN}RmM!^p<>h#5Z@-GiiP~}%g<MV#jln+I>bMO9j3aK_M<YsnQp5upKDg4_ht?tv
zd~5$673v-<vhZPpiU*H5Etb}k9uo-ZQtZ;r7e(8q=V<c`ddO?OohrNQf82Q`ashQ_
zOOt-56-P#bb!MLRtK*zjbTlc?-n0ze<$f(HYz_!e&;u+OacXon<BuuFdTLCw*HcsK
z5{J7#dMp7&hBt_n?9~)G)xnXd`7|+qq{UX=5%QD0Ey0?Hh*H&Tk3kZ6&D04;qRkLD
zzlL&+Dz~J!HTa>G3m7s_EIGx;2y=+y8j%wtU7n%|n<$<b>~Z9{#Mr;_!6iZF8`iCK
zC1=u{+Cr;aFP+E{A#AcJW(yq`6)MA$Mxg_wX(2>ca2Kn{Y7>T08AF92dRtiPy{hfz
zW?C75Ogk$4fb>17pnIwv7ONc=s~r}r4U68~Qh%u3#&x%E#Tlj;{Rx>JB38O0`kxc2
z7*SeW&rVChy--Ow{aqNgBaKevuNx0ejB1so%cw;R8oRo_K=hj{Zyl6SlySNlNM9-x
zsNa8osN`@0(|Q6dcV2e(105h0-w|bwbH~oc$1(aWn?E*3bB3l)(4_Ym^`;0;*Sap-
ztn0&s2`1LUNL1pmF3^640gx~NiWxYdxuZnAWy~VOW~q`TNecco@j%`HJ+-50i3_)*
z$Ob22&;;wmsM=adcK6g)s$9k)1x@pe$3fAK%rl0+W**9Xqs3d(<ZVorODu8jacGL0
z*^gR+8+fhSKa3vO*Z$60XHRPhUU-H?ceyzE7m7An(Q_$kpqPVQ4u5X_^2qH*+$~r+
zw*d_+qhl|vNf!!6_uyjJTuX*|v$pV47P5{jNb#HU?hoEU4hFy8;BGLG1@f)6z|&O9
zHACH$8JsxKDo;}@mlYMp+H3i8cBbAy?skOWoXkj6v{gmh|71N6N}L<f)|6PgZdQWt
zs+Fd=G_55haK&S`Xwb#|!SI(I{dt0cHVuO0&v|+GJj2RV(hV!_WZBx<cCMv=p?^B<
z%&_#s)Q)hgJDnYGL5Yr^9Kr(^Ey3)kclGh4(kv_5+ha|$t721c2_}+9J#*<J%Hdb7
z%rmY`G_E{kE<E25Ig1|Xe72STA*FMO1Tky0Ky;n+*L+y{&+=jSJ*cF>G%dl`T^FYE
zh_F0FrOxJ`DB(S^_V0%Nm{?2YUifn2>nN$esxSqL2c&z{i{?&A&ZFh80Zvm86FBvi
z42pFk1mNHKR2BhE!N1l-2*A+Id5k<FZ(mGZ6x)V$kz#r+#X`F7(wu*qIZqrBsim)@
zIJsH1^z8I)j~YrG3_g_yz_1xY4=151_(m2648~2t?_J*22LG9=i*vwc!$P198u;1=
z!Z(Uy*)bosdw*^D{eAeyeq%nJJlec`V4IsL7W(@*(KmX6?{X$Z8M*U^*%xd+a2I3_
zn3GGPpA|NQ8)#>`KXfMOeNB`ZMkG(np~N4p#C$7JU!)=r*n|o7OjtQ%a(I~RiWIAe
z@2CZsUvMzHnMr?I0B89Rt^b+q%xdhn{o$X=`u$}16_-+b*I)Td8!sD#Yo7%0GbT)*
z$^4Wv2<Fbg^-E>ckIkpAj{q+_w>ObbCifrkV`vJtI?!>Q*gJMjiXLDOE5=-zwc)`Y
zX0I^zU@jSu^baYt=z=MULsYW8U&${-B{_T~%7N8^R4$MfR!*OZh3FhdS~-#lQMGe*
zj-EM1^^NR!gr?oLB>FxW`c8I&{VPar3f57aQDkl*<zh?uU6^w9ye`q5rTxUEnL9Fx
zqb%`868)Aj1X|hjfep-Fh9LV*L+piNoqZiMe%lgfhKY(wN6B|Au`W#fyGz_@iIrjE
zpIu^sb$M8rxWXkCTjJ0#QC_p4>Htf8XO)dBeG`f3$Pcr`En(tiuKH(4OpgJ)JbPMy
zdU_Pb)SsS0e}U4XQ?ciNgbitc{U*#`Fhu!VJ~98!YUTfa_x#YF7i*WTMMm=-P=IWD
z5J^)ol_(R0rgJpuLdV_vE4SxB*MEbc{MrdraJIdZ?uyJ}EjephOK@~Hd9GhOHd{KD
zP3Glw(Vc5#=bcd_7wu*c1SWs#gwWbW7Y0}I`@}qQ_CU*ztYP%!@^8-kC_jH}w!Y)#
z$?Gz==H=H`=In0vIJO(%KqH-mrGaT0#K1Jh8*Bdpa}I2I4IfF0&i5vr<nF_T`u5Q}
zuO&?%GC`_vi;>V?WuGv!So_iT$=g+%nSug;aRnm4P`@?qHFHU+982e3v1@-y8Mx=6
z9-cqtxP+aF8cTJ@OWi^HRted@WL#?{@raZv>)L3qZoP_4wJz-Q4n6@tFHDoOj@?Q+
zFP=YRQCLE$vhEprqaiOo%5Q!Kw-CwS{^SaO$!4zxFk|f>bLMHlLee~(!`f!zq28nT
z#Lt+arI>U((30NwQxO8zm$6DL<%CP(KP(Z8$^^fz!fzf$gcq-A48uHvY=M0|<B0P>
zs+InISh}_n@SB)Ogp;vxUIpNZto1FyW8V}h%dh#mzq;XvM>v1-D7E!1EeUXP<tT5-
zR_B&2K!Sfe*~a6g9du#5YVEB7x?ZBAaA7St@vF8#yt=hs-6l0-E_>#jJAgRqwutIQ
zv~^o@w2@j;4zs=#EVYDc&#4^9&c&y~Eki6!oBW#5i0t0X(M%sPtNa?H3VU7v)K4$-
zCvy%f*Ey%|nMm4VKXc1(IQ+@XDM3lpX!1V4Zj--wG_vUaeD&0h6kU1KM`wQM^}sh(
zT*}noC6qjFRejnTBOHdNvmtEo(I`9CK9_V;#1W|oAc2+`TXQ*P2-J>dqknH^sW+3+
zXJLd;vR*s!xV&~=yabuExy1VPYDUF6<g(qpU>SPZBYuro$ALskEAPM~lymh$l)1_4
zu@jG9x0VA>-6je`kvj9V1YQ5sA#0Pz5xKc{Mq{u{zn5(CCRc`z;`a6&bhMTG2@8x+
z(qE#p7UxT-c#b@C(e^q#9r&c7*zZ9=<=P?g2Fy_!QN`G=!x9&^$dXH6huCE^j=Rpj
z2EsE^Jk}J?Z3zCuTLi2GC>}DK84up(H?2YJ>HXLk(0@6{PwB1AbQx>c^;+&qp=+1I
zYdG2@MV2&dp*@TG;*j>veG>Pc(X^7AhjM^v2~uHCwUy}&RN|Nc^o(m$@I3}4j4FHp
zPC^zmFN|f`*2OG@V?W@Rz_G-}&JwSsFc^t0c#Ywwv~8PpY%RXn;DgI}lSik&FMCbC
z;DU-1RQ`lsr(4t%cX<8+n@+k^tu}*B|FVj7H5DPRw61Y>mkJQ7m8ck|-kf1`7Y*5S
zP_)ZMuN9`M0Z(n!IoQASKNyE`Ap7S|gDk{S`Uw!RyZ$HZUzzwSa5n|V>I~#h9W@hW
zB)973{}r&pjcK>NpmGoU!x+-s#`?>5okJ1Fk=Y+PN0@beuMLd9YUkI{2*}JjSE9Ju
ztbi<xep9s0Im!GZwPd&iJ|=O|@qBaYyq|9&df8Qq&}ZihVeHGy8}tyil6i!}oUf*;
z@RH$0$v?r3HT#vYNBBo{HRU}g3n~VKxF4_jjpA7>6`V^=SiSiC?P37+aM#3fMy!cX
zL!rHmP26^A4GuWRQGsF^?c-08`@A`&hwr%=J4FWz#}DSZl5SU$a|r9&99Lr<(h9?P
zX(Rt7UFWMSDqpgRt<yvAXeM;7LUHjk8v!wP&GR5G)B-Q9Xbq0oCi>b$MHr3h)>n9J
zTs)Gt2#0}K`x9<ScyV-B6d~jtmy)*1_e6Gckn2y|8p#&$n%v!Rhs2IQxKb-BYzoqg
z`5B^DlB6c*J&1CCL3&Ou=lU?`NtZK8IrRg1<ip<zQN(kJqtbRut4_8I0WEQ}r&<P<
z0((W>TUzQZEwQD=tn^HFYMZ((GA(Fw>MKY#wN8vF@+OQ7hOxpJOuEg1GJw-wO3VE?
z?fL<nwkbF|ZJd@iQ18@m@$VfWQghP_w{4Y~hk4#Q-@3sf%e(TM{N^oQe6;DlWWj2(
zOA}0^-J&2Q_m6)e<ZZP!-4>eMn)4(xnuxV;b^I^4wT5J#{xccf4>Ao}0x#T8Q<}%*
zBbhaO?CgtlCQSTCJSXfF4*=J?Hi)dBSJZ)Qg__W~o9a&W7x`LzE$Yv~ouwJZ;%K?Q
zlpwll-qg5T7klTod7#={vXy1m(aSX1uE=`L`fF#M+I8(qoI?s$DX0l40;5PXA&ZVn
zeOQ<{PEgA?F4REGFR0oPj9~8oIv7l-)=Pa@wCH(6&QGay(bajSgEY8OSyM}rou~a4
zIqsq--Ys%&!v9rATgFZ;s->H2aF}mu!td_vEA5bFK9_SqJi}OMtOA42)`s9uw>yck
zzHEM9lVT|Zk6H>Zt5_^W7sypeI*(N$*tal0*^vgvJJ_8!&$O+$9(@^Qxk4tygNw2)
zS>PbCjb0%7$Lk;SbV-@Ek5im5MPKO+ZmF~epUtId^&1U<(DUiYo*LVIe*r2)23l8i
z^<X@e)~(*{d~i0=ji1+bF$}Kavgjw7#RouF>>8a2Oi8xWKG0iApNKNht9vjCd{!Z8
zmtcs5ORT%sKVxh|a8#9xEmwEHUw1E|AL=J~ANaK;!Sx^tG5vn*WC+joWATssJfY-f
z$?+~Vz9>1A8<>S$<fPIEuG;3Hg*pr%th01%YtT*|M0t43?EASAM}HSv3KKJdd$H^|
zUt}13q2xQ<eK8(g9O`#_y$eO?7fBS{y(?~s=&m(L+$)*Ik*LKQ@M|V`b$8mJ??&MP
zD*d`Uxs(k2JEM`_N#_hva0fpD&l=SD!QqJBwBc+H#DBS^(FzMPxVyvJg8OdZzFFWb
zxf{4oc3-GTWlE4&3mpn!*HXoXkq2LR-ZU`pz}*hBc-?IrPOx3+MpDr+&NyzjZf~Sv
z(+`7^FY&!-9%%SJb2_hU+>+a3?Yi_o{&Lu=?%0Ex&<}fHm*Q*<ZPP&-xT6`Kdk)V2
z=>WXBLZc~^c~Q!n7AbGON26S^0EZC`Ogc&PIUEF%&Qj1YD=n=e-R727{|X1XOe#3n
z@31XVLR%#dmeo&~nfZ;OtSQ~YFk}?E7gPDzmS76`(OA;k*^4N4uaQ^!2b9E5eA>OJ
z#KtxTM^F+f%e>l3+MO<K?=bD|>=?KWWTlr)Q0a2Irm;KR7`A*)X{B}_S~OEbo@nMt
zmoD)C2;22~yO)5X;0N~zed*Z%<@jCmBX{s_x*g(!XHFev@;|EOzQo>~P=}_L7R3^%
z@FPKOURP=<ktF;3c>48{2&JOq{=8ugW}Vy;U0z)sJObRD5VZEqP@saF{=sW{XB2Z#
zzz?K;RIrJSYPvsp!c6R(fd3b=r~7lqHU;-h60*m5MI(c)HhzMRoVTXq0wf<ou={6>
z>imJe8``d898JMTNXDZ4mf{s3Kr)To;oT|%+8!MB6S4W>G#^6NGkF3ug^sD1&O!(B
zu}Vqr>j=V%hGkw)7iH(PXR<2>r*zILjALhmx7}#8?GfSm;U9-&ntp;p`TDU(t~e&b
z_t{gx_iR)mz3Nr!eBbVf&oY0N1o84qakd@4a6G3Nk-td2tuJLV0EXuvPA5GbH{g4q
z`o4YTtyp)zsk#XL=K5<Q{ic6;B`4+|4y+bUuuE5G83i2A_WE~v&0LqCaxEzqBO*WX
zZY9nEd-;h^D)CejWz9a-+;X?UG4qRzR*|Cz)GJXU_b|jE*iIF`h6WIS7CZM2uj4v~
zE~+}g8ZX9&LC08KFU*a@U#?RA#bhN9vHPfIvASItTZofC8$2`Q6wbOpXk@Cl8bb|%
zt-M?R66z3Q?L%pui7|)5#Np_FVaO~+Sl~rbq2xW$ZA5GA3~gP|<4_ufOE{N{wnT@M
z<@`HEmZiA~Nu!LBR$T-8n9i_xnJ!}vi($X0i&*<9Diy+!JTP6!Pm!5=j<p}fFSPDW
zI3)?P7dAzjn5}{rhYz`sJQ1bFIux0K`H<tD4JU+gI%Fe+zxAVmFp8=*5(Tc0wR1U2
z@0Mmp&g<ghl6)<K^K*?ar!4XM>v$dz8ox-)7YMXzoDvmE{2esQw)u6ns|df`$d*rz
zzV7enyL2`2pdZ)x9tXsN%x_$re_U3<X)JX<iCP>+V7MB|)zPkRn`$7{$I)(q0pZ+p
z&Wv>ws-HRd=E2Wb?9#A7rEWTJVp^Qf%!VJ>pe@!*q)%Fk+5h^DSz34zHfms2YO?mF
z%`SgBb~$vD$|(T&f2DWmQ>~BG023jotmIRnZvw|_Ktl4>KOBhUb79=s+2=*J(p=AP
zsZq@mJts$`^){p9=jxRCSN0T^TJm4mobg++315$p2dPn@qmTj-#wHf8_z)oQpwe{H
zD8T&t2Lpk57GO+Bla@$JsN*)JTt14E`Z}JLrDEQqYb^1W->G$HYcyPgomz=Dft=R-
zMy_kzp&}E<c*}3&Lx7)z<=r-t_r7HNnqci^HlZ%>F>$)IG(^m_=FXgraFJ^}ok_Fh
zCD6aT8|cHSqH$d|N`mwu>@*rWGtkBiWbr>}w|cMPi*B@vu%Kzaw0MOWLu=ceTDuNW
z_up=aN<U}^EoPZ$2$%uGKDfr@t!lN$Biv&W!1w(-2BLO`>N+-6!wERCS86Os{oW8m
zs(&#-FNiZhna*i{$f4NlYzG~gef))G${#^KyLDmmUqI}2bP2KbrjEZ$^yMz6+{$NX
z^B*i=iWT9$=izyB+nX4ve48bI29Iha56;vn94%5@8Iyim@(6eBzB2SWP=IYoTf^WP
zkfC&yE2g(|JW*`bs+AlDZge;u_n2VC+kNRCLacOr8SW9%$#nI4WLn-ak-Vw?6PHDO
z$J+1HaOCxn_-tO^oBQ<*eSqlwUFYeSSeGyzH(+VfgB~sx*+NMCBJ|UCZ$kbuN+*&7
zK&2<~4{UU~uxZOE=**S4KqaI`iQ)}hl*@y!^`(bWpvy5OC}*%J$NzzvYHGVBx6=IY
z4<v`<sLTbZo{7!@Xrglmnpnob3*6mnx2UF!X$WSQ*)s7uZlPT*pr=JOw)D7vQs@6b
zi?DOaA50oY_}|W66uWj4upp5SlfA^4a%tw32;b9T(#iG0-*enhWLn?mCKjVut{xhL
zZKqj>x;U`>39pAo&%Hm#mahi=zQMqI_b)o7U~fC%Tu6TkbM`g<uIczvD74wS?_92*
zag*B`gGo4~_#J|liCNR}03QXNkLiy_CGw+-)}Z;oC?NB&QA+uPq`ubRWRj0vLrq@w
z{<tc3<2H?~(^|W<XhiJVUy5iZN)j4*Elbz2CW}-x$(BaqB-&y>(hRx))@x!nY@re8
z#+qR#(zezb+&`R1)+kn<IUozjml3_JD{!C-Mjv30&9%afaI7L>motkAhx2us2wOeX
z?iuq;o(*nsuFZ;E3C{qK!%qnWWd+a76+D*CBj))xklblVZiU>H8gE<6dR(y+^f`W2
z)fXIko8cG=<IS)BL<a9UScq_%8)yKG_BaPLIOk2j+5uH3VTzP-18NM;cCmQHr%#K(
zdvJflO=r=to`Tv*6VIB5UWBmeh9rV;XhOdjm2G!r2|7Nk0%!Ip`I|18)KgA5B|BkO
zRpOdq;naRrpHZ@Wkv=V2**PTEq4+MwnPTmV_Z#xSefT6$KlFVOE027)V|Tp7CXwEs
z%+!)zxUWTb=k+KPs%fzR$<@t7dX%_il%++Px)i>9u0O+e{u<#LKPCli9}>GpPFgwH
zj&9Lxs!osd@-uYwL;5sBx?Amjr?xyz{g?h7?$<<R*`L*GvPv0q>tvPsTY;NXV2om^
zzW>BJjsP3B)24?zbTtJJU1XXl&6Ms8RQ3Hq!}@h$x?0<#WUg5Ic>><;71Q~g|9J>W
zg4)psyIsOAFZGhcQL`ml@GsUIOBnY)`W$v49#-J~rM9Eo-CaQY4k@g^E42O`&q*W9
z_W9yBv5u$o$(+o-*?3MmhxhbaWtoFz53cc?N>{q+dk8wtO`n3gW!BB>YHe-6pw$wL
ze1}}yQ(;o5DQh^R#yakLpGkg@e<Y9*f5=Eu1MdJ8-s((omxJw6bVP%b?_wlz(dY6X
zi5fgH^ABRrJ#So*oBhKz9XL_9UBPr{3@dJ-eM0`wYeX|S3P}HhMWlner0|EuQ(J=D
z>I{Kt0_}$9In7LZB_&gR@Yz+~^P1G<tJ6QDgyWkiD;nEMkVDc(Fny_yiEjTc7+&`K
zA^$_0C&b#{a5K;v9JOC=HD)8+_gLA(!?G))vOD(OL)qJv`)rn6_6LS#zmKXejjBGn
zr>f_W8*VH)e<|!iS8XGPxRA9^UCF@Lye+cBHm=xpyu9>{&gKWJR(@pGdhZ2qc{}Ze
z$7OW(@?ZYVoeD~VQ}a4pK(IsAVk-7JZlD~p7jb|p%!&L<*j<?q7b9Yuh@6GkaSNqD
zG!k<{)=<_W`>1LX(zN5Y{7kH+jpazG%5;q{w=SwlFGY~N1*#@)RL31EP+NiQ%Lo1d
z|H2o=N+OYwBJbelVlQ5fO;9!&-B`X(Rl=YN1RE4=*nC`Ze4G^tl~{z9%ob~{)Rc1^
z?p!XBv#o%fIH$Z(yzL%5ev=!f>`Sp5mol_R$%cKZn&19|`}L<&kjsW_17W!kS`#!k
z2Iv0EYJ-hact3p<C$3@hx+af%pZ8ADH<kKDkHo_^c>iQgBtgBRjm0(X6+KixE;)QD
zk6G4^tLwe;TE-ROcDWF%F<WR?DU5wXr;rh1RLFy8cyVnmR=U&;n00JFVMNEj;(V6$
zqJhI~gp<;=`Fgr}3Gq~7(p^}t1~ZYJ(>ke(RA;du56Ao(5k`j&RcZMs=j&@i{}u~o
zgq;0t;Zvu%qRyIsB84vemIc;GEYXM*1T1kuYS)m&blf#cEnu^*vIj$nZ3LdYHK{iX
z=}um?y!u8nIxQv+lRXI~f}F~4fJ?%Ij+8KiAofPig5l10#<X*ZHl$={epC;lIitRt
z8ZJ8=5(t06{2|`-t|Zn*(a2U8>%_X$6^s>62?rHNt^pJoa&mW3{VU5*7X97;<^E){
z(o~^REa1*3d59cqnu(4FS3L>nhY9iu9f1$mNT3agS;?m%AtZ0a*T&4B-AMZ1*9E`g
z?F&)Fh~R%NG{;RP@RU9kC@R+e7k$=OLsJI=XFQmT4`5GyHL22p`t_5tIiIndNnuV?
zQ;SW*r@jLX_TU=`r{F!>?}qfA+&ib?)TR}jIA2u86DwBh11Q2<ty-GO`)I@Nx*nN*
zvW75II#_<i2`?*t2s7y3n_U6avmIRD6{-R=x67YpIyaoqiVHb5D7_@qhpgTPhU%wq
z!DR3G=1pc6BNDN1V%!`P54Jz>5q6tO>^51$TG%nhO1un5qxWU}=Jmc}tF~Eg0}cU<
zpg4jceGq-=^-6y+PfXoKgQETV%FJ)2|KjxapsH1mjb}`tzj#bb=HcD#J<cCpM1ije
zv&M8i0HSpYy@$VkOQpc%Da)48UUP3xz1eFU8d_R|S2<CLu2&{5$e+gBe)mb!ILC6L
zX|%byy)B%Z*5Dj=KAV`<V8pjYY}>q+N^HVj%jf~Ok#iZ5qLaVTJ8{ktuiyTZ+EyOE
zr{vu2i7J@Y(k`v?m!e3(Mc`nj4eubmI2mhihSSEb{*Ope{@xa@PU7fxQcMy9df2w~
z2+bwDC>cETfMY$lBEXioB6-FbxW|d(>PIh`soCV`%bi7ydZmdsRB=}*^QIJ`lD`}U
z{MVVUYL7RXqS%d^ub%qKz3FWJ;@m|FY35_?w@5;%ucYNG?&001MqU&|4|&EIEdSXD
z1!L`3s+8t#437%7RHhe0EBNo|mETyq?g~<)vs~2ES^hmP@CUE$<<6emHTfoG-Kr*#
zhqQsdyIDV2pUuNLLE`4~E2qAvIZuxy_^m};*hG%;XBOKD#p`WqE4dEk`C?z<DTLx=
zzgByU)9d9HVO3v)=~3KsoN>yjl!a%ViRu8&$#|whJ{I!(*amOHXX(XrZO<^*kK_qy
zJ;P@DD~luO!f&)vBh++Azi=9{HI<?ugW>yR(l{j7V(wz9-twnyBMvXYc)7oZ<Z2|H
zRFFZ;uD)E~<`G1~5&EO)KG=u#cN;B-=aEi*I?c*z^_RRd?8`E&uV<{U<XdVL$1Sy5
znr-#D^v}a>Dm+g$2+=vH)~pNrk9C|#P6!!i9i30tVb?X_V(o{LnVus6cT?SLbjW3v
zU>CE8oBo2}8eVU!Q(pudyl9q8+ZZoH@ztSooiKwIcuKJ;{rk1-^`aEI)U}+s+ic6M
zgkm<mbQMszS1Nmh_bHLqYe%rZmSDykv>AEyp1{&bUrd$(hR)hfLp4x_UTM{dC>RG|
zA`4&V8klFx7}N1V`8|_(uU)8jF(@Q|y=0HOis}Z1)$XENSN6Z=?j2+j1Z`(&;!6w1
zcHikWK|N)O;})LX{U|x9orfllh+QqJ>3)X1lhzO8C8Ls)p5ssQ^WD89>HX~PqpjZ1
z#P)^Lx*P4gIPvDi=XL+g+So7gQfg-`apk<O?!&Lg((+9A{#NFI#Hx!=?f#~HAC&lQ
zYUjbpSGup`XXY2-{@(qlWe!SwZ{e8k#nxC+qLZU%^5O2A_?fw?`y@)(+sfUql3;7K
z`+TLH$7D@Oc3QP`3qQKosle%c<=O975ksHh7b*fB-hX|MsM*wI(~nOKc|;u&k<MM{
zdR(Y&_Dd<ft28lhVOeTd*}~7Ib{(2H<Kl*^b{S$O=}CapuHr?bQ@e&<GFiI4!!OPd
z6!hXZQR(v@M{3tWm+X_;wLgv;yGA6R>q5#<h5Zs+Q@dhG-Yy?ATaTyepE7$-yShT(
zr4bam@4&(;O&n|eFFHmIPE~{Tsa*#oCb<5GEF^uu#1OUlHe{eK4ow{EfK0w@ow`v0
z+9j`?mUx+9$!iFi74}5|gqmAP{MGLJqw9ZGUjL`5|2p;mnSTAB81_Hb_5b-?|Jm`V
z{}HDp*FG`^x&S}n*bNH{1dRac1dw|jyv-dv?VcFo*8r-*r4AvYpo(1p-+Irdh27u{
z=Xbxvn1u(32rC|e^-(Y!f50`b!bKS@4YQv>r?ItgH8$qi`s?hAq(2wvXV|}c&%vaZ
z3K=6zq|CV+!4C4|OFj0m+xbxbiqt#YFC}<oQRYxW)uV4J%e8?dnlUFs(sQZK?U4Bo
z>mO?H4XEmE&Q|URuf?BC)Nm@N=OMvDv9a0;`^NEwZ-m$ZBN-4FEgXhHk$-;B{Xi}U
zVo%?&c--~H?dy{6?U`9T8o!DyYx}YfDtLr?qI-n;gME{+>rX43TGPHRAyEI8*<h~;
zTwm%vL2&y&b`5;8`nBsD3MZnDcq{XB8*k)4W$~E<k2|#N-j6V$lAj;suXAji!rK_B
z4+|32OHb}x`jOB3lHQVSI`7qtdnxf*zv$+1mC5%~AD713@1)M6WNOK_!bJ)0;Er2d
z%=%bTJZ|xV<i^bTT|SS@NQJ|3CSH_!s?duUWroTKNh_wbd3Og+QOUP84@-)@?YKSl
z2CbmfZJM7pOX**@QA+&K(~45>6ndxeZfp1y<j4Cb@<em%y)@P_LlYthhQ~Ul@tt|a
z!4>N`CCV8?WMkz#srcqO|JOrN%-Ni_uz_T+YRsBN;I<jeho&t{KgnU4GUWA7CccP%
z?7eDT|J)~Y4D!;c<w$Wy`1|V=c(6ZldTQtKiP&k$x5ll8euCq*m|!OKX3H$IW8iue
zy(ACH92(Noj_RuF<i38j4n0Kqo_<2|Z3k#1ul8uQ!l7Hd=W!q_=2cvbaZER_e!8pL
zer-8*kMRmg8Y1PypdGcPg^4fq$dc`R8tgG!CkFeobRs><IU*buRhpzqCk;wI-DOa#
zJS=Ce{Pnoh_y+Co-4U;hEniu+?z$(uwUG9X2tJJmQ_a|-<k9|=v%$@NnFIA}KR<pp
z>zkJ%7+UgetMuG#Z|&-;b(!rn9M!k;H-Xc{=m;9#3R6g&nHoDR(cqG5z13XCJyZsv
zPjS!c8K%8(ja$cuY5rDAN60q4Uvi7jxLsB<K%87u8vErM^SugB0<OXB*bx5Q$3uk9
zAMoS8#4)b9XL4;N2tGe3aUlJjO@9FP*tj)IH+gF^f1!`ezw*~VPs#~DC;C$q7_8Fu
zajdUktiezz5Q=Q*>+SyfY*y<nArc*bHPJ<A3F*Q3d#l%@=}zvK`CMw}{)sAoA))Jt
zvNcC@w_Vn;p=_!<ix<6y3jp_Mh?pZFH*<&BITVijF!68b;@-mKlm1lc&K^sxE#&%z
za1~b#4r*LvEl+JPWd54U6F*>V(fY9SUy=8`KeLE%0ch#IQT1|W-w?jqadV26&h&@+
zMYmlwR$D$xe{peX@-2UH5r?L&<CpY;gvlfCElO_k&m2qFf4a9cu`ac?$Zs8Me$TxD
zie1FJk*V!0R<Ctr;=WlnOUB=rs_=)SSFKlXqu&^ZEcPF_DmjEVjoI%`tK9L&L5X2i
zFWb*$e;VYSRvE0fLB+}RRxkVaAa65?TJ}zS3Gbt`Us^O>lyC%*n9U=yisbew0A*7x
zW<k8Hj}mWi)k<(ajE&ag=>)9^$A6Cxu)=t6bicxWo!Yt2qWw^M_wwD{%s=zGOc-3j
zXXfAC?fUc2?nV0ZR`-1U+1fo@e_rfftv?&OpVgnIyYJASC%bRfpU1lI)t}#X|5AT`
zIgo!KeT^+lpfaeuw>o)Z)rR(!iw{dZ)wkox!o-2nsuU(at3QJhhjnwNGvU;)hD(v1
z+Id1^KN0pD-Hf4Nwzqz@d75Tk>bD+wzkZ|NbuT4Sy9)HqnFhafr~lyHBvq~RhmM<G
znT%!9h7Z5!Mt&x?OdR)I@?H1dg!nN_Nl!Qp*izBnk~Spx-TQVT86YS``y1yW>C)n(
zCI2!1;d|-vbJ$^z_m^ptOYQ7S6pdT8<cPZ-+<I<7+fDQF2dVIz3fhk6A4G<GyBef1
zTDQ8Z+2$L@$t3UVtOVgxkGcH-MG8tjJGl$K3U7L`Hw8Uq5s2e=sn<N*<A@$U?vp8j
zrgHob`us2T&)!4*8wS)@bx5&UdXr<kDOlv}5EHs0XTd1Z14Gkrk1d{^*$d#a>m$E@
zg*T<lYN+D_^J;uIET63y@!$Wy>%m^bgwZ=eH1xJ8*|-zl^Y+Bl2NlV8P(*q)aS6uS
zPx9ttuwN734IbMM+<YD40ze$#^ZEoD{F+idu0&YWzSna60{US54EA75X3R0+T8b#W
z7e@wRs_!-HmyJIf@9yQ*`u|IL@zeiS9{%azKh(j0pg*N;j{}J05gR~q2n!9)W}|oy
zvjc<S=wf4@-S@Zr`?(r#_WeOC|E}LCF19Ti_22U8(={Kx{}PpFHGM*P<NvxPCUK*#
zm%}u%&?#N+hBJZ(78uTc(R{cWnLg9a3G=as@pGAG4-*)Ue-Gs)W9>fSx$=rA4+FRO
z>_B#ygKW4zWfT=z=EB-^2iRPLD<2=>>=0v6bhE$H>hB#6N5o}>`pNWysyc7}Dco;=
z*`2<m_RG=B?&TwL$&&k&)2XpfgkK}~>@v}Q=%_0Pf1Kj~1^(=Ne{32W@n`(%v-lJ8
z&cPRcBJT|Gy@&c@i(&nJ{y)^0WEj;y@PDmu_rWdxLSn3w)DCp=GS30D5RId;Z#}%;
z_itfi029MKZlcwS0>W?rE3oH>*P3lVas1){+332Sq>eV5uC;uG`%SoBU{pGfH<#?w
zT#C@8c(Y97v=S$fi(PNvH(qhtW-(^q{-;|95@U^@BRCYYryxeGOZ=8gUg~C$aif0p
z623P|W!T}UJ)Ga8{jYkAUwt}_9|%Ydjcx0%I~5)6@yFOni;XU~AGC4-fBvYflGtvq
z?uR3yl*b>@-3#yD=dJgb=xA>DahPA4-Mg=PY)|!=LlNmX%b^8sm_KO#{=tNs{=-qO
zB72M%{n5U+dVX292WlVJBP8JUkiT_>J`kZtgvV=*(g#$n>pq=bI=C8XjYCEz1U$Fi
z^d24NBJIij;`=8iWjmoN;_Cu$K@oTx<Z-ijfuFKd@JcqKlgkp}+^_EHv1FZuLK5JQ
zw;31~00V-JyO-2&e{lF1+*hp|d?6xAgD>3J9}zitLwpqH<KqBaVhkbr2mLDJwqEbo
z$R+<W@^n5wE5ZDY5A?KcP|Jl3>Kp#Va(_kzclr=WPvis?-e2+#LNM3yo0z-3!BSd6
z%dj%RwUMHZ9R%S@zT&l3xFX5F+GS_ttsa>tdCx*`Yb47<_jq~4ml$(|(xXo`daN~y
ztWLYHqjWakC<XWe<`*1)Pi-p`v@dvn&bv%yI-%3Eb7aGJA+MMx?+I@)#$f_Dm5OcG
z5+}IV$2NR%Ia2lkeoY1DkC_#+ckrggTm-C{<(YpnO&dX&fI1(|BqzsLqW(*eFbmv`
zBOK|QipMt<Ej<V%_y>9uuC6ACR?g(tS#$tlqc9j0$-Y<+_Xi^(hK3PuFc?`&KYQK4
z#F#37Es>*)iZg#;eROPC`l-$$*%ZugH9N<unAqRDq&RcEnQR}?bZ55EQm>}?VH6Oc
z)r>3y_Xp%_gPjJ>4Iw|oK|Ur6xeE~`vi#qG|6>Gvjq5T3{?YJ!%S9Q6+wKHngL*HD
z$VVx2eFUxDr(D~Yxi*xyhxcE12Ss!0NZPG&Tgc_Y+By{KRV&4UfH&k1ZS8cB?Us>#
z&RgARiLxwB-ZreDXRsEf*~8)9UTPV?D0i^8IpPx4YWxB<{&FVGQVfp^_Mk>)a~{7l
zhT-*i&%5<NbTL90;b^dcpiiT}<zjdAB}$3#(ApA=Ki`>OYt6W}*@#Vm=hm~yKaRd2
za2gxo?eg9Ut_HtV8(1jbdaD#X2T5}BG7|c0=1qt1Jo+@{Tw)H3c_z@zADxemu>?Nb
zhY^b(zpv}5z1}<CP^}MMbE+-x7OzH_ORcO7=Cd5NF5JnUDLWUupqXgIXJTGgzGpx`
ze!|gs4GUBX!h{%V-a;j1Dte@XL+B*rQ?@vJL)x)5%1RyX*O&LymQbp|dl6_1DuMI@
zBNs>xdw_J2K<W)1$8{(|#P0aC$K(>AV}ZcQy*2_kab3X7r>^MmL)ZaOQVL4Eck+?a
zEC?p=lD2K6Wu{gRw|u*wm?;IOE{CSi0#iPcc0W(sd}sMtzin+2D-{!W=+ajpeTTO|
zzC=P%4ahN=z02_}D)n9jH4X-acI=0r-vA49T=jBr2f|3^@BPl(5xu$FlTUzcxtOou
zuke&-?KSVb?`Sr-=sABeE_%U#0<IXrNu|vgu5}dG+ss~kfuxPG9zqFf;bm0uo6ZOG
z$F!oKE%BQY4c-${*KX!MDELvu+QrPnMLo3&DTf(T_{P=P5#i|I4VGblJa1G=?qxX;
zzR4lHduP^%D=(kQXomBr@Y^(yvA1Do_vSPKp&35&<iPc9^h{{Um5GT$3r-RtPa|cV
zw|d210ISucID$M%KKM|6I}-L@%<uLvy6rbNuRGcu4A_}BrEkd2hf}U!PeYoJtNE**
zPtW!&ceBJfL?fAhy5{1dw=@@u3xbUu7`S$8)C&!l_6&`wnU#q%cSG&<tmFQuT}+BV
zWD{T~1hWR>=HMLECRKSkTJNs8Ja#dj%9&s0pLf`A)(G&kvVa4}G2ZI<{Ij@87j(Y~
z*!6L*c7pEUebi>`(WE3(1F!4;zz_uOZrwrCZ|p%{<4FUJZH#|L(YWW99-sQ4FmYPv
zjJ|Oj6C=jGv}FIz)4PiN!WwVlN2w=@#%;XvU2l$U&$h_{SzAe`-0S#%(EQTiDWaU3
zM1nLBl?bgs?h>ErzkBK(yQp_t^`<=e7j9?zCrRQ%f~jU*c6z5%>{}*&0z0)8Tz)Eh
z(fH3A{ewp<zU3{=h6G|40^|4d3?D$5qfuuA`pwbIX!bsPnYX4tO`g)9CWD_qU!GY^
zz8HMhz6F!Kc@QF60(sCwIsGVe5@-p&fy*x&;G2-a1^PXU-#KX9X1Gr5PMIf@$<{#Z
zVAXlZ$@h8ZCp6ua^xFSAKLVI8ceVtj_kQeHL1iQ>FD&SB(J{jWlMkZxf&At6#{;Py
z&QOmOiy8>JV0j$1JtnYz_p^`tW_p8X@aV>t@U!i4GUCCX_^Aam7$6ie>VVeP7Jr|H
z;Nd9UTO*XXy^r8SPf&}y47=~w<?JBto~75k)qB=SEMk89AZBnifSrOnbsW{C|2$NX
ztrcX4hy4tt7h7%Q_%nvLty5+JnQY3nBQ+k(Y}?h;R9+V^?ws8VnibbT!D5HTgCSOw
za;$q0yvNudTr%58v;KY!!Sna1<ry>EULYYJ^zc(y7-|B0tX)sID>io=4sG|n)yv7P
z!H=xkfA59Bntu;_Sr8SE1_wP5gMcug;NV0qi2R!Yv^~iR$|+C%!=+J$)}=zV^_G5(
zQb1F+A^j~x5x?dF*_|%{QDDI#>V=<1@Y8zD1%8}B)g^%bEc;-Hpw}tl4Hf7L51crN
z>R|whaN3kLl-qCuJ{~+AwU|DS-o58EEsf{+6VLa{yIh~=S%X+N&;YpUIG5h$a=#e-
zF8sgh4IZEgK_0c@Gv<cVF*e)zXbpHOL#K!I-ayioKkTgpNwH~5D+tO!`LD-Y?`;fD
ze--f8fQ!|9NO*h)gOM@z^sm^7vir@*h<bbcGAceFoc9XuF-^h!^fAjDHnZ(5gY*ad
zB&fkKJk0`J>HB8-C(c01y@uo&-mqD1|FBYv_z9i`+ps+%+aE?=mMZ$`Bf|Z!Jc0+-
zZh>h-pG@bQ=xmU*!9jEyC}|2d5wE~-ffFT1*nN>m@Pg%L*<o5VpS&pi?8<Za!_l&R
zt*Q*eBZn9E;PML>;E)r$cAPEVgJP+N?c)Ff$xtqK^;n9ec8-X3DDZ(lxvYEDjk3%P
zN*vt1#=Zt8_U(R*uPKQk-G5RFq!)|?-WlG|S#58U5)bMk@Y55(s&00)cfrbH*XpXN
z8oS5tp2SF-66-j|daA_c66<)0?(eO}p$ut>8&Td)fulW*c7s3Qx@K6xr}j!c>i$;}
zX3X-2rhiTowtt@tTiEL+UJwbMAP?+0EH>C}QoRF$BeQ>Mu_k;OqME-SVMiK*<tpoD
zc<7#ISZfVl;0R(~1V{QJC>8K90S?+C7xr>;fG47_llaMLXQ;Z9$JWdl#@>#0rRIjs
z9UL|1CiXBIjQD>x(orZT7&&kUo3`-5;MxTwA@m7F#$<25i;*;m#d?f{tChknL!N3w
z?nGP;ImnMy@P8dLYuXL@5{g@+>5J$aH?CN_-e|h`95diyxr<#(G$G-ltyfcZAmxc+
zGIY8>Y-VuK>$dnlN173dYqBES<iXbDezEpeCMb4og%L?{?ArZYi(vQemxSFv+!+BO
z0Xo*MtKv9$#o8ZL4Z8k~y1p$c#p|tSmhwo`??{+C(;J$(#-BAjZRbqNeoJL9Aj@wx
zA=A+H1`TDW`AV1Rrte||!I}QaGq}|DHKqTrsB3C6*G`TII3vb`&r``E5V3$s&>7=0
z(eNSJ3_T&RV{#?;f$j;X)Hc<%KMHI5t(800utt7F?v7O~lD&YoeM8LCi%i_VKaCOL
zuNW0~O+6}k7%Df8hd(yCGns_+qhQdLI4ZxhSy63f{#<MC(kR81{s!%Zt;I7BLfpN<
zwJfA`6X}|QokHsf>f|khFYz;42FFo2#N($(&ZCFYs3ThjvGzjOVz?B*UC2Yz0Zpi@
zYt_{+e%P<8r}=3UrVYP!Y;Ze5w(TdX@Lg57loAlbjBpG1ezrpE80rM`sW8jmZ!TQn
zO0q;ZX?sMS`p2vOI8xn2DlUtfwdA9+$vRAfy)hI<9?m9zGc3K0JtcUL$R@6lst|7v
zsO`UIldH8PXuDj=YqH6MDNWnW*7mE}<o#)zNvXEvwb^8`2{rN`b$L}b`48X^a#>=f
zzn@LM8RnqUKUJ4a+2r3sDEa4~*=fn!1J0A9S?g#=)+4MP9|kM>F6?1S;)J%TpDYl8
zf$Xm7<p0zz<jRE*q(2pv=K6^!20XraaiF=P(NC6hslbIn)O``VQf5yOm612xesdsS
z-!LDsNLMZ{FKUhZmz1>xBXEIDJsFQWvtC}3R9HLKn>q&lrYs?f_K6-MiA{Jj3Pd?T
z^IXRtR7{(&i)uz}!tXpu61zmLtP?w8x70l^H<Y>;mMwX{AlCj1GI6Hvbq>|3wffnI
zo~u;Z7$uV1mMwXqAlC6cGUj#Z7Jva#R}pv5ToE8>+Hm6Nm7*%wjfis6NwbKIT(RI9
z%=-9zLU`)&9D<Sh$t_&Z*xVF+9=@D6L|juCPny#h=P!<E?#`aSU`iN=JpDy-=5-k?
z?egDCPqv~Z>2E_ztUv;ITWAu$=^PvdM)<WCFt_{R(}^XB<~rV0vD#5;Inbw+;RM3g
z=K?JK<*F}M>+6Vw+(PR-^)%c%p;qD`tC5INIs%Dpkn3u80!`n-w>xjy`Dm2)G-6-#
z*0zJ$+e1DO{PO$o;b|pvXTn}L@;!HE+tFmlgEjoX2kM&NfMXwRSIHAw2l*v~{Ig1n
zv=d*u9YTK+4+S|!V42}GP|M}FX<OsY$3tG%pJwTR1zpbhg!2c-D;@lDkK#tu<s`4X
z`#O5=;05kTc-!gSdpZKY3oztru6seeJGehU&zxZ+kU}ab<hMathKD#Q0E+#q(OgU#
zybo~1mb&3`R%aH@{s+-dfCrfSl4X6#;eE-{z9iqpwCp`+Lk}#VXn*@uh=26K-qTeZ
zSPI+}m><nS_)bPJoRji&Y$7w;j<p$>^u3SK?&{I+X}ZSIQ#6vPC<xwu&&fdCH3*KR
zh`kCf!TOVsEc|S18*Od&-X;X;c1PVdX8bjN&X~z}IO)$R+n-iJbYc(%N5HS1+(z$3
zp0`JYD1`JB(1^aXH-aJ*<?}ZiFXvz6EAItO*mihPIA_st|I#bM9?8xQ;OFWDTemH!
zBoXAIm-BXM?J`3R-ivLO03Wn#CHz-%0xsJ6gc+>cMl7%OTsX}9a5sHX1TXwIA}vk~
z^9A{f#Bn-Kpib*`gvS2=U5B;a5No&d8?0eYg|AK{U~_XRSnD;cX>Wfze;w=@I^&Ls
zoA9GbUJqXiMm-neL2k0EfrI7r9<&a9^v(?DawOeq|Eudw&lP9L`ajA)sZ`j@C(vMo
z%^hY_^ogl$+=5YlNWH-*?Q%x5dGQcg{>ftLE}oXPK_uuz>1YNI1eu1Gw&~1IL-3tj
zBY;qya9>E)y2VT^LANxwXJPV#A=^sj%(;_uf3N_cn6*7n?=}%T=?wUj=hTjgn6qC_
z+!G$V>1W&9%<-+RQ>Of{`g!dD{S4lWO$<m3h4Jn3{)}Ze;wcl%G|6&G))~>4Yc8ao
z(ERtd-C+yqXUn6pa*#fb5&(Ik<64}ao~KOabJ2ODxfe;{3X&Rw1^Lz9U9W1%XQ}Ws
zxilUR&ZGb{>ep5>c00|T#7>T1-4af6*DdCo{<^JVtiuOI)IykXJo^AuUaji(=C8Jx
ze^JCn(Lx<Y;oez@YxcdJ3VOb^Dab_hDHgJ4`UFG?Mh4>j>?@A$0OfNIl=dVO>F^`1
zKu96HcSu=(>U39}{lDWTf!wsf&QjZgiQ6QK8ASxm*=C`s@chsaoI<J%$k9lwy+mZ3
zJ>1c7*jHMcsoDEz4t5+*ms8Ttvxa|(l8r&{cOux+zlq9&zL#xIH<Af+<fuW9#Iwtl
zmB9-X=x|_hlEdw(|9e6udPcVx&4ln@;ynxFWF4Ffux+o>elUslX3XT_uy61&E8_BV
ztW(Y~&B~q?&g2w+2x+T*IqW7zPDz{$k&nnakcUjS?=_iiLOo$4j*xZRy5%lm80B(X
zP|DUuJDF8+m-!zoeA!Ih-dE;NcjJd4{|FR-pAxuQIE9S6Z)5rxT$bU})#vz^w~gBw
zyXi&E>m}zi;4}Eyxm7<WT*Ll;k-tb1Ui-DAtmx{(D>cSHP|kAN_BQv_UO+~{iU*am
ziGPA6nzpaLhrT`1e&%_OfLpKjd<jGEQR^dfAi)*i>wWjWp4v9q9Og+M*3YmIYyUCn
zFtes}{Mz%q30)1cGVnh6pE3CkV?`mtp5tA90bzC-YftK4QuJTWT)(21`HSF|cxI7-
zJBv>7YPl}kS)?nNypEkS;fGKrP8olBTdeaN8qx5_RLJPDu6J^eMf@*FttuLKdE1q5
z+a+f-=1GT|U0dj4EB%lZcS&z4=}#_cv`gBgq;8Tv!G0)v@pX68spRfI^4IUWU;i%C
z0LQIbdW=8js%p=MYtM|uI#OixC}x~!D%5cE{z6Tmmr_k`aSm#X=dN&iDQlg{kQzg1
zpO9zIiM8KADn@0QnL?woYux{i>iO2QCkF%j%5}-(JD<N9giqlg;=t;GzFeldDav-^
zK<F{>G?QX^mw;{%*K1g!{{1h5CkgQ+euXCSdf5?tSBVF?#L_77Y9&g>8Mwa9ezP(4
z<)Vc4<Mq0^;Wt*kzlt6!l5b!2l>T~6l_(UFN49Uc^d!GY7Y#Ob-%ZOa*78sAGcClY
z`ZBBLb@@~AB~1R#WiC_Z^<m~ujeq$~)trpJmHKjFVj7O)??0i|6L^;wCJ)>3M0MgM
zZ4PTWa8+XO1)SRQ^w)uz)T#~3p24TSGChOefkH{qWi{b%mEBZLW0@80>tf#6sCdaT
zl@@LsG`)i6Be8|2`s|z`dd=D&*&Ukv>BI2{u2qz=>BId6WxCWOVR%$ua%5k!qAywQ
z1mk|<g?`K*#F4Tw-h{uy)92}!bq;gttce)IF%3PEXD<uo<>w_o_T&T)ziD_QJ9;K9
zp`kPsh)tq!^1q}C@1?fVZ-=(Kf}mO>WuJet@)NhVtiGG*>|0IX+0ue`ohAHiBoSOj
zhxB$D?FLIbCG5>EnE@mJvA*4LBOWa02mAw<qaBHJzzIiAHZq<+FaU>p+u^%giG49`
zi$&BzphLl%18$G@8F;?-<D8u@!WoS94$0$Ov*4P<%>(ImH~Fp%JPefY7%v+Y4%~WU
z(W`r1{%uQ2OjjA)c7r5|=`*?D?hgvS|18^IQ}AmN*`dw^4e{U}elT3I_B$caGh*$V
z_`|+^iDh3KW)q~~4$|3UoweXX(z$vCYZ^3XZZOd`JX49YUsrQ4Cnh2+`PN3QYeQyX
zMIpoQtNURrt;}cO#-rjbyYGo~=Cq@Oq6RXLkv7X3{iknmryIeDLmT}qwXBU{)|tu*
ziIe>m8{bzg|JPwY4vu?_*TLxyVRc>No8Ghj+#+C`!`<-2jB)QK56H~+XH}DOx>6>O
zdxe!<Tltw~gi=YZT$cPhKlbIG1l|Fa?2O}|W>&Z34#7ZwL|^{Y%BzS5UkG>erdB2%
zj$rdoAyme4T;To*g4*r`MkzaR+v$FkZ9dTZZI9>+yhc@QJ$G<_%H9urI#HV%SC}|?
z+*8Tpz0F*iZ(Bnn!F@#4;KbMc1a&#S+^=@@ZS9!-+n-p;jgG>C#DOM%>~t40LNUUP
zWMU=voldO|ZqxvpDz73a0pn|`jO@7i_EPS%IS$Jroe1wcN$RiC#G*x$xKXrlE;p$X
z-{78Tto>JzQq{V6x5OAl`)hmM1|94Lh(MPas`2RtPQE=nweygLQzI4oqLuzciS|c%
z4W*eEjNfu~>5|hWWsSf1Czw<&{vkoi0HjryLGk2Vj~n2C_71wFJhk(H#6A~~Fe{Iw
zLw_R2*yJ<bjN;5y*mn6|>CGrgUu;?EKa#)l8Y=Aivp1tGJ&WZ0^ICZR#NU#`7TU9r
z@o3}Ldt^RWqTE$V5!jBzY<Pk~Z;P+8f{EfmWG6({wu%3TvUh=xvO50%14apmZd6pP
zXroOPm0Ga2f}jn-1x2GvV!}mHTW=}$g1YOKAedcseL%5dYc1YyRMApvTS&b`K>|vZ
zTC7n}snYs94ccfcqP6mWf95=w4dVCr`oH?BY@RdcHfLteoS8XuZjK}$vc?}H8!wV?
z9hW^Lat1#@GQIa`<BNxQ;m;Z$_HxvC^9UN<PV0Y{sdM?zuDgKuP9A{39QHEOt-?PE
zPX&t+G%!h(H4P|sBDPgDj3VxexkIb2OP200gNYHvpg(m`eX+v?@HWTI|GZ=EGMyh|
zz`!)2L*>@DtP=zT7+@E`3vS1niiYOXV`TUv7%Nk7+rV}u?f+#uK$83Cx3gl)x~?g)
zr*Yp^cXaHM4DWSlUmRDwY=E}LmQCC}E4KLFWdn;mB0G`5ruqhQgX@3TRHtJ6;eWkB
zSNAk>_T>CbQ^N%Rx2N|oKZXaJ7z;j>P}cQWykGsW*m##BtJ3!s>lQ#FFB5U!(!XO|
zx!}OIH-S*(nbRSiTiU;_tW(1_7t>3+DlK0?Dt|8e(%2Cn&O8Osxubq(m3n!DhI>1>
zOah%U%|dpq=!4jAFiPBu!ihF<J|CQs?=?V9_CH$-a$73Kk{)5ihgbb3tacDk3hWXu
zkWG=l<VvelV;!gPQdH`?a(>S(*K5g~@Hz#{lPE8Hy}a__WZ_TUaHmaUF+F>eE4-nE
z+U{!n%DpZZ`ou*q?lz8?RFT`{wJi3o>R)V`H}bOKxi`HuPL&XEB!z%9{a4>`#Mro)
z+c?60rn!2)6PWk4?b;u4c}rJFBVTH*RG>n-zrO%25j30y{@}9Xr8T5GTYZeWovke!
zaH$<;CB#aUTY~A<D=WA{e3Lf&)5?oe7b?NW*8tf(rW!+ig#j-lJuPp9303WycH;tX
z_hRD{LfJ2I(0S=4D!QJf^%|e>>Q<xqjT}9Q*H(mAblxVF)R8vn3Gakzd<fq0RmHkn
zv2&~1E!M?qZ;~ZRx>kQpy;Y;QPqoq%R5LO*uCE%&<aQ5UQlGW9a^KR5{n^_MefB+A
z@9XM+d=<d^j+k7Ys|*eTbi@?0&dB2!0{)9^^WF)=dBh&LK298-?r7-D*FhfFTU#nl
zhF*dz5!}f+OIh~r^G{+_HSQf%#8z|;q-5!RaCF;B{^L*jz_#ePux^paWH)c15+i!O
zi{)QU<rS8gy5S#;5Avo>tP+ni_p+`-y!1*WO|jgYJGvJ^<X-ym){gR;V)}89mmTUJ
zA8~y7%*py$$scNW!1Y8NG_DjbKho-mxA1_Mk9a<HgYpoK9r0qz!*d5HlS-L)+#a8u
zP%Pi0^`GS<UYx;AGr}NO7W<Ec8ftY@{ilvIgW1qMZ@+m{s<jgTvL(7zOL?Jbg|=|N
z<EKg=(I*y_Sn>(nF-+wbr~ul~yA~Q1dd}9&(q5eWMFANeB4BUaWO5sPN}op_pAV4a
zt@xb~?$P|$qR;W(dws)G9cTd*Jp)705RGX(acgEtL6S#N+oeFlC=C+3JK7?+!AkI+
zhTFT?iz>;BEWy((^%uXstgn!uNGf$px&tDGaGCV{_TlM{RNm}Gl-Cn{P;6X-!$Zjl
z)9uU}2v9N58US5{>{HHaHnxwfC0Dc_!kX36QN{~({1O`96Us-I7whI1dGxF^y1$@6
z!Bl>Yt;gCCneyEGUV1(Yo}RDo3OQiyxVhW7)`fYA1L~_8Ot3(8>J}7x1xoQbY!$Cq
zThRXa7xldY>I5qyir_11g?f-%Rq=VVA$e&ncV2Es(E-o?@z)Og6~6AojP_)?M>3#3
zT}Lyn?6)=2+((|hh&PqTe`v0^cG!Kw2bGBTW${oNW`x95Th+CsShwEm+ZBi~b}MGo
z`#E%?1F~)f-1#SngIfWYTa7hvL-1Yu>Bic1mxK)ihc7n*3SU-H9GoqfwBC!5@JQd~
zU)sjQ!Fw{*jAP<!Wi-`3|AeM>q&2y~>!;kI_xZP3OL?V{1bsB$k+w_z%x5==j+%kq
z34?iVy;!$8=nwU3VHrmHKJI@5?N4#_-&7IPI=(9Su6~jm43VN-sb4$~Re0ld^P7LF
zH$T%WyR(k*;r)QtRb+suo`Cwh^`hZ(#}D>@iEoy%>+GC+HMw6hh<JW>fT;u7Pek&c
zCW@M0(J2zkp4+6zM(l3aT@{}UQQ0#7W&G{ss!(piQ!8I}qS?TI8Y`L_GQ}<8Sq_Ca
zbgT2BPD$IoF;-_T<@Z9i@K^(!s!#{ald?=pQS<xJn;{>=m_L`5(Hh9=L&OEA9a*RA
z{lCwQfJoG3mgeJVMsY*;@UN`Rf8k#mILS3oxK|A*Ri@J&oR!vR6P@7yg0{}!<~pvV
zZqCKm^Ctlk7|TDVIOAWDbmfMe9VvY^K>*YD?<Z)0K?l9j2f!iokx{(CKPIkh8s&NO
z%;(t6fe`g+L%m|x{2zpMSBRPF@KbDJtU8S9&^f{Xv<2)pMOJ8XMy=9RPOk8prb~zX
z<15q>W=Mti5}*!s&YFF<O<*ZsnNH-X!1_o>5PzaTM^@-{6fksIn{6qsirWi*<BH@6
z2pToe5EptpdpX@0{3!|iJi+9Ii2qXB<R6(7X=C8KO!8f~GEHZ{-U9%#)K8h*z*u=7
zCxIUdPJzFVcDiomhZ(X@=i|2e_k`+VN4=@?u_Mf%0c~rnczaK)_P8JOGz!}XT0nT6
z$4<&_L5{qOSCTKF4!N~`vi+ic=T+HvWOS))C{_6Ve)Oo8HfO)1Zko{5=mTYoL(l8}
zjQ@96a3*AsX`0YHl!{%?Z7UD#yj6~03y$uV-NP=s6CeN&R~4~|pjN}-ugjoh$sd9~
zbQ+#-<8o*w0r<ziBe4_N%LbFPfb&dCWqol)kLexus+-<cQgo!dC%V~jTGk*)5~+3h
zf1pw$ZO89#5e?m$=5sX5CozO$*KVG#KNjm?zO8>k_KD(4{yNNAx*3<s&k~1o6Yer{
zL~FYT$J`^qbj5YJN=}w+Hy4^dpFLXaP|^G^+Rpf&^0b9p>9f6Ksz2pZW}<g-Wt0E6
zxS(Ihn4u^qdJmCNdMyLF_<*%ypm*X>yMEfIW6Y4<R308oy^E__U+i7HxT@<7Z%mb?
z2C3@GJ9}tj1w!lJ^vwICaR&!vGIv|o#G7RN=J@+fbgY?lUFSx;#YTL5Tz*K;5q~o(
zNaarj?^H%#EHisNi$TAAex`maBCzb>9{qOzB*X;IA-L*NG=skU2JU#F#>TfYfs=Mb
zH@eB<;+WIjOCM*DZJqqbzv>^*2K(_wph9|so|Jlp?T9rW>SYF@il1i6eD*N$Z-%6y
zW6F8|B<dq~jHNhw*TNjIx9E155^_~jzYC^%SC^DC<@Np%Q4OWhdHK3$yIxj%&}vl2
z@E_6h0E<t0vH1WnlJPhHIHG|8-rg+fUvuSsKP>JYttXf}47djW#Rv|4%}${a#24%z
zWVFCsiWiL>%G0r@MisNWQbiUfZl1XL-hC2?#btI;1j4=2v4gnq<nluG*K=!^I3)ZB
z5rZgzuXkY2#%y}5SY$Cn<9(_pFe9<$zOVrUmwrRj(dZx^E@)2lQ&AV$#esaBrdbcC
zde_sjJVRZ!70MpP8T?z`q#<O{`kHXqDZJO$vpnQLeC|gf!g%t>vXQ^xoyc9N+=pFn
z3|kjNJNrU-Uj*rq?%(&>>@mkcEH&Bh6xy#EQC!(J<mV8|H4LV0BZHnWY*q7czGRA>
z%;nebF&BMiE@lMdK3=>17@4kU`A^%qKo(c}dVOu!s`|EffNY)~*S=7-^)0Ghx<6Qc
zuT8}lm?VeATt841`iPVP{e-Fs{yk*sr)E*_mDV8>n*7Ck?0_QO&GQ9uya=Mro=<P*
z0cw6DRyJk);fL)|b|#x$aas62W%13THj`*Mi1i#(<<%TdVEI&<R43`~uE)2b&yHc6
zC)E2-WZfuq>2hD*_M#tjlD{6xNCs6GSHuHJ#{UKXr|l0zWY5JS!Ep;o#>rwK&(^JA
zC0bYZ)~T_6h&v+RpfgJNc4XH<<Wu|;_*}Y(|6mvJAAK8XPHxroh8nXJY#32nKJzTE
zH@b^A>N;Y|mF;f8rO%VIXXvd|Ii<4o*k0)DscX6rV?1<5`rg)MCwV(Co7{wnX#J!B
z{bX|_b_&M|iaoT6?5wgxsQs(%^3G6#v_VdOHt;}9w%_Jjsfy1EoXgs|AUSq><I2@%
znm(07HtKVT`pnIl2P@QddZRO$Y5n}^pIFDbV45oY7$RbdOE)rAo3#JT-%NUS-M@Jp
z&vO_02q2lz$dbl~2Zvf=MKs%YL1NVNV0#X2^SE!Jj4qQFG|s>@z`vD%4GR82;pTDG
z6*w7sf|<KB#9ejpbZOxwxu~0}fZHfr=f$QX*@<4_=!Trz;y>_+%u;KMTN?Ze_?c<$
z&+1HU`<po+uvV@0=daiFoywES>!I2n8X+sv;o@a1AFFo;%UBg0siElS;NXzx=a69k
z=;ukn9?{Q1K}GblI{2T?kE%A@UiTAWHS!7kd=nrjIkJTGuum>)T_UZ&ER~n;p1MI6
z5$^4umW-39#Nnld+&}WhNu?;cHzn>fuRj+Uq7uLI!ro;a;|8ix%JJ%&clX~9j~($_
z^)&NH&wRq(sKvCruvhkeZyZL%Z4^Rp9EwG%pomGJx@IRX_lVuM)z?CKSc63>yaadc
z^xhf)GfA9dp}b?i5<G$*79hVO2kWp>y{qI|YDIUM?##>W=@>R?pmy}Twd(8`C2vd5
zvt}g-6Mc$PUXJ`{yqLtKy|Kd2j{f7+bqT@uWLP*xd7q6bGRiOo<k+mion&xiL;64S
z{f#{f;C<As8Y@Xf88!Ap%H14(d6|3u20eC{S=^CgGhyQ)HpE?4jP`FV#XfZ|=ge4^
zy;ug0O*6j_iNcjS7$S$g?7Yv=4@N5JWVh_zm-4VBHwa$TVsF_gb@iD*N}n66W$5cK
zUj*g3@s&I(tcJR4rB*lk5=HlWX+OM39j&h2oe{aTZrLk!^*;@TYH~;aLYj2w{2IG?
zJi&(s+60A&lLv;j4$$hIK_-e^pWsTcT>LLf=#7l4TpCwN=mY(;GdNjGB45(`^qacI
zPQ~E@{`+C|K3t0NV4(ba`8(L(;JK>tSHWMs6?O{^=;f4{shoVxd}VYTmcRQe$%;I(
z0t=knR9qkR#>=i>Wf2|tjZ%3%J%Z;bx0*Ul{wBI%Huh|z+))3#=yAEBer<*1I<Z2o
zPf=yp+%F<(8*76-HJ<R#E^&k`x=H1m-GInf|0Cm*U?LxQw%V|~vsFC~0$d+_*S<UK
z|NEg3Cbv8|nC~U}XGHIwE!Gg4*~Pz4GHL7(e}+{XYTxGBx1oNseS<H^rn=|$6I!03
zhqw0d#!BosIv#V8ZQSe#q_NnRm=W3l`XD9a>moH6BT1a2@a^y4%KoXlTkdL9hT8i#
z52!@niPN%Ksy5E>VQw~WoK38WAoz^``+wO^hk(+=8ZbBD?~lG!>zgb_8UKdp+hBcD
zu5#=h(KlV--Nm(cUi1z6irTA>zMYh`cWm@c2-Th7HGevRCJzojUs?l$9%d{!b3gP(
z_z!M{G0JZplkq2L*_T(65b>%2VtjicD`awgM}IE}Q*f7#YVxm;F4Q7RZzM1*5<?Qh
zg=B0ie@!3avEcPyx~kaNS*%+t+#&?{yMx7GIa)f=F3LGPrEZ*|eLmgUkzUyk#|q?l
zot_}{a-B%b!c2aK%2G#qqpF6xq?SrAS9#-zuV1_WFB+(s-HWHC(Gb^rHJOaR#{r?{
zw-(nL1{Yc~;h6R_{>K$g>9d3c|KV`utfUtfKOVM@Z9qQ12LGP%yhgzz)Kji7VCg+d
zoWGTZ>@sd&xiJ1~*Xlmkh;8Fb6+60~9Pv4E`}&jIaaZXe`+nSLUD)W3VWSrIx-UkS
z2Y!h<r?)U)_+G57u>m0%^i+BCVv47gwQZ6@K@@#@y+39x%Z2MO=d&`PW4_WoR_96o
zr-hs9H~0tqgx6i_Oyy91t*NBPP}&r5yWSfcE6c1!_#6N@XB7mY&8i@t)_vRcdRnG&
zxmVj?vVs#1FE^snr*1e~Kc}u`ZU=azi3<1sL05aZwZ*C3_RP{xK}^kvmAN2XHikB>
zGKt4R=}zTug$xKNag^cJZR{AWQ*l{n4DT2XRk$&qJP2>Rr#$Ytor9aGC3?n2+#5u1
zDSpL<zd^voi_2R-@0GgdRAAU&)X9(d$xQk9gg)lF-Q$CWIcghQowB!LP!~mUuDBT6
zN)^XcwE0&w$;K-1SkxKDMHxO1qYU<+dBAL?1yhvPneKwiM>35}!=LWP8}JgxpK=v*
zgZ<bkRd|yhfxH+Xx-S#6_m=tnPh@{^le$W;)j&2gkPM{Ez;M>*);9T%pBa<INo*yu
zhOXsJVF+J8xmU4LL~;1b#?rwt+K1R;{yWj{I?u@W_*7vEAI&Q2rI)jXkIdj`ynsIK
zl)8pZsO$0b=6U<sad{%odQ{^Lo#2m*JI+sM;JhOImPnP(enW`4Sq<zcAv71dgic%t
z<bL8vk;=adZ)wekCu?pzw=>^A<50GAS1QCQWaKif>nvs}ixvKnON4hCE!GZU`vo8V
z0s5qz7RAv+dDGRgEf$WDGG}Y?r1Yh3V0UALox<b_e%iw4caKS+S|s2`Ns5}`y)M~-
zwC&1yF{VaUUQq2ZHH7k~{y>jY*W-*N`$tWGf9vnV8P}xp-w5dltzUUE{9=>j_kKF5
zHTp1Skw}J<D~l)Vt?E7<V+Wi3F$!E|-EWlZ<rXmNam44)JGOstt^R6UyK`gzRQ@yu
z;in$_B(%Lv*O)Zq44oY6wW>LOiPtlJClfNJ&J?Xcc`*L-brXLfJ$ZnWoC2h*B{b`@
z5$<6XX?P^xri^Bg7k7T5{U9<<zx1iRt+;-6fXMv&ehWomYI@GxDBNCHOHL{=$jkU;
zAb{Xz{`DF+@`O@w5kC#**EZ6IH=2is%3D7vBYy#ZrfwLakFfk2f|0mtgGqJJ$cvcr
z(TF>Q1ztJ<<komcUQ>ioo5&2A>*RrA{@Kv=k}6zLjZi%jzL22$E!DW5j5%mRMZG5I
zUw3-QE4fNH<>sMGA+U@uSYaFb2m3KX#OYghK3mJvXeM6aqu_4q8?|)ch_T$?eqYl?
z1d{%ax3s1sSD40SIE_*_T%<4&>|c1|yZY9S_z)+*zTkQ)zsbFA`%idu#PJomx49iN
z^7zW!>sU*Jdkleyn{4gGiCPnesHd3f`cG)^k3C8&Q-$uG>}tB5+^ikWA9^k(`$oz8
zV(sz4@vyG{jUoRtf6braqt@XZZ6&{LH5+dKq~yRkgkFce+>!PvW)Iz@e}ZE~Z!q$$
zZJMO<+L441fKRBH$6UNILq#CExXuUBt2RFjh<Zk3%+QQ~Cr4`SJ^;M}Mwi~YfV2HB
z{70?6EvKGT*5D(4pglBhf`A~I!ffzF2~3mmXXv>c<!`GDrtx`RIPc(d)`1oJFM?5P
z+FTy3keVL%CuokX`6px}Qq4n!_>1hZ>_6I^i2Lr(&Y*OWsr;P`+U^ZN8b6v6jkvIn
zR$AgV*C*_hEs|li?Tld7V^DVcaq8NJ<_)owrSD&^(rl`N*XdLH<J4~N;_9)*i>rgd
z;s7ihqd-8bPm+pWmtYKmls1qvo{VlCjDyW-@{vJ~)rclKngPRPU!&5ncK?{g+8|h2
z22$b<Z|BR>AC_V_&s7S;VK?-SyFqB+{+hleXP)3X(Ma$Z*fP;p_&Ob%Yah*%BgYUY
z$(Ozf9}p^=Sx0@h7H=w5kC=b$Z4lmrzqW#4C12~Cns3$$+xla8R>%Kk4om+<WAWnu
zomfpvIKeLF*oW8drtRoYeb;Ifjj{?4P%r4ziq)+xj>p|PKtxuBe~wjN`a`;IdqVyH
zoYo|Kj;DVi#{U`q6Lq|hx?iHtb6_nJI{E^-r{8B27*MjKebBU)Gx{d~oJk=eWK&OT
zUD(^hd_{n)GLX?RNdMBTMU=l}<p)INxhFAT|JlCn5`WWiZCc9T^yl7XxQ5ut)4sno
z(6BAwf`m)cl#IHuyFSzQn8~3{{?oFEL0dmzr%ujOrcV!4t{R$|;J1DMQ^gT$8U(xg
zzvQq6DwtfgCGtZZ`$80OXnB>s6wa=}KRd2hj+JLsII9N##OQl&G2b++2LGt|+gdlP
zy_gjfDSl!@7cE)Ptu&S<{}U|a!!~Ok)0xMY-8UG<uCb~37mSVP*pj}(D@er^lcr4T
z)#UfN%jxGl-&>YFW#$p;bZ`IeHP$JZYc9K8de5*`NQgI(5cIpL;c5NyXV5uaqYDcQ
ziK!u3U!DZ-oqbD%{x|2@c^9;TKADF?cyvHeiZQ66DTA4OA<iC$Vp0zdMjDoN-RXw3
zYciy@U@B-%7A~>>IC~VKq0jrDzbln7i)_N&f0}!*W>~v!2*myYC3m;$GWGtNvm6>k
zxd&sI#x=mf=I8;O$BwKnE_1f&#2H}rH^${M1MT4SHUhpQhi1ur9H5vq**c4B%*gMb
z%fQ_0leb7l5qQyU_9%Rw&wSYvquG<@)~*@0ZdBjYwMB7|^*{S<1rN?G|K;epr`N8z
zem6iy^}QtM+Bu|WJqMyULOz~bs~1JOXMMU$wu_fThJa}OZ=$XqRk~GWr8SOUy=hB|
zcOz23M^4=|<E7S?imlllM^3G{YB{OROG>#OaQhehMg5tHP1pP(m*6-vfiT`80<J|&
zlHakuc{FsD@sB^%38~k>`{>y%6-=lmJ2o6(L&*RYhtcHs{lfU%+;(JcxdTQU`f{5_
zcWoB`b)?x{%4$l6%jE9^OW_G=RNqU_Wzr6fqvw{-ntN*P8VqC+Cg15Q{}L2B1)p7Z
zL}Pbqj#;jRAuv<HW0$ELM?ss28@$!Q1b&A7b^Y$k<R`bk@&AH?Q4E%UzD-2TFn;Rs
zcXw`TB*pclR==`!%PyBxFP#VO+AiWh_+nnz>c7K2*;PJ|pJF|nTW3yPhTEe24rvD!
zvWCzW`Lv#QEVv9-pK(eSCpgY{+8x@up@tnav(Gx9XD>T|Xf-Y&zAh5sny-a(bWike
zSZ}1!wP5K<J$pY_y<fAmv**`S`0Cz*+m63`8ROBEUu4J7ZM=23(6(leVAh8hpC{1%
z``X?cl}LO?{wen6T7I#GgCcHyi9(xU@FbMPUu;%3;nI9#iXJE`lu&WNM8<5*=IG->
zV*GPQ`+p}~8659J?q^w)fqW*GSivNg3xT$i%UTpMf#bL2JNpT@5sS}GC~jFQTVnGl
zQ0>q73j?w}J*vlFR9f2gn;!l!@kgVb2foMgM2h`n{tY!ncICoj(gO9E4h~B)F??Ic
zMCm{7VdfuDD&M8vZ|jR;$%#vuw$UNhF&eo>DxVc{D$SvpTY)CK^d5$Y`{Y%rVw{>T
zvde#avmZy)xx07CKz?h7mahL9|9U6m2+fXwTkjVw$!7BNOxR=YcvreFrH@CYmq(?k
zf{YAs7dqdA&F@hT`@+ss{kGS_A^ymCxl-`}<~Jr<o`==x;>f6x?Cm_Z2nxoA_6|4y
zHyNR~r*NXD<y2vZxWYDA==V$s7TUFs?B}moWm{YE14Ysk-_-mFgY(;^8SzY)f?HAr
zS&-T1qGjB6fH$8K;=sL{XM@Zg9Oyj2KK`tbA;<C$W3Yl=gmlj3ns61j2t7S!aZCiB
zZR@#~#}VRAWsPlJuHE(4uWM@fK6Rt>ntWK=^M@x#WU-FVD{Vjyx1DjxGeXC1{vTHM
zE}JqLet#{)`D%+l5!MsoTrx1&3{I#n!qMGZe?e52=ue@`mZPAQNx^*nqxMP@Tl3f?
zbA-J^a}ydOf!EcpQ6b%sG%jwmpb#y)<wvJ+`N45{zKZg&)6dlD*ZCW5Fq&SbqTc_c
zE?SwwT($OF{u44*$$ENqe%l-dz;uV-7Xt)ErtT=MB)<h31@|?be1=nXEma2{7q&lZ
zcv-2toeN17cWPI=C>h2(;Nbclim$=Hb2A^0s!HXb;L9vh!CdoOevH~Bm4BFj3G1_G
zLj_PrAH^5Wn>XhAJ=m}+wT16&+g$2eWqKX)LMneKAQ=J+4p~VmpK5~E&fqQE=3VG~
zqW{rJ5f1Xgy!LM5nE8dM!+@9O<hoFQ)m04J+;?TMH_}o1TaxQT9H6UI*YBWF?Z+>M
zZ(}bU#~-7w?-dN=UtUI%+;sUCTa~hkt4Csa(#Q<#``_Zgq|{-RJ=!%KjG#Km`kIY5
zos3uEf2}Q*TM>G0td-gE!!`#~9QfV_zE=d!Lq#q9w`R?(!L<74UST(LQwroJG8H}8
zpI<bAR?W$$GA!=PN7HGvr?BaH{rWyr>}SonFa5ov`*swMwz0S`mEIA3R}_zEZ5g0_
zUbO~zU+KH7_?6a{fm;z&`ZAE2TT6iteKNtJHsW(mjJWY2RZr!=Pxs*j2c!!7>aV&1
z;n04}K&km{t9fWtGnGHwhCGnk)k*DvslppJF?!Zg21EJl3;NigV%-MZqDx28CfC=}
z8~yLUDJ6_ea3HLv%y$j`)8k{RIbFgky&<w-)C^>IDr@_mYIpk&q6SExMQz>aw{aTg
z#-Qo+18C|3U>f{v)D&^jjT<^@2hpDPvq+qhx$!~+JTU^~!DKcyu}R3RwqJ()@*K5|
zU&J`#m&f@R<NG6{s<OW-zOWrG5gCnmAv>qo*>uRtCOD*bJz=6e_H6x5^#5`~IM<x!
zuR%}rpN_s^C8s(X6Pk~mddf^6n%F!8I8&uI`d72l3q6!@07{tWdR?Is)9lI`#Z2>E
z{*XQ@#t~uCr*aH({!99Ni#~;{&}vjWP&f;uEF0JCO|{?<S9gVtHx<>*PGKdy>C<Hm
z9bLtmrbbNX*2nn(TUa_b9X9&2?=<^){_U_E{z1l&%gDm}^ULhB)3?yv2|3whH)J5h
zPV4P%EMPika`w&rOoDztf9A8=IAnF1$Q?5J_=ee@;EjzWPxme&BIv(6Ils_~;7m7k
zrCV(9Po*(yiabem@svmFDpHy4B)Unc6DF;?lS)JLiH7_pzXGc}v<cQhm0&s?c?Mk3
z;wAg4U^G1?3qm)*@oB5wXwfh)xkK!>K~EtRM_1!Ls@v#|p04=%$uto`*YP{?&o3k5
zi02kKO`?*LE-P25^(?hi(B%XRv-c0WhXG(VRIJroY&tx$Xoue1UcsG0Gv<jJWf0dc
za)aT$+ta(~1gOR8fSdt`kBhJ*^9JIA*Y!H<O~Lbzz&uYMU5`OZwmsLPZv1a-MAg5{
zh<uyHv8Err6PL`U9qLFDc&f81DoGX221#AFn3^b^yVHN9+c3!#l#uB|zC4Uc%N8zG
zC<7X>P>od7wRw56d(-*`wJu%pf~fV}fxtF*@m(ARTh^Nv=ugA3MuV2}qg2VV`A3zr
z%W#B<9T>q<1P-c6ktd}$=N=Ab(62Vup7FGt*Lh8vqpi}N!BbR)PT*CVs9P_i$2~<m
z?Q;&Ad9<i`Pk-^#rWIoMH_CHlCx0`$1N*E$53^YDC_)*ayhx7OgQ{I05Px-almDvM
zN3L(yaT=K?(!@CXKYUjv)BeRia+S)Q(6xj3fe+q^8DfGbHcjw5-6wV9WynxeQ<d=_
z-(sd#HPu8Y-tiS4X*}!wM*!tgBc14Nn82cR8Y?&|d$l|YJ)SVXE8~jIxM#KW)@`<=
zqP}3=ApXEQCh03p9mZlhH2mr*hX!tJ#F%Jm{)~kaE|dfQ+80>?LqlMzp5CyzW}n{K
z2N{_+W_q#rcI^Rdjs%pygmG?#f6e<eU@xDO=!=w0-JCHS{2Hxf=<_SF&zL=qd{rcG
zsl&&VJqi9ho+HU|ZIka}J6aiT7vT}c@Ap?$sY9H#n#GPY)xkNh^H{Zif#zvzw5#!N
zd(<O0*m?b#f#BO<jyt>}IF3^uF7@u_sdP21*R-wvVGLdCm*(vbSCqA)W;(0!|3|60
z=Q`=b&Tgr^WnVc)XO*u0PG1i*epsZ_$@TSw)WRsWV<KK($2vsEIM8y!<2K^1<q!x_
zq(qcz-fim<e2mr~k7e2=UOs}UaS&6fsny-JkuWGmGD1g^*P_oZNRT4Mom!2jlA;D0
zqe$i(Q~d8uiiT5Uhh*3;log=JpN-X5Qi?#wy7ic$_3ifCZR~D6=CQs8u!#+$O#$W_
z|3i0(7B&>eA>Y=YHfch!yIx+&PyL$^47B1+QT9?!fFnIaSS(#MmtCS!<%XJQ!7S>L
zED-G33A5YpFS|WUK_aOwJ2$RR6?S0|!A|@qmNjGCsp#3!5&nNyeBH^KZodxs$FZw8
zj*J1h+ew3w><4K~JDbF^Tt|2b0|Squ`!}EyK%x7|Rx!0w4@(K8yZ8wdBLhXCTW%dv
zrEoq(Ns-;7I@{Qv*)P_6lZUu?4kka|Spd5FxD%wq1-IsqiIE+kS3H3d0>ZH0;P=5J
z5g#6(6PG8iX+W*wm2Ng(R<7+<h$oH?*zOw};VVtJa{N2lh{Ij%Wd<U37LU!Z{;74_
zC|5FG#>1>(az=T_ll3uERqy}eBNJ^(!0rnZAS{Pt&-`jv(9Afm{3(SP%pG8<dobkU
z$!b?76QY5lhiNR7L2)4PHGb8tGxrVc16(^M4f=o=@E;bBd!c;vh);4|j_5kdEi^K*
zQL}hVy|9rnpqav58_Z{WS^tUtD<4YEqGI6sV+--I;K*LBIFC3)S%j`fTvPdJHu<%V
z7r?-!fiSQZ%4Ox;VL!Vs8n11N%HH2ZWS5AV-lfoj%Xnin!qt8G^?nAon`k$^F_KZ|
z%`0W(%A}QlpsLV;R?oQgqhsR^l;AFKS;Ty%l$pj2Yp=F{#{b}hk~s#_E|=i-E(^tJ
zFb5v-TGo=A%0vwV!h`h&9Zd9JeZdA6R8S{TSVBI!BJSEwDIqUuK4tGgE}R)U{Rf_;
zqT=kG5)te}LvH=pVwyK<791gC4RF2xT$}5WBz9ZbAp3Kl?r!AiYYc8LeyH_}<^vMD
z6ks^B$~l_UR^EIhfd2ZYT|*qs<p#XVx?1mlo62FtlTG{!=cgg$54#+8T+99KaHrwS
ze1Z$#fGe*W$e%}t`S`B|jrF7wkXXOqm`JRYaHTe)iyj3BSD8g;Yi>oGFzcn)_$Nxq
zu<h$^T46%d_VV}s18Vl%#_q{%mcw3_(EJ@dCgOCr(jTy8>*T*Q(HRkoou49l8OKmI
zjEafkBoI!Kb*iH0k|I0Sw^VSf41rb)!Ka{&-jx9Lr+zSm|ByGqTH%J&)HNZgH2A;A
z@Y|7&2E;(4G2y<IUGWrZnlCt&mo-75E2H>VvrQhN3ni1x9I%>uj*ggra)qT=>(Q1@
zvt4tCYfUjTph(K2%Hn1Hb=9P<v-ByNDL<oO%_rXqe!~4~4LJO>UiaYQ_GGveyM?;3
z4dxgSW1Nal+Fvv>#@X>PgaXJ$-vd^(1zn#&DB!rcoC3BXxh>WhGi$vHAOti7Q^iy^
z#P|WCwp(!KnqgMyC`U1<HenpQRE^y35_E+(=vtUofeff?j3uQrowU+5{4LOD`V1~)
z)$aDce^a~$fy9GnDu^zFg^c>=qob+i$2sJaPm=>LLc-6<!%ujSSsc0SiyS-9Zp36|
z>Kz}={f4*+^H6Mm?nO65G5cFg-;P*ckQ&FuE#+?oDA|Eu@EJ*qMq-<As&F~Q)=~38
zhG~cB*F$Y+kn61Lrjm*JBjSn5iWFYqhS+Sry)@s#7DJ=GjrTQoiZ0exaF(tqj;=zw
zXp5A;ji0<8h=<*TSN;aJb0Zp}D;XAsNJC8nR>+H!P8F9{GMveAN#Qbv6Fg5bgMoSW
zrU$Kn|1)Spl2RKGSL-v?sr(?inp@j{LS}AlWk%G6C_=yb4{1k91hs+VBSG1uOopJX
zWX$u9Fzj+W>eYlnfmkilUw&x%H0~zC=IB)ph`;Gyb~Dpg?NtUMNGsgQ$;1;R`3S8#
zwL7g8S9kCyT*wg9w~`>h!{~u><E0mLq-9<-E9ogX;EJC*3h(w$f14T;Ig-ssi=W|*
zmv12#F`Q1LBZr5Jl|932oF6M`njWS5#icdw>EOosVBtZz7t`~U89>MC`CW&C%oR`v
zWvAUhhg0W?`t&+Na<Qf(Jx@dINYBwfvs%2eR6#F9piq1Y%O)EC2!?DYfnxeDrGsxS
zRrvekNYZWU``EGXlJ)!(`g|2`CmHO0Ufo?8)$o7zQ%7FuIYRi4SO+h?P(RJ+0+M^=
zZbc#Li{GlFH>1%3W)lXMTRBd0JmGXQY?c4uhibpBn}xqs`m)`;t%vf#yeNi1HHNdm
z1aov;cq?R(k?4ZJcxMhFArt;2N615@rI{_?uAL_ADWos_PP8O?R|V9Xg9+jD>j$l^
zF8M0hrlv3MT{fA03iW<LxKHh}(IA*=;ZhjHu$=#iXryU+v2l^?3N8u3WJ=XabE4u|
z9*O)B6fl|gY0Vry{bOeE_*7#%i3OO0I5fSeqql+@i?v4<uc&tI|CnPwLY9=z#4JWH
zk~Pc&J!9QVdB|R`uHCQEr-^LpD+zVmJJ_FLK|?EzhE{5I`fH#>ddf7D%3sBD^hC^!
z-;NNolCe`Y#Em5W%|xp*#;!+U1+Ak{@DV&5yeXMcHwU`!=cVU_Dz=xN=kIo<4svG1
zf+6Bl+@Vn?sRGWSc-NLQCY2QF>JpOK3_;qJ{=)|&g;Zf5SIbUvcK%C>J~zo!a{fz-
z-l0eu*aqmPIb*y;n7zO0ahn#brgIMe^i*7#`9%NLXG56#c23`w%FkrNLJyH!B#E=d
zf_8oj^4$RQQ-zVnImJJ7U;q)A;aI46f4of$oSqXL2NZZQl|_PL_hhVC$tVK<b`jaa
zX#exAc>aeNYFNj_O!n8LbmzG4YueRB?@N->_rL-*>Gy9cRlm0-rFyT(_4}?$WwDx(
zl>UZNJ%h2b`Ms#_8A<8QYT1%F6`q1#T{E^u8p5{|z-jRi?3k`0?46XJWX-H(=Xp?_
znEwlw377tGN&~%f)TUAd_It}EDVK|!&qmoN8l&6)WWByEhI-uP;iYl?{Micn9Xq|4
zUKC6K{Z2@>Qn5`FroG#(y)|m@5I&O&ga#MVpccHby>->r)@O%KqxlWfwl<elK}u!1
z<WW{Z=+NCJ8>++@Q|X5qONA&2ObG4X*FySGL`A!o8QS`MuVQ9so35JEakX_!G+}mx
zq(f`_aAMlruTim_yov*dcE@(gyxQ=4@e}{xW!Cmmt+>hOrsuTG99U0k(>l}sazJ#!
zl*G}7q_xEAsiAtTPuwhHu5{LERDpz5Lv3${685!4);hbFKo#xAPiNje0YaL2FYBaL
zoG>h2r=sC51gZv{^;|2sdNhec61W#*IMO8{RM@?i=$}9v7tF{S9(*6wL_#0p2MWpH
zG*{~B&1uqn@t4SLe)HiG?1}_d!YUeXD!-A&9qbVi>}@e@eg&n#Zo5femO$Jm2)5<p
zwa+(~4zD2wD!k*GamoNTQa3K4=<oz+c*(f3`-`vUH`|y5w^IW5UBT5Yks|YwwY!82
zQran4gZhC^?>JoAQsd*r#w8-Y<wyWwV-zzqXOB!rCdgiT(yb))*T_o}1W{)=7X6W^
zNQtXjUUm&0wLiXqg4{P_<o}Q61Ja~W=L=vb$6)#YhH|Lgt2r_=4X4O_*(?1SAJ`B`
ze`U@Xk)Wn?jvc;|-N*>cmi@nn$33^IXE3w9p4Y};`3K^jk3Vw4w7t9X+ZpKn3HY5c
zxCT1Va&_8~roHsp%#GL4_Z+n9&0_`<zqAX#I?{_+kg}i;zr8U7^X-?XG@bE7XZ@+N
zIDROf7S<?jhM0ZUixn_CpOpJ1|2KRN0<9f7Yjstzc4)B1ec)O0@k3kNYg$(wNCO#+
zMC@2XTl0=E&qV)}O&qO03z<C3?c<L(!>*L1Sg`O6>d>~$j`3f3T8zJ167Ba!a;sT|
zzrM;UY$MUuPunV)M&iuovRR0;m*3J#Nu1^1B)$d)!(gKS@oRPSKn7&QC4ZIlgE4<F
z@Zd4Q0<zdrGNAu{BVNB3Z0Qzz>E$SWuC03WOf)ZItg^*-`=9;Znu&1x@Medp@k5bi
zt*a_POK`D}RkwydHiYq;HY%`m9D^dX3yt!3u9@IcMzfvee_%*7sC=VZV~uKtYo?M9
zoJ;3OR;A}lU-%pIo5;X!ZqvXj#r&p|^Fz#bEY*XD*-Juu=XN?9k#tsB(pmO&I@&--
zUAGjm4cQ48jl>j!iT-g*BP;kIjzprRa%d?euUR2^RiyG`bg(rNn@wV9lAdOU2H)fx
zt4nSym`;1o!Gk2%+8I9Ysav2zk7EDm(&Dd3n>Q6f6l9Y9(!(Nj6&8IIsR*J&<Iu@T
z=?#>+x*}MsJ2EMqPHAv2|IxvI8~@fxiXVHtShpBD-kGCR9~_dqpwB1g8-|Q0qr!ja
z8e0gmO9HyVsT}#g69J7;1cW@>S4SSq^@|CEnu-z1yd3FQR0%IfJG)!SdB?!~z5mLv
z>)KHy$Sbvc68V7$g7fMY`)@v>x39SFRM+lW^cNJu-k%V;oME_HQp~`5i(P2j<erA@
z@!=`tEHr}1us!(D5S`gl6B+?--~6RD-nG0VEi)>+VLL3#Kg;z`XzF2J{y(tGTaPlx
z9%x;VeIhjTNGE;{B{AGAbLb`xHKWkWq8oZxh+d=7VVgVBYt&V6FMrX3r)^QXcx%#v
ztTo{@u5(Zy2ul4-O`wiQj$GddioNka_lHnNB~bV12;vTAqg-2CBB<RGDCJQMq4si6
zTO+8h!O_g}|7G0qUL6{NRwu>lDGnQX&>-F9H0%drs6sXEhfuQ}R6My^3Do5gRQAl$
ziJg%^G)2?T9s@)?sZj~U3o(S2$|fX4e<gt!z_hW<<K{ID^c7V=1HGuC$ZaM|<1*L{
zwLt90*5;uPm}SnJx_H>C2InB!;&=VdXb7U+ISqwAfoSsTRw@GXRNWFFJeC70muT)+
zL3&AWJO5g!qOQ1vNWAvo2*-s#(vhW<C`Ggm24}}G`6q#?ug9K?8~n9;y|wbVe-4gA
z$(t2olNzy!iw@Y&ey*%3rdI~L@q625`^U`|<US1^LfQ9rk+U(AnV|9MMDXrG(fIP`
z1H|L(h>k7(T{3KJ>BVc$Q&)1s@*H*j2<6_y%cLjXqo1|qt;2Uq6=Zjp;a0kWdygP5
z?Sgw(Bgb>CQD=M1Pa|syWx9ahtyj$`OBLRhRzI_{7w^<`x6T~UE8FCauf&|;)$`oY
zCWwdk;I7rRqfB!%<VtSf*V=ST6AApvtuz=uJ(J4Mb;pBYo5PfDVQuqzGFb1F87O$8
zi>J&8-e>xyD3T(q7(vI|c~986cnEO=y9aep%X#w%B+$HSL^`@0j3HX28%JTNfrU{6
z*;4z*mL~t#KeI*aYTLHUOQIU7!b8wYa5Vqf7N$Oi$?s*OM)3BDmS#`(VIzlNkcOOI
z!ZY&0LHZewETp}i<7NuV4H<mImboo`zFQq*;7>LZy4tDhX1FT07c7rK3K!EiMX|l$
zS4q(%S7ZlK@!}0h(J>SSQ(d{Ws^E_wC*?Oo7MyCVY7;cskQ7};QPiPo4Nr<>FQ>?&
zSX8uMQiSJMMHa@QqTWdnJh3$(Dw_A-*s#1Q#1E(Po!a@oZEpCTL#x+w`eZi$L!-Us
ziLZsI+IFv5hKGn1!3$p!4SPcboqMEfjWcnQbkDyO!@c4S6j@xddHQd?s5Y>m$&I1x
zeDQw!3N<F<>^=jxub!r|Fx+{Frlk-jQV4d{1-utq99hU`YfmbZhhAk3{(w%Va<M$+
zTyzs_As5HEaGZFf6PDH=7?DEZV+cJ2?rFqnQiFe4Y+a$n?wsz-^&x!nAr@CkFwS|#
zj&8Buf69%A!Mr7_^9q7{u|>1J2j>D@vUlFjpS;>Cu_DIrNUzoyyS|EQT%3-$ULCFo
zIjSOq`U?PnYujMuGd(aKd44fPUtomZNx2NW7JwrGiy|Unw?p7ihk(ugw6&$XmxNyH
zWtF{V9w4=K50g7A$$Ylz2EXwRhCfy(WrB4oCA_u)TW(;78`yvljL9HC3WGx>=c4|>
z*Z3J?p}B(HCukAHjl)H?B(`t0T?w(ykBQR~#<{EDLl217Dt`gT%*ZFQ#s337La%WN
zI8(^lDU`(;Tr1;(yL<Uu1QD&dK!$X?-Jw%KFoGjOEQ`Wu`xS&$Gf#=Xe<Ea}SgS35
zoq8hHihG*`1iwOAAOPM3X-Dt|SF>EjXA$X<Jm2MNC(pMqjNmXzBYy+&3~R~COVZfL
zdrDujI*TN#^)CnZL6X8Xrz-A&=m(j62)jT-&z=}EZbcaH9)&-A1m+{o?H$dblyh-1
zHux2I!oZa#xGwixs1~kP0K<zI>Y;F~M?#=}j6#9n*XrgUvRwRF>-T%p2uCaX57C{j
zSK8U<ecn=#m;Z`$lpRCQ%uu$uR?pk&IUyl)t%0oPx-^Cy;;p_Kp}FveE19dC$KnWB
z!q-0@*D~v;`_IkN3a=-KZTxWCF-Q52@d@^`L!@>|0$o;XfX!J(3cuc_sqhdNC(xen
z$y@VG-m?rtJre9&mnv#p-%&f<hEY4phM}a#sQ=wGcA&G~$nj@xQEiF0kQB=iOyT$1
zoLedgH~keg`PGkk_p@JpF`9E6<Xd0f59Maj`qts3XZVnBrru-^ci@*XomnmG%5rBn
zpYto}Xj%brr7SU8gR#z}h8H<ZH5dtDDW`ptu_)gIVGvq7Q_A1pFCOMH(XNcz&C?fh
zhWw>G(aBkWN@j19pjnz!`mR<<2~KRmm+CL>EQiwx6Qu;-E9bNAA`J{He|@OLUz9ZS
zh9J}*+J$~9wP5xj@OfzjoKArIfzJ>)6}Nm4El(4$e9{9G;K!4e-_{vGA~q}FsZq;a
zgJKlCngIVUIxu7pV(QBTtf@bh0RJTczAgc#<(HzCZ%Tm8F6kzCnt-n)VL<jEB8M9V
zd>VOE&q;t+CM_S{qvZur%SR=^%M##T0=}4A=h=f$ByJM09IgEl;3pH{wGt(^D8k0V
zsO2~Ijj{1&0{ozWwJ53l>2$)v{5q<zD5-FbDsXKdfpv*0IIqwJ{G^Aas=#yC{*`fs
zd`3`~-veq_^645U*C!<)-w=pH-0uAJe>5F|YSAC((;KfiEiFEXW=!h+wf=7&rOeI;
z{}PF~@&3jnU_y1DeI=ftk(xU?Djx-dG;)*P_SXdJ6t(4`^ymaoMrUHI#R=4E&D}xC
zzzS4MVAm&5uL;VHYacf*qb#*`P6E{@>G9u44B9f1(zuRIpsEt6KRGC)CABp$f%;Jb
z6`omRBKi=&S16(`5|kU)Y}#Udje6A9>ICYNsIBaojLAqwV|plom>EMTMkJ<@>k^1-
zVhCwnMilDhyaeJ#Ac(P`<>m)i+U7rT$}GOFAcnR6R(ytJ<Mdw*b+4)2^SlOZ*4^CO
zUY9ET+^k{iy-CMOl03@p%1!cAaVNc8u|l7I$tSjmZEj#yW5y^>D(_(CQVVl0YGbKA
zs|&AIc;_xnIJ)z%KRGZ$T7EE%LGGqNXmGV1+Ut>qzW;M=HDL&QP$oFjtNAu@B6kw2
zy-9HVMR8LF#UKR#1@63g#n*#n96`3n7Ne62fle~jOqY1KFN|@Y1nwEZDRIhnz&_kN
zno8j|f%T@j^X9p;F(Ykgn4ppBc)T)!oG!>6f!t1mcPC&c2yAC9haJag&aNRk9A2Kl
z9UwRvF}G=s<P3g&0`@5o!Cqek(@uL>0`?by4cb0fc>=abV0x{7d#kd3uNW(N!F>wy
zICftKDQc0wL2Lr@C@8RE@tDJt=G}4C{QXqz=;I?R!$Xhi&Tgk}pKrX+*W#rWO2=`;
zQuC&n^!oR&EHw73FrQK>Wc>Q5x$Mp)twdb7_ZKhbPHJ}ac1|t_M)0Y^;XtF>e}GAi
zLl%8Ew~Lil!%F@i?=^J|V>hY`SI9OLuOQoGclh!SZ`%aFVo|<eB3Zs?gqQpPo7_K{
zMzFtGU)C2dJFe@G+oI#ANsS7t(WM%jKL6tJyE%dUDd_I#6A1EIAh&Jv*aY%*gWM#@
zTY*Gmut7K9sCh18p214`-1eNmbwE6cXRP{rsy><O$!RIn_}3<&k5L|K{948-cs}iV
zh24U^g~H(1{3o*4Z);ofl7?hB=;)*M5B|O#`uSc0Nv1R)|0PHzkl7XuM<tLK7-Y8~
zZvt}L8Sj!no^6oCw3Y?u1Nns&etVA?Ia3Uj5Z|(3)ONaGl0eoQ<i7>EyBc*{_1zGw
z({WBj$H|I!v{THA>lLb^eVsR!O$#}Y?I1RCPD}ugq-kq4drEjdUQShjV*~D?3Gm)(
zRT>C7xpFdP_oaI?zfM8m_DTRp0=Oc*t}H0Z8R7<=#*q+i;Yah6E==Rq_SCU^jG94K
z)I;V<SlypMd`got12nE70tte_TKBPyYrXBZ#oFdnzCqoxLu3YWX``__Sfx7c*|~MZ
z_BXD<{nTGv>px8}2$gD5`2$@AotgI5&&!w{ezbqvJ;<#>u(p)1CZl+QqU{Oa&vuKa
z@(Y1Pqx8RJp=xY=r)pq!`zp8;i01wr2ZAEM@F~5ko*39c&2A$ti-Wy`SwOTNy<@7-
zm*6XoUZDpHXoW26#KHZ^JAfg|^C>{&(_8OdHhrQuourQE#=|PyO<~ZB|HQPc@wlzy
z*cdGTl*mnI(YkKoilcjlzf}>djlwg2sbm@pth*j-rk&%1$`}<LYK(?5GW-cA%<-}9
zH};%Bx3jC=o3wV18=6~wf68hbRF4tO0)m}>q5w@`FxZj}cVg1k9gICWVa*a_>C$Dh
z?~dPg3Vbp=1=fV<wf?uGag-&^O2%7~GA7(7=x1VF%?@ROL1&L<gWGM@V3XhgMzalV
z@2eq&IIjr~W=7%l@SgY0Mq&JVwMg6n6uckXlTHbH>R-+jyYR0fDP54CAZ~{1T}b6h
zf6Cq9%C0li04McrFaMxo6!8687)ZDL2^%Dp3r}f8$|TE6U1MdmFMN*PT|!OxYp&B3
zF4=PmKQ)vtnbwQc3ez)8aw)(T^+Nm}m!U*V3c<@x<MAF0&3M#t%;7rj=q<pG+9M5q
z{7`HsP_|lgA%nWP?qu81$?hV$yL{J>?y|2i8~7v&7o2sKb=UP&;-o|h#U|*{QN7&l
ze6~0*38zEj&)4wTe60GsNAwww1IybrKfM1jbxG_Uj$+dr{DXc8d&{5Ob&dJ?nWz8u
zoe|z!SdFFDa3hud6Ic)<f+t+~l7%c`3bCjqx%@#07s1|sTC>60k}6E%i?BC#x>JX0
zr(>O?rJvyA_r{)z7gdM_fIBHo{Aux5pG)#9F2=p1g<cd}SB}~x;@rYKK`9$3z6q8n
zy_^SSbO+vo%~A>6R~_82b>Xq}7j75P<#Tf@Z|om8xwf=P-KNq#a|3!h0?M69Lv_oU
zMf048IDf)AL<xi!HkaOJ%V@V}vV)BTvj;#O`@vXC?0#CsBEq3$qf&%IzhVg9UL1?;
zeIh7Bn+Wy)My%-#jM!!~I_f=pHArIxu#zhj<oQ{c0H+=9??(JCCUTR0HDJR0$I#?%
z!oH))o%GWkQwy4<$+0Ly$lrF3=(5y}Lnxv@!$#QEX5%+LaZJLreNS6K$RnwIE&Sgh
z0^rWEF@_e_-jvua_>{8fexLkMjyZ<*9K`AIAhuzSv%^6=Rmu{FN6@(kL;nJ_08aP9
zGeEebqTZ(JS|GnhVK1}j<RvT^_p4>uY+TOB-7Tc!?EGuKRwFa9(3*ZRO<a#k>Bg&b
zYpfVNnn3I$2nENQDeNnpVlkiX*F5Fn(5Je*<kH>G@!qLtLTB}`S1SKAtxI}2M5T>)
zx!1Cs?Y(dtND6)@OpP13utMP)yk1B&P`Sc2_*AKAAYROiqJj8Sh3rJM3sS*A?1Mvt
ztM#D{elwC&NJup(P*lr}gg&^dk#iDl8LVVPauQW9_Kh%*f0|ar^>xcF0I}S!4QMvK
z{ErA_$x=6RyIQUmqGM^;P$6mPWE<adXL#@ScV1${<qm~N)}}9!VaW?ymLMH<bAebK
z@tNXsCi;^(UJqMGm%%S+iq(Y-c|J0Z-GQl^PdDfW|9?LfrmKRP%x`-<^<G6h!M++-
z$X6@PxL)J<YU$PDtCe(EtWEf8w_r{QJ!?aE^l?E?dY%(?u&uDa`EsLyt{(J!Mg*NI
zjMv;U%{l0YV_e1`lN5cEqF}Nsk9UW!CFO9Ws*2F9YDH31M^SJw{|T-9VwT`H#J^fU
z>E-^WUm*3}mB-()uom071pov~@tI=n@ar+eTYyKHctW?2Eb+tv{7~Wv8Ma6~aV3c-
zF5Pb838l;@@x+ukHA^w|`PR84zDcjOQ2z8<0teC?LU#2}e8yG~n#jLEO*AtEz1=k=
z4QH%=Dh*2(?{IJ~a}yy=QY6dw+>*o>mUIaDFLzs6O3~Qf5`lL5=)u&lB@p)bXx;MW
zCJAgA+c{NtH;8rC&bQ^WV{|Himqyko{#6L&@?a#3<Mvz2OtBe>ZkGY)PVRL*uXer`
zJjEBdsl*b6M@Msf(dM|Gc(lT*=z1xi%F6WI)*4x+Z0;nd;yQMBeVatBf9>~eFsi?d
zzXgRW3D?()+Dcft+S9u*pmlmRgEa4Y(FaJfy=XB6*7h`0(_S<a_mmiGC=j8(P|u4^
zslu7?Pn!`GG_n!~R6FDO7`IcYc9w+gd?##YFc7eCo-$hRJ`FUyq9L^`&+u8$+B%z6
zccR}bthAgnr7bhh{y8-9SF+T>&3ugI3$_<Uk9>VcTh-8S%I(+#gW~`@Zyv8xf`|~4
z#4Uy!p$cv3ajIE!PNs`MUN4UbB;SjoSZ@riJbz4z--hY64ZjwKWLI)FG}6lcf^NAp
zakb%oP}i(PCWNizl2$t8+6*_2><?pnE{A(#eEvheEoAIz1A_+uFP*)_^ubAM6Df`y
zq22zYkMS2a$(8=8t@L6_K;cM0f(iUbWB=6dc$N95>QosDxj|h&+jiE^?GPj7d1yQ7
z;iRyKPX9xeFYMt#38=sEpCsSh>D&PyMif1lS`<%m9O{?dzYK#)$PTST{e|$EWyNTW
z`z!1wF6Gt3R6eC+^aOK~mpk=s%cH=L1_NJ@;qw6kC`M49=;T<Q0IUSSI|?gWwbvwf
z(0-*IukRgAv>?}k2iGm`>46lNU8bV+BK`akKQ$vc2i(ms?pq-o+>vDo<HU!_ogah-
zYrB~9{h|hcr>E=!)TSwVicr^l7B~2h-5gR6f=SIQt6Q#b*YSo^EPhUHvx`VQ)V4#T
z5tr^T*5XhEJ+(!W>vB&!)tk4l7yBPSOu-qFkjEtQFIIbAgY1orNxQ`Gd&WLAP`}Cl
z>y3^c2~y0Q0}A)>GK54CFsyJW(o}zkdQujMWg?AOB{E5K_urao)hw&hcN8i)eE<PH
zweh7R|3xGOIZ1@qcO=O8xvqmKR32t1yv~2&=c8nMWA##nXJEhNq!ilUzPR%J;_2iM
z7uS=K;HdaM*+v>I^CIW6J)*pr{pDP5>LRdn21GI?TGW?OCBj$*x3(`aF7~at>5bC;
zSw_vV!9Vnga2<1B_0k)QA1D+*EP4q?yTfc=9w*{lUXWYD1w>Tn;Q%*p49+01%s+FI
zy^>UcG$u=;#kUnd2tI+aLS3d$iP!8v&JE$R?GI*xmBxS2c6?K+EP;3s2#R9u;qP1Z
z%8TuaQfq?8gxlz1`(o*gYNg5l-yEBPcT|uwu^AdwLMeP_+)93hH6X{_Vt+7>xll6v
zT8+zu;=jY(xWq>m1m4=(nHkz8_j%s<%8_+Ghj?I!gB#hniBymJ4XM@45Q6@Jq7BZ&
z+vxru&yw*MJ~HhVu;x5MfrH6o7pm6A5Z}vb1By(x5fOo{e(*3wEUc(Zy@>C;ngJY2
zF}tD0hao`W)<W#8mL?9Uwd*BaB`19CMnC^N#AbFc`UH<U;nQ}5fBR1y{@iiw5c)I*
z%sq{a*5rOh+okJL7q!Hb;;txO%_E|s+;6CHr6i}euYIG>slr{1lw-5q+mZ@d78m6|
zvjd01aq=z9QLzMFZj5$i$LbJ2e7TJ_kk*Jx*-Q>{DgS{Ny+Ud^f}+v^FNlhAJi6(w
zo2lzU^f{Hk9C;4gaBp*Cy<}o2{{GE5fHv(_Nk=x{!`l~<&8rYwYs(U@I{Z&4BWA63
zzz7zouvENYs4MKxY!!>zp4%PKyt!szZ`~4IOtc7D2@nhJy-nrg-$G`@aQIWegEKUB
z`ybp8No}2OSvU+$PvXgTnFY+y#2Wfj9<qUgx`Na^GaELiAJJ32cP0&2gH<#_=}w>P
z=a)*`3z9nL(Czl5ZS(ckBdPZgt@mhbE&b87Z&tfgS0dXHwB3p?<JE`8jXe8qHWNd~
z<Kf#Vv-MZyuyw`8y9je3`v^C3i;WAr`i@bi#IsdON%?KFhyNLGXfE&??;DY+$o<W0
zTsR`rKlhqfcV9^q)3~V&2<72}wp}q|*lh_h-eAXgeX%!1kv5pCQ2`Ui8@39>hx@7J
z)OSn$v-?4PdIQ9I6?B~Oo5<kqRw#cHV+)xscn*BGwk+qZo===efPmUILAM%0b30Y}
zXMz3G<dd@z0kfFXAH)*8Xcf$`G#z5%2@RI=U&tWdeGnH+m(mHf)U7GqkB)8BRMs$l
z){@Ij$P*0Cep|}P3V+v$wlZqqo7TV@EZ>A=)%MTsgcTK=FI3xGX>PcQQ)zE?^YE88
z-t7h1pM`}aq|29BWzWK_^WTSGY^S!^l^!RRZzdI9k7!3qy$jwZS@mLn$aOYC<`vwC
z$_G!{JxEE44?tpw<Ug`VZYBEPCzN!u67I6&>I6vF!$A?E&qSs1Rd56~x0R446MG8E
zz*45dQYDFX%%&>^Da@D?9d~NDV4#nXmg}%gG?^$09*?B75B2Y9(AxMs`yo3DJMG0h
zYQR<doQ{F_Zn5P|DiKcTPp1ZD*HQ)^?82&KQ?Mn*!^w8^kXS4P{B$V!<Q`2?110m%
z>Y#=KIWIOeUuU%XP*Pn93YoXY9q2g+lR0j4`XH39gAf#KPJ6;5;69iYBmQRBi%_dx
z^qhmp4(+pMhCbGt8s#rI)hap-<X?m;vLdKaUhQSYNfkjmA9`-vlG#oESa`u$FS!0=
zjXv47b$swYjuFtpcodl{(z!5^zvuBen8AODH_*&)wwW(Z>iwJ{GII?y_^KPacoKG;
z#e_paL8DClpXa%;R0W?iTIPtDZQ^A{3;b>Cj=1?GLzIQOv2T8Rc2sGVg=cb@4ex^;
z<^~Z`rB?1vtuFxLgv2OB=i#-m2LD|<PF00<f*(^sdf2NH=guAw-7nQ{w~8FUAzMlZ
zHIrU&3$S4NbR9sz)t+pT!&U`D!Wp@#cQS>bj1AIBo7pT~C~bNJheToTK&UWQoP_Ly
zP5fHyKOe3zxfi)p!;umqM<wlR7P5`zMk1jLlwrH~qb!O^njw-jslpxlyLQy9)x7dL
zDwwCg>Nd2!kItmV-I}1ThElS@Uw@V8sVbPZ9lBV<<58i2=)){zf51SmaKC{X+XEoO
zObEJk*7h$J&K(Yxa@3?+xOM*tX&Z>Fwxzm@lGb;pI6P7c16v4Dki>N1yB`_9^`zME
zBz5~xmxXvg<S*q<B)d$L|1CEP3u`g?y$E4o1o(r$t9j=o92y|uw|9R``SdWOD4|{|
ze<^e=ht*H?F9*@{`Paqah6f4uF0&Z+j>2(WI=jA{SET8Y_{g2!j-_Ih&+elCgxD>O
z$5qOj%g<$e(XnksXsGMNeo}LX7GXmajmr<BamgeHFIY4#AT1onZOL-G0vQ^k=b7N{
z{67O$H~u?X>%uAq>Ecc;X1ApqNBU*7hIbktbpu^OM!U#d^wn<bttLAe1q2$ccag9M
zvU`|MTEfLk8rI`n4)74yzOu75|M1taP#xSFB?FRqEeF3dkMrgwA+63HRjO+aO`291
z21RjT>z+x`6(Ydf_>b%QQ8&g@7^4LyXpHZE7*GD1c#H)Hs4!FuOc3Bx3E*ENz*K&c
zn8R*x3)lh^1bkBhED3JilkY78cGfK_Sb%~moE2BdUt{wLi5}%H@_#1~=V(U6S|dWb
z{mqZ)j}1M1%wqt6{=%$A^iCQ@7kRejgJ`;W!b7O&g4k$h=3OwN^6L22c6y>?{1M%O
zrFqy+OOGZkeN8P9@Bq_vduN>Lze7AzaZE`t0cMJ=%@r(mfM=2jfzEKFA|nRdgbNV3
zW2P;8a5CCjEHB*j6=m_=q`OJ3JD#@0@o$~_y;c|!Ae$a|7`gqn{@ooT;rk_R?WBCM
zJ@BrMS0upL(lt-(xKCFhir+uU`L{6%WzWJAaykLblMoTHe0ba(+?x=YWs)d6qOL^_
z?#nTpx&2&@aJM0*r`fq<(_}8dxr}D-+#YgvcK437E_i6)iPMIq7hw<f&X_)}mnG+E
zn6Q+?L7D&lNmdEF8{^`svPB(b`cA?m6IXVJ9Hn>c^zb}e#4}4%a@b+iM)4#&1(!yt
zQl`_wE}=Y2<>&ClZI#>j?-u+kL~E%vN>c4!&gm>o;_r|O`r`;11sow2%DP2R;;FyD
zXZ=&mFg>V5+6?c-&9J6IG`JM2Q`<G<_ay12KEaXbpx9@&xQEZIT({b>TH!P6jeAF@
z&nY}{VX@~2GT~5AzeYpIlh`Kq91cs9tGo*?C~~!c({*@kiAxG2ji~}Rua`KJTKUtY
z%2TQm-W5=eiR`|3srOtApsWQyNC3NOLj>>*|F~v3ofgxP(Q^&%yw;Vv?NQ5HgLlW+
zKaoM27*h;+Rnm~J^Mhu!-T11H;pcERSJ)v^fTx60-_uP!j<0$?0k)9vZSOq9;_L1N
z@NK%6zQKMmt&DwR8ir<V81LgVq~n@Yez={-x<hRl>O94pRLv+3L-Vq|LxHEKBrWd1
zI749OrDvpZu2zFW(-0TQogn`VeH?wI_2Jy_yF2&$&d#Hn-$}D2Kg8HmgQrm7Sgwbn
z<$7mRj1zkYz;a*OFhOw~Z1H3Q^&t&VWY^Y3%lE`Z`Dd6uH`K@$=dZ>TEQVhWv?Dy-
ztFMFwhX#x7+ak??&=ccWyIw#11e<|zEm1N+A(LzL2n@_wtgY_oEhY|XRehZDMC>j~
z89#LPsxlJCgwA1btPv)CmRp~eU5O(@)2YF6ZV7@P@NYQU{ln4jrJA%UqU$9e@{Srr
zr{#sEMd7cJTH8oUg`h1Ulcpmrr%oq(%YnDiCVWG)D0Zx2?ZDs<G;6}v-ouNxxrs?5
z?}sBHLe(9tFbLNwn@d?LzeT%h!w`!g!Q-`-v)^7pxju61NRBwZr1FZP*9UhU;cBsB
z5BvE)xv*s;&blO3Yau1s>x^Dcvz6$2beoxKw|*?D#|v>Wx_C8yr`B$vjH$*WcF$EX
zPDaZKfP`9MbcBugS0)`w(rVqR51eV;h%IAWj}Z@#dJacinpSI6G-7A&SBjLrEGj}}
zsYt!Z2hL#UMTY2XrF4kep$mKEc5+MY@lv6Cs`ML@A*R+`0HeggH*KWr3x&rhu@f1H
zE%;_EdMI!fd?Wn)G=Y0cEk$tq^9#PwI~*2NGcAFuDPeMy+D!}?<|qlAIO9^s+mMmb
zQ1EZGf47{-*OD0XJ>y36IzO;sTWnv2JavBOlSbW4B2*M6i5`O!X=^*{{5<begcMz-
z-om|qr>@^_2l(~`_%r$~ehN4}HepqP@OyN(UgNUcFFI3q$G2amBuyw}mj-y3TTyy7
zXpY<I^3Vi+T}hW`qso=CTS$z=cLq;cvx{6fh&f;vAxNcm&pgNQ8*~DJAhwt<9f4Q8
z8{<Iv`9($k+oGXO{fPm?NT?K6OI*Si*1EZjJ;eVTTX+}%rUO%S+HSLxW|C`cTHJQQ
zr7+_-?8LID=%l3dAh@hY*n=_~4N1zEsJx5+KwV0|WxH_yxIF(uI<}Dy-ge|9-?CIS
z6^xwVCI8@L<R3DVFl|OqW(_#T>h>R-2Z9^O)QG1ym6wys@xl2Z&X`5Rn@eWVkXhs)
z#4YTAYPII86J|L#f!kv8DunwAHA<P~m<TRc6YYj|t3yVa5a{h&+9k+L|I36)bu1;0
zmbt-y-`o#X!FSC5K+B<~8%F88MOeCxHhT{%%hR#u*zW7U%Q=tXQe@|W)m{s?RL$6<
zFr_P?%isrejo=J}bsXoa$3^%cxA%QM-({MOrDSj@EhLiJ5M?n)<D)^P@_$G7?lG{Z
zmiHW3@O_=GgtDF!+bL<|a@ufrc8Cn<_UGJeyDN!>kAU`>q?@6(>~E;8n(ClV8oy*#
z&o&?17%gqS3b|n8A}u?J?&lw5<5DP|HP?w~j1Y!_O5nk8$&#L}N*O#oY4skMFdV5)
z|8L`eboYy{J6j_qnuD{M*(X{xLPmOt7(3o7OyC*{`y`F(qIr*@?))!nEFNl*k(l8K
z7!lE8q;T+ic6;;JN9Ua(dhcmX@kKPZ(@|(Aao#yKJkW$Ubz_H_9eVtma}3{Z?&*RY
zL%{5J=G4f$;_^0k`u~He90d+^=l#&Oj7*5nI*r{Pk0_8Kpm9Atzp181m1M=_UJFl9
z!M4m{sSNcz?7cQhii{qB{pyNp@?o^T)Egv{6tknZ9Ms;4=M>42c~KQJImFZvEGrFJ
zy#(9oHyv%mDvr5KjVm)v$Cw#ZLdI}ceM4y;&7F?{pJSAsQ3c%dE%UdG;?v9_yb)a)
zEKnsS!%pRI($8^<TWv}fO)_s1fh7(Jr7@7axo{>1YzhbvcCK08n&9Z{OuT11&tizL
z-~~tm!C{K45?Gf<ZRTe4+5Eox{NCRpA}(N--P&~{7hP1yoL}}Bb(7>9`Q<@$bfuzH
zygiy!|24D0r)O#6u~1E`oLjdkgB6dKw!C4(uHk_u5vrLpIfZTD7DMYxB&Dv#TO_=4
zMJu$U3_+2IEl4LMo!lstDJSY`I8{|3?5$=&GE=Wk06f6a<bTH@!#vI4s`58Bqv=P*
zz6x{t#vF}e9U55P*bw0(|4kDmn_Qe?r+@a13{EB%oIrrXdYgj&VwFfNB#qn}HIh4+
z_YFW`a58}6y3#nNXr&Hd3bJ+*&&7K(w}!n8Rxex+G3*DsQs41IDgW`_4!*1GaV$;^
zR68m%C=9+RVzr}UR{PK7ZCUN7a~(|!k+LaRR*e4#pH*$kXD`7DpDF!xdi7GdZHg^x
zNj(miwXB!97@oSK(rfAL=&jc*z+LeQo>a~rA||X`OJqbtb|MSrZ~l%Oi{r2P{}+Ef
zJOT{$<gZ)xiQX=AEOxJm#Ie||`e`gSxhIQ#^yZha*k`BMNV=Zl!T0TO+5ep1CR#fg
zw@bO~j;L9;E0%IvYf^M3tJ!rOYaX%M`8erB0$22xT)0eZV1vFq;<btBV6{mD%3<Xo
zCenqS|HaHz3B>An;@<|s?3aT0{Ecwhxf)l0Z!wxuVX1UOT>1mh**qMsiP_4Q>8;Rf
z^;bwXru%U&RQTSga`yfSyrxR3o=@yOqzkY}!#6IIKaNqP;61@DG!WTy!(BCO=Jco;
z@Bo_7+RI4A^V{UM8gMcV9GSokh~O%^ylqFdO9Cc|NS<v_C+Rj{(#?iNc%ZbHMHC1B
zb6U({PF~b}E0GuPQ1WFQ+(Fs4@A2q8L|(|2YA9QoWL2JjxpR{#uW#~m>un+8D=)bd
z)c6?QuwRE|6B&Oz`^Dz$dCGQj;?N2H-=~DZJ=s0Ye{du(W@Y@B+*d5L93Z0o(K4x1
z_*h&Bf8SjK5O!Mf1rmwhP`}bui|&g=^5#qCgBp8c`Gh9_{&inApPj!jAI);lWIjzz
z7^aW(CRH`~Te*tK+<VSP^Bu#BPjAPC|G(z*u&efk`49_XFW|C7*^`k;JjL!Pk@u!v
z54j{&n9G_CTZaSWFlKs+X8OmdFk6lMN_S^SSCjG6;o$ITXZ0*}_`vXa^R%qvm~i>T
za9Q7GS*L1QFCE(C@9L^i=>;f*x7US<8ru5^tnunLxQL&ti1<ZsP-py&4R(Xc*^Q^b
z0ZFIPYO32u9QM0z|Nlv!ue|nU>p8M%d-R!h{V<W3J_l#~Z@RBN*VE{e!rkM-|6l95
z&LQ#(>nThWUro(#XFbQ~+jC<#j~UhrF*k;55WR|H$dyX$bM}0%p$32v-igN{0R8tR
z6ISs3N4%%>8?Xpe@!||0Qeiw{#8t|dK4#E)^Q;--W3C*IAbZ=pxQ2uQ%DRZj_NIEb
zBx42<Y~3)NZhq>WI7;1Ii@2lBp|lWOY0}CYa~y(gS2E<)kb$Y~37IapSXNf7GYcnc
z531_AS=AecW0&O`>-UjK(|S$7A7IcHT1EaW|4IjJsg%fXS<0`xx>V8n>8{ytw0^o<
zc6jq8dvG$Z^0*-V4gPcY;tk&`BOGqwya^=5gwmp!ijY1ietMdoV|q~oUzNRz!Cx7P
zuC`adj5MlFEg_A@NOT?Q2!<wN(iooc2e_}>Aq@&YZj9sr(OhqJ-N}%Wyf(3<`m=-T
zy5Dg|&-Z8tDH1AEO-K|rwsCsQ`Rcoz94<J6pzqcG(5oqDSUdCT5^}om2g;XbL37)D
z{)3u2Y@PoIetjXty%+A)oQ2wlEWb{&{Fx2Bxs5%Omd=59y(25VCh200bIW%xw9h<w
z*t%g`yADBajIHs?hjXObnDJZKI>9y5Iv?QHWxauI?Wh>hIrFQO^LdS+`*SG>;yQhJ
zc}d^7O&pd_ZtW^B<~CujYHiuHHFx!}b-`2!s>z$Wu_06M-%*TS#rp>rf`eL7H0{w)
z*Y6}?Hj-rN=qo=nAuF<P*E@I2)LWu+$wdFhs9wb*c^fdkSP^^<i)<&q>L8u}I_+_C
zLt)JTZE+8<yUNfu(Laay7l|+3Y5>FO^~^*hwJh9y-1~nM{W)!)un(J)gIg!;mY-;q
zaOLPV5%%dJ;?QMS`)A<3XTRogq+e`tCUvcs1q<U|w-@2R1s^u}x1j}{>E$*Qmo@n}
z@O#SShKzsird}9d?4h)F0#5VSQrFJ2lF!IfH{VGdO2VIvxP&LZ42q{xq)z}@GDAg!
zU&q%8ygxpcjjQi<(V}n_uEOqCg!O`%ED*o>@74gN9ZLxoL#Ft9EKT6;WSbu8vOogw
zG^$}GBVaTW{okV5Og;@Ok6-NSF}K2vfJBYTG5~nJ-OGx4{V^YxE*7D`!GAz<$M~d%
z(gOBeZ(esUFaE`Uxr(N?^v>=#?B&)iJLGny*#^I57bo+cCDruQ&sHtde%Ijtff)Sa
zvs!-lwP$<wUZK73-VMP|4D3A>E^+lT!ucgfcWSn7`JB@oScI&MGi}muzTQiP&W`Y~
zFz=Sne=aPLbIPr*!SAnulvn$kPlB#ju)OS?{laf=>)SF6D@*s)CIA{1^Mlq$tjL|<
zjh#e-j_mHO$C8};Ojf3K%i*a)lYY?SRQ#D2(<8ZPip%^T@XLtou9suIK?gpguOvV{
z8tPZvP#Nd^_OEYc4qb07-rDtAxZgzbJB&YhN#Q1wpfOD=!@sl=age{}HHQtJAtpc$
zkC3F22AbDHOQBTM#d6-+tab}klghtBnGC~y)Z}mYL#{NA0UtvP8GjCnT(OT$XSUPn
zc!|?oemxSSbyLrli3i2}<HK<vQBwJJD$v(^-nG$z#?;l97zTT%u06wHu*p9%tYbld
z)AhAw{SK-8gR0%K9uC#Wtm9OE0>xx{(|`*c&xqB^>cw&HXFFZ2*e75U<Os;(XZ1{X
zNt8F0w*4fq+z&#06IUNeChRp}yP&f+Z8Wc(%X4UTaStDhFL*{Z-ip+Z-_p;~KQR&-
znSEROk8oMKgOTC4P@Ixb5$ny3+uN@O>-F4D#AWj*tV6iO{)?z#<fs<O@5I<{5ON8c
zAGUQoZ?<-w%6QmbAZl-?jQ_Gz*@`=jY}t^StCKIM$G<R%jQ@wI=>J&BaU)wQcyMSZ
zDB+)0>1ryGI|)1Epe5c8{$B<$f1DZ5dSlA{CiDUZrS+CRgYaAWndC{;W8m!av3%Jd
zE%aFaYVePaI@h@7Gy@)Y@ztm(z@oX;+lf?bwbbFg0_!_knC;=~^kU<JV*0M)^C7B=
zFZshb2y*C5FC>(i*MOc<`V@c2u&rBXw=5V6gJgHqd*nk6V}|97e@CZ;Xmj@sh(XDQ
z8~7WUknWyT?4IJEg*?a*kHtqlVMIQ78{7~0+ncIuHGC5-dW{2dJ!Sk11*e_Se9(<y
zYc>2$RHIi{<uwih7MS8EUgH8UeV2daXu}``BWV(Ex6zbmf38F=srk!hf3D;zWCwgO
zzmDiWR&`d(gJr40e16UTTq#=IW;6S9O_x-_$cWjWE5}SKKLb0;?9cs@-%8pOeOHp5
zRQ@)DQEDD;!dYFV)WM&@e`kNL{5bA+Ys*5I@?@Y1U1<KD7U_GY2=<qqn8^if55yY@
zE_)>_Jl$}0j8hgV*G$s`c<=9>UWEVuCDVKp0MiE6`}G6#C~y_;($7t|k+;r1ljq+)
zSLWB{YNL5BjAwrfzpSTYX-d`V#RkFc@F+xoymkGoQ?=;2tCjKG%15z^|4{P%2@Qnm
zL|^7A>RAYayBFBi8<wbvTQ3v+LD-fUUC=<&XyFSU*UZnS39oU0)|MxG(E%^2Xle*Z
zUMXYHXLQtc3qMxs#~ivI`dd{xf=XfJJ5|Eq6^KZW0$)_aK6K$e&@a(9yvgh`m`REc
zd%25jyaaxv^0WAJ_DC&r?mbS#*jI^O@n85vcZBl$vUYgpk#?7oXr7TiLZ=h_CttBG
z$;)jb4QR%Hls~6T4jKGzS4Nltw#GK<v&m#{mI!m?XrCBh6t0f}e=ExLrEb6+V}Hc%
zm~Ad%)gDd}6|G@^AJ=Zz^(@8XjKXZupkb4KKkb%i2zU&B%Wu9PXVkQZ)#}eeOe<>w
zLBSfVDwIwaWKpPPdi=j4<K=iT*0E8Ozv&nR$5f*HD}|y*s3StlElyrB4Q}Nl>$&tC
z`ft05|M;)Md=6QaMwW|{4MRPkR0WS9;h^;8>YXG5BC9gSX{pP%Cy#~<+l=sb&(XGy
z;G&8$c6pP}3dIv*Vqb6cP`%bsxPy`~H|D~cRH0w;r<Ysnok8-t?8(Dk9@gH~5BY9u
zpB)meI~l!@C6)f~@!v^5IT8tc9g#u;b1S$mx3>6<Hp&^$iB2_^=<yPcsl3E}Y_Hs%
z!`jJ-oLf7L3xH<{WxG<FzIF-sLvLTYKh|p~pMA81NbX+}m;E!|_-fv_99M4I*E8DF
z^RF;&bzh<GuPpcWUBU;HiJS#4|A9YRKLPAfejp&9`X&-s<5>teQm)u-rvXgGWQ48Z
zf!isJCi`RZ`IURUzaim=u6gMsapr&~WCL$|U)bC2wJUg%JT>Qe+RYC4(gPvdU&~6!
z|Ja&}A2MD&bi{Mt8h2eMo0Go+Cc#P#BXersp_tpCY36QrJASdi`f^|>85QY&?%j=#
znMtjmGKblk%y51v0QhOfM!+f$+oB#qYmJrl{_o!mw|pL4TN|#eH;EbLF0^ZHvU#K{
zq1^t=rDDRwdcV4tCR0Uj`OlfmJ2aUkn0KH~KyQlJzc?X;lO`m~d8hvoXCMwMnoxT@
zp)fnWFnEj>@1pCD>E@qH-Z{qhkZYxd*|}>X%`h5ku7YFZ`KZJ;nBd2Nc%l{(9WxA5
zfByn2fSzEz(8NyP4Ii}qn*X%ExYeI?ENVfroD>iIeM#|;dK53cE~-j9s(muWmXrSf
zW9@C=qpGgG{{*HQG&)hEqD^a5+M>k@Em|U2hr|gH2~L7Z5J73L^`@4#s56Q$!9Zq|
z;{l`=s#a9mQcLfpx7>;?;9C&tpwfz#Dpss$ecE#xT4U`+e7W-f{?<M-6VTr0`G1~=
z*33Ek?7jBdYp=cb+H0@9_WCUcd>O4T+ofi_i{icD1692}n5-#2Z?^?KP%c`1o*Yb!
z*;9ohT&8(m>EGi$q9KmON)=bYAtj#pIcqFO!u3{)G4nc-g5J|>xP#{iLdOO%?*IU<
z53Vc%(0F@@8Y!!sp-wqsU)*SFX~B?mU_2!4VO9EFm6)yCw#1jYwSY%>jpVk1(Aby8
zS*B9wLeodXYN=rIZ&>OzTNHCR5u7sHus;z6gvc2qHwH)d>?)@?lafYuZA^T+*+0T~
zSc?a}MMCI&UXeaowuML@8p(LAHmYEm!fud4+*J7I)krmc_SQixAXRI`;I_Vr!ayjf
zgN1>3l?R1^(4sEei$V{yakcU6ef)Y)U%sT_)}yk|rK`H%txX@gsQ&G7<?&nU_@q;4
zl32x{5b0mr#Ko<`?tIose1rr{dicW77gebih7woYa`b0wplcVzz<I=+762vb&(sF>
zK7$vH+V(eEYkRx9Qo&VQZOoDZ@BOI#J^RYyxlf92$(;%0xxz|tB$ra&i>{@)V;CXh
zZ!Hf8Ys$NBD$J?MA)(+eG3wY(+QfKv18?e@sR;zZ5#e=!;XD8@oEqo3XKZ-}^U+p+
z5TY)gy@%XQ@vNK=JL5C|nW;_+Lxy1E(RJI~OR6Kv4MR$-IEKC*I3_X8WDWz7J&7-H
zfN;8oIK4_B2l?-_ISzr)^Ep0PAqF{OVmyZiPoAv=&vD4*Oh0d6O?)(Ncj}70HJMhN
zF178}T8$1R>BQ7bU;O^B>I-h_=$iuZ7MME=T+YVUAryprL6pg|yo6!T4O464+3WSy
zb@p3Ohf|$Juv3DgiP&dAB`&jy9vEM^N(I_BKYAiVPLoLHV~^JIi0rzr7paUTt^x#d
z|7pO~NH^IJ2qhsgH&ad3l8|f4)ukF{e`a#wN{*6E6lD+1=g^<fH&D>|P#Oha{+mX<
z=6ZBs>WF7`>>5gjz5GJsMVbC!IQzshPiMXu-Y?oQX`CNJz{AKG-=LafV%_2e6Ki%`
zESA$8#kGNk{x(YI2Nt}dtZ%c-Di&YF;w|VXEIDj=bXDOP5WZxn^xG8~>&HnfPv?*N
z=y?>jaIHzK3axX)?bHpnqxQff#An~C@dTQ{@iRNIF5;fXyoI9AeF`?>VhBH*GK6k+
zIr-y@`k=!4S-%`m&o@=iB<jI2po3W_Q_&uLj|dj(O7jKzg!N${oa+Aql^E_i>}1le
zxF}LL8Sgmmcod2#={|lzvOQS!l(gE8RB*wLa&90(c?3SJyl1@HqHtPj3nBx-(Zw+c
zu<$RQ%CgN`a+Y){n~BvDOgQ`E3r`c#6;*6x&#na8&YJS$_RM=ij28aDGAOV<JZ8M7
z`Q~m?oi6fKtXNQTgEFV=yLEB1)%B&(s;erTW!V`98m=BMq4~MO@^srFybDOzX7BGE
z$Z|+;h0CMDr>n3Vz?bYU3}6qQ>&q78cCzZxlQb0I$MOgoC@IMeQwMMj`<uc>{EU9G
zmDvQ7Ib)fFXw4O)dbz@4OK>RNqV9SkoJY3Ew?{T!H7n>EY-V0nbR2X}#B*1WYyEX%
zwxtoXeeFzA_6}sf4pPE1V7YkiV@60(T7!%3va9R5aFEHQQT>?R4z^L3zT9u%?u?4y
z>wSeL52nfL*cnx<)DZC4w<}up#H3{eoB5A{J-b)+EqWC!*S|iHN1r+aWLDu8W%F4?
z!M^*~FCCcaN6Pd)GOa&%VDe%m&r)*Dz~pO{+(t5bANx7$P?bmR5fNF|Tt<I@^{71^
zMg9&`q^*B=AcQjn;Zz`~fsDLhbKcE|`A|31kb1?@LG749D80Jsx}vpnH3Uv=kO0(R
zdT^vQT~hZ&2W3EYc~S=K2ewbaxR$BdQ(s$^J`u=^>W7+eD#tTp)N}2@d2XmL`s&_`
zFPX7PRZH1Mc=f$v@m+d$SFmU4Hw_)tE1j6&VWau4BE|i?<7^-2$xSkx?XUk}-}Doc
zuwr@1*Wo0ud8gvA!A5Vu5ay-HdDzHdY>jxt!Xqv4U=kkv$q5+wbrxzZ!4*fvxK()y
zJ3aoC(Zt%QAPj<kNdl9=l;97ai{aW3;}AR}Jon_>(}~bj=Ev@o4$w5Zfz9{|Dwpvf
z&^8VGrLF+E>!!wT`Yk&ST;ws$)|Q7Fr&f6FlbE@p#mg>^mfK=T+SPh+OPsAg>A{Pd
z7@~Zw8uc7oL4y~iSiUw2r{GY+@qs?9FqQj(cwtA0J6I<truYrejnm9CUPlT{X$ejQ
zm!8cvxDbJ$kgKJov<61<r(zM9d(NnrmRNIIT2g*$G%#8l<nLFY%q~2*9RPiTRIeOa
z0HD?}O!~>H*5j$A3Qo{>%o%e<UBTI%>Ikk7!n9>t6;z>%F+=?qgNTyQT80;u%u&+T
zf08H9+vi;^!3q05P+;aM73=@|P!ul(6YH#8#{&GCvr&+Hm3Iw!#p81m9YJ@MTVFDJ
zzALFk=)=iu;O<YALko>kx2ftwij6X=#1~HhWYo|9gfRIL5n&22o=_W&vPPJYcuEKO
zTj_jP+ggeGf0%l>mJ{Lhd6_>4)h0cn=bR(18O^moNTT4K|Nda#`W-Ygwc!r_V%fQa
z(HPxCtIkWVD{#=|OZ<cP4a-%opHdbr6AEBUd2k;<0uCyR=PqGzM_^V}WeAwLw!nV(
z4Jj*wr2Ec^FTNc&EJ8r|Emczc7hjGCq6>5qvF0I7tW4Nyd=9RhrWKCgILQ%mqmdu)
z|A4+V+P4HV4u?TEO`X=^PoNuc5+Z+B&_Tbn1oJ*CD%N_9lbA|_s5f?UCx^sw0q6+c
zT_(=mM9BMzD$RTUfXFF-?j+{8Kt0_OoZ}cEqCxmuGWeGgEx~#I`jaQYDPHp~W0omk
zh5^pYr$}${+Y_xp8O8kut&Y68lTetx6#h*I6s8y@vPYt7pu`>Cb3-*NdEH$o{fPl5
zsdEDvk%Am=R>^qwLEiTyK0heEks(>le=L{9Y|V#3kBw7lo?W6GoMt*(Ro^;NgdFOy
zvi*W=x>hN<UHu)&h?6;l{UI4a7nWp1M@uV`i}UG~5(_(M)J3hq6{<41lR5!BLx7vt
zdU?SeUuj|P*dQt~Mqe$%7SGiJ{dYqqE*K%Z$cWQO87(yVdJ;pdDf4VZ?7l4}rpbOm
zWP^vsS3_IlEAAzVFTS4A6XT0FK}e>x7DIJm)D5hn8Ygv1_!(PPHPJ2f=qG5&hw=Tf
z!&l?SP`QICjaaILx~eE_ioLz##K$@9*0wJ5vVRFIf+(6|6u1EjP`hK8-vHimmqmxk
zeIGyr<k=hKrR4>F>Txrt-_E>4Fj~lYc!VAoWQ(3omTzT%|Iht2g?>`;a}HJ4Y<6Aq
zI4?lqBEp`VYT&SH5%JPmk^OC28jWxBeu<?zA3!oNOp*^fI-N0Gg^~4JAR{dh?MA7u
zKW;sjL7!0^Q*xstTHRL*bxZ6``CVH&tT!Gt9BQF>VW^#lohqIkFEu+!fZ0g{gpb?*
z)@aD>fikFcD0L~OP^OR$H^dj8Wb_T6=llAbLD?i)aK{LfXX?N3bBur~9mE%LWAH{p
zYlrMz;zEe@RD@G<2gq-C+$knM($UL>^_k>^s*?=a3r+pTReRll*|sUZ_%$jt3AEKU
zH?GRs)=CT{`_;JmYWS|cz<eu)d=&HP1Z>0+s3pdK$D$DZ@A$7j;=lI}8Nh#&c`*be
z1^rgmoblWs4UZH{rtmY6#@sC9*|QO4a%7tm>#(jTZVzhx!;WUFh8dLs5gtvxiSgTx
z)uQxLc6x1&!7%!1!}D7*WB&7TGI<ijX))>eUqY-I%2Wxli!}IiSxTcQv~6v58b9ne
zW2+lSPq=pA5r-I)#41$n;%J_1wZAEw<3FvP9xuq8IY6UNqFF$FeffUq7*FP8!fZ`-
zgst$FG)kKZl-YC0INS?-JW+g{+h}F5<aS`BY!BjAQE_}L=*#+b1ukXYedCnkyc^!k
z$A|&9ImUbz_Mno8$f54OM1*smNoQr~)gbj>Qlc5r>%t~g%m@MkV^D1Uo&8JSODiG)
zl9PTN&0D8YE~>z2_*2;o|0xZ_SM}M552q8;pSdsdsZhSB4)p?sj}d1VrMg`h)4Yue
zCQqW(($||Zzlo~t`;`+%D;cekINBrF$%pCdmX;0-?yZqDa$@J-P8L}ZMG_a0D7wFb
z`XW*EtMDH9TGFCyfV2=v`cE)E4p-4=Cy$Q+mGBLb#x#<!n|CCj)i+QCs`TfhdS^%k
zPI0(=j(Sl(IOGt?%NY+lhW%Ip$w*!bKslM|uJBpN&suOh!%fM5IoKr&>u5CU=$*OI
zMuNE5vC=}1KhatN65(3%Ns_@ZV$2ml!sZCg+IG4L;BN%fX8vK5JYua#=ACKjVlDM!
zc#^87Z<+&%|Dq=4hU!^P#;U#-F-80{@*HK^YWx}MmWVuY5ZaGC1?K#dwV}rEQf7pa
zuz$_r6uu%MVpD2Cqz&hbO{pT+4TL6eQ)+mo&{odo-7Qm0!}@@a#hfjroD1l2=|st3
z3Uk2)qg#AD)>)ld#TOYeLxoA<Q_78@b4sNC17l7482&G;N1w;{b<D@o2S;m8KQRk+
z?(ZxGdIF54<=6f>U!M?VgGDTfyvBr7wp(~-{HB7RY#fZzS3`XahH=;cq^?bKHU5-u
zZo2OIxUq%T0BCkHRd5Z!V4x=4Vc@uxDCPK^H4NME0gD%%2A=s@lLzF@H%?OZ#$WID
z4pymrV?s$GXSZ>wJ51h{jL<2a7Xqfmxmk)iPvtXGy0e?)4O$fuJ;3Y7tuq+pp!cna
zwiowbFONW%<iHii892LiOJp#q3d(nJx>Y+H9l@`EDHjB0!_FtEAQe2qJH|`4tEjyE
zDNU1YJD8;+T`qeuGcE1ue45<BOfr)VWfO*ujQmaLGv;?U)E~V>R=2;=$XgE@_f6u@
zAyLMi8qaRySBBPq<JWs@RBuO$8$W`Re-Rlhy2qBqv$k$;u3mI?xzrIk8r<4YuEIa%
zanwr$Z?5wC)&Gg^F=d%|y-laQMXhyhRq@-VlS3%(5sHsEsI61j%-;B*ZDv1a-YVOp
z>NauhDnT(@f=y8Zc7vB}Phg;>d?%wn6|5*_*=JcwHWJjVx+Lx@a<gEQh=Y0wb_wd*
zcExk@85X&Bc9v}riKhYO63kDRdYf2cPb$Fd|4_A*(ZtfcRkI5sh5fA0onUcb3;u_N
zWuc=@?saNX%m1#HZ=$v8oK4~JVj)A|6g*8*!HdzC<jzo@Qr&aQzm-nk+F0(rg?`h3
zEA*k>j#K)>uLAAzCF5>PzX|xhKaaaH^O7BHR1J?n!{EyfPI#ZIcF`r}CUt}JBKY}m
z6koc}IW=x)#VA*zSNMWH%^j4^+}u5PaBccb@2xf8>YFdvuL=8)m2h0aJj=fRdrO7;
zCkpBP;mbg9&AO7K;oMiOPfx_)Mw)%=L3X_n_9nK=Bq27X>rH=Uz2{#oFW$qbtF(>p
zH?T39u2fp!C2WB5JcVm)j_$_c8HiXGH$~#*qxSPT@8Boq=xVv&Ak~0%jbbnmVQx;o
z9$gi#Xh@UFWibH<NLUklH>CXurAn)dmHLfUso+=j$fUMF_4a!8wM4t<VwFwcnttzK
zuVbj+Fw?uX#+y))pP;jdY{(Z_0j#eWRy=h@jh_Xb^(^<x-p4Z46}<KD<~Zu@SU((Y
z+|b6KV6Qwix9sbChyzR&O88goFiQA07mwM?x8pyDhx9K0g0!EQDXGv*K-Jx<TH{l@
zd_C_DLWeCZ$GqQ^<GC9s1HQ+7o&JPb7|*I$E3hRkC)dsAIU?`H;;8TpVERRibQsTC
zM27b2vF%my#daX85l3mPn*Cno{DjBLL5TG98MX<gnDhQMG4{7Euge7K_MWa?<(b>}
ztL>87DZzJLZGB7p_Mzzebc{c>23_gUzQ@gh;bGFD91%G7UNI;bE`}!RNal~Ukr9IJ
zYIlLYGGkqvhNigX#g6nEs~5%OAc^lB?Gi&RbnN0aR?23Ppfpt7EUF%XYjgy#@27xd
zimLKEX8HBCSZ9c)Ky(2#gWU*@-QjS`sVfJBKNP_9DfvdN6U)LsgX8+y>cR#5!LR=d
zCrEQNbi+xm))lJtZmdg%bT$O`^&Pfk;J<?Z=qxX}R4#Hb?JWN)dbuXY#>ndQHTmQ!
zwXg3u$MrN4pQpM>OWr5wu@PQ3i}>xet-+VSWL=sdDy`OI?W}ItAn00NH@5;mmE_X8
z+39qAeZ`~TJm?`XoA*g5+q~3okNM;0cr9tKG3H%4$9tZUwz|a7>g_@4&#==e-&Y1l
zlUQJGmCj(@Kzm#T@!Yr6w!8eU)jj8MB`$lloGo0_bJNt*;@QV|@sq1G>3dq(HV*aM
zal=xqQ;uo)U29KyiZv{@11|0%K#KDHK>5%?FRH1Vu`a&oAicJ&+xXfb1w^eOY+F2g
zsT$e*uwUtG2rSoI7t3h#boD1xac+yrH+cU@q?Bq&RT4n#VV#^4`ze5K8&(a-64V_h
z4$~f#YL>Kyq9xH3feg#l*h?7tRq}a3w6Ig$RLhZ0|9sm^R;)Nbx%`xEV;gGXi$?Oc
zC^paIsvNB{vyHZ3-iC4clm1y)Wp%dLBBfW(7y4>oVr+6-<_-URVD41fc<fJXD)pQ*
z6yt;lz&t-kXWuOMs3)V~)(QyHwZ)&Y4Znkz{Mb4g?rn)L4k+RMHagVZcf6YRb7;iT
zifuicVqVwQx)<VEw5u|Iu-}Yi+DbXUT;&t7;GpLq!rpzECl$t;7-r}stJx;#*&B;z
z<%!U<_aN?$QG*+CMQ|if6iDvjiDM*3)^w)fG<A5QDm1s9<kIzh8a2j&`#x^YC{*I?
z^J?s|+zU#DQ4}jS^%y)F0EDv*P6sktYUi#;v@N=MU?--JRVVJYPW)%rMfZvbXIX1{
zUGVPHcqw%@bfA2mW--8zw0vtdxSYUB)N+6Xw#Y{F5wQAXGQzsI>3x5EmG_FoS`#Ms
zjjs;c7!K08+O>Z33ZGN7HSE3_|Gy?Sh0EJkdDT7Pf7nWEwSQix*Sv-<&&h5BORlel
zYK}xZ;YW4CH~1obYf<du-uN24f?_WV&6I!LP-b-rJ-FXm?@fST?9$~6Y8F-BiKoV*
zjTCOkQ#C#Jc&zT}%->zrT}zSFoQ;Mqxy#9;WqoHab+bp+IMfXgx-}8g!KEXQ0XK#}
zl^_AacUWxnygMYmcn0+Hww3pKTmz47NA#*GQOX%Lm_)~e)l3b7uC?Cd@B0_j7@fQq
zij*R}&~a)$m;9Us6DW#9_}|tETR5FukJF9c5v#-XX3_Dgabq~xb>0<K#XfPT>#)w0
z<<(YV(%RIY-#<caG^FaSE0+4*-Q*N!v}iCuk~<cVF!qitf8&eoQh~Om-n0IECHS{@
z^Vh4HpYZ1CJ>O7?SODpz8btNuyuln(A{;B?jGZCQvBexaF?NIU_dd{uYg%n`IOOi3
z!J=40ERr`~4a$RQJm!1uB1B+_Pt+(fL3lSrf$@9BK%f!833md(+jt(Fqc3dAwHS%A
zQbld-*w`E}gmxchHKHxCN?z2~?<1htQ(GFG{493CRA<wNht_e`sucMsZRsOV71(4N
z&)p0%7HE|w?RQhkN|E<Z5xtvN`dw?h=2d=bmRG02F+P^BA4=<x@Js#q3wcoXe@MC{
zm-<Vj(vMxTgun5{7b%fkT`ScgO7m}50dJf-MDL*tJJJkpQ7>won0k=%Z|T;1Nk6c6
zG5#kZ6)M778V;B5X0HtNqs0dc@~Qs8QQt5OB_5bHsODu>(6%1|HXKZAs`8q*w_HI~
z5A>_~I-HdXp1s8Rz_{CardoUC)-tSveB?G>Q`Xkt{z6uBNjWWQ<@~jLWRg@=(<kR9
z{R*6mD|#LuG`4L=*B3FWjUD&xOuyf?z3#?u$1;Crp@^}=JHK*#JSTsJkS*zbOM=h7
z!^u=UT^nk{pP4ywS1@Pq2gb1ue%tooUr9g{YhEhC%@e@~5N@6b91#wbos79fiSe95
zb3?mYN4qub5c$cK!8+UpB(v6IJrXNWSVEJIbA{)3t8n%pHM4nXex7=&n*Tywg++nR
z6}&`cnxis?1@7{E0g3!ALUK6&S*Xis6ov|+2|B}==7W<#Mo5eXiBY|zPEzV&QR*j^
z`s9XA5FgbWy#1C4(o5C8B)rC-<^tE>V5w>_^-y4ofNUYVK+F6?+WXQf7(xF@a`-+d
zZ1^)NL}yx|d;@rCEe9Q-04h#C=7cdomO3B{ZQLylW(mj*bYHapP|y!6S=!*hg2h({
zpbv7w+`n`d>cXClu}r7mP~#_<pxMY!&|_21H6COF=;F8gOJ(UfoC9-5cGx4+7&DE|
z0_QELrkOpj;?}l_%q&(bIPuIzT2OhvTgEn2<8*xD<x6lW+G|0C&y^lIhQWaC;O#gP
zV!~+JR#em5Dlovj^2ZN!Eba(Wqw}DgH|QUne%0Fx-M(OjnQ?Xk3Ml{iVJHnFD8A88
zOwvG|06+JwwW6a6MelS)ulZ2Xs0mkBw+BC=30^}rQ=N$4RNM39AWze@I|0;HIVgQ8
z0s050KgVD8RxY3#oUX5~4o~Na{%a2oz89;^r7A9;yYp+q=jdfZ;_gc;E)?z_?Lm5F
zfliuIQ?)%$5w22|$SoIOuG7RzEOmRf3}QU;QSm6OhGjo06z_ZNBkf7-nC$l2f_(iX
zKyZs?N<Vw*Yw2%}FO~WATAdsVtOEZgwRkNCW#`N*+U-YWs1hLjDfT34>3v_YbT;&(
zvTBSnih(63Ze5j;3TFKf57(%!NQeji^&Ga2XE&333473f2f<hRA;4&6eFWKQqxLMS
z(ZUhW4)oIfYU<E2oqX(geQm6}w&teaxkdVsJvUVkO@BV<+Qn*WLajdIXOW*!VNdlp
z0%ou`0jIIu-kckmta$$tW;SkeO2ybZ&r{{vPg`Euru>>UjUO@RQWdq=&5qslV&5{_
znXez?Dx$@sSuK97Z|D+lhd(qpHh`~R%DhFx2@F`wGp<OLgMNhhAfn2+;`apKKlR}*
zN+?4<ajyGm(obm^frODg%)%;$Q>Eprw|+B;_tE@<hmgkp5Y4)cP1Nj+D-VC)dC@jb
zEhfFAq0h*;xf{r&PV{e<YQs|HG)^5@s?luSgpZ(^2==J5-=x?_{=I@Rz;d@(^8{W-
zXZqhYY4qIO<8bx3S*f`7Gz5$Aw5YpRpKc0O-o8XEESwtCLNoXUKC1b~G}&m(983D4
zCCzb3vq?JM?T-RvXbFG<k7oM(n^%&LJX8FeSJ_iM_qt%+yxQL84j=VWfj=y(PyxLX
zoVt6J^QKn~M*%B+auG|L{kfgFeRI$BhmI0!9N9ObuwK86^LW@6YivL1G&jRdD3Pdc
zZs$$E7uZWKD<%3juQkNd9}9f!Z2rws6Vz-nrh?%teT_IHNjgkPMJt(?sqhce{1tJ~
zzE=^$Q$L3`fZe%xa?%zOMSHc*3r8;KH&Kn>Ag~AHoW+p+7r$Y8v0hmMRj+JynbZ89
z?gEZ~=BR<1(2yd2II4^{Lk<iM5gjw$_bSs9V73M`IF^}jsG%ULbFF^*erau5yVAT&
z`);#i$shJVtCT;_Ztt0bt3B&u^`w6uZesD=Ha&JAWaC*ai)1}vdb>l9_(o2s2!7Wu
zD@;E$Fwfrfw_JP($%}?zeq+pxN4m*uN^mMs>(~u-i9<=aiv+)MxYsaT$CwoL>5IqO
zh>=w5&796W=}(qkT)xpK&*W;aad^~5;;Tx+LyJ<p7Zy)_M6z4I>@g<LHvR;ASwlp~
z4am3tOT`Q?lrr=^xPDeK{jmY*_c(ql=nFcJ%>B(fp!!Vu(Z#pEXhgIUC{U5BXu@t$
z$)et0$L0z7>-P`6bp0}$n)vV{ZDigqTz@?8AZuFR;~X;(VOir8<QAvtidR*gRVbgi
zi{!n_P?i*K`Q&2q{JtMsU?q(9Fzcb`pg>tJ&eb3O8P{L&>>ddzbjeQyzvl$hfGd6|
zGKaVc&{$nQO!HTxwnU^c$Uz*Z^xbUW_>Hr%V4@YU^C#WJd?MM88l|GOQU0^kiss!i
zzN`|U@unr+qsJC*Dv4*mrUifFY}K@yM~sfG!L+3jed5_Kn>~Q?>2Vl)FT$53^98>}
zb3b}aJi9AK=?O#ka3M}^JI}iG;a!&NG~sB57N5HRF^G2vfpRez2g`W2jml;1l9AtC
zdHZpU@x?gTFMp>{dG24S+-@VHjndHEr83$F+i{}Nhi+29weUhfp|;o_C_xD^26rrX
zF5Y&y`>VpTjo_@b?UJ(?%r(Q<N-0Vh-z{fOA{Q`-#L3WM*uUOFPJARuilmX>K0?<F
zT#OIp7mHYCzoGF!<M7H?J<TY!^t!I->>S=Zg<Dhp0*b-?=yUX_ZD0sf(>TQx8+Jx}
zd&6WiCkJ<t3LdJ<IKgu}HapzqVt6ku04Azs`^PLd6c|zo1&Cw=x9-k2UIum9k4($m
zVhPXTcliUC8hsTcy6g5LeSgF!8z96!ce#q!3U`!pZ7SuO$Rm9<m)kas<42Wp?JeaJ
z$5Nw3<<_`3w3KVQ=57tic=iME)acRmCCc@`zFoj8`$zi}Mdd=6DI(z$rO%r+yd97q
zJ0L~oSy9ZD+pS!>u!zHRE?2Q}*Ozh~Qb0R>DacsEM5L*u91X=By2Q2Es547BY#nTJ
zMvPo+P<1KCt%6|!=}?Dw?h5)Vn*QlC@UtPIJCKc)avx*#boOrKTtpd9MhbZhN5oja
zq(G}2i>rO%7x_~N9;G}A<GHMmCzG@I^ap;=6u!rEKNAc&&kxKaqPG<DWVO47w2E#T
zEf4PRHvS7gC4p23Kp3HSe6d(gBQsQp!~>hK=e9x<viBYU`m^^r&`%wJky`awshCdW
zI&^}s{ft`7l2i;m8liGqF@Nq!un2GB&w=QEy_hH4QG&Vb-^ngVUJKYf0po~yBdlMk
zxoSIq5JN{WUqn+yxXnxv#As#DiVYY)(ZodCe@4Mz5`LGy_1kA-D2F3|{_ehgYs$Tr
zDs%gXt`g>5+(&_EkVxNcLPMq(Mtl=&&=D*<L{zEuuc`7fJHxN2HY#e~VL2uJr*uB-
zM8jC@`UsLfc1TDjODf9KIn`x2-emxDiKegyWDcZB$Kqo5T+e5iH@sM+bLj2p{09V(
zv0B0hLToYQs=_ItRhX}*v$FrKM*2Pmy&C<tewm2gkPzT{L$)<n<df0^%R)((qJLs%
z)h2`js!OnKQ2~wIZ&j+%L`N@=oQ94)POf$$@%>vV*HMFuxwPrWh#gvhl`ZAEUV_!Z
z`UAC-%Or?uyrh`R4ki}q(&)s{Ii=4`Bn2Sz4ghjoF;^~8$Ylb?P*yc>FDy1JTg)K=
zQ*8S0N;y6#=Fr`1#Rff4%3+4yYldohG`vWGoFetWZ*+kIPEpk4+hm5(oKn&66!T|)
z?Q)r%6q2o_Tz8Zx7Rg+HWz<I_O1b6<mTt5y%G~00x(AhVeYa4fk;LSsaC#m0H>dOD
zbPb{PPr4{`h0o)q9O+^Xk>tceAFn9o$dRKn#RrbK*~JWKwBBBY7{B{C82TD5%li&R
zEf2;%i#F_t*C#<O#z=F2e2FQ}D}YTml{CqSBTg%R8$sk+%FE`uu8u0EpeAL$kDaFP
z`>;83k{Nn=L7$|SP`ADu$Y6iCwMd2gB(R1I6j)R#A-JKKC;NRqm#Q6Ks5YLxhUN!f
z-iGN-()Ykx<`g01>Qu{<EaFN5E~!QVE~gYTWv7$LZydpb#A{m_soKRL%bID?l-Ld8
z@`JCaV+eqv@U*r+)S`s8Rld7Q;Lqy&qL9`c^H&a^S+_@539O3rac$7N`K}f&Rek?a
zDiTrsmxWUC>}$e(f>tYv$owXYQth}u@s<feFS#84&#jXhJ7E?Wa$0^zT}O31t3ym!
zFY^;F6#AAlgZ}Vus`9#)hph*6jmX|ms&mPJI(J5O4h~xPtMfwD*)a<qxRVV{tKcGv
z_1*d*LjPq!vCsdVSt9&0e~R;E)ZizId9ss%qSm^mmIv?M0oumT;h2x;>xHF~Gb!o)
zzJ+1ny(#a>U<szdsHg&u9>^vwrK0Eaxo}PC#Nz>zTqnVTzoji=jtPz?HUf*7;3B_y
zon08TH~2aB`e;Nir#RPEGN{}=rEe3E(0wv3m*x<R`#Fn9Ko6}`&{xc;#T)p%y{&dH
zU+^>bOPK}3Nx&=EHx8ThF5Wt+7KW7Z?cF8V=SiU&K&t+0i|suO2nQ1R%cYXKFV0ao
z@PBB9!k0+;P~Uy7RAg4E$d3D6kyRueNYwXlE;fBSpVuouHgRhA23H$dw~DNPM&g6F
z-@(nXTL!vpxbvsq6l-xvfB#*;wypWHBQ+G+_Qs1pg;}1^;M)d<2Jgq%=tBOg!mBV<
z;eEljzv_HP^SoWQQCyE{d^Q)+&D~|yZnh;Eo7N0eyYOZ&@weDeqdUU~fq}paXQKzu
z*S2Ej99~dS0`iKH1QF5s<@=aHRK;I%1&ZW0@)c=8Sz9ox?AFrPAM!PPo<HK3PXs^M
zC(B<Ydw$$;tvjmr8qDB(?o=sK{9i;we2bE6$$quV&i<`iDs!0FE+(KM9&Nag6`J2s
zh06*I*3-2dd+#KXL}DYJd)5$JX~Xz-DTBQv6zp>VKc;|7P{c(o2o5jc63@AL4|1;o
zvvWRz)URcWbl4*~*}TR`ZB*7S1(R2M@G|ZnkXn7KjcmZJriJRjuT#cC3#?8Bca%V7
z1*(l8l<BxXA?3XpeEnED>2Vy6%#ff3YjSmq_iW0-w?K)=kZ`W8u`wi=1nrY-bcO_l
z@`wxxuPAjq#xs`xJWBQkHJC9e6s{*hW;v;eTH|V$C5jYZXQQ~vJmMifylBJyRA%eW
zhwu>z?u;^g6-p=Kx$*Qv_*k?*$@`D={<G+v@#QX7o-jKV+}9J4FkO4V)u)}h_f!=H
zAKzoM3jX87ZwUMevvrVaZ?K(%xeylr77??L?KD3%uIH(8FEx&-&(qm@<~Qk!esa6b
zZ=^7fD1mU}b_2~9N)weB`-mboTa6J*7yIlDj@G^%a~qevmBz`g`4Re=yQu^n*KW?%
zWc)<&%RFkMj9nh9@v*w_C2lbiWCz*qqV5ZY#ig%FX&_eiEt#xTc6RA2cBy?~yD2HX
zT-4e-6soY5-qTy7aitRN!S``KD~XRUjG&|czFvqxz6XyM^j?}I|H2X6d|kK$bb}hf
zBH<{61e|{=x%SkbjeSF=2^i0sVwZngbJZ7Pa4{2;OE^6&Do<xm(T$jfg0V=gTQjdX
zV&0eP#-S?f2V%eBlhSFLtnw`=<&&jD-=_V$RKt`l>Iza~7X!KZJrgSU{<?9{8vc%v
zj;u?-ouKwpR>I-0@fBy(i0^gaODz6QfyL7-OWK29&;lH@jG>l?KLrFBtxj#&OE$@y
z&PvO6o3eFSwzlQr%_d~l6laWjx9E7PyU@yPpd5tDl6r+0iRWG*A$-Hip|aY9#`z;x
z?)Fl-q$F9}=7N4Y^mM&$^XhSw*lfTw1>{c9xO(#+CLZ<%J$Q=KS9E50wZ^%eP~+L%
z<bhsXs9VX}Pc#yLY@;>OC*Ghr&G;;t4cl;gSTz?lKI<S8`v1jJ+?a(>BnG_~JXArC
zjj)H!Kvulhl{(sk*A8={4{sy2UyPBHLvZ*dP^Rxc)c#TxuStPzd$`zs_7ALSwQ^l5
z0L$({fzvG}8_2CT{vK~U6B+BiW%<>cTt#*RqvXT({1M!g;HPR>^*)V<wO=ojtxrgU
z^W-XqQ=KHplj$qHEj_QYCwo6LJaOuVkhQ0O5WYmKV$n-XFBQ>Cg<h(nmnyx~MlZE`
zNklIRUbuyg=qX!Ack^sfz7$voG=)q<wRgcVZyEsD>!|W3%;qmc@%UoLq=K)`E%Zn3
zT@8_|YoS1+cXh3QarKnog<<a?)OVm~V>vC_w)Y07<5nuFY{IvWpq~`n@XFl?7cAYw
z*q^b;)^h>G!1@Pg5T{*4w=z+`$v|4_P8&o;FQF(HwdN<xdYK{OUt2vkvnxH=ztj$n
znGp_ekcpKtAe<rmxRzos{6-zJ@#an>ZS1w^^+WaX(yFkEUz?vd{7I`r5c&=iydiV}
zv)|reB@z!PJ&zA{T#<Y|XgOTqtSP^N3&Cd?qn1Pdb_u~xn3){6uSTG;tPD;(Sgo(!
z@J>|2s6q|rTMhN48t4j^NI~!hENnHTXGhS32>Opc1bvh3M$~RNe6z#<x5DlT4H2CU
zwHkJP+89;Mcyb>txq|6>_Z3xKCRK4oEO-qr2R*AVGri|&1QH72PUZlwsY<K~Q>LoC
zrlBlKqxjPBOMb#kNLOYD;LRUM99q6gJQ~loGcv*^4W{O;-Tx>jEnLnUZ5htEcj}az
z%{d2%1-u5_MX9&VTwN=88``7x3@*0ka0aopr|Q7=z;yk(7z>O#yTR&;L{K@PRq-qZ
z6mcl~v~WuHk9xAzkZ`hFlIh$ZIt(%n1B;&W5&O&YcJCBXb2XX)m)YOMEH5`quk#B#
ztjj9ktwomBQoH8~rm#n}y1hr)^EvGIazDW~J+sN{S)(ThF2#OTe1Vj8f043|{kA^h
zI;@m?4BYuCZTgK@!h@D@%^2^&Ci3Ek-W7pavW`-+tw^Kym+31~Mv*1z=$ZePRyNHJ
z`zj`<jwE0Wvi0_Z)|~G??26}Jf*BFPuz7mO*v6Uh#ZM_AXYlaya}R`%pz<d(cSOX%
zBP=yZm0zmL6JxyGWy;W-sR^5v@}OS*Ybrc@P}OHDd6ANPuB#r(A?lV|bkOJhX#|eo
zCRij9&eB)bdJj%jNrz+OEPu{uq8Xgvk7o*tjhzt793I|>Jm3j^L4x5N9F5=1=PslW
z?ZIq5w<n*Q8NK;~{AGI1?ek+xyxb%n<JnJ0B2d?aO755>4u;U4dv!j!TIJ=<F=I7b
z<NoZJpA#x@)8cP&ykXQ!eaDMmO&qLebT*8=N8fR)<g33-fc)6^<YXMX7i5DU{zzO5
zNq+5TRyTT?)qeBpx(h0AS`OKAatQG65!TxKnr}5%gB9K*bMm?Aq#HKm(er`$oWm_r
z;B$=Oa@s&#KE;=hz~$HyE{hD{gzE90d$PZEO|hG97hWq3FZGg((ZIpvU4{ux;qo`%
z6}%s9g+C~2`pZNDd@U!(S{++1YI{9c|6}vCoSsKeEfXy7O*k|1wq+;UhC%SapHL2x
zuS+>N!0YmL)yOnrJ8}CvWEwL1WPR-TDdD-7mRkQF^>*E~Sp2qfDFPWu0UI|u0}%1l
zW&XG&{<Wjw$=naA$J-JN!AptV<O!oAuAf@#H`>Oi;#<%u`P^{83Mp^VXr7q2D}025
zQn5?tb1a-4_w_OXqoi7bzf8%8E>j7j@kufa&NCE&(pbSBmrfZF9<s4A-@rJRy8v0p
z<nYzd(U|LN^qv?y8E*d?FaANW(;MCv@2#MXh*)mWgE>2?5z4t{vW54<621*t|GWy%
zJwzioTDm%sRvg8eslzkg7qy0|p2@f|!IogV=ZRQ6cbz22MWYurd?5e3o8JfDl6>oV
z55ae$RL+RN^2IrdNj?>foLgR&Z){St)Mv{KcKrwm=pSkDPMyTqKe~`!+p}v}&)!<L
zLvRK5P1fSGMfIDdGd9)u<>sFMJS91-@hbrs?>zPcR8RBRe?<?EnB<M;&KDTh9&D9P
zTwMpKJ&BPOM9$=?dv0x6e8Gi>lh29q@y^GP&D*^UB&tgf5!_ronNz9O0yNwPlkgU8
zqA9sg3BAS<tO@GHFLO9mdP((^&N)wLriqyS7aXS{yQ7-2g>PUJvH5hJ31V1ejNt6w
zF}d$6%}qOr(W0Ar%1s-7i{_EV3zRU=<^n$7C^oYR$Zx>$eYBTcs8au;ObwUilUeme
zKG|(Qx!Lr!p8N}!yzjLw>3Mv#*S5gVEc7R%SY?ihMuA=Kq>CxySqnMjX0amLSF6ey
z3;h&YWbE=KW9wnovo&)aiLLWZKeK>2YluICK!c;b8CicumOlTKpUKuW#)v_fQ0ca8
zol1>1NLl~m<ioQd2xdPi*WRpZo}d<hSvzhD>9NrixULuEbx!9|F?@5D!RU>zkb4BD
z6<RnH>jqY1l^U6EggG3LYY5}T^>J-k;xoXk9}5n~I^j1j1UW1jSgi8n%_q&Du>fR`
z^D|5QMx%aGqMl;SOT0l|%V;$lWEX08{a0GGI1YF6?c^6oa6_V9J(aZ}f;Qv(<5BlA
z@$f&@VDw6SR(YyRRX{JNJtQjV8ukok_PyfTS{iS@=?`8n7Ks6grfw8=6TEFfatLzZ
zQdun=Hkqf)bYjQ-Eya~pEqM4@W&451&y!N3^srM<&L^I(H)ExLkA#x9XdHj@xpVnz
zG-Y<+Xh@>g%Z(w)U#1T}e(<qxlkVlP41kA;PTKk?Me=rVO=Wu?QIYa=n}1Kj%9>PV
zBAvqotWV6&vzhFwBl|A>^<}1BeMz_YvHSc*23^zcU7B`B+>3_6$(|R&>Jm5y+T{c^
zxDqNrr-3N&-aS?zZbu3bEJusetU!b3%Guw#drXkuX49U$`j`gdS&h3Wa&|tsf|p`@
z@ESptSm7@-io^({ON-)*vxrh!a|F$p88ri0B>DQ`rhM69micXXo|ub+VStPpF=+or
zoLOkZ3FL&Kay0^(T$8{q;3rq~^v1m83f}8%YKq@xmYrfZ0k-DbV#5_0N9|Q(+biRX
z?-Fxz7>|=|HS;+ZS?S-SZiOh;yY{#49x+1vwnL~jtVg2x^Guons-M{;ypm}l->6BM
zpIIVLiDhlwkT<SyAJp-Ba^V^j=J=SsKpdz%#c#V9%TKsL=AX8Oetj%lu8AijvEpA-
z=})Ql9-IXj4YzJ7oL4b<-x$I59_-YoJxtz5ddrlmp*#oMgx^}>Et^9^eDNuuozJDC
zB9aOB=*35@jJ{KP?2BO7^N1joq13`F@x@P&#Fie<Wj$~*;iH!ORx5hv^gG}8W^~WJ
zi9SEv)}M6z4GnegrN7~~buX&ChcejSVBQKbWTQR6l$YPlC^PviUVb`k0xd-tUu0;X
z`|bCO-A@q|@K`XqSRz5_LuFqk@y;G20<*H`5xtZXzBjoX^cw1NYJoRndHgoT2N-Lw
z=_`C|Ibsc+%9_1Mf9uY#jNkUAy7*90+hp3JdfXQ-^BQORvH2c)`hLO#yMVaqtN$Rk
zO&o<_!ltK(9i;a>qJAn%FN!aouUYdRkw2eYDtdS`?(~y)LQ3`weJt?Z&h1Utp51gz
zcrJ7n^d!F!GM@bc4+jvFutAQPHo}kl-auk*3g5E{+fdx4Vd4gA^-$)!;Or-KhAFH2
zrj^dIV9kyCR>`^0%J6OD57RKflz6)w{~U~f?EVv0oIi^%8^_^;sKZP`a;*kbNtMYS
zC8kW&ltzI+b+oZF`qHA<GPNG>GCNE%Ba6bIprjnMif11Zk(mG5vhPd7tmpq#Ow%l}
zqQiJU3QyAbYwq^PN7Ajp8OPr>p!uu}$p#Y+DX;{y7-zfgZ0Ok-^JXmdn(wT;M_m)Y
zZ4Ny?);(uWRXY}`j~3P3<;_^7@wQCaCi)z7;)Zs6Y4UCKc^rYyS>Eb3{vfZM?{)p$
zxnzCp$9lX$8nI5rK2m@ghV|8SVer^ytf|*ZYj5SEFxFPz+sm^t+}QS+@kKtb;ZGp9
z9gVIUaENDaMRZC~L~E>o_PKLlR+O^c=wZR0UH}iK<x7ehZlq53!vRSBSHuXBI(Ze6
z&(z7U>A|U!>6_w<#`P<l59W#uIoT}S#9H$jkbeSRd+KW|xYp23@K?@4hgP6#jtc*n
z^|WJ@d$h7PjkM>9p*`=S@+b;5fteQ%sC^&LCH^oxcI&fMw<nQ8E<S*rtDrTTUiJee
z)Q^a?*wiF{d`<A%@6zouhGn%;XZm>WiJ0y1c6_4f>?n!0nO1gmv`2)wCPw^PA~Qk9
z@O*)tSWvtbK_5!#O05E=j#JZgRJKYjGZ{dI-cgjZBP1o^n>Ps~{tj=}*h*%-#?j$J
z3>Zh6QIZv=K7pw}t$IpC-oN5^r7kttVXY*GqMcM}fL$@XbTHC&`6POnF7H*B4}Oe}
zse)I6A)8Pmjoorp4BzlQ)yn*mdxH*jYshGs8!dWejnHcM_2BT|ptpmNt#(=Gnn_?0
zaSA3E*RfCEX{+6uk6P_cjTPGQEA|Ok&wj*ecbAAl6IlzZvrc-`nppC9k8lcy@Im%l
zvk(cV^E#RDTCqwyM%?so11YuV@4T6GN->O!g~+Ywfv&{2_bYL>@<k({gCS`BI@umr
z59R1!+m+j8COnAzmKI<R(2m~^SluW+Jc3=nh|>*I@9&KFLcPcBSMRS>1=0@(@)_$=
z#ATksAL4&TE3$E^;FLK!_g|yxBPN|Yt|K`4b&CezIKysWcpXB<vw8mF{9YPD60sek
zs*&SZIDqP=?5C^W@)Ht^TsA~mEOV#JOwEL%Yo9Xexv0VU70QpgtBIhn;9R(jkrB@w
zvl|wZQ-+ai=dZL1gj@*;a7V76yf}bdN)KP_1B?;ME*^4^+{jy;Igp--8Z~6GvFtEa
zOa3cs=lw>;Q18lGg}jux^8(ca{W|Znj*6;mTvuQM4l01TqYfomgpUsE4Cowya%?rM
zWqd|mmFnEqeIBEIRw`KgGe_>magwdW8EES-J3tg3@iHUsUTvDN6dNxYoV`)PBAF#J
zM_sBizUXs$McOxKJ)2nkde|5Xg;hOzUV?cooTDMz&ftxP>>sEqYyxU@-UQLsxkktC
z*y7eqAvqh~56<g1L+gQ}c^;;!@NnT{ba$eAE}4RV<;(iz2V`$m_E#7;TIr8xjsNAZ
z7T5UW|5BhIT{&JPZW!Swh*QdF>Kr+6rN5Pd4l6kVD`)sI%Gv=<6HBu;(6SxDgLvbG
zS5aAUXhsl&kJmU~^(VqhB`BM-n(M|7oa@F{ARX*Pe4BIxZLn5gx?}u;+&bh?a4?mG
z)e-^hwM0@9x)(CD_1~P$kJp|^Svbp;TcUE$unrD)Ize+ld}Ov>1Aq2()aOt5c7Dzs
zk9&Ea<eEE*=hn<RKG&3=e<!f@FJEsSRnZCP{QMP`O8R`Qo%9c7#K9_`RXS>CMk83-
zuh&vJ)^~!pLkvIQ<ddCy()qO60-~%}-KgozcHp&Byxa6`)-N3O=Wr?2jPWlaD9hXv
zQN{-=W<%^w68Aq})KGUx%}sw)Rg;GjB`b=}Lqr*J9@;aPGkTv4UR-69LUgAC+YClm
z&f{hJ2>@f~@wjQT;E!aUJ2fA9whXWot(&9sct7zKu!XfrW_NftBN3wJ6E_x`Hou!E
zKBwI&eb&TZ7`2Bs3sL)KC;o1TMFEhCr|ezV)UC-<{HAB30zVh9BKFpI-AdBGe7Cad
zU%q>RdobG8r>Q+29RAA)v$Vd6=-*q#gA5=)j}q!HBj@S<#7=D4!~H6>_UAJ3KJE>n
zFE8_}?_@c01ZXt`gPt&0byGWUdd(oM6@<Z*HtV4yzO$G@CAEZ^zad5@Y^7$|@s}*;
zr8U?)d=T-dP8}qK$m-eobiaNipg!Wn=tw~rU@AGD!{K%_sqqW`%Ej|y+*Z2<ziO_L
zoHzEw4GlXp{eI6<RgXS~Tgs~ld7n@z*m4K)huSLqDI5~3@&<uwblA<JO80H>_LRmG
z@T)qv0->nBP;?y8x-1db?cm@aA4DZgxn;rbQ#g0hqjm=48P#fDj}eL(<?Q3`F!UJr
zf7JMm|KbB8P4|T|ESBnH;(EzWOJ)wzzTS*Y!51Zj&<)dXc(X?a9#!NUMoSua4a8Vi
zmVx-TPqEVJQwZq>=baSnMNC-nBfQz%cvR^%j0?^co`upxbT%mHE6}r4{}2LPMJTK-
zz}OuOaYb9X`ZX2Y_(|s@-!P(>_rU!*McaywrREc3z?#FQ&c@JPFk0mk(=ENbAY}60
z4=aIxPI{ftKBaTlEzE74ZEG6Y68!3=|3*kd-9m)FhN<}mMS5e@WfF9!3q8hWqjf>U
zREYNtcGb8Iy|RUX;v52c?x*S=i**4HFf~j~1z-9P>oWgp?(fStb_!lF@lmL!^XZvG
zs0<Dhy*XnPd|Q*=<6dJ8u>Ti`<r{0QPX^gRZX#;MwlKks;7@S>?|{qU`pMuE37S%W
zyZcNzw#`OGE%)^>;*Rr^%oFJ&b;Hj{WO(hoxwC%u=wJVkuH;~7al6+}qsA>Vg<32T
zUSv_NMAOfSNtLXd=)SV@AO;*RBbAUXf3OBf{+4b&3b1#F28uT!=3Q&Ybf2Il{^1~W
zaDGDdw)qggopZ~)H4H85;Z6Fx-fBkL8+@j>+L`ty)Oj1$Yj03aZ^QfT4JQ%3jYwq$
zMWo|xWUt;PW7^T%=xxtWbdKn}O&GJpat^ng6UO!1+X(lT7?~3k2@Z0eJJa4qySJt#
z_BP4A&Fr<elzY3ZUvHBybnWY`y_vW6sn)&;vu5h8ak|SndxgEtbZ_ZetG&~`-MGYB
z)Rdnvwd(g1CGIa9+jwsJ()@(!YhI)UZB_XRbGGf6$e#R#y8x5FMG|`E)bq>yL3s;U
zvFnA2(7ej)sPxXF;}_wdF-WHY@c^<3xo1ncXAfA2A3%DAx{Czxs;=)oJ9!+>Y3s~y
z93wUF6)9Lw<I~kw;h*%L1b&sPySDv&uviEdBdHlcBf%5&-Orp<gey9vR~3F8UUl)_
z6zvU1OagsX3A<!Jx1)K@yQN_?YghOLzh3Mx)St=*HnRoJGcW3Hjm?z`qr{P4-9T#3
z;i8j2h!n#T|0Azv;QPX@d)5ATBoQzrq)+r4X4XC4MRc!*nb8<Gd7rnfc~C>`Yq3oe
zHm?4a(=9MHL$qmqlLp;%{-Cv;PFw_jcD#ZV*jtwVW!Hm@${PzAf+{}y4V;Y~EqGw;
zDhlr;#Hnr{XG>;wReLa`2>pS+6@~LLy17xJ6k>F7qf#{uKi5qv$M}gkP$S+>+|zz!
zO;zi@Z6N2SB0hXVLHjb*UKge^%2TP`1`+<9e!P51VWQjbeht-y?>pq5!q&u`I^T$Z
zsWBacMyL8yW^ra|Rc-p9p8i^|zIKBqT_y%rG=uRK51Jk}DVQk6Lxl<}M1@}d1c&GV
z#Ya%#b~O2c{SOXZ^bsCC+?Q?B=TUw_%0p!fP5n?akKtZNuWMifM?vKOH|^7WKA?S_
z5B*Q=JC$P;AJx8}zx;pDzNY^N?Th65N7C=y{~z$_r;ntc!LM<1ewuNFRKr?LlsEqv
z!Y>l)zrWn>iN>RC(fpx^k)FMWUULdMh7KjOZD><X+=e)jCU599VwPqZ?w5G~DK6_P
z%&EU;!3RHkDi+Vln+xBhQg)nMe?oR<h*a<lh6x*&goGsDsF(7MHJT#(vZ_rvy85DJ
z>M#K_Blq5ic4A~yK-i067|#7*MwnZ%L5Urm{Z9f~w;(2~f+IL$2y_ctI`7@xFhxB3
z6QKj_ODe87F-Sb?Jj@A3$QABaJ!6q3<WEIL)<N9UbPL(Ny{hX6pyeO5;Q~-U+kyIT
zzH#UMCDh*<Ec@XH`%*;nZLHYvAczo0PHjw9K4fpg=7BB3rZ&WQh0LwA>mIdY^Al|9
z?9%f06DWwTGS<Ud>Md%l_1gh2YlZfo2;H(vpoT6Hh0XJ;EPYITp`7AWFkNreS&$7|
z;;;z~B!g)O#5+fwS60?p>*I)h8h^g8Ai}IYR}p_fgwj2vzV52)r?F)QixWxg1S>G%
z1HWXLOs-B@`-DvA5@>CNUPaRi%O+0jFsXoi$>J4mBZa$8e=d^fEZB~=Vz+;XimcnE
z9ETi95^bPIsFSZzN1bHnbzCd9kd5eS+9bYTnGrXv5$|?Y>ZYdPrAH|Ev~~Pcl2r_s
zorCD7p#S@b`xjF#EOKK7xl*0AGy(>Ks;}i8yPQNRypT5(nDo>Fw&|gUsf0_oi(#_i
zD`W}Zi7JWbZW8&79gAGB`9Ln{iYj@8^6SU&b;BXz*kl#R1S_6q<?=&)d6C4zm%vl<
zc!00pC80c^z_;|}Dhi;Om*z_w?>BnM1*pbeTNa;zp0i@Cb_d)<Znt42%Fqa4ox{q?
z60GaBU0;R+tY4oHH_j&+CQTp0H6@97wo<H$spl$82AS&cyX1B2@iWx{x2RhhW6FQM
zpBnl0;{ut!Ec@JbuLQT=BQ+Q~hFg8iKc1+a%n)1r!@ak?<|Tbc%W39Vk1ew#oA4G~
zb+z{bJwGrYo7}Em@RJKz7k&9@rlf=a&8f>HBmmkL1QR}O)l+kywp1bp_NOJ}jrA#E
zK3L8lN6FnKcRRRpBOn_+QnzH=Y8kob@!oV|&-jtC%vt0~pRU{^z2A%PUxM$6Gq;X<
zIZ@IpD`|7K@9U~|+o#|JJVEvW?sJ)K^Iq$vs(4o0J{!uQCaT3ZmOImyHpv}4A9$@8
znYJ3=HD@<G4#>WbyN}=GV>=^jzshKMkbI^z#P)Zgva!nO1tE4_>XHl7hx^S7FnJd=
z1%9JoRvd}xJg!);H3iUrkxiVV3Xdub{v4~BV0Fm_*4AKa^mT<gpWMqwLOpo{{}jHL
zOiqg;_RXJmu0Ollzuqnf6%qUdT5@KhI<qYJt&Eb*3#bVL*ZAq|qu{?Gq$kE&@ceD@
zTeax=#0uJ}T$Sv5rTp<jQ~r6=TY{TORvY2z)O0^F%&V^^Nd5wDOvrK$dnhJFzQUzL
zLCS74&g?RJOwT8(L4+;Y>bm}TZo6EAFkdESMk4pjC}GAf6T^4*4PsLOlSO84w0D_L
z?ojzr`$p}_Cs*h(pIqsFR=J<m?ninl&DlkB{PNQRgaotbwL_R3SNsND^BIZmA>1v5
zBhHKLhWh69k-ZBVcr%c=G64YEmbdw&t!<--qWR=z_f4XYEL+{rHutk#Kl|5t2z72#
zoy3}z&(5oUaxERTj0lQL8HJz5@nFc`(<cyPq;nh0;N&@Bbup2ugI~fE%}Bk96G|$V
zybsTaWyyQHyY4GXpVQrSZ&|v|y3}uDJ21E#4rgLo<(CIb^w`<-YYDVf+~k<5ZgtQB
zyB1N!oaHB1=6X3Q0l<3<`10<qdkpOI64=#%J=cL<3D`OwqgmC#Ug<Ygw*VioGa|5U
zOIc@}mVGIG3TH!fZ&fWg(I$e0{H4d{^`5;SaQk9~3;+aLv0=OdP3RKNO;EIhV%+OT
zem}XwVvIa6pxE6MGp66lJ{2@Pg+eZ<n2~WgEsn^z!oP^UE)ZL4h%q~*rxBWuil(&c
zeh-1Rc-9vV06)&avk}<hzz_G^dL8&rs+R;Fm&?X#M+8AX(?R!VER}>im|_HOl><vS
zM5n~$TQYzG!Tb^hwqe3%psXaH1os}KJWVIUHr!$DerQ1EACj3Z!UxHu-gkTR>acij
zI%znWLyU_kkGHuRrh~vxe9iz6GXWv7n?0NY<o>J<EL=2{Dd0qjBem_r%+ldBH(#f+
z(&N;loWKG;Ty|w`doXkW{4%vCJ#>l=yjqw_ApwO(M<ANFK>Kl`{g#0!{*EiR;c{b&
zM^M-jnW1(+5jPZZcclaIChlrB61GKH5IWfyWR*V~EN&kF;(9<d6|exrwg|+3I1m~%
z1>!A-cz28atZ_y>CPoo&jS+9`0I<5z%ZS%Z0Y|*;A0pnG14i2M1+>*UM!c<#cx#M!
zFLjq%zKNaWri>A<T*TWdBp}|~rmI##iUWw}P`q;h2)X6Za=Wf2BA$U*8-Yk3NW3*h
zytV-#&UPSN7dqk@h$|h4?k-4XULnSVx%XjR-@qF2wmIUhHsXD7Q>k%(Vg|NBdpA^c
z#M|~E;;lY_crQEs%yITW;;mNK2lozue>3nQo?{zFJkDw^2sT6@GFuq@<E9`Dwh+XT
z3u9LMtwcS)cmN1lzYpL%195Euivs^QZ+D!xT8#~c4geuN1O9jP2aD~hNBr+V*kFx_
z2M^{d5H%nKIgEJGm{@7V+lYH_VNCqQCNQS?4U8{Gye-VeJe|l1QX96BXkQ5hr#hLp
z0%scynC7h!+i+ychV4ot-j@f!KM(i^5O1Z>?utMZ*(MqF?@IqF#@r_dfH+7X_8)Tw
z;;aG|I*_H2Um)H}Bi>70rB-fY)o}pv48+@bf7;03p~-4peA(kfnb%bK2ksW1(cSfj
zGB;tYBW4!;yF>jO%pU;w3IN-{9Yps)G$xF7A3b60D9pS6;_Af5Ecq~#wN>{D6WT@H
zU9Xg-r%1>?Y^;6(bsaOHt`AT;tu9?~O<l|$oRd^nm1d83aN#P=9(y;JnwL3*6aDdD
zWd5MoYx^<>`CSj+I^z|upVj0zY9AxvyTf|%TIhc-8^8q?xtV&KGRJZmBeECH+u^;d
z9(*VQ-h8Kj-AoR9)ce=Q{9_i)Kayn%XkIfy8u$2_=veV^hE#KK=Hfs-O^uB`D)Yv?
zcl&8bwAZZjAdgCAOQEADToC<vPoeX~ywpf^HqyOq8-tItYX2j;{b!;3s6E6oLm{1b
zF1psI!W)3>K&B6Sh-Y5@27HW?=W#qEp1oK#A2ILUH%QDpZ#f=Swsrc`_j~U*;duN@
zyym50o&D|zN7?U+@D%&q9Ddh+d&9-{yEeSpe%FO_?RR^4js0#7ziGeQ!prS<OL&R>
zt_fe|xT!YkU$o!V;j{L;GJMjGp)OcI0-bzAf<M7ckI-?75v+}7Df!jmp>niIE?EC{
zG`<Zt@+X)UWr|1p#T6x+KkFzWw84`8gqVxSYYVSkO8$b9n|FCfaBYVR-q}zywy`F@
zP?1mBT~!`C%IT7`UuNA?)K0j@XaIlR`MB{{_$9KyhO9^E@sZ5`Wq5LHyCSY0oilRY
zGi7D9W!{{TQewsx91ScZn+#-)=RQrUjyq;KSw}mw!K}qB5E5Jz|2blX@)7l9P*n1w
zk@KE5fESGn|3>4bU+j|ZB<wDS{TV_Fg7-E$<W2$L#=jixZS$Vr7#!U5r}Ca%<>6-5
z583D9p3W{C)`{?YB#Fn%I@4&&BDHQ+8ueUoq$I41dcKmiO{=Ul8V3)%aqvJ?&o|-w
z;y3P8-615t8-4s=__VcKK{xN2=)NxcDDNjItj`L|PvCA!PLDpG1M~RF&0cbaIz}uR
z#*{>K|K_FQ>+_ZLCs?RBLG|Lb1BBxv2zL~}0iL^hSLow^<5<T44?iv*oUsdo$N$~Z
zB)o;rag&p12YR$4xPw|)m2fndx`h91xVXSfWMKU{&GD1z(oGRk6UFP1^x&LHQ*2(H
z6BTxf0y#qDRDDhe<ZF=DpE|YYJr?>3D&cLEb)v>UFCpq|*4K;N*L6Ji)Rkvmx1%p@
z65a2?abxWPHv2pez>UOC%gFE+6-L6eCcL&g{Z=~-FqJg7O8mcC%I&}G{6AQ7hWl{u
z;ATj3uRQK=3^<N`?UBRYQG9THPyeFR+RXL|_9WH6x;L=BUFzO6W-wg)&tq2Uy{07H
z726~c&u+t*%VlN!56Z8Jfb3w$Q$QZzBV*D_%?$G*i5Y0ll?=N4P8%DcFTb(zHM)_7
zqdkMuA8*27ptPhTC*c<)#lth458*(`9-ipjWh`wFo$5jP!$`yCihhnN#Q{9iD~1d}
z`%N-{_D<vN2<=soN_1j`_G5f>gN`<#FPX9#i#~o29#ajbtf|RT`+l4$5#~0lA$PXp
zST{IVM?fBv=!G!yYb<aKao|RVZ4Bi?0w+yIhUbz{!~wP2)-2so@fRh$z+t6p<toGB
z<N-Jw>TtM`d_@7VG6FI-0&*!Iqq&*IqZ1w{MBh&5o1f{`0&p0Q;k$AXTKj1PwD$M0
zAI{sokmrFWME|Np&smHL9XrPr<0mLisFUaOhFnjumc(*M_yAsdzC^Z0WowMGWk1Io
zCAujg7gLR$X$ik|wE4`QOiItYIGrA^hp`_^A7a+I+yj=5Q|%wn-!)<A2BvuSTrHNz
z9><Jes%(~fWfG&wYEbJ(u8PHTr!bXMN6+=6!Q>Pc$31iPbOCaE6$VXUQG`5Jq*eD+
zVF9S}EhPDno-q}SecIu-*BqF9JIRtB{Xp{Zl1^0$FB$MxN#wksb$Ht<=!Dg@URKj%
zg(D&f$M^Hnej@EPFZZy3Jjq^QTXs+VNLu$et>ZS_<O1*6o{bm!Yr4U!9iRRw!6+xF
z0rNH0hpEh6=7G$qk0I<1&L_2Z4{fliFbAmB%~@G7<GE!}gmgA>bOX;#pAHo|&(5bM
zS9)(Y;MK&*f#A~bB8S^n>V)OuzpDf+H;97~d;|XW;J!O#jmyelm&RwENs-VmeGk(~
zXlz>8n;G>yo<xVHVKz<nzd*dE4ewc}EeIB}mjUXG3buW1IhF<t_~uTwId*}cTv#{0
znwg&00k=4{E%5q-Z&d-gab(ylv!0o7uWU+lb$~l2sM96p)w;(X@M@Jq28505zeeBO
zSxP$}PafOF`0Kr9&0X-US#x8U-)vUO2Cw74QrN@DTpQjjkhCs+yCW$PaA$)=!LnS0
zcMtF|*e-k~vgY=Eii)T%$|wW!^<=@|TSFG8#A<2IFm?9^RUUj}K(+tOu8S%=a^8~~
zKHkKU``dQ?i#r(;x!<8<w5SV+CDR$(CS1IYZkvNSeF$}k{`x*r;uJusk<ug4rS`c|
zGMdJ%VvLMXBkOH&gtel2v84~(V=dhd^bp3>1n3yp*Gof9@PnJ3srv@KYZ~qpSI&wo
ztf|rA>0r6U&n(X;mq1-a2ImMl1JfGgtfHo%i`W>L`^{(u6f0uD8|24O8t#;u!?-&^
zERONiZk1YW*HNLijO6y8R_>eF=1;5W8#2D`9n4x{=IX_D(<->2N=wKwW9ut3uVdq4
ztfEH=whl?(Wt=Vzb-6#DF$KODBV5x4$#S>KzwSa7F)9D53neXoCsuE)89Skdv282k
z%o!NZqHRlb-OAw5c|`7RtW^tLtigdd&@>KHx;n!|AXcy=jj!WbH3nU_%vy*{Npmlz
z@G(s^5z_*1u>#F<!acGNdu==ONwfdznlU>7)z{!(U+GU62_m1_K+Ny5;IH%5DfkO@
zJ*+*mU8GSQIE8qe{*3KCeX)JbJG~j(;|osGU_n{1<4%5NdwIWqTshaYaKD#M?rcuq
z=g-*by?CD2+#6qTo=J?&RLL!H*H-i$Zs+O$5<5Shl>@L}|GwW;Irhp5w6Y0f#*QD8
z`6Fi20R!Vd85l&|==|#QHZl}uC+-Gh(7w7f8vog_ApFXf;IzB!e2=keTW=T`V-Boj
zQdCJ=m1LML+KZLE`S1USm25$qNyKy7xeb2-6N|eqN)!Y`_OHywCK4OzJSP&zsT-TK
zbr*HUv$w)gOvIhN$VGOL-j*z9R9^j{(-mq2kUQ%Tskq89RcU9cT2H#XY`bHNP5ear
zmKs@XzK-~<NgM#3Isnk++*h)sEPeLev9@AZ?q65wf1crSX+>Y9bGsWqws{FICb7kS
zs?rS)`lfzNJgXf|eN->$jM>pZ*Z>+JyF55^2^)=%k|S97ZOL;@3H3|~(h@Z#{1!7o
zb5{GP%bCP588GE72xdD6M@ZL-y0d=k?^vR)=8wLu{SO7WxA`j^EA5C#MRO{{bC5ZX
zgt{`mK;m4;i%l*=>BbflowN!tr)eh;jq7>(K+c-n-dmAAj#&Y&*?Vw2_mWi9hAPcB
zQe|z9=WwqcO@1NrZl;k8M9%QDDSuGfe3>9}%djiTEp&{kX}{g7ap!LyP+jCmF3<+`
zb;JDBFa?mnh3>H^TSKLWuCIJZ{HfeCmNigFR#7x;vHF?%Rs{=(pgs}kiIi{}1@<(I
zqTA&wDtR4EsY7=lbam^s-`=USkT_Nsr~2%rdbzSw;;AoY#qx<xY9Yr0wITx4vYw9|
zXP?bBpPKZA?+j?tF7*Htr>u!(-s}WAoL_&gH?7laIM=VA={3yE*Pknx`TCjqLBDB~
zese#(%^4KH{ev*mHoY$cl*la&*M0ihtMsY146lzqox*SUIO|ikt%=ug5i<sj%_q_V
z9nN)BV8)#$D!@wh%p?ReX<#rtEy`&KpaRf$c!yYyi5B1>BiTI#t&%T4AY<LOOr^Wf
zIezo)yvuTV*?>`KeHi@ZKOGBwNAztR?bVOgT?_R!eq*Os-x(eco{UbkQjJWzb`EtC
zWy1rz0Uw$N@M|`~i#jSMjI=`P44-4w;Rg2?l+(D6NDH6l#k;CAe1Ok1EI;1-c1JxK
zo~HcpSHp#bRI(;Bt{Rw$#-~%ZD*j3h^>41F7fu3mH)vMN1fY4|sn*8|MXA<YLBIoK
zIgJipRPW+G?1gv|OuJq*!4zq1R2951P-zPr0lNOafrIyLMqRiXib`d8$1Qfi9C&5n
zU-XLO%B8i)h-5cL(}xHxg_g3kcTDo3^eDe$m_K=#*S3}^CAk*UD$K&C$J57ZhEJ-?
z$H%Y}j2+K7IFr}zu7}Fv+26wDQvaV8x8tOp+%Yy4V>45${{IpKo_wowGl*x85|7|j
zfKNeVEeHGCYvopuc{02OIx)VWdKTj94(`2(6T6X1oiyjdP!S3Dms6E$YBz0CUmPeF
z&Ow1f`pB1-8$Ct)X7gOa&~cu`LW{|TU{#cD6F2@S=T%WJu|y#Z*_;}`b(mOgSz5Cu
zv6~XrW~q90k%P|hOKu8E;rAQQeo;la9TY>|#0sDIkUC-G>|dt%XRnabCe@20MpNbg
zkh_S_Mdh&UIU20H&<jemB5RovEhi$oZ|hxpQMQ=X2pvQP9ts6rz89HooAXt;7lfxn
z6la?(Gu3uMuxk~xS|;Ea>UuJo-Mx)KT55CEhNGg%{koNI!1Zbs>f%Wc*Eqglm^k1~
zb@2F@MUV)1&euyOm4#2y@}3)5$K?)X$b^s6D)0GlsM#H|!O^AKmT#X@*0;oQ%`ys!
zYu1S>$!^Z1Vm0!1p!#7H0;;jko8b@nTsYr>Cc6WHBoTHAb%bv+>#Oe>Rp)p5sZJ+7
z&j2ZUUcEVnT#;52-Byx_XK&Len9|9~x8SK|qFNTmf)?KUgAKgnP%;(r0#sU0fxa_w
zA}g#x{)yIOhe`%&l<u-o(<t%(s0!~AQQ7wAn5a5pBCQS0c4`Z%PeSMLd<1OIyMyDo
zx#WeU$g(s~l8#vu1z>wQNQD*BrnJ~%l(#Bx!1PMMnDvZGIg3=0JA9lT(90MTtj=>p
zI!<sqI-I8FvCt=VIja$0ddn&p(2?+}==)`Sw*{>`7Ow7+6QJwB--{b&bQfbXtQIdY
zxJCGlJerhvmWNxDYZlo3zPBb<FGxPq-StdadSdq@H!!5i(&PQE?t+fKPhRug!DTQ^
zK}~l&_%%1kTZ^ZJ@=jY1Q|e1ekXs^n=x0L9MTi^{;p)I1b|Bc?IAgs9K~GNd$+Nih
zxzCUoejSo70dHbe0i(>J|3vbc@=y^OXa}vf56Nequ%?yUeGE2E@S@gwC4GpIDfc2h
zh0b=c(J}oEjic|0thT1f-NvIMXHJPTx+4PqN&Tyay#c@Ez82+@b-p_|H(jC+()Cwa
zuy--_*J3QnC)}VsgEHt&w+VXY{=Od*k^*^rx>5g>)cQeMF16$R1AhdO;`fpi1=!+U
zTJJp@o+KQaS0CEEhV%9$2@@UK6GVr}2EtPodJ0U&3X_PA+2JyNP8jAVB<;f=Q|?16
z^!E_H9jVTg)~y%G2Z;gx_O)(+cgarrc@6%7{&PAnq`M8$HCS>oXZqMy%hOeIgUcMk
z3GlRzdZ!N_)qBy!Gd3*&l^qvfJR{8RpgBB~7_Q^UC@$1Pe~-R<Hh+RV1Do}B->(Pw
zOMB1b8}2<*_Y}?;^!@;&QJ-GVLC~$?VNbGxr-eNEmm~^aWyfA4{4>|py^{WV&)9M<
z1DC1dcoS0<-a8iCwLkbaTx2pT-6(L`9|5HMrjcdWP4+LHPOl%*m%Mz5dEA}tpHG;%
z^7KJ_#(zGMo-R0D72e-5Q}hSt7ocRem&`Nxl&yP#L2lO|>t#pbWzPik!dxST<i@@?
zV32F=bcUcnfk&0PCBW{qFOmKm)%M*E)%pVlhq4jHZ(rXF+`|32c&>%#J&hw7=o6GW
z->qK?{`DM&0mt~#<Xhec-g}%5?D^9mwg8d)Z<TSA+;e!oKb8IxHim<+QVhy8z@>VM
zW$G~7^XX(Q70S8Z4%P1Ip6emsue`1b4((lhi5g{>4vp%ac9FGE-!r>xM=(m+?>v?F
z#1!HpJk5fQLptf9P3br%8oYk*MNR^RMnA#t8<4n1JogLwBeJ*l?5^PwZPwNVdL#(s
zOX;uRd_C&P+;e&5Vf)v=zS?V_mBOCi5q#~NcB0f&YS~OV!*w=YcE!=bw^qtdtvj!3
z8F@Gjd;J~3sjPr)^`S|E03Yp_xfmaGo43VvU|T<DWIKYH@d4K=9gpZqxr^McV7>|-
zU@|`NY9;!zKln>4+>UcuKO^R7@F+R{N|c`u7`eqYR(mf7uW-JJX!$6H=wLEk(1lo6
z&epM`X(RXKE9jkxHKU$`4P%+n=3m<VXYRV^y&^rBXw86cE%J-;cBUF#`BN~6U`(vB
z6>Hy9R8kNGgZ!p~3v)jzq7HATHjINj+`Y1j!HH{Pz~wUkyLoq~KY6t4j1V79Jl^bz
zyDJba!Cim0-2q$*-Q}6YmEFZeA0ZH2Pp#nXZK8vI^Mi6K)LmC&!Jsom{krh#UkeDJ
zGyju`fAZ+?9O`xbd`kqT!}_^%^)DQlTEJ*-*0LZxg52vzzJv%$^M^|6@1vF0|1g<j
zfpD+*&>8*@@E;!GCASgsR`cvclm;w330d=FW%1luykiKD;dfZ$U!TJ8kMBTaiqbur
z$I|8AUZR!;KU2RD$=;c%2-HTme^N`L%(l7@2wpQGCHQxPG1u_y4SJFEE(GcVOWObP
zH|b837n0-e-X`f)^*oClWhhetO+?vz6Th7ep_GrLsZtiI_yCIT2DDT+Ivl)|8Jd3_
zKoQ>-RXO{nj2IT1ae+wHHPvt^xC4iSPnC6Z76<upTyIbRzMfr!=Dk){R$c~+ZV`)e
zZ73!XHhQ-PFQXk9pT={i(KE6|&Yq;Dx@5lc9N+UEy69F&YMYL;>;YTQ*La{>7q?)#
zUfQ;CyQRgy{tSYQO^OZBxxL-uYo~$>E8k%r-R9-xj&kKB;XSnHJpf&6)$Zt-BfFCP
zQUKKR_)M$zXS`yqyIZL=F^U$kg;!e=Jf?KHsUgs97;p1iQ?^?YMd@wc#-gK&@Bw@+
z=+DVr{_K%&KT%eT4@d3;Yvne!Zv5+O6x`?6BzXOwD#NfZ@;%w}=DvBamX%eMQG&ga
z^g%Lo$FNcEBqOol(qrKy`F;#aAN{rxE6OsJ^O|{xIsfyX*J9~PhP&+A6=m2&*^Z$@
zV|AM{d4B?rnIU~=xU|ppjQJQxpddu%WMIlkJyxtyJy;RFRg~53$UMz1%}H->v^+zs
z>R4H3ltVV{62PUFP8NMmgj6)4Y*1O|Fh9AAFb+I&7<Y+eUx8@3R~VCsT@$(-h*0G8
zRPen+=sDvtI`1m$x#P^;-|wg?GNW;AbSDcjHG-taKzP@CLIa_WXIM$2qCXhH3oO{q
zplI5uL9yY_usB%49Kq?hQJbLq=W^zMSYU91J-J=bG-#zYl?Dy$R=hCAvV=$SUHo0|
z_G-9C11k!a2;xxlz>;GNJR=W{IWKD+v_pP)!&+Sw62?s%m;yBX4HPR51D)rfPSi<U
zB3j$=vw&&ITrq=mZgt??&O#rs@f`bB9GM_HkToEiShf`lQR4aOR-$jK&FpNoMu<l7
zA?*SfF5i*~oyBzU<FA{(n4QDQQ)`_aMp?OeB5wl8n;#)u!MD)4t|U>ZzhNaaPlcbM
zsCa?OPx-1QOqldb=;8Eya3||c<_!PJk)al<GE6LY0&U}lKe^ru&UF>g14;=u$hIg?
z+8V#XTyq`<Rney8?W118!G^=srmHhWV>GA;o~ANS3#jxM%t*U16}9?vD)6SqSFgsO
zJ+wWz3)g<yqVg9bz}K(+1Cz)r{1Ni+YiFO+@WB_Za6Qx@8DC!${BV||(Qwye{&C@V
zkbM+!aXMm@4<4iN`r!h1MFj4rq=d5WvITl&s{M*Xg3qqu?rOq+Hw*<TX!uP-S<bk4
zK`#Is<z|6k4W2_uT>bv({PlvD+#Zb|&cDQSUy(GcABi^+8#~hy7=lo&UnJ2Ty?6^1
zbi*cS+mh-$_Z7ED-R`{;Jk7orN-LPG(^oXhBWZuMO0=W_{eJlpg0_zXal4>1UCp$K
zoI}9Nv7hZ7j+jBk?f)NZZv!7yb?tvAFhJD61c(|n)>LVw7HdMWO-!_t40#bmCkaXL
zC5Wx1DWxri8K7!-=_JbW5Tq^M+FP}FueP+ct!=eJ#L9~jRH_tEQM?r`>Ny>1gL)B^
zn&<o5`^+Sv_TK;hc^>;IIkVsQ+H0@9*4k^YwV_}?Fc?QK-u<8|SOaftsKRRAnmHXp
zyQ{>a7y7UA{a$5pL}=adc~wVX3wJ>6xYaaF`>SHw6Z;%YJob1OOTdGx-r-(588-4_
zoe{i#IbSAku)4$%I+)x2N9N%iW%c)XXY$CsWS78vHMehx=hiDv+Jp00Rsw#XV@~jw
z?HeG)T!YlUS5>@B!!akCXwG^>GU!bOlj0CQO1s@XG-KWar1>fvAdcRHV|Kkt(67Bq
zyf%UagQ?APjCR?L#dvZ3YGz@sqIIrVZ+gv8v)xpq0~Tf?&jNylQKANo@Gay_FOHJc
z#Y~c&r!>-0wAKAA$t?1*SNj+F4KZMLk(H~qJ~g;4C9AD5Bn!}ckUagrs|>t-xbt<s
zj4Zq1h|t?C?VnKe=$6&Ix;7G5*ynT$R`4->EeLh%D1<wk+@|dl|BLgs#yLC5COyin
zajBj4PI}jJUD7{JC25?*z8E-XC2O401E$4A?<;m|rdTzL?8DRT#|@@;KOVII=YP+@
zK}l-=<Ad8*vf4k9WVd#fh{SVzN@4g_Ggh-W-G8E(x0=@0>q`}06alP$dD&tF(DPmM
zGU$ZVxYg3YaUT^69j+?LP8`zYzsj8@>vI$6<lnDuz>ad{*G)j|aI`oQ?mRbx92Zj-
z<j6H^+5HrKS>!mme<DiML}oC60mz|bjjNL6G@u@vZ2{Ha{(o_s3u@cfTHU)c?LWl5
zV}LM9RQpH7>h&X^lGXmJBpYP+6)?k~dFSWYRo&uu0Ejmw=+yFNFAD-+p;xo~d(4*V
z-fsK#zR=&RlGN*W2KTCD_4+lE-P*}op3gBsnCs7enKn_xlQJLhxr-(nTi4V{?n2{B
zelyVJ7H>GJ=e;rSIc|b!2li<{b3(;ZvMa-ldz56G%dMB!uG{X=IHllCYuaA%CSN7Z
zy>?uX%nh$Q+)IGo8|33TraK|rS?x54C(V%X`u8$KL56?47;N}x^=7q)>lp?=4cIZH
zekn6xJp4&ytXCJJk6+__^eX^DdT9?_Z<jWj*#kqCnWdd%QRitYTGV+7iX1Gh5(VTl
zr7`VaS|tm}!*vMPUW4GrsITL--;e3U*_!&C&Q(0@#-xJ~#kG^n#yZcyG~8(d)4~m$
zf$LKK=vi322>QFtP>v1vvXcas+stL_ep4v*q9N(wj@k4&n5<`8vi=;y3dnlRPmd$(
z%F|2~!qXpT#tm{L^85mQ8>gNfGOk-*DvQea-x#!WwEIbFfe(AU!#`ms>zAgDmVifg
z7-MCO7v5v}Io;mi52ZIO2Bek*KEu7SNZ`xdt0?Dpth&v4Fv!`WoR&z2do+x$FzZW8
zScb-sSX|F*=7)3)uq*iS>-B2*%@D=q?le@#o;rINp*IDx`@b={-tlN=aGJ>xFMYjQ
z5v<N-XaiPV$(nwil8xb09vD~F`ZC&nThe)vg+>AaU?-yjv}@flKRv_adHCh+OzI`e
z!zcKrs^#I^_z}$RUW1)>b~`k?xoiIS*&RH7b{Uzs$y={hG`mZ=B^xk1C2MvQNe&$J
z=!DAXr@-<D-Bzq@9&o1JuO0RY5fOZTD9Ay0m2Mh?2a7l=ai?v<a>uwB2(2KLPq?Fn
zZ6`+<OG8fk4wM9|tU$Sum(Rv}$1Nokp6qu{#0Fspuvhs>x1l_ikwQvuXk^1vnqaeR
zOn$onMZ$YxX{4##j(rqjxi;B@-ko@73jp5?-<!d!1DZ@v^?v;!?g82&ujD3ZSM~b2
zKS4c$*!%!c!=!Hgq`$EFaE}}-mdD6k3h|)A*@o$WN%Fj-;-I&(FYfp5z6#~C+rHk}
zjL~G<{i@ltv7!4Pm;;bakq5mqZqb5y$S23IN(SfTDRMB?Goxi1V7zGFe==yMI*{g>
ziTJmY;Z`F6$XsKiTgebh`R%>IekBoOD$^3PWiEfvOuce5dOO`=f6!#jO!izU-5AQ0
z=C;)b00^%uH^#a@959iFn>CUDIl#jv%&RsDE7~{V1}%JBua58bJZXh=rvpmh!Ws3)
zs!{yvsou%(vr>4N*hvmmck-o+zg2(Nyl`jIz7wb3q4iGn+T`Mb?8Nh6AY`XPJ<Ow>
zB@<<~USO=h9(SkYl<Z0kt15dteuf+RK9{3qbvX&#uRJc)sV$A)L001R03-n_7|87R
zK6wLkoA!XS)xZd1Y#~GI!hsxe@x_Q-)(Ee$AMkYd4FJrG{|A6E%b5SqN7sHq!2du@
zWp%!mTFNuGy+9CqT|2D3fUrJfbgHD=ly5aaW4T2~63K;f8wdScmD!%}UQr~i1sGsl
z?O=kU^m^_9xh%I%Kkbbt)9&93-VsD8QP&*r?iS#Xc%WOD!ZLN@hz%bXQn59(&3j!z
zp+W2J;pi?6Zoh)e1d4tHZfmrnCo=f&e~RulA=Hi2G;ahH48Ba4{NL2~2|U(0ggV&V
zRERUtT&GdIpq$7=D@6|wlY)or$t4BIZhai@!T#oqU`me|1iwnN*=7(t+^O4SgWvBq
zTl{95M!@+1zmE-A#`*BX>5UrhC<b$n+j3^V`lpi7)q1dNS}(M_7wz$h*L>JFg9As?
zdS5(d`#}aLf9YuuBX`@PuUu`4iav9pyuZA<7yqWF;DBvvXR&5cW)|^bk7%268*{&R
ze*ZMagNJVGMrSjwLho<r9+nFtO{cNJYg?#x%-U{gVt(zx+V;hVb*s^4Zhf`5o9yDY
z=5&u>aS;t4^oAfS{V$8#{vbi{GCB{n=RYI3EtRfunvs+SEMix=grwGBwTWj)QU3%}
zY9KbwS(qMio<^L(#$d$t^^8}bcze2bWvp#HLl;&K6IS~8`0O*_@`urK|9#s{#+V&j
z?+&N>4k?>tW<j`Pt=hsI(9PJCc6^ObosOF@%W@NU7zdN_sqT#-cR{{8H4kM=vwNy{
z?u-xnuC$u!yH$5Y@<<-GD}07;j)GFjBcpk$#?KAczX7pW!9Oxl*`%Yun#MhJuYh}p
zTbJ*)uW(1Zmxh8+#ZJ>ojKp=M)`Ge{)oZnpQgbnD3*R!76e-b?FX`wz5}IEH=cLhI
zccL8xo2e#bSTWfr7{U=Bl`O?r{z3+0{dKgjSiUq*PnhDZ)*gH<gm*25du7#Yc_2@3
zG94rmMun?+g~J_}&|CQC8$`U0oQ@6ynh?I_agD_zWYLgC8<SrkLX`=A(Yj*!ji&L$
zPk|mjP4I^zFt*>@Q^|;E8{eHv5G&%RwzRZm-FRtM%$tMvmY$jd<%(d)x*dXtbINR>
zjO}kvWufvwGr1bPwiW+8qcATM8e!9L#JdV<im)Whm)Kd|;#LowQRioDL06$c!kybe
z5@YilUX>3FN)D&$lAf$<7kv&HlUwzv5h&=1)^M#C102@PosqZv13?V7M2#)ZhdOtb
zkifNZO?l!@Y(RuA?JM2Fhh@$SF1Ylw@ILS$@n=`ofLN`^a*+`J$T4eN@68Z4HRcBj
zD)F=p^CXWD)9iYWV|sD}z7&j&WA{*Ywl^6w>$EOqFt5-XK(42jatwoa0#{`Q%wEC>
zBwq#rT+;<8=YN&dKwp2c90J7aFa8sM!kuridw`{T1;L5&vpUXeoye6uaFbVO9e{I)
zGRys9ta~HVC%RUw?aH+vcWp@5Sh3sSTe*6=gTl$BIa~~+)Lv~!E$r7PW5bkb5ze7_
zcw`QOGk~1f$+7%J{G1x9Z}!%YGz!QdhL<WY0)55nMT=wJ>39hOQR<d_R`)1#L4EmR
zySlj1D@sS9j~D3q%mWQ>WRe>h7xPBg3=>TEe%kA}kM^)SaIOg1aCg_jR#+3*<>dkh
zu0ljffrM5GS5)J?#uCJ6W53n8o;<E%1&nAOg0KZfG&c>5d;ueBjJ}F|R}Ixxpmt1*
zUbZ9KsjV;u+B`?m*^|NBaHstE_}ffr5GFA)HN)&r<4JLvJ0sWJ3-{XbB|OLm0O^U?
zHJ?hXj2xu&z6E*SRS3esN7LNEU0bpgTJ$J;Rv|ysSmJl!^zy}Kw}d;7aftdcdJXWw
z((cWqGE6BW-(sV?i>?XIGA`6_!qJaROL_b<1DkMOCynE3Hw1V<^D(lPfDC<s4snF9
zhd%~Vp+?Ct>kOn~ZHZriGuMvem|5YSp-nc;@DL#BdsJ}o#xmR)s`dU@v-9VSJr0hC
zI^1iKI}>O67cxLg&l3Bc;YN8G?kFM=VVsJ`slo3OHEi1N%n0>pi$LKMJx=X4sUFxU
zED_!Lxk9B&G-<Z`6ykZVcV~<%*(9WRh53V+(NL`3JL{wXF{N$K5@OyXG8iD{avLnX
zF1+eK!OVtGZvdO9UcDaN#xH4mf0TLYP#YSW4US$G^S)$rke2+}YSd7r@GadEw#`E-
z%!E5mg%rEd^y?BW@voVhck1P$DpqxP^*4>(-BC=fICdlyt>`{M6l91*%(QdkK{}Q+
z1#!>tN73CnI(kmsE-Dlc_>?|dN_EaWrq5Q$Lxme1=Z(HVJ3_QNz3M+EpH=S#vwLa{
z)o#=iv=9~QS^t*OhPL%T7r7W`5y7lKgiS=_OVov)+I!0F5DOedIf#3o^9fT=ux4Za
z_!fwoyeKE!d4US_dLM(ykkryP_f4aF-kdQq%tvlx7x){gQD5KeHeS}?W!ZrDHnwa>
zwMZjx>aj=V(JVHn3SG#pDgaHEbD-TMSl1SnM~lK8=V;=`6YP7q0nz(~5cImmlIk1*
z`iDqZX+VcNJgXZRD7zVW`_Gaw$Xn}hP|_c+$<~Zp#~jBpz~puU%Z+2nf${`rUZ^K(
zH~bm?^|ErUDO`u0^k1oy+&%<Pv$o(+XI`$eAeZI*f-!|1h%bL(gL!XG1z)z=3F+v0
zfdhe)$NRC;5AjyXV2;08W0_${qb%mrq;Z29P5d+YsWIedA6OBPpZB!wA`mkukv>}r
zd0dCZYPfSDO(bu~N2xoPFT9sF(X&~|yyF*gD#Di*GOAuVKg>DaagVVgxPy}p4#WQ;
zc~~T5MF?tDQ|v5?7@K8+nmAYH`4?gX>NbME7yw1b<t5G+@wzf|LQYq^l}7d|mZk>&
zV@keXORAwSoY_C*C^l#IHs_@Q=k=Da>0KA+^}RZ;*Gw_oXm>X2BeY&)q=~?l_($%x
zo?2i6&;E7J<-oC-Dt@|^d#z^1EV{{hLVEJ}e=cW=IcvT1f}V5&vu68XDz$%h3q@NB
zv`s%@h$!0>d>H4=`Sc*l{1Sb#N1x=6n143swS|rD6$SMs3b@-c3B|KL&=|~;pz-Ny
z+;04qQZ;%qjXJts4|gW9Gqp6HV=i+V)|STFB#yDy@x<v}7&O!_qts}~`|_oNseh?R
zF73*Fa{NlS{SNo)Jok!xe>=qtIvfBU^jZ!8nZ0!}!W~V55NQ*{6%@5Z<9q<=)E4_c
zWf=j?5OuN5KLsS#=3MFKufXQZ<Ec&dqRY_c&||f;B{c%aW8lU`Hsx)O%f#Od(#GSU
zYU)+F4tjtEfQ{H>1HQvXXx<w^5&tXvgU0I4#NGJm9tr)5mJ@`@T=yy1RQ?Z>7v-V8
zsv4KvKN`jmdInTiz#8<Q{D~d@PAp7=^S7tUZt#X2e>U^c67hP61<I>u7A?6A0mGHw
zPeETq3Ks?}p%t?br@Hg=n%%2%O_9d79rv&dSLBKU)A=ug(z0sRN%<MC%sN#O=(HOp
zkSO3&VsgMJUkExeyOYd*(EQ@j^xQ&;zaOspY*E5j%ZGHpWEh&nbN*3XMk3@~%O!5U
z|E_+q!Yr?EK3DKM)pWEkHQY2ibwIQ3lxtwby=6BPXD$BJfL5RP|C7o%5&iz1%qj{$
zc;0u+p={sBFpOKden|b1S<w6<A_Im^?4nej)oR-H(YvGm&Qf};n|NJwc=T5cvVRVL
z@@3%~oMpZY)(7?+#HaV&Gzxa!O$k4n&2s$a4OXqtn_FY)gxS5l-kAv5tX;Z?nbc?G
zfx(n}EpCIuof|j@Qe*X0J#lBHGi^^<Vh;`s#A4tU3nVN2Zn8X_c*R{H*BYO7Z=8VH
z%mibBzzKN}Y5}I7Z+6qmP^w0@(wKlq{T(A;wh}uqEw=s8pUe=zi>~Nop3*pns3-5E
z+JoNOa<Yt_MSMqi<=vo#X?419TOAR!`a|1lYMsF(!kp-;pb|EkZC0pz5e5F7KZfh*
z@Xa%H+Dc$563vn=@(c8Y=Qzra5-pyQCvv==+g5{(OJazVEG%MWHo*sy7h#U8B~A2Z
z$jIlQA^t5?Fsu5S27c~l1J*$B4R_2k%}M%BZLtJDwaNWf$Sp&qSV!xjA16yk#jB%b
z?<C&g%pt`}kGF~pDsxyOhjj1P^#stPP%6D=!kxJ~GtC)Nvd_=fC?eQ0KBUt3?A0XF
ztasub|3#T2L)+kPm@jqN@Tn7P%iEzKMq#eS-H<FloemZhI*HY+@2ggv9F{B%EAB$3
zwI_X7t<9T2ncTyXi-+j6%gaVr+E@fEZ^9^xoJ1Neo~tuxQ85TDMh6SHcfLW3)LPl+
zbg;VI>c7}MJjm^~oK@;O21{@zo1eiFw|X_K?h0>FSsGCipJ%*oY_g6ej6Z=!1<Ela
zyhn??D{$Z`Qi{ZaMI{9z6Jl-S{>uA}uJFoB2jZ814MoIgSB>Wd6#u`W6oZk{W{C3&
za~b9}zG?c5ggYN%3H;ylkF`9R!~`^`Dr8}Qv{{~ji|Fiz+yx#UQ>R(_!0jjc5X_3u
zhwSC?rXh&@L?5!=X@5ESg}lVeJZI$<F}rFPDol=(B~NwbcEV@&b<NNl31`}Nr*)@O
zy(72~NnPeHLi8%8LXm;L*HUYs&qIVwn!X1$qAWX_f$kt>g)t7`&IA2-Vh5tY6_@iI
z*lFMCBzCw7-Y;)=r|on<mc17v=u)Ts@%Y_X%mCsQ*52-M^jq^Wira}_<kaw_ADR+h
z=2jkql`FeZ529;I%cG@<HwVAQJ?BeM@79;ysYU5Gxs92ZvOTCK(j4taD<9NZ^&0PP
zm={){5?HV$()+FRr%*6I^*8C`26y_aFY3s^w$^m2H@f}LbEOaYKkD>Tw$pBrNyp_K
z>AYMYp^|s(Nck{W_rYXXRLBCggbJUBLivxeV(16EVe_+$(~IOmj9zzmKZjxl7v&Qq
z0?0Nj|5ohV%xy)QG`C{0mb|feX#9)L=2Ym``s~VO?-#}2>#BOMB70%)viC>EQ@4)B
zTUf4=N0{VAUv*pes!pOwm^?Mq-GXqa9mqCY!_XwG?eNaSkP0fBDmLfsziv5CEuUms
z4&U;yj)UqwX<e-P|DN--_>o)3GKxWE74ov|>2Sw4wCkL`pW2S2d|7|xyAh&uJ<WE)
zYzezL+4LDv1>GnElfKkmM}5+Cw!@t_Lt^tg`lUz>mWab;5c}eFSe!1*!>eDeZvY#c
zb~?QcW}gyi!p_*+a)+5GR$AHv+ZhzAtyaFI2Ad0!!=<*Gs9)wh7@^>veeqA<I@Z~X
zlcr8sK@cP}XS;uydAM@~GxJXq5>6vbM?OsxE;vtrWP(RXV1$HT@8dVYCsyw<cJ%l)
zGxGcnm9eqqhN)v?;lAFdC87`;kBuV*t0|MXt{Cd@RFoez_`EI6?s0A??WrkNC&~6b
zC<vR>Kjv@KQ>cL3_{ZDyEnPV7A${PuHR6s4a~ZH+1F`0OtyK~E|GZXbVb{;C87n22
z`12udw3c`zwZq{l*fzn(hGi6iHRCSL-t0^%^&9yO4sykxMnQIAb6XLkv`Ba#5}|lX
zZs~cWhnfdJIZQjKo=^1+Z-TMiLp3jto$8M!%>)(@4$p?b1v|xVrOt=gZT?jv%C|oj
z)ME*LrJ66$M*unhX}*K&=Z)tImQ9%ZTaPsN^ULYHMl&&SVOTdF1y{`quR0`MqzQcQ
zR$e1yTBW7C-4v~wMZ&7hN|<uJ8()5mH=*l_!kv13AYU;Ohd?%C#ntgF`yGE6!^1aM
zsY1}?ta1}P8T$q$*3Wfzy7M_^@r5Ji<r1!<A5_MYLSC!nIgcuI4I#!wI!qvYq4X6J
zSM7klvyL7$$hX=2JjT$;c)QfccbV}j%y+4(?16Y~Sl<h*{>ndyP~SnZvtiaD61o7o
zYak)7;d4m$SJ0@T7mDz}3{k;-Qjju@c9*KF=qz{g@?#}WI?=f%^g~wLy=J*Re-4DU
zah4msUc6vvH3c3qH6Ar1s-5fn-~mA?R<!JyAx^9a2uhJj46S|P74j>S0hD6^)vu{{
zt0v)$`2Keo|90<tn3tFb^qqfXYB4(ju2U7YC+G<Z1Vev991BnbERDx3;B8+J9zJBo
zGjpzXoYBjAtIniNLbufri9<`$`E|+}dOGVZp)$Pgg_^qo)+74#J}{V_=j&0Cy+^!W
zQwX3x%Q2xd2I*x?7Mx}PLBJF4D1$k%ICDXoO}XQ5L674yJ$kEbXTkhhX1TT3yVp(<
zjBAOptLZqa4QwNGj{|S#J^+j(4R(ybMw73aivbqOZsATxAqaE0=HswZ5p}ktLife@
z1J?9B=Ek_;LjRo`Yw`T~CWgZD8z-GkVOx$yoI=_r<f;NS-p?P;25M9&poj6TnS4Co
z1Ro^$iid}=gY|7i!36EVy)8h{P7Fe!S+&ga#|!7o(mhh5fmNk(u4=AXl^F*Gqi&OD
zrti(gFf72I`dMye8U-uo`t1zQREquG0@n81{W%);E>tzs0s#*}ljH|XY%EI=?)rv6
zw)<FGKm5-~bLANsq*;utgrbeY=5T@{-Crfv3{5M?g-+?q=O#B7>d6r|y|JgnV&+*d
z5PycN(9zK;M->~6u$8(mW_C33B8s66`vKN*8+9}3{wtI=vx=nAWugFOfpP6u4CC$Z
zU<%xVS%bIJ$FSCsiQJ}qTvWtPx-O1%{0YnXI#VcZX%)nY>oGW=7!(PJ%pOe*dAPb0
z{6)J?qQ%<3X+zsx_wYKUen{zIg5Rn&%)DeDH)E%o`v=o-P1$c$D!gj%077=J+Q@yt
z{dO@<I_0w8nKHNg9A@)~{^1<4lX_~lnN;ebpg$hCb9GRg@BN7rTA+SQ)URc(Q#AoW
zYyO1fC8NR}zk*owR861<kVw2m=TU8f`3jH;)ph0<86d_3)aaHsD%;;9`t(k=o%+|Y
zN^Wd!s(avMorFSvcb1826F*zNc2;O0=EO%icxlKnfwFl|WWr{Xw@T+l+BFdhtM)aW
zhuxtvO|h<Wc!_V+4B=H@qt%i=)D8AoRc+aOfiP#bh5H=?wZiqNE>N+&Y6B~~+~34<
zZq2@ENa9&u;?;Y<fBTp)4T<5gSj;uC%-yO|t`PF-y?@W-{iplrVr@7RMZ70Ef#u6`
zrjF<0#<_8v6D@=zcOQ*Y0*Pi#S^JuRF}E1BLJR6V10Pcho;``X0J~iKR<K+jfY(P@
zf(<L7-2>3r`v?2ZKZ6{c!~mX#xYM*kqU#e{9h^B;O&1`4$r7RX5#0WRPx(bm>tB#=
z@8HH=1uV)g4*-(9aY8omz!6g;?ggfM=U~|jga~q|R%QMZ?tBpX$2_I#P5nNQ*KFkX
zssiM&_|;rT+ef7CT{j6bjdJ0(Fqm03=bQpjSl?wq_-YHg$OLF-mQy$0nSrvsSl&N~
z0*J*|v{anb?=(9Lo{dm+HIXNTvwfRzr#+Dg%n8R@<DI&3K4XVAn#HM|K=ICRGa3_`
z)4J5LZAC7T5|l+=YGEOIGb7)roI5A%-8&~cE3lw-Hh0w)fbQ8b6S4Lhn(|J@K0l!K
zQ)ju2kj)~Vzqt9gI*oI~D_ek5;yl<9V0MJd7_(Q7ruWL{Gke8*3;7E?Gjt@F;4dz=
z6TA+|mjMOlQqGpHX$P8vB6Uv~I>^9BMDWZ(XYRBE;?>WWv~2Nw+5x9aoDk<0CtLEV
z92f_GB>B$sJ=JT06r2;6EI-vAv}f<t^PIb4s$u>`WpoCL;<9atQT`*8E?WRgV`5TD
zNpxsKju;_vM!}e_XT$sdB~|}bMI}!zdp6`;Wl2N_1vzr2XD0oKKD~FZv!ph{kTz_G
za2x6!G<K>QD-)I*Zcc}5mk5bHOH3N1s(G$+L!sXqoC6)hG<j2^=VqPh`p@sxi0p=o
z+~jm#&-{cvBc!|E66^qIN99dvy>Ine<?j}m#SG(7RdBwY<C>ZQXuFiCr7>M_#&XM{
z`zsz3WjU4kL^{P`?CmNPOlJjebXaB9Y9pFTV$6$q{kZb)GVQmn_2D7=Ttnk6p=58@
z&T?C>*E`YLx&F(VJ@-(?*t264n<b#9urb#L>(;riCvurRc4n$IJg~e}ww>kcVPlj{
zVfi*`*DEB&A-{qWjduR^CMa>tJNxrC)RS?havn(K)KvHrv^-flOU>cB*SiT5YyWOE
z{2P|)$Q{fIU#m=AF>JW=xD~Bd&R3`wAe)<}e&LP}%{psW9j;Y0_BxHyvTC8#T8z&t
z0S^P6b14JT<5)$kZ^v1r%TQ-2f1&tiTK*gVQ|DQ@*OskUFX2_+Rs+YA{|V5l#Ged>
z3U~Y-(j8z!W!$-PuDU%+T|+J4oqtjV8g$O1e-?2%g`t+b0G+1Y6G$m_jO;Y9BIY^o
zl4=l<MenJp6Pj>;VZ2&PGng1Vn_#oi@l-g00Ct<-Isxy;u4(;*UL5C|;zcx-+@9x7
zEp(zqT|CBW42c9O5S58IZm7_0JiLbT(9lfA^;6IS>I~{KTa8r*!)+R(-8VDig4%vo
zp0?d+QOvvcJ0>_Nb)OQ(m?ubo@&CYgj~R|eZUjqIm-l0PC9n*q7c+QVfeNlMNId+w
zKIat)vG=jPoyJK}9cp+7Pc=KPa}MKSaO7qAGx^pKrWV>+X<k|WI8xnUjV(0rU6kYq
z!pBB3i+2>tZyaygk&ct;(1~J>S>ym5J2V|4W(8WX?+5neXv81TscqtQ%@RYhXrc3v
ziDmY-ckC2ab{h~J?wIgq-1e!?8mM+XC%;gx!H&w6>;I8=9<hu;xa0ex5nXDAAcDCK
z2vjN@^ZxxwTLe%f=#K$4XG|!3lzaiN$a}H+SykQyFe?)7oC3$W;a<_yC-^6z8+p*k
z0FkidvaSPGt<&;C6>8@C+t{4Il%Zz%C#Zo3Z%@}X%}6@kF)PEU8;-;OE|rkGcmevh
z<gQ>_s8!ATE^vF`X>{i2?P=7h4Ppf`_)Pq4xKoiRV9mWp{y=+%xQznN0j-VA^&ils
z42xV_5c66Nu`t#oX7o|^d5xY=U!(4qTqfdP&!;&f3ph}W)L52j%X<o=O)C2@Ks~Sv
zn?ii^82~zYv=9FzhJ`M_Vpe#ST->Gi;w+~s$Dc$(k69DumgVmf3AG%zrOn9Iu~PqR
zQ6HS5Z%Ta9@S=u)TEx;a_U@^SBEv_2$Bx57ELvs)H7}jy{?;sr0S!buDrP{-6P?Tb
z!zXn5EDK<}s*Y9>Y`KFRNQ-jsa4VrjqvJo3m*#ttM@Gi)#KJEA1GxF*krNl)h6KMI
zF3`YdlKDWYZtjQA&#$uZ`4T{JD<^duix-q^vdw(=ZB-1=X?alaA_|(;GTeJje{0tS
zg-%v$23&#VQHCT-bgtwm!mC3m($*Q5%5p#^X_wIo*YVp;pWav+GUlshKW(!+VW1Vp
zezPpU)P`sr=PFu2xI_MS+^Pv~!(=BqN#x^~V=ejkG^^)t)Dl|43S!NiJLi1wAG6F(
z7cUSk^o<YuD4xG2xRJ>Y7bDREf4?eO4#3)yp+@bT&g{JGlR&7bv4Z=C`i&H`nZR@C
zN};_cxZnbd{XOq83M7`-g|b#wF=|oFA>=)^0}8lGj=ZpJfU*;2YGvv~3==!T9VaQZ
zX{8(bt!WX30Nr>md`9iYU#35Vy{xv&zcer`pnIX>0zxzt7tov<LjNdZK%cx}4Qyoh
zEBu2>>hG97`)%m;1H@iB&v{fVoL?%$v&hbB%_vGf9dc$A`D@sdX61JV+8GNNqoeV@
zD05E>sI*8QuMKzonC3T(SEqx|`UUFyyJWU~@%lldKU1S8T6a3C;XG|j2*N#F#+lg!
z4%6`XDzRb+-sepC%dSu-Ob5W9;J0w;yJ4PmZ<=U;zC+aEjR(^c6K%OxDDeKwfY=xM
zPo;oS^&ZsujY2}s;^#g+9Lkg1)wCy|;xV^NWZIR#_1GO5V%|Z|s+pas`J(|fgJZzf
ztmGItg_?#pU}aLZT~o5DOEkTPOzqYIwe7hO^sCx?e_;Au-oDxgp|BS*NCK~ucnCev
z9!~f?jvk%xNM14TQ~zO#`?mo|P8ppzx~z-2cWEY#-j!R^)9Ac~A{#Dd?gNjJC)tTQ
zn14g&;L}L<Vx-I&*B_!n;?R_1mQ&t<VgR4e@BG4l9pr<a%>sYg8d+{Xmu=g2nZAbb
zwc+~5=~5hGuvX1<=`ViE7}iAl546WhNnZa~Dy%tfjGs`2JUg83DFeywNm$$q|2rVm
z8)i_=FA`uZ*JU_n<FV2np8Y85?Z(pAKcv2jj_YfKa_$uid*HYO_s7b)l^ix^SR1oq
z(8fGIUgrb7w2{YFI&N#sP%{hFwNXp`ni6c*Dy9DR*gxslrCpc*p&oDEcUX?6C7`T$
zn%+4&btIefrDeL)bWn_zp2ngL?5UM-*XLX@-FYVc2E+I>a&M9BBi;P4^4eKTirnUq
zaXi^WYFE`ikkS|4)K&EXf5SIlskRhZBz}UkE%k)qpWTJ|$t9s|ZYLoeFx}O?3f%Wq
zN@CJ;0VXjfK5Kk<c;z=#o9ya?n45yZH1S*ambLVwQOn0MHAc3xR@Y7%pptI&5G`@|
z?75ZZB0zo*>v1x2`FJQ30X)2mth6L35FeHS=BmA~Xtvw@Gqv_Dvz#MUPRlGW49SXw
zJGQDA$GIM%co^w%!3twc|5eyf8#RJFr^Sc65q|I_#&c&*p!ei<#0aOdsOJ`eSpUTv
zSHq|WB6qq*^#Qy-nf)e~c_U9L=>;|f?EwAib;|+0u|;3;l5F@sjVK3C9*NI!uO`e|
z;#Z_S{D$C0gJniz`6F$a8SjEOHT*;Vxh*Inj(GcT<e0(W<QekK?U61MDvSL8;&*0U
z!ySL+Cu<vC)u?hW^UsFD{>H@gy}+JH{feC(^KQD?5C=zoMZ%q1;1b~;G;ZgJISJl1
z9EJB~Z0yW?WNo!?3COhq+39Yr#FVk7sY5v4CEMBR>x|iu_-`RT|2Rj~=a=Y{ITSJn
zf278=Qe#?dCaC-<`98uxpABu@pK+ctKBNYv{KKkwwOZ~kaDoa51~xQ!e?~9wQ~bxt
zkfQWB|4Br`He&Wr;YPJVp(D)Nn=t-}(fJUnkDo5#)`fruAl1E!n?8cqTTX4Lr7gzA
zNV9irBBq(FF%-F4%KVi??l2-3VfkpFv5~YD-;&=hUKHgzOU7db+J!lOOS89mDRTl|
z2J{`bs5{=xt&;7NOht(~`=oAh+!0QYHV$^`Anb}zg}Bc(<BioVfyHM`2a$%^_2JlK
z``3)86)siB*+0hCx8A$$CetIU#m00-w0M6w%dCECD6s9{gZ%i&22$J1dmZ`TBceIm
zl;?di8v3*Vz$5CI_l;%7)(ez4Rp*9bN(lgZi&l>-^I`bE-i{T+u_w2FM0|7_EJ2Vw
zpPJ4B{G7bXW)OU$6}0zpCpw+*?s{U<>c0uCPus&QYVHvdw>o>BL)|fRG;qKNc>BvM
zU|MjI$uYdw&@cSc;RH_O<{1fNAD+A+lpP<&uv)jm6w}kYk{RnOoXP^He!8>0)&DlV
z4fH2x=`qjoc>l)jDG%YCX$N^*?=<zgP2=6_B0U-BvZTGR%Beo!nmadQUOVlcQ$I_T
zH>Ye%xXWJB@AbaME`>%d7aq17XE?RvVO(O~+c?*CqPV>4b)tEQ<B%gkV?izgKX2Hw
z;#V)Z61^<}dMDRJdL};=(o#Fo$>oWI@rZk4M1qsS?#8<E#>wGTTgZ0XJ$EXGV-Yv>
zo)db?o%~*CS!q^$qeFGtiPYHoiA~A&16lEfOX3i(lEYo0Wf%&iM%(vDFDJcWW!vIc
zCbtdaU4T3NH@PhT<lp3dYG<s$d-N~I6q6uL`(XTcx$XPi$q!>E8+sTt+3TH$npXrc
z@t`G3+u6-ZuY$z*D>X=d+=owU5hQH}5YxOXGV9kB8ngMekQ1$|uWxXp5d?;nHafNw
zji|!uP!K3s(P7)@*NdTa7YP@~_wz6+8Na3{I+@1Nh)C|r@?RAJSu4tt9?);<C86vk
z771<g8gjf-ofC}3zwp|l63ee6!&2&WrJJafdXf<w45pPrMo6vyDEz?!h|S;2!3|x}
z)63Qzjwq+;fLo16@*<2m<SwgyoSPWW)>z01!m!WdI)p#xFs0@eLhS6vHsk<*J^mi#
zZ!gM*yoNq(4vO968YV{Ja=lznjCY!fFt2c$X#9XfcbtX1;cPnS@ah*kigun_<PMmk
zJVec2-4Fas{28$$n4X};Vy#+pJpY{RENPBPK;fQfzLI;Ql3Vy=$PmoU6L5C+K^~sB
zvI4DIvv59&KS8G$zV=;r>I6O7kw6-);K1ZQ1^ZDdmo79IqqDIiNp+_51+-lJ880w+
z+c6iS9d<{_VG_rBwPlz$L=DmFi55|Vkr+zo^ajMjo%XKe$yH?GuWqmR(3PlJ2m`2A
z6F+yW-*pz?wG=}XcHShXW-`s=+JJ(W^-wUe-1Hl>hLq%)UjM`#2ltAT(cglI-8=ZF
z<ghmjVs!jK*j-SyUJ)?MUqvU-*vHU_{}*~2X5TiQ%3N;#Ws2o<hgt+zZeS*`!WP&P
z6nG6pcB3)xw*t8t+K&K&PB8yAvQi^g5B#sGbC>gaGafSIpJ7hCv1s)C*DT!?LsEpJ
zmwmL~?EUD>;qot;QB?(iY@QQFDDo)c9ijwl5M%`OIqeVhCI^2{%bcfa^NUi-u46#>
zD{Wf2ZE{t1(Y8=kQKW3^()#R8U3J;pCXZanWnQlqZrkKxD|zDF(%_v<^KSJrdcc58
z@`?i0a2dJqoR&E`jG^Q`#_;v@7%a))yg5>^<W5XohodIBh7xY`Bx2m_QN?$F4<3BN
zB(`{u7OL_8={bOlZ|W){<lt%+m|SFP-9jymM_Kt7voK!>-?pAXn^LshXi8mYOT}U>
zxX;?Cj)u$3UD0iaEE;Y2*Z7HDQ?s4-J#luXHMY9dXgV*F{4mMsjo310D3kpZEqlvs
z!@j6c%bejPpRMGt2FX)QvOsg1k{g2L&zfX4a=wzwgXBV!ti_Bfd0dcOLvqO`<DZnp
z^3gcb)hU!Zq9y<E3<Cgvr3N_IUn=LL=CA_^)@{$V!@E~4KSdqhK)Y2rfIvmIQG|E<
zzaSI;0mN0ZjhZs^w6lQZMrFcadHMaBIEWp&@C#&~eS}Q<@ZLM!u16xbdCm!p@j^1Z
ztJGh$I!i8|G-A<bT<H0@&h2FBJmb?-bvmANB2~ViD(Bixly6v@7z;O4&1l%AX4vsb
zI4%B$YSNjvgpSE1$E|`}33uc&C!C)wQ-Nu@^<HZ*GMI*WahRMjZcQk_aEf>C5G5op
z#`_Q=T~z0K*CPn3MVST2Tq?c%0)koUuV|p^mrng=R>|aOwPz~l`XHx5IZe3@W^#?n
znG)ojtsKT?HqR906bCsu16zASYj#SI^Oo>aBM@|-QO>c`><IQKN3G?ObFx}{Ey($X
zas=K{<P2BN_8@1va<o>%$jMU9uY#P5l#|Aqqv~f(kRwC8%n1IjoEw6i;pv={Xzee`
znHA(5<Rmk7w7`3nQxoLuO6O$eGa<;4qrVJ94GhKvId?0^*gSM#4kF;1-QkUaGas}{
zn(wWe)!qWIqb6kVhIh?W;yUX3;C?*40vpWyRgyR-;E~avicY=sSwp9`kZ-of7?t@S
zNmXsx5`1*ruW=4{F=ZHPUJu8|nYYA=E;B6+?&s>VT+QiyY976&R+-E^GJmMdkC{w@
zb7@Gv3{p+LAbf}5_~EH$^)u7fWCY~jDDzdD=_{UwUg>}~(7zxNBMBpxrOyY+V@wYx
z86xd}hKM%K89_@$M``H?wi5ROm=B!JZXhB$Pn#!_*XRwgnOL6Y#ah}fGHGv}V#XDV
zv8laFGqum;K`1S|HJ3qF^4P$OP3cXxG-?5ozX5f>#U%fXWVfcmE?Y-86`?h^o2*so
z8sa1;k$ksFUSw)a4r=Iv(5Z$~%2g$&HN!l{D3$@4EOX<(m)8Vu6M}{oVO^uyUscrd
z?lesnldLC)VvpB_65m*tmuOs<ohY{xY_p>=H)OWzcvZbFNPZTCYiSWAz7V8LW+5Br
zXcgzGV5v<`{l=!vQrbAuu!+}j{>@UxCMA!|B>Rg^BO*ALDd(M&(-r)y$Z=XRO~{eL
zHkhfug#t!?Y{q0QhkY-e(WQVE{8s+jp>J1XKT%^kB1KCb@>rBzWHfsDrkh|d8UC%I
z0niO2nc@~6GgPKIU)Axs57TxkcUtv07HOSIdSQcCJ5^$8Ze!cL>qw~?AM={HV55A%
zyI5MaK_e-&4F?&sSKC3ppsehHL+MN~Y4q=nbH)OZSC#*2z9o%PO=Vav$)6B<<WCUi
z@D{iUcZF7UiiCahC11K@Y+~}SLy}JpvB|u4-jx`FcLhnRbd=F&Y<6BZ5_zN;N8{hB
zb97l1U+mVGc7-CzzZP_bwm6ljvx@oIRrmy5;WD)}d+XsSa_`0FIx{{J*02BS1tvJ)
z-)U%YR))Pd!ln`Adn&CJn1p(U75q%CI*$KCvXG=x9xHDDa#yIqdA_T{j)mk8xGBos
z{r|^+ntE%JJq2a+i<kZs5{YaBcN;5SIs)q-O+3Bn2J3_R^%-ZoL;q>Y>|5sPj$DSA
z`DEX#X3m4_i+g5OIMvT~M<tJj;-3yb);#g>mPq21l1&}E7Ux!yn>>2*!ZzR|M&CH9
z*9X5<bopzW7+j*nohgOj$kcfEYGc6gFsWeg55XUCls=-#$k}eq#N__Ra+l3^Y9_if
z$LkS10?Xz2+YjGvFG^BB>KoS;d%rPjc5+Ga!T5J+b~g6g2hklSa(xL<rv3O?w0&{V
z_TOlG`0VAEPh2ME)f&goPF_ASk{NHR*ADN5)MQ(IKh=#|j-mZ6^%#m`@9$8W)I%kk
zQV(gEpIAm$vpY9wq~T8K1R2J}NS0r%PVqX|OYtV0&A;B<=xmLDBK%kksAVT|OEx86
z8xk)xGEqOQ9{eQDWl>M*?$Ai`$jOTi!M?3yrtX3QF;(ct?x$_$GRj?uu|eXkl1;Od
zQzt5vK;i*?Wt;X=_qyC2F1JPhl6u)xPn?wc-t5(;Uc7^rzNk@}xxF-Sy*1wW*|+BL
zYNOEEyjqVua_y^<VY2NH>p@7zuEd+Bqt>k@n^<PU8FyKKZHgeE2|thL3$cE`U{X@t
z%ZSQ7v8xgl{Lt{t-`7-+atkiPm^?ZH1(C`jvVPknjE=V?kB*HuB#(}XPfH%ni`ONO
zhU3xX(NXbBl1E3PNIsfNNZ+F;#V<%6Ju!YBPPbaIyh4v~g?p0iWZ^_QK-+e7M0`BT
zuyM{y$)lqaKXa$x&o}<8v)zu`i4|hl07MTvPp2NoI-QUNty^hslxZ&U8_ZWBOm7(;
z=xS%Xu-Z;H{XXFJM(1f%ZpMTW&01v<O|))hB&U`&7Q_q78pp-YDr+2%%M5a(<5T;c
zKlKa&_I;`6O-e!P8S{5sY8(3{!!Ia4$3bVB2Z>)0aMGzN$$KN?RYKv8li?E>_e^|7
zp-yFApYG;$RUJ~^&CwwcgQ~a8_ig~{Bzo<_kLT1ma#CW0w$4A|DeW7K-J1)zy2t0?
zQbuJFYj2vA(7LkeU>9y_Oes_eeaTBk@cd7KYtpIQTF}t={)CB2818H_{)Zo65a|I8
zXW+^AdA1NWA57(InhM4`O{!Au=}?q#r@k{&nn#(gs=v#^@|N>WX0P)$fyq1#90dwb
zX?kb)ShJ{_0SE@Q`b7&z00fdK4#bV7J3Y7L`(xsNO};-i{(AELy!ig)`{DS$<olz;
zoqyCmzngip@*nqKW9;mHW-C_+bwyYbI+qtXPYGKeR~`cx1~Xb0f6-ln=QI|A;A8vZ
zV~wj(@2_xzb@4^cD_AMN;hqve;g<L5!%&=X#|kwv71wFu&I3xV_D+&#uG>u8y@JMf
z%@B&*vFJu2{LY_&9~au;&PP>VS6JbW0zL^b9_|eDVeSjGtx>ExwME#@QPY_@&Tq8<
zQiV6gKv#SIOKO9K@-gt}>yb50mV1h|)Dgt=Um9XP!>Qg!Znf$F=NScxwFZJb?^G4J
zWBhTX58fYWwIC>G5+6LSo3`PAl)jvu@}o2)F^q}C-%dW&*Xr!ts_{12@)xN5c`O@u
zFGRl?CEJjE=q9B{1_ulqk@D-o^sF@3p!yE{Lgyx<@%a+_>DJLJb{|i}hE}G$vP1Ff
zx@Kmlc<D4Ues<-G#=hvSqq`RLLH6eMmtXWM--(>cTSqJHh^2#vROKKv@X2k%&3Wf+
zU-m&!{QPC_XD=MT?1Pc<b2|3LFSxb9+05Tpx*Fe8?mp!{-&L7Sfy7^&?U7px$VqM6
z7VR@_Y|G9{{m$-xqgjZfzf8N=abmb>&vRn1RryX{h5!ZhcDtds65Xfex~+L`LT{Hp
z200q$R)w5w5Rs1@XDBBr(P#)1GhANm(yds2jfFYQ^k?`U#g%Tt!9k9e-gF3H2k~QW
zWQHCGEE!KYSog|VPW_Co(CsSClh9pmfkm1nW8F&LU#vdnR8Hq!!>(6P<#f|(`gcY@
z=j<jR(C1g1OT+jD7{+x~9cBF&zNHQ7C*RMHAF%hgi^d$TDGcF@F*@G6oEvj!;8W(>
z#Nv-zR{;xZZaT)h_1eKhQ)flE1xUPKwv%{Oe4HI2GUMT%N~6lv0Tz7rR2FD#O2Lj*
ze+)nWf43fn|NXy!CkMXH%l{ASXYOlq(LX{9xh$K8P!XTS)me{?%?371aSNQ*UR(-A
zu`id#C#Sxde?6;>#yd^op!pmUn==M?qP#U}X>RZ~-}3=7LoB`b?Y4Gjgq+rcsb3B7
z$87YNsdYBro?p&xIBxXbJs9|N>jm0Fovr>C|70h{Kc!=A94ABkn{FeA4;QCfAuO0A
z!x=JO`gC@hOA$9(OrVp#_>4QsdK0h4HcSOWjn$;PAjdh<+?MqLlE`~d9cTywj<Yi}
z+y@Om1y8uLzcu)u#sV%8=ub}&alf&OgxSu5Vl##>kT$y~%AE?-P`ALWzvbWJwZsxe
z`~GBnNneD}CJeHgDK@l?qkjv=Ia%^gmWBFq2r?31jm`L5S{uO7T;Z|5OP(w_%+}eJ
z*lgj|79G$)(9ob3%1sNAKtNlK-%<YtMmFevQJU>U&YXDW3J47NIxb@8#2JNm!ieEn
z_XO5RL|!mf9L|D#XDBljzV}2Y**`{x=!ur<m!TCk+{KOSiAHSpWcw#(|CpN(MrF5N
zcPrB<+2@&)(;vuB22Y!FOSm5)su`T1WMXIMvWv3f!|lFg_@COVtF9HnRo7<5Ki|UV
z*0KH6c%k7yhelI>b)N0IG)=o#)I++*R(5?$wEKeo(gE!z?;~h;eE7D?zM@nQ6kOQB
z>fqR~`<qMx&Nv5jLWA{&Igc#&?nY)g&oe3<IbBoMIHUbEH#&nii_WC)M4adhXTfyE
zCbMfC8dL8?ujvXYmH?<at3F0NfXpS{EXWmCxuz@c$DF|I|J36^peK5bv<ZXm@l<$K
z>Q5FD0e_u==RWa=P2vw{x{=9@?Rpn|z>=9$99&E0xP`0HdO5EgbEfsW32%dFIoDF}
z+-Eo@u3U4S#zMCe9rlv5Xkt-Wb?;5pxDhaeuJ(?(Hxi7aaI-(;o%;l!y#_$wFC(2(
zG!W00I9pBQ$4WLiue|dMUcgWDATgD>oA(bHICCDp#LLJt-GW!Sbk6Rp%%w$ssdT1U
zd#!Vl>`X9Z#ptH5`$m>VjMiMZsh+4gnfxye%xEM76Rj&q`zUzfKl)Cm=?>wa11BlB
zFtG{x)y6NY{%^gP`E^zHInN}IjKxv(boZFsP*BNU{cBJ4S_2rp1p?H#z2~O^_f7ra
zuD&CqJ}~Eq${DGr=?-VCTg5DKpJhgln~zCYe~W?qB@LA?$Xz<$S&)<baO{#MIq#^_
z9oZPJma%>hjZSU}xe<6Le1TwO6Ge%WUXSA!Biyl*<_0f_uO}8=xiZ$sVo{H=q+N-7
z-?=aKTi#xVOmeI~gP`<V2lTmx_rFFx^Z2R28R}NAW%T~VBqcu_y0jWMVB!?$A8qbG
zFJ0Jpy$sguPH#PWKi^!m91Z~K|CTLAC#gr(M5I9P{bJtEFWQT_>a~EbQ<r&u9zAB-
znMXS;@iEmsoaRUD{oeDEu+L=l7r3z)_&m>zTvisXYmd0mI=e~hg8kXON}GJIcMgqN
ze3q`&Ui&$d{^|a2^Zudr19vc8Jc=_nCmPG%<uqRAHmbMo)E&&DCvusHVo#(_ux?w+
zKm8cJg&LZbOcv8aSPS=(dNfcZrRS60-%!gJ%zS3VI6}v}kvg{O$Hi~e#GK|j_ID3=
zForb`c4uHe@TgEM*%w}V;$wMyt=DK6UH|T))u@I`I>@p(gwyxXqx$YIf?WpqcCUdv
z1o1sg0;z#ftF%NV`#5M*x1=*)B9m2#Gcn-VFTZO1yUd!DyE7CF=5)QM8rt5<yT!&F
zrvl136jZj9SAg@fXu{dbZ8UxF4!~la$PU)hF_e}8_q4W&G#K-<STami8hDX__p*VQ
zJt}Q(5;DqN?W5lAyFmwy!5_msKKi^L_rIR^W76k+*B$>a&-+XZQ%wv1(|K?CJ>4g?
zb59&^>g-!m4@lb90K*KzvB(qQ08FBofKcBs%LF(JW@MOvq0WuhIC8X+S%+T&4eyA~
zzkU5==A-CoAqt)u<FNm6o(=3TWx2PUA&96-iR0`J7|`@RAa6RQ33kU?K0bW2BnISd
zo=w8yH%l6?mmq$b1o7JB`=d~FAZcBkeE+0)Y4ZIO<DX5wpBw*7**nB*i54-zFtILv
z#?MjaC+@oy6e95!jBR>8hTj7VpN22A{Gc-<qwm?7dMw$OP0-r0{z5R%MbbPW+-b-j
zYL_SDHAvc6cXHOtg2i(RS689o?Fp@B*jc{x;n|yXpjG!aV7o1P*f5xqo`bndY70v<
zXTrdBxsYUFqSHQgZ}%U}!FIsIx0`t{(&P<@09@^vzRshsOhGxZ@C!&W`@Mg^HT6RJ
zFrC{KpI;ukY)P&9EgjG=vCnAC*|uR6e{@>E_s%ceC=_hEv_R}U!^>PI^+HX^><xS7
zhsL-IrbE2~j;5t0hG~Al&#(v+FkDN0pU!$BG0_{SpvF8WlIfZP8OpcE65oH*VSPCD
zLnB|cU~c2|4CX3McD7`=iWlDb1uiez(Z3^6;BQ%Vccl(mtn8nE54?i28-arxb=>bZ
z=QPB;w{ZIbdXscL2Ni$LLjH@BDaBPir5aRfd!`f-(Z*BiE6LI!@rt&Y=Rn5aWW;TU
z_-CN?vr&Ey*f;1`sJ5j)K&?B&s=7In7N@K}c?=@PON?KdEd<-d>nX`9f&LfnbMSof
zby=7o0zqM0_?Rw+&dCgNjMJX$Br>;cCz63zxKm82e>}*9pSE*OoY=pGG0tfA_LG@5
za)rdc>b&i>V%V-YekGf{20l9vJ3aA>nMxUkoz32_)tb4ax_wj0z7<=cHloD+@3~NR
z{fLBqYMfe0@2MBWNCo;)<g(xbry56ZT7%OVt)0^qwtZudOU4M6S=TI?*<6tBpJcTE
zCA*$nf#xW!fDQB?nf6U=hSM4vg2vzeof-VUY<!o^@7y%F@#F1>GUxHLmfwb77vClw
zFvA^#b0NYAVDI=e36Q>3_wg5M!8@2bqKT}oDSJD->IX_I{0(PdZ`mvH`R<7Fp{N3D
zL*>yB{<&-O%A<McGiou9>n)GwB%a3dy*yfw*y^_MRxiJ7OZ;^4AYM^=#9?bq+ma)b
z%xS%yPcHeGoNZo>shOKyJ~Vz}YK|NFZh7eYi7!@_H}xjohI7WuW|mHB<P>{gGDwE#
zRD8FqDqFU4Lk44GVO9eNDTnB{at7`9GgX$Ic2x*<A1{coityw>KF2(iq$6{pdXM*l
z<%l-l{bzVKH}ZH{*2&QKk2tnIS05Z&5HoMukzrYIW!`;{9K+aavJqqZk1w+W(-NpT
zx-MplsnlTk6XlAvh2E=WXpXS;iJt9k;W3BXJegnTx<lZtPUpy5$m^>d{Q8moS?*NH
zj+ULiG{sLn9fI=$ON-qav0|rD9JLr}rhL?!Pl>XbbxZ%oq(}`|N``3f-3PNUyk^uc
zgSYy{L8-9f9}CVWD#yI{9>FxW*IP}N*?tLMZO)t(Fkqyy|Lv8X<!bw04Y=FYmL4uY
zcns!HETq$w1-(2RDdcv2ok2~uAU;_1sQ@`Vi{W!yXD+4S8qW>iY;I&&mz%PtXL)z6
zH=BrKWnX-*QSak+Y6(Wb@Q1wKt<G^e)jn}@6fK&k2&iMRMXSkcMyZ4oP^@40D<{nS
z&;EQ!6->gAmN{ebFB+?F@S1KD-!!>@f@v)68~5nF41}?+FNDI;N2f%*ZvC(qZ4C8H
zet2&`91PW%=f~P6kcfS!nOU0$IAUJU;bFQ(U-qb(ZMfqwvLBGOWwuqnLy?LN=~hk@
zokqn&AX8cz)Xq}VPEqRj7;b%tx4?fV0<ivm&z8^Y<NF!=JxSkNVr?D#^}k7zv9|m5
zDXA>hwnv}3Pl>f1(WhJ#Ldu!2ulp35Xe-e&oRXOvCYdI=PRV`0PY<>=NS>u+FOytD
za;)tdHT{nHd|F`h%;(;J@Tq47gd)`EF7p}DXAhrt__Op=d^xsW`qXnpo3l<o-!OH?
zGk5>{<};>GJa|w(uFrN`zU@wac(Kg5er1`Rwg<FuWtrq3kQ{4!MPr;CR6L>*r)Ekd
zf{I1-?qy|?XPSyPs^UpO#eY-9Kifl-CmR)}#2l6I`LxT~($)pM0_6Dly9POY6EooQ
zkbfb?EPrC(ClR!%t{Bq4>Ljoxcq22I!!`7vX+Os6A<XEoIqsU2w{!{C$f#v--_Ip>
zz$&K-AiiAW;}?bNs{>`#Ui@?N3|Cd!Raoi{=X7|bd}>bOCG;qI3RjaC^Tz$sEVUS^
zyR>&N&q+PPKV;^c0+?B%(cSN!;=PZZmfL=?R#c+>;Nco$22mp(=y(#8A2_A^r>u<6
zIx)3aWgXy<iPE~$dLX%(i-`j$mC9np;oC-m8Kn0_id8VZXW^?F^BXiW@9X!chuv{0
zWsS4xK%B_jp9cDC1&NUnExdLv?E@NU&Si(Ag*k~DSwHU|S{JWI9V`$SBkO2I$u7~d
z4H_f1g&}AA2|L3bKj$Z)ILQBdu`h1m;M02wz>yxGyP#AyIp?vC_?RtgEDm?c2FGng
zA%tnl)Czl-o1>tQN0bpY#wC-U;F}+%*+lp8&<kG@?);Hbh~%xXClFlBsX1wJ57t;A
zYG?>9e$lb23=#goSug=7xix5;(<4DXnc8M{JsOGcf^hyPff8>3c>Y`86<S@-5eyEL
z_KUGxokdGoura})CU5Z^UW`UmO?sj3$=TDbJX?j=K(?x&;LV1S(%{+;&S>$jv|JU#
zWZ1wU%b!N=o|+s@p{FKSe+&&RzbM?Pz3*?edkRId$^>fTwoQBwVDcFi{=(E!bOJe9
z{#t4U=Mm%3Gk|#&1UhRD0p(HN&^O>bw;*c3iGJOk$#WYX>s_vh(=^fNjz;Z<@dxg)
z^Oy5^YJ`y3?~<vOnNk{ngg=LA;zbZkCbi>~9IWeycb}nBksQ58Bf1MHD$D0|9hNBQ
z1vvhWO2grUsCE?>3f-quv(cMPC29o4F!t%^X9IpPM7LCLb0ZP{T<3ECzvOBH8N>em
zAyO6QT}bLo(F0r=#dDT_xc27ktR*9y-G9(W6=50AbwfX(;=9Skg!O*Ojo?A7kEr3>
zmb~Wdu5z}OJ(c*gk?%V9Ee@4Eebew6Mi_&p;Q!aDA_7^jVQjB7s*4{0>41OuNO|Z~
zDMKoAV&0$EWwzt*1R^674bz=inU#qosdao$8)GUnVsG)O7z%nV*FBah-c(L+E@B6O
zQ^HiZV*w@MQsJLs-lG0)%ua0_Z^Rtd{V80abA#U@R!oonr?>6>#J>`<U>^r`6U>k0
znySTGsKt^are<#g1aHuY0yIH5!TmxZ3zghX+>=80Dr-%2hW|I}1??f9onhp&aK{Uz
z1~S_3h49E|uj-KzPw-KM_Bt(vzAT3s!Q~pk)wzrS|7M`e=hGwb-=t!2C}g@nnC@O8
zVZN{H51_naEq|?KcvH}8B;9NACiSall6t;EzpM3WSLD}x+5kGn45hJ=(Kttb8x}|9
z$!(bdg^4+AM(WFTA!E@2aPi^V!tD5^AP?Xmx-!p5`s~Wk-30Xk^{Op2Nq(WJ7r2g+
zO#v|uImoscA$-`2@YxTuy%bq9^{YYqLwE1aPT2cq7Q8_YcjA|!sX5i)bJF7iFni$y
z?(mXZMF~n|ISi=ZAV_w?FW%%F@=Do#b&3B9L}M=ZFB%$uJ6$31Y;b*T^*L#NcR$c1
zl;xunSRrS(F1}j4yo1B6m1R$79myw9L|2ZO&zyi(NkQO8fwTr6br!U}gJz^(-gigp
zAwQ~dU7eX2)grL=R?_UfB$C!al*igK@2dOib@0JV=>+b!!kzy?Qcv~c{F~J^ZLJag
zuVwGB40_tAqbvR^=OwRP1J>opJqq0viib726Whk{{@U=1=2;YuNo)sQ)h|1E7&iO1
zP5btnK^FvHp_3z?;^_n;Z@6PBZM)I&#pam2L>;~D$-^nPn<#wjvr!u4Jg<J-Zy^Qy
zqVl0e(q^tJwp{J()V<g}2R=SMy<gDyrM};G2uS&Vq9v2%%bdx6iI@Es=lk={v%p5-
zttupM!SO)j<HgPgDU7oNWH`+o?wv=ooCzrmSS`&v75e{Ta$Cq9PVym=1H@ot{rnmB
zm%(jVu1L%nm>qzbR+7M5c=#|Z!ud4E5Rsqu;ch>|OJ{SQFc=<W_hJWD$*Dd~^0IE8
zxN;#KiW@1aB3*K{Jx>Q;co=_C2U#BaK<b}C<MGp-m&~0K`^kIiuPnmVMNa798oGT$
zO<x5ih!=HDdU*Eg0R`^~3JzzkW`H_jmMo^t(8CO+j$5P2#6cK_$9JB*<^C8*zU$^c
ztUmtD!tC|fhCCP%1`>rG5=Cgc9(F(__Pk<FG@QjhfoG21#4k$rnf=IdLfeBmLmb-o
zvL7>g9fk}co}HXBv1q^<+TBRg!EgTw?>K$r1m_vvj^ei$2Y(}z&l={$-m+qw5y0K4
zewn^s3u5b>#TLY|3MnTfONZM7#lRaTS3WIZbM^Hy`j%K9A>)g1UDp?0;Q@K6aqE+P
zoGW?<2HC6L164GhwdF91_m;OKoHGih0rAs@)jf<m?PX&j67HDEFEn2G;BQvbd4?l$
zXKE>{ljXw`5ndSb1d6d;0HU;DBeAExMcxqI8*^Id3PobbJW7;WI+u=8cLe8)q40@E
zu+b{f)?dy$TDP)7!4zTy$s_{cey1+KCsM#H&`ls0?Dc-8&!)YwN}Th=ZlqLQfiIhO
zI=-COGkcBe4MXrBMQLZb8%=5rXwW~YoB7407>!$LL6+ysBNLs+jHhHlMy{v4MYN(>
z?<ZFvXLMNeSNAsJnHv}h?m-Ix-B-K)_iq6|r2Bwa1#db5lTO@A#w?uBHg=E#RRbC5
z+JzoPQ3I^d1GWw!Yilo1XAHf|%Ale{z~_>I*drM2_o{gZE!TyKNA*UxzQVmB-)Se-
zYA+|<P5>e`FHY+ByI1AA-!9~Z{&ozZoXW!Z#PX{O5;>_)m+g(8OI%9Z+Itwi0l&^s
z+B~*Bv)IGRstOX%(I3$ZoW+VpwQ3&AP_nC}&l|dnbGU+E0vPQ5p_oVoLo+crk-bD0
zI?teh62H8U(vp^>nZ_}$nDY7`r<t+NEYuS$tvIeV(x5ae9z(}<O1&yi?+BWuztBtL
z+6tEss-tq||Dl+>B(J63of4|=+il<FuQ->ob*Ok~2$1)KSOaY+z+`~xSRTf_m}S%K
zyVZ-R<s7>86pSbeWH8ZgjolW?*zH>wz+vx3#r<03DFw?eVQJ)Iy6jN6!_@3eh03;D
zgO2!N2k7lfoaZlMH_8ZdzxNzRx`oJUZF6h?-Js7jxXS_c?w%@Rla+c3bGX3h?!WCg
z-qJXH<2udSX^-|_r%mj|j4Ao=)V}HIYe7%(*NsyJcOjP3T)UFmVm!a|bQ#=%Chi9~
zUOP^Cg!v1|x9#TnUHZ1o651tbHlHuh?M?q@+Cjj9anCGp=i@RO4)cImyh`0Zo#s!}
z0wT<-1$MAAFCX5DG&{T<umA>eUsf5sR8A>0%UTS!tQxECj+E^3e)23>h7l))&3-@*
z)n`+$IE#*heBXNFvZF=uysk?5`#)jXQM}GS#k8tYZ>YJJiXiA>J|Hfif}=|*ElhBp
ztZvD0T9f5c(HfcvW&}EYGbjm5qCF^j>++pgf#0OgoAXp@!pmkH3UIsMJBuG&8ElQ8
z0%;q=<CJFaraO-@avA_wLuvh=uMGB?)23h32NCal7p{c{*;W;M*(k5`vjc0`i-Cv#
zq4Jnh1H|&6Hte;9+*ulq9)9O0auq#$e`g<8d+}CG$Rbe9gN)prV$?N%pagnxh8ugv
zK=l?S^!X#SH80OGQ6;mwhXp{H`}Z_Z{A<;*v@#WtVE?dw3IAb&!>gjEQSZY)GC*<v
zK(I|JN$=RbW>cFz)rs;0aY2L{tdn6a4G8N-s1va6AF%6Aum4AZml<-IT3hJ<jY(U?
zNWO|S?~5w4(~IM2%KszZAE8f&-{v|G+p5F~seFTX@sW!7>s?EER_35F_Z-MC%ij(s
zTC4(bRW#d#I#@MY`%wq1VQEL|SCu|jeU4Ae*7{PPS?$VUn7Lr9%Rz73_3r@<OK@>0
z;=ucqP}%&P@TwuEdZAlb3OV;VlNCx#rzrAaOS%^FApI$}UVIp+ow&y|pSWkB$C)Yr
zCXX}w6#>11Kn%fIDW-K^zLY*Q2o3=c>*+vckyARuAiuDD8jm@(?dt+(+W<UgAwY8S
z34Xp0dIitqRD}|w30=kG$IE*{A`<v{Hb<1TeloyVa=rjT5j(L{oEJ4I`d#oBnR(+x
zZvYgQz5skhfNcXJMBfJMQnwDA-<;bA&5v2>R;Pbr2ZM=?`G|?dKl3jp#TjZQb&yGg
zJ4@-**Lzr=jO<Lk8ZhYg{tWxJe~CYMPx%P^G4I<Tb-8A8!S#!)OWye3@an>!H_&G7
z-VNSvGsxfUZOb>lRdEp<KgHR)`Gd2PPiJc}ypjJoL>l?j!yB}FV%?_zbd+|6w|O<i
zN}9XO)b4@&M!NqKQ4j>z9^6nvXkhMzNgPwT|MLAxe)|0iH8TQctg&q;tVgr=F+0xA
zP2b+X;dxSG-RBM%P)q|dN{Q4h1MDvYdko%D5ovy3yb%`U3U}&s*z@^r?KtPgww~zq
zLM8w+xlvjvZu-~`cs6^M=mo;nZJmb~f7Oj%UvgLw%5k=B{_w2iGugr%JSQOMB%d*8
zWPijOO#=(2H+$bmH;^$S;=Yi6J_nP`p9^dtIsE8Mf;dD<4&#<F^)pzID{{JJ9UB08
zF@lE{;WmQIqcH70n=G>e*DB)~L#o900H#@6r)D*H@4aGH4bsq|S48rM>Fs_V9Lwcb
z!1$)`e+_@Q{NSDH&R9P=x3>us;creu*=D_lvZH2H0K1`zbZxxNS<j+8jEU%BLAG8)
zE&N2kSJt3VRZ*R?jk8vuWncv#c~FvxrFY!2BI!%2&WWFxJTd}TI7dQ>5$;kRY9wBB
zZVdIenfkf=ki-I~7Xx!tzwdHr+guX+QY!}y%uL0-su%&nTR%>76NJR_$y<SKsC;H|
z`w4~+KaW=pBbD3fdZ)ZZH`OayqPqj<sxhN5-ic92P-HCd#B(C|%cd)D!K?hX9{B1b
zK_&AO`A{r~XIT)pdZp~H@Wfobnuj$gb0uttS6#qY3FdbzSck0CXRPl$qv}StpkC=}
zuQ!TLdZHC70|)u3ld`gE%09oO0el-Y`OpJBRS^}ECbGUD7~yZuF*ts2FgVR9zR63W
zDYBJoda6vzWuIUAD`MP91^+{OPzbr!)$Zs|y<{A<T}qO)UnUsXw3R)E4!cdO%SX3g
z$SafGo8K71SfdbQH@`UO`OQ6m^Zg8{>h{y+w3Ud_Wv4COWvA+V=-e1dwy)qs9j8u>
z??AUPVj{j+r-Guh7S=D|TE#A?|9$a&4CkqnsU%ziF}`;i*&krPa@uVBUV(58s3I|M
zGuhYiZPi?hUe&ob9!rXo?+Vz0)H7<WbwF$L)2*Fh?vLa&E!;6f3m3F^*MRnPwKBe;
z*?R&u%TNv;kC~}3{k>c+c=yBO7)HCJnLf}iGv2MhP!38@WyNryC>%H2dl@Qt`;(@)
zA_g|OOxMeK9V{^TOvyffwb+xBr3`Dk@KXadWEd(1X5|A)f05G8`vD+7#%TICm|vro
z%pMCMzOYzMXcFt4>g^&XufqKYIBxtCyLs-VFe)3JX%8N*nV7>HmFfpAE+w~zaFU;F
z--yhAJxW*(6SsBa=D!Squj~k{$g3Y$n~gy47+yyHjNxm^Cb#|Z<QqfY`9(ZuwlFK%
zGlXY>uVp*NC2oA^wh?M+U>lp%M%cDdvWYg_b{s--*kl^8zR}srsvT?-aVntz2B*U#
z5+q6OJi}7EtviE|Z%*r;02oc%rLmX^(;n(1J`S$RFGN}CCbl20$zlD*>jwp5yor$q
z!|=`baZXObM3x0r5XLHavT#QV=-KlH9;@D)9}aw#5&nmjcbm53H~4T>4lV}X!%(ZN
zbt6=P0d-B1Zjt;=U7=HC(;V*TAs;0Gf}X>xB0PKUHF}abc9naBSxw%dS?!_U&d+BE
zo~BT}(P@2v<W+g-G~CubJ=OcwywiGrPxU%|rM}t^n-8A`A(|d=s_ze)ee^jJES0l6
z^io>9-<kG6K$X<r>jWfm6Z;u3Ze@Y{aCh1|G$i7@S~qf~y1%S-f4E~MDoUCT+I?bY
z2J@P>J2e$<>wY(}$tA)9{)a<%)5=J;e}=bQ7tjZKX{7AqZs>O~Qkc0|`tUGQ>nHeU
zt0#MC8RsaSg#t*LR12QZ2(Jwpz8AGFr~I>A65K0b^i;3a9!uqA2vUtZq^x(z4Cq@|
z;X^9oh6?%t_Q$6L_WQNmS0b{w)%PN2ZA}vKspA&?PWLMENWDm2*^#BcbP{Ww9@Fm9
zb!Zf?=?BZ@5YA-#T54Y|9J3&=UJG4xZ^-Ei-QpJaXb8L?eZbhrd|aU@Wgrs(ViffQ
z9Bz)tREB^eA}`*T(T><pH*s%IB%(&d{_0xaZM|P4?#tjXZZn#Kr8if1-H<(45AO}m
zA!t%Coz@5X>5Fq^MS5)>M1AEf(975J_$sU3$@}yOKNF);r|FkObF;A1_M*P6lP^2m
zdIsloVobW3_2mnS!z-5tM5Oxhz;NeU@T1?*&37>e%8<3%Co>Cd>C~mg*ey?kZ%~+=
zEck|C<c8G=I=ZybonPQ=$CsXzQLti#;f_OWG{mZlbte2b^e8~1DcnGZJ7lwx=`yZk
zG+3VlywR1{Kn~C;T66<)WEt-jk(#$rM+B=72E=JRjsM7wNq*NWye8Hs_3L2iEbcBT
zb{7^p=B})&5M_m3$dxo{c`+oa%u&CM3)XbQM2le2GJ}vP=N<kNwM?_lRTa+s!txuq
zW549^01!U@he0R91o8rw&&~$6>bguP{zzq8VA^3_h~6eRp%0<j75uIc{DKpD3#;jT
z5X8$#ooXHx^3+4>z2H#A9QwFJ+O1xLy~6GGT&-S{dMdM-w1p>tnaFy!_cvc)IOfxt
zS6IH7xy@w|7#h6wDCecT1mi|l%k$sj9>8@Y)9Xp2CEqVV!H9u<3abx;Fx4{Swn1|+
zzxii_{{2|*=c-KufU?-6aL1XD9N3+K5E=R!T|stBO-XISp6VUic5YR%$i+PL4`tiJ
zD@y=PdS=)=Brft}<mk?1EZ4nIf#i`>(7+!#l}8*p2JDOz8|mMk+|ASqcdQmua?!}d
zHYOl(rV3+^Ww#pOu>+sX^pLvGjYXguhWb@&Yy;`XXAJ%CXL47G=?%Iu^yE+eXw@-;
zpds}<M+r2y<Pt7JM%j*{ZhfTe^d%G2INrvg>2}zc&|Y0)Ur-3{7o`Lt^eDS@Pf+9$
zA-LIC!9zFy1a)8tYkj8U3_Ufp)Ua?M6GU7M`gQ18g2w%)(WTpJ6lKUk&Bb}v)&55j
z=m%0iOT){|FkftvW_XSvx6pvhgueb<x^<cs!F?r|#=D%ycE|NpMHo|-|BMt?l{oiU
z-A}LoAi`zf%Ngi==%+MTGkLhj#tQEe@oSd<ciuye9hsp&Yt+778Dh~kdHr0SQxkET
z3;j87Q^16S2!O^8{xN(9*l-s@NkG|%g2*MoYLU0|Aa7bMyHaa(k{ICB^;8-$!Rkt!
z_tJpf^A06!;TJR*ixZ0@EJo*U^32or)o%Mn5>_Q3*LqasPTS5CGdIK*h>z7VTD`}+
zlEX!O#EF!NA|#ZzZcM!3U&Jr1>wb2F5ojk0F}QxeF_MNzV__Nsz2!A*`mc)!5t_|=
zZ^IyBb}i{p6YV<P)QC3~Z8@|8-=P+S)7E5fcbhA8JHeSSCEuwk7_^yx0%tDv-W*nT
zrpZSoVD{;G^OgC|w@~T+SaQrmM(jMCIFZ#Fj@__BAfDDWqB)B0tgff6;SO8xc4*L-
zS*{4v%P4{ElBkGXHuRitqc;d71aIPj0b_^|m&M4Yrn^lTrr$0SgG#O^!bUKMd&gI7
zj{{E4rl7l(>dvCRrCD5oajk`_YrEHtv|(Edrdw4J%oVjO!j`)2GTlCz_+ijnYPHBt
ze)pO5Y>ap2qzTpioRdscbBr86oB{N7BN|wk51ROxZNdWCP~WfWsI6Y3R#?IJrK`0o
zm;vK}h8B>G4F(M%Gp5I4FYYaZLII}aKwkY&S7^DLWBDmw;ZJ*@&Kcsb<6s-882ASp
zlq<G(K}L5-hP>$XvuD3`dpk=6VniU!LnkI0N@)6vx{D)aXJJZ($Ucw~PU1v{5(b+o
zwF?O*oY~wDZ>QJy>>{Me$5j@3R;&HVRq10<8|TxUYUTlJupReqNu$3o)SvYhqr0-$
zY26X*QPdMAj@`Nt_j(3z2q}&Dmg&D`o7s^a@qQ-M?vtx4#H$;Z|IS^Dg>W&9jTm{a
zw;O9D4dwyr^b@0C7b!k2VvNpvi*=U91!Adtb;P~2!fEYrrY-aKJwdCsH-nlspq{!#
zv0OE&rzXO>s;7?KVlXbB*WgUMqq!}zZ7SBnZ|yLOFy5B-)XX#G*m$e>KsoRkbH6^n
zFi-{LgG7zq#pjtPj%w}<=pTB&FIkTV*JL)76xxPKNo+OR@Nmc1#pK!jHtkM=YI58z
z$l-DM>OR{$>ceku=w~F-djUTBZq7gOm<z)@h1xOvA(<*hPqB=hrGY%DLthwvXUuEw
zGWo&6@o;ssn^@+==IK&JiuMlYTX>F+*vNBi-jQHV|87XnA);oBw3renS1DE<06E3z
zH_SY0+^R@fad_2Xu^v2DHjBh1P3QrqlG_$6IlZkf2q&=iIUFn@S}&c6$BQ5?s<mLa
z_C!pJAg^g*E!0djMa%hf-xgpvjpx;%9MLgkSH5LZ(A7f*)$WRea4_mu7BXq%!xp%A
z?=m<%j26>kM7ZPcy5}%k&uUP<h?3abhVr`~DgDby3vjGiS}|fBih6p_g7;}qKOjMy
z`v^nw9TWk8a16(q6gLq1L5iCm4ojA`AMn1%=^Joj^Yfa$!^;9rEZkY%PduU%+${f0
z{kEH;^`Pyor!pekWuoe|;3$p%1zpe`Xn&dU`-lquO1{z0j>b|a7<&|s5LJcSx?SEC
zv)w$bw7?~ys-4{TSpW0^X2|!Z#OVPLW=hvPlD62#A3S2)F_qk=2XV;ce~jMT#GS!O
z6bqE|%a5heo#3(CAb}{uqWMNc&lzBQH3WPe&<8xeobpI`|9?1p7x1Wxq<uVr0VWWf
zAfQnqL;(c_B?v1BYA#HIU}TaZ34#GH7_;cEs55{<FgP>9$uWwGF6(;1U3FPyS5#ax
zENTK-5|Gu1sNrfvR?l%z;|&7gBmeiUK4)eEe!uT|{yvZ7%sJK7)z#J2)z#J2MZ2_q
zmuo3z26Q!-{0^M`7E53nG(DOeYNf_fqB3)$Ii6su4bN@CV<+SA8qV$3Sllsw3S{_h
z#Mx@wtpeY^4ra~4n|P%@tR4`X6$BHuWx9fEXl2;TiPf}%Z7Xc*M6AAz5MEhkhxs_9
zz?!0&&jjZZ6>(Wu1i-Ah!kQYGMjkp3V-11;2R~dp81f1hs^AH9V@zPco=$_6dFAy{
zm^B~CLl0s)Ia762j-H!2KGpR|2KzOBpswaXZ8Xk<Bw`@#Y;f<R2&vj=^`47(-qA?@
zZ22&<ow<5H+r8RMt|}44pw4!VAKl=P0GJ1wtfpOv8O3VWTO5VT0Kj73veBX4Lmo&#
zpkg1azpL;RYnpilKiK=RcP>{m7p^!{7N40-`L;jj$A6xQS=Stl&x#7f%yQ3?YO(uq
zOZ3dgVCw5{aR<YrcB`<3Y;B`tV2TA_5wVWJv*l~_d9(4(hn+}s<1Gg?G;gN?eWXc>
z#x-I9Aa(ybR6>_Xtdbpo)ZOb*4?F;I@LyAeajm?2hlv|6Z1#Gfvh*7!8c)@zL8gp|
zoKai|@&rF6=CAYuza`cjmv&eXKFK#~LC7t#*n)5gKPcgw`w#n3S9ug}!ngPZ;XVC|
zjk}io>VnW3K8Gzu43%vD<!2DcMCI#%*Sr^vd80=`LB=*2&&^;W8XVW!o~R6`i4YZr
z$Z>Ch@eqP;0Kq=)M_ub~EI{nreufiy9EHa1vCqFywJ2RPW1>>b{z@f`=6US;XRW>+
zM7B?jS1SdI3|W!F<P*S+=>${w7?+HJcCiKa4Vr{)|MLN$B2SDI>&q;BQKJu=YuHNW
z&JC=gCgXWXklCA5sB5_vV{TIOJp{4XSaZy7W$@oL9?*F?_-m^cBON_zIYsutcn6Ks
z5Sf;Z(<5KqZ<h>BqzBHD1I`Bn`CA6#kt_;sPnhFcqj{9_hqXkC)!+53NaiMUB!>VT
zf(i*Pe!3S{n#1&xZY4(xMrr;X=1HuhalA{kcY*OGB3RHx=0emblx^gY*N|%nJUfE5
zR_7kR9MhDtt4}x38&8A&7Mt%laTZ$<D5?eb)2Bhd2WU=~QJXyu`p(m!9|JTNMoR2^
zuR{;L!?A`SI?jE#2@dv{61ByS663^C)y%s&_b45gB^{iV26g!^Bmk-s+M~m4A{&+D
z%!e-z&h^<*v%-H?{QOb#0Vq&*flbGg@3OF(R$ak~R9w7Cwrr*Bpj&>60@+j-COo+V
z@X|S8vutmMlE7iizXLGSnE!*W!u=vY8Y5o?T+S%-OE?b@oO~&(k>P4P@gi_DMeX*E
zS2}68+wqO#PVJ@tcqA%wa%BC?Z;4V3V)Q&tq(v<eTAzO0hh{G(i;Z7!Gp8kBv*vST
z?{$T4r(Z@1oqx5Cob>rYJ!hhJ?|fRO!bsRp+GNW(HSU3>X3|+C8Z^q1gHQ^>k_XXn
z3gjO!TO)ImbYZbEQBf^N3lT2{4Ny>QTx7k3f6MOF8z!24I7Fn28{E6tB5Pj<3fKH4
zswwTONU_1~n;UhjezFO~O~6pV921kEV&k1(l=!5xCNV>09>);F+5TpXXCb{|yBaRa
zQxm5bak-DOJd7YZT**wN>Xdj7iC4gVTd?U71OyA>N<A-=%H%^R`|=xy$8Yh)A9_br
z83L{bfbxbs@z8*KD2ZrK7UrQ5rXLL6jR%}YZph0dPi%*`hVvKhR<#~zfK$ZU7K)yu
zGYHJ{w?#P3bI2+z?!0}vV}+K-s@H#xHf=!&BxwGP(CoXceA)j&?;Wr&WAsvvcuBB6
zCzC#sr}&82G0^`iAG`8`jitCx6^rK<J$XGUZLdR5%*o6hfB6H31o2mei7?ZqH~$dY
zm8IcN{-N<s*P|0Kw$-T(prF6<1t5l(sLd!qL4*xz)94RnBV56^fyH9}Iy{zd>C~7`
z(XzNAtYo6`?8azoIwkI4*qalZ{=z2%v%Sqh+>Fv@EIbfn+!gx5OlX_T^777g#h-Ri
zJ)IG&i#=Te-y|HvSE7r*0<E#ICP3p$U)0kftP$BTzl3m0865WEBMri{?d>DLeoStZ
zhz~P@pJQS)n`;TrUcph7X$V7X!FOM6wBd5T6gjP|CL%2UTr3hHH#n8PM>;Lna07gT
z-|!n+X^S~S@IkH+BjyC>HAfXX4CNK2JOvY|FcO#EDiOR!#$K%?6TTTK28Xi6)yLnC
za#f2<kIDlxC<hYn1^`-wkR^8exxk8-H^xetJ@Cr^F(R8$!*;r6EzIKpV}64P1M+X5
z-$FPYbGkuDR@I`r9Kl*2!sapikTvV<SeLSu0JC0eNKu-L;2&48ky6FeeZ%mO0PRRo
ze;HzkqdTp}HyeP$n+y*J((|<%5omh2BDtvuswL=ejuempzCte1X22#R-f2J)s8|Ol
zsT)rl2LrhW)~q#$kKQVXENUPz>iinc`T@m%$%b6vw_dT1E?ZntoDf(#1k!XFp3o*N
zBXDcPF!Xva3x_&S%jjzOD|{F7V9X^<9C)D+5&9YI1SCqcxXltI#c9YJBMmP?(PZFj
zVi<&PC^mQ@r$`YP`F^}R*|$-C`&$u#fU3WZyrRxSAa7!(6o)CiEAl?pKWzF~@}2S7
zkF=xK4Ai@xT><`M*rnBItys(&qy7${qV<5cGF9gtZ9X6VVGTRndyIqs#8<4Q#y#+U
zpkh6k_&P9w^X6{+1&bcXs>u9?*tbapmWFc%qV0EM`3QDeOc9Xkq750fC$!JP*r7>4
z8W&!+(M(2Y?iz&aYwk@*=<4180}3}56dFCUBotsW4kZD<T$6KJ{F<Gg&wo~AhQuuG
zJjPyMbhQd79fq3%z^4BSKl}%{h`|yTv3g>_F{pL4B9nSSh4c$QGZAow;}9G9&!O<7
zE{v%g8Y^g=K&$Z$?Th@I{cX#CGLjb{*^YHU2a;KdLfXgJEKPn-dYs|azVyI^B>(q9
z?%+>IuJ3D*i&E?ygeW2^7|Ab@ud<)ObYOZ!lX6s(GEf*NXqHYyBv^}nJx(V1cQXR6
zwNRQSye|cL7CP#{*um3GUy}7c^1A)d5;uMkj)Is{rf}iln?MnlKtR$?=QIPe16MnI
zm*JL%XTX&gd}D4&2-IeJj5FWDskM8Dp*pJRhMc)<i!I$N0}nuyuar=p0<GCzA^j8U
zWfb7j)Bhi=qH-~5Me4~<Tv0`KN8YyM;c~}Np5Mp2LKV*EF@_<DE~~5cJtjLJ&etH2
zh$k}MgOC$?At=E15LTRwvz6pI=i#%5f~zi8{3Gze7$fi-c(mN~V#EUQD7XmhJ*>tM
zRkN}4P0+k}ZU@rwAkf@9QROtM95)!p@=zc0E-V3GWFEmS6E=Tv+r*7{9e0n{!8g01
zm2**Rf_CqnlEy&z@Hf<PHKu{c8mroZ0$Fmvh_V*!mEaQEEvXiCxn3=JhqM$iM`Efh
z^}}uH#HZZxqn7>_LtVKjvG7)#9;hKrn&#h&2u1`=&_Q`NCL``~uE*E!-XP;peDnhm
z{G0~w5DsJ6P7GY_p68D;1&1<mg)<d^j??ZK5?B@HAk^K^P(|bgtN$=Qtb8W^B+N7_
z`=*|IC)nGH?7tWjCSq_ACk>5~fPTdLW+o4Yw)Z&f83DINw;DgfG{%Td)~_EXNr4cr
z%4-ri7ql8<LAa%_BY!%@epL4fh;$=^$X+BM!!bUb-t>(}pLLey+&3W0IU>uoY^lhi
z<oH29`;Oq&3-)p31GMs1A;))6%b70#zuM>gV*c<ta>AUF|8J{T`xqAsb&)vHURG2v
z<sZ?YnGS^Z&g+e9E0%Xfc8rTj6Ozuh8f&noEtYG0p5%u<_z=J?j&(dGgA?Y^Vx{I1
zf#LNzn?b4ZE$W8IM4naUcJSS9>z!7<5Np-A1Ei<k1brKXt5~ih+RJh;sB&`rzgVu7
zImFjhc#UNT2PBS4s>_4E=ZCxbK`zfhr>20{zu;}Lad5qm#5jV2@{{uFL-k7c@<vT=
zL8|ty$5XLfi_(+rJ>ROImvWWg3(_TvK(Sm)a~1&-SfOxgft2K3C<FQ7Yr&8Ev{ABH
zZbW*Aubc2%!RHD*S-zbg-nQW93Ouj9Y3A!SgwK(dss^>-ZL!fupi_#GM>nxNLcoPl
z#NR?~DqelZ53?=AO!`qg&jI*je4W<`F{Df(u6a#36^D3W6!9uSOwvvgLpKZY8?efh
z><oew8Q%eeYT;ag=XGKu`QZ~moo@2LkfN_UU%yNE(_47iX@oo(Ma+Xbs>VLVu*5<<
zToCh0n-@vnZBh8W(0i&6*7L)47Cc-<7U9`^JvIves=)JlBo9BNS@7Ego|ju)#Mj-T
z@QVeWT{(sy4*x?2iTOu?=eU@|*Pr0EV$4*5=OszM<%dlc{BH%G66E9Sm!j|p@&Wxs
zRKX7qTkzunFZO`S?<wQEFXmU7$9v$T%;A1S#M_zEqWN(Hhp~EdV)BJv8jhjT7m6Ey
zhHA(wQsmrb{`P|tSnv-<jjPGwbEU=<UfBwLQ7GcPi60W}52xrqIe%c??-K#_oX&X}
zgSt9r8;frJJJ^w{Bpc`W@KMj4%*k;i9x-x129Vbn1}F@3eSw20egrD7XosJOB7l$H
zc_TpO3I6m6#uVr$+QLik86d~jmrI#J0Gi$nK+_aLZ*1gTCB=BV6>G1HR`CSE)A_MD
z8Oryc@I@)|pW%ldf+t;Fm-I5<{IX6+wG^v&ULRCBoFDe74-wrvuRq>R;JZfkPEvw;
zV~l>i6Ao)W^UfQ9VxO^zkNw(rb>mT)g^@?jz4Hd5gpU=?v0i(jSiP~1n{2)Q3!r26
zq}$Ldkbvhfcpw*ze1gBY^J4(CBm|{rU@=3b-{;Gp*d71G6YovwK!!Fs^JFN9OVNXn
zrak=S--T3l^`Hb}++!@e&2o78-tl-|*mpimT{?GgPRb~Ye)_XMYYgVhKcNJ$tkN^N
zK&eL3x*bFVSE6yH4eJWtgLct32F-4~*{hAm*d}A2*3c#nF$VKneF|*)>+pnjfi9)N
zVPV+jBFL+;$vcQE_e2hmIxJ_1IS!@b$z;{<*&x3CDES^rdW{Lc!vzlRR^u<vVa(<8
zXdt)NWl4|3mxZ|gS+h&|?;^48)>!H@b3M8MsNS%ND79ggQ5jDF`E+&c^9<E?uTga!
z2uK@ZWG|7ebGxO*z>Mm=#yso$1)aa&jq-8!_>IWUpcTD{o-WruLjv}_KD8k~!YX}e
zv0zsLgueT%G!>I@cN1@+_w~~nBJWc_OsIGfNdfrIe^`H@AH?I^D6W>Niqh2zm)!|^
z-Z0~()nZA9n7*FgAND#T<8U{9AK$Zq<K29#1IN4jpN>3+6GI%S@1QsJ^C&~bP&Z`F
z;9G5XYH$rd&KZIA%_SzK7!2;!9nu4Dzi|Tb_tt3di%EDTMfr6RYRV$ynKwQ3Ct_YO
z%ue5Km+*aTb-GCNoAzt}nu3DzX~ge!78=jkua%<@C3dlI5dvr|vp@N(@OnB+@bx_V
zwJUTN`lKM-6FksMoJh>Xigfqd@)3YFMn5kC4T2@Z8&J%)QCt*75j=pl<5N36l^D;@
zvl2$HBhOyPf)t-_kWWGD6Zidsv+xD7;xV4X5l3)`7mT}tI~iHTyMJ84(TGn9_W@lV
z5anKrRCVRP9-!$t3cY)sFw~bK(!DMw-6DSNEzlTahG^~4=pb_&=4$LN5b-8F${~yp
zEeQ;B4k}^0_vUCvy@iUgQGz1jUU&ovGcbLv^_I5)*f<w7fB=&_3T23Uk_Ji_rNmH#
zlo$xdC<ebEL`aE2=(wtwYRbF=g9b$OwHf<C4D4fo0r`3Mr#EAtcvmDooo|0y9sBgG
z`m_hgBNuXf0B#=Ps1WBz;es!zZWBE~p(u)e3UPA)rKqRO_tmqgRDxX^1q*U52{6^W
zFC$%Ev>%sY@4C3SM4y&kV7!A5+SVB}i@nCq?y9fd8`u$lMGv#TqP>L0HM3sCg4KXr
zN!7I$auJ=uNf46KwR(;ZSRQ#4-Gj~X-g^GpobfmKT#qcp3%zKqp1;9^TnX7rRBS<^
z;YX?$B{kS4a&MTI5bg&^PsYyj^-gfdz1GNihFZG@{YHsAjT*hEhW<F8A{!_yvD5Qw
z*zjp%%pkQuUOy#W)8WNK$I4io@5KJe>}da2<CE80&Mu-h>nGaelj!&0UHER6;~%kq
zz=eD4{#zdd+DY!uOT_X6`)27L<E@$2$lF2Y{sE<talsY(Tn#kcy(2bC%=_>aXhlUW
z1Z_9O(4GKVYfzLJAC)Pb!uOZK7g3XNHUcU3XJq8$A?bnCk4^5V0AvFIb^^dX#-<<y
z00~2f^l$5!d4tDmT(Sr+N;d%*YK%Baj8vb%C{dU()9Us@t9sE5-PrB!P0*Ho(SMt~
z0t5XqU#jgSNNC!Hy)0d~wA5yM@GO{AQIR@w8_xJHq#35U>CVm7D(ZDS)%sE`m}2A1
z9KkL8gsh+rBp4{hVb-<|$g}RRFE$>n0O1D&OFgvzJ9=p?CLhsD`L(eqPkkB>z6Uem
zz(WSvz~)hrF4!M{Z^GZE^=!x+MVT`%z*nno8LV4wv`G&&@)Kl~6H537N;ovXcD(!~
z1jEq(sMOJ4RC%TSanu5%wK9fcr0R1D9Yu~`Z;5^lz6?K{*%Kg;OVLGCS=rI=A!cZ_
zbtTonMfNBE0FXSnr^W3Q`?V`rgK-k&c4JnQlb7IqJf{7#qOH73B4uLOHb*}NheJ)G
z{YNs-$MG`e!3tjmE@;Q0q#=lvsNV=;LPtlKCqZgBjbq!IIRKExspD1vAb<lfoPswT
z1vq-NbX`mXna|^;K8L9?E;Dn$PD_7M3wez#w<-yj!#<%Q_^i(YC{E4dk;bQQmw5*J
zK-3Fk`#u_fT*idEnKE?08jAD!#T|&-#}6OCEYM5$ff}u}M%^LMkb?%mYnQ`V6a1l9
z8RFjzwT6`W1;#}%%b?{L?v<UXb)^8#%!C+^WRr@T3yrf96|opQQHk~%nVHdkn8dj@
zf32RiMC4mW*IM1PXuQYgsxIut+SY<7gd2K%dgc=3TGz9Dnc5BWwJaZMz*pmqUg!ec
z3<JSN)2MW_p_7*m#R*{Q=3oeKwU70}CHkZXPly+ZTD!sVAR7Zh3yk>*7E4<Q|0f{=
zr}dTjFDE4nC=*IwGZ&1fJT(bglO}=j#8cAYmdZA#Vt50o*Jy7}NSHN4%|6%Q0t;=+
zjG4%TF&#I}$w1|HKrj({4$!g52E&%KPfQquIdcK~$hYX9*c>z0^~gSUSkYP!2wRVX
z7I$)vL72AD=LSobeY+5j5l$k(89QM|xYrh!H&F&Ze^O{hxv&#oF@~8&i3S%GmQjbV
zosFCPbulFZ>Uc7*J(i8${DE;R`L*5x(T2sw$~%OgW&uX>sbgRUra5B{YS7v_O#X?Y
z+VKL^EoK%CtQSe)RivRvMhUiNSf{(Qffdg(M8X11C$^c4rP=tYHK$%fQ;DOj*=sxj
zm5Z9~{`wPCPH}V&DKYvjvt$7}-WB=+11a3f5Eu3}@*NhJ58)_(Zj~^w!M%w>WNzfp
zqa9h?!|L5e_U;HsjqYyLu`WcsxCmz>POf7tr0YdH3JSxeU_O+rc3hahi)wU|!YnOr
z#C-axm;vT{Ak#KPr6;}RE6B<I0LLOI&U$eLZ$exk%EvflUXM4YaM?pHfA+-x!DX#I
z4ogp9u?9h3%9QY=Jc;~x1c+u}d}!@)^ZTA3fnC(t#pXwd>9F*$*GQP7cr3AZZ!_9M
zX|Q#86b<%?`2yeOua^YT1%_*^rNNrW$rsQcXy3flm<AKm;1Z~d2KI-&&Crmk^j4<m
zt%gjTwv>`MYOB$bUhgq(gFQwKhREG~N*fO@<Z=%tLF<kqxA#oMWrG~e`6rIrc7-n$
z69;uM@>x!hhLEU_sH>>R?&Pmkmge%5kN3=lB4a;eoe3>ASI@jt8v`viH&eU&CM|2O
zUett7#$kvDOV$&VIt*i8bQs5ea5V5~AL)g6iVn-VNofU3hsn9gUmYZDVpKG=g=5Te
z&Mf(BnMgKk5%2loG7&>RYYE_ZcLPjXZ~@06bC$S5mC$7}hTsW0@ieC9D!j1#Gw4j2
zp=r3SnQl*>!5&fp>>{S^5H1xM%WfAgnGwo>Qli5tKjkMNgC<=}U~!2tFHS0gSSfc@
zm$pjkpqs}lap5F#JrJ~dO2pRtTaPIB?*P6+9m`><vcxz8RYKjC7;oJtFziFitn1{5
z!237>?~Y2*7nW*h$ed5+nD;@GC@~%s8C+Z}HF%AQH!7kadH!)CzrOAwyZhtXUSfol
z@o26jUoe$<me^?h&>8SRtEI(kfW==jWZndLusFJgz6#e^NyoTCBk>9L(d)E!Xdhh=
z{S;h|kpV{pZuGzdrHG47+*j)g-t~)EPBkn<qwCwkD84@vR;@~}RZwC`5vm~y6}%Lm
zh!JhLCw<umJj<%xla8Z}Z%WYHTJ45(T=v6gQ{@%q+`?Wi<jjLkTPwY7-1aDX8+v~k
zT8~DEbBkV#(pXKa&<o-v<00S{Ol%SdWlV@c+{1pFhGfu8B6zmh3_Y`w$KA0#gS>)R
z9c`uN!6|z2&;3_Ca-V~nvdW~-?E8Xf>yw33>ZrVLW8i)`@33T3-m#fZuTgJ<`kuAj
zBM9*;wBq}Wm+a3ltl-4pT)azW6OVDOwG@Kb;$ATD%UGmS2wEU?bk`N(obp<)ac@L8
z0x>#|W|d3@-h%KipsTzdR)#V95dnyaF!|RTmDvNiJbobGdD=j}69X9&@y1D*FEEfV
z{{sdxQ(b}7^;my`F!YZoq4G3NDVwWBmp6Hg^4TKe<}OGas&B|bPGTt6EFZ_kycDH=
zJ86t-FvQJmK)w>M8**+Up!p<anM=R$Y?P19ck4LcO-F5P&=>4enH10M1QaCDWfoBQ
z2ex_xW`%<ANiyg#2sVAxEB3hTr_5vXuasA;&%JlrWHc&8(~!mEzG%f<5_ftlz^-gS
znmb_LgX(o^h<c5GsY}Srv+)uBPSsH)<XWIB_iz?m@vv&kBVYi8TLv3PXyr6p+=5@T
z1#}yvAE{6DPdieNg~Z2r7oG?#aZ81tiEo^R?+t18T5P>H>UVSSVSdu?PB+FubRa{x
z@E1exPW%X83@k|1LwgSEjanl42|`B(^H3t%LzlyO(Ynf4QNo%m5Zvitk32j4(5SyY
zO8Y0=T~Xo-*`>o74l(0RL-0e$LyG`lRpE_Q;b9fOv#MamIPoXQezhd2(mpOUzQe&b
z5D5i;rW~A{jc9D_DX3j+q%)j^Ow)Tj(&t)h`BYk|1AtN8IQA*mN47s7@r$_ZCto7$
z{sAH+2L`<O7}&002^fbA5vXPel>&~X(EgUEeGmrq#P}vY`9?rg!{0&73bj4ZVOm?c
zFL^o+EE#L6q{)nEQJI(EPsYg4ah6{T0FSXU-{M(khd(u{Kl<s<*s*Feik^aHhB?Id
z26SCR0?uG3@aA#c!pOUz)Sg7Ge~>wkO~Ij4B(p_cBWzh@B5i>|%`%jl_y>kcw8?#^
z!1cN0J@<d8<qksuTqh*{H_}Iu^cbzz*?k&13#CO(x<V%*@MaS9iskPiJZA!rQ5%E*
zO$?r{eu+`C;FS@55A1=JG594>_+S9=!r{<;99qIJMbAw!__t&5-YERFc*0%>=3dfM
zV2p~v|5d@87e-OimE$pb+aUh4tmgFxgvlJjYJNI(hhZP`mn#YUkeb%mSBx3ieaNT}
zQ5)tTnu(!q9L3zEfG)-fBXa+F)}Mc<ut4`X3(N0>V20ZvG19m9tq?KcwFt#d%qeR9
z-gUY%92gyo-2Vs(JCc{4=(`z#e5IT|TFYMp7LPI2Cdd_<ib@0sIZv3u)ISCm=y5<X
z1FLa?4d^?M#WB8bmch5DJOR=OsrX^J&@sW^;tEcNTLNQP_uxWye{Yj<u8JRU1aW2J
zKZ;r1yns->Wv7aYKpJOkoMKB&a67+ylRIAxfGw0~s2;{8X>G1mb<4i!fG``oPy^&J
zvMiqA90_;C(7g(D7Op6p_7y5N<zhz!XU~8|I4}tJSwO;Rf-5!+iJ}R8g!(`g3;;P*
zsxBdtEe*E8+ST~^+Gs20vK0vD#fcVV*7+xXA(9X`Z{k7vFZ{R~n>cT$G#_q{hv6A$
zNyJv`Ikkb7_CRft)*Z;rS2&->?d`FFRd!AOr%mqCTQ*Hpv(B@>BU36qn|EXA)%+G+
zCbP3Pf0+3vU`5<KwqnD#pi2w2Hf>M&4l2Ka4@sAb8KCVc(AvW113;AiNMJBdLTah>
z8#yd=_aUgS@+VNx<b^1lz4kzzaq=Qwh4Ou?2oqa{zlRKa$OJ*@A<9>+?{DFI-2NHk
z@t|*c-E42AYr9j|`YsDQNV1e)OF3lT$=iX$(rTbCZa=b&`xj!-G7Y3>vON|z>Q^Z#
zECH8k-y371-=5QRxN9{a+zl0hSWFQR{_=Whe^A;FJqm~lsXMX~y~&_7-*SC1F1f^*
zl6+zdz;*=c;a38ZWV%~1oAOR<=7B>l9el*J+iLusrNxrV#VbYypHr*th6rfKDFj^s
zaz9L3VE;F8U>v=L)@d_RBX5Sgl04zV5s)VL?ZokK1a3D$en5Q&w(V3zfVLG0I#3Cy
zY7(m4mj92Fi`Te3FDk%{9t>3M0G+qs2^JQI%A<T4UG9+03r4^tHyU1U*?=j=xu*xF
zslkN?`CrCr7*&TZA&LbfP$?b|yWsyoP+JkJFwKs_?dL?;YS9kHFBUkAKf;z*DaBqv
z2|$A<$PXQ8=@O{zqxC@82ZSO+IXuooB5V{B`(Lu!4{k_6vJ=cbsmO6aPw0pEr4^?m
zmD}P}eHJ${-z95GcOYZsqE!DB<Z#rdjHCbhB2tQ9`N`F=@w3NNdlI#RF*s|}8z(r@
zy~eSJ8IzD);w7D#<KTb($Y$A!dema?ze414P{eDrxNUj6PqFiHt39p|@1w;4a$-w1
zat->0yfL4}%YyJg^sD-UI|a%sfr$+aKBz|CLx9mrQq2+QNDmkXh7l|UVBsGzx(GYN
zg3Xso1jbuZ?jgubL7r@kwLmy=S$SLJWL6ZVxBRfGIeZq17~K@S-9!k&yq-qNPB=O8
zxyyhlCu^K5^e(U!N&&k87&sfO7HnRoTJQ;gAgG=4H3A=c7@^dNUp<m@d7{5uw!B@z
zO7KOWnu^G@ixBZFIqn<W;&##e2t;>go*_BmRRpj(2UW<`#lBI6g~cADW3$}>>DnG^
zK0@Y;LLNIjqJG;gBKCZ=v=jCvz#duis}(2nQ%LRuu;X*emQ5X<kcfRDcM42PB*RMc
z7^NRt6fEjt#j=Qj68o+w6wyu5GjX})2yNyF3lx?T2L521Bu3slUqZd%DIk<)ETfUk
zd6iJCe3OAwvBDa}tb%Q5igPom{KRUhoqyH7|LBFAzP~vEHz46cKaB4~C_z<0gVnmf
zPA0zmWR8ukcw1QL^%(2wY?%)c9|a-p6o1)f_5Ku>88${h(yw{W8dNrVuh?Ih_n<3r
zgAszKa-qtduw}qdj5}U)<nE^}#mz>kLV7XC`5)vmhWzn%i~EM@S21ZIvW5<EVcSh5
z3!Hfaoa49qA$r>h80m_?G_ac_cc(|r8+pt3flpZAN_Ig7w|8SQkl-S|JHTF)iELL~
zEJEhv|1#pM|9o%{im1!BEowA$QC<BPauwZH6kap-I`m0R5O~U0;<>zu|J*bV|0Lia
z<8BOuaMRMM0FpUeborW!sR`xt@zN;d(Co%qs2q69O1fNCIUV@ok4dQvvD@tXJSBdO
z(WwjKr%j)7CEX$m5LaZT`Z<L^{gYq-a}U;QymzhA-&{ECXU_HD=cpPQ{x#HDjPZ^R
zSJ4bea0(Zfb|C5nw8e1?&R|=T$$K>=DuZ+Hu1rgA{J)m~DCAY*gvT{f=qBni%PGZu
z{IxbL_G0BzEVzjVkQV!Vp(?4UPmEFT3SEsaD&_WAHPaW{GyN31xc}c`8?hm(8Ay}|
z+h#OMp01yGc;!<qe}^@B(i^1Ck?aV3fvG7)%Wu@&^<^vdGXlqYxq>f&ZviAp4?ZIg
zumdkZF9wdm4tyFGLUq;;u=QLIO@qb`9CNyY-R0p-czfglsj=?Ihz=aXGX5ob=mzH-
zoV9^tJ&<W1KHb1EWIy-;Z!kJTTe$}yDJ?^~><!c-;;7c=^@Oug7&l;92G`vFFu1N<
zB6>J7R@PTmF~&<sK6(W0@iBK)S)lEN>(NsDfOU_5S69z)fh|Y{7pQQaiTjc(oPB*4
z;om;4AXjgAa>7|$;q2nS1WW=GJ8}?#Z%_NK&_T$v?ryRbu6;hh-Gs9$xr;EXxtk)N
z!4&<`Sp761vDM*A^Mo($)Piv-Xu+bz(t;!I9S%ZV(Fx*CLKH_K5`9;A!Xr9CtR}=5
zfk*~#<g3LX`E-sd47tEfUByFq;;7B|8RjXZ12hfv;%HnkW?dYTF9;t+f0geb#)J0@
zgjFn66?;b&)3yZKU`}yr$5oq{>fZu0g#QB03z0FEBG-KW4pz3@E>)fRLz$L4O0K|A
z`o|L<)2T5VFfxtXQ8jvx^ugld1x$gfA$zwHQr#ES8;^xD!3pVfI;4>3k&0-!#Zc%0
zQ!yg<qr=Hw7%J*1-4$A{o-$pb8}X#)H&XIO@lg_=hIq9b%5?Gfvg&kDl)=RO9r{4D
zEwC+7Yx5efV$CD|74vnp5(0tlUkGCv-EZ>N2374o!3z;U@=!jOBL2V?VuTsc0cl_x
zuIB+#atqs%>>6CUIENS&VMzp4gwd0sdIgk_jxH=U7^Sq$#tu#mQdkzJMU7nM^#tWs
z;RCA5BXwPHT47td!lUZ_q8%81L?XsE<108nfyF!kq@FMjYs3cKurtBue?!0tuorz(
z7#`UPpsf!8UbFys-Ih0eO(%d&1PE9Fba!~dS9byk65tjKfX4_u;oo!um_dLn3t%Jx
z%EFg8;%Mae^R4e)@m=-8E@7hd!dl@&J^NgIFZnyb5?6?E$l!^27s}|lX&4^3Ob5D3
z4gp9{f#VolU5q!6+l=P@X{djET>YtiQU41IDG!Zc6YY^CX~yVI&6r5A`w3QBPcWD(
z%yfu#Dw+~@16JnHa)NmQMvm_Q09LpJxZDQV#4Z^v)d?O{w-;cZFt1gNapf?<dRcfj
zQnr*p^@s{obi{swMVg#yVU^8n>b6YsrG%xFub~j7JYnWch}E!yHT(_I&tgp?JZ+Rc
zQ7>@9V3;PbYaX&dmIAZtnnN5FO4OM%Ls1rdo~#Y$b*dwUO5Y6xqIp=+IAE#iiQ#XW
z0?%lS7)_hVz5Z5(iDXMzcvM_pt>pJ#)UYu>1<e-wX*~=3Td0zDSpaW<F&1&#l-x~@
z!?n5}K>uce{te#)$1t6&;G7A?QJjkFfOcSbEo>7GVT4xzU12z*6Ty>+WUhteRuJqx
z1t5h0ITpYbszu}Cs5rzH4Ys~BBQ<r*Hm7+t9+6@-9U5)g5L&_OEy6_em}0h+g^{!(
zI>F9oO}l-nKX<E|E{pp<j(rifz89fYh2gQC+H!~pR$BlUfg#?q@Ps%7wfw%w`hJ2H
zgbgJy)(keC5>;XWP+Z_aFz(<Y?+}Pjz;X6mdN=yPdx%)nY%JW04)MP3L%3uNJckh+
zO=oRz7<Pr!a-4k*A+z!gSlI_GbK&2>3O@%vCqxGFyuB|YP_Zi!2j<<aI5UxnWwyK3
z6?_igGq#EUYxq)dxQNH2QTwFFPWZQ37$ZB%R>GA+$5~fjG4E5una5qUBqDDhsU3UZ
zLdv=vvQ3fzKo@>v+Xk^i1s<cxUYqzE;U!_TbFG7}nVtT1=I?=p{tiF_UQ$MQjOU{T
z{t)>Ocz^~!Lgz<=y9MOp4;Mr53AFGix8pJJEdw_ajzmB;Jmtx&u__(FkNsA{Y$>WW
zDj$;*ZZLW{eI?*pvlexmQ~n`jEod2^-{OB0WpSj@@icIqb_v=c|Cbbdw}D<@0!7`u
z55pCZ-O2*jk9G)K^AT*q7(4_i6~KpAXbezoAVj)MfL@RJEd)n#N$%Rjsa$FF{zQ7Y
zU#S&K+~hi(rBd)!yS`uK9n_6Q{RC@8>TU+_*$lHU05?`aaxoI~7sISRhCz?|y($e!
zp)te4D4zKE22k11uSLdpTJOUiLO9r`m}_y`9MUxo6$LTZ)0`j~!{WqHR;Ro;5dsxv
zA|q^2;4rdYVc;OLcZ8lhga>!k9kAe4&%jddz;r_a>`L}lvIarJy(DrAsJ=K=8%H19
zXri2k1nBTr(@CW4D?~#SI3Y1dwJfIwClYf6twm}pdXFHpaK0g{S++y&kU<V?l!H_^
z8-93MD;K9HELsGpjBN@6@1Mmghvlpii2As)!#@;T-Ef4ZMAC5oA%0KOr=&xcCS#)+
zHGgX@lF6ZFIdDC%!|)?U27&>G+V(Tf);AmP-p7$`fC_NOus>;@<Vc;C=P)OL_gGlT
zZa7`~(=N9c??GO@7WFLW4$&7mON>#m&vp2$j_Ujg2lcoMl<hEi6y4^@DrD1<!=tC)
z4<!DDiSXXK>l@sSqzy`8v|h-#Hx<h;3jSLin_#n``#j|n&!rm|lZ5d+0`{#UXen#~
zyG3Y(g!6KBST)*iM97Dvz`AV4|3g-?YfDO0^a#=w8n?vYDhRiD2o7gIByg2j@w(4~
zV~v~kSH|G(;yQ}>T)~-Oom!oG6cgtX9=GoqJ!A0m7}BTUFOI^eEBIxEC%t<zqV)3S
zGJUE{CC9-_g})U~*miiqhJPgnKa_KW!oNKVUyCR3<5ioU`(yB9h+n}!9fjvzu7IbP
zSLm4%gTH|I$rr4~qwqK33H;eW{N&HMG5Bj@_^*t@k5c$0ke}`S21^-HTdvTc82vq?
z@CgcDJOhN^7=tgude)+U59T(-pC-<7mUn>suZqFH$Np0Md?gCM22bGUsB^6L&WypI
z4=0q>-ut8Q^YMiC(q${{y*LJc4dE3(r$pg1@dSG0=mY6Lep$4=nKAt5M&VNw{;{No
z{M;Uczc+^e8|YNk-WHmH)}Up3pN_%57K7gyg<r4W<+KFpnHPiK6N9gc!dEKz!5DQS
z4_8LvgE$F>sylmI2E;zgbsCG4DK39vaIB2ke<3HXb)5z_3@!KTaD6g0+64-v5hk>F
zIM3Ac8!i8Q7X9;DL8^jy*@AEd<)|g0AZoatQ$VuQ%~lwyo%U>a=%DgaoAbe!QME!f
zi>SmG68sknVLLGammp9F&9v@Ftv5c!9sw?>014((1d=_;;$q}?9KsD(<H8u`by3WT
zG0ZpHn2{0@nEfwfBL>V2cYtba89|qoKaBBXd;s;&NiYNOYJNF&w{FwOXdC_<t?3W2
zzO6PKg$XBZ;I0PR@DwH&Xv+Sv27CgDQ#-9JhIJFFR-DO-VST~IN`EnZSrehOqTH!L
zxBz-e%StsD{R;A=81na`$PdAMwn(02BWKhBk$;X6ugIPq!#ogB^e4q{#IaLf9T8<n
zT@?F6G3;Mq1<;TH@uOdooAO@6IToiK^3}o-(>A<m=oaIaGV(=tH==9kHhkPK&P^!y
z&_bCvxQCY(p2j(dyL@0P48z0hwzGdL-KOW)>vto`4VJaI9|$;631kE*z6+d%IDhuG
zO{rEOtDHvMms(V>qZPQ!SD&0#U@Uz_Kq&mKV6MWTXOGabMrcz;m;+GiRC!o;iH$UP
z4?e4&TMm2PV(!;iG$_xyY(lz%pW;P0Q8hxEfJRJZBMOmNkh1p{0OI9?GktEXmWR;~
zP=7pd=QZBFJn8^OVhv~yBkeY7Qv@g*g*e4x>GjXxWK@(@Bbga;K(cxHQI*hqZ<O46
zY9NFv7wu?BfO1dJ<~w1XfE;?s!NbzOMVniQ@-ilI%N{H+*!rAZ!SQ1KTBH@UZsElN
z)Zj7;seeaFF*a|pQOyC@d^UDQO27zX#_g*6?oH+f;9Ey&RJ5RSp4gBRB1^%7oQtD1
zFX1$T7_ox#8Ng9!42ykwgN(%vD54)YSz2Q|EfxIz5%PuGKFN|J{=Vk*s7Cywvg^p?
zcy?{HygnIj)#g9I1BYNxhnWVLm8YqmS8YgF@cgI%JakW#qhB4N0H6cd8r5sg(W=*Y
z1FW1qG|Fye^}Lh(83Z+2z4p&&uYHD0a&lv2a4647xEr-aPHn#3E!a5Q`d1-W?ZT$Y
zSqi8Fo~vOMlfZulQ8r>xR-l)tn}~7JXxC%}pyxMwiXj_WPU#EqPW6nj1%d=Zpv%~|
zOxCL-&yw8E?s^EBFcQMk!C;XpNkde=o=mP*rOeh}enm@H4vTi-0&qo1<Sba?w*E&U
zYa-!>y({<%UWALH{V3jw-*T*6XjP*DAbzY+Z=4&er4~J=YWZb;w3Z^0##shjp}Gsr
z#E3E@=sPZZP95JnE{f9p=P0&?yf?+&X!azkQx)RVu@Y-gLce#6ZB;|Kn}4<`x-~}8
z7QAdo;2xmmdSZSdbPN^xU-9i!n#RRy_<fY7zA=3F3O+2CFvkfWZ^4T&jXO0SgpZl9
zZ;S(wJ9M&{1pqbQohIM!Ul?UT2AhN1<-N)J{8W8W8ZI|6Mqpw?SV0mLsfMcx?oYED
zi|&hX5tNA#wnnoBkEeFj-7(B6T)ZAvG1FMt10RO!wyUwgu!Q3|U}#9dL=c-tYA@x@
znASX!jd`RV)46dj{5+IuPVrfghbebON7UbdSXhF2WSC-yJ&zn9J3hQc$vh^7d(!mc
zG)n%xfCD<9qC}>GisAxKp)uxln=P6{+9q1Fp6fClmw(PrD>gD-6cCwALT^I8I2ED3
z0%v##kQSD=p-%G+#3-xA7QpABMli1-X-I$&P-k$?EH-wHR5~M1$UvrRuDgqkt447u
zZ9yMud2;Z+h^u5I5xg%Qx=yQTF|Wd;d@ARU4zY<3{w`YmW~v)>)mXf-L!1j~U~y3W
zJ67V>Xo)qyi}p?e3xRF41feRB83DP~Mj<(R7H%;@5`50q>bt%uU9Q_k{35cZ!Ze!l
zsl?0lkeir&H>#Jn{U9$d(NnSm$NMiF+%e?IxiEmk5oNI1y|#<~xpQt-y(W&bwD32b
zL55IY9Dz(wnYrt=Md_v&$U&(#ISnH$(h&YOY6Z&3_?bxSRSDd@0v<{xHkhCH4>4bc
zZG_c|#3*s1SciQHV1{gjmZF&yx?E@Y2f@hZmCvPGT%fR-ymKRb5jtO;6!cL5UgtX+
zqUzmnG}C+*@02MNmNjK2CQVVzH5Aif7PbtmRKhcq9HT0pN*aR+(QsPdlW2RmccD8H
z%rP|b5Mcv4bMOe^!TB4GpQs&{qOJ%NR|~2~U_Bjp7vYhPELZ3}J{?ZRweMD#l$R9h
z9^6(A2|;26Pe%!2OVTmn59hkDsL>N1z`=u_zaOLGo)m3Qak+yHxP6Xvhq?WG2GA4(
zNEm+sh&TU?ci{{1s*t?}I}i5J^DH#lDl`FRcX)7Is{wF5ncT+$_!0md9MQdQ^A_NQ
zQGkBq=Dx=`dcNIh!R6FxAk|ZT25{)y`raM;`UtuOWHeM(f`?S7W(nZKhdT?*GZdI7
zW~(+G!O@3Kol;W%FsZxO`i=`8aG5iL;Jcs+GVmD>^dkGsV}UU7EgAsl-t2!cVy7Mf
zhm_u|G~Gj;6uJ{*T6Bn-c@xODd8k+Ekt8f)tP2Hyi<g}DXD1^ip@h0&35AfVbIjY(
z8qRlGUOF<ps!JvB!aIfHt8ZoaeJ$Bd@|&=ij)AgU8E!(j9MB`p&y-5DZ87@~*aOnJ
z)oPsIpw3FU_fd0lgOBF@K8b(z7+r_Q89`NGEs9xwRLgIz1}wD(Lh+iDD;e?3yOisV
z+aqWe*^+|eCRi0r)E7D6EE<aw-n{)A`!{=i!}J@_Qs4Rd)HKTR6|5d*k?ZNZsW|6?
zSf8wCL<#~G&G0`qP;cfYn;~?MTGtQ58;FI9)-6KjT+k!xIdm3bc~s5+iAAdEg@K3$
zh(T(kDwB}8*8jwrx4Q`IkG9fc_@6QNM&X-v{rtbtq2{K;urEO)jn^Ba@?E}!Y#s}6
zHB=k2<oKHT0Wh;hxmEmS*gR?`)Ut6|JrG5S(Um!*Z8hs*tuT6?xWNf_q2S&<ON0c?
zvwE>1TUC(&Ipo*?J=d`e^QV%B<vXZT|BPZNV{$&A()a<Ik^Ng@b@1aEh@74nJCbN+
zpfra84xLArV%DT^4>nXH`OUTH)$sNB9XIkfvZirXO~;hpMyK@SSmoqCa$s~Mzk_Mm
zoQAO<FJ<{-pyF~F@@Bpo9aT>3Y13X&qY6tu-UH|geE{?lm=!mwm@OWx#8CVgOG6ey
z?mY}e6jDQREp;%Xxp1^rm<nyg@n{5QD)uk~26|5H2j3I{Mbkay3=A{h`UW3We&l!g
zNSkkn`6eF2Hvy*%Ml~%Qq7J#t!udD>q*76jj2biN;T_g9vGWfIH*YZh2ZpkBK;Q+8
zF*t@B5`Y*3U=&iy>+VDPd|7lQQKa(?xX;^+@CP#ZdnwtJKp4FQ0ikjV0htdQ@<srI
z?SE&9x4EiB5UKBSc(uVHy({zVEgXvEdb<Wd;R==Mcq&^NK2DVi+S-hpZx9YiHU765
zMwW*t*r-<=zI*D8CrPdQaA2IncNN|Fr3j}@k8H<Y3OKzMI3w#6{_FU>hPyS{L$sMg
zw4C(Fi*jzXd=bAqgfHW>Q~m!^l^;UdOuXSnL#hvneGe-?m*z>0{4snCG!`-^vsAJP
zGqSN^274;rp^wreW@f5+B?iBup_MkuiD(NSKp~1A!=6wWwE(~Q8~lppCzSiI1BWHw
z_9%u>AHx2dwMPK|(N)MWiBP(9TyIY$?HdV;42)KO`O&gJHy$T%@al8)A2vrm1{``E
z%f-ETj<GX#UNh>MZ#~x<JifQ%EkuS_e-i!ljMVWGr5Fw7?ws$MK*ga%-&yR9T&U#3
z?7B}OP9{2(P{{S@KREtJ{{bm_Kh_u^$l~vO7+m-jX|(9E<u#e-b!cxdp(OIcTC|Y?
z<dekBC77C^IlzZJj6Ez${oNyj%T~spS3sn3MlI(@rp>muBCt-5d<B&u`v;ufkDp_!
zj1c#S6+fS*&iAi^>cD9ix_&*z&L~{)K6Y@NpOt>EH)EeMDxp{*(T`&Npw{WTiFqm(
znP`n<6XUj;EWsptU*zhhG|1JB#W4}#d>k&IF0mwU86mDDgxo4`4kLf9_&Cr_XG(!_
zag2~rHX+?DLVVL@r3)IwvBzDaFvmaEfmRhctm3mGMZ^pI&O^#jX4dx+{Qfq-D-vD;
z2p%Q&ne@i@ANL1?1!%D)zLAWwl~nUEh?Aw#AIodblWoZ|AOsM|<@m4^&3N{FE_;4E
z_XPd*=ruX2NjrN|YP8qVqHuo}xMu*z>_Di;W2D94uC(D?!3C^{`;2l80N^Eq5UvI>
z4xeq~4Hf_>w(!9o8y7x1V&60PJ$DS1Qg>Jrm=*-$%6Fqj!jZpEtQ@t2N9TTZtT-dH
zEN{vhJYo^_euwc6*hz$s@MAHg+Sdzm^jCT7pN}DYr+I*#!gw%A-oS1tf1aIk!Sqf%
zjE!`)g!g(2z)bOuJ7YxD1DVvL&I+Ke#h5Wk0q@<gx<t}IMdckxW`I#!&WbXM<XO(#
zVq?M}Wf`eij3y-1f$^kA&BLvj>WoHpq8qh@nBPz)nYnYQ6-2`?mNJL2?b?ta`^6ro
z<p;@9*pSPNdz*P9uyxyJY(I`BK$FfH0oAR~K{9@>YJyV;iyN!*TMNC2Em-w}O|B+0
zu;ikn>c~v>7=Ku0ef0M*J*22fE~)V!6%9SYyaU<}M=6;NOZ$<hYR&-rWz4RG{2FTu
zMQqLg;CuK?CE3<+nZfTXtnYv4cNtD>vXqzMRBnBD(01VYRZsN$JuE-j`u;nVheZV*
zhR?BUDc`}qztDo<!ZdtDW-A0@N)0vq-rf4nEsF5Z_|6K{WcWS5e+60R#6<C<9J}Ll
z@*M$L%I5hTOvDB<*v3(sDXYiTD554`Cuj}-WFa@6uuw`eFd^DgJ^~Pteaf-aDV`v3
zcp}dW83Sj7!{P>ghTWH&isK@(j30n#5UBVb<~$52>Ug+4u*ZKtBm=Wst+o^!QHYdT
z3cDFbKYvQ7SCENiVTQ?emMhqoeY+)kjHZ!#FmeVwRCo^yJ{|MvUAh+)A^CeY&hhyM
zVu>g!heQ9PzP1R3oTLsX4%Bg0bO^1yfnembkaO}zqF-MwkUZ~lB1Axf1i2p|s0&aS
z&X1jTnCAS=pqGbfJWQpZ4?ABhsaaSDaKQYRl;$Njbj5Xs3G9p9aoQYl>PZ+`u65o8
zXJ4w_yXK{9#bZ21!b~~%f)`k#=i=bY^5^W9tnjiWlCm(RptyW~WGcqzxJTtP7DZq|
zN?~z%I+jQt<9zEi*qxh->C{Tw4(+KjxH<I6{R)f;1FZ4i#8LPYqys#(&cB{%RqOi=
zo9*)>P7Aw?9+9{vYq3W$WMsWGk~>h0SeS!IJZf8a6OeJI*JI>FkzJt<=d1%Po)Z1*
zJz)=q2l_`Pn=c<hws)N-JrjA{I;|7YFqE3ui9A!obG)tPGYGindI2=CJ<y>oazMb$
zr#UcPGUOm-(v|x-Fkb^G=mg11+(M55(Bv@pfZ4>&!#4^ykK-6iE!<TAv5)QWe61Q@
zm8x5`+;Qw_*_T&`aiT5ZSsY`$g~W}5EA9Dq1moL{fiOL+rT!COM?(UoM9(9>;CJ#k
z24|zxktm1=<fCK^&N-Ece1IKr+l<4hjN8>p7^PN7qW0NXKx3y02u`s+Gvq9QWqpnj
zo9AEqE$g$W3GO~mn!kw#DE5kJfHti}CAKAIpAU}OpYu~}`FJZj+gSd_qUfimrIw*s
z+(lN0`%9mQGF1njjI?~!dy~<7imMktD_Aw*LWpr28{a}dW9G<&C1nm`H;YnFmA=AA
z-bOL__&SAXD!$XOIYnRLd?T6q5Sc1DS!e45abwA3TsY7bvlZ@mfHE1Y=QuEgItPlu
zqCD*#D2=6d${T<61DiM|u1}7oSHhJIEXA!nkMZ@>(j>sdoLV+l|Ce~45j+`((>U&C
z<igOWFoq?xgJVB4m4|P9XWH@n5>)7Kt2@YWLL_sFh7*d{<|U|igy6y7&#k#%(0a?Z
zvzCLAg22^XF>4|&Y$(t9YL_Q&#w^V>!7iK(_zrd+mkl{M^tVs#SEsF{hj*9pF+cI1
zdK?`xkSq*~0$1?QKmju5B`Z2ubc+>Lw--6T{20tF07=+5ZV>D}VEG-4AYAo=;}b`g
zPGGmuLnP697s(9b>#JHN;dw<2&%;-|iYXsN{Tcpkc%@hD!x<#&B4iw3wis+4#~AP2
zXi}IG$Eg-d2DYF(thE0Pj4J`B)Zr<jMmtgpjg{y|#2<nPD*zKgT4;Qz_5rMHTR=Is
zS`nwGW#ix!EF*>yP8sbCRJ6iBwGs&N)WzQu7#gyj=$GgcC!?0Fp7>xU>v10%-{h)(
z37?5@YjxU#k@NJf$ft_M0y(Ca%Xlrx4Qz4X2AqnedRJ8SgN`uY5>T_tm?r@K_dVhN
zu{z&_!xI=L28Ia%{&ua56u8FSEods|QaPBT#&_6MrHCJ0ASL@*y>*u=iE5W<w*2Km
z&T&MB^zt%T5dm#WB-Q#3PJyx5uyX((Ch9yDZ8`(drv5LnpGn^yV^#HROo~1UpIof_
z55Z}IP39J~s=)Z|A1pQFf5S%O55x5_0TLJ54E<m(#XmMZ?n555l~<H8RP=sa**4rR
z?+X1Mq?q$bkNc421s5z!h-Do9fpeh{i9W58-#;ZaM}l$GjaSsE8{sSp8x$PuoUVH2
zFth_9sjaYNWYLz$I)AZot8&1fjSO#(+T|i!qa$J#>@aJTn7@JOo~|EwKZDp9`Pif<
z(+q4c<5CH#scyzzd8Q@Mn*pncPg0eLnQbeiV)YK99aCd+D+A}JDE=jZaXoxXb!JFF
z0CV5KaU7HS2U>-s#;zdet6x)%YJcuj6^ad()6^<fV!mXM;4w-Dbm2j_)5*d4uE`R<
zw~(#kMLs@VUGo#fnZN>yN5@W-6l+7|S1H^DPfEv`a6EPx$FOxLjc^4yIp}>QPScVX
zdp?H$f^z&YTP0jQr3Ku#v#34iY_XX1g$P8z<t9AvV}0p3OMST>H2W^ri_;Ok+!qnZ
zSb{lL=NM}s1mkC?Kkz+OO74)D4#V%*#DE_$J!a1m@%|?E52`#<+N-A;<IyOs8MF0I
zvu2fUIbB|GUKSTk9r4|#=A>>0P5gMWCtGBT<=)NsBbg*;OS&2P<cF;3FV=J6s*i8Z
zM?mwd&C!s7yf+oGI#=8Ah5EZi{0;Ef;f51!i*LH3A5+WaXw50?7GYMx@k)Qi)Evr?
zdUX*fwB$wmDXQ}k7V^4XQ~Y^ntNpGZlcXUB&FQt}-h_AEj8@?bj4ykbT=s;Bkz9?0
z@0A?Hye|sRV}wa}{tB)ozw&N6-d(KEz77_L$isAzhm}~}jh}s;l85W3#~TlmQJ|;(
z6lV=Aqxzi2Q3wh0)ASS0L^|=;@<)!q`s_2Txl(Y`41~zC{UsfO@37uO?osKR5%<X&
z4{-TD18ol%y8he>)b7<E3gS;jhsU_NR7R=x5Z}jex*oa(Ge(UUr3ySR@S3CY`FIZ0
zX0p(b>u9T{n2W$KC}v#>dlXWSaRyNG-t8?4DHc!@$yWhta122`*3p4zi93HwBGTq1
zcun}oI`rpAo%mH{gkD%sP@<P47qY5HNN0i9_~SwrNmo^<0!Q*jXZm`T1s)jnwJWp=
z<V$jhN*I)yAk-Sn26pxwxNMP`Y!{yG`Gu=aSCD6CWCi;$AD}vXUzty`gpiJM8g|Wa
zpY}=tx}9HG(BJCCMM8=&Oz(v@AG+TttTlNC`E)KBv%sY}T*Kp3gK7qF_m}Y__<O|g
zW0BP2(cfj$OH^CE##)refo`xQzoo#ugurYVv>oOsL9msQuLz85!6DRwO<(lN%dzj+
z+&P5aU<J`m$%|HiZ>D6GiSgmEWqhIamzd1?!26)k@=h4K35FD*0f%5{=)ya_Cn^?0
zL4ex4`x+IC(S<Ds!9j0y16Bv4ujuHQ><SG7r0Uq<d8Aszw+va4zvfEIF0u<8FjC69
zBxv%Ts{dn*M$8_G9>a-jN;l|FQL=E}13$=lsVmA5%r7>>;B)TWmL!yzVfXAlB>h2g
zR1mVAjv`?h9bTidKl;_ZD~cU!Ek%ww1?V9t*ai^P=9T!3k@+*mRSg5h&ByVgh9T+Z
z3O+Fy*<8vehDn<~J~2StoX01Ix|=ugi9zyaF`u}?H<4VaqlW$xGn-FbsGH;X#PA3c
zF}WQz^rf2!9_gr|1Kz~8LPt$G$S|?M>!_K_r|x`W5=rv}+&MK21UG-=6SE$g2A^gT
z?f{>-cr<tMi2?rRc0Msi(5%Ii-8+ZOr=;sBB6im`!|Q>a6=POee5VaWDb;D-e&qTi
z>@?iRfgkWkMmY<^^KATvB=4j5(Tz(1(}4{7(LAmDrU)Vt3y*Q$?@?Rc7|k)nC`855
zlfGe`zu#p|CB`P4k!4RcN9$4=#9WSw2$u(k&cZXLsC92)q?Yfk3O4;tiC5kjvjuHl
zStRqLwiOu#{5|2Q=lwTo=jcaTVEueoBQwEqhwloBtN8+PHP@vxZ$cE#pM*;d#WjZL
z3pDsuNDkD~VYx^L_v<tpNtnBi<Uj%TC<`ne^|jxj_r)D|LJyiG3W0epc#=@^ZK(Ve
zXr$k1{O(;~!%C8ek7X)#1qa{}t6Z9zmwkSW^Rh~?Gl<G%_GBUA)7LS4CGE~ZK+EK{
z<z*{X9JUDYPSV9qd*2%6)^<LpV*0ac2VV#51xwUyOzX<^=uaROD<1Uh1ZAC%35@IK
z8!A^|Ho%*pQc0(f&JssM0(Zm#hd2mrO0r&<49+}8MTmRT<~TL@m2)#ST=bcH9Re!!
z-0520kcQmJWQTQ2T0?H8`Zb+@0`FGh-$Y-Z*feO(4-I+As1n`^+j7%$XP_0lIfXoe
z4qkd=3GxB&C#TZIj9-Xv<v*eqjpv>8*G|UFCqGx>C)t@h$$S&EioOSI3GOS#8bOiA
zn^RUK<LVe(Mhe(yt+OXX!H2l6Q7IN>9p}KcAd$1d50h>c$?K_{%8isEULIOKfr<x+
z%nLZXim`Ns__(d)c~;iG+W<F5pAGkk*GNM3C}9y~nm`RIBVW{9#OgNVS-*aAfpHKQ
z+{A%#;l`;hcaqS-9jn&z7s-Vr;3fq$m$@E+{pN;^?eCSbm#HqADal?h74-wL@M+&c
za&Z+{A6?jk?W43U1@e;8`9)5*1WDwf-8)(9+7O^|C4I%QYZ;Ck|K9FJc5dU79IU(^
zQ~U8)X&C);6B1sK3?#MwE|M0c^|q-A5><`)LOWq)4gp5$h;3Wq?RBPBaXU-R0z_4<
zEW(&p2~CQ)TXZhGv7^AILgV8FQWO(~m8uCDM&kG9^ioE}r0e-i&T|gjsx0O;o>9f<
z-SVFSdV$`S0VARCf0S+V4V0WarMv(oaQ+8c8Z?4CISoAwS?u@I@|+Na;u2%zizn4b
z|6JXjhEl1X66A9k3yI#sTZztFB{z*?n|81750S^qknf9_XA9<=qL`fxJ?KV=yr@3k
zA)m9NpVJz8Fv>3y5^3IsRAnF=G?`fxx+31>un0v8jWeP}dNuT5?4Sv+ump&tl!pZA
z;dZ+<fH+Kukx_`p1Y&zU1VaTSp`0RYjX<o8hhU;ekzqy0TA|~icnBs{6Z25v*dRFO
z#zV9cf;+7W;yr=Lj)!1?p(&{agnwHFB0V00$)(JjfkV;JBy^lSZnYL^L-47g2e)tJ
zp7FT*UYRWim!t7^W!&Gm)0Yi)Qdm63T|P_3e3$A)sfBueKiFcpY0!B29{Hec#!aDk
zI^M<CYkgwic!JNd)G?|S8Fv~xtozfHe*g|HR&b`ek+PSbj~Fd~GUXMJ;z($4|IEQq
z*x+uHzZM1G-m5BNu*oh+7Y(n+0Dwo$-KM+K;fVhkEJ?%79(@#1fE*-J@BfSLZo{u<
zAT@|T1Eor8B9Ex|LA~^6$(c0cQi>~HLZl|RQ>{fKuQ<UAs-yg$3ydw+&-Rn9U>-yU
z>eBLoihBU5k3dQrdk3UEbhnhH6*qt)N;+I2xUM@ym{!LA1AmmZ>JH*cx2(jK>Hc2=
zi)M^i;K-=ORGv8lc3i>*(-W3eBvaH-DV``Wu2q|pno7kB3)+)M@+&TZTQC*hIa++#
zc;FcDjmHBAu5T0`IL>U!fgc4q3Rv(=d?jLE5*{eD{<pa2lu)__zbSyeRy<IGd|%^%
z0_Qt`2UhI+1P>zUv(QL(Y|Nh?y?n11I->`Cplq15mim(Ung9X0>k1#&ulXb7tG_!-
z@jULO3xCnOfGHcm6g}G+z3y+*MHC#HpSWgtoXcnN5I}MAZu>V1MgFe7bYX_x9r)%C
z20qC$d5UjA95$WbQ7C3RVm=sXH-~m0@`mkB=-hspjcoeazv$IK+c~~Ifwlo~Shw}{
zfBC{1oVO|6^1^!cr&j*N^tpa6w|}a7RcAF#Oj_uv@+MXuzih$e%H!h~=48|^J4jdj
zibl!lT<xf=c4Swtq;q0q9}0b2uZ4qGG*y*20xhn<!PcbBqqbG&bXig2(7J1ll4eVV
z+^FZ%{XwwjI@dqTs^81{um8X6AGq*R?6|Z3LCX%hpoi*O9HX`+Z3Y!(S{xZ{Z#*fn
z_S1t|)CwxLT0C$qr$15A;d*E}o<WOi`BFYC?sBDnQH&}wB$!Qh1lrDCco&GMD(;q8
z8#q`83Kn-=QQWO+YFEYB?5YxB?3HZT*v=?cDHO*iEF2Lycnw@*bqCKF+Hp;5M^Y1R
z5vW|;?MmN3$g_-?nZnim&HPOTseV^Y?OyHeu4-zoDwLX<SkwD)HBEKK==JP%3<=ab
z_7^)V7dtQYP2T<8?rr<O_`GHRZYGglv%A}{QPUIln4h;CsdxLI(sNVlTDq3i8IF<R
z<b;Hw9XM54cGV-@UCZf9!5T($X4IO9o$sjfCRI;Os-D?Y*`Bm8dv~{Vpouuuw*BsH
z&0~k)cSdd2il%@uiZnED0~H50qw->BRiEl?$l!v{_U}e%*F)Gm=-A(EcEcaBH;c47
z%cGQxA<h&6zBK*Zs;(>Ck%=RHS1dTYvLZ4Q=NX|`gjMh}2(yB<{<A7?PB~e&?B<lj
z7HuH&si`j$FY$lk`sd=rYHwn79>u@G;@x}X-A1iViN7d9^3Lw4vt7%-5^?ByrGHg*
zjswvr)ec4%Ce$75u6?E#q?8SBSavY61@ic{qYO7$m(_J36PGY9v9>G;0eo(wOv_5C
z@;X*Dttk2l?3kG3T0TkGdAQ2M9&|l47C%M!nDWu?$tw3xv3?A+O;|X)x?c~ZM5sIH
zSoSrmEUP>2(3-5ek{Zgi`%=J}k-khl>({$+VOr(2DT#qC-Ax|X<g;Q`j`<;ei<p_O
z;pyle@B>}1s=<v93VGzOs()8(hK8)pesAJA3zITx*~MAVpxMt)JZHfO)w7q@Turte
zzr^>|`fJca-{+ObuPU{tjLCtP_u#7A0&UE~dDcU%!_IFPjc-J(=_swJMa$n;br!Za
zKw5`X;99;*@Q?EM$N0#t>OOIl@0i8ff8&exV@5}IUR4))wcwXPN2=@5t#}{kNO3*#
zJ^_Bv+O6$K`1{?5Gj>+>nF?-a1=>@pr)M`|H_~rZ`>t-)Dq7!5K>^F56zFg+y@-X;
zt#M_Xs*K@BChhl}0I&9SZwqxSEzo|_j%Czl>;&qnzB$)cPs(oc|B!f+@uZ`%<D+%q
zE*xAg_zMH-F#fvXK}ZvE?!19$Z5?IQMiBhLjU@1*LrcLu*A)o;Jd8SV(1845Jg+@|
zQjcV&CL+RiK78^1GxQlS=lwnOOd8??k7TD}k5D2)7%77r*D#(?C-Fx5$k$M@dc_&M
zD(jpT?t^N>wxKF3waL)h<=5~nRoVFTrTXOFSA_^G|Gp+eecT#oPt=ebrW`n!4llR>
z597DE9&H6q*TeLzT~e`6t2pdhA@@_>ouc2DjKiQvS%ajNfr`V<2f9bnGLB%dA#nD`
zK*WgvT6rBo!?mNh7(M?m*5;2q3QX2|xaL1QcI-I%6#`>_tc!Hj4pck-q_rp34&SUb
z)wOgR-lWylebIe*oq$y*Z$J8V-8WsUleOx8kK^CEFPw=xhku-SOxsg;u-ouGEYp2>
zQ#FJWiXp91A^)Q8OQ-f(-S^nXZmo9o-6%C41fGuk!<c1|&mLSvKTVjQvM>pU5<%S2
zQtE<0eX4Y>F40N-#f^ZTxj%*B@bnI#|Ii8KcqeF>zOK-0eAlzZvBwPOR%gY*S?BTY
zMt8eH)c~37Ux9-(IFhjpJG%GC>j&_9sw*Trk_r&<-u7;_gyUjQF*A95o9jV@H*}0|
zaD`-vl<k~=BtH+1<2yWrsH&>mUygGhbcF`vIkE}Ib@cn;=x`z+`Dp23G#IRqEl#Ur
zqW0WoYlJ&9wpC>&!=~^#MO>;UcPJ_!S<CKR+HrI%48sK9Ej25_5p?JAL0A*E9&N`4
z#eI5m^-Y%{NCPRU+pCk0)U^-VI4Be;(3-20Kd3VXCbm^StUZCo*0ps>tkc?#euJ)T
z>rr>S+wkV$dlKu0e}ul9Q|;)ZW>&3LN+10O09tEZ+o0i_DG>c0N0h_(PyLUZ_o0mz
zf0L`%sEQ*Y+85PJ6D>M#JDpD7ZJ<+uAJ*EeI<$7s(mn{}XuIpofy0|oY2vZEV_isC
zwc|*&V=JUh(ResUqb=Wa!IMtRKwfH_8HXc(gm#9#rF~fC)IJSv^UbU}Gq@Ai18#|o
zRP<LK@9i6I&oV0-hc^Y<5|&Kx52>1(m<#xetIo<nf&SImM<*sO+*x@n-S=Op`Nlxo
zpr!pGO8sTh6)DcBMFvsd&v+TZOdW|R{H$O5uvi?5<WE)K%H!$2WWl$f8*2BTpA-28
zc>VXwe4nEL+7!SKB=2x;)%6{q<#G@*o25TeAGh=4zfYxoivP;o92BVP8{FpqPmp2W
z=fJMZVZo!SU@Hqo@CjCdMY?Ly86f_QSc~xMM>ge0>DcIc;QwgP1=610zBof#xaxZN
zHFTB#8nn=A&|PTI2+}oH(RC^58crVfsLmq4Ym_Ncla7Mpn-={Z1pPin9syGXa6wY#
zvEKe%lKH>$&;Qu}n;9vcneo8msO@nyUpN%!Pr`f>s`a{p8i=aub82sP&5C@Ju@?<H
zFSv6Nru%f?d8%>euyOses`@~l{9nS01~UQl;st>^^*2g?4ygO;GHR=`5{K5JqCjn>
ze}Li!teh6Sxr+ZFEp1(wsy>ld5eqFSS)xm{gb7&AEm!d$WQwZmTGhu~g0Z{oAiV<1
zj`O`ACP!6P*Jz;)fjS4k5MCtnXKX#$9Vy5Wu^n9?G9PmMdb5k(rF0AAo%`d+)D4eB
z5<;08#T`+Vh<h1+nAqDlYhseGWMWUBSKA)x1^tenF8u73UDX8;A5QG;|5p2W`1@E8
z78of%wZn}JpFy=FwJIfY7Wq|qJjr)v<?)`r-mn)l!KvrKSHHP6AwBXPZuM*6cticj
z%bMs*f={zauQ;JH7N^HMCjYB#4%0R{f#!XNyjsXL&HG9cv}`Btq5daZ7QOGj1iR&+
zXI>0}M1ZAqMxmWc=V;TcIj8Wara#d#g|e|8EQPg!7^P$lG1^5;4FNCXh6|-SYkbwD
z3A`||G}&Npp-gWs+V`TAud6mA`34G)Dkl03hdPk|LP7R9Aq~?SetO9Yr<x6t;^de5
zaM@u7T4-DLb1A*Qv<7#yz#?&Q1>Fnonzo+)6bt{+oYa$pAS7qg(+=0~oYKg{OnGcy
z*;0e0QG)R)rWS-1gU~PcyKDB9r|h4RqIWgk<7;?EeIH`mgY;QZ#wWXDM$fMg)H#o2
zIb431UQ}O|jj69S(3rR)8>!Lj5iKK&uQtc(>V6^eM=TGIUQvq$)V{lrAltEjPD<Ib
zTT>HTj%GPp(Rsj=lRT8`;Xq?bnU(`TQ@!r4MF@XY7U$I|GOZ?VE(C_%wasHkU|EKK
z-JdpOf9YDI?_&<Sr*_xwuK23C_b7ZT)7@WfNG?M}*naog19i=^uG{^)L!VbP@BZCa
z*mBY~SK(;fK^F*5YFd$-jBk5Ockvs}Tq2%ziZihhslDMD?k6UW>p2zVS3N1AgDJm3
zUT*48u3q$l)MW?B=cFd&zfG+wNUh3E4IE4iw45a7R9r;6KPzQlPRjn`l-R1Z@{qgo
zM5Zfr4jkJaPpo$LF0L}wa(3Ub-3ZQeNF!Gpm#%b>@o1uI92(5_#foM@ICs?<X9QZV
zNo*pP{qEJx$6{Ri7B@7<xHRT;E_LP){6ARS%d#HJd#>!`n3P{%l?A!p)nvejplV~c
zjO)}bOFC6J@&8?+KHJGY=^Z#YD9}=uxHG9Kw0A`=G6Pq_a$;Y#xK_A7#FEQ3v6pN4
z9eBw;$V%oSA2h%x)EsE(ibMRa5YJU=&2eT>^C@P~$FAU)Kmgt8{*b0xzv{|M86_)1
zHh!}!Fo5VQ8ZnEc)`*d^hZY;EINE_Yz0gj4Ru)pH_rZ-U)~~u2$YR}6QA>H6mYmpF
zJu$`PZKrW4>wxkYL;u<_OoX1vn%vx?J3^!hR_h}_popH|#3)wD6u2i$l1PwM_Iv!)
zpY>sk>W*hwYIp;01h?9k)}=b9Lxk$IakIBNULyYgj+^M1(u<vm5EBlXK5z*?-)Y1|
zyAU0X6=j*#T}?=fi%}oP%_vLw{uGvwv!+4Kv?okUI*tiU_@_UqnDC^)9kI&?j4uC6
z`yX~BXuD5S8`j9`tT}A$03Bg#3gn!ubA^~%J+Q5#27S+%#T5_YcY}KsG6Z2WAo&5u
z6s>3#7d<U_p>6+{-FJ;N{$0WCc&it!(j8B-;}RQ?zTce01|FC3H%N3MJS9m@`dLsf
z$${g&eBSEW&Z9_#d(xHQ3T*^}{kfu9=>D?x%3tt0fT{MPs;Q2^7p}@<Sh6yJ1X0>U
zsc?}pJ;fDdO5}#_Ja_~(fwLGM!@zOYIZ#<%;{cw(33CVbvZ)la<A&NX*r(T_M@7uk
z$TWMxtEjqhyIS5@EgVR>%ts4lT$tx@Drv+}6<<w5ck(H+tm^t?+#>UZOPNV4@;@~H
zg~$l16#Df7hf^#~KU^1yZSGC=g$~+R2T$DWl&DgqMl{zUd>~_|Y!UsMTy+EHxS=ny
zl7M%X8Zfi)95|lj3R2KcZgWZg$%gJs?IDRs!Kz}T7XAg5gMVF{y`GZ!9FsrpzMyf2
zBUzaDeIpPlrsn&=gi9A(g4xu8653Y!YY;`@o2D&v=(8N!QTR0W<CVPyiSJ$EiXSlq
zw}z<lD7x(^i>lbsTGZq*{))WF7<1?;LFa#6^S4G`1L$*cpu7RWV=MtE;5dD$+&GKT
z7xLv6`%AKUyLty?9%C<pW39F*{5EZ|^-(d~iwz?`j#B&1LUYd4AyI7oNN$sGFQpd@
zal4?tI339fzSDa!ZEm+f+xh;3NAgln`r$l++VJ(oA03%kS_5sD_|8Pk_Xt=t$In}M
z7h*M1hcW~kx6mZ(UA42WB6i#<iHfe0ZJ4WShV{VBpC!(PPr$eIC^mX;(Hf1UpV6<2
z)3wc!?bwZiV!CyT-vGr0#vG(XCo?wVbL8)3H5c_jS=WP1W)OK-wz|s;`yqtR0RPL6
z;~#{a^3IJ6#>}FO$#a#Evb*r7tmeWV<54=)pQS5N_g8_6l&=1#WU(D@zj^i2G(A5>
zD^1Z$k)##ZjKgBWjv%~2&RM1AE08!C)=~cg_wV6Q^8*N}Zvn^agwpiF85;J*^PTo>
zE4$V0DtDr^EPA-b<Fn7FTJ~bmI&4?!6>v!5GI3Z6{d9k7pzTuE@|VFv$k|G=H-8;t
z%2(lyUbL3#i3=roxq{m<r3Tt@jYFM041~i?9tOFBugOEYEBLZJobL)gD-Ra{kvt4`
z1u<$-d<gnW9)`Mt_sPSBuHbxmxX2Z}T^@$Hg1jL!&_3K1WcI5-`^B!{b$9?<{)P5Q
z)TP+6*sog$k@-e<uf?A)1MMUH2Xx#%T)GZc!T6kHSIF#5+e*I=30Rn9_3!(n$KfP!
zJ^BOMWm07WiI%?}2$Ilv`s?!71EE&5L0;jeSEQeDZwR#a$1wz;3$$PAn*diJPIa|+
zLH6kO6yJzIdmmgb(SD}yf<Sve-+6)dvwW$6_Or2@)t>4*BhY>>^31oN=L%f~>H{6n
z!y0V9Kt~r>=msof0w?jNf<xsb-dqZGh^xh`dIr%C7vZyBx&hvRoxU8sbUhZEuHe_?
z1w9(BhxXwSD=38D@c}Dp?1}Ni@~)_$)AHN3f(}Ya`fieodc`{W>0afde=UQO7%&oO
zcez4;;5!HlI0;V~GZaq5whcy3o%t8a1)1&&%BeLn-W4p9l3;f!OM;1|YiaM^nxfzB
zL=sv{H4i^YWu6JGt;}+nMO(z)ZlO_+K5Onh37>It9P5MOje(O12kKxkxk3T(B+!AW
zZV@`bwxF$fE_jgdwpklLFsI4m_dCo_F&SB;N_?gw^<Q{fo%0j@x65B61loxN-e<Ui
zm$Pr%db>iaRl(hv&i$oG1-RDwey{y~5x?iJ-Hiks9voA||BasgrK^pb>g0NEnB3$^
z3BhI3GV;_1yj@kBv3JE5a{`HwRjSnsjL)=s;aofh+Ivx)92BQ+6sPVKrydk1C&j5J
z#VN@Z`i@gp>AE91bbsF@qP&)Fa#wH+muP4j?pW=j_Zr^_uQdhDa6osp^>8g8hFKpY
z{<;gPP^CM0R#wIlyyu+#+WWJTG*<}GIUURti5riRDH5G~1CB#)*d2|eK!hf8lCdUl
zGNN18>6w^kR>i(wg6}v@oCh?R&y;!@%gU5`LGnUWc8M!=KHmWgsLn|qpABgm0jmTo
z#zAt(A@1vJjt$;1;1YB##0{tqw}YK(ek>o_H(p`u=kbaq9MYiL7Tp2OZEgZQ+v8qm
z%}M5ynB~;@tRjs44fgA$k&ccxuo-%SJbNe;Lkt@rdo!9cwymf;QitR8)4;}MUvj%y
zJ8)!6q7V99v`@Bke2&xgu%A>u$`Dhzed2sTAKeOeB={~Nqe|CSd6KJg)Ed;Xd+hbc
z!{enaLrjm<In+Veqgz2i0#f@(S>2NiMwQil<B;_a*Gz-3aCtaE3gYl?2d?^Yh1Q`6
zE-?8DqqtszH~&BC-aRnN;`;y3CIJEjH)>Q+DyXQS2*heNfF&d(0ckW46D|sBt4OKs
zM`btQ1zgN7<jJ~9Em&JGm11x921;#8y>Ri9fLe=)3IZAx^?BT=5vxM5=J$HfJev&{
z`~7{tpYQLFAFbJW=5l7{%$YN1&YU@;dEHRiht1oT57@hPmfJ*$;N3fg8^b@@Mlz!8
zB-ej%6uUry{*}qnNS58~Wyj{}^p(TbV019^Gd%@;DzB!x$GV$K){h0fCm5^8a?F|B
zW0~G>^%d~sapAEZp1eO7ei6L$G)nwk`0@G?GWw!}m4w0A8AkW8W~@`O1|6?hWVWIE
zH6;ysQTAm!Dd-(9f-v(7#bPk}FX9f-vj*>kKs!Qz@sgy8|HkyTJY*hTQv;i=a$kP6
zlfdV|P@uBKMhO0`J!^UxOgLL~Lx{J3ultCPW{#xX522%3>yz1a?+i$smo;_z?2HH8
zby(?@{=qF)Caw~at2vbmbDDPs1U5P|wiUh+y!#PaP#E48jNL;ZK4Uv<aJ_d_-CJW4
z*$HrxVNQA)O8S@$x3hsA!TOdQj(`*zvcalc0x!*4e~8j0uznI-PYVeyix%P_c;#OQ
zuUsmeBf@iX2MJKQv^Z~gJ3dOW-st;?Us&YP=_1?d3LI%6tJ3F}-}5o!_qlM!w&0yo
zLE>FhLwZTB8Tcb~xa{j1SoXCIJh;PU|JOU*N$TNlW<f=oM4wdY{%IH8#mw*5`aN%u
z`w+ikI1`b>Ej_|>uZQQ>zq~4|?wu@eHAF}_Q1?#2`;`rMuY0Gv_cI&Lta~TZOW1I*
z?wz2w$cA(3-pTR8Hr%7`ogUuz3G<SA!OqCY4Bo`UzSY~$4x_FkD;V3%mys}rf@dRP
zoB@3uf!nn}mX3L*0h;~^tj~^Izjr%nTBN$pQneZ2-@1Bk+mim?J%<kPy5OBZVKN6}
zzvC|h{Qr-!?Ih;c;MSIy%?$pn8^OgC8c<Plw<C1+?oEc8?+`oszt>snW8;lRb$pj8
zd<aDsf87i*TG;<Ig-bMr&BW6@J_1?SxUcV^*U<D<ey@y&pRI8>5fW90*;pBR+61O>
zn9XbGrK`Mk+S#V4r~(B7S9$QV<!*gj^zl)4-FpK9O;e{ETW;9m*~(#f=W3Gy-kIVM
zZ`?jPn79w5rsmibw}Pstaw8gl2!12lxEWvf6=eQ4fzC$gp<(}=FL>9-pD`V>__KTa
z?(Im1$u-Q^8aDt0b!`83AUtn+v{Jy7_AYTs+pRRZx>|FHNj_tHRZ^DHn(fJ_I@#*~
zl%aB0cbBXuX6!m>n9C1lT>ryi)(Cel*q^ZCb`Ez+Ed3dg2AB8lP2(~p3+-iif_F`4
zDzj~<e}&&P!SI5XQ1``~W~4ZN{{5qmp7q5CFSYxp&rbD|!Ppy6NwZOGGNh=-8ujDs
zm2s9);<bITKOSy$s-q~vGB}ft=Pn<?PoODo3I#S5wgsb?P_GoCFTzp3*y-*4q@!c@
zZ}GwF<uF3QCEuVGUPo#a2fSuS@dSRSF^wj>eF$kh-xBHiOnd*UHrFTmg=u^ID$i4f
zyrHamDoOV7<@M@S#SSv!j8zT2>z~(#>qC2l`5ux+=&fWAq{kw5i~Ka?>16O@dwl5X
z`0$<N$jE^{p-G*x$aeo^wSpG&t|VAz22orxsD-ksp)cY39SApEIQuauM97KG<Tr9a
z=d2|<XMI!^onk9GQ57BMy-E(rPbqj6s~Y;L#K)#Yt*dst6R%j4%x;(zkT4|>|FR%H
z6bLuDq{|ZF$tlk6?ZL#8;KF-|hJw8+uMsI|cd@of-Zs<tC&wd=v=3PS!O4Lw==X+f
ziB~^aw;^kNduAecT_Sf=A{+Ce4Kh%{Bw!1s42clJ)dZ)a(c4Q6P}W^?k+ggJ7jI|_
z_n2xe&heH3T$2|mECXX9ZL9J*^|{aekZ0N$E4$^2Jpv`|?v{7YB-DbNcKe#pe-$B6
zkzlFa-!m?^`>@Axj9U0rFs9cyfc*%c81J3W7aQ<o5A+QU7YB+p%3s(~Zqq0ykve?<
zH&FsCawOc-lW$}pQ<yyDq&^t?0eGW^Vp9WkT+VmOdeOEi<n8X(_t2(?zty$bUN5SE
zc+7^Qe#?-J-d=>tl>Egc?55F?W&0tZ3&DqtGSd1j;JouQbYe<p{I4Rj5(Hxp0M(n|
z<J{X!o4e|-jD0-EpQzG8r=yEHMH2~AcwTpk_nIUYoQv~7PBbG3f94g~Mp}dcd|Dr+
z5(}i$LJ>FvrQx*r0INnutI`LpiqN~YenZ`c%(%5@sM{aVzE=rmgH*Rp?m8-+?cBPc
z%E?Z<dyK6urDgQ@gM6CWjTHdn*{Pq!W8X&SIc?M%AdYxWViBIxFp2G5d)n+UXTE8r
z-$8pwqxwsZLX5l9Y@I<uFs65>j6OCP?I5UKL=Il*mvTD~;#3_nf-?Fz%;z|JwXgZ&
z**WxaU3-7@S95t_$vP-G=)GU75p9*4fjw}^ApE<HxA)yPpuh+{hDv7DthK{?Bp<a`
z)^MOu=bl2+yhd~aU*Yh<=wyGdm#U4rwWx02$tbV(4M2IdZy?I6eW#$j+IK42hJB}@
zZP+&mZNt9P(KhTmL#Ehgg7tlaQ3UK85{z92?_IRN75Ro+YbLDgAY2(`bg5zOFr@#6
za;)jh5RGC3yd+4Hm%|@z;|Fs5%k8WEOfS$<w~w0xN0GF4DCL->??5HqF8=U>!sP>b
z1Pl%BKf2`AgRDhs&myx?-mFn}`5wZxzd)Cwb$F;tc3t^edp5bp!@-qz5r6z<DDO>O
z@-9){At}hym0Lz>BGZzA@rgO8UaKJ3DQHcrCf69^UWqWM8)ys!{U{^1#(97MjR24*
z)kM6zRNNr%lwfQS-=CNDh1r~_6m$RM1b<x4M)w90*6kb0yY&jRf1`H7?Bau|&^#9H
zzY-nq4aLYLIB(H@a}(kFi}o80cxbKBfR}-KZW?uX3I3orf6~xuj#~JjsJ%4D{gkbV
z0fViZ(TZPpark|87)o=?pj?wk4ao=ON~btCxeV7&$-CE{LGKEwAofjFFqA)Q&m?LT
zQFjbfR6qVugyWUserwNBk|?2@lD=Y!S(@%=l;d~X7mfFw6^zLloTu@_DEmwr?ayE4
z>;FPuF8$F#`f}9e`Fd#{4L2R*j#x@Xj;furgI><|g01M;b;TAf{qgY$QxATJoJ`4`
z(xK~qg}raqse-RSXP*zuq47*}`VczPo;*ywNY_8Y1v0Uz%qe`ScBVOs;OHmQIo8}Q
zwF%FKN;xMmH|{;>*yOuQn@c%hKnx1!In|sQp`**l(CyLlgaWPKKESzsIGr%%R#Wbe
z9B=%ti+*3@CX1cW55TUo(P%=9_qU~5jJjH@U50@btCfo-=_MV7&(H09xCvCZ35Cz!
z<R-=jM$O0x9Y19I<jLIN+4B#>%TnC6uqpf=Vc+B`F)`3^tn(suC2sBr4KY&0yj<t2
zAv_)u9`1aV{D~xrj~k92ixzu{^CG#(8-C5!{hF0JwvZ?MMpCYbs@zvzG}Rf;06$Ii
zAK~mU8t_7Or@zgAoM7gStv|M;;b?mFZnD4db!2<2@G;IltS`Nbz$zzlo_vrsWeucc
z@^`6)B5fZh`x@hq53Y&lkB-pQEKxI>K|fRT+e2$lqKUH?4(6)mFu$2Sj8$85H2O_l
zor#iW9fX`oR{XP29W%-40l)sX#!8+#_gaja$RS;i$8>m(u8!(V;W@8&77lTy(}{Fb
z0S|Vk^8GReFZrj)!hV7Dv&K3>D9dqTIvSE6$>p;ZxFpX>T%$l)J{|xtWZ^zQLv?FI
z#fRATCuBJ<-C&?T_9ue%n+!{jCsdSmGj@YY8i)>$Enp~ZvIW+~4a}Y!u$rxZscvIt
z-CKeB>el*1E%`ZKc~Ir*HfCWg11{^A%ju?l9~^FBKolC#!RUR`RT%d=DTiFK`D7Mm
zw(#pTMV=B&ZrC+toKt4Ynl?JICy7si*$8&xG4+#@v1`ni`XD$*Tg=&R;119BZqn@X
zGa0?*s?FIkWXq8ClWN>Q^^_Nmfsv=w;EZ7OQfaIbrlN$p6pVczVAg_^YXn7+(IYa#
z`!T9tE<~a^UE-<ggaNwA33@q1vl^gw`~kyL8K0S7#fabxC)XP9RAL2V)O?k*|4nle
zGoGGva+Q0gZHDmTKK{I&Aw9e&VVXqE$>}tZ<1#p;#%UZWG9hS99oqv|Ml=Rdm9v|H
zJcrlAw&ZlnKs<PMpm(DR)aW&%`u=oLxp})fRbcY$H%(japL1H3dq0I#<iD6wwkP}O
zBI|3}5i1kP&mPFU@J473mgUeT+}o-JbnFs<=_d9YR$_8`c<;m2E!b@|L}2q156X6%
zP@XC|6i@%D-pi<W&bd|Y`#sd=5%%~?Q$qK<u?vbns6fHSAsZ_zt9Ek1$G0t$*_FF?
zPIktQr(Pt(tawa6I=qU#Kw!ro_4m!E)|s%9;xUDt*fRbmvWs}5cF0EO!Tb2aJY)Cr
z2!S1M?OtBbuRRD;1=FYi?r=yQ1zZ0YwM@pjS$2`^|FegzcQ$c{YzTjPRK7WM(5^qK
zhPr2Sc0Z^yJ+}QZ{c1-f`9F3$YZcom6S@8T@tnB%2URbA|NpQl8>t@i@3(R~n_}Cc
zYE3&<`R&keXFFuprFJN?tCfda_J7t6?ux`70M`1qGAGO4aFZHg!N2hq&4`-;XJ*uo
zG3txmF*72aM~BhDL|atE4WP=Zns`FPHz~ecV>)^EGR=SocN3m-O_h6ZH%m}*6H?cj
zzoRUN0i9hdGM`|ga_4kEY*yxR;?RX!XFsD!(0#Hy0brVjdEN*6?TkLW>^4#kn!}A0
zPOi6eHu@cQ8BEyO*Awa9)0|=u_giq(38TrWN<281d1P8SXK<CfHQP?)UrU8-pZ*RT
zG~~`cUvMr44sK~@=1!l6tIX@o*Ys(#FCdNg&}?E2Caqk9zO=K-!Bpw5LYR7?xzKwX
zW)->$)R|T23Ie<tpmk`f;u4BTuSQx{TH^_2Zz%n+VMc2`i^?wa<Z+WdaZ`XbCX|)9
zNgF|Ko~D)w!}$J)4$|h6ErZOXq&;b;4Qv)36wE4HALFXZC(pi&?yzP1Z;s6^E1U%g
z;qpe|psXo{%S(wa@xE&?Dubjnoy0^Zm2oroD`(H6nD?^f%(KrEjLc3LIC4N2&}=A7
zGKF`I*sfXM0^6I4Ix?Dyz8cX~^zUKbbJSxSs(xHf`_+$-9p?CQb%g#1aaFUgRE>p<
ztXe%;H7?~@4I_4VKSNul=t4!`+!=ib(OsIc8<LGDBqlg*lV)E+Ub_r(#Ps@*4U=o!
z-(-qZ^1Of1frHnEFJ7;lJo{y}0LL8KWf|FkA1$_KZPgk)Y4$~j1D$Mu4)lIu5iSaK
zUwzhZIh%n!DE6AVk7z0j46AF(^mwxeTs;XiD@_d9SmYS7BEDQJ@ubQ`|KqC?C3v^!
zXItBpHO#w%LRAd85XO)TVc<<8UuBx)1qeoWhA#ApWA=5l6LNSWkeZTHXayKN7=#fO
zy#LndS<nV)Njy7GrdgFWiR^Fkjw3L*yID17M2-6pj|vKbdqI39XfdaUL$(4M=@3I}
z90;SP27Sl_cDef+sh|u0=*kY@130$uSG)bDvOzU&-wmb$@7b=kKK@ddS{JBR=HAyW
zuCqS?AHERsO9M8)#$CVOg8d<2oi;fR<k;wnu3*owo%s(EL6Ej4e=WiNAbTenI~fhr
z=b_>3q0UYeqnXK^cUnBl+LcN9F_4(hSSO7ARF1u8?v0VgR)%K#%$CbI!Mm=mJu5U?
zE*XrTN>1tLZ?M$G74+oG){gFM<vN}L=6!@0En>Q(-ueeQR-0I9AT>zclQJE%GkQc9
zIPuQd6H~Ftrw`IMH6#4@N{jCexcOl>^ut3pXr%{j(00@wd4slNo;GNO2SR81`?GQQ
zf1-V<{TbW4HD`#olyRvk+@5@#4cjZpMckYE&0+f;7A|?&os&5y=sx&>^r-{otiqOO
z|4sUw{+$dKteks9Kd;S2eN|y|MnC;6%7aPqldqr68`oYq1kQ6e+^JxlRRpHT+gz3S
zMuaQ=4E4MfH|)Jyi&%X8Ws}^y{{3Z#iI^Ur+8<+wc#-~J>DCfI)qeY4Aob-35hSfo
zLsPQ3NEb3P;(fMI!R1qDw>&oi2Up8+*wx%kb?P68Gq+s2j8|W-`#IcyY??E_v+LFa
z(_0j9nk(nb$A_N#k1sLE=XDk+V{T4!$ql#B&1Sh@!;N=QbBU~Q<hFKbZ8^r2buJpU
zlWNb6myC$K5O7LHRLxd?C@_A$T31=)K84{aIh~TJb})UvgX}3ECMWG9k&nEy_^|dv
zf>i{pPWba4PHv%wx=o68NB90Wn<WPA#O4fXh#F6!MechqFlEaI`rd2F?aUpAxl#sC
z$d53Nz}HTtx`K7?Zg^Wkhj$YLXY1?KpT>_fBepfvCq;8cAHm4Y8SMTV^cHMhsZOmu
z2e^&T(qQAibESs2x#&EalHn8;xesWG1bcF5@<eLvovHoj<fqZzy!Hi(i#v|v;QDKb
zFAsnapAgQ~5qBJL?Rd?wOCl6$auiA5g0HIFIYZMmnD=f!!?@<lr)7(bmH#IN>puNG
zooUWQ7RqQY)}tHz^wpPBb$H=lsc@=XypQSSL4_K>eKyw%CSA4`=PDWQa++r}-p=}!
zEnunfJEXd|6C3ZN@0D#rosiU6rIc&aDS2(A$XvVea-~d6r$m&Z_BURo6g`jULtCm8
z*$y>+UnwV~QwAzUTBpVzDTR5JDsz=mWboV=Qi@)c^P%0K6d}6tcBO1irxYoLZD2;@
zVx{~!ol>b3MvpraN-_TbY)?lhMQ4DG%ax+{IQ)7ZR*J~7@gb#LolaRQ>>Q<(N0cJd
zGQZ3!l?f{4_e$aE=Tyo%rSSN7M&sj3k$qIEKcA3two=wAWxoVr+qO!Gb?s24Jgby9
z(<xUeMVzJaC8g*AGr!DLf~HGjjjt=^_a-He%2(zo<z%I_DCNhbtmV#71~d>MsnJ#J
zt%@CJW0xxSfMTyTP?T%s!-8_Up!6O}%0%Tq&E{`Y{yfE=uh=tf>=wo5D|UclhuGLW
zI?#BcVtb}xk5I3~AsPoL<zsd#YqgBf!c~HDu3~p6c94zD5R@^B-Kf~XHnv51Co1-j
ziapE54piQ0iv20E@jimMvPd<aN`}T+N?Bl1MEon)k-S#Zt+7@q-xDNFVcL=bHXD~H
zwnDMy)r9pcw<tED*b594eXnfc&st6S#(S0WjdV(e;B#`E(Rja7vP_C1S3WH2I$kL&
zmEs}Mu06rlJdpIpM-}_BMDsrSUO7ULwD>jtQ7L~*r>qjB6P5C~Qhs4l%=})bl#`UQ
zRw*&19H+>Yl|Zwk#A^a;wU{<;R2J<y;>QW%%A$j^VDOmH_?)tgF<I37m2LFfE^uZs
zs_dWQ(ra^}r%o}%`x4=8?T4_}WU`Asc~PsZ2A!rA5nws5ISF3WG&-|?5G_;T?*LWS
z!;|=p$80JWBTcB8JjCjR0}px%&YUW9>3MYr&I#Rw^|bHJozuMNavBepo#LKnZ<;tU
z-X%l6*I!nI?(wJ0w*U;QEoJ?~M?xy`SV;*c{UCqOvV-Twq%Xfvce5#=HUVVb(;b5z
z%sB@XSoy|18=QGVs4kri_gU1vJpLEcug^pAM#HmL|F>OILgP$}&&3Q9@BJ)ZY{V$<
zoakMtR`28l(<m-GUFk=FX8dNAM$$g3;}4oX?hM8vFpIhujZwR8`ZL-u8vkc_(Q@`9
zHx@Va7(F5weH)@2U4Zd8#5Ov_w|-}Zdq-{$Tpf(=haD}o*m+umF7)qUU*o;cpCjqT
zBkjQa1u!G+06i06k#?Xy0L?|(XNA{9ZVp@>{!`@U%<IFyjoh3yH~h=U&Dqz6A4rVt
zR<INKb-nB@gUr4Z1q7qA|85lf#W{qfn0%pTYEJwqgQFhC*&1&X2d22IKerD@HJKBk
zU^IitsGAPcar7IE?gg&SMEd{{@3d<W?d^I#o>?<#Ql(CKCJmhI{=SW2=s(D5PW!R$
z;HvcPBe<yW9#ijWEqh)wD;~z0)OxFz@|zjk0%$vSy5{gpvaCABeSTxAA{_&okskj<
z=SZ80;Pmrk*emkmw57e0%^#gKF00&D7$YPB?(d#N9y1W$1VXmY|8DjBtid^#=rrmE
z@zp3!<&IYq+8t}JzK!UHUNS-Ga#ubW+X9k{liXr81QLvWLBWO-BJGzz2Vf3E!1i;3
z(OyiiNc#k?QGi=v^*uPK3`kx9DlTn;(HBgBtQ!g7kEUQJ9))_3<z&Qqzxga}u@h-$
z=AH_<^fvblnZ;@vRwdU4qdD-$$N>z2J4kn)!yG_Y6_2BlC@f;vkui<vLRQ{U=W7WM
zM*j<%ZPY^UR<TL71N=7Wl?gU#vtNa&O>vLjYm}1XgV8($70oTT>~SMCdPf2HaLNwG
z{>9LZO}^(W*pryyCMsGJcs42BQ|11s5gRsBOTF9`<J2T_VMZ|4tZ*4V$heE5ImR(K
z#{<j<&c5j~^P!F-%IIeV(%ra;Wz&6-J+OJ;I{H1WqDbz=#`g`Epz(xLoYz#`H=}-f
zKg&v-<IQW-8nXi$|J7#9oE<ze(+$IsvauHBSm8V~x?Ams@<P<D_PzLmd^m0FH)Pg)
zJBhY_(WLp!+*7*^^AQ2R#R}FaF~;qoR<Yj<M(?Fnm6bJB?x4r)o_D=sf6Wx)!H|3o
zD6)HvzN)r+ojb5TyH_!97JlTkIhW?FcLxO8UfPG0Z0Xav(5nMF{P%GG48hn)sJ|rn
zo>@PRXaM7tkfWhTl&U`zec-O>PTHycj5&&MYo8Fan2$}snBd)2&_lfRPVArVENRHX
z5!Oz=;^8|{)XNnL{!B8Z_%5w4`26$IJF(Bo5$gR#h}Y9$=#7%u+>CXgp>&mce3w@D
z>N_Ex#JJ-FaN&CH1K4>Q{VQA|Ua`t4jXGm<8U~;S8t8n5@!)p%&A*st^^7lw)(<Fm
z7DO9n;#Fj4`0aRUv`NfrRlK5J{&3Ao!SK%10$iF8#~#tpBQZrz6V4os0s1VeAKeSP
zE&cWkMr-stFc@8!%dE{TrjI+)9q6YHNYZh~Jd>IeFA`^X(UVvV`>T%WvD4S{q!ELr
z7VL4_MOHGZZpa+XoNfY>1s$WA=9SFEgQvpx=$o@~Domk%lUi+O>@O*cLnm1g$5ty^
zvw{m=zk+{YCK8P1!lAGn2}ajw)xxkLI+77h6X6v!#$EC>u+5&Tg3r|f9fQ~JIDB?E
z`|6AP)?eJuGEnDe?_{!LUblxPSf01nnq4JjcJ-clNAy1=>y61o>GNFw)F=j{Z9s#M
z?)PWVx0p1M1EA#zkkK5QO>TNi6!<w6o~a^FQKZ@U6S7Gog0V`50`C^`$^`+(&gYXW
zAmq9p0QwgX=WC%_#-2>f?iN6xMkGND_dCc}=320O(^Is@==d%qPQp`xaQT!06O5L?
zTt=A>*fyI4cvGUXBQn2ZMCb&s8eU}g-wnkb7b6P9ZiL}p3Z`t4u#3W#8ttUt0oPaY
zOL7x6If<Ehkg7$C;em7Dop>kUw37mIP{0*;Tog<X#`;rBQ(3=&9Zlz4?{1Wy4bw0W
zd`_l=pIOtvk7PRNd5^(j?V9F&)MZVZNs%-uSMt>eePp<yCuyDWV4X$p4Jm)}r^85j
zAo=B*c#6BME6|<-YGu&Pp|cw$i@T?F0(^{A1MuNAKwl!0*9|!1X7rHA3w1YVbG`0K
zKI(2BjPUswAw-L5t*NHXfTmf}D`o2wFCU0|Wq0&STuL7zUIe4RWtR=?=3*TfWq98Q
zkS|YKl)U<37nDp??LK>=^&px3+}~4m{!7h~1pM|NJJI1w8RqVAFxp$?OLOYxtMy+=
z4%+AbN@n*4op(V*^bLUs(P{EPG<oiY_nS6%3Pkj#xqPsc3Enf(kRBqpXiMRq$3krR
zVg2(EvM-X|MfT3B7x7W>d2`WVBT>ot+pxM|Y!b_|xO=EryzUm7D_(aKzfSw;p5fEI
z>j?VzQI4s8j!J%u#SY5}G!(-v!!0R91*6AMfpO#KUbr^Z*=FJlvi|aiPGni$d$K3{
zZ+IY*GE@9@6c^2<OX+fk*xz)zl$g<GBmvjVf@^T*;!6UXO;4;OAe&#q^G;_yMfHGH
z9L<AYU<$_^W$w!oE_xa4BF*z=Q?vV%zfry6dDHkbtAD2?fK-szP`VUB0DjlW><Y-Y
zROUoG!}(Z4L6CPtR<eu2%$bG3cm;+T2wdkP|0Q~8<M%f-$mTqkrr6SB)Tq?v$lo~`
zyA=0}MjwH(p<vouB#4%2J&3Z#AaoF{m+_ZnU93^*ogA!z8dn|dKHdrAD<Zs$$RoAA
zovpR+cA@vn)kIk%1*7Yr4A6}Q(G>TWi<KvrLwE5^J%S;dMu@g}V5R%+Wd?wj>Jzp6
zbK^GUc8<-{!OmvWBytzvjej2ZxK!(+=c)K|)uEaHDI*q7=*!{xF9Q;I$7u?fk4pCk
zk6OV9<+9zP4Df!A6>Uw8xX?p;y7X%@>MMUrmJ_63Y(u8F&&9rAD$*feocI+eooqXY
zwb}TAliZwi=jupI59Tcv`}DTbedl+!9i<Ug%ac-l3}s__bm)F^&*3Q1&G}$ddmW2W
zeXZh43)AyhOi!93X7<b-#v#5L<nJCtR=*+7s{ZbaPk<<U9rQeqpatwF@E7ghXqPTX
zFZcr?$%Td@xy|YH^5#%DGA1J!?Wy`D{&49iMOeN4el=O6w7<iKob}0Zk@nG{vPk>4
zLzqjS8X6sGzcqA0q<ul?+(`Rvp>rbbSA+&f+GmDNi?m-AIyusQW~iUP{$XIP4a{8N
zB#Pf0J)`z7O@S+uu4P!Uxx%lR15b<JsU@#szU=MckC9J(L5WRuFxDG^pdo-8)}u!c
zpV!B1)kfnq_kQwXTlr##`^;a24tef~E+$e^iIJ;Dqx`fUIv3wYh2lCV_`W>nLK)4a
z4~X%Y9oY4J%Sq}TL^%7KOYc)kJiN?a%^oX5nCwU*RJ<i#y3Dx&G~b70dtYkz^=jRM
z`?3~J;BPi>yNwwU`gXkZ0mgx|v1MPp;oO7?^)f&Zb2_Kta?%xyj)irM#-(hbe&Kxu
z`h_J9;a7A&W0~n`l^ggq%#_2(-(&5~4S+pyAQ)$6d#!<8QU-SKd9Sn3`_iFY&orFS
zT>7v&VY;^vEJxZagRx^Fm&BC;G!f82cRq|`DIxKeHA3PeLgH9z!liJ*=LH=a!@gpt
zUv;y-izDrq1*3mg8@bFAT|@;2qw{Xr@lnCLlKL&%`^XJ1Sg&k2c4zh=5_S1-ef>)~
z-+e<Hq?IsFvqgOkzKy%RF$VO>)N$cmeJRT60jwcWgJ1S6ES=lC<JoPo5}a2r9M6sE
zGe|9?@=*7py05y2lUx<jLivcnR;By$BNkf=Ff%XLPWvFIZ^77mps76h-Vygd+P8g=
zzI!hV0n@orfH?Jq6{p%HP9?opm_xeEItmQ1*$+m~H33#jjhpjwNkeb?lq)@e?_BR9
zhub4lrc_RL$3KF#?t<Ss<whB0w*?n^+YoDxTvrW?00MRR_sJ)h%557P1v;hu$kY55
zdu6Z&vnYJL+Vt5f<-Az{B)Z0(Kam!lH^|x8DPf3F+#&mWZO(hLyM(S%EG!ruPr*iM
z-rXNP1}#WziG2$x+1p0~h7hF@(lWdY*v6Sz>-8hvcW#fqq{Cn6QXFMk*H)z#ykK+#
zIjuU-`zt|dH)2OKYtavQJ^5|OD)?M|{WHXAcbyr(g~hF#kA3!-;9VQlyM0Amg(@+r
zfhM!}e1%;j+fRF^C6Swnq1C?37)~vVoY)mwR!ZxG(J&y*4a;wcG02BQSkT_e8uC)z
ze!i|#Ki9cSf1@hK)Z(eIp`>G?8?oQ>+Ui>V8H^RH(+R<3GS+)%1C#x+8HW?LQIJD2
ze{l~+CxAWP*ed1+T4X{pF*CfmU(#)Kc9>>EXXx!N3C4z)P*w)_;}99sW3mSG^^_9k
z7$%HW!o0W&xJE^ACBnptsjaA@kGq1u&Lp0GVF5Ktyd1BV(v}}nAGNGt?5VE|*AXV9
z`ffU?zHwdZ`<$6->zmnG-^a{TQPH!ct<W`?_;LODYwJxeE`CNmWWVEmOL!>{Al#W4
zT>YGe{4Zt{I~f8p=#cTQ*oSuq`|PKUh~9*LdF<l>XrUE6n>n4LyF0-mXvTCE+{3Zb
z@5p(7q*SvJ6adJcQG$d*-h3!bJ5f&yC(U8c>D|w?!orL!;&s(hXiLmcL|X0ZT||83
zmH^FN%l<lXaVDHMa!V%P+eF|8x?Al4j6HF2R$Y_)&nEC6+~(e~!T^q4NS}~48Zr>L
z^F~h(<&Hi(lmmm04Isg0U9!?<?PIeV9ali%ie=4MqX^TX-Yg-bPQ*cqcKJr~(U$aH
z&~F7)8sHQZeC{P&(~l|cJueaHN`&9AM9AZZtc()l)a~0XGP#gr!K~1khWn}{XrmRq
z>jMaZ4N2YY+RY3DIHDrEim`*4IvL&oBFq{R`zCne!qf_Wuyi04Csf>UqTRR~dY=gH
zg{SI0!c&{u^04jp^=i?PFjPf?#n83Cv{}d6tOi4GDl80{{f#u|%s;EOx{+;xb}kRm
zJne1n<=5<Oj`!kzR2{!&Gjj_8vzb9PVv2=ZyjjH6Z?uX9HJw+J``h_LJIjmf`?Bco
zk!SDdH7uwNCniedQ~sT_jv>OSN$e+Zv0~?|hF;cZeja7ZitBSs*{@EheLtSK0b1+%
zNih03H@O>5bc{N|`NEqn_Gk4`sB+-$>dRL0s4vgymrd9P{SFKrW%W_Jy#?f(#rmLi
z;n$=UC)b01?^PHI17a?EdS4K4hbv0R#(hjEF)83Izl_G<|I`XfOLP+_9#b5gQ$O}r
zCm$hw7_V&&<9gZbwXehz%H#c5v*q@{O}J$?Rb__p?_xq(*P{P4p=_8<H$uiUsw9CQ
z!Gm}s5BWd#AzlaK;Z}*kZ!1{QCcX4)1ikU(!d}0+ZBhHrKzeZT+3Z^uwf|h<*k6>n
zx^+?e@cPWm;Nm=!G(zFn&kdZVf^#xU^P&ZA$3IK5knjZbeYn$D>BP@LUORAhIExQE
zn4f#^LInPrfYP#x?5qj5F{`_-3D?_itqB{MAF6Bl6<~s^a87l-cN|O=mJ2?PB?*=b
zK6;vv@X^6d{lwU8I}Vo<J!`31KVJJsm#OP*7M)kSi`u`*kOUW>1&SB7pQmu_X#kjR
zUzOJ_JGeM#lCD-bwvwbp3)(uK{&7Zd$-R7dpU|JB#+lI)Q_LWIueiQN`1=YPghyv7
z|7-fLZqu;Tm;$Z5#}-_?hFQ!_I6QMJa=}uK;ICl@LTtmf%;1tCDtwptEc;DpKFyHD
za6SU#bkgUrmfc!b6K&gLk`80R+ldz=xgNagpEpuV?}LVOvjlzDFJ`ulT^56jiH}#f
z8u)t^tfu`#f{Q<Z^y=EV!L*1-Vd%KuA<~BU@cv1Xuj+0tt!Lh6c;i8-kDo~fo*~FG
zf^`d)B87eidyZEx6_T_M5fW}^WR?sPJV)~w)!p*hv^wQm)SIBz`}(C|><N~;PX4;(
zZIViJ(AkLVd+YfWmw)XYfK4<CyeYn_%l+OfcK_MzJ*jprFl@Cs2VGO)gO*o{tU$lv
zm5*!pxL{dx4|d=g-XFDwRJW?pw*i`W9W;nH5)?jIF@sC4QI*d?l6AT*G2>r+-OnFG
zKe4Akig~j!zMxelFA$J$n`Z4$f)+FPF)`y6X5KA=2h}ZbZx1f%Bd|9~#<@N7dbDG7
zFmij=Tuy*YD4R*~feCekx?2dbkX#~=(zvaAjzDTf^VSQfqWAy0YxJW;`vdkc<$VHJ
zPEdWL_rWFge0c9brP{hI=?VHuj2zo=taqXC)Mbgf=w}v}bB&H<52nwIWTcSo*}1Gb
z#>?_SYx+d;*%j;Y`)$cWmGnp99EGcwHD{W&^GxP7_Oc#TntuEkCnD-zNsgBZ;g~{*
z3Hu~KjSmQF#U6(D(fcgm7UIcsxLnb!0_5K34)@z|ui58YO8A{AwyZfrrb6CI3E}8<
zrm(8V#~Kalql=Bw!K>BuH%X{PicHd*3Hv}_v-caMg4w+hKGN52jsHESwLCY`4ew0O
z`Z#^^_t`V)x_zl7^*#%GM6)~WUH=^G<4*sXmeD=m*igG`_jV&cdhgQMMx@;gch9d_
z!HoiSZcFO8@nv(|_{&%P<HndLf=`|J*1buAecl5wJ#K{ctosW7xC3w^(w_ox$AYKv
z$@}yg-0D3t%PD<w#}A*}IiqpM51)>gHrlHo=4dd#gu|g6DB}PV<4A{T?<k(5%a=US
z*xJ`=6IgREd)1C==a$PmhIX(0#7{ooCUe`ri>TQ~lg+kd9v#`0`&o;eDwIA_wyQ|~
zoz2aiCgfyuVxq%>nR)26I5OaTm4Ozcc`(IjwsS%-4ey*Sf%=+$XDt`!lzU!cy%%9}
zu&D?*2rgMbmEPM7<_g`yj~|!cDZ_iuK$jNxvmZ(AGWJ7AlKPLPf%f+Mj;T4`a!r~U
z4<n==4KjBZ=j~|uVtURO({p!E&$Htp-Qqt*gl2T&;YW<9`u1)^!C!OkansKwv(fwp
zbMjGtN#85IV`w{<@vnsyGG(gVkCqXD)}DAH)z&9hrrKITeY?A9OQbe_qKV0RWO!4o
zO$+4$HzTg~>ShXi@|>#lG+9&}Mi%i&Ie`t%q#W;ENL$6hVQ|Sv75@drttSIj7Ns)U
z2P3I*C(=agbW}HZ$NJN_&HdhTJB?pq9LzMXFa7K2k-_MH>wCen_@z0Yug?nSH(tZH
zW4yCAJDcRnm^f{v4vzZ~>L~n+@t}qLi=}RW)xAAnRDSF>oYV&IUB~w0`pAO6W`vIC
z@AMGQ_5AhhP%r+%W0oOXS+@1%y|!7>4y4#ttqH?2kU28E8#LMrmNlSLoN|QPp0u?k
zmvWy2s)J{FudtOd9PZD{P<&MUK}>FJjyKIP7`PG*I93hl!sJT98qz}SfYwS}?Otru
z(;xC>9G3^{W0wLv<yra_;)ShaoadevzU0ex(-&WXtK*3gwmM^2U-%Tr;#{t5;fT6n
zxj^BIZB+JhgQ_KqRcT5+_Y<;9Jr~z6>bW}o!vAmOH&S?6FgBIksbSsc=K2kncEB>>
zM;T}wGfB-FI=NG4*Y%EX4)QtsiR9bjO+8h)zh3-X7&5e=3G^{vV4cC`CRq_JHeR)N
z5c_qM()VymVXQ@9rvJ`f_1|hX59+_F4KGVwX&lW<RC5)Ty2LknRB*|6iSS(*r=Rrt
z-a$`#;XTuovYzD+f7WXNsn(aU*I$cL#WH8FZ48bjeHY=3i6N*Zd*M;W&n?scJ;D~Z
zml$k^$EFbW0x7iIx<~e!V9h|)wN4H35uiRGs7J$17#D9Czm`3`glwSsy+!+k>93RL
z8A%Iz($>9oDIr)+>kbnG!z=iFvU{x`8zh#-Br2YVQ;YU5gZAytvGaWcF04Tfa{~C3
z#pzmg?wkNOF#<Y)aEEO-em9<Ah|=#ND1UW6S;-$Dm&uRsj_O?ZtJjX0AGNeVS8!f~
z=Y&b_U+KNB2*BSu?ZL5qex3=^=O9Zqx;WYGiJ_~eXlW}H+X7eb-i#;*(adN~W^*gs
zUj;w2TIY|Xb@qIZ!?TuhMS^pIfuZYd>a|L}id{qr+LtzSC%mtcx7*~Gl>7n!b;aFC
zkf9qf&qrhpEkuYb{4{j2L=f{->s}3ydB-&?d8@r9QTS<iAkP+V|C&ab71QK=f}Ed=
zBbT<OHXh+NjbcDkziYf1T558d<U)5o$pV0IOb8%*lYg_>L0gxVdo3mGD1%?!k1&Rq
zI(%9e!tVn(JkDNdFauIG$^BKfk)+Hm26yTf{1xpusC>MSEI9>WbEv;;DSH>JGvhZM
zF9%peK8r=9`F2lI;oU1*$ew)L8005+u8_5Ja@z`-Lnr^SLN>d}rWG<4PCm0jX1&SA
z6|yHzu3nL$pGQ};VWFB_xuQis53JatpXDpo>F2H$tMs#E#l!lEtXRsA@uR#VqR{o=
zWyK8&eOIBY6cXQGQK`@+3Q42njZ>&daU&Jd8Me7uykdmn&QRPyh59R$r_eD9Whj)R
zkPKvv9{^*w=gDGhg^Y#04-}H^u-BrH%*MS}6<Vc`Zv3v0?V6_tm{&ZkxJDDF(4Q2F
zDD;RzHz@RTg|1R)sX~<sEmo*Vq1zN1q0mhV4OB>X=2qk>q(`z=WGHl*LT#$|VnPSK
zmulV@&&G#ZUP?1GGWf(zfyDGcqD*R}TxUSRI{Prxtfi6tBSI%N6lW%;XV#Z~YIHO6
z-i+)o2%Q<(e{LvusW~uCy&^Sw_`;7zpSO_5zDJ)QemAn<)8Px>Oia&8{t3lc`u>hz
z|3Bk7ya~vQlvobx`MlodRXzNWi1(P7xhAHTsjOx(mCp%X#feSm@<{uYp_)kh!qB8h
zI|uKlYbk6$CB&OYgF@eqw4V{e@5A8Gd6D)Zq2ZDCvqER-HNMj$?L$KYBkiL?C-ER3
zQV55H9AAy(kfgncZH}s~%@|qzX)xMK*g#%SK<5FXGP{vjd^JIHlqD)N=SSl0v<Rmz
zCa^FVy~qS;*{cQ+Mo(v(7_0<OH394f`<Vddf_Ww|BpB^s0%rxI@-|_NEk82>oV>J}
zz^GvK9TT_+g9Q`7#^5CrKyce+0!6{7USVNZ?7yy?Ji|T%^gCj)&9Ta*zKIgq3Lc#(
zk>y}7=cs~p(~K2#!!%xg0NcUEpOW9?3NCg{ketEAy2$J;?+WTD3kuI-WSF-k4dB8w
zfOFCSP89&LQs2JA=T~-X^$F;Ta|nCr0e(rYT>*}elGj{<QjJ}~;f4A(%l_hsNducp
zWL9&eQrXQV1HUGT3tPzaM=aI9xkQ?cBLN)TT!O945t5oq1}on1;I96%%>6b!1AvZI
z=~+kU8@BR?AqgYm!{T`G`LMWwM~KTlLYx+lLo6vuWaxfq+~C9FxM4}JSVP!~Z|-=@
z-j!Q(hI(uL<G=!Z%ZN4VVRa5_<Kf(PtTmQ%!;R%!RJ-JcOy{-H!@``%F~=o8u!}gY
zzK7noq`=-}rn4bY9N>Ipc<8gH9>bjt<<dulUufzfs66?rY(4ZyrU4o%YdAS_V0fsz
zvlp|>)11Ba+W~k+;^Kf5=FymHL>W6QG~0PG`Ks!ZCExJS>%auQcGi&#hx5>seMimN
z6qz3w7Cs>|Ka(~#RAwc{XX(Yy_Yo&J`5RT56MCf~4><^_q<8(%W9<`GKnieI&dj%^
zC})R-@8J<IYAK<XB~9H~`XUPh=<l`WC(5#L#vPkQki%K$MdOl&;{vjOU*?5chrFYd
z(c+g!1;-toU7uYr7GONuG%B1^o1ZA-a(&0}aPPv>oVne{s|%meIFzB3t{sVUl=-9{
zl`MqclMlW{{3V6qoSWLb=Lw=r78*FW<HKTPzvTjbohDBn;T!sz6>Qd0|9w<3?Bm77
zyVVBa;xphK_gYVE8_kN*dEbKhkAFBQ=v&A&m9wwnd|mf~^*_We{+Go))01t4{<^nb
zp&O@_TnaT(>g?OQl<>11T4cN_QbZB|eNY|<d=-aG85wyQw+~G8$6bgnfTOy-GiBu)
z>hGNFUkh%0fEwJ(gyL)WY1n3LZ2WIUjU|fvzT18AI_(b#fw{|NLHc$aPlutaO1(bj
zKT_8ClAs&_dj(s0KG2^Z{_BwanICxj5)*JK2|vH<IernW@xCKH_8#+v;xzOvr>QJ?
zx?jG5mx4bXeR^nk32%k+iteTLWn8vKbS@)jE-wh&zT0F;zR3mwtFzQK9}pmiJ|%(r
z()WW;uXE3%S+xAA;L|0U?wR&uRYU3f{^`tbs2#}2vphj6y7pH`bkAn-Mx!m8mf+K6
zdaODzF7tQfPD~5beVpaAc{hMLhP%prZ=KPd88cL8AhA5_NwKaCBOm9b$hy7-w(WjQ
zf^(xM1g=FH;urI@%%<x^-PDn6Fpa*NwP~mcO(D`qgODXux#YToifmS@#@gf^s|<Zp
zUl(}22p;i$@4D9h&8022<q&f)`rAwnFwLVbmBh}0w7M9Oe}#3SQ`!PEDd>pzML3^U
z@OflZMrcf8L0gi&R!c+n$@SUimPJONoDn*!Fx+-~lH<|R7IzF?74!(u1>m5Z;aABS
zyh|?M;}tEu%h{BD)JSvC3UkMg8)XtV1b8lVL0dzOv8RdCv_wgko;FS7lZ<S{qf$ng
zf(Ps+uzF0SeN3ooH4l1^41H&H5t34<boCh$vA(_fB8gEKtUg=9)ri%DBzz57&HIi+
zL#M7rM7un6(&`zJ_8Fmk_yA@%X$fztH1nk`^|@IkWwt4?Fqj1&=y}!F>0<VN!;V&e
zs#}_}k3FqKO5z&_`emZ$k!vY0kdInG`yWveNsYn9jtTNYb8zuO6EyP7T!Kb!n_~iq
zYgd~9Y=5c=Af;Vu0tj$rCV(h*kqIDXsWOC0Bsmj6TszeSz*s*M0Asqs4!)4&OaPfo
zUaKTsMn5wF#6BxpBEY?4Vo>P3ZUTsgFPQ++-X;^c97)auW?+F%0N*F2EuhPJsVO__
z^!59*^%C9wUcm>~p@!PeyG@C4ITtYU_2YU66j?@WVqD$@d}lfbd_4bynLKI+_>w<f
z;5B9U)lZ5GaK6d7yrhxwt|sfOrIzrT&?3MMdaL@<mXx0o^7?yFpZM9lb^+$w&$X1*
z=L7CmMp)Z`>Nc{tVGD4r53rcJ%<v=EpyKMzSe9G5yn?V9{u72bjXNPQ91^H&&g7Br
z*t*12&cEc}x1q|A^EX7{^Rh-U3lhI%1blL6FhN5O7@HAm$RT8g2tC>lOaOBDt_eU6
z(@X$zs5Ak{q1*%@hi{tz<Z!+TKn_Dq0CG6Z1R#eKO@P5a+5{N$91~#7b^K!l`_D~)
zG5^p67;~|6JHl0FgnRtQ5e}LWF6kWMU?!*b+AS>gyZ7Li{w`&i3DCW`3D7-kI@w*&
zy_-#d?%iMlbniM7pnEe-fbLbB0NvBO68{ql#EF}i2Mh+kq&~k#xmQkWePWos&$6}O
z!QL24QCLwr^<qCYPO6f0DcLVL+)ui}PuiAF%J-A1{iHm8Elu5aykGhg&YnbWx>hG{
zs@c$^s9Y>_dan5Khy>4K1({L}Sta$^h2@ItU$~&{b{^vv5wG$Ad_unfkbFfXd;^y|
z78WJSd%;#atHPAoRHch!s!CPlSIzEV{o<C(kbS6SS_1p<Q}K7R9tN5Xr|XM8Ho6?*
ziT89ql?HYY;RZIYNMa``SjKAoW}SOAy!EICg~r14mSl+BZp|DSjET(fNS{@387?f&
z4H>nXdc2GH#FQ+jdiyBe>rNc7O9pa5c2E+)xL}~6B$E*%lo?;Jy`d({`@M=F53`*P
zMtAeU_Bj~cW&+U3^CkeDY%l?s;onSv`LN0a;DM4ESUIqYF#+boaua|D-f05NhdL7&
z8d~_jI~NX`3OqND#68n8g9W1uBdEnG3{0R_mY@iy-;g!|Rp6B&9%vpGI!gM3o~RUX
zw`!K677=Ok37=G&Fx3*`dO%>7Lh+!h<w|>>E3jiVJhivhH7!*qj4|UkSem=&>HDEP
z7WTfDAF^h5FRLGSY==qAA+dzQx4mx}?F_%7hv1JQsVx9<4#dZ@?+QkDLenX}m~Yom
zs)lICh@fujpIR6nS3ZAT)C%M?!uL$jFv6WCXc*xZgK-#PvkAZ{o;CqE#a~PSPVom5
zfK#kA0Vv?-CIAKe*aV<}dJ}*GBmzpya*K9CVaX3SNP75zWQSRj9Ilq!aD}9XDUul`
zOJb;yyf9wULdpMx%Qy$TeOgK?wCMCM@sepalJze;gyX=tzv}Esr@qUfl2CjGso>pn
z_|+IrFy}r-jPMtvDVmRlRj?rSU_q)j3)1wQ5`P&Q%N$QFLl)1!kSMYdv=|BuE^ahI
zgZ)1mWP$xhOaScPZvtTd9uoljjtPMMhzXn(x>c&HTB*2hl#1(mVevX)@w>u1GS|q^
zRAIYH*uF&Ao*-<G``?{YhpaFCnHWn!E&MxJZugvaG5;;cjY1wbrBnP{x-5V0=st*2
zpC?tQeI5MR4O9jxzU1J|Bh@c3%`fnCzrbA@Q6?L{c@dkK7<LXU0QH({RxUs&@S2ro
zn{=EHqsE8vk_N>lwR6^^_KdPg$-nvWZ~O75`9(ee8vcB{?8lJQ2eJl)<)pRB{qB5w
zOwok!l=2}Ue*@`HlWpP+KHFWmr*2(7QBG-FdN-qn<U>)MsNIT<Y6~Nr(Qsvlt`=&F
zu{h94IsMOC7>*n$3SE^zao4YQS^{lbzuL)Gn>SJBV`Y&8S8_Q5-Noq0fm1jHIk1q+
z5eLrVa>Ri%xg2p|Fqb0^3<;fFS*g3KtT^~Zy6eCE#)YO)tN1&lU0&aR1U7;#-dsC~
zSW4<73r=@Dnb`0v-r)ZD46lR1Y0P1PanB_W-NUt>)IRpe`7JYajM9kH>$k6Sv$-pN
zF(vEPji?`YZa|?8nf1KE8zkWrV$0d~a8T1?X0ZWV@VUF=V^kbJ1ybF*3pz8rCdh(>
ze4B!lTw}(|JTED4&S5MQu7D5_OQl~7oi=F_KH7Rc&I7J9jOn{kP}yyM$6Nk3-ueRT
zs*f}J>i*8l@nf7O4v~!hA~JG#2rpv)GD@6c*gFXYn|XhHpL-%l@l+-^^|#<Am*61^
zvn-CI3b%y5`+3=*%uvyg4U;C}3UQ5Hop}tJROi@&b)CTf26<q~+~({n*y=tdbCPx8
z7@5?Bx062`vSA92^ef$sU`g^f8O!?e)JSz(vaz|$XgQOAmf)S%PY6N%(f?=S)1J3O
zXCRTcp%V(9Tto*-+iZo~-ASgd(A%k&pg_1FK1Hud$~nd4PRkMz>G6ddLSsKKr$YmW
z@X8gJ4BnY*r$;&OQM5U@PD_CqvZV^$&Sdu(8tnL~G#pLJ?&fma-YrLN@3~Nh^QlaF
zGzV(UdTJN-Id)P1o)-1Xw4Pt8mHlEJ5tJH5zOL?QiRbpvAl)81LwAM->(0;+-5EMd
zcZSXm^%E1#7ZVMNYxWYK?FKsypTH5Jsde7nfD3;jX*R?xFnhb+>^pcs)%gT1Bb&BW
zRAsd!i!UVwi^kLm$Ia@N5kmgUws*GL3zr@yE`6oA^uiD~oj5qK3+*Yo@-#?|J|o1&
zdN7ABwD(lC7y0FE$uC1Czl@Una*^bhGlQ`x<id@Bwsghw8r0|{=Kw@|KcL;bgl24l
zYmZ5cm5z=_AdNEQe3O=G(t?YR=gXuA7xy+nlSgNbrvLn=4itim7gMWvQ@7gN#hbd-
z&PQbx{e^f~xzu}y%z^UU=JFg8kDxHGXe)ftI*buL@l+i69P&wJC2p1PzR{;CyqC8{
z3fW^7kO<3ia?<pbK7lZeR-1y0Gt_>yE4W1OrTVCldq*H8^*S6%kpS`s4@QJeLU=qo
zF*DPd(I!9QiOc;2G^%;Z>762IR$qsvS1M%Ja0PEZ2~3mG@$$o!@n&|MRmmF^L)!4%
zw$ZK&PI+ErR8goGorsU{{-RyV+<^B-eoaPZN{#C#Ee|WtOTNr(<(=MdVKXSZFf(z7
zh2}wi-cKkq<P+u=h<d`7pl@8g^S08>=5ljP;x!Q-+mJG{)`=DE9o$@=ufg!Ikp-9N
zu!#7)czJ&CX<lH7B*qnQamw>K3$v8_wmFi-V#e7HLfl_tBFR!_O|!*J&|b?FjHbr@
zq-lKG<_2RGHt7bN6x~Y8jVDs(M{2#z#Xg|A4d;wn^nasKJ`o><*w@>67+m}g?M=<6
z;9^-ZnU)0?OHFDNJ&&6JlGLLnfNZtG1dyceGXdtAO+v`hsUvfZeX<Fh5t^_0HdpiQ
zN1AWn*L=H1^X*E_x9OU1)#4A861OHw++wZ{*IXSF8ZFvS0w{jzAU*r&%fz>a3Up<W
znS7gA%@txbGsS8y7ps{eR&!N&N{ZD4mkb0=nz<ipx@GavIc<-!)0UfEko3GCH%zos
zw)RyU|4)B9pG_H+Z5ExE>+D81S$&<2*!HD^v}BB^dn+?^Nhf6v`H?@%`p3()zd2;;
zB1L6Ro@_k4R=WTGp`UlKxP0IAEaXM6A#H|wWiPH3xV(Sz&uMw;pz*!=2;=(}=u409
z%lfjK8><~dWL|AXit+ue2{685H`>ER?==C&*CsK(R+?sftu%ec!SeH2lAq6({5(|h
z^C-#B7l|{UDb74noViGxd3b1y#us(y<)QO6WFs`vA~ZYFp?SKPIz*$4KJ+%7FJGba
z<(Z)#8rx~JmZnG7o&@`&+wJQ|_rb3l-E;iW-E2lzr+QyMx~F!I?!@c;5gT~Oh^6_>
ze5@SJhz(5cOwGssJg<cK^O~k(3;lIVur_s2C7<BzH!EXsi5a75yzF4UYrkQaI!=MK
z--gO%?Z<itl@AMNl_Xz7KpGsE*VID@tQ6m{K6yR#1KZf{h80If!SSWTLn3|lEmhyz
z5Omrj`%yPYH6r5gH}7(1fty(17HnQSl6E4HId75``7b<(^A6;kVC;R?Wh3jjR@T|)
zUhC%x?E>~}U?Z(K_Q`0|jd^!krq6uqSNo7%JAWG4e@^J0$o^rWL}dS!q58=Fg`v90
zeyHx7S<vBrs7@z%k^NAem|<i;x{oVOfc<if39w%lGmPwKPc0Lb$bPgTqf7v$;JGG%
z4rPc5pfNElVL$us6HE;F(Ai&Pe-Upv5dfv5k0f)Z1i=AIxf}zwo&Yn6>Q?&NABBTC
ze2<C2V3Z#jIVKqWD+r2=#FfE|CXf-HSFkgU5!S#KxV}^2HdL`R0`CoB-$-RCD~@_<
zU`<QRXysVRNXFaUj5q8maghjCR#pr}A~h7PDY5hQ-O3eu!#kdAPMdBKWVo-q$r2%r
zG#iG*f>uXu=MASfI$K|=%se0Gp41t2E>YfD^vY)(KO|@thHFd!#&Nj`z&IwG0E}aT
z2{42c)NyG^FEB9-;V=_m2v0WwhEN+~7KmW<SQB6fbwC862crQKU<jp-fT3VLX#xzP
zF8)eTi^`S)=7JW@1Q<e{wK9Y!{f8msJ^`pV;t%6ARIMyzoVuAn2A(DW0TzDs27P~p
zO|PMdnj;DAE`!ZW6VWOVY_=kWNaj@t=0j%NNyk<MpH!u--g~UioKp`E4NFwJ0C(-?
zIu-`L5hoG(jYvO+1zn88luSO$5e`0tIIweGr_{Mt0TUZTDHCy{)w#rm3Cti6##L|2
zERGQ^Nh(EHMq)dI`WvQX`os7QvYYha;$uuuc^3B&kRS7>7{aK=fmf@$S{r%hJr7P1
zPj5ZF@|aG)QMw+Jp5vz<L;BYvtd&bpLfBFW(jaWEkFb5S(g=gxU2h75;7>X8c0|L3
zBa7R4<YSUFj8942&(RQH;(o>iP2biK^z?{0>tPDj+u%_tRJSG@QWJa;mcUHRHt>Cq
z)quzTi5>%b@#LB}ox1FE%`%)e`KeC`Jo|t6y>u<rxidW70PWO&3^n!|;k>T;4Wkc6
zC!Tb>(;8lNVcNbK88s|aTvLPV|J4jBO@#3d<83Ys33K>~6lR1kKnSUFPrc4!t%)xl
zvc$i@Zj(Rx5dO`QCQAp1<(W(Mv$$_^t^11>RntN>yHH;sWrn^PU(jN_g@}0?odb#A
z6hyuG`R84F{c}Of6!%wz0OO5On@A0FEq#T7-eRH0D|W??W@}rDf-4>XNS@i2|M3db
zNPU|Y{m>ukrsVyVs8D!>vqcW3<Hfm^?xIxQ@HU|FsN0N|_>Fyeo2+k@`<GN2w+)$Z
zDprhY0CRhN&DfPX_rA5S1d6+e#2`B|1|HRuwWPUJigtcp&=2;+IjlOt=*yb)TKsyD
zCq83aL+$`<e;fMe@fP0e!Kc?3ZU~o3lXR@=pi!lJ$P{P_97yJtl|&Z247=C|ym;w0
z)IHnS|HLb{)mOjlRJ=eHJkeDBvH=p>YAU%LDACPwJ+m#a@TmBV7b3R}kgdosX+^wx
zTU~ob@UAb&lgJ$z89j11Haj2l)iAbW0+u7ucL-k`{sf7kU~9oTnW1L~bi2ME@qy=>
zOSh|MqdDH&o-$nHvB!$-Sh~pD*?VS0F=N<XiCKgDg^$ghT-Y=nXe;=fAu7_4w9OuX
zHj4LNv18ZJHYJBpcy@oOsQ!G7PjcStkb7tJeW_^poyO!T5+OUhH>*+JpUh_qCS%_K
zh#9xgS<fiUsL}ikuTt}v$0i`G34JHI<5TdwxfE?w&d5djJ3QR2@nn7{Pxc%6kiWBQ
zO5V-TVC-?%V**vZ?PBi_1O%|6ZIau=_Se%o10N$gF+Y&Vp3IR^+9$Pf6()7OoXcQ3
zy>Ot@)|4@<sVKmInZxVWWpz|+4}XZgMq=EAe<!Z!o&~bN+VsLtYk603q1{Xl4_zfB
zPT>i!Nx#U>Xc{-FL$|3oMG{(T+*T~syZCZ&-q5UimbN0B@VD66k{CUbQTF=rWlASE
zHl9gQ_ZX(2F>a0Aim}npQBWnyJBm>i@y^ae=GcquUu7hhVN-=*poijkwUKE6eKzFw
z@J=DZNH4Ju;fKc4FY^N8)4b4+_b&0!CDXtVY#W~t_8#*#kSO$nOs@tYhuQ1+3PWRY
zC#w}>jS-C15k!sXo0g;eJ<UCtKA<5Jk!)h*VUvbSNbw9FK;{hvJ6S-!#|Ra4)VOc%
zHu26zzH8i5wwo`D^`OQUO|aYB#<JVi+euU01FxA}X=%&--A*cHbi*a^f4RSCqhY!d
z{ujQf?Iw2#ISO`~$Iq5aqPE*vQ|T3{CK%nstff3yRO6n|+1@<kn$AM>B$CFzEe0f6
zlHvs&Rqm}<+c~q*uh+iE#3oSp_d_R;E481TA&d6rl7VU+(e$pMqte|8%7}M1njLI>
zCiX7eHzx}O5YGgJFae0A*7S;(W6Icc+D+BLDdmIXWvWx0xJ!ZZf!3qV#6zNUtQ2)<
z?!IK3;+A%{N<yUujh&%F9d<I?cWs2|G*o#pD&zfYjq{;U^Yjo+d44h;FEdAV5-8Ip
z)&KJT_BFXnbfOfK+MHKybOTlvd|!(TbhCPuf-MCUeh5HpEJ>Au`Owz%^>H}v@In@c
zi~zMB0&k#a)b*WJPJqG>$s(MZH(#l=ujKdWLp~h$r2EYrPE5^IXSBHS6et7bX4-^+
zCP7uF9Tb{hb*qRvnxF-A5mOCioI*sw=H}8?QBgy7KXhyPT0efmXCk{FmS$s%(77#y
zjm69RHf87VN|5TBB6m?C-o=LV;TnV720O-{gbL6?D)Vr&$)JSEecA|BM1|xPw6XR1
zeM?A`<y<~Co4k6sBUMRx-%7XW6~qbie3~{r#_QwQ!iv_QaXmoID90Q6XVv%5gzK~x
zuD^YrFfqNacfMiUAjP!iZwFzXRzg=0NWA38bR}epw9Ip)1)IG|0P94MJtz4#?6qL0
zyZTia>^%o8HBs%HgR1=}oG(3^|L?2)Ddh}Nr?d;Hi3&llQkoj585_GtU!opnK=@^&
zk4)=(WY37>y1W9jv*x`Ox!gwHbf2fy=D~?~n~SuG$5%75W0+l>nQ6h;uOQ-h_X6z+
z$FOitr?ZvrwR=pu5#OUXlLNknap+epl+&)9J=5g*gpY$=F<M6PZJ=Cbat!DSMKg?L
zZWbw1jJ!7ON*eNqBLLArO$5mI4UpIUO^<dG(U0gsCy*N`YaYS6&Nk~tlYjaVAVL_S
z(Vfkz?+Vd8ELldC!RVg=4tA!vCmaEU@uDXCBs(7pfL3ej8`%}wC8m9V*mn8h$T56Z
zTD7XG*^3Ms{zR_$!okz0O{sK$Nmz`mIbJ4f@d7eQsH${#pb1ifL4f2j<K}Me5h@V(
z7WVHl<yLepCtCv$r<5t~1(Y?28+I5FNVvv*Z3{HBk2+IlN<P>9E)-9*>J0eeH2Bc;
zNt65@?V5g|<I3p_?8^iWrVj5kiYI1#P&s=p0Os^UF8OJ8#?<MCobX3T0Yef$BVZ8W
z{g|n24?oX;*~~62`Xgx^$zDFwp_3G@?JP5jG9vu+d0b6Z!A`v!`g!P7_bK2Ak)ace
zKm71O<Ba(_Hr#+@TAjpcrSwvr_S5l_L3NulosvPxSHxf4C;zGCjLgYb%=sAmxitLa
z-5DwPy`8=8KtyC<_UwddAl%Xk;eF(bl>Sc-ENSH)4FNS|jlLrEEiBN>Oo5+)Hq*M$
z1imZXLICh>o>?*nq}~P74s`hEC6QYLSA;iVo-`)BA#!Wh72zkjc~%l2dU$v>(ZfT(
z*P}y>*HQ+d%DvuF9T*woG!1zJOZK{b$IkmE>-Al-!Al(nEa}Tf!RA>@#}?ww#u!KC
z_p=%){9;RK_nv$8R&a}#>(H&H*^gD)VdR~ieVGgArqq@_tiJDiv}j~_26j;NGkf$E
z;mH&-mQ?Qdr$RYBSh6IZX7hGX$}-t5X#rZ&lrcO$udf8@vLXpwWq3f)n4Gb+>;Bm^
z<0PO7TTT9osQK4$ywk?=(>vL3sl775ZRz$a!k_X1WUYT~@g8&}41_7}&7wWcKfatd
zrnrCm2mO>RmYN-=N5LhsH21dihZ(rcAa}r<wxroQ>>>pSmF{K;m(t=mx>IE0t_3D>
zo%?4khgVOrE#H`2Y}zr_&vTOK0paoUDef>oDn~O*O2<xm8qLEDqNvarWUX>#rf2Hp
znJ%^Avlr+CZ(aVo#>bB2Vf)&F$*=cq$Zr;oJ*LF5oe-?p@i-93k!)(vWsh~-Za7ZU
z&Tc3}JsHt|HDwM@ew?V@RIu(#=QU%XZ=UdR!Yz~CK_Zs4&pNx$nMXI$SLsZM`C%8b
z^nCvR_Pb!6YE0WF9QthzB2A-G`2L@^2YnE<)_sN-`EhneC*w)?w=?~!Bd6;<ux$6!
zrDh6n31iI}B7}5#oBnbt{a^%FAKJgzRxEOy<{IbKs)ZNOu5Yq~S=W#~sw9yea5k)e
zyB97JURv*UFL;UTvhOCcH(%~-n7RIg-d7fEnBi<$-x3UL+2~)s5j~{%8}}ilHhWc?
zs;vtLq3*WL{1335O;GUqmR^Zy&PbPS_j=X3KDKk=De!a5L1@*nhqsDHvcqrDEZX`(
z?}80}lk5#j_^q?P+S%f~Td);<Sq*BKqu0OPt!`hhg_ksp3s^UVfek<&+tdEw5JF!)
z>`!<5)6M>5+n+4^lWBhfpl8dBjq}>|L>NpU-T#fe+k$49g@{dww!xrc(fSv<vkCaB
zSMV;G^)<o{B=80H4%yd`omsHedOloV*U@X?4BAoBGq7GiIrgWA{poIhy4jy>`;%pV
zGVM>m{16B3v+LH6ycl!#;1XFt@fiIJH1lb$Ok_|^?Eq)*koM$usgQCTvJ&|j>sz`F
z*%DaqO%aQ!CI3_V$ZzpqOndwgP4Yvu$`8>nKSbO75Y6*Lw8jt7NIyh7ZHOpm(@ZPH
z)_mn%sLE?PybH|l=Uy9#O4NMeN$H=c+2`q=Rib9U_o4Z1_jI2#QFFlBC)Rvv?hq$x
z{_S~+KXiWRs+`DjGnz3NW;R=*J{*j55j%c4&Y(lX<5haLey?v2lV7-LUbn)Fv*!lm
z$8f>^Ba<n-Gnr#J1Erw;8R_@>fP~7|JO&?(PtsfUxi~6_Uz{7*r1$IzAIv{AAF+8P
zUr!npFYfPL+`lV7GWuiY<?-=KwJOL+@!-KRflajKGgS^a!<jn$5g7ZbT<4$hsoZUn
z@?LU=OpN1I+3bFYY$;qHyhF#f_<`M=%<YWbH*X$~_!TzI&BVRMNzl&D@H>nSP10^e
z2T+YJic#dM9*Jzpml=utr}V?!`YjZCm31Rg);Fy}qt!Ebto(*t|LwO#QNAoFO0pCA
zBb+LpkI8e6b*AMx8*o=t+UmT@S;;wf@}6H+cA%Z5rYVy%ut5A)JSb(Ca|&^5=K{<P
zzPcMAjjoHoI^$J{UJe~^gO8yI1TQ0;1vz(3>w@sl*50EQH**<985#5T#A~wU`MPu)
zhEd>pTiv=yBK!W}veNf?Nt)g{r7xs=2ZNK~9*kbB4HY`xbziRcGC%!2>NRI(4k{3m
zq`yU9?yF;y*JH=R6QNG&7U!jS>6U`6Uwne_pUA&w{o8n#+Z5PfwzT2-@g7cQygb_}
z&c@is;YE}3T!$A;%2C^+7|D)TZ;DrJY0jozz?Wq^-^t92mu|0X&S#^%o%#z)w___;
zu3gakkp=H(gqAE?m=hs$FnWtxG$ki~Nna{(zmi$5X^`37(#1Jl-u*M))UQ#2^6YrU
zrgU>?ziCKwaW1JDaaM{<wIe@Zthms|`w9oA+U0;PUKr~LmwPXgb!mJ`9(E|I6AYlc
z?uvnz;09yW=+bz=2!t5(2<&K#=66YrcBd-q!NG{>)Ed82p&988os;TNTk@fJ4-HvB
zh#YGWi33#-$z%kPV+|rJ+R|8T9+zo)BW$K0v`R+Pz*hl$ZG<*3t-R5YnsgM^Queo^
z>BbthkYm(Rmj_Wuqi&9(AQ%4`DsM3YRT|bcX;@plk0fh754(e1ab6<RfJ?GH$#9+L
zMWc;WU`@x(R>oT2blzXAe_7*%*}9#rjkFSvC$wYCyxZVLi*EME{|aT}bp-~dG&g=}
zU-!TlrdcwGEPYlM&Ch;;G+dDbRmN}3PGm0!QbquE5_cy<r<&_^dGYYGqi)Cxo$qYd
zH`%M79aWiUujkXw_*D7S|Bm6G&86!EAYR&OuZVZL!udJjjq#%F!j3PU(sgi~1?c77
zPk$ZS?rcx~p|I4QyUA~SaPb)Wko+6I-XeerM)kI5yeel=yZzLqv3SL^dMOloYBlsU
zQ8Oyl@J)D8l8uF|3nibJ4$PA;5;~Agbszcd`PUKJV{Hh?w3+4=j?cm4Bw&<rb7#Xp
z{k0u$uOCV9_X!xB3b(F#+!@;~nhj>X6&hPkh{01#4}zs2?o{|th*7z@@YeB1WVC=y
zN$wIO?m=GW9KQ<+{w)9#Q?(A|91=1RNlwovmnWnAbn=HJla_q9%lop1KYqujuPuf?
zIKS|Z(sVzz6;@U+H@<25k`=+C1?+b_#&9#$3__a5#w)96jA>zL?5Aj-Abmq)Eyilz
z(wI}dE0KK<yfr={JFv+qU1O+>i`oEeF4Yw-e%9zGMOF3^MJF{JP|ay-xZ7}IY$+N=
z4UM9PG%09V*%F^m*Fv)l*&grdo%MKlPrP?oY_k*I6B>#2-ShEqBeW5IA76-~(>GIe
z;revi%7~jwI9*DH@dwpdSdz!P$qaE-PB8ke#R)8cR@_L}cS*xq4Nu5%r*e|aK*H#*
zk5{ab`g*={hj$5S94BQz5ucJRtb|)=F(v|)*}R^h`y}9_$TF!L@{HriT)m`Pw_s0J
z?I|o37d?ttH}8Z5>%hLiRyPA4LnS>@hoR})$%Un@bG_8~EiQsYlCQ_ZYkZu?PiFe|
zO;(usf?xWqv9WddJ_;2&GuChzwqOmt8daVr>7cc6N)GQsU7B6E^-JtmoEITh=Ot$H
zJse4<3Wl307-w{=Tf`<}!$p!6t!6@<rtl4BLg6uJL9V7#kT~ON2Km#>C()6yci_w<
z0up3QFVoI0L*GqsGz(1LGd|@@v!KzR1+C(+OeLLDudnl`Qmc2ijqbAOY1P)`Q!ll6
zwK516^ZqDw;@|1v-K>n4o4#Y0@rK{`U@S`=Nbm=K(AlP&XcG<ce#oTZ^yYc0?xGJG
zDhh`@DwuEEo$75)#TGT?TnIxq)y~o{Z0vUkVCqN3mPzjZJF+vTLq{z5m2N8^ror2p
zuLw_xad})oZ|mgy<rG9l;8dUr&NB%B236Z!dAN*MQ)*ZI;+(0|H9L2)C|A&k7A9xn
zJUMa5h>y(<G~qBzZIX>=yt_{;h*U=>d0cr<{9CMpdyM_rg@71UmKXMr9t&&Oo=u6*
z%%<8clUOaWhq=h;ASg-3F6F{VHM>S#k{7N<GAJy|30G9I`lIyO!hdw}lhJ;;(0TEN
z*~$I|=<R8_UGbuQz>ws^Zv1vtiu>(EJwn#W`A+o<NOm>!uM;&t5Em$YAwE85(f$a1
z!!@&EV7qkvz;clOW)+NAzYs6Z4s1k91`n|Y;h_R~i;QN9w-^NHN!-3l>qJW2=05lx
zy3nTvCyzcTTFgyCcQf*HvoCbNVcaJnDHl%62@jY={>hy<_;8eugJA53bQJmmgC`lx
zXK8HC5EgFD3%ki@tgzl8VckgS42IK;pjo&jc!z8cAfp6or_KX!72gQWBC*duNMhe^
zB=!prlGvTsXj7{hmnrW22((v%SPJ3g1~xQhjx3g?Q<WXN$?nutI*(H3Dc#8R6D8M=
zjdeH^ksQ85#qyRnfQHGKqhdR>7oTLfV8t$R!8T`pwo`cs7aX4_l;4nB#wJ5tFt}J#
z4;kKY!r+q6G|BRd$OJq5gb66o-yW8LB^=r*H^f%L(q2Hgl5SMS7i__O>b6O4WMm52
z(R^jRHQRdxfbp??D<`KXP%rN3%=}w~fxMDQ<o*3iQ23gsbG+u#Jjei-iMhV!(7OxH
z&ooQX*?odm@j`r>KPh2e%*)bk?h_wTta&Q!o*pmCXWJptyEw<2LjlI^5PsE1U=XS+
zcKMvjV#?=K<MW*E-YaVV{Jz-GxSELm+`shWj*jV0^R(o{Y5kY+AF?8X8!;wm=4L5D
zS1jeL(jEIDUFxP3{bMLMv!AVA%ZO!kEre9HW%EY2irfWTSE?v$kZdd}-7yFZ&Dn!g
z+^xEuYeU(C+&IKxp$gDczpm5CX&_ULz;$h(-QQXbf05tP(6Dqn<v}stor2>X&h8hU
zZa_Mvsq01FX3|~RH_^e({>Z4C@r%^hDemu7zAPUAG+agmmF{A4^9?&9>X!ISDO$f5
zzeGk@S9IDB7<o6a&j_5MGvhqFn>&$(b7pSnL_yb7(_X;Y4y5GU{x+3qt}76h<JAT^
z!)6-?hw4UM$;VU<7TCFo;Jlm$$Sk=N9Kf9Itk+40>kIw`EOSc04J_nc^ijtD(Qz6#
zX^6Lm&Y|(=0>Vf2qgbHCvx=Oo6z+dV1n=+A-5FmpkS9VqVCp#(8(kd_rS*-1pCXuU
zZqkyd54-|cZe#)cp^uQugNKvc3B<8;5O8yzY1-GvP~7HlPxny((8*d_IA>rN?i9L)
zm}XtZMhNOJ8fq>wn;JwSeK{LvXCVG`mVmqX4y&3=@|6LgXH7PFFs^iea$9zW`)xa}
zPDx+CK}#|FuuY>fPS?%VJ9GT=MyI|VUrXT}w?s2rCrkZMh?o)Kpc^=I^K0BCpbY$V
zo&$AJ!TRIjynNBkxCCFj_}t4fLMJU8zP5<KMYj+Y>a+G23g1dNeDYG7F==vD<(wYw
z9Vg0B&p?B>i{>k5kG0k0Ozv9yBmMa2Q;lo*=scuK=9a{>AH3?k%hda0CQs(R-ihBz
zEx&tK1?*)#Ir2%5r>{T4I316Yn?qM|cJw4LE8V3ZaC*u4n3)&@vC~uUu@<axYe|_l
zb@tO_t8u^22YDt>M%hH#bW=)4@?<}j{wUhL%wnFXKB*~a<_}JaSPyyD>(deT=`S5H
zg*o?IXJGdcu!*J#n?t8mqBxqFSLL30x#33+;`6~XAYLLbt=r?3gV2_}1e6UxG4<#3
zLc3{F_!?)weRip<3)jA5lONFU_f4huc_yz{MVo=KgUCtlH~-s=u|1`oYf`G1o|W#;
zr$dYVImSwD{I9jenp0K(>^#5fPz-1<rlRjiMF*pEC_(L8l~k28*}bkaDb~{hd(D)}
zH!qh>NT=$4wl|b4hw;n)+KN@PlprqljfYXf>_LiV58;0BB3_6w*OAbpZQpYee#)}z
z_8rC5b;5P~`e4Fm0zHG#H74-?uy!u+QB~Le&m;i?1SdkIQKQ5bEvedyqGbd$Bu+py
zI!R1|Xs{12<#M&PFaxLr0+S$zW00z~wpUwxv|6<-wziGfY5+?>t)f_spn{6_j1$}V
zC;}?^e}8+QlLyep{e1rTF>}s7`?=QIYp=cb+G}x*tVELNUP49fGbwC&9ySkyi0f!R
z4G1?qnXNq8SjR~EEFbM_g(PYGl}{Wk4>`k}PkUgs{2;<Ir{2f$g%e{DR-Ko}3plH;
zb}!1Qtn)&q)M=Kma*fsM5sOU@cjhVZxD&+xL~qgE&MPrzFXFLxoR-SV3RFhgO>J%C
z!&nU)uN#y>v~G=HaW)r>PJzw17mbnVEejfuk!^a~@>kP<GQ~$2tDv}TIc`6gHG!~q
z8ZYLmM)&&tjY#g_kAA4&q#1mOAvW#e|J{C{t`(GwNnoLAqnN4=4~;NidZ3YMTckDv
zjSt^3-)uME;e{$?tojL@56_WEweR!9h#MCUVW_+HB1@le(<^!`0pTF?&paph3U%hY
zj3A8X2?$M(za+JB{51qI;h{a6n@fjNDP^^`SF*hC3)F$Ml+TdCbb%RL1syy5*v_#1
zx0pW3_CLV%=j=B-wjuT#Fa&o+);i;8435C~aDz#P*Q7aM_4odrVq(WRiCm{94<->v
zV<iCIojHbruYlmahQ=Oxn-0z&Gkr#FowtT(pvX8s<D2FGeTpwtR?$fOM;O9P8oH_q
zmOLp>KgT0K(7P&5hSQp<3NU#0X{I)o(i0#YCz_l7jf8i$_XIJ2pFUZ^G<6-ugz$wA
zRIc34@NWf0<9`C(<zpZoFXnyMzbnQf#HDuzTw4p@Oz-A2z29|gUmBoJ3&1VpfH=(@
zz<o9|!uVG;QjNVc0W?AeT|Xx4bOtwrif>l2nPW_`cp+J|C=k!xCQqMHUFUs=XA3a3
zl-eq4u-1nO9vO1#kNjF{+=HC#Q)6N*+e^qVUJU8QN3#WtkFusk*u-5EA3@JWXmwuL
z*3Tq6cn-;S0p!zo<8>nMU#a%mJh#-6^%`CcS^t2C3AMSHge!w0_u(UjM?=)t@zB%O
zJ#U$@r2dOU20PGnU=@i0JeJuEP)Cji`<6J1Xp%vNneuI#@~JOUS}dp>0(iJ&pP<A3
zJe7%687&<_K{qqz{oqueG~mLv4<qyi9UiOhb-f>dYd=~vX8Ilcki>rLH|M{`A2n2x
z$NyN<<8s;i5M>bJ!(q;g{q??`+v{5Ik25UOma1kJC`^`NnMGomy^FOyW(m$a<sAV1
zhj)j3+OwKyzpK?`qnHE72UnbeHllq>_AsUIh%W-9qZnhYH{nfzv<wof^}fQhTQ*K4
z23}-)O|~zYZ230ZxEatti|m=zR9iOQ<cyC3lp@Aj?{9CI%EtS-!sH?gpC_71p5rs`
z?!^+^N4oWV0a7t%f3?%)$%!f-nX)3bTJLT$BbGZ;vPtb3HjOf|e?h;_AXoZE#*e>6
zAZ<K;`>>XNmqNaL>+e@se-o^~UF3xXbOzZ_;9cD=aK%pn=C$56r<?9hH7MXd#dz~7
zhT*)AZ~NBk2Y7#!9Uq1>=h8TL@B9q$GFHE8Z`V_1ct$FfPmQ`-NQe=3@$Dnj{Dv(Q
z1>EoE?Vq5Z;>|z3SGDJ<+G1O6`aysHVCYG%$}4gZoJCNTp6+ZJYU;&*l>LI{lMYo0
zaRc(?PxCo`y&E<m%gHR|z<H*}HVn6PAEfpX^40T%3|MAQqa()qWG0gDim)VK<mz9Q
zQDU<|n{N1&gVUXl=GZzue9)N}c&_!G%K8pu+gW{Bs>%xVQ|o<JBJH7Yz&=!434cV@
z-ZnJjG~&zrn5uZsEAK`<eU*02w(aC-*R@&nARvdp9&>4@IhvBuSz>6P@63ozL_zka
zI`M43<WKbYb}ZqU2gh>e+Y((}IeWGSd}Yjg@)|A)L_ZYSvVUa84Nm`x*+<s<lh<d5
z5+5>EAiz$@RNN!xT@X}>OvQj`YBA|X#yzd~lN|8X)y+=o(*-$|-ciA)#NF-YmN}rv
zaCWALx=YNBnN!J6h`3PV@2+t-;6d;zjQx4BKLjqoTyYBh`g3nQsNMj5>EXftR((fr
zN%cl;7XKS@w6jq4#<)Y5cmt15PPCCuuLyc}eNcb6$!Nu+jVo<5Vf@OHZ%r_`YMU?k
zm>BFv8~vEYL73qraX*``hf<+gF_iyeP-uYNI~S5>3;~Z1zz}ZwCLf93V?5{e1QC>-
zfz1vk9!>4k>-D+LojOf|yEQ9Foqa=h%hvjF8&nMhJu)Z501Q|6-u<zUyKR6qwCAOE
zCq&FoKvKol&inaAW~URIeG6kVfT;FP9Hcanh8=RXH-Z$iD^LBz$grY~ywqwd&kDrN
zJQ@=DyCo415)moHyfI^Zl;LpCjNH<}^*MFku;5eTQT9qU7F_Bhvy?SbUOkF=-WP-N
z%~vzvUxzH70a!-rCK9lrt@6G(*^I&%XETHAyt!fGGEW@sed*kw<L_vtg4pel>b$N<
z@Z}kO3GAx^eyR1u%+-ADR}j^^QT!^NS^QM*Ornj#H@`wlwchws!E4=xOqs~m#1U+A
z>pZR6ViU(ti+`)ne1w4RXGq*vu;0aM3@bhJ49l2cK=E4kpw;4<-cQ(JU<N2>DiHcQ
zanstmYEMqatcVrx(sBjwQdi!yEZneQ?ugTq9W3?g$pdQ3@YgLtp7d?v>#%iLqyi+T
zCWD<r{h=PZzQ|e6mV@Fyu*kzahxB?3FlTA7kM}J5c<1o!<Ej&Ta618n0wBXaL>ra8
zp9=U?TieS%&I&%o?=~#Tv285t*G3P^$mz-5;m$h+v_0={1bx+6dXPIG-+TaA2MqBK
z42S5n9O7+v;TSq)*n@<q%X{jYy^>gV-SOifQ^OSW^&I<EU)mB`+-C=6)VPML40mX)
z@0|ThL(#JWfjZpuL#Q~}W(2_vfORF7p+)liGC16<yJIEk_ZWxfL7lg2v=6I96LTQi
zr3sL})4eP=^)Wg5HB<6B^K7`@cX&Mfl>EmRf~wjAwmdJV)_Xljj{h-r4~1=?e{cHy
z>#y`+>O$y*BWy~x@u}APLGP!r`c%=$hHDF-D!oO)r+7}XZE)%+eU57N*k&rN4?ZW}
zux-6&lFNINpGrLhH|Qr{`tuV;+8`tA1W5R<ckkn7iLdqkM{EcwS2Ic4o|yN;Vy0)U
zKRu<yvr}%vSIm?n+c{P4%+b|sF~0J4-}yF*OVG8|-j8%-Z8kK)Z0mR)Nc1kkJrnC1
zTVs0dw8SnFtGz3NCK7i#ulN$w^=Ot;3jo8x{KkyOd-acovCPpaF?G~>|7$sg8P6h8
zu;(4qXFTVahW30p7|W$x`L6S7*Be}!LS`7)$0ND*AI6akV_JMDqhc_|^v%@uKu}lW
zk)BR((!It2a86H#Ta;#aO2Ve4m-dmz(D%SLk#(f?!3<2wp3nZkQe>_vo^Pi{DFc=C
zS?B%QGAh&ON>XCpt}piTRa8Jw`?UBmI%tS?wxcOQtkR#1Kp3J-wbuzR2K`LG6MK4}
z)3^6e2N|qKHq%huItwoBrsF@+-gZt#9rCXZOp(4GeHKAH(8phF3Y_&-dWNyhMkkZ)
zSboflp2_ixt|9z^1&uC>0yEKw2PE^;=V(FwyD(@z(VUVK2@=hQV)t1R_86IaQJzz9
zMP>RSzF62EZHt(jLbAuP{8+|%HN@_TRaOQ1URZLEy^epFD>0u7T>0+lq4y&ddEw-3
z0F3)k+KjH!0b+=gR{)xa&&ri~^R7o?S#hnhJja@63=E4uP6P8?XMIb_fJo-z6IPBS
zYy22OOf|i*@HBF*7!lf37TKHF&gH85&f-^`F7RH=5l^l&L>fPu&vi3r*mx9tY{)A{
z6&8Gi^!!gam1s+EF@JX*ZoX@M2{+05z!#@vnC~{^YnQi&F4Gll{7zPC1v^mKL!Jyq
zj&^fGPla|ufRP3OV0;hZ39>#<_QCZY_N`gTy-UK&MPHMi;7@qDTqsQ1smB}E^4D4a
zI0+faH%65?dy6|Fo5DBA5hT3lyvWY^I3B@2sk8OOHsxt+jDIeDD#=9$B`3npW(=8k
z4NSgq?%?$oC0<SLBYvgySj-3PA;QbI=((nA#Sn!yqGyqv;TvX(UnX)m6R5~5{-Br>
z>RgAQc!FvuJrFPfKjbtsd!6-!Yo0-YNq?uN1!20aS(1DsZ2Y57`dF#gld3IA@{K_$
zdB6~yYVz$w8rx>4Rr(j2WKa&uTAJNnyg7XXn=krF2O7{9anzS*3U(Dg=b+I-r<*TD
zQl2p=HZCNb4G09q8-#<XSG+f+;|iG=G;|fWiy+voB|PpG7jKeDCXb>OECWmp&XCj>
z$*-H`#z(t0f(M@ui1~wgbATN+`*kDZTS@!JjF3KwU~bVP4MGx`?pR1O^a0?F)IbWq
z<Wp!blHF7oRHWUX9Q(+_wYQa-O>GOWWR=6e*R$BHb}i0oDI6KuK6gm^h|(3I$&u~x
zfy#632l(8bcgchbZ|*aCnl_=Lb6(VxK6eHFFG7<w9rgtiq9PxQz|6EZaRJ`iyn)Hh
zZ7V_qUQX^hH@UfS1woV7XQq?H6{uIyj`T)Hy-NSY%#PpLm7~ACt;}%*k4_CYk*k^T
zh92uNh4T&LD)OXGP6YEK&plG-+K9NF?vT*F2x@@}FPs#qYjQL|g1dVr#}HEe$#IPy
z?d1537WzyMxR;$B##&@g{M(WG&IO~=-|8j&GAQ4=<l<9!`7+9Dn)I1G+n_Q!1&c`R
zwwww2DBk1@!9L1R$ZnrP(m6)IYT%e>=-<pEFT7m-Zu`um-D>KF)1fCji}oKhi`tg%
z>!!r~Hnm)#mi=X`3rt0KgE(-8q7*HD$h4haWoFtiYCLqNNfNU&ZEc^KW-j6$W~QY|
zG%d8E?bb}AYbjZ7FnQ{kH@ivbNL{Qf39{rCA8_l@BAeM)(^dR5Q?H(WG4*x_Q%{EK
zX4)K0DPMnL<R!xpnPJT8M4p@D><m5U4k6~_yQ5mNk0h*T@z$v*O+YQTAZqf~d!s^|
z2{0Vms+kdGuIv?AKrCDeKbxf^rPpDn-Aas4(akOZ<jd6QOJ;HSy@^0B#NGq2;5Oq^
zC?=zW6T_MCwB_P?$^9@t?Lb$+IupAmB%r(l7H`ZqpDdGY114mKTP{>v(rhMvs-fZ6
zV&%Z~Z|2a(VD3Kj)}FYVYUUB(jjYzGmEV)~OL1qSk@<OFg|RnhQY$@#7xI<A+%y^d
zd}L<}TE7r{|1v>c=i<AIpB6!|vOx&&%1-z%yaZ4%k5Skd(p$Q}dl1aE%Go-0%X+5s
zu2GuNS!I!(3x=5xWRXv-irm?{&GRRDR#`GN@Y;9$(J#wXgG@SMxA>Fd&9s<aHET6B
z)Aa=>J6j*+=0?VPPw^U)n|D!p`Yy49l@|#dZy0c_PZdxLS#==2-W#6W+(kYUT@5lh
z-^ocG4}JJ+aOzaGXjw62RMA<yky*x*_;4`GQpb>qb-~`>PVJ}o;qBWYSF=7}Wsqgm
z9bY$(h6&f|u^~?k>Il{(tsTISwE=R>bH_ScLm!Lewu<CBSf=4g;pAlHJj&1*vjM-^
zka_<lyAM~A-Kfu%j_0utR|=NwMv}!AUk5fK!<YCyXpN2^lWH?x|NZI>(*Q5w<#HaR
z=R9ae4Kq_A%t!+67S=1V8=)v!6j%p$@brqV_1=(S86BACIUxvG)Hf{SRlQEmOs>zi
zgVgFjLfGsOe?Ym-Qt&}BazGyeU;y_Aj5@M+{TEj<jF1l4wO}`L%4q7C<qR=F<h#;$
zS+;dKKner|1qh<pik$VSoE1|;#!*LCDxvoKc6ddIIGQ=EPkp<+!t~mFC=b#3)HxKh
zJaAGU9ym`;FqFP>g{8s6F-EQbk{4k9T+zv;T8RvxA34D*-e4C23?z-vfV?2Sd$7!*
z^B=<u<uB1ETjXbSD<UV6KC2_UM5i7G&xtgx<Xl#7yh<g{4lOR&6zbkIIdoucW_zaK
zWL3H5!i~TEkRX+je(!MWF%pghD^_L0Zx6?9UlW}k%xw_`;kM@9h9!LrGBwN`Ow7~g
zj%^#eW97h=GehflnF+tq>FDKu@v_Lv;pIBDNPYr$l{mEGm{KRvsR$a$H+V%9gNv^7
z+2Y2fZyC1Or;5ZMO<vt9H+k*hEUj*#)r*2wxhmC{lWHPSRWB!fYslbNA}_a~*$^lF
zjxY%r5Hk{5;=1~ha3BLM{lqZPN~fbQ1I;XrybJ@4P(x%t&SCj=I(ir=;*w>cW`N5^
zsh#>9%RnWw{y^&=6^nmf;dC6tKQl|ycmIp^q3KJiPC{>9@l$?}JA3G^)6iWfGb)h1
zJNok6%u-+8H9WUKgfCLgM;?ymI<QL0vqh5R#l52tl^A+9v)B-<^t%1^0|h>RU1m^Y
z`0E1mX!xt;x<(2<MqJY}SC~eK&=U|MHf%lowJYGSHUE~s7SY0_CqQp_`Kx-|smB|n
zr#lRPy^&<`*N?~~{wnTsD1Q~P{3pAkfWQ8X`~iQJSlNfa9;?^r?xiWwnfR+VP?}JE
z_-pia!<RBwMqgi18iH;`rmzviZ=DSUx6WBnDW<!^ur7bsrJL3Nitk$Ky`Y!t8vUEU
zjeD0~AiTnLPo^u*W--jn71KgK^S#3|-wXOMUwIIL`Ob1sk>Mc8=ezv}LioA93q@&W
zazi%znA9}L^iW>=E!B81uhlfNT&e$dFJ*LgIQn42wo$xRkK(n@?-Seo=R9|xz;w_)
zPZk)4gys8?{i)%%<~HINk`1|8OFqxv%<xTr0!T#I!=LJbaPyZzB>o7y<E7>*<H{pf
zY~xD&q?M=`IKg|0ti;pPV<8z^(N>c?YhwIG%1lf=(}=r}#3oYCO|;Eg-7208k8a#Q
zF^*&H3*%R!dwr?#lfNf!CHrHEJIVe8XN2aaYx;YnWh9O=RfJnH$571~;imb3ismPt
z8&7c6{5Za!OH@EUC5~*>Qjn@4gV}$qJbK0U^ct%94)+R3B<p?QW*twqN?xPPt>Na8
zyrw?SpINIXP7F88_ESxUo6lB0ogtcLn@?6g$yj_{7;aW5P@{w4>(%V%cwMpG_-i__
zA>6Fhjdl-&oBmtH*7K^$b@tneFzQ#?!E5S1{silvJFH8FkZ(6{sjUt-HImUiD&s?p
zWM5cZK6cOQmcoCKlyR3bx%u)lIUGe)uXA|&;k*JFqW1UmS{^x5^(^@#`Ax3&0eaWJ
z_5peRlW$7eK0x*BABwWT2Jm-!mwu}u=cxIE%*9gfUqo}b*?h^Fmt?d)h7}>P`hH=5
z&LN4n<LuAVHt`+%v%~%jx8DZYpHFS#8v8TGCO%@{&aiLO?9Y8R@qP1i*z*wYw?Oo+
zHH<-gCrQ8WYBMj3r%iQ_Qu;l5ce9rPrrj>NtS-98D9>gxg`@$@UgiVFrbvIe<adIj
zs_KE6Ui7bhfGW37YyBtS=*L5R+wAug4*<I!ZWFP=NBg=POwQxzY94&)f9TG)*rb`*
z6}SN9wqvxjg~O#5Y{FVNc&e)NF4>Wp;hy8Hhc9u?Ufk}Sqg87}@djrENmTGvZ(mh*
z#ya58og9z9eeYdflj8@)kMwrw18Vqg_UIf*6egcCcJEvL^=)$eNz|f_edU{#t8g^u
zn@aiOlpo)qwXgxMu0eU1FUk@<Aj0%J<GyAzWBQwWgtQxP0u}CXI?cP5S(*EJCDi6)
zrs-@g?f_e>Op5u=jSC=h8J^b$gtn2XcsoFVsp4|8s^$Bg)PVa`_xq|!8zB18U8Oh^
z$-V4ju48=c2175yXOnvm#Q*3HbW4iRBHf@JJQ}admBF@CVpis<B#iAY-X5a~TWhR^
z`#q(3ecJQe@y-OUwA9?Ta4hxKcZRqIM&<MGOJ%Cs@;q#i&|}n&4sA^-vadV2h^qId
zH2Xo6#wi&>tA7_4Mr!lZH}uF8eyr9+t_jt?S8h1CdX5VgfM}dnS?&9>=~<ec?EH`3
z!_j$iPj^rJT`taKK?42fKjdUF8JI9wmnGbGp!PD{hfqT1#GD7)nt9Kn3x2@g^h1W9
zGXLeiPdh_M=SXu~+V_xSzO#T)4uvDIiNB%cESBwF!)@N=``w}UkuaT#kFXxKrY?vh
zEA~ME6QcQx2eJb;3Z<@48yC=5trKBfkPQJ;QA$+r4utqWimA?m(DthC=dl(Cd@>Ar
z=e0cugUIwBaVLap(jli(Rymup^N_Vaiw{nI!ePA3bI0yTnZvPpxsL&UV~I48-<WD`
zp=SlAp=e%cyIbINReKej?x@o}EiF<@QdfTDa@A)ujX0&*?r<8|#C_|;_h>*yw%FTH
zW6XQ)ccx=xqhl`j{I({$x<g$~^rO@$+MOizXn2*P_i$dQmy~3i{`yq^e7D=w$oz_V
z3&_)ZzKi`$WmOQdl`}E^%Zkl8Hb}uu*YDqvWm&ARz0p-vBwGhI{cVZi?a>?Q0+e}U
zFv+2|ciS;dQJ1t+VJ1|zAZ?7Qu5^zGJyq3>bbKSwXJp)=I7R^M<Y24*RmO{+Zl=H=
z+UU&8c1MD4!6w;o<AKDT*m_mN@LHl?b<7P{dWA!D9<y52$P<DzzpKMHJrF`xWsXR-
z)KdRqZ1!K^{B!cFy+2iCXIyG*B3Dm`3;u1#9;s>PbYomNe5andKc9^?orL!;I+l&<
zm{Z_zQ!8VjZ7m0P@d!iZ0wp2i8WP$>OqOn>S;`sn#*l0vxJt&{=^kGRIfONQZxZUB
z%QW(e&gqyKf1CCt$6*f5aJRZ6x$^Ii6@nXLKuR~lH$4o-0J4~F>NcJ^1+4Yj9-(wC
z*I}^Gg)CIXW{H<F?<O<d%t-w=nL(AW;4vK0cPDPv1G)Tnk2kYHAZ%NR@?PEP)0d#8
zQL5>41S4vxzk6kA77v7(H-AI=n;DzELqHx|?S1V+U4SfdURk%7l-7Bl!@*K?TZSiN
zlH?M^!=`OKxq~)k6s6?6i1vUt_fQ~$)q?zLej$d~c7qY0xKck>R)Bq}xdC@9gQUPf
zpc>ks#m(t}QeWF^szcGnMVXNd$p>gKh#Ay@r}>A}uQ>hkK4pRi4NT&r&!0*H{`4$M
zo6kZme=>GBz5EFW%Wx=YuR|*_u2x<E8P4XD%SAaKaTjitJmzx8PPZ!`03$F6I1M8u
zjsxtdHpT%KmmfP~-7iQjzsa(sYOnegk;Wm6!cfP71My>%2R^figlUP~B(W0f=^}op
zyQThdH_ssFUm@!E(*i`Dc2*Cf{+{7s`Q4qq4}*ip!Fe~PDZgNFF;=sWSgdMckUp1l
zPjfoBkD(j>eY<{p$6>pkJYaZSxLF*Nqbwa6QEB!NNckTRQ=~kH%E1}BYB9KW8t*yp
zywD;f&#Y;IYbo|0?gg^7OyR|YgXTA7V-&rgm7{}&XzZStclFUm1SN&5oVuugYxGx>
zjNW4TWbo41@T&}5#`DCXLM9gH90!JEG+5^)gOY^e1#MF!UE$@o@?eWB=ZO_26TLTo
z=3nPV*Kz=<^`|VC>&DtAYky2lZuI_`HxN?8R>|4u74l@{ftt?hs#y0+$tMfkiu>i>
zaZ`1rcTo{n)Zm1&hb|>2z(|7ZGK1{TsL-zcO=f4dDJ7FqXG40KF$8+^IMasr6sCxj
z!y^$?aV0RGnv!Iqu2kILQopX!TR2iVa@oAcva0kq)BFupt;{gnrrw!++tkAlNIJvY
zghtdvg>D%KD_om;O1z=OCzrOk>;}xZkDw)udy_Ysr%Rm;SmLryb}EKdNiL4oPQ_|L
zJ}4{hhw^6tfeS|o0`;9T_bxI01Oo8Ff6xLn^C>_5<wrl>+y8++9_m9M6&A>hfy7M)
z@heG!R;B_&=w-!!Yx*YEPDtd=&tev|<e$Z)ULGNplbT7h`JF$YRX@`9^dMiy$_5Az
z#k|2sSs-lmM)7nA@*fJ2UwM2l@}uPRk$)7(M*<NLK5r+ESf47df2i7fD8Cn%AopLR
zv%UQA==_)&jG<940`Cg?UP1L1f#2lmFbKQ~BMP_TA$%9qcNqk_kYPZ=OHAi10;Pli
zfmeXQm^L719BXR!j<rahn)-!kD6w|wfk%K{c=;{7KCZ`<{QMqr-)IpkbBtm0lF#+I
zb1QyeOuSM^&`z`oobE(6c4}6@p#KuA0dEDkX@WnDpcfL(R^ShwXI2wJ5nyi^>wZ~F
z81gm3_Tm%V`X;STvUGlcyMdabm-0@j|D}{jrF-EZXD`mJLYtD^=sdpV<0wia9$-Lb
zp%q>}8LpSrm$?<Irz6E+>wIZQBFv43-Xy|wMrv*h-!vRO1T%Qmy^vNv5hgRr#n$MJ
z)aGG^t||-Y5%bw?;9?ik=FuWcJDP)ZaGga0c7}U7@61hZ(^*9`M|OrlE1K|sZgYrV
z=<vj8hpB}iYczu)ocR8cw2a8c@bWeK$Pre@QZD^ui|+L!x-ZXl7wUMr`CcK>ZikX|
z+>jAH9H>G2U_M6A8z^!qz`laal98&tFT5{K&}42UBa>Hqr4UFTIG;f=KtxIs=jF{e
z(hwcK>5Kf%dg8P0)E*XZ;lF-`u~mN&E{LGFqRLxm5!5ohJ9VyTu-mvspnXo@d;>vu
zI-8MjlQes#$3QK9WY1JpxW4XfPy>Xp9x6z5(g@qtyT~$DQdjCaNhUR`$F|k}TiNKm
zvS14KmyO~d`E$Cd+8ZA>L&eQyxM`HCu2{V(RAd~Kx)m#`tE(!#-_rJUH-QA*IYTBE
zO-|y*Sx*RpH^M{*9b+m;y@_zsSK48+ctdF@wME;Kh334j695`!vZC5sk|)$)@dR$_
zyCk}n<jGC%4S(<MzGAxBnj#+={lg+F|BGfm18iFGq*xleBR#Mz`N=oqa@!q#Jo}88
zx2#kn&RcQb$*a+|y=nDRo6b9KwQ)SLibC#DQXfT(nkw8PM+@#Gqq6D_uX<45kCQfu
zC=*A_T3w#pm=i%Kb_?k(*=iDwy4u)yb00LDd$%Q~Id&y4YFI-ntxm?RX*5bJHg^r2
zG&WAh1(Q4@lTPQHO!h6k_Y@A+Y%xDFX0PE-&*k5H)FaKKDoBd59Mc)?hnhr0JyV}s
z3I&-AI-rI^AG${=)yaZGGF%Lmxt`uqxV_hvdRg{e`ciU_`QFo^mh9o{-^{*8FoJVZ
z-Hq1uy6HnoO2q#AJs&@oKla+|+GW!K0dT<@cOM2>f3eW(L6*UTMOOFX-?;USU?Ioi
zAbu~x8*;jV`f=w5P=C|SO5eyt>}Sujv@=(S5!&;|>wr;ppZmF)&c>GJ3`Q|_kJH=*
zxu*x0FFo)fRDh6ci0Js3H_7i;)0dSKI(l_e)0ukAX#Au3N#u^zU3+J<K|`xleC9yt
zQ}?&3(`o<kXNj=!Cf+C4ETrB?rEl)d6yISKkdI2k+M60~>Y)Fv|D*g;`}X~!GuBq=
zCm&_@^!xH7efjR;$~5ZBf<s#mH_g%)X+jUF?Q8n7=y0`_>&vpk)uwnut<shnZ>fEI
zU8pZNs7&rbz1CT1>n(@-qTm^=Qo$Zl+t2jnCx<JeQ=`@g5BFuRzDNgaYGb7}h{8Y5
z4>p8vZZq8)PxKx!_*Ut5A0B#0o?&!dd9sv8YT(1<Il|Ag6Dnwx#`rLK;J2op$CO7J
z=fmU?a@CgntG7zKe3(2iWs}E*5s}XMFnL(UOrDEXkCfaG6I$<}v9n^CJaQk@`g?%)
z@Q_3Dh$pE(gOo=~?}rEV&C?dXdBd2k;m6yg-`kRWW90d%*I@dq4X{(X1^DP-YDjI?
z6By4(J+3Dmk)#yA=+Pm1dVr@x>_N~MVL;1&nRAZyF5E8FQ17)ryFM)KETB$AH0-t6
zOTuBbP<)>%olUrEHB&Y{Ol+%c=_h8YD=>v!FRCWm^&)!$(|i}no0^U@Q{3m+V%Hm0
z-D0Zab3bP#@k&QhJaP^jfA+ynd5&{@d%0*lqrF@>#GHLEQ=VGH2+)n<*q+s^S-0p}
zE1v|~t=F&xAdvAcOu5sqP~F%)zRt6?lh58>$c^&p$IUAlrIk&u4fLDI&I14FAf9Rb
zo6KsD9vC-#_GTKl3&=gv^i#vi=z)pD!zQTD#Bt%~?ds$J8N@I(FuzhRDZT&7Th;7q
z&a23<f5hB8$;SwNvrjvg<gEq#nfFza7un={wo-QX>LQX$j_1!JefygKZI{07IxZ-u
z0~hZ+zq+*}NnUdlf5bMtQ~l)CBS>i*&Yx!0q)=~ayf@iZayPVSk|&izAG2>&n(^16
z!wZ00NP;==@|rQ(HnvB0ybLfSH53fAo~JUJW4-!GyPox&#+(3f5I$JIIK0o{jw1GM
z$E{^Z!e>X%Dl9$c-=z&A-a8aiqZKcUg|BDPJ621-A-WOhStEUgl%1wAyX>_&=C&4*
zt0w7GhQK?;sC>+oF}Lv7h=W;X74(iB@2`O2rg;pcJaQoM3irz^8Y^d8d`-(jvgUTZ
z-dygac}q!A*Vr(iU_6dtX_MEqA6O{m`)zvt{sv~j1kN~zQ`NdVdH{IdyMWpV8<pPe
z43mmDwn!{Nf2;r{UK|h_uRIj}6B+x>5_^<xPl?-ES^0;r6Z>PQN{N{&l#|VRBPUc6
zVf>qqPL_Z7(c!AvJiNouHn2C4k9o)Lmd_tELFGb~I1gs9pPtnNo=Zul=4!9VP!Y2^
zHJK+XpBS0Kz$oT@?R+0V*8gq|!EmZ9Fw6Zf?WrxQgBiM`&U^S=AdEf#&-tZGDfwiR
z{)pp-Y=cnAAMlMg1nEzXnm>3f=gG$1N%!bGKLWDUGh0iqcY~p0c$VQmv$g1Y;_1{%
z+B5CZ9Idu0n!221-nAf@_Y0McdUWvUo!e99cBMTj+7?f@^)xB%X{CKGNDDV#1#qbE
zFC?4#tbQ^_3zvECgd_7^i<EhP)xK*XG4HzRrg~pfy^2X^+QLhM1^R5QCf<F$=~Adr
z-(Q3FZsgNlVjihC`Er+7h4Dd89xXDajoE%15_-JLdh1$iaWPvWk5|^4e!Fc$@{TF5
z@P5=M24mg}?7Jij^RDoIe3xus-uJSE@Gc?1ymM<#?^^K9dxw43f@|J4^X|<<)1Eqt
zmJeCK`qM-F5@ga7?0GF(g3s9#+P!0!oahuTD>28sGh`FCW!;72;a=ZmX}Am{vM1lM
zV)vtqNL_cUKF#$%{hUwUM`*~>KkfBDWEfUCwx4J#&o!#Z_;_Qy9UrTMCu4JZbY$D&
zOuPv1Sa=-vLsCL`4QJrm$XJ?zN2kC!#?3Ic<r=4n#}e$vbU)tcLwfHmnf1uX`>?*h
zS}OoF)EEM6cQ$e;YS!N=?58F)bj90Sa?Nf9RU!gC#%M9`eA>2@x*dvw&)J=nsSz#3
zO!xB4Y=2!e`xZDqhvVAgaJpgkFvTcDV2|ew;f4mzmuHX5<_auTro;lQ(<1s0hvup-
z5$EN<I(c1gX8a>}T4D1RVxK8yRpK2t(+}<Do8^^C_Q_~xUuk{};|jb~*RT@{9A0O+
zrE-S-$VtlAyC3n}BO`9LZ4)1oGwEd_E6w*XU<u8~+gomSe4vb35=Tp#D9v@N3c05F
zLi{QFs_ybREAe}EFIQ$MPHCR0)K^f-u&T#Dmf8ADb*poe`?KO-GRLdKllwCdI%DMm
z7nrq9hPL2f3w?$;v3(8%_}~Y8Y3o5MkT=YD;#a!Uihx<YiP2T(mgYoC3*tlMfNsfx
zEW$Bz+!!g%?~{_xnA<HV(KHYn1P2-CyP2C<T}umWxz9WJhAz#wF9SHJtltRK!QGM`
zu(p@x=sn%xgSkEPRpvta5AHNk`dT;B8B)ACREn)-M*2R+BYc}9ejnd%tO(?P=wj>9
zGoF6mr)pFmy0M%{tROygsjO!-pjd%BHJ_80$n)`Ge&PTpmXBZ7y!z1d&gKB^;{Uw}
zXCn6?{15<510vax_3_+byz8CPeBwc2u)cXhG<WV3AU?EysSa3|IMebM6ge|;+-dns
zrHo&);8<r`c4S(?{2u~BqFiy;>E-}7+kK#=cN%_xf`B1$C&bX-WRduXoFGOf_rcfX
z0=F`sbD_wF-tJ7!cQ!<7au?tWHWy1n&ZzTsK#jXV+u?i%2h@{&Y~g`ATO`^(+2ZG&
z_Q?iu#_Z;IqRgKAC8j^|voJBBCtvwbd!ncW;B)K?L}}>n-|PQ-eTH|Ax0EvW|3C>P
z1@*<7tq1$Q`Us!?eE9dHFZ@0Wne)H!Pl&5|OMPHlwh<CccSybv|AvKaiI>40&b9P4
z{y&<4na*VJgj4?fEFSX>OA%G{*XIyVKuRT+sVW+|$l__rVekaGOztzoC+E9II$N{Y
z1eN7xVH{DG2X!c_gj1cL9^%hepunW)r>~KDhO^OF1k9d}5_ZmU-mGWLE{`r8;Z|$H
z4kB)#zS(uCKRp?H1Jh$deA45IZl#Kx=~m`MD*MjiN{Bo=QkmapT0`_DtcJx~CrmC_
zki#B;{%zUlY+knuuHsz*s~Ov77rtJ8Zv5rRF@|DZ`?e$|@*uGk%5x&+eWn$Gj?1$n
z<$ZvJ2c(&WjO)9`qte0%j_aGZEWAkfK@om&Ix4Swgwf+U*ByxRj)R4=yjr^y`l7Ef
zfmxRm!7pByC%X^?Wids>WWyVOy>5*C_7n5XCf-T?wccxp30e?!78>xsKJaIYeVmti
zsu%cWnxg`~w(JJ@2ivdVRMvWAG%HRyt<1q!T$5E9A_z=C_s#-en(xdg#F2wm2E8hB
zLwjkF7=xI8nOX6&xQ1A!pa7T{NZ?pk!8klE-eX@#r-S~Q{TUktg3Y(ZFSgTkDlVxa
zWqlxDre-2#eIQ?!@6O9j9>|Orx)<cTWd$wy;mC%0qu5ClTP2>U|6u)Pq<!w?E!SO{
zJdl;R+{V$UanFbqzr;E6S7Vql`npkivJgCBDU;<~U$C^>u;>f4o>u2O*Zb3a!G-vc
zRm(JKt<~^XGm%|bmUNqSM&jwMZ%m)6=C@Lhk6xc;JmMog{Y$4~UA^EWhp$|4oCvrM
zo?qE)MI;37z!6nh0U=&Gyx)-9y{t%{AQD3^)tof53i{Ve-}5iYuU3^RW7~{Hg_4~l
zqf#Rk%~3@cuxiHBG)sAX>RaB-7rBSo6R#ChIfO*c;%=8&<rYkKre{0TbDZh<&h!HO
zV2bLT)7nc6o%midHRpg{y-ytz*vpK4p(l~;rRD(JOZ}vO3%@k<Qh*x14`G^H;R~Hj
zJ-bmW;`M9juG=AErXe8ePJB_mFy*Qy@g-}O<{Pg`31F2vz7#fvU~4vKTmeLoqJr>W
zSrExlh&$;g4PB3I^OmsjK*9Z(c?Xo=;hi$RkZZzKr+<8iJgNEGXDHNK>mGH7`YNxl
z|7t`mA-Eh4#s&5E?b;~1<_`*6^`7ZR;7ILv(rL)dOvk5q>(fc&O!V2l__p&?6vw?$
zj=5SuqANxcZeC^{|NTsbRM7M1M>Z{}#$>cCxA=WTM(2Wj+}G~SN?dJ))LCwp<{JcE
z+y%^&*XL%%zs;MKPEHaVE%T+5FUjR|52pHtSs{x*uS~J|FZt8T=_0>TF}Ne@DqFHo
zXFpLehRx9kO29#77n8o(as=0%fNPH8mpQA9><!;=EtD6l<fM!uZ-0>@)p?Y0M);*P
z0r%41p8NMcytrM_VD8zj7m#Ka0lH>Q$^U3g!Oiae%y83k<-e%F=)5BP7R*iV$M@r4
z^bd2d)jlBJa>bD3e*9M+ARh_-?RLBhhnr@S%Uzsbyf3-$o8cS&mke^|)5G8hjMp8n
zcFu8T7Wi|umNkpOFc#V~P=A_M1E}%qpKsA7O2y_!sWI}&+}!jHp&h!;(Eya1cU=2{
z(`C8WJXR)z*e9s9z1&P*i;$mTM4+kMuXam+0rkqIYAb%!@-ffCkmb?Qvbh`S+n8%*
z6}rY}q+}gWZ;ay4`DE$h{B9KS;pN80qi`^HE5jx*lkML-ur>8Bb(u;P4mO9mxZsmr
zl`%gV=(HEV9QkD4#7g&~e8N<F`%VPc_~-*HvIG-_u$qJG@`BW#sO_Lmrye9t_DB=@
zts@)@lkSw~QE;Gfy6-a<-+o#4tcDvWhQMp#d&VAiUJ(L`93}nRMUZKd8UGV9Bn<m;
zBzqK^@r#LqevEAfN_B^>99h01KUCtB<u{&_fx-ZaZyPe9tYGdN=B#^apgu}GAFMsU
z#iGOBWRNkSDj8wMAI!$j^_`6)n2jt{x~m+BEN^iq)Cw`FV!`_$`B`gMTVenMX4Nqg
z^hcN$My5)-v)iF8XDU0i?8sC}cRfk@$%Tw|v##PrbLvx10NI1(mp;-<B8LVH=QHdo
z@&11d&vpyXwq!$I_o8(uQ_Rl&5xpjK-vKxi5ApT=lD)VZXw))`Z#Eq3Yyqn#kDEH7
zt$;YZ{01fpzGADrH^gX-25><D=8Nzh(|cjWvcV_Z5zh0)>nBv?&3^>B$@<F3bFwPw
zQ&nZm`^Fcf(#b=Ba4%r#=h2!0BbWr(xvVdC>MVAo)pfI~BrBmCiiNgf_d!i4U8n&&
z5KIcQV%`8%ZU#WjSqS=u@Yy8#RnPxvfZ?C?V)%zt-6vj)l`kZmpmWx~W+*!*Bi6+S
zOCC2EL5f7eJ4nSKOV~s9AkiFy^i2jAZFCmyFhei#v)MKQdbU4;_T~wt1@or@=_-$C
zcRr-Y)3oJBZ(+A!LA?lq)ZF#fyc!@dxi=$x<JU<~JOm+&L(p@8l85%0ZP3w}S9<TB
zAh;uT<pC4+ccG`8^=J&-jDDNwleLMaTY=VN2%<4niUCq3Ftgie>yZh&T3@btrVsq!
z2UNgX`$Bw>*$o>1>{z<jdIy&7;o=$X`+NfZvsKg#vdnd|uch%{$FS}W)5QlWl56<H
zNrZ~kw&8aN)q^;n-e%-w<oWcvYB`NL9jww4(OIAAzn?VwGf7UGzgv3d?_o47s8?cr
zcV{tw{#yOz`pP++uH>SnY_|-^w-5jS!Vhb5D=X)GzRJ5}yTP$m#M_vNoVP@C=X^2d
zHT9-zZN!DwRmj}LpM`XQz4JapUpbP)kF#6KLyh}CPt<@->AywZkLSf4+?>QJtGy#_
zuVZrt&i=M3n?VA(o%I6SrgR&*k0^dNR!iQuB?&&6hmSJb%mA9Ps?1}c3_N(*<iD|K
zVwjaH`=y(K|IF#>XZe^g)j!|oW5Rs&KeU>qmg-Y~CixKg(h%+c7k;brxkLG_=s||Y
z^4%Y^>I?LM%+j*|M2P`$5<{evBVqg{#Jp#YGfHFj=vM8j?YcWGKJFVC$@N9)msZyh
zvEc2*;N+HW$HXhd7u)do`)vBhZh<04q*KZLgX8(h{lns6w*>dma;~0@*p&F|<n-TI
zhD`ZtXIp%{DS0|2n_pOXvaDSRDfETa$$f*dJ=!-cK7!(r?MsfNieW57$$g>3Tcwfh
z2~S%q4xW4U2grN6zs!=>9Ulb@j&+IEyZ9(~LC)AMk&%f(>2M@}RXlfcWPM_fkwCFD
zncnS;iafpe$d*f1WxJV^ozhRauNirI$%pOPKZYDLOg=Tke#i0y#VJMcn;F@>c(jTi
z6M3a!lsh-)pVz?BIyWcXbqGC}_|WF|1!Mb;0mC<qGrstE_{9MCh{?_oY_?Hm$1A1O
zy)e0VaC{1G*5jo(OOH>I6XeOsy~E?Dvae9sH3H*I$Ddr{DGvLHP^mgbPIE@G036A>
zK_e-c$S=^Y2yB6d<*v26I7J?f5y9+*koW8)e-Kaa*S<#_&Quw0)>)`g{Pw~dc<8Jm
zej$=Hm5)<QpT)<I-C_6_X<DDNZ!g0?*b7p8<VB8Ol2Y2t9DgH58m_kjSNsyVP?cN3
ztH)ma6shE1h~pH<_+_4petyBxxIp=sEo^&qw{Ya*yTRX6B=-&^%Jkkr_@KG25Hfhp
zkig4?s@>yf1{i1Is?_vtZOr>V!<um^v;5PK%pHaFU>{9@P#{ZuTps!A;yVS@KBcap
zlsdoBiS8y37OAEq>1_(jY2BLWa+x7l>;f*)bLnXDzRT!8*5yJrF}+QCksQERjTwvI
zYXx-jgK+s5J<>B88+K;IuWp(A8FUa{uCv}`Lq{mQs)Kz+Z7m)sz4r&=tBuG^o2IeV
zy%z?Ds}g5pPdy!i5xv!xQATE5rg9r_Pt%EiFzgbkW<vcgdE@QIsD3A>)Gf(<`PMs6
z3}#U6eUJJzT6tZIt2^Q5hk(8t^@ig9qiKzO*61QU>flLU#~=LA0F)}|;t?<`xoDD)
zOs8SDF*$e3#;D90l+lP54`K{0=VeMHh<T^3G^Me&#gP?=WLkSeYdRBaXO9~gQ0iS!
zs(X~kmo16tmCAigq&ynz9^LW>QS?zgB}Cf?mq_0=`?#JAs?tmde+E!vdTDYW8@eZf
zlO4;l0X{f{eEdo>T8-lplfjPtS05lAH0;)3@x#;bVhAoosIHD_-T-9J_UMa331kof
z@J+H7;fjWjuT%{vV#x&VNBa%60|lQPQtu0abIrYk17KQHF1+d^p8SCmI;v;>x%sy<
zbIwR!mpy#J5CjtL=jNSFfRFBYg%DfiwPt@T;;-|%-{;oGlmhw-iU}}P##Chw(=)9!
za7df@Hk4r4WbFTy%KnE>Wg0R5m)ax8hi|$L45ZgtVl5P<L!v++ixt-&tBBN4XX<O9
zON7JaGOsjkQJ?TqgBY!$Cr&X>_LHHW`$(><lj)L|_)S13DcwaPHAEmb^s!kMNzvV@
z*8utK6G3t6Pol!=F#u&QBp;t3A>>8G)YF1Wz-PGW7vwiMji0UzyD=2@YQ0yxY(q4E
zBN+_Ea*%|dmls<u$?Kk4yxysJG5rf!itHwQS!b1Z-Mc*{W>BIU16(@%<gfh>?@r(B
zZ$N|dMcHG`z8nl0qb&Xg)>)Zzh6PE~@WC&|O}WH(@cz~6J77vLInRN|VT^OI3z<Ql
z{V(DwhQsjqd+tc08P;@Ods6yM<X8MYMm_JpFhS9zQy~tvYXZW9e6$V?(Go;l>|u#h
z(Zg{0c{8ryL>-mh$p}9N{a$)K@~E%O1MDc~nyK9!Hbgs_B~YOCEjBg2gcjUV_&_{i
zru}VO{hdG;Hu^Z*TRhq>Pv7oYo-{-K$*Bvy(3?8m8QL3(b}hlDR40BAir2?*h!E2a
zxTrTLqxj{R*J4d;1dQ&ma~$MoVm}9tWxq#8`sieFs4_COO_Qv~b5O@RBaDh6@ZU`*
zr5~quy1a;hVgx&51)Qt&+iqlN?aNp2SN4qU=9Ur6O))cK-a{|%hxT%v<!h8O)SZ`I
z{Jy*F4|@4g6Mr?5l@IaYENkU2%T#^KGS$UK%DuUfhbq~w_ZaBVBJw2k*=4B&a?!h?
zlgzq)1hf7jLomS_Y00Kvc{xz+SK9V0mVWF|{iCxD#wBIVd-RD~s=POz-Pb*Xn|k6T
z|LEA)-4oP?yAfS8=Y%S~CpI&9?o`EO!UZABax>&V_bZ%o*L1Z^53%+gvvO*PP<?xv
zwm`Jet}>?}{JS$aG{}Eq#b%;jEQ)PynY?x4;Q6l!tEJ*o1CrxII818jg8qiqc@tnP
z)UMB&rt<hb!H6~1L|3i1`3Os0o80Ny*nbTM$ODoSLh&oeQ0tw|@eI!18C8Zi^QC>=
z+&bvG4DRrGhD62bp9Y=2zj0w`tX;h+xbEsf;4s?t=pr+7J#!_}P^S8kl1mBH9nO9?
z!^`24ltZxO_)SVNK?S-9w6y+Z(}3~nd<eV?(MfsXU+-hrD$UYG^m!T)lTZ^>dwV%`
zqG!^!8z1#<i6U?}{RJ7rJ;KH+DrhPFcw%Ti{yT;xjz^v}sfl-It!78HGyS)|0T97Q
zxM>Mx4K$t^?9W65oN&{Ls`B{831hf~jd!mu?>(_nzm3sGo;2+oO*`S{zeDvsZM|dZ
zjrO*s-!)Z#w@=maGhNI&jpYZmhnvo`%j_WRO+yx+HulDyU}e%(KswxXGmo6!0mg5*
z#GnbqFGJvq*HZPP*%Pqg`8K(nt~p%k@TRaZ0-&)wutyP!+jH%pOu*{3)FTo)rHpS?
z-h|B-%`X`!#xIjIh{ZLg*lNF6d-}JEe=|Omcm|~j2yrtegc9gh+0WP>o$2No)$q*>
zgNWgYqtXxi@+1|-yqDWe8>Z3;wo-WW?f{U-T4d!LAWBs01)}ivYWnZeT^q-biYymy
zUZZ9-u-D7?cRPC-Y9Ep>bB?d}qEGMdF5!Mc?~#PALx-DIfFf>WS9CoghAc0b@v#$&
zZM>d|;6W}oC(aBvi6glKS7xjT5l?<(<JlSU0j18!m6?-~6Q9Et1Yu&RI}lxGxaoF-
zy4f!<4YX={XKyjUrnP2W^1uo84t=WMUG0tP`P6hbrF3!d90&4(01pI1x?oUHys4fv
zX9HBXfOXV4Cp{N<UmR|}lBv})Bjg+}o0R4$DT&#<udKqGX9q-&bMBep=5t7Oj!%76
z^RNWn3%BopY-*u+JS^#WXCQ~d0MX5BFPTb18N_dGFA*JLVLWgpa6KNlDg&(69v7n-
z*zG^^DRn7xK@kML#V-N~wEHXKrR$3#b5pX;d;L%QxUi(83fd*<(TO6}@A#zZ{n##^
zsnPaptyljd1zuptO^8b>caun&GvF~jXTVOmneD%&r|sqTn611(*51B-bbI+Jykw-_
zm$=fe`!nX`)p|qyJ{rH(e8zpyIsP4+=`%ElcR#a(@T1+l72x$7?LJ~SYd=C2bLW+?
z+Q-*=(+Aq=Wd-7s=~zJ7BQ0fz#fC2Hq3U-b>NnC|t!-58eS!)$b%Y%y<KGsH-xn*+
zF+p_AICejpqQE+F19U*%H|)}$x)j(o?w^z>Zn-w(oU^hLZBbFYZ^NfgA^CHpCj5p?
zZC(#j8@l{(?yOt8D^t%|T-14E=NlB5qs?b16Z4i_08JH+cG|r^Ma?&+!Bh^K6*Tjr
z+)8if*;?;9oq=4rv?MbF0izGe`~t#gy<5Z1*071(BNSDq7D1)|vR6I<&X^Of_0Ip)
zBIp%J#J7*l(<<)mI@jXC81HHZx0lF)0@D)f2Sf%eA1;Z_UVAN8;Qs>|;{P0X2D0~#
ztsp6Gk}mX<N|uv!ok@!LNxPPibc0DcDJVFfq+3nW2tR3coTN1-DZ@`HY9Q$Wll0z1
z+v1u<B>l=HZ8u4nAsfB4&X;u_ds+{@!|+dVHkkV)is|z5hYvE?_DrY%ONT-<^bJ@x
zwEmvDykDVXmSw{s`XK{bO!GLl=xW}<0<V29Q@5E)<hZIqP(p$@8}R^?brCrDnjCjz
zWLx5h^n}TgeetN9zbdjV{uN|v<ctYfiFZ*sB;ICoG@-08@fupU31vlzzp&e%P&PX8
zXJp$6Wn&V5!XD7)%&BebS<7ico49yE<Uo9y-b!<v!qzFy*?stTFxB}C1K@Th8n@D%
z`1zljD;-1~ce((9I@?~Ft$CmR9d9k!=Q^c$U}(v<W}wsz-St{O;FggRRFqypTdmIm
zF6p>Zi@5)L(0;@}KSia64!k=)n*J6U9nUfBF=Lzy=D4}Hm*M?ljb@6~?@*^7H}_Ee
zq^XaXf;n??`y#cDZ6LiDm1f%?BM#8o8K5hGf<Vx23<cujK)-<j!_Ok_AqQL<zB6uF
ziIb%c*vkWk6gXwSo50m+&l1LMJZqxaX@n9Ux$e*X>|YA4PAeL4uHyo=osn-00~_0q
zfo)IYXTz6A2gPTybst*m{c^9FngKQ&_g@x23NdwHt#@nxFD;j{e!;6&i&^zq{}T_g
ze6Ji~n3d_DS^v}Yz19n5vnbh3_`*UKujXzaa`7SV=b+|hv!9T~!g&^+Q}t8pMUs@m
zu716hl$lRj_lVc~gy}38Wm&8BPX99my4XnS+|P|@-DH8U4>wQXv1MuqAu?uo>oJz8
z(@A8$Bl*|^mv`vxYw0d($J8pii%siiFg$mZPscmLtM<|(VgUyGud#@=>P)rw$m6Cn
zY%2-x7H;~z&Bs)X41&xxknpO<l*rm$u?ycV&JhYpJ_T{?RkfF$gZ!o$;Qa`Bp8XyQ
zj#_Ufc5jk0Y6){X2%U^mdL9)xrBelu6PCfP@w~#;g!A;N!4mwVOu)5~yYRK%bB~!$
zNpPwbJZjXSX^jwLbMy8~ivquodAEs?vs%k#FW+mu8dZ`#+I#JfrUv5_P6dIqw}mv&
zhm(XJ%0G{CU~{T|uBi4thO?Xg|M+QJd@h}{v$RI`VRiPzI<DXn{W;~C{W)cOrZ(bO
zieVaNnkXGDP_~zj(VKL^TQ9o;FKus&dw!Q&!f?-&&klOd$9v~*FH<&bDL#+E8^#P<
z9ozOPd$Q&|V$WUe8Dh`zsp=p1tt@oRLVBj*B*kn%9yv)}3G~ISQ(~UF$gr!uDOUK2
zoU>$?mec73C+#sGu@m}F1i%i6=*`3OFX=-Nvcs}v3Y?iCKXTac-XTyMeK6E?rxd6;
zbBlW2p0(}~kS?TQfb?LW^Fp6rqS40p75Av+S9ofCq{3fPjn4~Gw{WAt>=#Zc!GJM*
z<2EyR7zh%y9@)|iiVvD<!^YFYTJOjVyPR`lemrI;CghfZ=ly^OhyxmE&RvMYJKS`)
z>fqcXyh^okNh;q$MVj%-vdF0Lsz&8tzU1D{e)2sxgkGKaT9rla<U(%~^aWpd*|@DD
zu+b(fTctOxW)wpy*e6uRQ$z}MC!^JlUyeFEGk%R*ImT<Ig7hC5ANjdP(Kr8($R997
z#%1QqCV~bcP191Y6i)<Dz_CHkE+%y!douTYt`LNq74irlbQpIT@x4y3ekDt(<O*hY
zwfC*Rn(0T|y7okMspWPy8x>3h9%P&sFi|TgLqoU@Na?mqAN`JTfeTOlXZYLpfyLhx
z@HZvE-xPzt9}2QP_;Y!qi^NB=k~UMt;4f{{nGar|lrmc~<CPly)is48o*$_$qupK2
z6L>sA7>uEr4X@ILNxS+Uiot9K*%yOoWi`<BrT~GxVNC}!5|B>rpBn@&gb2JRk-*cB
z&l0{3{(7@-f4@Keq^lkHs8m0~--XDr#60bfzrW&NMp%*p>@g;P0R87$d!R4ZH_DRe
zto2$+md>cs`|;cT5ZREEYVh-k%dWP?>7p+D(yH-B5-ij{ztZ_+ZMCyedZK~xLH@at
ziSQi%z`bS+<}P-p|2DSyU#_g=_<QO-rduV67u@R6?z}NrU%F+5PIaMEHrkn2<XkYu
zuO;&Al3y+Qs||eEdmh#^|8;*yHq3z}A~94vfde=l(CT_heBs>Jk{+7W(1O1({65TE
z3L?Az{?yrMn5r-AR^<9zd~U$S&D=$E3SnF^HU3p@PwFV|BDVJSC{MalL>(QC7*QuB
z2c%M4OwM-4H+L^to~rFlVBN%U*sKTcc`H73N=G|ez25=#)EPmh(ImQ)$2g^9(r=k+
zSZGNoQo;*n?Lgc*BSn!6iX4Ow-(FPuEWu(&{F_tb$AH4Vym7(bAu)eFC}Vz=<uCf8
zHO4W@zDPjBz0!1)5=K4>=(YFLmsDABE-2Ar%YF$2yRbAY!6omj%ttIBgQeG3{ME>h
z5&kj;i#f25-4b54L$j^AM^rh{@>7VO#1ittfqlt@v<N4252yfjAeP`{C2Rd(GqLd(
zjc1QHf=OtD`muYaj0^s>(dbLPJFi6sxgd~1*i>p#RC^=UWgIHiN<EJ`ckcK~?`CE=
zy@Q&<hD~$UHVWZgNqdYCRqK7{w}z0}#!k2(FWejps%zgzbx0!@+wVpxqK*+}+M7UH
zA9$4X6-8jtwDR8w&unD+Pw{L9Ao>pMfrI;NhtR(XW2y7sKD5plCi+Bf!gNYz;3}%-
zTYHv~SUNC~r}x;i8Orodggy06tbpd8;HF;srhg`{9Ms~p{w+4|Y0ol3%IG@cpz5Z(
zJRAv1=Ub>cWre*h8fdY_Zh+mTw+CB{bJhO#gWLD*yDhb2?~wR17F`p{PFZvoaCS>B
zVf5!!aXlmEU91)Z$ZGqW`USg0e{z`j`c5!ckNZEvl}*w#lFU}wrfbDB>8F$4dtWh_
zZHKlWQ~PXJXkV(1{_UT7Q2Vc?4{84?k`CAYuSxH_p2|kxF#OP`hsD_g6kk0zIetJw
zHc|bl<E;L;f_p+80ZAAN(TRK6X!hMs*%*$$WzUoTen1!Z?dI)<e*3$BN}t#WcgIu7
za|R@K|J!bq7y9H`#{P?zi$u22tR+&qu^6pY`o}>xiqwrjQ2f8G7p6Zxc(lLi51#P{
zfv3Ds5bEhvAJ7ET$=i+0k-jzP+48q|TmB!-Ut{l=5;3<eeAC2iT6ieFPCuwaQC!WM
zc`Oj2b{Z|`t{{pj-r-%UuKY0Q$|rB~<{onXaTOzKDLo(`N;l{@4D0H}_-n_oPaJS?
zay)1AMTqH`LJVbTsb>8#yf5JViEp<@b)beos>3!IGq#N?`Yc5gTkL$6hrtJt%MH_i
zgpaY;O7dQ5cypE;ee;prSu7f_T)k^Y{j0BB{id6EHGMkrExUR6CY)fS*RQ?y=p$-I
z_9p$B^?PhLkje4c;pS;fdNtob2+c3kI6cFC9bGW}3pag<@4eDwp`W{gpu8F6cB1zN
zhgEm66>)3sb)pZsoYHD#2sd4-bDXo;EqutH*{!%2DcZq3VMrT;NqoDgJ*xcyP`ShY
zbm#}?Q*O=uZpH0dYw}m1<T}Z>yGc+Dat5bf=3zj%sVqo2n+GhZP(4LEy#x__I28wk
zELk1u4=2qRAm)UdUQ?I$4h}cHXdZ?U`<n;1z9T&Vc*@>}o+mz59L)I9ZkY~+W#Wr}
zg<rFWt|$K89Rg0pTKD_{r(&xc-Kv3Jrh^RjhS4>8tI(S{-VQgJurzq8t=W3MQ?YsF
z@D<OmsM$yiA&s+Q_0(`vR0`^vHRk-;I*&BX4W~In2v0_$o5MHBK&G)_V@9}XFO`=#
z(OV5aL0i(Wy3Vaw<6?Dn{+Q6S4!`xAtG(YmY>KNl$M_9Q8&kZQf}3TD5k$rVMB%28
zGE{UVuT}a-bj*<B)|j`-R>I`~@MQ!LYL9NEw--6lXRs1VUybPkQhO*q#Vrx2N+{Y=
z_|=$KZHq=a!Y!{;y|Xb^{2@jO&v0?#MK?Ak^ir+YxX$llBH~7$Dc-5rg3mzEIC^=p
z*89dQMwoD-FH&s*?x4FDUyhYSq@p9?aye^4^p3^JS*zWs0naL9&Ro+Gsaa!VxXa7|
zs8o8#2GtnEXi|Wf_ULB%l#yD@g5%cQ>eOtO(h`mD9gIo9jBeIhg7&mbLqA?%#f?63
z73|dBMxAce$5&Km^bZ1&d=NneZp9y*D3P|hrs6Ff@eM!e-dnG$P`K$C1M9W2!{MMG
zU67%o#z;oE`C%lgmNJ~Hccp&Dqg!!Dq+)aUM#%wg&FyaVeggg7&a8;!gm03c24P7)
z8>b`c8qE)E;8S)&h)MUxybm7Kb~LfJ*7JCB>mSjS+z}6}RK+8e-V3CPkZW3{dA>wC
z5s6@}F|XBrNtKX>DdUTEI<+=7F*8}#uE0xR;vw{Nv`YEZSLhyR4qy)KAeM(V)p|c`
z4T!J#GKua#=a0YtR~z*6Nu**!-K{=D6m0%V^@rtne}LnqIILqBSbD4}6LNIi^I}TX
zO9rmtHcqT6HAAq9-XUCk2?)70cfbX_&%K0Pp;L(FQ6#2H^rf_r3+_@IZCPB29fjVj
zc*peZ4&ZT<qKo=WDfKg+`{ZA;)z|cpJH109snlq6g8w^Xsh8<dpbB~jkg}h95B$Jb
zgq6!5u;Z@3H}xLl>9H@AJfKC5E%!}O$f5e0x86j+)%mWkuTjiNqwozk$#AEaLqE(L
z&DMHf$9mX+*zWh2P{3fg6BUi@cRYW7by+=45#QUR9;GwVSD>MU>;9K}3>0&P4wK=u
z-&4i=2gd(<_P5ZC_gZPX!?fSy%+74^+GsLR+l0}B03T9dJ04GwLE%+ej->a&;wF1F
z)96-i1w9+=sCpxye)tAN8yoFTFBExdQ0~+*l~ry@5!;oQd~L#QtN9M69=2c|7OEJQ
z<xJ#g*YNDc2K0Y^Xn%JMR#5HTV~P~nczGS(liQ$L^I@f}D>Vhu>D4#%c4Q763085z
zPYRxQ&<hxaXv^>DCG*%g1@d#H7T&+Fdrn6BE_E!t{F~H^#lHtxsJL_xU&UKdpo6%8
z%)$~HpqXR|_Ak=^`}A<`Vd-JpuKx6p)k_a%<JY7A(ZWi@wO%CxxuJ*MM*nj|Ko7ft
zA@uMjn+HB~*Ny!qo)WiG4zC_n((JdzYh2yjxY%EY7pYFR`<Kpsl|9S9A%!WLB3_nN
zr9>tyz7DGsHy^H(xEIvFekkhq?gXf^Q;lEiP8);WQE3tXWA?X`T`^ruKR^oZGc@D9
zr~S0sEPwHLCVljS4^Ue_{CU;hNl3y5e}8_2rmz&`Qc176uk~jnRuzgrZ^a+P(Pq<&
z1Tidp0|&0yb2gWV%n&mcKMxgY*30S%jnFx^GpT{(lEi`3*lC;urt@X7#vj?CS3%P8
zFB_r6+Mx$@F$$Jy=wf%wJA+OLTlKqBwa^9eb6YBnmX#enS5VMSF?{dOoG_9r^?kCK
z*ct)n>9FoleEuSJ5Br}N;!~HB5!2<V#vuP}E?-`kbN<59(d!NKw~bS~Bd;tvp(X!l
zKLphCdt35vm=!sF!P~PUb2I0aV<v^A`A+}x-)cqyp59kQx#urTQPH3lQ^o5o`9u3u
z(LUkyx$jJvn>~L36{L5X+kVEV{m}C{q-vrVLSYNaT1uZt?mc?J5R)BCL#~aL{)CkI
ze`{G*VqiRS{#z}}v?t$^+<ScZwzj4FKc*x;{{|B%kEe~Z8z)_oQRPWKm~rWrjWuYo
z<RQjy0iP*F@f;42qyZabn!ydr{$agt8U9uOhWiE2_6w?i%cOIf)cq2EoKw7@HJJ3-
zC|+LWg-`X9aK)8DM{Vy`>t@3G<o;3h;UD-(2kEQS-=z&X1|GP7o4tnNm=#p|XN~Bf
z{Kg;3B$Ita(mM^X4DM--{>@%X`Iz@M@`VbEKB&#lKS{@2TY5ZFXg@Z)&E)@WPyT-J
zn|~6c`ZYuRX(dBEcIo~>r*X_OqGj36=QIIwf|fbbf!oL@%R%tx2Gq)Bjm#!KnSbVc
z|NG_ik7Xk8?@}VZ@F8r}Uc0dUCkf7~F9T4f;#~<(C6=BK^S$V>-$%M7G=q4wa7-wG
z0G;Zssn@@W@gEZ8cS}yGN3!_7kG+4NKXzI@E84%vfAD>hgWr94VBAXoj7Oo5+Dpa*
zUQVtj+MoF9yDNBG*!92q5x3^&s$V_+-s|ldu}w;wo$;i8vfEnplY?_!esYUe=_haX
zM*ZZst=G@j)|j7ywSUlCQAV47Mi)JypTg4~*Uy;MkLl->m??f*Y@Oc5H9o4Jl19^q
z^NN0`w=36tPd`)b+l3jo=q*-svwkk=I${bx)33?X&*l0t(6ox!UVVjs*f_|&;3}4+
z0Y>*TCzJb>ObFD$)0?-<NaVJcU7}H&k36et^9(&47M|gzXO%s66}V~MD0uY%N-zCP
z0ss_gBudxCPXH+UR$zaM?9XWXQ)qw2*q_4!YW%K;1%-*L@6b<)&3O>mzGeXYZ@~tx
z?Q}Exui3j$yn7>HOX7cKzDwBtH{<;e2*Y-<hcI}BFl^%geZ2k2#MUx37_X`NpOeW!
z<NezA`i<8=4?zRjz$&Oc&?GImW#eMr5m93W&%7VVCN?`hHdb5b&O`TlBH@dyf|-0s
z2Z3mJ>SKF)gbB0%b_mAPklQE6V~fZE<LsqZ?kD-$Pv2L<ym1ncFF=Fx%etWb1@0{c
z;0&SYEAA~)f?&THkIJLhV(kf*DrGU->?`P%5pHx%DfQ(ixG+&YnuYx-qzZWs$;eo8
z#w;f`zNeDJW0a7@RdR~yr71US9i5c(0gi)}uyGa~1ie?&>VDOqOSYi&Y3Vlmm~Qn;
zKB4l^lN}!t2C6yk_N*k;oi`5ggjVrSKRp;?+$ByDL)>!65U<w|jr&y%@$!CsxZv@_
z4DqyoKg8st43YJ?-}r9mKfWu-(>p$HQ3+7#$NG)Wp5I9tug~RJqxD6NIx*gfUBW%b
z>RKD$D5IJiQ2ZCFnv)gWm&ow8Hb{hv`CYKJCR=3)*PVDG?OA>B|Ed1We)V7TpVV(p
zAN}3Lj`*zPV`c=XEFUvHiB~WVr}`4ErP|9KF*}s3syQL{O*YLNKvV8-v_)h<egv-e
zvMU7(wCY3Jld6=j0lXDY=y3Jf>ey{OvdF+D{oJAQm7TB7bL^ObI_BnWxcz8U1Bd|^
z>lV6>ECw%KXcn}11@~q<b1G}iMI3H`uq@aSWLCM=*UZUg5IR&Xqd~vN1}E0}$7&x6
ziTl%?1|M$8qV(EWthc(LE>#r#=k2-P_P*7(cg(i_W>~|}&9N8n+rRp;ZI$X24s459
zluW1mnoNSJG!xHE0=IhlLn>#<QcdkigCkgXFNEp6S;;ItslRJ<dSWXNdU#09!3S@G
z-*unLnZE|!g+$zFjDtb#dY(pmr6uBd-nsVbEY}Bj`8E8V>X;vyzUk1L8+;s=J+9>j
zCpxouZJ&~jIyIwxO3u(#Rj8-g7gfi+zud#QqPd9%y-&fg`ySQ!xZwv_cOfljxMw!L
zi$B~w@uTj#1APJ@lqHtzw7a*m#bK8g?Bb|0`N^P_xdls3+_QWR6@|jhZ&E|@ldL5p
z8uxuZes$x%FUDs#?wc5H8l!d^I*q+;e5kP$3*T^`$vh!^lVYzaTeJLSQElU*tk4PJ
zrZag<eiB-IqS?Etcz#5Nae3C#41;bg&GN`JIr2(kmmQ+JTusHi%PuuLvUJ?XPdQR4
z*Be!TNg=oLVbJK>ch7RBj86?#YRzsth>}_DrSM=><;XEk={OU&4SPJA`Y9<XZ9U0c
zncQ$nHEuWA`mWtcd_x1&P3Mg|g<Sz^F!07Hu)#p7!9cjln3!{0qI67ZB^3eGITQOD
zKBAl1ojO^<QviVGV%jnnj@C_vWSuVWDCB<%`i9A%qupLLP5l?;xGet_vekN{{_+pA
z8;z0ZZ%caU%dUY^0}<kFhur^+1I6dN*Kk~HuYa<>WyMRJeY*10;eC@9$uLGsrIza7
za5;_#Q36-A5!73zgq+8+fw_~+;cq}3OBb7A<3`g}GAHN81F~B?rltH8h&zIh^CTbK
zTU55CG(>Q}rb&9tJ$vcC#@lYsm_KY!QdE@_Zjvnw_ZhmnDRqN3mab`wgBZNGM0bZ*
zyhU21V%L(>fqdu%(1HO6P4#sg#xznvLi?7Fac)tcY}0P}n9v3(PCZchHm4G9(u`(5
zL&VvJGV5L5BvPXc?mcH8fSHE&(%jx@kZ58dP@3<=a-A5U!3d&AkTLx<;T>%gwch9B
z{z9CXPeFH~u`QCJm1fyRV=BG7erS}oj_F2ANl?c<WLdWm`~qQX(wZ8CLUf%_o=&g3
zL_fRDJde3aI|rt4kjyAx*OTm6Q}R@2N-zNFaZ}eaA{wspj=c-cU`9#_KondTxZ3Yo
z`IwmZ@tXd5Qii~c{L&+T7+a3w#_?Z>pQ5X3)j3t(>g&violUyCDH{3?QNc{VFmd(o
zcZ<9v@LhSmpEvzNuXr`;S9=cQ-@x$8Q>0JX6K`;5p64ze2SI;{W80Gmu<11Ha!d2v
zX@uL9Wrr?ecVPyNX+y2|lNZeVaLZ@6FBc&I1JU>?R>gKAwp6?w?@m93`ab8*yt1+`
z)>3{|%=_XKpLCyK?kvx|5}*-Z@+fnyG@$wZ@}@8Es(<088%29`uv;!a&I2R3BJAJ#
zsqRdf!JK4UALULxg<VwvtylT2|NQaZ)>rpYtbLtMtY*aSsx}cdgPxIF+~Guw2g*WR
zQED0W9(>-688dHR-t-sVgZRT$&L*ekey8Hzv4pMD4KtiQl_NybEAT(nB4>lUd=X7?
z_9dQrt6D87um+#zgS&hoX;a;XTR(No<JdNta@^`x+{zBlEY0QPaEwW%&g3F@xt1-b
z(lF>MzS5xEaKCdc&S_53HPO`9NW?Ksskwkpt<H4?PF*360<=(VIcTA(xs@Q4P?uH8
zH@{;5UxX&LSqEp06Eeb0XQ>g4(_Sft$>qRS7jyJX1B~YdJAvav(WIG4j7M0vR(>vr
zgD}Wqs38)9K~u+`<@xkHC(+=y^)wA67k@1iePhMFkyYdQ7;buwM3$yo1xE|UqSc>R
z@((v@;gyA9MNaW2xKyw7#@)db<0LHl5EBBJ8@l_>%_>mjMjxUB_U_R`y|+gK>NEO?
zaPt=+=G6K83B-YLv$=W`y&s8~J|NjVH`n43j2IM}nAEHucbe7Xjb|;T+~+RW1_)Zc
zvv)Yn<`k^q{>F3vJKTICtu!tPT^VjZ);uXR_K|A2At%OowBM@szVW}Zhn~Z6+Cwof
zK^#ys^YOW6FwM|!b!#3%-ZCR?{+<C%O11O{n%mF=w4t_%UZ8dV=rBNg*D*j#1+2B<
z{yOh03te$IPP8F25m>nSZq_*Z;Y>Xxb)R{>pKpk;fGYmo092{1a6*wwNAXtX1BYj3
zPLyq7J#4sDRbr{<Ov!~_pQaMXi5elE$yy35?WRS$b$M<T@wvHMN3QgCD$yj;nIl_6
zJ(@E|T_FfJp9OhLsLu&6pKj@-@!XT*Bb>b@=}-v=x=p2|HjY0j@qxR1FPH-CC9)bY
zFEPc<EZ%G6&5#(t1JC0Y;x^@jl%|0V$GoUTg(d*}oT$6Yzeb%(yGdy^%!zyFoDL}x
z?T|xHZ@}y9<`!S2(Qb4aINyuU(Xxf9!9_Xk%U4r|;)cxdRaED_bgjXG>=+(5ALE1C
z%gt^jQh$4Vc%=URxPlS)`u}ii*0PBnY3uY!oHVspqeDEkH1o=Sl)*70aUQU=XILi?
zS@z1*i#k`tuA?TW`02X3>MC#N?Z)b!F^dVQygwBgbb13UA+c3;bAd%u@m9BXT%9FI
z<@J{Kty}l*IP86NEmLLPvEoZzay?M(J*}%GoB$MqNcOvdyfqO*!8H{}lx~!Wkc6>(
z#*L2QbXz71HAQa4XeZhxzXA9HPH@!0dH0h7|K~M3I0>)laI40-*UnZX@NT^H;>9X<
zny6=TwlciP<M*RG!_E7FJ1m>*j@dm_?2^QFrfR|GbVbLf?xWf^I7{{QVwA_`)!#ep
zf;&?ZTS!N&7#_`EBeJbRg2hp&JIS!x?s!44Cosp?^}FnzfbnVwtHsSg-xsV3xG)g3
z!#6Fb8m?!|awd=W*BiDG8s_`@5PgQnRc}+6Uie3!$@NzSr@Iw@NMFtQ2F%yLe_D#%
zX~XrprDpQnMsLk(ZT$$iGp=N(htCD<F<#_hm+1EoF>muK0`gUKKqL*Eg%&xNUa31E
z(Pzq%n{qhD#$!OZ=?e9N5HrUkG~kz!9r7|vnMHrtUc{e6N>tllHhuLROb@U+i4Tp`
zznCCU^)6@OXk+G5q)g($w3PmllIG4vN{KC9C!3{l!~gtX;ymZ2>gwdCtK4bqnZ2v)
z4R@2jvsJ$^Fu{e-m0avD$w6MZ>FbIlNXOfa3xG2z@65Q8PW7^Wx)E;vL`;OnmYIDZ
zU3imz!iMo`;V!cx;gf+#7;gHra#wV4ab#m(qG=ZQ5;|9yTCla3OBRuw3|<JDCxea-
z_flB<w|?t0$6X*7dTUm&K8mi(JkN-!<|f%Ux^$ik7M$x&OFd(FXh-|9K<olhh-CN!
zD}+0lOH9CX6qc$O!C)k$c$|`HcVS+$yUyG6plQ%eJP9;EM@xGewE|}+u=U#P);w9f
z&5>ckR)m5h=#q;}LBAEn%8hOYLaV;3_Uqel20NN+%kpCG^|^Ie0Arl69}`YMN)WXC
z35m_&rgCL9fyV#hUQZCj#Ipj*Y6BG9s8Fh^(rvU*{q{w^pdFuHSLa@kSII@e>f9=c
z6dm4Ow&L_p#fvND&F={U=>{bAMbnS5TVl8bC{z644(}QY^xPCBUuw1%ybH3;s;&Xu
zrvX*$aw>CD-+&*fUg5afo8?!$A@u=U0}D9p!+vI(GaE@jX?2V#-QzVY4s!3p(UOmh
zr<18;gvh&PYGD`0ALw!6Y04l^C(?1KxsFG7i3JXUCcNh`tRRK1>Og~ksc(?eXstxR
z-noH8m0iA97F-<ROs_+<?|tK^ws-%a2*Za|jTJ|SDcO7ut82|JYG!RM9UX2S2Ud_&
z3Lr4$^>%Y3+k6c-uN4;vkls908I?uONFKL>t7c_ABx;-%HQhsgSvfsgXe(Q{MF~Q{
zP1pqp?(%=<^D8?Tx_lkxdEwsiWQpS8T9eJHh8Y}CZJ(S=O&O`L@~qX(d*T+!C&4Ik
z!p&Gibf>oQ8IztDYYjA*Qs)DWTPFnrX1M0wn7T+OOX#HOp*r|CMG2yVC#i$M{>$!%
z2o{FiTC>%u5La#bI{2Xv_%omn*l<w_p!lp+8FrDuog#+S{JzcW)<44(YQG^^&57(@
zH?9g(kyy(VHbI$l{WZNK`9!d$PcfsXXG~uBpzOzNolQGcz4bA06lR$OcfWWX^|32_
zV4|G_xRDAsUBowc$~e2_x=`y$8QTHlk_VM}#fyYf-T(h+dl&Gis;mD$69xznoFGwA
zqsEFAkSbW(5{a4%2^0h;1QNWUwzV{GYFjTeh$0ZojB+@R(pFpA*IulBTU%}Q?JF%%
zR4$f)T8&B-6%|`A=Qvd34H2#Rf4+O4Gcy6&_wsxG_?S6opM6<-?X}n5d#$zCS{{sa
z;zT}HZ6SmlOQ2<uW+(P+m?4%Ps>Shq`9Avty=C9qLgjJqmtV^@i8C8r(t&Z9zNf~i
zgchR2ahf(5QPE%T^EI{rZsN_I&VJ5i<pHuLiAzs0i_$nfUc})oaEvj<EJ{ZyRfjlk
z4(YKKPbabTDs}V*vs;_-XpLi@tScZ!Il`9d%4cAN-_LK;b~)xnNV-mCW%Z{8js6%A
z>%V1I4kP#+Zgxn!f_;-SPZVd9+>0);IA92IfQOfnyD}<Q&SH2G%ODH+VI9_GmK{Y~
zj_Bq2<Q|Zt-C8~^Tz)uK_kgr+9KPJQDR8v3T@ZIN4LWcJk^UisD!lfzwL!=D^SU9N
zwy6a|PO^LLW%{u01kFK*Z7cD|tznd*p8XnDr{o%~NAoOjK#a8=mXfnq7Ld7!x{{Wi
zz3U#NcJCQqe2RX+M_{SOg}WK_SX%d_463LDzYYOUN&VeUVc=`=KD=2~2eb`lRn74f
z3&?v6l-@CMVJtm@G+e@bBbJt%vyO$um)hz(7WVrl8#QX|SQx!BmhLf6{lU&_JVB0b
z(oETxK?weUlNHeYx<~0?v$GfZf79Bs2Kvx!@3gt!FJ%#6vo(mUoVpD8Zl4tp`eXG{
zsO$tKp^pk~pBRvF{wSg)c!LNQcPk=Rj9`qk;Uw%rp%muSoSnF}En$IU=G$rSrmgg$
z5_&O++8%Dt4dbU0Lo$nZ<YkkSl8?qxJ1k;@$O^#VZy{yno*T^3IhM}wW~O2+t^0DF
zOE1R1_Ch7j=x%Oqdzd~qd7t3+!eTu2G?^GPE=ok=-lrck^HU>nEa>OH#-lBw@QX^2
zbyszonc*uk7u$>$?6|hiT6;GY#@CIZ7H6+F09z~fhDtC=?Ojt0+g4?J8IZ0ULS2gQ
zYkY3lK^c8~o;UwOEy*(;Z5DHcnGLl|EM7@urNt5OX;w2MvT&{_C*eJ(B|P@6=S%iA
zU=gvT)MvtHw`lP*Ov+5^PnH_c)tYQ-np#2*?4`aLen~Y8s)k2f3?DG8`Gae0kE{5i
z*|vS{LiJWuV3rPgTyD+3{8w3l!0@_u+7IdL7R{0GVv?m%N>hiW;(0(|skqrZiHfzi
zwN!kTc@h;%S|3tza-3yy0f)0|m^fTZtM~0E;c!0@hjX?}*FM}l8!}!^BFkNid(nhu
zZ%}PGxG7ika88?eX@?$Lv5JhPlI9U}s#vOBkLMw;V+XIti*y2*0iSCUqnzdIuBYMa
ztfV@+#qHTGkB^OH5LufEVDW9~zH_;7s*~kKm-xHDnjwBo6UOVR2`%n9B~4k~*=zAe
zoMupGEL>B=wMR22>6hpf-<!QVBNnws2~mdg9}GQLa85@FWWG-oddw3t#PsVBiD6`n
zW2wdwcykjR6XWd#lk7_t(iX21feqtn)`!mtpyaVyPa%p&<LfQ~v?gco+S%ePKj6j%
zISr`)Kqe|GxKnhgylW>|O4=S@_Z5xYUa#F|_u&h@#&R`vg!-j>Oc=HE*woV214X&5
zQ7e$MzLj+sIW<CiYnyW@kK}x+PtLuJMzHb9>+j9}2FaQ<z@h|sm(+ld*A`<AH$cp?
zdxG9(O~8CuX|vj3kwfhEHFYlQr&+2v5wW-rS}*5?KQ(${TOR+PcZ%jJorYBc^JT+T
zIdM}t)0%~x%PVg3HVJe;)?!QxKh&W&f1ZJ-R#=<K!}7=9O{!<ks`*acL>)|5;jfGK
ze-+b_N0%62p2uM#&3yolJU0tUP`-*I&uy*VQ$IGdKw^Z;a6TVP4^ankH)VF`DP6>X
z2)O<snbc1?NgYaLRx{vT4R-^YA;J5oGt=+@0$YK6<ydef`>N!Z{6A5f#MXE-wkz{@
zmj<jhIoxfT2=?Ulde3#{n8iBLIMIl`+{Ws-#TiG4xcA~$O`F=3-4!%>2fyxukwVo;
znhF<=12qKhnFs}bhaJ3HGuyUL<r@517WpgpR_7_i*tm|<7bXXHT*Eq=A_%o+kd7TC
z-l5jE6U~A<y|i<)tSO_|GO#UTl(e*!<xknM)a4dGBp-b10#@2ji@QrEw#pB!cj6-k
z+vcK0D$7D_Bm13$2*+4zHabsb4-vjFP*B^rxt)c4-kY~1+?>8vwfL4;su=p8v;@tS
zT;v0Keo-{KATx7+?#>+N>|@kQyfdx&XqL!xcSn+AN&C4O%>cy<$KlWJ-}1u>YRyV?
zs-_W^G<!fAp6Bs?PHfx~cP=q4k|%<f<H6%Gpc7QaQtL!F`yuT$TIu0`XieCID9guN
z1jtJNmQBe|8zcV2arWxLyxTN$hzQW+?H*T{k6J)Q30|+#QVcNCp8`Q79nJ19Inb?V
z_9S8^X6UN8_tWD7lGYX~r3kf!(AQKd^<8ms2m#)Hf<>Vn{c<j02EBk)Y4nqS^CPOF
zW}M31sB+h|aav6+<55=)jepR96tzhM?cn82s2iJVNpbU}JTC4H|BA(P!@X5K$!!Or
z_l09yy*D}Ent7Z2rJ?9pY6}%Js&VhBw8Y(QPl#Q5dw5~vaqdM(lHcH2^RnSix8Y8K
z`fI_05*AP!^k_*emYT?m^Gx;-b^@JUATgHuG$~>ncT&x}i$Y3!NmPVXJGVvm#eiqA
ze!7cSwR#U%?dd)D!uBGhJ9B#0mN#PZ5S$-Nyx;D$?7i9GUSrpHb}-6z$NV2J!id8F
zEe)#z(ZLtQ^5-(4W9beaeY0JY@ETFVWt#HoTeZEgq67};p(ufw9*k2u!K2+3(3TY?
zTnJTrsTas%tiVH2!ZdQuUuhUYx|$*FxJDc5)6A2$BBRWcHq^)RWM-B~y2SGlJb`e3
zAjy<hsXqX1$2BS?Sx3h;Ds_i?@LT?v9;@KJFOVX~$#6=45??Gkp5^`F7DKrHw*U!Y
zxsSsweFNLGynheAas98?dAhY#qP_DlO!B_-MMEn_w3iZ7WTqJb<*brfE#7@I%-7?&
zl|neCOS(EFAe4a5Z&btkF@hQh^fb$B?JnaJGQsC5Q{*3QQ0g|^yLLOox9%v>R1LI^
z=w7`V6O6gG-@Ic3s#39(iA-xPDb1w}VNl9GBG?4<>QARg4m;nW9wFvaG$+HZoIjY*
z|M$hN6lKYa-4@gw$l;7Ob)Y-98n$q)+sHJ9JIqAPwB%@Gp~FHc(m4bMOpbwWb2Y`j
z?0!$G1fGW33I@A#&xWlLA@b}%XKeMQKd_&_V^1)y^re9=$)6gaRyu)iF*TfcbywpE
zgR3O3X1b2V*^g#reRVbyXh!?k(*e=vT@!Wd4A_p?(Lk+c`0GS&fpu&L)w$noBh87=
zjiuJ;wQ(xlSrVF?S+iMTwZ0sE(rK1&ZgIpPW2qY`KsEd=vepj8s7PuqVAaA7!BpEg
z*OljS<5ZUN7|aXa#%dQ=6pf?YP9u=qK-9D=r3iOS>&fek{3MpTihg3Ft(G*-rppm-
zk~)o3wSvir17Krmq{7T|g6yrE2&0fm<6X}|S&h{KEPIPJD4?{{7?(deGqJK6JAu8L
zYxi0lmiT{zp;&vmz@7=iA<kXpGWnbV@9S~rAeBK~-?@W|G4@YfqadZ9;<|`hlE;u8
z@SC-3fMOj;wa&;M+@X2KuBj*9)ZVWZ$gyWMSKBI$7xE=;V+|B{l3j)>t?cMarr(M4
zT3fNx;;zsSk1<d?jWr=dQ<dDPGgZn8bk!e(TT^B7H|}?X1NIXpsOux{)Y+^W4>^l5
zxhahUUUszGc^?pFf9!UetQ!))Fj;?Uv;M$lO_7y5QF+T$eA=^r2=zl2KSWKFNvzQi
zfg%DI#!`~4<<Mjm8$#8m_ea%Up-NI$BW=Is83vO2Lv&$BD{TEa-!*mus(DEbBJEST
zze2A@1=M2nD3)4W^2jCwlzSIf?2ozmD+}tEiO0O(=TZ0b96q{TV~+^&=Bym=hlnt$
z`#ROPwh4_AZt6d4HW+FDdZD@F;j^uM-whVke!Ivyz;-P4O}+IKZC|1%4G=e-dHm;?
zFXUG_`wUB*?i@lS#8UE2YB&*2QF(N>4(bkcP1lDcOGJS_B)j&~Db^~dXWhS1#Ee5J
zR~_l9(W>^$YC<V6ju=6Qw~HmQ!AZ<_TXZxT<t~w*f#W5e(DBupn^;o!R#oQ>K0=!9
zQ|I|(5p!%Z8^g-%uh)(Pj68K1WChyR?6>pumPDS)zM)J}s>A-a7|y2tx?wK^TW5MY
z(wQMg6MRJ3smb|s+R0DOPyI#fa}KWN)+TqF`uc{ka!_AeY+uLPzMe>5>G`pJ`-`(p
zZ#inN(7fh={;J;d)Zg#edb0#9Gb>p3_QLsO?(4Cs+LK7IFy!RiiTNBkBui@bes_i8
zpzw?H5nDFLTU)%|-*6J_3c8LUD5uDVLB&#s!iO~C7p#p=mE=Hd2}h%ltoP~d+{1N~
zl`Y=b)6HTNg3W!9^5Vo#SdG^11Y7ZS6|Bal5E{jwQc66WW$7BI)$mL3=gzA%<brBs
zMg_aQ5iq=RGXpVBLo<YWn)P40Fz=h#Hn=|)hv<BWZ5WY5EiORz=iQmeNfM{po1>$0
zgmo;i$QE41&ti|8L$qC=EbHvM3)If^WB>%V{3bK(p#Yu{01U7d)I0*<_6K;ZKaCp9
z{RcK3z{mZd5}4sUzx|$l+{Y}qA7tiZ#rWrCZH)JgJ&8$nL?|@dF7jLs7!^q%+Tq0Y
z_518XxS2_Fs3owY%{c>`R`3Ftf#1i_{*%K7{+4tSN&eOE5bETNYxaMI)oe)oFkfh8
z=L4GUh$3Y_WE$L;&zZbgv{f^TPcTV<c`^Sjapc+>LndG2V?ZXoPnZF>g+xB)l56Lp
zamBH;WNPm9Ye>bK(a6!UkaO#6Q2Va>*vQhgK5OHsU1$$VzW>aiB3guKsI04gvTBoR
zP68KO4Jxo2LUV6$>RIAPi97bNC?hYeMqYY(K>M-O^V<5?Pwm_qA)^UU6m+P$nGOx5
zLmV6k+9I8vl$=HWcPX(pMc>S7<Mc>v(dwN*-;6h@u0}0FMgDbUEAaO+o)fAzCN-`s
zaOIwW-AJOwtSx16FM7C8gBN{ByoJuqj+%MI0sMJ$Cdun1G&tOmxX4}`a<4aQ@0!q!
zO32@gKdHs#T0nmT)Eq1a?Zpe89_!nL3}f&tD&VYWQXxusogU3na+RKHAQpB^dYn<#
z0_SNCWLVm6;Il&?8p_yMXkKc4{l>|R30}eQ@q{}Q3@Pfl<?)JJKTd|Wo!ZID2(f+y
zJD{%m5yBJRI?DOU82~%=Y>chK8^19oNBvmDHpB`Yskf%47W_XQipZ#bB!kkqa74e@
z&GNZ#B8Xw?A(-$v(^$a+KA$Dj=Eu}Te~?R~!UABRZuVx*HaoV?MWZ51jtKb=`us9O
za7teKrY3m($hh~j-@cD0gGJ*47JwqbZ6@$4u3L6F^`l%a?beTV8$960Zdq*2bQcak
z#_k#!ZQ^Tja$P&p%mU`0(G*M{5xAG84212Nc)j`Y?UclcvTxW)oz_t``vPPfr8nH)
zpJ#3kH+!9Ht*!I>d}sUmGw9QM>v3qiVdp;s(n4t4%&stO;78#WC+h#9Fa0va5U_Tx
zIILj|p)L8nHHVrbDI51LkL5%m+|i#|3HJ@}DJf7a@{ZYPV=6{^d#{2>E;LiBek`L?
z)G8wtJE_N>WGexe;`1Dcl7AG%_pDn(kIa_hNcHN%lI%8J(1hOcX7?C&WzJJob>)jc
z!|B3pMrBlziPp#s>e*#c)_G?_8BYq(TI19ch&()$L~GpX6&rW;V;V9FatG{e5>;*O
zW#FE}#T{de9d+{vVm$THFPAz`BM!y*>v1!}n#@a1nAC4cE%!ktC^X@<o1!&}n*s24
zFmvZ0{POBp(}h$GJCe#g<!|CFlznjHuBd_p9sten-RV)nYDBg<)1%oR>_6YdIap8#
zaZ*(uU5rPqC{jUZQ_aS|MxFX-<Y9)7VAq_j>q?y~2nro_t|^%s!nSc&fAJyAE)Hmw
zdCYB`QnAsJ?5_+zGxw`tOP{gwzjF7pkZ0c&li_Z5-pvVQkUl*VU_8g4L`g(m=61&n
zFa7+IQ{5VD!d^k(j|aYmILUcs{I<?bCD}vWV&~~h^`C_+-f^;YrY<@7Y}nn}(yARx
zrs@eVaJA)5`3^#`<002MyPGlZ!Iqw2ht3ls9~*Id{5H6-;-b9b94@Q=*#o2bkKnxp
z9n!hwu-d>cG*R5>+JkZpJ*^Ze2Dq;)cczsV`eTAr%$2h_+RV*%>&mL?DiU#uMW;G-
z*j<-6k4#@U!M&o~o%~{SQeD}SQO<cKOHRm?{u!}MZ<gfoCV5!zw31H0L^%dbM`M?K
z%{>&M-fwlWectA-IwmIBe>umrhwOyb%4Hu=7u{1ctR^|w<bGQl39X?;x&1^z{=-dv
z?L-f8XHh}&ogiz$wN^VmW~n0J>*J`54fTSzMiu<KLWDfOq>?)idx|2-lblWCw`GUY
z>&{JOox5<Olq}cqyjk_q;$r6|cL6J2@=w`y3WVBwzO&b?T6QAj<t1$MN)TL^5J8fy
z%Dl~gocX2oMflvLhuEt}t2QqwM#%Gg;;$Hnknh#(vm(5Fd9$BN4xpplKell^-vuX;
z<RE4Q5be&RByW$X^Cla{LxY_$%qN@-?v<6{c6m?o#O#Y2{ly++IM5-Wr-!kWdp^@h
z$M<dIg$rH_xfjmk1`kYqjVno%TU#Q+-Cg?bU11LDfWyd)ryRBOV$ZoM%ITZ?Ng{D{
zuZA~FDYI{8)Fnt<00N2kY&ObN7wG!Ms<i*aHRxA9mITZg0@#Hl?9YDsBO>NOug;d{
zrTrgJQ<NY7e0zD03jz8R(z?{XEFkTV1+LFMV|ZT=a|V`?vIY~5k!}x%y{U|ICCnc|
zil~?Rg8hqiE&f^`d71nH8nxUJ@%GC0-ezy&-TjJKCvxn=UN5s`6Y>wm8)61O#`u;N
zx-h1x5YeCkCPRN-!hNwiAYY2cJ-+80B|dmwl))S89;=x2i9;-ZuW?JaKxBKtsZ(1a
zN0r^qRU<-NG7Z(Y?CS^kV>?^$+~>@=7l0tDHJYtBFA579N?iClq#F1?>s(yIwf=^`
zAxXQX;jO8G)1j`04XR%Tx>rU!7XPg%F|1?pTSbacOT~!FncD6Wg7hTMWD|8~Bsqe5
ziW5Wb97x2UD|OmC#+_bP>r5|mkA}L}xykhq&&?8f`H~XQxR^usxz0ruy~*v;vMd;|
zr*T+KVk=TTtZo74rZ?2cbi_Lk8CYiAnLUwXUo4g4=+?RS6668O(C|==)9?^K@&<O(
zdL=cMohZ9!wtC1UBz5I`b2+Q4TU`uOf7G2_9Gx`h&ZV23y@Z2+b|PEd5(g8<mm^pK
z^JOs#ti*pv&4>c0rqm%a+Kio(8ZZ=F1n_i~#)p{3cM2Q-sWvc012<q%{$X$3FmY1?
zYmfUFb@bjl-8uKIh@4)WY(PxY<Zbv$u<OS%ch0?4b9Tg1_tQn4Cw8zeyFL6IOaFpo
zcV-!Lec8*lOI!u<x*8r8Mwq~~m*#RaBm5{WF*+Lrk6h|dgdIkOzmw;#dOL0E?PRVu
zlX-sUlCq+hbAj?I=B?eIPmQG(s5iJhFS?U}=?a(2YV{=7lOE<y2HBi3D$%eWtgrWv
z<=N6JFo6(Y!o62_=U<EAD|4uG42b|~Lc|nyBp?7fgZ{-wPmdA_lkz*!snB+v(~Q6D
zs0L*_+AZ8r?P=H^b*GkMsV8YUBsVZoX(IXTqyauglEV}T-dL~Pi5t8$*{Wus@4Jxi
zqRm+93X(cMyd;+XH&rob`-6fPNP#oJ+mA>I0Nc}eD3>SCA}7+IA@1T0I(v^(!FpuV
z75<5O6n~ASuQ88z8f<^l<R}TK4TpZ$mhG)NyX@oGjhDj~A-5Khn>%A`1be`Tx*EF8
zIMVS~{F_vC#s&y)f`X|}FI)Ckjd+MCc+8AD{XxQg(VYlEF5)Tp=C7h|3S?R%wT#oJ
zJ`jnni6r8C8eXYP{;m-1ARCnXn+(Vp2Zq`{GpTj|0n<s5;l0@R9fiq)VO@|Gw^-D2
zBhj>jxy7BN2G75mB6d0`sJn2q%n$*a^S*PT+|Greng|0=XEbhAzJ~1t-C=Lsu)%jt
z{iTGkW^NrRdMNT2Q9FZ~UV~D_KSdd)ml<gfy~J42^fH!e;sX>=8B0y!$)BWr#-=QF
zgn6WIiCf*p_rgiz@mAs&UTpi-Me{VCMsq~}KBO&w00o$#t=_RVj}X)<SZ3T?H3MUG
zscM8Cd<=OXT@*~>So$87J(YY1><8puXa*dtggI3-&u^8ACbxcY9S5{<8=(~6u4FrZ
zp8t7e2>18)n=LO|o#!9Xr@WQVNO;IDY+Dd1<#~4Vij?vczlO_ul!S_Q+aI$o6O@~f
zAzcl-lor5KHDlM}O6dkTYRub}iJqUSzOM7Ek_9NTcQMs>@%`FeY(Wg)W=AB~kHO+^
zlAx4ujj{K|2jUK@o1>EP&aiGJMa2hZ8?ZEQZmQ;SDlI}sndl}LbBd^gwea+E|1wai
zV#IW{w}cy2D$Y(ZmimT<V~Ru;zcD_+6S&@^ZQg$b8r*5+=05QJl_pOt^&=3^YP1X%
zXM9^4JrfSAtoCK^VX>6lkl~UlmO4*0FEBD#X<rNgZ@K40k=PmD{WrtAqq+8;3V{0o
zO&H)38?Eu)Is@4A^FqLW-FX%q>37P8(f!-gGQ@E_gWD+@->K#Pze9Au8vwYSH+j@b
zJz^dJaFclez_mOC0RC2wtx+MwFz}frD~j<Zn*JW?+%81^AGVH_s`6Sq9uk7eWe6zB
zfQv~o82~vulP<$TXN7em1rO^zlQc~0W_kVd^_q2{#TfMeK400}kQAzMbg6M~#|7aO
zNh!XFZ|;eypOM6Hx&6Xr{$Xe$=xzE1zB6P}Au{J4=Z$T{;l?!4&Ie;X981aHl01+m
z&B!ztj!b*lTH-1HcHq?jBB)cv7E@AD=X!K0F9uVe4U5H6bCtnj>OHy<P@G|l)`a*A
zWH5vK$@#gSouER@8|d~4_%N+9R5CPWsKP;AqYomsd&~p<l^v^pJAZ=dg^(~4{UUSD
z9cX0S-!T~(4f*>AF<>P<fl8TUoG;8#C_e$Af6<bW<0@m6GI-XzR7Ec`f#^n3)HmjN
z7jbNgrN7B1|5N$z7wUa|{(Yw2FQAa~HZ&`Oz40wl%9$5={$=@(L~P?$94<EiM_M-k
zhboE~S2%VyI`%{Ib>hvunEiW(U2Jk!Q!B0`yy{;YF_E*`xY&x_{98yUQ}ZA`%wpFI
z`I-8km}jxCOlOUmq=(0@mrv15r))6g*6jP6mVIR0n*Dgg@tYLlO`5c2AK^=YYdbfo
z#?G7<uGsa8QMl|QdE&A@8#A4uH?AALPTrv0&GNT0e`Tg#uq>Es;aCvQ!LXnq*ZzXj
zZSzY{%hY#6&<n<NesoIW#LkaC!{+3pixNlMDwkfn>?1i4i=}VlZ-74*k;oQw9iU?T
zuL4xq>`PLpM&z8W*=zkz`YGm?>@MiZg3Y!Ui9hCgu;5<G$b(t4cS5erZN8W#ALJUX
z*&Ceu&`Fxymo<BP?hP7<rN2&I$r9t3awg7j7w<w=&Pp(PZ=4HzKR&|b!wlIuEoAev
zW*I2s-hbvQxn+~TK->d1*TbbuS-_#)c-t<fgq{89qL?vC#J%C#f8yVSYvKPVdfNTV
z|9|Oe$=HGsh+Ths0WE1OlN*WH_1E)ida7V$_+a_ybWG5puk2+3P0bEy>g+sC)#hpH
z^8rnr642DAMN`L%rYb~JM+7vrFr=wfY90AYo}OO*MPGVao};IM_x$ha>8am_Wp48?
zFQlh+xes}I`bC)b-_X;{!~O+5eJNMT!RhICy98%9+La;af6nTUkw2EK7<NFsuET1b
zAwh6evp=!%y4Xm5md&L#FO*ir9o}*J>E_BwbJ<$S53twT!G6%*?+Hm?61{%Jv4rX2
zE?Wbj=wq?#bzw=4Nm3hlpzf2zL2({(7Uq6&)jqu<6zObRI>Ogl$*#0kZgvSxQC|_e
z=|v?ad*T~k>xX}e`VsEr0r*9|c}}>O=;r+4#?8Vn#YntehaopQ06Wutcrt@oAh`_c
zx<z&6vR|q86{L>4tSX5sh%$l-?~a>p0_^Er#<0xht3Flfq{Eg>D(PKR#2J!OQsbG$
z$L-fKaZK_JF4qNk((Pt=+57g6h*lv5El@VN?L$1)IQ{(f{Nj1tR>ijL5Vc|L8#W2p
z#k+Nc&?Y9=czQW+EOkWT>Z5uxP;l3sTOGe3N5@i`lig;X`oU?x6VzcVcc^?;dvDu&
z>__9?6Nd(f@?RuZz>jGnuT%98QUBG&Sb8Rpz;5x?USu?L;9MY0AYNR;Zit*MzCtUJ
zT43`%mZE*@U1akZK)kA4Q8_aGC;U+I^#3_MckDYQmim~1>eyF9a5f$o*d{qsFnTiG
zk9O@eh^5ZqYe2U%cpOh~PAJ!0Vc!SKnyb&XqH{&+JUy1`Phn{`ujYdxeBECTD)_2N
zqxc0p(Bvr`RM^*doC)D?R-+<(a|B6?@b6Yq!*0$M$iR0S!Z*9<#k=DhU+;$<zX*RI
zg#W!+2O<0@r-6X*O9!$ijSREn$$`$+WjxF0DC<ET9?Vfa^%Ip8;iJI!)&c|y;T>MB
zb?~d1AyzJr>V=f~TLY|)EUC1JG^jYaNF;!hnw)qr`)@Fn{vn@9ykmDmS<sqz!w4G;
z8t-JRJNAu9e9i!3fZ&1!V63w@L0IgM&z8~3o|>}a#N7SnU4HKTJqO6&`cPeVJELZ*
zb^5hXFTFK0^L$%<IDyU3(&|GxQudkDnHnRc>|6Sn;F?MTlFrl?Yd*9c`Ni4X3VS!6
z+X|n`;0vmS2nMZmjs{K$s4sE5;jOW>Hf((usCIJ!9Ua4?Aw%snDf}9;jF66|srEt!
zIxPD&SRF(ZaL*-k5tHsmKyyOq659ot<(xh>6%x<}rn@*N1Z24I%}0?Tz_kAsJREn=
zJsnHLYd*_c#}e@x`4#9`B3^SGPvKz1QX?sw=QUpqtM<Q6F3T<<LRe+oFM$#;^FPj@
z@$PeSXf&5Ga=^-1U!=fwP-*}thhos`?>223E>u2nmiOjdQ`+hBbyKP@&#5769}4m3
ziv&$~?lw>A&d<z~y0eO>usex{d{=%rG{jOk1Eg!qvpX}#5@+S-m--p^gZRak<u!(I
zX4g^Hrkxh1`BQZO5!X#r=2i*+Ted^_cKlOGsaZRa+5@(X*@Hi!Pd4CZKz*${0k0O8
zwjzHq<LnRTL%{g+`kS2m|Fg(^5h(OkB^pygd0vZqHFo#HbACy(x`96WAiEzi`W>#W
z04^#_s<n0OgusEtt(P{dzqgoIqgda+)%ps)AA!mh!Jq=6yY&@$j)VF%SK(bu87gdT
zA1T$v;_srmm?zaXUU^W91XH~CWki$dCzt$we5j+z4hqiKL{XYB(MW>#2f?V;_d`ZQ
zPiI$YZt9gU-C#_WLq@`WG}MpC--cLc8)S@}UUntO!#048qRw3d0!cQ4P(Jg04L$=D
z>^zn_Z3qF*ueIw@DC4)^l6XPGFcYzvcNLtwt6{4ulV;9h86>r%vk8?!3X>5_Z6u3P
zgl%6th)43s0n+xa8WWMbeWA^dR2Ym&C00Qs6(B%c4T2Aoq!832sEbEud6!#E2SVdl
zu?cYzA>+RWCnEf9*x;ZzAY2Ca3COh3y_#?s>APsxowOp>@gb39S7vJ2F)qL>AHskQ
ze3|0dPs!I(+lVCJ)A8Y{+~45lzdSAkyokv^2R>{X#vwBhE#A-?#v3EfiS%>ji24Kk
zk}n((CS}7zqjz9wa!E5*UW%*hG;F17Ljz2HhI%zNMw#OOr{;~_CnPF^UABp@Yh%f3
z84Q;>;C(XjjDa_ndW9Wx$A@e|j8RW>*`B(xfm|b{2PW0wwpPc7HS7`qk`BgFxABQy
zaq$Y-u7sHB5t;}=(|rQi%Cx3WqXe++*hd{N30U+6*OV=Lyoj~hxu&e63K-e|hPrVL
zz|0a2rdJ2ul9*QVio$rl2R|REf%LBc(k|8vHC3ABwDd(Y-Bhi@6S%|2Z|gX{C~;Js
zGknG1?C_OlV86f@v(&jHYTO5!VZZ9HjPdU5s|;`Ic(MTH&^(lft2%=L+8!^IT^*sD
zf1>RJpt$~p92AEDWeCM#7K%dvBKgCE0U#m+0HLj}tmDyQs8obWgEH%3TTO#A8KjmL
zvaF@%u-k{_8<aRDZ170i;Gw41{{_qkYc%LJx0$JvJYk(1;e}?}C1<!p2>6ot0^_XT
zQ_Xm154YpRM0ra1)Sfh?kb!3306tOCXI~}W>l^mOk$#xvAQ<&6Jc8k)xgP1-m_&_2
zl{99t)YTBovc-?0Xeq)06hP^PGz=|SV3_wo*j96UQ~`R*(K;mub)JO^ql@f0PyRLD
z7(y!<J#Q@as!#(5FfjmzA^K*nI>p4dC^J1ZpUU<;6v6m%PLF$DS;ylY&Us}d2Qqng
zR=G20z4H|E-J6C1M_0p6YUD>YkVRNS1WtJ#(8w58<GIr+&|*&I8e+6_A`Ys)&nM?y
z*5t;{4W(7{*0YORf=lrA*={0a=}@OpQtQ*Ai1uTdPgt!H_mHyjZ&5rIxOKp`%PlSI
z+*a(A0^3f+LId52osUPIiNXth8{?IFki87mbFy3#6D-$M7<u;url0BPh)E5*V>gwl
ze!iNXu~DB2_HP=^gu)I+!MI*g&oa?jnTqs#VgUy87|3MG2fCAwivp%o7v-tMIa_ZS
zK9so8<9I1?2g{&nH=4)MJ)N6MJH6sYr}Q{fYMt5Asx8<4(VerNdNIN3nmiGhK;z_z
zkT$>3iTWWj{haMJSV6dkBN{`7hOGsQ?7WBkud?R?Bq^$N%_f{T5$27*8T!gx9f5y;
zF`_wsR3U5EDXI@^hikb-s7A)J>oe#<p9X4h&|x%y%y2v!JP{xNWP60&sP`Yw8HzCi
zisk2tyJ5=+AnyjWV6pF)i;KLwr(p*YZ*427gaMK*DGzmJzmg^~mVT3+;83GR)}j=Q
zoWFxq(`?)}d0JtUuNyK_qasd2es&1`+bJgf!&3mozINV@=Jtqjh|~EAK-^=>LAU%C
z8OgJ00=GKqnSVS(Ov2(FosX9|i*dF^X$G;!Tm7u<Z^JI=WBI?CT4>skd|~U7x{H1O
ziPjC@dX{5G=BkME*%jv;I0|wP)yO9pVx?JNwRVWfrI#|W$PRc)@?^MD+<0n3mN9xq
zz?X<Xg^<Xd)NvMkVK<}2h??hJ1<%{<^NLvZ7^4O>>-!OgA>Pd=`5x^TEdNPy!gsT~
zu?%d%Dgk4!^D6SjUSdl}(i>67v=MAYBHLV9dts}pY34r&y-C)6j09IZyr&S%8-GZ#
z^iD0K{Z^FeYcFK#KSV-azM=4E_OKdmz@#_G?Gc3jJ<L7-BpNU{T}<&6GkLCrQK~BS
zDR%ugc~rkrU**Bs(bQznW>&>LPv=lJm5&Eq9!^qC5}+M?QMB5`#p@%9F@F^C5W233
zsPL1Ih&q#FaDXF9_+{=N;Y4GYAvjM|?O6H(xS9%Xn8ZHr0eTIx!OiRV4GNcvKAQ;%
zqW0fRXtQ-0u=zK!7O&J^L`wdu<oZ||<7-sROs>>jJb@@TUe@tg4UT1X3v@^4!)WmF
z+lBHRM^o*WcyC!WFl|J|chFd;92iRtwDEPW1XI2=@(ik;t(DF|zk+5~+7tT@!X!$J
z_FL|7m?aV4n9!yF(fc%Oc&q;zk>Z@~d+LU<1f9>vz>2`X%z)NSi|JzRCaf*U2P!#l
zgFR=IdWUgcx2wJqyyA~XhG(z&_$CfDOs7ztyA<DA==*sjnD?CLnB@@Ua8-VpmZ)Wq
z71h9oE@Nj~X)as_=ZA*vvUQ84rE~B%L%*zfdFwF0hF1DcuZOpXeN4|1xg&WkilyEp
zpP>#enDVN~Mwx4hVXo7P{SAT?EYy`@{&6U14Aw=gbo?&}^f^6zGt4eol4o>1eCKlG
zF(BP7##X5uz8I8riv3S$oAXML;J?MIC}B2j`6;Hu_-+0d88^-|CSI&gGs$R{_?X&%
z&*j#ESxe&H5Hz|Pvgebpn6sdX+LHehly{zDC36o&=;;hgZ*Ye@)1qiVb&!;cRP&H?
z@I##0&3XGSf~zY;MQK$-$rS@JFdF~l@=Z=R=9M{n0(;&Z|2!UJpJ8i1(k*gFRP9I(
z$sQ&Bz|mF5CWdi2f?ZL(w?!vIY*>8`2*I_Ce<pv-)psKG&5ha$=dX0nkE%i}Dip9G
ztZ=E9uke8Lbs(QN&?RGi0uV1K@+Lty&gMx260fPw0w6hEJXLUi!S?RJ^3(s@@_55H
zhtXto{Dy5@!Y=i`Mj0^GgX;7k@q!M_f7QRpZw*rv^Z`|DQpd*6I`4RL1J0;Ao7+qC
zN79XaJkGfcEAXgW<_zQi66nCGjmm&<uhT74#oHA-4i#IReFA$Cg^)8XFm6OL=6ro%
zd*f)Y;b84yk(Q`Xd;Qoc^>c=EipA!zpfMY%4(~o{EeKebYwcO1FA3>i)~Z|=<|w?w
z8%1MOU5=L>_SbMR!@JMJbap=Rf%FTYedQ}g8gkI`^5SF4pBt3dZ=doZeTVmvlKry7
z>LHdE?;^&<5Ongbe?foYedr_H0d84UHvz|va(axts`FgcvB|fE_WXPc=DX?diJF++
zT3VTlyFj~!7D`t%;SsH9!shJZ3+$a?J9s(1#YRHHHdy<EFy0fp>Zn`n%1+u&<Pcv$
zJSo2S=er5(WDJAC?*;V_a|dJNJB*NQ1KmSws-8%GI8X6x48M}cU)j@~$3Wqf5eNf*
z-4C*3<3%j%FR`M8@fsMPW>4Doa}Uf9)z|{#C@=?`z&uAxoC=2A5rsr9qT_r}s*QRd
zy0e7aZD4Va5t$=P7U8iuF_99V6pg>QKR@c*-f3!2{OEt(WIS%BR^h}NZ(4jQ5Of6h
z=kxgQhiqrw=KbL@#`fkW)hPE6cNn)mo?u;IF1WQ(rzz@0oF^E!W2-hNWjxM&bBaY^
zIr_-m#}04TeFn9|Xh>5$yCi#@Vc17%*IX7i?C=>&;jaf^1~U8qzCOdV2W5}79Qz3D
z$*_CD%63+7P~&T6zxvPXL(HTLW7B}IF$dpi2EMVt2di%N{=xphz?XQPk!khr4`(xp
zp%9ASAUYmTW~v({p6!pNSJZr^VxV#FT4*qsVxrMAsITw%1o#_axj_LLKzCmOhJzW7
z_hrLeFH6jJFb{)1YoczyU@1@ZbFM^zkr?VM(zT&rc|-&ke|H8Vi?BCH?iWI|T#r1=
zuxd-ZBHf3f=iB&X=q%vfn30cvKCdbIrM)j?uQv?QQW#jMgHL=tumh~1|5Rq|(O<?-
zf3w#v)~;1M@kI8|L3zWShBSLP(ls-7P;k4&-2ZL%z8_SA@-Oi!IBE9YXPoAqM{PG!
zo5NiP4G&i<=J`X!1@iw2?{_c(s{aLl;&c4K`BA{1$T0a|mp}W!@_pvt?EmKb+ylQm
zbhsQ$@?UZLV6XIO-CVECE%VUZJiqI84rYb>r)9e<bmV0H+EYJ*{k4Rz?jkv3O|94C
zmE$ru6k$b;W2GBp+U!oBfa{G+c~$0mle{U`d4smr+&N6|0>dsB4%0h%$V3M@^$Kr=
zk~z54!)-Y2tbeL%GRi#qlhGeWdK~lYaPRC^Tf@l6CdWRSDxLaKuBmeLUR$-x)xZ1I
zMx@IzzxK0JKaSuxf(i&*Fi&gpcD+X5>L<$c$<69#VqQ%wwaUO-4s|%`-Ga1XcURg|
zb$mc+D~}U_(Ly|9J_x5w`|=v}v((6KQTlPS>=nIJuI*Q(;OVLRc`LYcMm%=6e(dNT
z!iaefFG4lZ<4zwtdM~#aM|Zhbj&k_jGI}GJ7RmEIeXKFz^Q0I*W5P+qhB@qv&+-!^
z)+e)I?~vqhb7l98MiLX>J7b!DZjQJ8ooNSngT2g7R6ScYU&8rH2iv@V=z{0+@R|tt
zPfT;Vy6PwB0|*1RAl^TWR^8^Y;JtaQKamF4{DpeGU$MiXme5SV)ZSIE@4Y@I1-)w?
zQm#(r+R7ozevrQ@v)<?92|1WYJ)TpCC$7Rs3P7%b#p3^H6pz#03&)P;R*UyF>O!nG
zG{Vi_$vo_?+I+1iu^d5Aj$<!p5@S`H7Z2%tsDeffKQ*^V-Xg&oYRuWyHIN}J5=;n7
zG+x0Mt~W34;WTqSL(WmvUql}Y_dj;Ob$jKzUqUj-u_ti^y$^OjUHz48t1Ij3UlY8r
zH{@b}d!*T`{_7_>{#E6UqjRy3AKV9m)=G%}?k^IJ@wQ%G+g<@W25jeZRyQ|KJXetW
zgMar)Z{Iv?Y#y_J3WwFI>i)|@wvv&(!@yf#Zdv6$cL=oXo#L0KKO<NJF3E4jt)ci&
zGzYP|X}?5%PHPtub7lbLyI{ot8+cvmYAn}KcQsDd59k<PfDVMI!fcsUplLRRh-x%4
zNApRCf<B*0bEU-A`+Q>FnhK@Wx`RiY+Jn{CU<p)Z?UimM**NUE#yv-oL9War!4de@
zqv)WHN#|R~uY6{UB^*gMNG%9dr^u5{JYO*UQtD2T;xXuAVVN>_N;zK!kdv()C0o6V
z?=?^{Bu<YZI#Syzr_E-r6_zZ`{#qb-gYYm*^SaA(QyZuxxK!`FSb83h2yfw$#CqpE
zJ<$?GW7Kcq%bKCoH-3*dk_9Y#Yj_@9wtFfxo!24?X<ZGn$l}My3!SIq-rkpmN)BP-
zw?Cr*MB^G)X5V4p=XWmRdPw>PJ-YRS=XdUn#%^dN*D|z=)RW%8EYu)6tJm}7zr&;A
zVS5xPYRb&;n%b7kk9H8BjAm*$nVSf<5=Uhk9&ImUbF`cf=fP^XQUVNQX6($QAEGK`
z4wk#_qNXC}{zu^zUFog-Rn^Y@Tb0M;)O%*NzBJ(lGlGyP?j1#~^r~|&i_=%gK<Cm=
zlMmxjP-VE_4bR{;pn9YivsqCvyBYPyEjPCGG7t-TFAFJmwY~`lom-+pgJTk6H)s`H
zMZ*m}7<D%%m>u;c^W{>yp~q?Hp6jNC7wkZHQJvH97^FG?r!mFeoh0DW*y$3C>4$;7
zr7a%9mVFvmY#~6RRs&Poctv_#CMltF0lPl41#0y!qCyTb=O&NLWQ4$$792EB3ld|g
z>x&G2Q6^}(GAIw`?2gZB8^~OO&X_~qr^##AtL2?!L2Upje>dK?K7?uxPzhr%yks(Z
z^OE$IyTN6?u8zjren>|Dr#yOpL{#`0tx2-izWzk>^<sUMy?wlGryj53vAL}(tbFfZ
zAZcA?rMn^jinskL{QRswW3@1cQmt*DB00NtKYkqSPrB@ez<F#>&4>v14%t73`&7=0
zco15$n}E{;BAcsTT=I%MqoDeA&F&$>!xY?Jok;)E8<xIMlc<9tNy;t$xkX+X+ly-Y
zZUORJ1Lz%NMUa{Op+`6<Ey{`eJbcIZnw2_nXS^*N_N;fi>6t9gXK9u{(rdhs1RMGX
z841}7Gza%DW2sRPoUsc`>}PhME&F~+=CbGhX=11Qr-`5KpQata{%KPWk~aGwX>$*f
zcJ@Ki;s;5)fHbq3dOIs4MK~0@AXqLm5$emk>PLuznKps7$jlcEsu`-Tdb0`zf_!Dy
zncnb2Biu?1nCHWedk@%ehx-qORKZ_sZ{kW8>u-JR5NEze1MuKpM$1T{-~9!K^|9}4
z7{6!YrsR2<8M`xcdZ^p0g5u4LS#p?hM8z=T6y+;d7;avZD8{S+Qqtk=TMV)@VWjuW
z<!tp7h9IPNisVVPrA_xn+9LdE_HH998D*z<^^K}$hVEfEdHAT%q{wbP@ceD}C+ZI_
zH+z#qJ0CNZ+a*ZxG0}0O>AXo{rf_2&Nu24nj&rAs9o=2EWyz6v%q>B@%Ovm%l8Xt7
zhR{OpG1|Yy)Sohr#@Uol8JE4oJ?8>Bv@**sPAFQ(DWI3Cb1pAKco*O?I8V5>qQRN&
zx!ku%9ztXPj^v#!++1p*R`()yc<@hZF~82aQLY3=<iM@TI}{r-WizYv$xYG7bC{&e
z=}BO*q5=fLt1TP7#c3Vq%gYSjs{8Xpf$U3t<YmY&&E_qnwLte%xO2OG9J?dF_xCEm
zQdfVy>Ys^+ylnR>h9=BXylpe#+R~R9?xr#G-hM9N#;=CWl-e5jNDU%ZvoX{js%;<C
z<(>6SGstRCR$iYXOIyF`eE4+kgF+3(y(LKBHR|`^@wzDStL)Rtd5Cg;{EeWB<kQ)2
z8^J{&uUS(8n>R%6UHgM#SUWq`ByzEk^o%JF8WXH~yyL)ES9&*^Ge9fKq~DVc?S8$(
z--1*QS3K$D_dIjaHMzat3oeLrwemWfF-p@0M|4|{GsMKVt;?FNgE2PBZ+4w6%&7E#
zk;r9gson*HdzkjA@NqSQzU~Ut2-Mu-WiK@ybPv<UHFIrI8H}4e-VkP=S?e1xV8V9@
zav^PJ?o_!hoWF$IHJ;+$FKi{5YX_oL)pqSj+4)3xkd7hlU7!07yAh$<<ZtDYBkCp2
zbi4~lx==1WwlsP1;Pd1GBO-g*HN`XWBb-}%fDQ{a(;xNZ`+{i02~JucRE>FnzlG;6
zc2u|!1|0#}pk1O%>?u0;#<|YPd4S_;X%lw3sLD!b#oI1r;N6U>W4ZsjA%M!v1iaV^
z@?*KD!b#G69=);cyW}N)PlF|s$d<6$dUogn#^j45c{jz{ena-r8!1p8Ry)qtXSy|d
zQ`;6Y;1=}#pz9OHS$yJ|-{Lc9KFt22&A!EEr+G6j$MX}kEMVK-4qN?kKA#y)Sx9j<
zwzYBhzjE}ZCX3;=_b3yfvc;RPa-7%~RXB?(SuHf<TD^PQ4e2-=oqY)89~QfwQK?{8
zJG}cvJ#tVrLTA9tYEgW4{EFh`1Eg%LAGcya^<Z?3)Kfjw&4}{DjcjBKAa6b6lNg8a
z6Wr!;lbXjSyQuMzH^t95=`%an+nz{KzGf8^ER#|7TN>V#E+L#C=~qZ|Z`EH>$@_re
znly7m;1O#1_`yTY4$g<}YUR_kNvK|1Hlwu8js3^>u88-~)OA-6x~e=AeXut6z>}G4
z>$+DAGieKU8zcC~=qDdZtTwh@$8_u)lrZ+Prs@K7(zoDfwdQI_Vy`m2YpdQqeorR)
zd)1ww?xskstv!pW(O?;m^(Sxg9_PwxXHiY|m+JMcrq=@$|3aO14AdY!*Xgvm012l6
zZJ%SL-TLY?PNsjcn@-~GjGOg%bA?D?hj;1Uh2Ev_ciu0C#MqdKEQSj~^g5SWmQ=8B
zFszFYHI8|5>(Az+g~YI{9p3k)7dCtju%zWZ5uu-!_7{7^&ipD~!}ZIcskMD*TRDT$
z;+1mnQXvi*Kh%(zfwaTaxn<~zx}nvTL=R(7s|UqWz6Q5`DuDLgTmf9bGVyUnZ7T-I
z)blBoqVyv{>CO6`6ifY4zhkjf;@5en&e(;f@6*dOqd#!#58Qv@77qXVW7xsh&z*Z-
z+ou2=D6rS%I)a5grHEXag(WL$N>UpVmsD3KF0LMwxS)DcVs7<Vgu(kvE6J;zr$>L{
z)*ra*GpCT_X@TmT`q{p`5i~M)D!FvYni4!p=9Bft_xi1*5!z}s%d$Es!GX|ItzSAg
zLBC@OTEee?l3pqkY2aC=k5>mD<zmy<sR$Z1BpAD4tU3{WFrfP|eZd}oI3L{mHBI8}
zrEMqE|5mRVgQZ~LQX04`r^-z9UF7MmnNZ;vmaeER6_8(H;t0s|`91h}U9TMEToUAz
z!w5nAP5m-n^ZCt<*Cl%SSL5~6r~}4p<=7D9)O5-HgYk-`w6Rsocj^}ybr4g_GFey4
zEBSTyWh<4ZD#$ZF$TK>~BZEszODS1eW}m8BZP;B(j%(=fmI1+rAecNFX)}}kvou+n
zqfXB()*Hj3+rBSGzKQkWFY^uS%}f~Qua_l4{Wz*JqFOT=Imy5O4^<M(twC)Q&D^@T
zGVE_!W_x|-)}R%2gQ_c&0}X8@K7>5pXJ#KTwK~qkWK$=p{FoUUJ=-s#MX6~@&8nwG
zy=@6#`@hE0L7Ba)FR{x;mt3#(ct3-&``=-`$S*`qEQCV<)h<Q3RcO~&54H-8397TJ
z(B!wx!sA~DR=OH00kFtFhsuMg@}2wyx`D^62SjakH02!)U7Y7Gik^%2!?W~!E<ut$
z&qL6y@d$#LVn5ehNPOB5<SjglEN;{<WRcP@^Xqbc{j2!Xx#1YQE%7f=|8{uS1D)lg
z;>nK(yF0@n12HcbI60F4fiK~x4QrcbMs44*xltRZQR_3ChOMX_#%%r!!!_Eij~_5x
z`;AiE|1$V7I7vQgfBuy1A(JE|$<laBTSi0nf%tb)4)2aJ?3I~dM?9caT;>Wp#qNv|
z?ychaoL6q$z;b)*rWA2TSh^0ja5y{sXE+J*b%tVMnt~3S27e=|O>M`}aww(!{GXVt
zJG^sPE-cz;PMEuuoc>0p6Mkur6r?{O0VtduU7&^`Utr$LgSQJ{XO_yF+K0DY06J%R
zcO4U;GkH$m2{3#`-S9pWAeR2MChl7RvV}gbX{JH16k#2A-VdRjS#1*p@@s4){i(Es
z=tGmReOTLNv=sMh!<O(h4{X7}nFXzLlO4EN>RP@qcnjn0(YEUhfP?eJRzp1uPFMZK
z>RtQ9yga#{lRfC*dsj^*-|$>D(*BIHKkRcz)E~;V-9XLl$LaX*{X7=YLBc<mvaA=d
zD7aW!t3dYMum`cWjOoGBiX7>UA-nBgYv+bo`(Q~1FZ+_6(Djpjof<;>4UrR`zh_k7
z%C?E9ksNf(blBy8&g_50eyPyjNcuDEWlAC40Ty0-JsQnVLy7tIeg$lW`ZRMMuP{aS
zJB-7AbnC;&8Ek7mqO3?2k!)i7$9dTU#GVsB^x{M5d;!?@bI@$$1o&GI`o<yR>NDw4
zvscX6;yziF*qd0Mi`uYAE#$=ThzQ6ai)}dMW4-paijizUMHfRmfnbB{xGf5ln^7~5
z2}B7t_Lzo#0ArMFFk(UQD`=rmJ|}$P?}c;Olc0=sPa?Juc_vCD?tbSO<jwNVhVx)8
zlKU6xCrWRRbM8amBKPC?w%kwaqL2CqV7Fh!^ZwtJ7JlzI$akd$-#M?!iA$gopu#&;
zIlM)w`IGG(rkP%o3Qr8S^LMBshUSio&F_diR`MGjwF7;Z<ax&4Czk4<P0n0E+jm1~
zE>-Q9bWnlb*sgjB1q(!ClO7fpn1i}y+uPMy!_2ZzlY=LD)iIZ!Bq9sUa|*|+rFq%z
zZUH7Odh!q>n+nwM=+768?M>{?tR6?5O>IAA+O=&ZFX!_M`!NgfixKJE7|pEg{p6ER
zI(vGL-?Z$n9sEmpA8hLAKpA;l(UYCe_8a{+p{tt5&hl1oGh-%tUx>Umd+WwG$~rd|
zXP=F?{Zc%jsC|(4?1N@j`wM7trPaUZP?$JdTMFcXV&HM_Oseau7i^Gdse$zvL!&2>
zf;e$(+&kK2G00IC&6GCSrdiL7%y2(@qd-15Rv_X`Ynzd!S$CBh&(4M5!_U-IBk^|)
zvd<_2&sRO|epmR$W!tiSCgD$2-AgfWTY?LT?$MhF)EC)H?B*8lsd<RgOhMOG2|Hq-
zl=C;l=a@wIzf5Jxt!q@*$#`^2MHzM?sC-xB3p41BbhD44f5RCLMfi>_7hAD)Mz%Vg
zs$k3H5!G1AZyhp+3dVyH%Gnw?8+Q?P({0!qc_PwP^<k`Y1*M(6qqm}tT9OF1*jIgN
zMQvnx!<(JnI1ZV!GnW@T$(|Lp#mgJsvPqmdlW)cz*yJQ1MRS_DucOQ~@@QuAW!-#w
z%aKo`j!dGl8<Cxpd<8MqXA+aS&cKoGTZSKZ>>HdozP9S|1<@75vhTRWnKnJtP{z`7
z3FKeRA2P&lxRAQDuZ@4wL?8X&MXJlLj<@|+NH#yae;+>2(eZnu;L{9TepdJssUy?W
zk5FVz_voIgeNN|8&~xRX9ar}ooE(^~>o|RI;*7egeOK&Zxfz@|t$JuOQpeSRwa2Bi
zZ2AD$g7tx~$0s)KJ#OQN{hfwacpJUZe~v8`>r{3d>y_m9%XZ60u$@jZ^v#82W@t3a
z$U%ut`aQwb@LoKV?%}B&C7XUV!HsFb*sg~6c$V^EuYQS7xy8(OoZ>PEVyL*EOxzCV
zZUlnts^+!_LuA~#o;hSR^Vwzl+Y7PG&GXAC5%MSCg-eI<Vqa^G(#-f+cmbAq7xy0f
z6Zz_4LT1WY_}NLSu7>yWz|)`Iq!n~auj*Eu9w9+7mDoPj#J#!Hs=2wh=-SUGHGd6Z
zf0<NSq=l@_|0?5e=C3RYm@0gf8^oD5*_1g&H9cH7@&a@}{Yq&6IF*<$pfOo!cf`U4
zN>5RQr{|Zv&U~9uhGjd#H}9^8m>-*gap{xEqX47D(>@O{vYQGyW&uGC`=jAw*(VQZ
zf7$MpA`n^4?ayz`wgDT-&L!}fSJ<uYA|>-9v8;I87O`IyZT2obw_nkgh7ZJopZ(V?
zI61)bSj&i?ZED7<qS+fucf@Ysa#tVGlxMydth3Db-z-*Jyhj*0GD;hqYEmLNzh%St
z=a+Bx8+e7@wSN55{+NF3rVrzvXVoLTWUe#a`Of@g?*F|rjqt#W5S8RQQ?QcUyw-L`
zVgoZ|pXh8GbY^zn&S-~h=P&!WWxEwQ#mtDrg@Fb=u#69`rUf^(ngSK?pEjZMC1bJ7
zXV~E(gD=V~-f^DjYiw)Vv*En_$C_|n<~9j=Pga_bSOKy1xGb}JFC*U6_PUT{7u;)F
z|0fG>-_Z`2-7^7?ezQtA3hddEAMZ;6=-lk*GRdA<Eu1hvLq=FNT|ucKoAz-{-tnZN
zZNB=Hc-y2I!5aNJip@pNIm`Rw#{3d2hEp1L3`Mo!8PAacqYZ4vTD%u|mf||*$TlI~
zHYKd@)jv>Q_P4OIMLLcX)#9Yiz5SE@8MW*x{+OEL`KH(gQGvLIYgl<^dUa%DxN3bp
z)3800+z`(Yco*9P{@=>~4{>^Y6LdCtWi2`vRCeyg9i2pV@wOu1XzS*n#P;JnK%qH9
zCTKk_&@9(p<H-%QXL=a0KVPC1PK)0TB~MqqlTDL#{Du_`&)Wfv>-jnJ_a*c9Mf3Ls
z^LJ;wZI0Tt!~5@Z1k|`K4G*%Zg7N&zZPkIJyol&;bAeDBfnzMl&0fq}qiV{gu_98p
zd<g@%6QihmMavuB$jo@do&3FzmrowtTi3a7VDcTe;SF3*&37B##D?LyxZBX9YY6cE
zhmopW1R1PrX&Vs^+bM+CIoE%WDhupyHGRfKg6V@hRT{EfE%kjKK~S^zJv$GXD>YV;
zm{~2OkEXV73L#@D+~Td6{Xe1i#D#q~n6rV>Q2Ny~3K+rlt3|G&z*4@4JH~)qW%jw*
zy^_ct++h|M`08H9S&8t2V1N2UDD!2BMW9SWl)p1wN?guQyzQzy)Z3fQnNzI!|1yl)
z(S7>?JB-!9LbL5OJ2mNQ?Bb+IfR)YU_wQ>ehOscosLQ)?G5S7Z3VVpv&Tuz~bE_`;
zXcuek;B>4=zMfUU0PYMld(%ZMI^I2pp#Of4vt9OhGe)OzWVSqGxvO#0S_@=48GQp_
z$aA2rMBXgI>|fx7yBSOEU+kIJ`^Nnm9<$U}B~}H7nU>8=<CE0h3(th;2yPMYol{Et
z*_#bCvn@3K1W-VNp~xCl)@Mc@&evJ_E#b{vSQCo~tDBqcQd!YKl(ISlu)8pO8UK0k
zApXDR<3mGyR$puIDM{1w7`~dm$5K~vct*;YID*@rsOOr!55=(zbG=DMqz2s8h_Ohs
z1b!W<naoLOGFsYPkxGQ+p~?GIlOYxIZ%NBTR#7IcJjD4v$9%9woOBV1pc7kl4p0fe
zFjzVR(l`fQy0b-oBrmWy`QXL4H-;P`g&S@h8lx4O1r*GU_TOo4XomNoX$VR>J)kC}
z8Qi{{Y<hK^W`ODG^4r-z8<M!7KhxX5D2dM|*h)wo<G`qsHbVLauPZ&4R}n*(iHvBT
ztnFA}0-DJvVj_D+WkgKC@n#&G!$|-IEb3-a?8Y%P8%uqQVO}GXUMza{QbK5p>{Wrd
z*N^-bXJUoFBENg9Fc^8pxxbR%EvYk<9WbK$$qkKb-Xj|y{1GGMWGeV*Of)}sSL<0i
zxSx~RP3z4y-_gOLfkO$FJd`Cs%CNmwXEr!o5f<!mwq~O%;*lDC{XmDEcjO1@@9wRp
zn)?OA=<Wzo9LGGzZvG~Hvm@`W*4N0}78ut+?`BMi$GN{|00}zJJpoHI{^cOgLMMn$
zPHYVUaJC49_XPs}B8DcUz`JYw1|=Sj&&H+wm(TA1LQUg}!%6=xsmV9CG`wD999kwz
zNLI$Zx>0+j0IcgCkBIrIkt@-^G=_@D!>wu%#baeM796V!OIA^Gc{khkeQIv<VNcc}
z;+5vBk`IVBU*AI7!J3pnqp)CCSnzdv8x-t1Sivs715{VK1WanIfq9~v(VKxf>SQL@
zbvx$siU9mwS=nBU-_z{vvR4^>-B&H_hj47cDK`D+3Bj402dC#?;Fx2mz$wjxbE2Ek
zTOV+gkO!w<VcYLBM^?;?=+5^WdTcBf0$<{><3pU2NjOx^FV<A}o}i@>xt10T%APcT
z<?@Fq?V4oUWJhLpU3aFo+qqR)s|PK3Vfn*d>GGghSGp{C%9fb(U?D7WAiiP%0Vj^D
z9-26A*@yBPwzOn<YN$ABZ7{Zz$y7Z!`N9^PTqF&9qNExx7GwA#8UJ9kIYZIr7#VAW
zYue7>q}nxY^CNV?{tVD;M()?}Wg5C#+0;GB|1U5J)M8wRHM3}pb9($AYKsB0pFR%x
zWs_Hq=g|Ug|0+8pgP*W_5XSg|&h`)Rq|f`~Nof{Oa%2`<XNzoEad;kWW+Gfw>1Kq-
zK0~X7+|cHS$HW3|ZCeHJF*2~f+`X^&LjNp!MIU?|JqD_)X3w=m33Iy%{i{AVdsA2k
za;r_bGFzV5wk%w2;G@&cqT***nRL(y@6Va7!?N9%ig7RI%JY6AYxk-s3;u5R7$X#A
z8Fa+&KPPb~hu7%*2M#OBTr|Q6YrCe5&=e#5sEs(mRUy51)f@9}G?A19T;%erVbO&3
z;iw%;eMIW~&T9r^Y<#&Msil}~(b$7^gWXxB@yt0DZZU4y|29?EC6Mb;HagNfn>yw@
zQ;sqh#bsn$PlAkWr;O#y6-&*buBP@f;_@BJ2hJR^<zKPww|aZo<bW=-E&dr08tAop
zVS85;h?8Tf(V9X(x(y<Yx4kbs>Wtg$z57MZs_By%ng7$-dkP!8dr{tNxa5m)`6D16
zth9Px&O?<NYgX5Oi4%!Ka61r^0Sh|_Iqpq2g-g4p7?GwgFV(k82rc-(M=`Dn<biDj
zSX%mjgtv$$EwIOiz^;aj4GIbNbrHC@U2<=A$Jn)E34GH$uw^i;Ta=l!@aUvh^4FbW
zRApZV*XmYl6hn9OxvgqufaSQCVYE4-<p9rQRKfrBP~@&wL&%+N#Ymsy7#cQvU%-UI
zc4UsA6V`X{W_N9Rg7vbtZ^o=YmKqFr7L@^T8vVHU{**$5TB!c#hc)-szHmJOTq1~{
z{4RuxU8#j@b^%;B$ZI&xVfqWnj6jip0nCk=Y00yt?dTA3#Hj<o9M+s?ogW#L|1S=c
z5)cVjLx3qD(uHFTsy5<9!eFX6QQLWjV8P9S!V&oMfG=3@3pSR+?$pLo{rmoZs;(T(
z{uoWX?F={t;f5aMrrJ)l%#TFc=2+b9r5Y{5F`{yw{hwo6ItTSct=H1JNb|OE%=cO^
zwr2afT?pUX5AR$;sjhV3i^_mvrjgF(&0cRq4v7DYyzQK^P2T!@Ef7b9KwOyvBGGIB
z7y$tBwz(S0C#@u+`xjPx^$GaWR5>Tw<V~O+!#jPnB+x*KpX4{>0BL14t^%=!{em)_
z6Sef))OKP>BysOl+aLc&rpYzoqI0p@Gs-^yBUXucTO&pMZ!p45ZG-gqHu;;4Ff035
zi%AMb>BY$gLH={(jki4$Rv4qgxqclm#cgg)qGs>jAU6TSIj!A6ZvR?Fd{$m6_4I$J
z;2^%|^nrL~D{`JjhG;ZDfekN{)KIC_sTE!vvP%%;%6XYWeLjWPjbwwmh6<XR+9Sk6
zzuVp^5?3}%S9gkRd}9-{)N1b-htQg=-(0sb_fj8KTaCI#bXh)+CJ>ejjnZHCBVwDo
zM9SGom^Yu^>K$2ckmi_}NKMiWV-v|WnQc*70+sPv!%CM^HDc?^`INd_ybti7OV#1|
zjI_4v7@vZyr8a(GK}uQnp+Mem^wUIkE@?ZP^&+pcM-*%?NVS*`oWQ&@>jWZa<dVa{
zQ=og~N}tf4S6p=&Ws^y>T1e@|TfL^GIfN!Ejc<fgArEyRX9kqNMhsfsG3J^>$dlFO
z>9!PIQcc`j9pug4wb$tEDzksyU!P(6lhYT2=|1=Kv~STr@YU5{+ZO%H-_N@Z8w!mQ
zoloTM=lwe^8+XvUpV!*<6JFb%vU9Tf4l^gwsRr2h+pp36yuv&qY#y^;4#()g`*{M4
zI}S8X)Atw!vb~=t*BKJh3^rmLE1fd&<=#?ckJH$Wz2*`s>-oe>BHXz5?62}&c+^~k
zt2NTB#OVqmh!+k9^6zIETBFtzsRZ*qw+^?$&*V~LKmr&zv>@VLiJ30V-bz$&M!r(!
zCzzjn<EEQnsMC}xz%q>py*3;fjz;<VX+|(-jiawlomIY0qEc&2q*GsC(xq;jGrPS&
zo+$f$A**kjUHuD2_W#uez#aNiHL#5f07u^iY4_Kw{%t#mzk}dDfGM#dao~M`mwz4J
z2cUPB<}`cSegheKlg|tW!kYds6as#)4=3k7Tq@Lg^6UjN^!;IdACmhnyM(+^p0P_%
zu4k3&)ic8C_si8mhitcC!E{R(3X<2E+X-zORPwH{WU?c>0!Gv4d_esO7QJ5PCME)X
z0=#|vz;23LKZY;8`-`N!FgJU*!n!q-Fw?{ng4g@5J)<DsL+&WX+2VCuPwUP*HOYI(
z)8ak;BKsWUgyJU!<8SnJUZ>jLgTI@+Zy2L5(NtOT2E}m}a2&02-^ST&`JRJc860mA
zFq0ss!-F%@bBM4N?7i9hQm(b%<jhY({~v}Q9PcXLZlbSUhKlC+m(}d{@kfFr$At4s
zOmk}{0NQXoBQ#EQqpRw@pF;3e7fx9E76}K`YhtAIPaJ*5a>gg|Md2gYOyJGHZNX=4
z;xIl14y9B^=a~M<ZEnj5zHQq7TlQYN_}t3}Xhtq@DUrQBFF(%THzWFCjc!l$?Jsxu
z4@jf3{cw=4FYG_35jtYn(S8*+f);}CHjWFiGr?fz3WJ?-OW&e)w{b!qTKB?HFuO7C
z%#mE^Gw2*;3Va)isJd{ZEzmM5?_|qutT`CS2jDYU51}s!&10!21#t5y@OU=bWUBa_
zi6^<_6l|9VhxXvjqfD4ZcXFASVBfAaR$W=S^aa5`eN;gZVN+M%oNoPON}uI6PrwWD
zsKWZ|C%e&}gVj7?siqbM3ovsKi^`m}k0qMkmjmJn;Gcu#$E$0^1Df%Zb2=<<2L1iw
zisBVVPTY*0=9t81u?VkPab)WG#Aj<eJ{pt!O!c*izgm0n_why=3OvrAx4EuXw&=tY
z^$5!Nu(NUbj_hVUo1iz@U%t?}yV}|8JfrZCv6Q^*>jGH=zpNZeI^8^i&{*nJJ>su%
z11~ozLIaC}HJ8M}mbE4$WSq*Y9=CQB?f_NpEZ$_w|2GZdqKQU>PvoXK54kheyLIER
zhg10B*gajH)e&j1&Fy5Fh(6>tjYAM|(=R9(_>kiwX<dYJPQw}sM0U87mtnKD<Sa5z
zsvWuX3+{|HnP{5LaBu9MjpU=sXwX)-TQ@=0Z_!mwbVaQ@fIx~h6mtg9N`2LHOWPT5
z>gleUv0=#<XlGi4n2^rapqcB{%+YT0p-GJ+mkvL$jnh@d(S(hODbPC2r^~g77N~a`
zHdHlqUwbE6P`c|mcB5ot+2u?r!IkXhMxlZ3ca5Mq33SPaoQT_^i+#FEl^D)e0Bm(m
zEWnbkf1Sz6)17`c5g;L&8*zk+S4M{6CJC$q5q|E<xd$$>o!IF%cy3cgq#JLnHkjpd
zaW};?+(9Kv-6s6IJ_`LM@kzIAU+aWJiwH@?KrY+YVxGUGA)YFS$jc|#@l6d<QvGZ<
zx*UrmEVU`k?Uz5R!G3ik5(JRjHEC*e@d<MM8LyCp=~V*@j!{e9nh_cmXU1-KKn+8J
z0o070HO3Cg>)e3<R*$5r+7YpvzhlbmbT1#lA>k$$PU9wbS0y1yHnnuON9_eR073<(
zK*sT`0);F**#+XniSE_q>}rqAbuBU6b_@Sgih~<l{#!M|RmP-X=%Ee+14czXRgEKJ
zHyQUEb2e1X*&WL$;9>TA_}A9kjdD`&&jatUDT@gI9f3%{xR5#LQKx*lI_XOt#>Fpp
z##UM+qvpv#(&U;XErpl=A%EI7p-Hi>&)VK&EpID2C+Gc)#lruK@;peM>~pG2HQlS4
zYQvgjkK@*A=@{qM;)sY#tGk`(O$N^pTcpN`n2=cz7OG{6rXOH)<2UffmBZRnr}{cD
zusi#Nxxd?tT`tqtnS+}}uJ-}H0s}g8*me*a@GjQ)gYXwwSVF(53{);Au-^zQd|5X>
z4}lCZ_LU<sKzE9r8D&ng)Zw-)5oLE6CtT-CGwRQxV*D9MzEYHZmN|8vk`J=~Bfj|-
zTq$Dp6B-;;jDLRFU!`BD%|!p*nHkMokiUlYnhm+T|9(bi&yO_z0}kNzHikP3q?mzO
z?=)fSP5hFo3!`?uyRf8S1)f<3y^S%aR9m3T6p$CsstZel6}7Bj-7x3W{Z=I7a%KNC
zt%CcfY56|QF5gFMb2CB95&-7wuexyDQXS#?EaP}t3VrbFOtb&Ol;3ZfHNo892L6NG
z-?ra}Xg*Ipd(ackRJ<nT_aA-yC6yg){B(k0*T^LRIuh$L5;aBKw)Sp{T3twA^8fH^
zv-3z|4*RUc=ZJ#7w_joq0nBYS+(Z=5cV`td{t$o>Pe;1XpNC6ZXXCP$jkJ2}=J{@2
z@%i)n)fUeyNVLaTeVXq!6`PW_lE@~N|BL8wK9{QV)fDVkVB}`Yavhl_9W&vUrlQ0(
zla86F-zyM?Ol9lKS?_D}-R1x?9CYtH?t>*Iwh3q}Q@+wIuG)b+vkly$h?iA8m+YUt
zVkM@ePvQ-~t_<&M@45te#UuLgOx-_l(m%0dUw?B~IiNfOs=^+==*&bAVNa=KFV1$e
zy~jqO#WU7oY&QQ)0*dk$<4+GwbNP9EG<tkK-s^12t}4X0oO{9@ap4z_*5RQMH22wG
z2lly9=P4$-^H|5E{tJfUOoDTE7#e-Uihekju7rt=FGzOJFU>wFAxo*-TpGu28DoDq
zt#_BW7$+4}unX7moiL)!EGRLaN}80d$6Ic*kRcxF$~Pn;+OXtEvX9?Tb$D`cb|uHA
zs`Bd-%WEbzlqOMVmB?8}Z&gESEOUW)Botd;{vZn&Dva+LC(%SIspCtZ^Oo_PN!EE~
zT&@KZ$1x&Ak4_w+?XNR~h}A}b<va^F{5uW6szi+UeOeR~%FF&+{7eKtG+T%wdcRoM
zY0Y>2H@52rJL~aSA7aOOTapEXz!f%&7POTB&<8{3ml|(M7E_0Zm>QUMgr?L%&@|^j
zGzmWk8Moni$YRTnRk8ZgJv9+T(yAjrN?=&(;{yKszrpWs4!|$ihD41#rUdJ*x=81)
zNFo1`Pxe<kKkQA6Aa17FXs4fCIJoMG*pEZMmz@hsdczIq!T1yF3#(2ro^tbFUqQSd
zYhZxtesIEsQhH5ybYE5krO{{`5!<4{JaYUVRv=y0b*5LC`?|qhU|%*M&`52BjMNvr
zvQ6L5za0)9!-fNY0tNlWe;o|<Uw*GV;CnD%tMOO+l=C>G`~||fe^Jx+^S37^e3>iq
zHSzXC+9Pcp5Ty5y&sh0IZvyX(Z8wwD;%$5Iea+BNk_OT>zi+YhE1#Jr*Bv%j_CFxt
z6~&!iKe^~`X0DCj=Ja?;5r{&*#M19Wq{ygDc+nI1Zq$WKc&OUM-A#T)$vRuGfMw=A
z8lTm+kOtaMYWDUT;3{>Yd)BPx7H^zw(w}K6&$s#}Etpm%FTp?Jd;?%HxdDNm1mG=L
zWHL!+ZbQNr04`%A^Hm<Y>EoBFBKt=k=9;>G|A0Y>uPC`B&N7L&2Z>@jOqlv|*zDgo
z+KhLRM#KjEAJmU9QSEFniylwrjedqd1|=LQ_V7%%w=_I@@|K1_7nu-n_WdmL{t4g1
z!pEube-tDfqJ+VqBg|pq-Byz@tL<9=Nku~BJ!8!%`?5)#)z+@Qy=vPSW7_y3>3Mzz
zqk(h62!}&GvGLpH`M+f67<@kny&*4Lwom7btB&j)d27uq?z+iJx2=jN@3xao(>U>H
zA4J-zN?V>!6CqYAEs;+fO4^}HyEvbweEpPmc0NsQeB4CZ#C)3a{atAz^J!(I?NnM>
z-?T@R_VJh;e5K@jKxtk+Z6ImCSK9V`+7Qxyt+Wk&(|)Y9yYp$P@7qdSl}{7QE0mVX
zr>Vc!D($j-T8y+ym3BcsP5n4uX;brQYGbC-CgjruU!Bq_`=)(fX{Grz)pw%O_Kwcs
zK=2)_v{&+J!f8xt-F?%Fl(s&fCYXETq}`cM6aGA<-I7mJz8y;I$fuQ)wpnSH=F<e<
z@02z-pVptWyOlOMpC<Tzq_lDQG?l$kX%+djVWeH7w35DQZAyD@R1OEq*P^st`84%o
zrqUkGrwRA9N?Vgp6ODgCX+O`WX*^C=+RA)d32C2F+O_#K)pwZE+VW|tZ-~-n=hKw$
z6Xvj2lTTB=_mnoaZ`vD58__pym(rs7G{N$W(t1wH;XwU;TxmP=Y09@nX<PGY%J+cM
z?#rhs-)g1(v~SwoO1m*k%kvwnPjVjD{&LQ4opc9kHQ0y!>tH=B-re6W6g+W`Ucre`
zi!)IXR!c-OuVjVRo|KPra?*?v0;BTKv5)H$cTl>T-(T{}4r0DrTReYKUGakcoJO5z
z*mODj)}WCq@@_y@&3gF`M^w9Cx4ZYNgWY?k;#P7|MGsmWx3nJ%YAoAgx5@4obr$^M
z{Hn`~lkc)rMu<9-d;>^<esd0b3CXIiE=@iG7*$Q>h>vSIu+-uQk)y+usPi}#PsJ}{
z_E3Rvby@5rdFPPNl*0X@+`Ds(&8pW8r7PGDE#I0cFWR`Pzq4ij=%;0)W<&$?N}V3(
zosEC(KYydwFVa0f_P`U7?(thz)JK+YtVe+OGCiHwr>Beh_S7Gy6}F+gs-Y~F`kKL>
z+!iiB0nBzTE=M@E(!fwY|73!VZJFQis$%~E))2&4^e&c`nV^az*)d`dx*khEsl+DE
z7)|+Z`^V8xbyQL$;<1!~hlY}>g{AmD62caiTN!c3Sq%GVwRlds^GHWkl*nkUrQvX1
zS>in5w3a&;mAaQpD$%%3W9snSfCoDLhyA-mALo<?&9@hsEc#@2)C>8F@e3Mnd~wRJ
z`#@~IoR`=+_)ASsN~>z=)i6Du%V5>xHOrTWefIN=G{y|_7aP#zIfB#DWa1v#3Rd$C
zJI-{aJ}fTrWo}C=#Efk9e*897E|wC`IDa*Jq*A_1X0x2%=H?~{qRCsJd}rvmsjM<Y
zWV6&>k=G^bLSm|$^e+02q^w3b;HSj?m;+2#O}Tv=p`R7_+pR;$#I1zl`OXyxW_xh&
z1yPo{wUzu-S{i;nN5dJ>K|_gi4X)M8%~VWvleA|_B%*L`C3|Xlh;~eiM9^0vL}X76
zov08Yj%skS#OpF%xh#oRv!SP}PFE}uH%8s)5Oy2=IQlx}Lx6+1d2T64F7=D((fB>%
zpZ7Zu{xWB#GH3iO&pM#=U~D$8M?+WUKcnvrWt|(&@h_ze12ErhEynxs{7Fs4u^Uoq
z2!U07>HJCY;@I^?%6@s&kU=9gK`oY4<geKI(3_8JiZk>-p_i$A?R*H2uECKk?mf+2
za7!?XU~hoqa?b|c5I;l00)ePVk#xbdY36=No~_;ovK*OLlD*OLBxYHW_b%pXMECs~
zZK*zU_KSPpph{Ktx&WL}#w2s5l{<AK7!}yi05ceN47kJHyRckCfyb!JN@Djs=1eQ`
zQxH{GT?w<U*I&ppe1unxgJReyK&Prm4$#SNzrjp&<pwgbzG`Farq7XEbsD?#J$ZRj
zz|Xf3;t{oGeZ*<3a4)QYNmnM`#`yH_7@zvMIC!;s6huzTHVcP_4m$31W#NpJXslRK
zCL3t%w<#kFYELJyzjf>zO{^*AlI6euP2NSZlx~)F>^sZ)^}$3tmb%WQjA6;(q2T2D
z9GaLjf%0^q{5(*e29&2%k4lWG9-a6!TA5GbtLND2MTw)(+8kbea^leHvl53?FHQ`u
zb6P5lYG%`DZtx741!2Cj3bnh23d+8%owEf@2cV1a@`d7bKyY0FAxLtNe>J1=FZ<zt
z*5vpQysX2h61z<NoEp~Vt+$sUK-(ZAPy5&P#DbPU_W#G(`@lz49gW|+$pQhR8zpMA
z5n@d(snI5iHX)&gEJ+XuY!Z?H8n6~=jM}2?LJ*QHY=T^_3u&v?wp#Idw6!hPKebA!
z)c{JOQjJJ8Dk>_icf0BHq-Ze&%D&$@_ukD0NqBy*{gm82f9K4ZGiT16IWvi{6!jW$
zY*;*sk62H8CoquhZXK=g*5qzG0t`hJK%*V8;HeUDjBmz(8F>!FcS1TvTKssT=7@}5
z^WDk+aXeSkjyly=aICGWUoubpY&<z3(J_A^Y`h4YJ~ap7b5GKriN7`fPyM|PZ}EB~
z|1H=8hcC#o-*F0p4ZkewByN3(zQNcBH_&!VRkRJBVQGDhFAZg%sXkEiYn5H&H>4(S
zQgj-E#=b7T0b(1QmyG|yX$$lxCISAJV~t>nQe}J{%fj5l^5(==C4LFMc~Hv#0lw^E
z;LDD|cNz`F!6&?pZ5Q|?Sky4^-HEN<@bFpA31D5CC(T4csX)6UGJ0wIi1=*X>mQ?a
zDI)@6QB)ZdrJt7pA`*_%S6TcEeP^%sx+qR~oFH7nbnt1ZL)JiQ9N}f7{x624Uny*U
zuoOxW?Fg4G##Vt$S)6T08DXZ~r*JDf_U8&4rXa%pThgm`2jkPvEz}G)n7=yJ|1<qc
z5dk9i#ab6lh_d-;D;OmJxZD0Hz*w5O)?3KduT2eqOa9srogeGHoG+`Mx?HlgG*^<2
ziWmKBVyF>CMQZL|6t9UPui6t$$+cEFWl^hNhIyq4ae)HRS8g&Vw7%PAzNJ8_J*4p4
zEC&hP*H^{0RfX|$Lya}uK{8!gT4=KY(WykXvkOWnGn3!j`qn~jw@W&-*YaOM=!GwB
zoY0Cz!Et&E98DwyJ@QZBD6+p?V`_)+gZd^kFDREwpup9m-0N49V_hsBE@ihHFFT(p
zdFp2io^gGumvrdf%r?jde>#(7DAgTu&r+Pp-8T0xR<K`bm-CbZ-_)4Q0@fjYekQ})
zW4w>a4W297Iu<Ty{ATz<%FqHY$cr<bMElK@mB0(o4&x6}t`4UTs;FE0g1v%mU*h}H
zRiam~+ruq@9l>E2OZr)XgU7a}k%_YKik!BzofAcooGAJs9d)1P^`d|6@ETWqs_^`f
zMW-r{{aK%;u0|zp!b37>yP7^HSsM_@<Stg*rK;uc^8H%uHl_lcJ}1@8zghC(G49q&
zNw&%9LcVPxct;VnwB<J6QYbGttfMiaR+M#An=Fd|4ny=?vM0G)-(_-ignE^nM6x8F
z#Y;e|(a5j$vSjA9<V9lu)REhEI>-$i9p!HOI>iB>R;5jOPp{z^1UKEZX~UN&WlGby
zQ&dzwpC75#yK_h#Ig{J$vZ2K2wP?A+n8DU5oQvJt-I^ni&Pg^`g1I(8cn=PB6)6~B
zu?i~`J;Lsd)#VNW>~aAN-?nJ~J1UI3|E2<@sL0A2_*U+V!xG3>#-!rK#?aI+dxt`k
zxG1!yhQqRqsVp`3uv)Ck_)fz&gBl+zm($NGSDCiTRjES#Su3~0SZzwsu;`lxC(K;6
z9mXO{ynY;514lX1{+xMLNPe1>U~?Mk|KIS%RcK%ekDh-a-({%<#T=K!#aj4L{!w&A
z<dU|4q%7ed9A=3LyO5?tlD_XC<B`oMTt+HBQv|Os(354~5GgPrv*@Uct0GyMO1_qP
zFoP-dihNx{L{+Q|O1kq)_PJYE(*{X;^&UNWok^~Euwp?P(!-~5^dQHa!IEl89zsSl
zvHVF~!MFKl{;IKD=rDeO6pp(Wk<Sf)VjBPQiA<xp;&$+j!xtcw-kwxFblC*>U+QNc
zIc*bRx8jJUx-VSFCvZZ%w0@?vu4rrzGiy$Br@Qqc8K=Ga{wc#zL?ml`E<Kurb6o2F
zORRBds7ng%uzL<eGXl^@!p_Q4O{$*n@@NFLQp=0cbQnuGe#ngcK@J+R#nh~@r*t%V
zz+^Wm&O~AI>N=?PpVBT%OU`>&$pp+zQ%AwW6w2>%Z_bgl#q25hJuNQn-K?EiJJ^#U
z&jrA+z~znKSUQaT=ED~OcsImhLs;G$TaDYz5-O08&|WFDcMed8v-xM^gs{OMnV~)z
zm)E$2i{tr&jFXv@VZO$|*p&Q64M8ibjL{TYxFGThaj4Zk#ms)j<?_P#dNQ%$d#R_a
zerfp)N~l?qj3zRMaA*LK^czXX8dKIX;aG5Pv(r8s-$2gcVs)6VJ|G|N*106%1_Q(~
zV=dnZU(IiBLex0EOK&u&mxwWoGKi_(pYKg_-*vw9fT>R1erqpfBigT)JCA&k5*71l
zLo}wgN#6#PP8eh33DzNe-~qk-p!Tj1!Di%nq#!}QJg_DpLBZLwfB42J_}aw3fGlF6
z{5KCMy!I|M(flGmWxUr3ao488Uh{W0<5rmKt*{%?3AUs~{gZ%RUzF;8d>2LXceWhB
z7?u40WuhhDx7(c0W`p@_>ScO5YK)s{IELkOfvN_3LII$X4AaorNvgf=6_P5{C}x{c
zpQbNP3m%R7?gS;6k`dPC5p+tBVi%<N3Z%FT_k+t6YpPXP{?CVYqg%lR`z7*+DSsw&
zLwq^sau9ZjX~>nyA9ZdXeb~b^o`E(DG51>5B-=H<gCe6vUu3x_0>N^8Pckmy03!aR
ze19`nlkY8ciCLgT5Z{}MBF;fM;PqBk8Q%vSmCbk}&r-btA6LeF8_3ARv3N6FXG{Dv
zaZ&#sx7m2g#*Tfw5_HZL@cd^gBt{a{qkJU|u$}f8TcLb_`IuJ-+P}1S%{%_^dSvyO
z{AJ7E+)axC5RdhJ7ovP1u4v=w!GY)+OvD<~^1GX{J4VL-(+7$W2oxv*1KPD}Y?AQF
zXKJKMlzs}cAUV}afp9Oox!F_b1=7rTg~}pX?!s{sbl5k6&cs3$=}9pGXqq#1mGLB1
z!OKwlOJJxmz6A_$<r?EMK1@;R9b5k__AA4;FKRTq{fc4RfBSu_{nz+7p?#ZPFdyN;
zgP1V*E@z3P@P9lYCVGwSDEa`K^z(=433@nCe_#s7GD`}5%3e#L74vZDOWaNz_FY2L
zU+1pwq6!@SjjuG4*2h|ubKee`SgxbP8K}9%F}*S#F{l4fjGhI)%Y|bB(%bFFk;TQ<
z8K{PuBZ;|d-7(X!2<LX~3ap{_B<lQ>hNY4}xnWYAjO<&Y?fT<55PA%pfA|?u1(M{+
zD%{O_vN}~<46G>!2;Sb*JHUOcwz9AB-B77g<)uujTisPK`b;T*MU7F3eX^Q<J0yuZ
zFDthNk*&r)a<xPj;)gOu+_0N+^9k|scD9pincEOnLhNNujQ^nQ#l__OwJPn+6@+w+
zOhk;`iWrO4q;2N9TbeP78c~;n!^6IDuuv<{LjRD$NAa_LABYJaCA#%y^)Z(6!J`@O
zyLXQ5R;II&ZShss9u@O9_vXJMsf9c*1pCihu`uL$Q2thif<-XhVE;KQ%0j_O>T|-1
z!nH@gphnB&kf$5>11qwFM=!(Y&(TY<Fgm)}cR}#z6knR%>H%6^dz2U494Nm+1B&G+
zS0E>YA!!hXw=5W58-!ukAPn0q7@nX<H9TH(+rtaL#ikJ7y29Y|D@+U`B|SsFN^9`P
z(!?%PrPY|24vUGp>>xjpzXRj&KPxD;LL*(+t-Li*q0+c<rD`O6Jp~J@liUyNET~Ji
zO-3j<!)&?IxZi|8N#d&Jd$*Z2FSbi;w@Qfls4AgZ2`)Qfo0agH>}%5d7_0Y>?Sylz
zgg5MjmzJ5mNMs~cWuKKGlDJCnSXD&iRtdNJ%qk%};UOzwjh*m>m2k72u-HmiXea#6
zO1Q>Oc;I%k(L6ih7Arv<sHkp#ZY7*!C%m%UtTM_@_^H+C=LoK<%A*zvKd}?uwi5Q*
z3G1yYJM4rjt%N7+gjOrzK|A3y3qhOggmqSlCOhGWR>CcI!u3{_Ywd*BP0|X_v=e?|
zCFI))r&|e=ND!ei#an6o+QLApN~;e{C8Vs8n$BRA<lpu@>7k(GDIyd-Qo)j1{}>5t
zkB-UVyY(TJ`Qhu7?oV>B{}DgK@AD5<CT2sgvH-1y{HknRLrX}o8=9{&V+~2{aN2l6
z0dwbI8@Z&1<@$rnEh@8NFjGc={Y-~SuN+K2c2qWw@D=>A^)EPx;lLu2;hnIFwFAPA
zS}L{fpfQ$PtQF&eDC|cC2PQV(tS@o}<p}#WB~~sA$|>>>!dcco!oNXL*5LY#50|fq
zePNfVyx6U<1UB`ZC4HC57BMyYmcy~)_ejx~Iu7vjKNI=+u=+{%R7~?7EACN_0qyFh
z6cId{vNETZ0K#)pmH3<cGS|4qRU#wTqzhj6`t(8OOe}&m@Vk)b{$PLRiY~@{Ge2kf
ze#zH&_@cl3QkXLS_<(Z*(xQSCs;2Au?iwz*gJTni#van;{S7wl3^MmUT>IpB^@S<i
z_g3jMlPdtHG70azea3$yw5oabFZq)Q{AKygliiyxl}>ril)6n%;Qch)e24!9uRc>6
zs2JLSc=A>a_+E_s`Q$~ejum-`JGD39PceBh9qWFL6GXSKMJ82tBeCUg=P$>I;J|3#
z_e5Bq&s>i7U6=o^dwq*!`8mTJ(0VX6!zbzfP%%_IYUS<00cMr?;u4>U*VIRX|6(=w
zuS>P^1JYPUhVd9oLU~iwnn@4y7Em-$YQIsK4V4}ea!L-BG9#nhclJ|YFt(2GUbDv)
zn?fGxdByttH{I*jQHBRH9|VmtQv-av?-V^Ko3z3Fu*I}>fnSMc$$N?7)B>({&8YSQ
zm482m^#!HrzOjs+X(re`AJzt9>&6t({+vdXHG8BJEXbRL(u{&)MH^I#JOxtTQa3xn
z<Ez~3{{gO{ArEi_kKgKEFGgsxqSWu(-0NR4e_y12-{fAu-TXaX{XWCpDmQka(tG9M
z`ubz!g-SOC`^UJ~i~G`0>3WrZP<^ix&ynkU<a>RSRF|-VqNJm{7x}aHxGY%r`uS$k
zll%!DPxk*8*<x81Jl^D9FIU$5zDNB=HrdEWsPspwmuB^CLUOzMHhY)5Lkp@qSI{r@
zt4UgWT&BalKFmauR7_IvI7S+x*|H{e{Uz$#Y+h7=_CUw0Z*!ny)VCVkoe!989p+EF
z%oy`lld4ZkH8#H@)D*sgvdoG7T%?9KU+zs3V@76tnp%x#$uIxG-1m0;U3}~+YQVZ9
zPv&tl7ub1v;eG0bAcXu51Hf&DB5HZ}5)|8#7v)2IbmIPs56Ju}mBq)e`N;2Hk)-u&
zU%(|1xA1!?<#7(cL!96dehLRvxBYA6<A~F@64i*=g!p|E0~jS}vJx5P+NK`4DCKcH
zKZ5<=b+3O^sx|fSrTRCP1p6n#QDsymJwf?-k^4^3v2k#?if5cvx|>r|oESQT2SyhD
zJiL)~Z<d!SI?rmV51>yt$X9+bsfsT5hCgCsF!`x|m0Fz0w2$fMq8NWR@>}?l-$18P
zP?od?{d00bDe{zQd>d|26gb9IyCZk{-9SCg-L{hkl^U4veFQ*I*uX{6&&**#@Dj5m
zd_Se+!3N$U$k4~|Wi3T{I#im3ZX&-lx#{xoRg|{it2RVk&+ryY<&s`T)5}Fe{+wj@
zU2^@&Ols8<jgS*q87Hv0Ny3Dyd%>GA(Y&Ofn+>v<f=!0g|2uxQj;F22Q^9^WSI>Mh
z1`J~!qDc4%d!ho&7X3?%@C`EPrXFlw-Xm8zROV-ryKRsBY@iy<sCPb!?~<NNTh-VT
z-1k}-D_8Tt9Ja`Evr}ccsF__YUNr1fi7BE|mkW*Asi)bgKZq|Yj;vJKo8wc(k(Ell
zQHa@Y;bl_o^RZ=5%>HmtLu18jG`0m<62UtNU#g~VW6^BZAa>coKBs<7n)%X?CrRjK
zd9Nn^D09V~is^kWawe-Vf0oPVFAMHYEokcX)uFA@KI8G2^G$g-<o}RhC#VqM&j;98
zJEzHIKTG!@OBeeHJ+&R17*Ti`*UNNPA7InNhJi9D$^5^e8~L;v_w&fku=%zeQ$=-L
zon(w+CzOe8q=`;X3hM@Cv#J<*$pZ9*iYM4N6!HvGFPhFhK@rcLN@C&J_3G#JnX~mf
za)KW@+oD=IJO2*g?<^4pfQsWe(aCxy>#lY#iv)rJl7o#X(l_-fAiAWS<@8qWXUg~J
zbqCm#oV&ETZv6@|0DDxbtahPa{RLloT^E-!n|{ovpgA($96IbIAi30^mL5vak@Gwn
zu#a`I>V;=^7ff^c_vz03omhx>_+G&dr(mYbzcYA*Sv?3sf=5RApGLFB94b}0UZnK;
z7M)Y&Cwg_aUYu0mN%G&N7bh2ZlKrjHH}0swYP6uK%fGfA1-RaHpose`6y?EA-j{W0
zO$YKly!pFOrq3_$MN2jQRKJ*Ck>lR{j!^G{92wFEps<)YcQZ0a3V#P}{3-F1@D&#R
zMycXz5@Qb|_ftvDIoeRrFgZ;>L&k&007tM{Ft|nXg=e@o-NR?D{j@StYVs3hSgnsX
z_Mrh|%xRsaidZ!Nz8Kl`P*2p~j7~9|5+lE)m*?o!Y$#xUj6TaH?-Sk^%=;hLYuHJm
zzSkKF)Gb3vZP!HCBceZ~3`If4PYm`Gd01~U*yhT_GOEb{!Frv6u$8~S#$nw)bT{L;
zzUVAUvDON20T0SU-0Fi0sj~44?n-(z-aE%pYmp_hs5Kjwo3n}vy)w0u$@UuU&r0n2
zlyC~k)&xZUc%nYUem_L~&jT`o6W?=L@7>=7c^*9lD$9BUv$Wr!@MHK@^|ve#rz42w
zmCA&qA+cVvc%Y!JBIIA=ynFirgDX(cALj1G|J_S040}CdwJ#AvXnw4oM9YEzTCS{b
zRV_;k5_E+BCF0m5zTF-7sCEe@@{G)&rEj$O9cEMV3|8GAqo~rolZ5YmMTiZ{yXyuO
zQ|eyteA2aDwGG#aYHHQ71V~DZ`Z`OCq~*@iJo%%~oYYyWY~DIcGbEw2G}HVuN&Vq=
zlU8a}w{kX8`n_bW3LPtovNTo3ldcNk<EEIWO3k-%Hw-+3H_@8BeRsFYK1waE^O!!9
z*HSw^O571nK;wobUR8F;wT>8Kou!;V1%}DypXuhG8M1UcOTFf=`SJ($X`ORGJ8>^m
zmS>*)iTn`;fS;h!RP#}WdS~0Fgxk2-z}x?usmSdxywDLbC>~e84J8Vmpl!Qb&LcJ2
zTUf|INHD4kfmi+%ROK|!(>*zQ)nu(Sg%54=I!rxsV(Lt=0B9~?YDgKJ91p^tzYG2H
z^FUyTeI(6VLx76p*}Us4a7Kht^8p~wIK&fzb<qw{jnX`mBkNUtwBws(yR6E_JlL4%
z?0%!4s-kX^UF1vq<y-83))ewi7~|FwL#sY0{9E{%yzrJIguaMiMKc;_@Q^k4<xpyy
zU=`ap=T6p{z&9=UkJS8keB6}u<`?%OsTTJYl%*hV!DWg+=iniNTEDNwEa&ereO5Gb
z4ho5^O0)W$bc_{{aJ1AUy*5Rgm*kS`%hI%vE1=C=iyHZ0><2GMCAo9@+7uIzG`%*X
zNMDqq@q!gM4F$EC?oC?+#M(@~Y?79ayqAf+L8iUM$~2UwCQ+hZiVe<0DbJM&+9*{Q
zrP-kcI?FPoXhX(exw1*j*hAZoGhZCGjSFBYl%kL$@^hK1($tEOtGhzXFF3&CgJN*1
z)(9?3)5GelMA5R0xM?k$G-O(D)5<29W-%pw+h3(Kiziv*2$zUh2Ll%~RmH5fAEZ#^
zKn$=}3NTUuEF6WdV;MI~&6?Cf5@Bt85MN-X6sXM@EKrsa7V`^}3&rVI@MoeiQEU$=
zT3|lU(wCmTK`bz~$|uiG<p{C<L4L63D#lm9=DkBQXDMF+O?(b+X;+CnAxpGz6%HR8
zaNvoL0#`fZ#46D!menB_ih~<jFZ*<Jp<b1)^(&tON-Bdt`Tv+-ZTSAG&%o%k@hWMi
zqJiM<?YS>kYS4V2aoF6;B2QVaDQ)st+K$dFiJl{^CLk9H_riXgT880Z8OeULN?1^W
zj3?%P8vEBskE{n9KiP;+dgEkSMsirvi*k@JAhAtOejx>6k-Vog|F#_WrWYkU{aLoi
z-r#D&mj7KJk6Oa_q3%f+zXATY*pt{T8Ofgf*L+>P7IduQQkILFRezEvT+is9OlkN!
z)Z9BhO0dEbXdF5{ljOJv0$q2C(ZLLb@(hYumL!&!hR8&ATqJ`YL2U=V9(v?Rg5v`(
zP6z(QF!gdQ7J8NAhWuqNKl`H+pepcWfNJOfw$v4R>bZRG)04P?HtrJ&D&HfMwQ6$Y
zzi>CePPO?)TC(wsl!XaPpL@eO(tI_q1nyx*qL5SW-pIwlf&|}~&O~9B$Y*_05_S?a
zT(GEMQy(Z*N8WNnPv;2Z+Yj0tzE_&}De-cwh<N#{)0(f<XJG^B>{3Yl2S@~ipX8VK
z`O1Th$&OV$i~_3W9w}Y%X4BYvdJg=i&s)YYXvR3hq&bU9lsbi`TOJ{s$qg?SLNJkm
zLyc+n6i*<TePo;`zpl%@DTQC5$qz6Xhwc(l)(GZ}@_%CdXd9hl`Ekc&eP)hU-qq>)
zmXwLSENkiCQX0|t8p+|EZ#~ylt_P_+MNMP#6}aXBRb$(WnX&v=aBq>rDf*DUj29TI
zBD!)raj@8eO%+-5zNetBYt0`8bVZE0dv(`OXc5yfb=g^*U)|NxE9Y=`>os7ebDCHt
zJM;x<d<n6O$g37C2Je<*l*ol<8)rfa2#@1vO6p)HRvO%untxkb^F@%2)?=^Ea4^r|
zr+*>dm#iW!@9TBlOyk#(`6E9Rj8x{}97Okbu@`Nw0ej)^2@0Q9@0o*5T^vPz&Ah1D
zfVO1}qnT2tuc)}7y37AhP%o>?lfQt~wULrTu>Us`)DMiap0)9BWBwK3R#B!<{;?i7
zgm4hdbZ`DWv?+@+!FQG|=OiKoI>LF9!S>|(iRm>Ua-hAsZLcjMn9lQbZw5Qli~?^a
zj$AyMI{t!2^VgIQGGp?A+UMgp1kcb7p+fUaioCE??*E9O_a!+(?MlcIlNKUJZ1}e&
zM`Qq`Bl3W?cWh6Q%+t)w$er7-<R>!2LK5_<IDYTR5Sd|#;5=qez*_=u9^<Gi@D?^-
zLV#Yqs;JYolQJxz!p`YC6-Usk3RT$TLMvjBh{3M2c6{v8Jb7M3m!ircn_Rx;DT@4F
zjVMozC~lwi6tU0##D?)1QGC3DWTXVu$QC>O7o_V|dDdP<2@!enA_3{xdaoRJzwIAO
z39Wk}uj3i_SAktryN&<QXBCB9FA1*T7C0B-wNHvR!xh<Qj=wh8i!EJ4c1#F>;J&Ku
z{Nrg<kgMXiKl^QG0$kO>ixFvr!8dUf*giw>+iwiWt@hqXIJSS*RLR{lv3`7Kv90}F
zz}SU)y3g3cOsJc12{bVXzx`eTi_%w7l1-2;%8Qj=A4dDpD&rfR{9v^<Yc*yLHaJ%r
zT$F~3#Q641YXW7ekZWG}e?#u+I~rxPlNTHB@Vr)b+yE`nG9KPeLv+DBg#Aq}7OY@!
zO8&F=JGpPM-~&9_Xb0FvwZ1B2qYzvie7}LWSOb2X>HB|$kJlpjbm^<m-ueFt-v!!$
zSDsQgL<M`jrb^AmUb`XMDGR(53%u8qAReP96MxDf19LcmRdGI!b^DATf-d;j+13=A
z{3`c7^QV%d<<0$<&!^`6iZKjx67`kH<L14-Z)+dWScRGyf0nmi93VABYeW~A3{_1w
z;ikxiz&?2X@z#siq{v^@1(21DQPE%->PlP%rfVmkmqMJ{%CyLR@%H6anuNvB-fSp}
zC;4we@*;IxB(E)WA$rQb&{=F6%b2gVggm;h<$7%U0*n5!(S-g#jnThpe?h#tH?`Lq
zQscWgPtJsCnwLE|SzG4Pys?lITL1Q&gnK<EjdkE)EbhI6YA+ohJUspqqj)jANBs&R
zqf2W-VR2A))Ez(?yu+2~yP&hwl$d`+gMt@jHy{3tw-PK9HXo2bwV-Np^G(>kBKVaX
z==1PO)TjKFK*?gQ>l@F(MmP`8(L9s2WI60jwuwkMnkVN=JQ^Q={;k`e5UlhW5_y$E
z0Og2uD(0UPcN&0Q#-AL{gQ<nT4|#3BgW4ASVX>mHo4beR^s1aep`GY3w~`;bKNANr
zrg;*vVAy`~ry^?}-;HqxVZz*UX#XdF@=Ma!{7r94Z;Lj6pp2gY`6D44>^*&Zgin;G
zRv4QfKN8h2LoUhC$_lBamBByKwX&4XvLw+KP)S97u3<M-k2zdB+urMx>r#0ED1UsD
z;ASjE?TA+`>nh_~dG`ZzGoHerO|Z>zY#}2dWf`}k*3$Gt2RN`*`;)bP{;%U}92{Q>
zhrYq_Ifsm|1O?OMzdOSIo<YD~0i-Ndt1U!2YLi27XPGG-RU>0+wJF9vpw-nl+ujSg
zcH**1OVP>ny8KH3UCa|L(6`G}Rrd)CJJJwEYQ_?0DZ^2N{<HPmXHl9Qqly`~niF@M
zJdse0nZ_m|UxzO?^FVocC7&mvG1YGI=2(l7r{nRZb?QZVte0|wC4=mC8k@dNz-WTl
zX#PhpMm^#C6xmzO#_f!n)nPqJXxrN|K2nN3e|aCeyuO0!zUDl<9O4xX3BdjMZl0<-
z`*a_E@(wq@SFk*@<t@g{Qc>qQ!)SY4)Rq1^Xg2bkUgo8rp>|wqD>A%B_G3a~jILKJ
zo53uIenecBMZ<Fy0(t?7!*;Rz@tyIG{KC29&cSL|TbajDE;iLP9CVVTDfi=^oJ0;4
zu66t})Ll#T4I0-yC~zj3egSvuE^f5BKwCshawTCYmeu=^A^WLGe>@8H=D=0UISc!4
z=4@PqLFqIZ#-ho3>GaxAdXKSqEA&(|T}zaMZMm!nZT3!iiZ&Tp3iLWekdnXlL@Xtq
zijtp7;SRJiRDMF$G(GZwaGN5N+r-IFrPD$0+U?H^(`@8viKR}9JYpu@ND@B&2Khy4
z4qje|oL{SZgd3Oa$4MjX^G#MO*b6qgK*=om!G2XHjN}KRGWv_8Q2aB!IEjOrI`@Cd
zKuANFHvZ0Tg@Dn>F`P|TZb^`?t9y*^V;e0EabHp<3P}*I-InINR$W-WL4CPnY7OuK
zMsOu5W*7Qmkw`WMTauFet#Vj-kWENz$vMC7H<D!?0`#&ppf#F*qqd90c-j{4AwAkV
zmMT{2^sq!K;~>-CHU5hIu`-mjXM%DtHQDZD74{epQzs54TG=bY7Ox(BKf-2OeuH8$
zQI+o%ln%>Xc)K9!4Qu1{sy+$crONMQD`uT-@Ir4QR|u9Wvhxq&e0fz;lIeI{-ka<<
zCefNgKaZA~jc<c{_nq=cR<LEhW5@3Iur)&Sse){d|KhEX)HjeAx$FK1@YqL#eL^RF
z29%EIFNPOV&LJaG`s3$FF`+!hleF+z@>7foOxMqdhs7K~FsBzPpkgOOLG{3)VWurv
zL!}~I%M<#F<eBisiWL2t%$e{<y*3+*@%_eA^u{+9kNo0p&2UOWnZ*2(wtorg8H8vw
z$`4paR_+r>72TLj45IkVv~Vi0K|Vf0Ehf3!UV^7XpKbCGO**+$L^`hX6vlI8EZ>qG
zMWw9Znc3FV=#`lUu5zS~J~tDvjNkJMr2T;g0mG)A8JW5_TN=LG%vKNiYbODsB({(k
zF0;CRN<=M%&F{-bqagSlCcEJxeuADjY0E4ohi-%|C3I<DpdA-<yR=dlYfLK@)N2^(
z7o+=3QJmVnsTlmj3~3DU!Fv0piEm+d>uEAI;w$W+U`$yVwA>LslT<mF;h@&#)mJCg
z>c}<wjau_aAsa&nDsB%G;FB1qUgLpZ!NHn()ts=;Tki0Ywwm*t{lek7Rvo9S%}Y%f
zw>%|D>awTlpw>J&zY&|E`vrg|Zt|0Me42pq5SK>IPQ)y|n9n{v9ZO$#+fuNm_1hY%
zN1$9JUqH)d0)+-(8Z%kq`(<j<NMmZw=QOUQL@C!w>~iGWslSxzGW41}t0`x9xSFQ7
z{~Lmra@R?@KBJm)Li%s9wK7n_RH-T4mMY;^ugK)aOHd~gIQ8}+i<p$T;XzS%HSO2>
z^_6MH9`;>XxwS=@idl!sZXtPE)l!7|q5Ev1`zm=^w_nAV7n(0WVE#UhH)x{0HYsQ-
zL_;^>1VwiH71+k3yuT7)v*<W>{`#_fCok-W%6GOTcdo1gk>oy>v6kQ&lQ=nr6~+sX
zu-U#N5}h2eB&Pd6ZHuhNu`t~~$T9E<tv~lYBl8giutzL=Z-TKAA?v+{L8_x|5AS{&
zcxF~*Bz;T-A6D^U-x-vvG3L_^zu5*8Ez4@mr#n3}1ii5!LDQKfIIMNn9F+H2<?4ll
zu}&yN_-#(7={Umhip(QVZiQa6OgU4<87O0t*?!LG^vsq%u(p%CI_TOsonZh|m2vlD
z(2%mI{>Zv+i=Fq({T%~3h>r7FlD;@y-e`=2{aXhtW2wNhn@yjNFEd?Xo{M13eyUX1
zIO}})Ve!3rGH=$r6D;Mjf@M63$B|lTPG_kaJ3AtRfnJuOmClAjFFK$g?JS+7&}3eV
zX}fBScem2_Vw7y4)ZVSWET7bCyBhKanL^1HVG0)sQ}A!e?Kt+wGXyWfWD-R^l_Ok+
za}8VuRTW&uGf7=*6>`6U8b`01&V>t31-L2JJ+rk^v`4-h8T*CGySV>+-7^F6W4vA}
zGm)&Eexssujq+7=ilT&BRwtiMk9oQ0$utwqp?M0;Uq$jqkZe9|Hm5}q(D!76Di!lc
z71jbnD7kNm8{NY)x}T$?)0<tLrfCBwnVA?H)xZK@l!hbc=;hp8zo-?iEz_D_)SI>x
z<(IjdFXkm4O7~C5>~yUa8jKv=o^UN^wjLwrV`$`X_$Ctd>McM53qGOat<v#0>9|}K
zn08`;C!~N!3N&reTavjS*wlr{M|*H`9ZLZhFGMA76MB9gEZ)Uer)l`nS<)qNca}UV
zf4BfgTZtZ>_BOpt0+ySnGwo%VHJDLM^zyB+c0%6ju0MK>CHJW{$8@}}mprOhKcN+-
z$i02_7DmruncKQ#_oi*qGJtWdQ*LmXAY@toC^Eai<!1_$5_}TURxf!Nbc^@+`FhC{
z)+fNoD#u|p`mLs|Qq1*WoEKQs&wk|vwq)yI<t@2~tsm44i@!L%Nx)N`bZM@0^``Dx
z<Kl<dcJNwEtI~t!+RVdND2c0sVsypf%VkQ+yVOQgg2l!`s)q{OK%T?>_>tN;%6MAv
z{}5HRBal6}&U(|+vbApMEZIY8hkl1k=47SXE?;Cw%A@zw*6tyj>kh6VwrS<}?=TXy
zlKa>UL57~ZO}!x$PZeq^ky8%pu5DbZgj^wMm-C6<)T1+;r?u2PE?n?EEmPMoeNt9B
zdc*xVuPmR#D91WvS!OnoZ-mO6`Q7d|aTTg_Zoyy$V-9sKf{>2Y#Q}9!vsKzE?;%_4
zaXPgoWEW-H@v4}@`Cif)>=V{yP;nuoFh+0M14o;tS3j&{E>yUYD;!ky)%S;z*Xd_+
zD7=%7aRy$#hcncAk<z*1;mLW^9!j05R~BlicPa~HnXU3|xVX244zV5bjYoQ+tX_T}
z7-p+RrFxIOmJWU(GseC17ACD%4B+Ov+?#(V^Ix(BPnn%X=?oSdU*8paBU93RUal-U
zL?6&vW>h~Y)wkrYa<znML;A;1E*8*0wLt)qB$^OagZxoV$<0HosT9@J!e3ZTCC8e=
z_HIa1)z}${(nIr3(q?2sbUI$*o3?5k_-16rgis|YXpNIkx;TWo9U>@{Z&66^oTe-#
zd?^Zbdj>(5-_=iB!3$VjBQG?tWiGUBWrHA#Ws_QHO<N&-E5<{39TE#c*I&j%ZMj+J
zrzc&U_HtgV`?p#l60U_CR)l9DUnyuGwxH#?sa;rxcOm&PCUsC|Peq>MRzmovacI9;
zoe_oq114-rc-Ks~y2?E)O^p`mN)YkzAR_Fpz{yr`_)l>y+-J31x7B(YwLmI{<r-4-
zU)Fm-<d@O89isf#JxT0NpTW`Rz|pmy1vt(X{Z0J&H$6_CQu^4F>&rxeggz-fza#^F
zSxH8`KIuu07pzeh!mCP&!$w%07MS92x2*#=GCa{S&AMN7OiCAk^$Ux;I#cr&D%BC?
zGc>P|v87D=0dkBenNS$MBqZ(R-fW0E&E5Ji$*2~*N`h;M63}^^tTfR#8P|*4Xlm5*
zV3-PmG~!FYo#0q3B4EkE3Zs=D@FNtc&Ti!YU`K+AIkmwI6rzMis3BG9O)6@QIw>ws
zl#_S6#;j5MMp|h4xlWp>tRP;L%9i88?&(~E3mA8#DmV0i^AMx4bYj0`2E!%7#7p`R
zE<1n5PqFS+@};TY{Xfr#==V-K9~W}iI{AEb#?8l{e)gsLz;QfNBAP$ZfmwH)YN}*<
z7|GiQPn;L#ukAh208+wb2BDzb<4k}x;-}xE%8+@w0UVg~w2ddZ<~)fK@B%@LXky)M
zXYpw(0WZQ|M%Zbh%%m12nAns0++X7+^>KcjVp4B5HDOR>t+7Fhml!gmOstyJgB9ki
zrtzHjCY9Z*W)v{3NmWXN>f{R1n4{2z@O~&mRD|~_%giD?wNtA}{`fvQ`!dNVk+;|O
z_6i+y$m4x*l&8u=Rn~FtZp<T1zcC$jsMEm5%zmdwZ5|rel%ml_WLFE%f4jZt-ZG^j
zo^k3#QM)G_G<xgD!=>tl6e^7gZzVWFAxYMfGsVBJ@h~;e=6KR%Vf9M@p}nYx7!;fM
zhMfZJ+!@o_4r_B~m_g$?3x;c`FFls0RT$a(5*!O<k*NqB6-GM0^?OpKhqg5SWwo`X
zOZgKPTw4Z-4B-ai-by*9iN&W<y~c-c(nv^3n3-xBI@jp;NXgLjGo1vSmCWiid4~OD
zTxr#ntV+yLv{|X)e=`qSPwru3_D`6V2V_>v`z!l=8P5-gPDb4QfqlMwR_I)vFV%Ix
z3A1pOJqzBSnCHMUiN<Hqb**s+dNT{JB00gfe<8=tpW2xGc&~*?VOM|U#|V_IxbMsu
zX|ra%#&4twH$xWJ0$tUH!WFs-6Hy!N5+>sk6wOTy&j*w0=$myfC=wlXY`+j)IyN}X
z*UZpYPU6H_mdTyB?z&t~($g<@X=Qo*Nz%&FIMX4xQ!-8WU5=@SFEf<f#vmPfOSTB3
zpFP5fSCpKlj@$b2P|PoOI<8C4m(BEVfY>>PT~bhG6+7WRc9&i>e`?^~`y4IHi-=pK
zdFIpKGF0)F2Bs=gUp-0SWD(3t(p*z?Po6e?3coQ@NZWA$Pnh%al6bZPxZlvLGPSpM
z{N3d|9&Ao_xLbcBFkh3ZFVCh04hl+=UNa^6vqz}TUDyzVJCA9vFnF7YErW>R0cm7b
zhSs^`BbU~v#{XN>?!a|brRK?yz)GVCS$Bdd#0^r%Gb!s|z(Y-`7b;|H|LnKnuY-^w
z3NV4YG?^QDhI&ASWSpLd2<R(h$l(G?Z~vB{vu2;%#$^DHL;2q~Q;SGF!7?J8Y1hGC
zG(&17B4tFwr}NJc{9}LLja`eVU5UR^-i0S1D0#>wOF4QWd=dB}x)X84(AA|2kxq~<
z_sBE$l5Xob9~S)uhB2ate;82!LmA7;3;QZW<I5<@>4y@=t*}AqcKLK>(<&5l?bdVj
zB91Lx8pbz?`q@HHoGnB|3+^n^sympCwj~TfN&4>Au?Wnn6$FxQByqtD=M{ZU8rK{7
zU2B$xzs3nljn|IMvxvrkZ^Lg<S^}Tco|dgAw<Bxm^V349Zx)POb0!A-ykX9LZ^N!x
zxD29(l)Mdl@owFd2GyhywG3lI9ItPBQQDc4j<ILRwN|Xxyz=JauR31ziT=`K1_$!5
z#hOVdX@;Byo72F>?_&n}vV%Axa|;%^+##{2SFd1Nf6Et+RF<XUIb~0kQLb6XVs~3u
z$_VOG<t;~b@3i1fZjgCY(yP}U%wL2p+&sY$=e<Sg&JXokrmpd?1x@>W-4aBpG$}Os
zue5-_&@|_3GA@Rn-cIjL8Pc=we4-^_v<|@dFW3<4^<p3|nBWeHQc|XIS!yJp^KRkx
z)UaPoh#)B3pmGr<n@hD<IS9?dFtG9Rg1UXaOQmpeQYiH=(s`mcO&Te}`tUhDc|*ZC
z_gxRd%LVV7@8zQmtE_^iKL7IyWLXFob716fH<3dPq(~Idu3EWCSy;&P&(sRNCZ#gk
z4U3ThRq%!_tth`Zt$DoCAG<eo2--`!jXPNbdfh%HS2w1x0HyinY&60-rCN?Ivqw0m
zY77%rVwokV>2!%G1-|!5QR4E|B-xx$PI$=YzOfROsP#8OB_vhvvj|q7EGt7Fr!7nE
zEJ~9`0RJ-GJ6%@C#gxW@Oi>;VO!Eq+O?HP;rT&8HA=fTQhc%$yc}Sn5!(&9J+SDT^
zn&V_3b$dkI`hlc^0fceZ)B8W-7f0%A(h)9R_L26Y^dmv+p*wkJyJ1)GD6VjBq93Yj
z62zY7J4YXrDU-N5el=vMT>WU}F%g4XsAwM6>hm&8-z-8A@%`m1(55}LMpio#sb6N{
zm{!UyU@8hh=uOAqd_}fCBNg_mwhl{M06}QomMM}^hyGSDo-3CiqXeXBdEs6t!BTg`
z&TEPpgg+sNle(~jcNs|d21XHV+K(5l?^x^lw$$LavEfxN)@b*dY!Qn^YaW)jp?c}b
zhapSthRq^ao5Lvff?ut8w#@7u^Yq)}hauLc!aZDil}!`j0l}(T9pTr7)}W|m+;BB!
znAES&%+{fN*OLX)54qM52}rG<N2H{`M{ibIwsF#g1V(aiiZUuG!}B8guW@1Oi*YdR
zV}HuM%re{oL+7Pw&FQ+_fD_V8hzL4=u-|NPP6~~ZU@0jgqiI-DAgh{m@%X0;ZO_S*
zU>&7-yn#q8oo=#V{~j>|=EC$fDdF$VZ%$v6i^z<^4Vhp?s^-P1+hhnEWb(eiz3E;l
zN7tFsb$Pe8Dowjh0%kI<Qn-oGht>*W%hf8aNH6B<RjWvcAZ0r0di2%F+OGTo_g$@w
zKX}yPzH2of?zYv)4$6~|xp7DrxgU{qso(}bMhzDsYRr(m@s3xJmlXLy!JVU_5R4B5
zndXjj6uq=E(4YxzMxHE|RmqVM_+|S6Zw^?QkW5<}q-Z+o7+@^hpeODt2d~xtCIe(r
zSa*)d-v^=kxwPLxuQB@}bqk18jh7y!->D1VN!=mx>e^nV3lk$d|LH?s-Lr65XubLb
zcH=Pq5oGuHSU?duJ%#gc7t*EHHe0ZV102K0Z|*Twf>TuNTAN(ZPQ9Bt?#*lYH`KO>
z1g%Y8rf8io_~a_iP}8Zm+cnWVK&6DHPec}%Mnw>xM4qmip*{0pT*Gx9GLdh&DH~%B
z!*S93ffDbSzduXk?$#^$mjZE09rYla*Zm!${<aS3G&3C)K^$0Nxt~xDmpI<xX6RYa
zDMQ(%7Q7ld-V()YuTjX|vdTiU{%W*yG!>(!`Tx-K08%r27(+FfF3eNVh+A7Me^C%7
zAp)1&&#H<s8MPO8mfWZ40ny`W@WvleH}gku$sd_A{ybs+c~SmosH%(c7}#0zoSE7q
ze`HCDf4U)(o&c?aM7G`~tcq)P^|%Nb(qxanwWVmSZH-`~>25hui<(NWdsG<zJMxKf
zw11zoFMyfySj^B(ANgow1#n5^DWwQYt<TGbQN7iIR_o5M;<1}R9==hUL81aN0r^Z`
z7fMyi8Xc4@OLHC~%GQoGje4ak|BaU0a$iQT+xjXMgDoje-?{o?{B|{-&kY1VwH`&&
zRU}Uw#)V4mHop3~=tGp;;ofja##q-OaLd~++7_tft)Xe=-zwHsq4Xc?i3QW&aJlai
zZ-q2SeVWutw#oy?P21^K1gt{y2*RPclN%^5%HHMLUB^`2t;um+*j2TR7vz-hb9M<H
zi1&u{;D1tI!L?p9k6NFgKPIn_e;w*gV)zoOc9wKVLO1}yRfekjD!C6d7QFsB*WW_l
z&zZDVvS9{M11J}4+Tie?tD1JVmCG#21yajH;c0xkLj|hEyWvo*&8>8gUf@wvkKQI;
z>me}dO^|itA;>mOrQJ<&SlV-(eu@>!kQU0HMi2V+-1nC9w2^axK0QZdA<@MSYEh|z
z0sqq~e(PYUSiSmDu3iz9E>x6o!j`R<+zr;+#Hs5OPWv)$`z^voKkI}?-S|0`O)D1s
zmzKA)8*O+EC>f_#au-!Mb;vKdKX&2ylwC=yZZ$>CE3D}jv|7`x4*u#@N9)<74o-LI
zOj;@8el<oy?#*H@Z%tEVikb@q9;f&LHM;&{O~?z|rSm7I$yzFZLX3FYlp_LmHx5zd
zcWEW<WEYg*<!()+IeZU76WY5@Y#H`(%n1~xINYrbl2hKEU;f0J`_xrat6sNND+#c`
zWhR&%t@=@89%g=ec|a<XTmGo2yuv4A+e^T{wy9T6uI|m-_`%iwlh%03lBX&u@+@nG
zO(4C~wN7STkXFWJpW-4MtmGjB23~Lw)`e_pJS<=x?*z_pR3wAytpzOFP$yei$n_(A
zHD`@G)x!z*hObF^Rua#L+-<*<y-or@yEmUsdRUowtVq^MHfa9#g7S82YlU>(cika-
zYpYLcsPn;D7Q0v>Daq~EXvyu+IA~oaE$x$T9#{iXss^{)({`~rpw#DeX35<QFB%?C
zWufT{#k2rhj~e>EORH`VUrKh?y9`JN9DjTG2b4x%BmTQFSx4Fx5B0Ns*98X3%@ccI
zV2<g{CNSVNgB=707Mf4I0|QmKCuZsb10Kr2E&>DBz}xxYN?zW)Zr34W`$9ha;)?*q
z{dUOf)T&$?z0SaZA0r*rz%A}p;RAsIpS$%2)zYo*)|b@B58SOkhLvnvLVjn-=Q44T
zoVYf=Z@w8141CuNFdG=Sk?T6DZfh8<p;xImuEO}lqSxIj-WPyOg)|$4XNhT+78n2?
z*%JZ-^!}-|_5H!NB2UHjzTDmVfhtH1iTD*5SmtiML*Tt5u0|l_P1trb2@KpCgQ8wZ
zUOF_nk{QwcpX;-dl~Y@BD?aN@#q=z2+v9p?$ginR0lZCt0X*;1phAL)znch%3_O8>
zrGyDkAB^c&0wGSGY>b8_l&dm)xNI*U9xf@|t@}ySt3OA;RQ6p0?2SW#756G};N0q4
zt)}6-3Y42cruv}2_xRW*{&4Kk-yEw+7<qucl3{FL4Y^pP6BaWp>2b}_9>o!gB>RUZ
zr(4P5!6y#Kqpai~3{CzYtL^U%O@7--zGY~#I4p}BBsdqxw+f$fyQ*m9EHzL_@mn&`
zAPv|9U1v2~KeSPCSSI7Rb!hTDD;bAl@#C0kB`+JAEHZUySprWJmb*62NC-`P5N~;S
z+@e%y+6(G?z4})E@tU<m!6TRYR%RW-@n((jNWfI3mVCZ#1BJrxz*+<%9GAs+EpAOD
zdG*lb-&)Bx4NaDvR!aMZCX2(eP>mBnS@?6Dk<+y9Vm@<U-Z;Z)LcQXjCd4cL7MiA@
zeIHoeO5%;|l@?bFZSfMTqrlK)arY&q<<VIj9mwUOB)1Mt{=1bd!c1IgIWJ1-l|z%a
zS;=dMCO>2)uN#`Y(MpyHh--VfmE1Tq`8q54&Y{WjW>+9tH8lA$Ngnz>$K>B$*T#gx
z%iOIqq07SSeCOGG_@Q_{T=)XDXF9c6E<#UkDEXogj`f%ja?=;E_{;g)Sn`GG@nm<f
zADR~1-C+Oi7?-OLSaiPnxXyGH9_(M^ZvDDSq3a3i<7#*7+3MpPX0(!E|0SjX5bU31
zISA>`a<~4AaRvKVyIT$Q(d2IZP<>o#`P%Bg79OHf>fEg&-UH(zcdJOD!G5^LN2-r1
zcdNM42=>G3URNJ%L%Y=ni}lay!{cs!T7AGNf2%&GyIbW%5bR&cZlFGDu~_G0`~EmK
zv>Og$Z62nF7}-4jK>ui<P(QltJ)}5+AAvg(7|Tv_EyQa$QR(0Q0_};j(p`U6(`GgI
zf((Ma$o~fh1#&;-H(y})P4nyf{!!11Z&9`a@upEz(~w{k{Y7mBk+q>%hyEXjiWBLa
zjpA}S5CcXYh+ND*vi&b{BRK}Mu$of7BSssa?NN;>!}q5~OMMdH{b7+3V~xHqro*0e
zOL1W~?|($S5PvFxO8<E^wqY0`O9taBl7aXx<KOT5(zRt7VUbv$AIo6Em(lj~r^}b<
z#d(-0Lkx=*2j8lMxWMFFl@Sdj)EG28g_BoY`TQ8lq9Fl;3>b;JQf=mKD=8H>v>M|)
zYh;VaP?U^!qU7u5Ii63Ufykeq7bQUC8HL@*<IjsBTjbH_ljYAt%4KktIi|1(i_g0y
zT~p9U)|sF;${<c7T|KcG=6x3WKkQc|h87Fu6AD}U1|ny*is?16&fs)VcsF^$eki<C
z3YGNLcyS(L+_>{|b*yF$vK-`a2JXcMSR~RaS6~Y4Q5@2-h*`~rRPW*!tGbZx<jJ@i
zxavUp_>c}nG^c}F)q%_Epi{4MsaEs9pj~%p6os}I)rtL@MaIV1KM8^vOQ`t23FAC1
zFmS1_uywC5&$Nrkl_9ptd_oVm!ki-GZO-#QV4cJ+IVQv!Sowl|&=GmiE_%Q$`T#{E
zZ#D?oGtV_zkI?;$S4_J9lh9wIlc5|E%J4=510eA4d<O<#4Da*7{V_MA9#>?uxkfft
zCWMN63aeLq+wN$T8k;ehj?_D0J3ZY@PnUFgDq_P>tDei)bW~5N7lcr)Grm%FydcyX
z`R5Bl%#ptnaZje=?a2PveIFJjym!<aaYvzK>^k2heGV#l|AheV%LbwT(G2Wb-!x9S
z+hwU*<@`Nbb27KI>IkUrPxM8}y#H`<khdLlankBD+Nh*0N{;*j%??E<(OIe<VUxFt
z(a>NZug*WVh(csW9<?8}bu40v`i!sr5xoDHZN<L7&CqsP7dfGlUN4B3gWu~fD5?zh
zU*=mG?7z-;d$9j%->t#^Z}{rr@xJfE-+haM{aL;RYzw}5ke_cZwC$T2?05J|nmyZ*
zkAxsPIon!drZ9LfRB3l{3tcet`f9m+(~2{MHaoS|uE>?9K2On6U|@~!S}3rV;90)P
zzyQ07v=b_Rq|mu?DpcVsqnD3_Audnn9Dg(L=kDE@wBeQDz|}xa(BoSJM=tTz2adq9
z3m|!=XpD?q+8!9V%=i4DM@IOK^2u$oSho$g?>yR9-pYjG*16l3(1z>?kxe!|O<1gG
zf6ucZHlVn^?<;{LY>mGI(!de6M)7|E6s8v*b32Lm6e*l84WUUf_Zwf5vB*zxYF;b9
zJQ(2MU|!Z~DlM^+%zL-hX+|f|$XdzE^3Ap3*)J2_V-y09iaWt~(Qc+;r!^7NWdS#4
zYRe{Zx26?mixV?XYWPnqD&9CG(t*0sR)c(=6qlrwQmH7Hxs(m)!WLTC9qfzl=%0Au
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%0DL3+Xo)
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%0Ab;_J_y>h-Xt6ZVnqRcCoC=1HP$_2`m
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%0D{o4I`P!1O-}EG%MfD{i#7B}K
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

literal 0
HcmV?d00001

diff --git a/build-test.bat b/build-test.bat
new file mode 100644
index 0000000000..1ad7c19e4d
--- /dev/null
+++ b/build-test.bat
@@ -0,0 +1,158 @@
+@echo off
+chcp 65001
+title Qt build test
+setlocal enabledelayedexpansion
+cls
+set /p __compiler="Please choose the compiler: [1] MSVC [2] Clang-CL [3] MinGW"
+set __msvc=0
+set __clang=0
+set __mingw=0
+if /i "%__compiler%" == "2" (
+    set __msvc=1
+    set __clang=1
+) else if /i "%__compiler%" == "3" (
+    set __mingw=1
+) else (
+    set __msvc=1
+)
+set __msvc_edition=1
+if /i "%__msvc%" == "1" set /p __msvc_edition="Please choose the MSVC edition: [1] 2022 [2] 2019 [3] 2017"
+if /i "%__msvc_edition%" == "2" (
+    set __msvc_edition=2019
+) else if /i "%__msvc_edition%" == "3" (
+    set __msvc_edition=2017
+) else (
+    set __msvc_edition=2022
+)
+set __llvm_bin=
+if /i "%__clang%" == "1" (
+    if /i "%LLVM_INSTALL_DIR%" == "" (
+        set /p __llvm_bin="Please input your LLVM bin directory path:"
+        if /i "!__llvm_bin!" == "" (
+            echo You didn't input a valid path. Please make sure you have add it to the PATH environment variable.
+        ) else (
+            set PATH=!__llvm_bin!;!PATH!
+        )
+    ) else (
+        set PATH=%LLVM_INSTALL_DIR%\bin;!PATH!
+    )
+)
+set __mingw_bin=
+if /i "%__mingw%" == "1" (
+    set /p __mingw_bin="Please input your MinGW bin directory path:"
+    if /i "!__mingw_bin!" == "" (
+        echo You didn't input a valid path. Please make sure you have add it to the PATH environment variable.
+    ) else (
+        set PATH=!__mingw_bin!;!PATH!
+    )
+)
+set /p __arch="Please choose the architecture: [1] x64 [2] x86 [3] arm64"
+if /i "%__arch%" == "2" (
+    set __arch=x86
+) else if /i "%__arch%" == "3" (
+    set __arch=arm64
+) else (
+    set __arch=x64
+)
+echo =================================================
+if /i "%__mingw%" == "1" (
+    echo Compiler: MinGW
+) else if /i "%__clang%" == "1" (
+    echo Compiler: Clang-CL
+) else (
+    echo Compiler: MSVC
+)
+if /i "%__msvc%" == "1" echo MSVC edition: %__msvc_edition%
+if /i "%__mingw_bin%" == "" (
+    echo a>nul
+) else (
+    echo MinGW bin directory: %__mingw_bin%
+)
+echo Architecture: %__arch%
+echo =================================================
+echo If everything is OK, please press the [ENTER] key to continue.
+echo Or if anything is wrong, please close this window directly and re-run this script.
+pause
+set __vcvars_suffix=Microsoft Visual Studio\%__msvc_edition%\Community\VC\Auxiliary\Build\vcvars
+if /i "%__arch%" == "x86" (
+    set __vcvars_suffix=%__vcvars_suffix%32
+) else if /i "%__arch%" == "arm64" (
+    set __vcvars_suffix=%__vcvars_suffix%arm64
+) else (
+    set __vcvars_suffix=%__vcvars_suffix%64
+)
+set __vcvars_suffix=%__vcvars_suffix%.bat
+set __vcvars_path1=%ProgramFiles%\%__vcvars_suffix%
+set __vcvars_path2=%ProgramFiles(x86)%\%__vcvars_suffix%
+if /i "%__msvc%" == "1" (
+    if exist "%__vcvars_path1%" (
+        call "%__vcvars_path1%"
+    ) else if exist "%__vcvars_path2%" (
+        call "%__vcvars_path2%"
+    ) else (
+        echo Cannot find vcvarsall.bat! Please install the MSVC toolchain first.
+        goto end
+    )
+)
+set PATH=%~dp0bin;%PATH%
+cd /d "%~dp0"
+if exist build-test rd /s /q build-test
+md build-test
+cd build-test
+md cmake
+cd cmake
+set __toolchain_flags=
+if /i "%__mingw%" == "1" (
+    set __toolchain_flags=-DCMAKE_C_COMPILER=gcc.exe -DCMAKE_CXX_COMPILER=g++.exe
+) else if /i "%__clang%" == "1" (
+    set __toolchain_flags=-DCMAKE_C_COMPILER=clang-cl.exe -DCMAKE_CXX_COMPILER=clang-cl.exe
+) else (
+    set __toolchain_flags=-DCMAKE_C_COMPILER=cl.exe -DCMAKE_CXX_COMPILER=cl.exe
+)
+:: -DINPUT_intelcet=yes -DINPUT_spectre=yes -DINPUT_ehcont=yes -DINPUT_cfguard=yes
+set __common_flags=-Wno-dev %__toolchain_flags% -DCMAKE_MESSAGE_LOG_LEVEL=STATUS -DQT_BUILD_TESTS=OFF -DQT_BUILD_EXAMPLES=OFF -DFEATURE_relocatable=ON -DFEATURE_system_zlib=OFF -DFEATURE_system_zstd=OFF -DFEATURE_cxx20=ON -DQT_DISABLE_DEPRECATED_UP_TO=0x070000 -DINPUT_mimetype_database_compression=zstd
+cmake %__common_flags% -DCMAKE_INSTALL_PREFIX="%~dp0build-test\shared" -DCMAKE_CONFIGURATION_TYPES=Release;Debug -DCMAKE_INTERPROCEDURAL_OPTIMIZATION_RELEASE=ON -DBUILD_SHARED_LIBS=ON -G"Ninja Multi-Config" "%~dp0"
+echo =================================================
+echo Configuration done.
+echo Please press the [ENTER] key to start compilation if everything is OK,
+echo or close this window directly and re-run this script if there is anything wrong.
+echo =================================================
+pause
+cmake --build . --parallel
+:: Qt's installation script will strip the binary files automatically by default.
+ninja install
+cd ..
+rd /s /q cmake
+echo =================================================
+echo The shared library edition has been built. You can check the final binary files now.
+echo Please press the [ENTER] key to start building the static library edition,
+echo or close this window directly to cancel it.
+echo =================================================
+pause
+md cmake
+cd cmake
+cmake %__common_flags% -DCMAKE_INSTALL_PREFIX="%~dp0build-test\static" -DCMAKE_BUILD_TYPE=Release -DCMAKE_INTERPROCEDURAL_OPTIMIZATION_RELEASE=OFF -DBUILD_SHARED_LIBS=OFF -GNinja "%~dp0"
+echo =================================================
+echo Configuration done.
+echo Please press the [ENTER] key to start compilation if everything is OK,
+echo or close this window directly and re-run this script if there is anything wrong.
+echo =================================================
+pause
+cmake --build . --parallel
+:: CMake won't strip the binary files by default. We need to explicitly enable it.
+set __strip=
+if /i "%__mingw%" == "1" set __strip=--strip
+cmake --install . %__strip%
+cd ..
+rd /s /q cmake
+echo =================================================
+echo The static library edition has been built. You can check the final binary files now.
+echo Please press the [ENTER] key to exit from this script, or close this window directly.
+echo =================================================
+goto end
+
+:end
+endlocal
+cd /d "%~dp0"
+pause
+exit /b 0
diff --git a/cmake/FindWrapSystemZSTD.cmake b/cmake/FindWrapSystemZSTD.cmake
new file mode 100644
index 0000000000..dfaa5e1305
--- /dev/null
+++ b/cmake/FindWrapSystemZSTD.cmake
@@ -0,0 +1,91 @@
+# Copyright (C) 2022 The Qt Company Ltd.
+# SPDX-License-Identifier: BSD-3-Clause
+
+#.rst:
+# FindZstd
+# ---------
+#
+# Try to locate the Zstd library.
+# If found, this will define the following variables:
+#
+# ``WrapSystemZSTD_FOUND``
+#     True if the zstd library is available
+# ``ZSTD_INCLUDE_DIRS``
+#     The zstd include directories
+# ``ZSTD_LIBRARIES``
+#     The zstd libraries for linking
+#
+# If ``WrapSystemZSTD_FOUND`` is TRUE, it will also define the following
+# imported target:
+#
+# ``WrapSystemZSTD::WrapSystemZSTD``
+#     The zstd library
+
+find_package(zstd CONFIG QUIET)
+
+include(FindPackageHandleStandardArgs)
+
+if(TARGET zstd::libzstd_static OR TARGET zstd::libzstd_shared)
+    find_package_handle_standard_args(WrapSystemZSTD
+                                      REQUIRED_VARS zstd_VERSION VERSION_VAR zstd_VERSION)
+    if(TARGET zstd::libzstd_shared)
+        set(zstdtargetsuffix "_shared")
+    else()
+        set(zstdtargetsuffix "_static")
+    endif()
+    if(NOT TARGET WrapSystemZSTD::WrapSystemZSTD)
+        add_library(WrapSystemZSTD::WrapSystemZSTD INTERFACE IMPORTED)
+        set_target_properties(WrapSystemZSTD::WrapSystemZSTD PROPERTIES
+                              INTERFACE_LINK_LIBRARIES "zstd::libzstd${zstdtargetsuffix}")
+    endif()
+else()
+    find_package(PkgConfig QUIET)
+    pkg_check_modules(PC_ZSTD QUIET "libzstd")
+
+    find_path(ZSTD_INCLUDE_DIRS
+              NAMES zstd.h
+              HINTS ${PC_ZSTD_INCLUDEDIR}
+              PATH_SUFFIXES zstd)
+
+    find_library(ZSTD_LIBRARY_RELEASE
+                 NAMES zstd zstd_static
+                 HINTS ${PC_ZSTD_LIBDIR}
+    )
+    find_library(ZSTD_LIBRARY_DEBUG
+                 NAMES zstdd zstd_staticd zstd zstd_static
+                 HINTS ${PC_ZSTD_LIBDIR}
+    )
+
+    include(SelectLibraryConfigurations)
+    select_library_configurations(ZSTD)
+
+    if(PC_ZSTD_VERSION)
+        set(WrapSystemZSTD_VERSION "${PC_ZSTD_VERSION}")
+    endif()
+    find_package_handle_standard_args(WrapSystemZSTD
+                                      REQUIRED_VARS ZSTD_LIBRARIES ZSTD_INCLUDE_DIRS
+                                      VERSION_VAR WrapSystemZSTD_VERSION)
+
+    if(WrapSystemZSTD_FOUND AND NOT TARGET WrapSystemZSTD::WrapSystemZSTD)
+      add_library(WrapSystemZSTD::WrapSystemZSTD UNKNOWN IMPORTED)
+      set_target_properties(WrapSystemZSTD::WrapSystemZSTD PROPERTIES
+                            INTERFACE_INCLUDE_DIRECTORIES "${ZSTD_INCLUDE_DIRS}")
+      set_target_properties(WrapSystemZSTD::WrapSystemZSTD PROPERTIES
+                            IMPORTED_LOCATION "${ZSTD_LIBRARY}")
+      if(ZSTD_LIBRARY_RELEASE)
+          set_target_properties(WrapSystemZSTD::WrapSystemZSTD PROPERTIES
+                                IMPORTED_LOCATION_RELEASE "${ZSTD_LIBRARY_RELEASE}")
+      endif()
+      if(ZSTD_LIBRARY_DEBUG)
+          set_target_properties(WrapSystemZSTD::WrapSystemZSTD PROPERTIES
+                                IMPORTED_LOCATION_DEBUG "${ZSTD_LIBRARY_DEBUG}")
+      endif()
+    endif()
+
+    mark_as_advanced(ZSTD_INCLUDE_DIRS ZSTD_LIBRARIES ZSTD_LIBRARY_RELEASE ZSTD_LIBRARY_DEBUG)
+endif()
+include(FeatureSummary)
+set_package_properties(WrapSystemZSTD PROPERTIES
+  URL "https://github.com/facebook/zstd"
+  DESCRIPTION "ZSTD compression library")
+
diff --git a/cmake/FindWrapZSTD.cmake b/cmake/FindWrapZSTD.cmake
index fb86c27676..089969cd01 100644
--- a/cmake/FindWrapZSTD.cmake
+++ b/cmake/FindWrapZSTD.cmake
@@ -1,91 +1,14 @@
-# Copyright (C) 2022 The Qt Company Ltd.
+# Copyright (C) 2023 The Qt Company Ltd.
 # SPDX-License-Identifier: BSD-3-Clause
 
-#.rst:
-# FindZstd
-# ---------
-#
-# Try to locate the Zstd library.
-# If found, this will define the following variables:
-#
-# ``WrapZSTD_FOUND``
-#     True if the zstd library is available
-# ``ZSTD_INCLUDE_DIRS``
-#     The zstd include directories
-# ``ZSTD_LIBRARIES``
-#     The zstd libraries for linking
-#
-# If ``WrapZSTD_FOUND`` is TRUE, it will also define the following
-# imported target:
-#
-# ``WrapZSTD::WrapZSTD``
-#     The zstd library
-
-find_package(zstd CONFIG QUIET)
-
-include(FindPackageHandleStandardArgs)
-
-if(TARGET zstd::libzstd_static OR TARGET zstd::libzstd_shared)
-    find_package_handle_standard_args(WrapZSTD
-                                      REQUIRED_VARS zstd_VERSION VERSION_VAR zstd_VERSION)
-    if(TARGET zstd::libzstd_static)
-        set(zstdtargetsuffix "_static")
-    else()
-        set(zstdtargetsuffix "_shared")
-    endif()
-    if(NOT TARGET WrapZSTD::WrapZSTD)
-        add_library(WrapZSTD::WrapZSTD INTERFACE IMPORTED)
-        set_target_properties(WrapZSTD::WrapZSTD PROPERTIES
-                              INTERFACE_LINK_LIBRARIES "zstd::libzstd${zstdtargetsuffix}")
-    endif()
-else()
-    find_package(PkgConfig QUIET)
-    pkg_check_modules(PC_ZSTD QUIET "libzstd")
-
-    find_path(ZSTD_INCLUDE_DIRS
-              NAMES zstd.h
-              HINTS ${PC_ZSTD_INCLUDEDIR}
-              PATH_SUFFIXES zstd)
-
-    find_library(ZSTD_LIBRARY_RELEASE
-                 NAMES zstd zstd_static
-                 HINTS ${PC_ZSTD_LIBDIR}
-    )
-    find_library(ZSTD_LIBRARY_DEBUG
-                 NAMES zstdd zstd_staticd zstd zstd_static
-                 HINTS ${PC_ZSTD_LIBDIR}
-    )
-
-    include(SelectLibraryConfigurations)
-    select_library_configurations(ZSTD)
-
-    if(PC_ZSTD_VERSION)
-        set(WrapZSTD_VERSION "${PC_ZSTD_VERSION}")
-    endif()
-    find_package_handle_standard_args(WrapZSTD
-                                      REQUIRED_VARS ZSTD_LIBRARIES ZSTD_INCLUDE_DIRS
-                                      VERSION_VAR WrapZSTD_VERSION)
-
-    if(WrapZSTD_FOUND AND NOT TARGET WrapZSTD::WrapZSTD)
-      add_library(WrapZSTD::WrapZSTD UNKNOWN IMPORTED)
-      set_target_properties(WrapZSTD::WrapZSTD PROPERTIES
-                            INTERFACE_INCLUDE_DIRECTORIES "${ZSTD_INCLUDE_DIRS}")
-      set_target_properties(WrapZSTD::WrapZSTD PROPERTIES
-                            IMPORTED_LOCATION "${ZSTD_LIBRARY}")
-      if(ZSTD_LIBRARY_RELEASE)
-          set_target_properties(WrapZSTD::WrapZSTD PROPERTIES
-                                IMPORTED_LOCATION_RELEASE "${ZSTD_LIBRARY_RELEASE}")
-      endif()
-      if(ZSTD_LIBRARY_DEBUG)
-          set_target_properties(WrapZSTD::WrapZSTD PROPERTIES
-                                IMPORTED_LOCATION_DEBUG "${ZSTD_LIBRARY_DEBUG}")
-      endif()
-    endif()
-
-    mark_as_advanced(ZSTD_INCLUDE_DIRS ZSTD_LIBRARIES ZSTD_LIBRARY_RELEASE ZSTD_LIBRARY_DEBUG)
-endif()
-include(FeatureSummary)
-set_package_properties(WrapZSTD PROPERTIES
-  URL "https://github.com/facebook/zstd"
-  DESCRIPTION "ZSTD compression library")
-
+include(QtFindWrapHelper NO_POLICY_SCOPE)
+
+qt_find_package_system_or_bundled(wrap_zstd
+    FRIENDLY_PACKAGE_NAME "ZSTD"
+    WRAP_PACKAGE_TARGET "WrapZSTD::WrapZSTD"
+    WRAP_PACKAGE_FOUND_VAR_NAME "WrapZSTD_FOUND"
+    BUNDLED_PACKAGE_NAME "BundledZSTD"
+    BUNDLED_PACKAGE_TARGET "BundledZSTD"
+    SYSTEM_PACKAGE_NAME "WrapSystemZSTD"
+    SYSTEM_PACKAGE_TARGET "WrapSystemZSTD::WrapSystemZSTD"
+)
diff --git a/cmake/Qt3rdPartyLibraryHelpers.cmake b/cmake/Qt3rdPartyLibraryHelpers.cmake
index dca360d074..8ec7966f32 100644
--- a/cmake/Qt3rdPartyLibraryHelpers.cmake
+++ b/cmake/Qt3rdPartyLibraryHelpers.cmake
@@ -320,12 +320,6 @@ function(qt_internal_add_3rdparty_library target)
         qt_enable_separate_debug_info(${target} "${debug_install_dir}")
         qt_internal_install_pdb_files(${target} "${INSTALL_LIBDIR}")
     endif()
-
-    if(BUILD_SHARED_LIBS AND MSVC)
-        set_target_properties(${target} PROPERTIES
-            INTERPROCEDURAL_OPTIMIZATION OFF
-        )
-    endif()
 endfunction()
 
 function(qt_install_3rdparty_library_wrap_config_extra_file target)
diff --git a/cmake/QtBaseGlobalTargets.cmake b/cmake/QtBaseGlobalTargets.cmake
index 64f7ae0bc5..82db1544ab 100644
--- a/cmake/QtBaseGlobalTargets.cmake
+++ b/cmake/QtBaseGlobalTargets.cmake
@@ -288,6 +288,8 @@ qt_copy_or_install(FILES
                    cmake/QtWasmHelpers.cmake
                    cmake/QtWrapperScriptHelpers.cmake
                    cmake/QtWriteArgsFile.cmake
+                   cmake/VC-LTL.cmake
+                   cmake/YY-Thunks.cmake
                    cmake/modulecppexports.h.in
                    cmake/modulecppexports_p.h.in
                    cmake/qbatchedtestrunner.in.cpp
diff --git a/cmake/QtBuild.cmake b/cmake/QtBuild.cmake
index fa9e61d203..130ae55032 100644
--- a/cmake/QtBuild.cmake
+++ b/cmake/QtBuild.cmake
@@ -586,3 +586,17 @@ _qt_internal_generate_tool_command_wrapper()
 if(CMAKE_VERSION VERSION_LESS "3.19.0")
     variable_watch(CMAKE_CURRENT_LIST_DIR qt_watch_current_list_dir)
 endif()
+
+if(MSVC)
+    include(VC-LTL)
+    if("x${SupportLTL}" STREQUAL "xtrue")
+        unset(CMAKE_MSVC_RUNTIME_LIBRARY)
+        unset(CMAKE_MSVC_RUNTIME_LIBRARY CACHE)
+        #unset(CMAKE_MSVC_RUNTIME_LIBRARY PARENT_SCOPE)
+        set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>" CACHE STRING "" FORCE)
+    endif()
+    if(NOT CLANG) # LLD-LINK can't handle duplicated symbols.
+        set(YYTHUNKS_TARGET_OS "WinXP" CACHE STRING "" FORCE)
+        include(YY-Thunks)
+    endif()
+endif()
diff --git a/cmake/QtCompilerFlags.cmake b/cmake/QtCompilerFlags.cmake
index 62bd63bd22..8168b70338 100644
--- a/cmake/QtCompilerFlags.cmake
+++ b/cmake/QtCompilerFlags.cmake
@@ -8,18 +8,16 @@
 # property checked below, and is equivalent to qmake's CONFIG += warn_off.
 
 set(_qt_compiler_warning_flags_on "")
-set(_qt_compiler_warning_flags_off "")
+set(_qt_compiler_warning_flags_off -w)
 
 if (MSVC)
     list(APPEND _qt_compiler_warning_flags_on /W3)
-    list(APPEND _qt_compiler_warning_flags_off -W0)
 else()
     if(CMAKE_CXX_COMPILER_ID STREQUAL "GHS") # There is no -Wextra flag for GHS compiler.
         list(APPEND _qt_compiler_warning_flags_on -Wall)
     else()
         list(APPEND _qt_compiler_warning_flags_on -Wall -Wextra)
     endif()
-    list(APPEND _qt_compiler_warning_flags_off -w)
 endif()
 
 set(_qt_compiler_warning_flags_condition
diff --git a/cmake/QtCompilerOptimization.cmake b/cmake/QtCompilerOptimization.cmake
index a093ed4dce..73ae832b8d 100644
--- a/cmake/QtCompilerOptimization.cmake
+++ b/cmake/QtCompilerOptimization.cmake
@@ -35,35 +35,40 @@ if (MSVC)
 endif()
 
 if(GCC OR CLANG OR QCC)
-    set(QT_CFLAGS_SSE2       "-msse2")
-    set(QT_CFLAGS_SSE3       "-msse3")
-    set(QT_CFLAGS_SSSE3      "-mssse3")
-    set(QT_CFLAGS_SSE4_1     "-msse4.1")
-    set(QT_CFLAGS_SSE4_2     "-msse4.2")
-    set(QT_CFLAGS_F16C       "-mf16c")
-    set(QT_CFLAGS_RDRND      "-mrdrnd")
-    set(QT_CFLAGS_RDSEED     "-mrdseed")
-    set(QT_CFLAGS_AVX        "-mavx")
-    set(QT_CFLAGS_AVX2       "-mavx2")
-    set(QT_CFLAGS_ARCH_HASWELL "-march=haswell")
-    set(QT_CFLAGS_AVX512F    "-mavx512f")
-    set(QT_CFLAGS_AVX512ER   "-mavx512er")
-    set(QT_CFLAGS_AVX512CD   "-mavx512cd")
-    set(QT_CFLAGS_AVX512PF   "-mavx512pf")
-    set(QT_CFLAGS_AVX512DQ   "-mavx512dq")
-    set(QT_CFLAGS_AVX512BW   "-mavx512bw")
-    set(QT_CFLAGS_AVX512VL   "-mavx512vl")
-    set(QT_CFLAGS_AVX512IFMA "-mavx512ifma")
-    set(QT_CFLAGS_AVX512VBMI "-mavx512vbmi")
-    set(QT_CFLAGS_AVX512VBMI2 "-mavx512vbmi2")
-    set(QT_CFLAGS_AESNI      "-maes")
-    set(QT_CFLAGS_SHANI      "-msha")
-    set(QT_CFLAGS_VAES       "-mvaes")
+    set(__prefix)
+    if(MSVC AND CLANG)
+        set(__prefix "/clang:")
+    endif()
+    set(QT_CFLAGS_SSE2       "${__prefix}-msse2")
+    set(QT_CFLAGS_SSE3       "${__prefix}-msse3")
+    set(QT_CFLAGS_SSSE3      "${__prefix}-mssse3")
+    set(QT_CFLAGS_SSE4_1     "${__prefix}-msse4.1")
+    set(QT_CFLAGS_SSE4_2     "${__prefix}-msse4.2")
+    set(QT_CFLAGS_F16C       "${__prefix}-mf16c")
+    set(QT_CFLAGS_RDRND      "${__prefix}-mrdrnd")
+    set(QT_CFLAGS_RDSEED     "${__prefix}-mrdseed")
+    set(QT_CFLAGS_AVX        "${__prefix}-mavx")
+    set(QT_CFLAGS_AVX2       "${__prefix}-mavx2")
+    set(QT_CFLAGS_ARCH_HASWELL "${__prefix}-march=haswell")
+    set(QT_CFLAGS_AVX512F    "${__prefix}-mavx512f")
+    set(QT_CFLAGS_AVX512ER   "${__prefix}-mavx512er")
+    set(QT_CFLAGS_AVX512CD   "${__prefix}-mavx512cd")
+    set(QT_CFLAGS_AVX512PF   "${__prefix}-mavx512pf")
+    set(QT_CFLAGS_AVX512DQ   "${__prefix}-mavx512dq")
+    set(QT_CFLAGS_AVX512BW   "${__prefix}-mavx512bw")
+    set(QT_CFLAGS_AVX512VL   "${__prefix}-mavx512vl")
+    set(QT_CFLAGS_AVX512IFMA "${__prefix}-mavx512ifma")
+    set(QT_CFLAGS_AVX512VBMI "${__prefix}-mavx512vbmi")
+    set(QT_CFLAGS_AVX512VBMI2 "${__prefix}-mavx512vbmi2")
+    set(QT_CFLAGS_AESNI      "${__prefix}-maes")
+    set(QT_CFLAGS_SHANI      "${__prefix}-msha")
+    set(QT_CFLAGS_VAES       "${__prefix}-mvaes")
     if(NOT UIKIT AND NOT QT_64BIT)
-        set(QT_CFLAGS_NEON   "-mfpu=neon")
+        set(QT_CFLAGS_NEON   "${__prefix}-mfpu=neon")
     endif()
-    set(QT_CFLAGS_MIPS_DSP   "-mdsp")
-    set(QT_CFLAGS_MIPS_DSPR2 "-mdspr2")
+    set(QT_CFLAGS_MIPS_DSP   "${__prefix}-mdsp")
+    set(QT_CFLAGS_MIPS_DSPR2 "${__prefix}-mdspr2")
+    unset(__prefix)
 endif()
 
 # Fall through is important, so that more specific flags that might be missing are set by the
@@ -74,32 +79,39 @@ endif()
 #
 # gcc and clang base
 if(GCC OR CLANG)
-    set(QT_CFLAGS_OPTIMIZE "-O2")
-    set(QT_CFLAGS_OPTIMIZE_FULL "-O3")
+    set(QT_CFLAGS_OPTIMIZE "-Ofast") # -O3
+    set(QT_CFLAGS_OPTIMIZE_FULL "-Ofast")
     set(QT_CFLAGS_OPTIMIZE_DEBUG "-Og")
-    set(QT_CFLAGS_OPTIMIZE_SIZE "-Os")
 
     if(CLANG)
         set(QT_CFLAGS_OPTIMIZE_SIZE "-Oz")
+    else()
+        set(QT_CFLAGS_OPTIMIZE_SIZE "-Os")
     endif()
 endif()
 
 # Flags that CMake might set, aka flags the compiler would see as valid values.
 if(GCC OR CLANG OR QCC)
-    set(QT_CFLAGS_OPTIMIZE_VALID_VALUES "-O0" "-O1" "-O2" "-O3" "-Os" "-Oz")
+    set(QT_CFLAGS_OPTIMIZE_VALID_VALUES "-O0" "-O1" "-O2" "-O3" "-Ofast" "-Os" "-Oz")
 endif()
 
 
 # Windows MSVC
 if(MSVC)
     set(QT_CFLAGS_OPTIMIZE "-O2")
+    if(MSVC_VERSION GREATER_EQUAL 1920) # Visual Studio 2019 version 16.0
+        string(APPEND QT_CFLAGS_OPTIMIZE " -Ob3 ")
+    else()
+        string(APPEND QT_CFLAGS_OPTIMIZE " -Ob2 ")
+    endif()
     set(QT_CFLAGS_OPTIMIZE_DEBUG "-Od")
-    set(QT_CFLAGS_OPTIMIZE_SIZE "-O1")
-    set(QT_CFLAGS_OPTIMIZE_VALID_VALUES "/O2" "/O1" "/Od" "/Ob0" "/Ob1" "/Ob2" "/O0" "-O0")
+    set(QT_CFLAGS_OPTIMIZE_SIZE "-O1 -Ob2")
+    set(QT_CFLAGS_OPTIMIZE_VALID_VALUES "/O2" "/O1" "/Od" "/Ob0" "/Ob1" "/Ob2" "/Ob3" "/O0" "-O0")
 
     if(CLANG)
-        set(QT_CFLAGS_OPTIMIZE_FULL "/clang:-O3")
-        set(QT_CFLAGS_OPTIMIZE_SIZE "/clang:-Oz")
+        set(QT_CFLAGS_OPTIMIZE "/clang:-Ofast -Ob2") # /clang:-O3
+        set(QT_CFLAGS_OPTIMIZE_FULL "/clang:-Ofast -Ob2")
+        set(QT_CFLAGS_OPTIMIZE_SIZE "/clang:-Oz -Ob2")
     endif()
 endif()
 
@@ -107,8 +119,8 @@ endif()
 if(CLANG AND ANDROID)
     if(QT_FEATURE_ltcg)
         # When using LTCG, the linker cannot cope with -Oz.  See QTBUG-89472 for details.
-        set(QT_CFLAGS_OPTIMIZE "-O2")
-        set(QT_CFLAGS_OPTIMIZE_FULL "-O3")
+        set(QT_CFLAGS_OPTIMIZE "-O3")
+        set(QT_CFLAGS_OPTIMIZE_FULL "-Ofast")
     else()
         set(QT_CFLAGS_OPTIMIZE "-Oz")
         set(QT_CFLAGS_OPTIMIZE_FULL "-Oz")
diff --git a/cmake/QtFeature.cmake b/cmake/QtFeature.cmake
index c778fa2926..5733dd3848 100644
--- a/cmake/QtFeature.cmake
+++ b/cmake/QtFeature.cmake
@@ -963,10 +963,15 @@ function(qt_config_compile_test name)
             # https://developercommunity.visualstudio.com/content/problem/139261/msvc-incorrectly-defines-cplusplus.html
             # No support for the flag in upstream CMake as of 3.17.
             # https://gitlab.kitware.com/cmake/cmake/issues/18837
-            if(CMAKE_CXX_COMPILER_ID STREQUAL "MSVC" AND MSVC_VERSION GREATER_EQUAL 1913)
+            if(MSVC AND (MSVC_VERSION GREATER_EQUAL 1913) AND NOT CLANG)
                 list(APPEND CMAKE_REQUIRED_FLAGS "-Zc:__cplusplus")
             endif()
 
+            # Tell clang-cl to emulate MSVC 2022.
+            if(MSVC AND CLANG)
+                list(APPEND CMAKE_REQUIRED_FLAGS "-fmsc-version=1935")
+            endif()
+
             # Let CMake load our custom platform modules.
             if(NOT QT_AVOID_CUSTOM_PLATFORM_MODULES)
                 list(APPEND CMAKE_TRY_COMPILE_PLATFORM_VARIABLES CMAKE_MODULE_PATH)
diff --git a/cmake/QtFlagHandlingHelpers.cmake b/cmake/QtFlagHandlingHelpers.cmake
index 3ce5418146..228f8bd4a4 100644
--- a/cmake/QtFlagHandlingHelpers.cmake
+++ b/cmake/QtFlagHandlingHelpers.cmake
@@ -212,25 +212,25 @@ endfunction()
 function(qt_internal_set_exceptions_flags target exceptions_on)
     set(_defs "")
     set(_flag "")
+    # Hack for clang-cl: enable exception handling unconditionally.
+    if(MSVC AND CLANG)
+        set(exceptions_on TRUE)
+    endif()
     if(exceptions_on)
         if(MSVC)
             set(_flag "/EHsc")
             if((MSVC_VERSION GREATER_EQUAL 1929) AND NOT CLANG)
                 set(_flag ${_flag} "/d2FH4")
             endif()
+        else()
+            set(_flag "-fexceptions")
         endif()
     else()
         set(_defs "QT_NO_EXCEPTIONS")
-        if ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "MSVC")
-            set(_flag "/EHs-c-" "/wd4530" "/wd4577")
-        elseif ("${CMAKE_CXX_COMPILER_ID}" MATCHES "GNU|AppleClang|InteLLLVM")
+        if(MSVC)
+            set(_flag "/EHs-c-")
+        else()
             set(_flag "-fno-exceptions")
-        elseif ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang")
-            if (MSVC)
-                set(_flag "/EHs-c-" "/wd4530" "/wd4577")
-            else()
-                set(_flag "-fno-exceptions")
-            endif()
         endif()
     endif()
 
diff --git a/cmake/QtInternalTargets.cmake b/cmake/QtInternalTargets.cmake
index c5a1e9b7f2..29430d03b8 100644
--- a/cmake/QtInternalTargets.cmake
+++ b/cmake/QtInternalTargets.cmake
@@ -244,7 +244,7 @@ if(WASM AND QT_FEATURE_sse2)
 endif()
 
 # Taken from mkspecs/common/msvc-version.conf and mkspecs/common/msvc-desktop.conf
-if (MSVC)
+if (MSVC AND NOT CLANG)
     if (MSVC_VERSION GREATER_EQUAL 1799)
         target_compile_options(PlatformCommonInternal INTERFACE
             -FS
@@ -255,26 +255,27 @@ if (MSVC)
     if (MSVC_VERSION GREATER_EQUAL 1899)
         target_compile_options(PlatformCommonInternal INTERFACE
             -Zc:strictStrings
+            -Zc:throwingNew
         )
-        if (NOT CLANG)
-            target_compile_options(PlatformCommonInternal INTERFACE
-                -Zc:throwingNew
-            )
-        endif()
     endif()
-    if (MSVC_VERSION GREATER_EQUAL 1909 AND NOT CLANG) # MSVC 2017
+    if (MSVC_VERSION GREATER_EQUAL 1909) # MSVC 2017
         target_compile_options(PlatformCommonInternal INTERFACE
             -Zc:referenceBinding
             -Zc:ternary
         )
     endif()
-    if (MSVC_VERSION GREATER_EQUAL 1919 AND NOT CLANG) # MSVC 2019
+    if (MSVC_VERSION GREATER_EQUAL 1919) # MSVC 2019
         target_compile_options(PlatformCommonInternal INTERFACE
             -Zc:externConstexpr
             #-Zc:lambda # Buggy. TODO: Enable again when stable enough.
             #-Zc:preprocessor # breaks build due to bug in default Windows SDK 10.0.19041
         )
     endif()
+    if (MSVC_VERSION GREATER_EQUAL 1925) # Visual Studio 2019 version 16.5
+        target_compile_options(PlatformCommonInternal INTERFACE
+            $<$<CONFIG:Release>:-QIntel-jcc-erratum>
+        )
+    endif()
 
     target_compile_options(PlatformCommonInternal INTERFACE
         -Zc:wchar_t
@@ -282,13 +283,62 @@ if (MSVC)
     )
 
     target_compile_options(PlatformCommonInternal INTERFACE
-        $<$<NOT:$<CONFIG:Debug>>:-guard:cf -Gw>
+        $<$<CONFIG:Release>:-fp:fast -GF -GT -Gw -Gy> # TODO: -GA for executables.
     )
 
     target_link_options(PlatformCommonInternal INTERFACE
-        -DYNAMICBASE -NXCOMPAT -LARGEADDRESSAWARE
-        $<$<NOT:$<CONFIG:Debug>>:-OPT:REF -OPT:ICF -GUARD:CF>
+        -DYNAMICBASE -FIXED:NO -NXCOMPAT -LARGEADDRESSAWARE
+        $<$<CONFIG:Release>:-OPT:REF -OPT:ICF -OPT:LBR>
     )
+
+    if(TEST_architecture_arch STREQUAL "x86_64")
+        target_link_options(PlatformCommonInternal INTERFACE
+            -HIGHENTROPYVA
+        )
+    endif()
+endif()
+
+if(MSVC AND CLANG)
+    target_compile_options(PlatformCommonInternal INTERFACE
+        /bigobj /utf-8 /FS
+        -fcolor-diagnostics
+        -fmerge-all-constants # This used to be the default in clang for over a decade. It makes clang non-conforming, but is fairly safe in practice and saves some binary size.
+        -fmsc-version=1935 # Tell clang-cl to emulate MSVC 2022.
+        -fcomplete-member-pointers # This flag enforces that member pointer base types are complete. It helps prevent us from running into problems in the Microsoft C++ ABI.
+        -ffile-reproducible # Consistently use backslash as the path separator when expanding the __FILE__ macro when targeting Windows regardless of the build environment.
+        -fansi-escape-codes # Enable ANSI escape codes if something emulating them is around (cmd.exe doesn't understand ANSI escape codes by default).
+        /Zc:char8_t /Zc:sizedDealloc /Zc:strictStrings /Zc:threadSafeInit
+        /Zc:trigraphs /Zc:twoPhase
+        /Zc:dllexportInlines- # Do not export inline member functions. This is similar to "-fvisibility-inlines-hidden".
+        /D__WRL_ENABLE_FUNCTION_STATICS__ # Required to make the 19041 SDK compatible with clang-cl.
+        /clang:-mcx16 # Needed by _InterlockedCompareExchange128() from CPP/WinRT.
+        $<$<CONFIG:Release>:/clang:-mbranches-within-32B-boundaries /clang:-ffp-contract=fast /Gw /Gy /Zc:inline>
+    )
+    target_link_options(PlatformCommonInternal INTERFACE
+        --color-diagnostics
+        /DYNAMICBASE /FIXED:NO /NXCOMPAT /LARGEADDRESSAWARE
+        $<$<CONFIG:Release>:/OPT:REF /OPT:ICF /OPT:LBR /OPT:lldtailmerge>
+    )
+    if(TEST_architecture_arch STREQUAL "x86_64")
+        target_compile_options(PlatformCommonInternal INTERFACE
+            /clang:-m64
+        )
+        target_link_options(PlatformCommonInternal INTERFACE
+            /HIGHENTROPYVA
+        )
+    elseif(TEST_architecture_arch STREQUAL "x86")
+        target_compile_options(PlatformCommonInternal INTERFACE
+            /clang:-m32
+        )
+    endif()
+    if(QT_FEATURE_ltcg)
+        target_compile_options(PlatformCommonInternal INTERFACE
+            $<$<CONFIG:Release>:-fsplit-lto-unit -fwhole-program-vtables>
+        )
+        target_link_options(PlatformCommonInternal INTERFACE
+            $<$<CONFIG:Release>:/OPT:lldltojobs=all /OPT:lldlto=3 /OPT:lldltocgo=3> # /lldltocachepolicy:cache_size=10%:cache_size_bytes=40g:cache_size_files=100000
+        )
+    endif()
 endif()
 
 if(MINGW)
@@ -299,18 +349,68 @@ if (GCC AND CMAKE_CXX_COMPILER_VERSION VERSION_GREATER_EQUAL "9.2")
     target_compile_options(PlatformCommonInternal INTERFACE $<$<COMPILE_LANGUAGE:CXX>:-Wsuggest-override>)
 endif()
 
-if(QT_FEATURE_intelcet)
+# Make sure Qt users use the same symbols as how we build Qt.
+qt_internal_library_deprecation_level(deprecation_defines)
+target_compile_definitions(PlatformCommonInternal INTERFACE ${deprecation_defines})
+
+if(QT_FEATURE_cfguard)
     if(MSVC)
+        target_compile_options(PlatformCommonInternal INTERFACE
+            $<$<NOT:$<CONFIG:Debug>>:-guard:cf>
+        )
         target_link_options(PlatformCommonInternal INTERFACE
-            -CETCOMPAT
+            $<$<NOT:$<CONFIG:Debug>>:-GUARD:CF>
         )
+    else()
+        # TODO
+    endif()
+endif()
+
+if(QT_FEATURE_intelcet)
+    if(MSVC)
+        if(CLANG OR (MSVC_VERSION GREATER_EQUAL 1920)) # Visual Studio 2019 version 16.0
+            target_link_options(PlatformCommonInternal INTERFACE
+                $<$<NOT:$<CONFIG:Debug>>:-CETCOMPAT>
+            )
+        endif()
     else()
         target_compile_options(PlatformCommonInternal INTERFACE
-            -fcf-protection=full
+            $<$<NOT:$<CONFIG:Debug>>:-fcf-protection=full>
         )
     endif()
 endif()
 
+if(QT_FEATURE_spectre)
+    if(MSVC AND NOT CLANG)
+        if(MSVC_VERSION GREATER_EQUAL 1925) # Visual Studio 2019 version 16.5
+            target_compile_options(PlatformCommonInternal INTERFACE
+                -Qspectre-load
+            )
+        elseif(MSVC_VERSION GREATER_EQUAL 1912) # Visual Studio 2017 version 15.5
+            target_compile_options(PlatformCommonInternal INTERFACE
+                -Qspectre
+            )
+        endif()
+    else()
+        # TODO
+    endif()
+endif()
+
+if(QT_FEATURE_ehcont)
+    if(MSVC)
+        if(CLANG OR (MSVC_VERSION GREATER_EQUAL 1927)) # Visual Studio 2019 version 16.7
+            target_compile_options(PlatformCommonInternal INTERFACE
+                $<$<NOT:$<CONFIG:Debug>>:-guard:ehcont>
+            )
+            target_link_options(PlatformCommonInternal INTERFACE
+                $<$<NOT:$<CONFIG:Debug>>:-guard:ehcont>
+            )
+        endif()
+    else()
+        # TODO
+    endif()
+endif()
+
 if(QT_FEATURE_force_asserts)
     target_compile_definitions(PlatformCommonInternal INTERFACE QT_FORCE_ASSERTS)
 endif()
diff --git a/cmake/QtModuleHelpers.cmake b/cmake/QtModuleHelpers.cmake
index bd41a3dd06..eb2b889bc0 100644
--- a/cmake/QtModuleHelpers.cmake
+++ b/cmake/QtModuleHelpers.cmake
@@ -467,8 +467,6 @@ function(qt_internal_add_module target)
         endif()
     endif()
 
-    qt_internal_library_deprecation_level(deprecation_define)
-
     if(NOT arg_HEADER_MODULE)
         qt_autogen_tools_initial_setup(${target})
     endif()
@@ -558,7 +556,6 @@ function(qt_internal_add_module target)
             QT_DEPRECATED_WARNINGS
             QT_BUILDING_QT
             QT_BUILD_${module_define_infix}_LIB ### FIXME: use QT_BUILD_ADDON for Add-ons or remove if we don't have add-ons anymore
-            ${deprecation_define}
             )
         list(APPEND arg_LIBRARIES Qt::PlatformModuleInternal)
     endif()
diff --git a/cmake/QtPlatformTargetHelpers.cmake b/cmake/QtPlatformTargetHelpers.cmake
index 54d1916f9e..94c34f2a1e 100644
--- a/cmake/QtPlatformTargetHelpers.cmake
+++ b/cmake/QtPlatformTargetHelpers.cmake
@@ -63,6 +63,16 @@ function(qt_internal_setup_public_platform_target)
 
     # Generate a pkgconfig for Qt::Platform.
     qt_internal_generate_pkg_config_file(Platform)
+
+    if(MSVC AND CLANG)
+        # Hack for clang-cl: for some unknown reason, the "/EHsc" or "/EHs-c-" flag will always be
+        # missing for some of our CMake targets and that results in compilation failure for static
+        # builds. I tried to disabled exception handling unconditionally for all our targets but it
+        # seems that some code inside Qt really need exception handling and it won't compile at all
+        # if we disable it forcely. So to make everyone happy, I choose to enable exception handling
+        # unconditionally in the end.
+        target_compile_options(Platform INTERFACE "/EHsc" "/GR")
+    endif()
 endfunction()
 
 function(qt_internal_get_platform_definition_include_dir install_interface build_interface)
diff --git a/cmake/VC-LTL.cmake b/cmake/VC-LTL.cmake
new file mode 100644
index 0000000000..2bab2f21d6
--- /dev/null
+++ b/cmake/VC-LTL.cmake
@@ -0,0 +1,94 @@
+﻿# https://github.com/Chuyu-Team/VC-LTL5
+
+#
+#  VC-LTL自动化加载配置，建议你将此文件单独复制到你的工程再使用，该文件能自动识别当前环境是否存在VC-LTL，并且自动应用。
+#
+#  使用方法：
+#    1. 在“CMakeLists.txt” 添加 “include("VC-LTL helper for cmake.cmake")”。
+#
+#  VC-LTL默认搜索顺序
+#    1. “VC-LTL helper for cmake.cmake”所在根目录，即 ${CMAKE_CURRENT_LIST_DIR}
+#    2. 当前CMake根目录，即 ${CMAKE_CURRENT_SOURCE_DIR}/VC-LTL
+#    3. 当前项目根目录，即 ${PROJECT_SOURCE_DIR}/VC-LTL
+#    4. 当前CMake父目录，即 ${CMAKE_CURRENT_SOURCE_DIR}/../VC-LTL
+#    5. 当前项目根目录，即 ${PROJECT_SOURCE_DIR}/../VC-LTL
+#    6. 注册表HKEY_CURRENT_USER\Code\VC-LTL@Root
+#
+#  把VC-LTL放在其中一个位置即可，VC-LTL就能被自动引用。
+#
+#  如果你对默认搜索顺序不满，你可以修改此文件。你也可以直接指定${VC_LTL_Root}宏更加任性的去加载VC-LTL。
+#
+
+if(NOT MSVC OR DEFINED __VC_LTL_CMAKE_INCLUDE_GUARD)
+    return()
+endif()
+set(__VC_LTL_CMAKE_INCLUDE_GUARD 1)
+
+#####################################################################VC-LTL设置#####################################################################
+
+#控制TargetPlatform版本，目前可用版本为5.1.2600.0     6.0.6000.0（默认）    6.2.9200.0     10.0.10240.0    10.0.19041.0
+if(NOT DEFINED WindowsTargetPlatformMinVersion)
+    set(WindowsTargetPlatformMinVersion "10.0.19041.0" CACHE STRING "" FORCE)
+endif()
+
+#启用干净的导入表，消除 ucrt apiset(如：api-ms-win-crt-time-l1-1-0.dll)，满足强迫症患者。
+if(NOT DEFINED CleanImport)
+    set(CleanImport "true" CACHE STRING "" FORCE)
+endif()
+
+####################################################################################################################################################
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${CMAKE_CURRENT_LIST_DIR}/_msvcrt.h)
+		set(VC_LTL_Root ${CMAKE_CURRENT_LIST_DIR})
+	endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/VC-LTL/_msvcrt.h)
+		set(VC_LTL_Root ${CMAKE_CURRENT_SOURCE_DIR}/VC-LTL)
+	endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${PROJECT_SOURCE_DIR}/VC-LTL/_msvcrt.h)
+        set(VC_LTL_Root ${PROJECT_SOURCE_DIR}/VC-LTL)
+    endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/../VC-LTL/_msvcrt.h)
+        set(VC_LTL_Root ${CMAKE_CURRENT_SOURCE_DIR}/../VC-LTL)
+    endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${PROJECT_SOURCE_DIR}/../VC-LTL/_msvcrt.h)
+        set(VC_LTL_Root ${PROJECT_SOURCE_DIR}/../VC-LTL)
+    endif()
+endif()
+
+if(NOT VC_LTL_Root)
+    EXECUTE_PROCESS(COMMAND reg query "HKEY_CURRENT_USER\\Code\\VC-LTL" -v "Root"
+                    OUTPUT_VARIABLE FOUND_FILE
+                    ERROR_VARIABLE ERROR_INFO
+                   )
+
+    string(REGEX MATCH "[a-zA-Z]:\\\\.+\\\\"
+           FOUND_LTL
+           ${FOUND_FILE})
+    if (NOT ${FOUND_LTL} STREQUAL "")
+        set(VC_LTL_Root ${FOUND_LTL})
+    endif()
+
+    if(NOT DEFINED VC_LTL_Root)
+        string(REGEX MATCH "\\\\\\\\.+\\\\" FOUND_LTL ${FOUND_FILE})
+        if (NOT ${FOUND_LTL} STREQUAL "")
+            set(VC_LTL_Root ${FOUND_LTL})
+        endif()
+    endif()
+endif()
+
+if(VC_LTL_Root)
+    include("${VC_LTL_Root}\\config\\config.cmake")
+endif()
diff --git a/cmake/YY-Thunks.cmake b/cmake/YY-Thunks.cmake
new file mode 100644
index 0000000000..f1ae33350a
--- /dev/null
+++ b/cmake/YY-Thunks.cmake
@@ -0,0 +1,102 @@
+#[[
+  MIT License
+
+  Copyright (C) 2023 by wangwenx190 (Yuhang Zhao)
+
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+  SOFTWARE.
+]]
+
+# https://github.com/Chuyu-Team/YY-Thunks
+
+if(NOT MSVC OR DEFINED __YY_THUNKS_CMAKE_INCLUDE_GUARD)
+    return()
+endif()
+set(__YY_THUNKS_CMAKE_INCLUDE_GUARD 1)
+
+if(NOT DEFINED YYTHUNKS_TARGET_OS)
+    set(YYTHUNKS_TARGET_OS "Vista" CACHE STRING "Supported values: Vista, WinXP" FORCE)
+endif()
+
+set(__yy_thunks_dir "")
+if(DEFINED ENV{YYTHUNKS_INSTALL_DIR})
+    set(__env "$ENV{YYTHUNKS_INSTALL_DIR}")
+    if(NOT "x${__env}" STREQUAL "x" AND EXISTS "${__env}")
+        set(__yy_thunks_dir "${__env}")
+    endif()
+endif()
+
+if("x${__yy_thunks_dir}" STREQUAL "x")
+    set(__yy_thunks_reg "")
+    cmake_host_system_information(RESULT __yy_thunks_reg
+        QUERY WINDOWS_REGISTRY "HKCU/Code/YY-Thunks"
+        VALUE "Root")
+    if(NOT "x${__yy_thunks_reg}" STREQUAL "x" AND EXISTS "${__yy_thunks_reg}")
+        set(__yy_thunks_dir "${__yy_thunks_reg}")
+    elseif(EXISTS "${CMAKE_CURRENT_LIST_DIR}/YY-Thunks")
+        set(__yy_thunks_dir "${CMAKE_CURRENT_LIST_DIR}/YY-Thunks")
+    elseif(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/YY-Thunks")
+        set(__yy_thunks_dir "${CMAKE_CURRENT_SOURCE_DIR}/YY-Thunks")
+    elseif(EXISTS "${PROJECT_SOURCE_DIR}/YY-Thunks")
+        set(__yy_thunks_dir "${PROJECT_SOURCE_DIR}/YY-Thunks")
+    elseif(EXISTS "${CMAKE_SOURCE_DIR}/YY-Thunks")
+        set(__yy_thunks_dir "${CMAKE_SOURCE_DIR}/YY-Thunks")
+    elseif(EXISTS "${CMAKE_SOURCE_DIR}/../YY-Thunks")
+        set(__yy_thunks_dir "${CMAKE_SOURCE_DIR}/../YY-Thunks")
+    endif()
+endif()
+
+if(NOT "x${__yy_thunks_dir}" STREQUAL "x")
+    cmake_path(NORMAL_PATH __yy_thunks_dir OUTPUT_VARIABLE __yy_thunks_dir)
+endif()
+
+if(NOT "x${__yy_thunks_dir}" STREQUAL "x" AND EXISTS "${__yy_thunks_dir}")
+    if(CMAKE_SIZEOF_VOID_P EQUAL 8)
+        set(__yy_thunks_arch x64)
+    else()
+        set(__yy_thunks_arch x86)
+    endif()
+    set(__yy_thunks_obj "${__yy_thunks_dir}/objs/${__yy_thunks_arch}/YY_Thunks_for_${YYTHUNKS_TARGET_OS}.obj")
+    cmake_path(NORMAL_PATH __yy_thunks_obj OUTPUT_VARIABLE __yy_thunks_obj)
+    if(EXISTS "${__yy_thunks_obj}")
+        set(YYTHUNKS_FOUND TRUE CACHE BOOL "" FORCE)
+        set(YYTHUNKS_INSTALL_DIR "${__yy_thunks_dir}" CACHE STRING "" FORCE)
+        set(YYTHUNKS_ARCH "${__yy_thunks_arch}" CACHE STRING "" FORCE)
+        set(YYTHUNKS_OBJ_FILE "YY_Thunks_for_${YYTHUNKS_TARGET_OS}.obj" CACHE STRING "" FORCE)
+        set(YYTHUNKS_OBJ_PATH "${__yy_thunks_obj}" CACHE STRING "" FORCE)
+        add_link_options("${__yy_thunks_obj}")
+        message("###################################################################################################")
+        message("#                                                                                                 #")
+        message("#           ██    ██ ██    ██       ████████ ██   ██ ██    ██ ███    ██ ██   ██ ███████           #")
+        message("#            ██  ██   ██  ██           ██    ██   ██ ██    ██ ████   ██ ██  ██  ██                #")
+        message("#             ████     ████   █████    ██    ███████ ██    ██ ██ ██  ██ █████   ███████           #")
+        message("#              ██       ██             ██    ██   ██ ██    ██ ██  ██ ██ ██  ██       ██           #")
+        message("#              ██       ██             ██    ██   ██  ██████  ██   ████ ██   ██ ███████           #")
+        message("#                                                                                                 #")
+        message("###################################################################################################")
+        message("")
+        message(" YY-Thunks install dir     :" ${__yy_thunks_dir})
+        message(" YY-Thunks target platform :" ${YYTHUNKS_TARGET_OS})
+        message(" YY-Thunks obj file path   :" ${__yy_thunks_obj})
+        message("")
+    else()
+        message(WARNING "YY-Thunks's obj file is missing!")
+    endif()
+else()
+    message(WARNING "Can't locate the YY-Thunks installation directory!")
+endif()
diff --git a/cmake/configure-cmake-mapping.md b/cmake/configure-cmake-mapping.md
index 383c64ca10..e7c962feef 100644
--- a/cmake/configure-cmake-mapping.md
+++ b/cmake/configure-cmake-mapping.md
@@ -127,6 +127,7 @@ The following table describes the mapping of configure options to CMake argument
 | -pcre [system/qt]                     | -DFEATURE_system_pcre2=ON/OFF                     |                                                                 |
 | -pps                                  | n/a                                               | QNX feature. Not available for 6.0.                             |
 | -zlib [system/qt]                     | -DFEATURE_system_zlib=ON/OFF                      |                                                                 |
+| -zstd [system/qt]                     | -DFEATURE_system_zstd=ON/OFF                      |                                                                 |
 | -ssl                                  | -DFEATURE_ssl=ON                                  |                                                                 |
 | -openssl [no/yes/linked/runtime]      | -DINPUT_openssl=no/yes/linked/runtime             |                                                                 |
 | -openssl-linked                       | -DINPUT_openssl=linked                            |                                                                 |
diff --git a/config_help.txt b/config_help.txt
index 3c78115e29..3bd9a0da6e 100644
--- a/config_help.txt
+++ b/config_help.txt
@@ -220,6 +220,7 @@ Core options:
   -icu ................. Enable ICU support [auto]
   -pcre ................ Select used libpcre2 [system/qt/no]
   -zlib ................ Select used zlib [system/qt]
+  -zstd ................ Select used zstd [system/qt]
 
   Logging backends:
     -journald .......... Enable journald support [no] (Unix only)
diff --git a/configure.cmake b/configure.cmake
index f9d902fd9c..1b05cadd02 100644
--- a/configure.cmake
+++ b/configure.cmake
@@ -106,7 +106,7 @@ SSL_free(SSL_new(0));
 ")
 
 # special case end
-qt_find_package(WrapZSTD 1.3 PROVIDED_TARGETS WrapZSTD::WrapZSTD MODULE_NAME global QMAKE_LIB zstd)
+qt_find_package(WrapSystemZSTD 1.3 PROVIDED_TARGETS WrapSystemZSTD::WrapSystemZSTD MODULE_NAME global QMAKE_LIB zstd)
 qt_find_package(WrapDBus1 1.2 PROVIDED_TARGETS dbus-1 MODULE_NAME global QMAKE_LIB dbus)
 qt_find_package(Libudev PROVIDED_TARGETS PkgConfig::Libudev MODULE_NAME global QMAKE_LIB libudev)
 qt_find_package(LTTngUST PROVIDED_TARGETS LTTng::UST MODULE_NAME core QMAKE_LIB lttng-ust)
@@ -971,9 +971,9 @@ qt_feature("system-zlib" PRIVATE
     LABEL "Using system zlib"
     CONDITION WrapSystemZLIB_FOUND
 )
-qt_feature("zstd" PUBLIC
-    LABEL "Zstandard support"
-    CONDITION WrapZSTD_FOUND
+qt_feature("system-zstd" PRIVATE
+    LABEL "Using system ZSTD"
+    CONDITION WrapSystemZSTD_FOUND
 )
 qt_feature("stdlib-libcpp" PRIVATE
     LABEL "Using stdlib=libc++"
@@ -1127,10 +1127,22 @@ qt_feature("relocatable" PRIVATE
     AUTODETECT QT_FEATURE_shared
     CONDITION QT_FEATURE_dlopen OR WIN32 OR NOT QT_FEATURE_shared
 )
+qt_feature("cfguard" PRIVATE
+    LABEL "Enable control flow guard"
+    CONDITION INPUT_cfguard STREQUAL yes
+)
 qt_feature("intelcet" PRIVATE
     LABEL "Using Intel CET"
     CONDITION ( INPUT_intelcet STREQUAL yes ) OR TEST_intelcet
 )
+qt_feature("spectre" PRIVATE
+    LABEL "Mitigate Spectre issues"
+    CONDITION INPUT_spectre STREQUAL yes
+)
+qt_feature("ehcont" PRIVATE
+    LABEL "Ehcont guard"
+    CONDITION INPUT_ehcont STREQUAL yes
+)
 qt_configure_add_summary_build_type_and_config()
 qt_configure_add_summary_section(NAME "Build options")
 qt_configure_add_summary_build_mode(Mode)
@@ -1183,7 +1195,10 @@ qt_configure_add_summary_entry(
 qt_configure_add_summary_entry(ARGS "relocatable")
 qt_configure_add_summary_entry(ARGS "precompile_header")
 qt_configure_add_summary_entry(ARGS "ltcg")
+qt_configure_add_summary_entry(ARGS "cfguard")
 qt_configure_add_summary_entry(ARGS "intelcet")
+qt_configure_add_summary_entry(ARGS "spectre")
+qt_configure_add_summary_entry(ARGS "ehcont")
 qt_configure_add_summary_entry(
     ARGS "wasm-simd128"
     CONDITION ( TEST_architecture_arch STREQUAL wasm )
@@ -1247,7 +1262,7 @@ qt_configure_add_summary_entry(ARGS "openssl-linked")
 qt_configure_add_summary_entry(ARGS "opensslv11")
 qt_configure_add_summary_entry(ARGS "opensslv30")
 qt_configure_add_summary_entry(ARGS "system-zlib")
-qt_configure_add_summary_entry(ARGS "zstd")
+qt_configure_add_summary_entry(ARGS "system-zstd")
 qt_configure_add_summary_entry(ARGS "thread")
 qt_configure_end_summary_section() # end of "Support enabled for" section
 qt_configure_add_report_entry(
diff --git a/mkspecs/features/resources.prf b/mkspecs/features/resources.prf
index ab9761a83c..115eeaa6e3 100644
--- a/mkspecs/features/resources.prf
+++ b/mkspecs/features/resources.prf
@@ -4,7 +4,6 @@ isEmpty(QMAKE_MOD_RCC):QMAKE_MOD_RCC = qrc
 
 !contains(QMAKE_RESOURCE_FLAGS, -root):!isEmpty(QMAKE_RESOURCE_ROOT):QMAKE_RESOURCE_FLAGS += -root $$QMAKE_RESOURCE_ROOT
 !contains(QMAKE_RESOURCE_FLAGS, -name): QMAKE_RESOURCE_FLAGS += -name ${QMAKE_FILE_BASE}
-!qtConfig(zstd): QMAKE_RESOURCE_FLAGS += --no-zstd
 
 load(resources_functions)
 qtFlattenResources()
diff --git a/qmake/CMakeLists.txt b/qmake/CMakeLists.txt
index d3e8f56a54..07f79a14d9 100644
--- a/qmake/CMakeLists.txt
+++ b/qmake/CMakeLists.txt
@@ -126,12 +126,6 @@ qt_internal_extend_target(${target_name} CONDITION WIN32
         _SCL_SECURE_NO_WARNINGS
 )
 
-qt_internal_extend_target(${target_name} CONDITION CLANG AND WIN32
-    COMPILE_OPTIONS
-        "-fms-compatibility-version=19.00.23506"
-        "-Wno-microsoft-enum-value"
-)
-
 # special case:
 set_target_properties(${target_name} PROPERTIES
     AUTOMOC OFF
diff --git a/qt_cmdline.cmake b/qt_cmdline.cmake
index 5450b2562c..4143a81b18 100644
--- a/qt_cmdline.cmake
+++ b/qt_cmdline.cmake
@@ -73,7 +73,10 @@ qt_commandline_option(openssl-linked TYPE void NAME openssl VALUE linked)
 qt_commandline_option(openssl-runtime TYPE void NAME openssl VALUE runtime)
 qt_commandline_option(linker TYPE optionalString VALUES bfd gold lld mold)
 qt_commandline_option(ltcg TYPE boolean)
+qt_commandline_option(cfguard TYPE boolean)
 qt_commandline_option(intelcet TYPE boolean)
+qt_commandline_option(spectre TYPE boolean)
+qt_commandline_option(ehcont TYPE boolean)
 # special case begin
 qt_commandline_option(make TYPE addString VALUES examples libs tests tools
                       benchmarks manual-tests minimal-static-tests)
@@ -124,7 +127,7 @@ qt_commandline_option(Werror TYPE boolean NAME warnings_are_errors)
 qt_commandline_option(widgets TYPE boolean)
 qt_commandline_option(xplatform TYPE string)
 qt_commandline_option(zlib TYPE enum NAME system-zlib MAPPING system yes qt no)
-qt_commandline_option(zstd TYPE boolean)
+qt_commandline_option(zstd TYPE enum NAME system-zstd MAPPING system yes qt no)
 qt_commandline_prefix(D defines)
 qt_commandline_prefix(F fpaths)
 qt_commandline_prefix(I includes)
diff --git a/src/3rdparty/zstd/CMakeLists.txt b/src/3rdparty/zstd/CMakeLists.txt
new file mode 100644
index 0000000000..de0494384d
--- /dev/null
+++ b/src/3rdparty/zstd/CMakeLists.txt
@@ -0,0 +1,105 @@
+qt_internal_add_3rdparty_library(BundledZSTD
+    STATIC
+    SKIP_AUTOMOC
+    SOURCES
+        src/zdict.h
+        src/zstd.h
+        src/zstd_errors.h
+        src/common/allocations.h
+        src/common/bits.h
+        src/common/bitstream.h
+        src/common/compiler.h
+        src/common/cpu.h
+        src/common/debug.c
+        src/common/debug.h
+        src/common/entropy_common.c
+        src/common/error_private.c
+        src/common/error_private.h
+        src/common/fse.h
+        src/common/fse_decompress.c
+        src/common/huf.h
+        src/common/mem.h
+        src/common/pool.c
+        src/common/pool.h
+        src/common/portability_macros.h
+        src/common/threading.c
+        src/common/threading.h
+        src/common/xxhash.c
+        src/common/xxhash.h
+        src/common/zstd_common.c
+        src/common/zstd_deps.h
+        src/common/zstd_internal.h
+        src/common/zstd_trace.h
+        src/compress/clevels.h
+        src/compress/fse_compress.c
+        src/compress/hist.c
+        src/compress/hist.h
+        src/compress/huf_compress.c
+        src/compress/zstdmt_compress.c
+        src/compress/zstdmt_compress.h
+        src/compress/zstd_compress.c
+        src/compress/zstd_compress_internal.h
+        src/compress/zstd_compress_literals.c
+        src/compress/zstd_compress_literals.h
+        src/compress/zstd_compress_sequences.c
+        src/compress/zstd_compress_sequences.h
+        src/compress/zstd_compress_superblock.c
+        src/compress/zstd_compress_superblock.h
+        src/compress/zstd_cwksp.h
+        src/compress/zstd_double_fast.c
+        src/compress/zstd_double_fast.h
+        src/compress/zstd_fast.c
+        src/compress/zstd_fast.h
+        src/compress/zstd_lazy.c
+        src/compress/zstd_lazy.h
+        src/compress/zstd_ldm.c
+        src/compress/zstd_ldm.h
+        src/compress/zstd_ldm_geartab.h
+        src/compress/zstd_opt.c
+        src/compress/zstd_opt.h
+        src/decompress/huf_decompress.c
+        src/decompress/zstd_ddict.c
+        src/decompress/zstd_ddict.h
+        src/decompress/zstd_decompress.c
+        src/decompress/zstd_decompress_block.c
+        src/decompress/zstd_decompress_block.h
+        src/decompress/zstd_decompress_internal.h
+        src/dictBuilder/cover.c
+        src/dictBuilder/cover.h
+        src/dictBuilder/divsufsort.c
+        src/dictBuilder/divsufsort.h
+        src/dictBuilder/fastcover.c
+        src/dictBuilder/zdict.c
+    DEFINES
+        XXH_NAMESPACE=ZSTD_ # Always hide XXHash symbols
+        ZSTD_LEGACY_SUPPORT=0
+        ZSTD_MULTITHREAD
+        QT_BUILD_CORE_LIB
+    INCLUDE_DIRECTORIES
+        $<TARGET_PROPERTY:Core,INCLUDE_DIRECTORIES>
+)
+
+qt_internal_extend_target(BundledZSTD CONDITION MSVC
+    DEFINES
+        ZSTD_DISABLE_ASM
+        ZSTD_HEAPMODE=0
+        _CRT_SECURE_NO_WARNINGS
+)
+
+qt_internal_extend_target(BundledZSTD CONDITION NOT MSVC
+    SOURCES
+        src/decompress/huf_decompress_amd64.S
+)
+
+qt_internal_add_sync_header_dependencies(BundledZSTD Core)
+
+qt_disable_warnings(BundledZSTD)
+
+qt_set_symbol_visibility_hidden(BundledZSTD)
+
+qt_internal_add_3rdparty_header_module(ZstdPrivate
+    EXTERNAL_HEADERS
+        src/zdict.h
+        src/zstd.h
+        src/zstd_errors.h
+)
diff --git a/src/3rdparty/zstd/LICENSE b/src/3rdparty/zstd/LICENSE
new file mode 100644
index 0000000000..75800288cc
--- /dev/null
+++ b/src/3rdparty/zstd/LICENSE
@@ -0,0 +1,30 @@
+BSD License
+
+For Zstandard software
+
+Copyright (c) Meta Platforms, Inc. and affiliates. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+ * Redistributions of source code must retain the above copyright notice, this
+   list of conditions and the following disclaimer.
+
+ * Redistributions in binary form must reproduce the above copyright notice,
+   this list of conditions and the following disclaimer in the documentation
+   and/or other materials provided with the distribution.
+
+ * Neither the name Facebook, nor Meta, nor the names of its contributors may
+   be used to endorse or promote products derived from this software without
+   specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/src/3rdparty/zstd/qt_attribution.json b/src/3rdparty/zstd/qt_attribution.json
new file mode 100644
index 0000000000..79a22a29f5
--- /dev/null
+++ b/src/3rdparty/zstd/qt_attribution.json
@@ -0,0 +1,17 @@
+{
+    "Id": "zstd",
+    "Name": "Data Compression Library (zstd)",
+    "QDocModule": "qtcore",
+    "QtUsage": "Optionally used in Qt Core and development tools. Configure with -system-zstd to avoid.",
+    "SecurityCritical": true,
+
+    "Description": "Zstandard - Fast real-time compression algorithm.",
+    "Homepage": "https://facebook.github.io/zstd/",
+    "Version": "1.5.5",
+    "DownloadLocation": "https://github.com/facebook/zstd/releases/download/v1.5.5/zstd-1.5.5.tar.gz",
+
+    "License": "BSD License",
+    "LicenseId": "BSD",
+    "LicenseFile": "LICENSE",
+    "Copyright": "(c) Meta Platforms, Inc. and affiliates"
+}
diff --git a/src/3rdparty/zstd/src/common/allocations.h b/src/3rdparty/zstd/src/common/allocations.h
new file mode 100644
index 0000000000..a3153c4bac
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/allocations.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+/* This file provides custom allocation primitives
+ */
+
+#define ZSTD_DEPS_NEED_MALLOC
+#include "zstd_deps.h"   /* ZSTD_malloc, ZSTD_calloc, ZSTD_free, ZSTD_memset */
+
+#include "mem.h" /* MEM_STATIC */
+#define ZSTD_STATIC_LINKING_ONLY
+#include "../zstd.h" /* ZSTD_customMem */
+
+#ifndef ZSTD_ALLOCATIONS_H
+#define ZSTD_ALLOCATIONS_H
+
+/* custom memory allocation functions */
+
+MEM_STATIC void* ZSTD_customMalloc(size_t size, ZSTD_customMem customMem)
+{
+    if (customMem.customAlloc)
+        return customMem.customAlloc(customMem.opaque, size);
+    return ZSTD_malloc(size);
+}
+
+MEM_STATIC void* ZSTD_customCalloc(size_t size, ZSTD_customMem customMem)
+{
+    if (customMem.customAlloc) {
+        /* calloc implemented as malloc+memset;
+         * not as efficient as calloc, but next best guess for custom malloc */
+        void* const ptr = customMem.customAlloc(customMem.opaque, size);
+        ZSTD_memset(ptr, 0, size);
+        return ptr;
+    }
+    return ZSTD_calloc(1, size);
+}
+
+MEM_STATIC void ZSTD_customFree(void* ptr, ZSTD_customMem customMem)
+{
+    if (ptr!=NULL) {
+        if (customMem.customFree)
+            customMem.customFree(customMem.opaque, ptr);
+        else
+            ZSTD_free(ptr);
+    }
+}
+
+#endif /* ZSTD_ALLOCATIONS_H */
diff --git a/src/3rdparty/zstd/src/common/bits.h b/src/3rdparty/zstd/src/common/bits.h
new file mode 100644
index 0000000000..def56c474c
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/bits.h
@@ -0,0 +1,200 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_BITS_H
+#define ZSTD_BITS_H
+
+#include "mem.h"
+
+MEM_STATIC unsigned ZSTD_countTrailingZeros32_fallback(U32 val)
+{
+    assert(val != 0);
+    {
+        static const U32 DeBruijnBytePos[32] = {0, 1, 28, 2, 29, 14, 24, 3,
+                                                30, 22, 20, 15, 25, 17, 4, 8,
+                                                31, 27, 13, 23, 21, 19, 16, 7,
+                                                26, 12, 18, 6, 11, 5, 10, 9};
+        return DeBruijnBytePos[((U32) ((val & -(S32) val) * 0x077CB531U)) >> 27];
+    }
+}
+
+MEM_STATIC unsigned ZSTD_countTrailingZeros32(U32 val)
+{
+    assert(val != 0);
+#   if defined(_MSC_VER)
+#       if STATIC_BMI2 == 1
+            return (unsigned)_tzcnt_u32(val);
+#       else
+            if (val != 0) {
+                unsigned long r;
+                _BitScanForward(&r, val);
+                return (unsigned)r;
+            } else {
+                /* Should not reach this code path */
+                __assume(0);
+            }
+#       endif
+#   elif defined(__GNUC__) && (__GNUC__ >= 4)
+        return (unsigned)__builtin_ctz(val);
+#   else
+        return ZSTD_countTrailingZeros32_fallback(val);
+#   endif
+}
+
+MEM_STATIC unsigned ZSTD_countLeadingZeros32_fallback(U32 val) {
+    assert(val != 0);
+    {
+        static const U32 DeBruijnClz[32] = {0, 9, 1, 10, 13, 21, 2, 29,
+                                            11, 14, 16, 18, 22, 25, 3, 30,
+                                            8, 12, 20, 28, 15, 17, 24, 7,
+                                            19, 27, 23, 6, 26, 5, 4, 31};
+        val |= val >> 1;
+        val |= val >> 2;
+        val |= val >> 4;
+        val |= val >> 8;
+        val |= val >> 16;
+        return 31 - DeBruijnClz[(val * 0x07C4ACDDU) >> 27];
+    }
+}
+
+MEM_STATIC unsigned ZSTD_countLeadingZeros32(U32 val)
+{
+    assert(val != 0);
+#   if defined(_MSC_VER)
+#       if STATIC_BMI2 == 1
+            return (unsigned)_lzcnt_u32(val);
+#       else
+            if (val != 0) {
+                unsigned long r;
+                _BitScanReverse(&r, val);
+                return (unsigned)(31 - r);
+            } else {
+                /* Should not reach this code path */
+                __assume(0);
+            }
+#       endif
+#   elif defined(__GNUC__) && (__GNUC__ >= 4)
+        return (unsigned)__builtin_clz(val);
+#   else
+        return ZSTD_countLeadingZeros32_fallback(val);
+#   endif
+}
+
+MEM_STATIC unsigned ZSTD_countTrailingZeros64(U64 val)
+{
+    assert(val != 0);
+#   if defined(_MSC_VER) && defined(_WIN64)
+#       if STATIC_BMI2 == 1
+            return (unsigned)_tzcnt_u64(val);
+#       else
+            if (val != 0) {
+                unsigned long r;
+                _BitScanForward64(&r, val);
+                return (unsigned)r;
+            } else {
+                /* Should not reach this code path */
+                __assume(0);
+            }
+#       endif
+#   elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(__LP64__)
+        return (unsigned)__builtin_ctzll(val);
+#   else
+        {
+            U32 mostSignificantWord = (U32)(val >> 32);
+            U32 leastSignificantWord = (U32)val;
+            if (leastSignificantWord == 0) {
+                return 32 + ZSTD_countTrailingZeros32(mostSignificantWord);
+            } else {
+                return ZSTD_countTrailingZeros32(leastSignificantWord);
+            }
+        }
+#   endif
+}
+
+MEM_STATIC unsigned ZSTD_countLeadingZeros64(U64 val)
+{
+    assert(val != 0);
+#   if defined(_MSC_VER) && defined(_WIN64)
+#       if STATIC_BMI2 == 1
+            return (unsigned)_lzcnt_u64(val);
+#       else
+            if (val != 0) {
+                unsigned long r;
+                _BitScanReverse64(&r, val);
+                return (unsigned)(63 - r);
+            } else {
+                /* Should not reach this code path */
+                __assume(0);
+            }
+#       endif
+#   elif defined(__GNUC__) && (__GNUC__ >= 4)
+        return (unsigned)(__builtin_clzll(val));
+#   else
+        {
+            U32 mostSignificantWord = (U32)(val >> 32);
+            U32 leastSignificantWord = (U32)val;
+            if (mostSignificantWord == 0) {
+                return 32 + ZSTD_countLeadingZeros32(leastSignificantWord);
+            } else {
+                return ZSTD_countLeadingZeros32(mostSignificantWord);
+            }
+        }
+#   endif
+}
+
+MEM_STATIC unsigned ZSTD_NbCommonBytes(size_t val)
+{
+    if (MEM_isLittleEndian()) {
+        if (MEM_64bits()) {
+            return ZSTD_countTrailingZeros64((U64)val) >> 3;
+        } else {
+            return ZSTD_countTrailingZeros32((U32)val) >> 3;
+        }
+    } else {  /* Big Endian CPU */
+        if (MEM_64bits()) {
+            return ZSTD_countLeadingZeros64((U64)val) >> 3;
+        } else {
+            return ZSTD_countLeadingZeros32((U32)val) >> 3;
+        }
+    }
+}
+
+MEM_STATIC unsigned ZSTD_highbit32(U32 val)   /* compress, dictBuilder, decodeCorpus */
+{
+    assert(val != 0);
+    return 31 - ZSTD_countLeadingZeros32(val);
+}
+
+/* ZSTD_rotateRight_*():
+ * Rotates a bitfield to the right by "count" bits.
+ * https://en.wikipedia.org/w/index.php?title=Circular_shift&oldid=991635599#Implementing_circular_shifts
+ */
+MEM_STATIC
+U64 ZSTD_rotateRight_U64(U64 const value, U32 count) {
+    assert(count < 64);
+    count &= 0x3F; /* for fickle pattern recognition */
+    return (value >> count) | (U64)(value << ((0U - count) & 0x3F));
+}
+
+MEM_STATIC
+U32 ZSTD_rotateRight_U32(U32 const value, U32 count) {
+    assert(count < 32);
+    count &= 0x1F; /* for fickle pattern recognition */
+    return (value >> count) | (U32)(value << ((0U - count) & 0x1F));
+}
+
+MEM_STATIC
+U16 ZSTD_rotateRight_U16(U16 const value, U32 count) {
+    assert(count < 16);
+    count &= 0x0F; /* for fickle pattern recognition */
+    return (value >> count) | (U16)(value << ((0U - count) & 0x0F));
+}
+
+#endif /* ZSTD_BITS_H */
diff --git a/src/3rdparty/zstd/src/common/bitstream.h b/src/3rdparty/zstd/src/common/bitstream.h
new file mode 100644
index 0000000000..72b0b3df22
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/bitstream.h
@@ -0,0 +1,437 @@
+/* ******************************************************************
+ * bitstream
+ * Part of FSE library
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * You can contact the author at :
+ * - Source repository : https://github.com/Cyan4973/FiniteStateEntropy
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+****************************************************************** */
+#ifndef BITSTREAM_H_MODULE
+#define BITSTREAM_H_MODULE
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+/*
+*  This API consists of small unitary functions, which must be inlined for best performance.
+*  Since link-time-optimization is not available for all compilers,
+*  these functions are defined into a .h to be included.
+*/
+
+/*-****************************************
+*  Dependencies
+******************************************/
+#include "mem.h"            /* unaligned access routines */
+#include "compiler.h"       /* UNLIKELY() */
+#include "debug.h"          /* assert(), DEBUGLOG(), RAWLOG() */
+#include "error_private.h"  /* error codes and messages */
+#include "bits.h"           /* ZSTD_highbit32 */
+
+
+/*=========================================
+*  Target specific
+=========================================*/
+#ifndef ZSTD_NO_INTRINSICS
+#  if (defined(__BMI__) || defined(__BMI2__)) && defined(__GNUC__)
+#    include <immintrin.h>   /* support for bextr (experimental)/bzhi */
+#  elif defined(__ICCARM__)
+#    include <intrinsics.h>
+#  endif
+#endif
+
+#define STREAM_ACCUMULATOR_MIN_32  25
+#define STREAM_ACCUMULATOR_MIN_64  57
+#define STREAM_ACCUMULATOR_MIN    ((U32)(MEM_32bits() ? STREAM_ACCUMULATOR_MIN_32 : STREAM_ACCUMULATOR_MIN_64))
+
+
+/*-******************************************
+*  bitStream encoding API (write forward)
+********************************************/
+/* bitStream can mix input from multiple sources.
+ * A critical property of these streams is that they encode and decode in **reverse** direction.
+ * So the first bit sequence you add will be the last to be read, like a LIFO stack.
+ */
+typedef struct {
+    size_t bitContainer;
+    unsigned bitPos;
+    char*  startPtr;
+    char*  ptr;
+    char*  endPtr;
+} BIT_CStream_t;
+
+MEM_STATIC size_t BIT_initCStream(BIT_CStream_t* bitC, void* dstBuffer, size_t dstCapacity);
+MEM_STATIC void   BIT_addBits(BIT_CStream_t* bitC, size_t value, unsigned nbBits);
+MEM_STATIC void   BIT_flushBits(BIT_CStream_t* bitC);
+MEM_STATIC size_t BIT_closeCStream(BIT_CStream_t* bitC);
+
+/* Start with initCStream, providing the size of buffer to write into.
+*  bitStream will never write outside of this buffer.
+*  `dstCapacity` must be >= sizeof(bitD->bitContainer), otherwise @return will be an error code.
+*
+*  bits are first added to a local register.
+*  Local register is size_t, hence 64-bits on 64-bits systems, or 32-bits on 32-bits systems.
+*  Writing data into memory is an explicit operation, performed by the flushBits function.
+*  Hence keep track how many bits are potentially stored into local register to avoid register overflow.
+*  After a flushBits, a maximum of 7 bits might still be stored into local register.
+*
+*  Avoid storing elements of more than 24 bits if you want compatibility with 32-bits bitstream readers.
+*
+*  Last operation is to close the bitStream.
+*  The function returns the final size of CStream in bytes.
+*  If data couldn't fit into `dstBuffer`, it will return a 0 ( == not storable)
+*/
+
+
+/*-********************************************
+*  bitStream decoding API (read backward)
+**********************************************/
+typedef struct {
+    size_t   bitContainer;
+    unsigned bitsConsumed;
+    const char* ptr;
+    const char* start;
+    const char* limitPtr;
+} BIT_DStream_t;
+
+typedef enum { BIT_DStream_unfinished = 0,
+               BIT_DStream_endOfBuffer = 1,
+               BIT_DStream_completed = 2,
+               BIT_DStream_overflow = 3 } BIT_DStream_status;  /* result of BIT_reloadDStream() */
+               /* 1,2,4,8 would be better for bitmap combinations, but slows down performance a bit ... :( */
+
+MEM_STATIC size_t   BIT_initDStream(BIT_DStream_t* bitD, const void* srcBuffer, size_t srcSize);
+MEM_STATIC size_t   BIT_readBits(BIT_DStream_t* bitD, unsigned nbBits);
+MEM_STATIC BIT_DStream_status BIT_reloadDStream(BIT_DStream_t* bitD);
+MEM_STATIC unsigned BIT_endOfDStream(const BIT_DStream_t* bitD);
+
+
+/* Start by invoking BIT_initDStream().
+*  A chunk of the bitStream is then stored into a local register.
+*  Local register size is 64-bits on 64-bits systems, 32-bits on 32-bits systems (size_t).
+*  You can then retrieve bitFields stored into the local register, **in reverse order**.
+*  Local register is explicitly reloaded from memory by the BIT_reloadDStream() method.
+*  A reload guarantee a minimum of ((8*sizeof(bitD->bitContainer))-7) bits when its result is BIT_DStream_unfinished.
+*  Otherwise, it can be less than that, so proceed accordingly.
+*  Checking if DStream has reached its end can be performed with BIT_endOfDStream().
+*/
+
+
+/*-****************************************
+*  unsafe API
+******************************************/
+MEM_STATIC void BIT_addBitsFast(BIT_CStream_t* bitC, size_t value, unsigned nbBits);
+/* faster, but works only if value is "clean", meaning all high bits above nbBits are 0 */
+
+MEM_STATIC void BIT_flushBitsFast(BIT_CStream_t* bitC);
+/* unsafe version; does not check buffer overflow */
+
+MEM_STATIC size_t BIT_readBitsFast(BIT_DStream_t* bitD, unsigned nbBits);
+/* faster, but works only if nbBits >= 1 */
+
+/*=====    Local Constants   =====*/
+static const unsigned BIT_mask[] = {
+    0,          1,         3,         7,         0xF,       0x1F,
+    0x3F,       0x7F,      0xFF,      0x1FF,     0x3FF,     0x7FF,
+    0xFFF,      0x1FFF,    0x3FFF,    0x7FFF,    0xFFFF,    0x1FFFF,
+    0x3FFFF,    0x7FFFF,   0xFFFFF,   0x1FFFFF,  0x3FFFFF,  0x7FFFFF,
+    0xFFFFFF,   0x1FFFFFF, 0x3FFFFFF, 0x7FFFFFF, 0xFFFFFFF, 0x1FFFFFFF,
+    0x3FFFFFFF, 0x7FFFFFFF}; /* up to 31 bits */
+#define BIT_MASK_SIZE (sizeof(BIT_mask) / sizeof(BIT_mask[0]))
+
+/*-**************************************************************
+*  bitStream encoding
+****************************************************************/
+/*! BIT_initCStream() :
+ *  `dstCapacity` must be > sizeof(size_t)
+ *  @return : 0 if success,
+ *            otherwise an error code (can be tested using ERR_isError()) */
+MEM_STATIC size_t BIT_initCStream(BIT_CStream_t* bitC,
+                                  void* startPtr, size_t dstCapacity)
+{
+    bitC->bitContainer = 0;
+    bitC->bitPos = 0;
+    bitC->startPtr = (char*)startPtr;
+    bitC->ptr = bitC->startPtr;
+    bitC->endPtr = bitC->startPtr + dstCapacity - sizeof(bitC->bitContainer);
+    if (dstCapacity <= sizeof(bitC->bitContainer)) return ERROR(dstSize_tooSmall);
+    return 0;
+}
+
+MEM_STATIC FORCE_INLINE_ATTR size_t BIT_getLowerBits(size_t bitContainer, U32 const nbBits)
+{
+#if defined(STATIC_BMI2) && STATIC_BMI2 == 1 && !defined(ZSTD_NO_INTRINSICS)
+    return  _bzhi_u64(bitContainer, nbBits);
+#else
+    assert(nbBits < BIT_MASK_SIZE);
+    return bitContainer & BIT_mask[nbBits];
+#endif
+}
+
+/*! BIT_addBits() :
+ *  can add up to 31 bits into `bitC`.
+ *  Note : does not check for register overflow ! */
+MEM_STATIC void BIT_addBits(BIT_CStream_t* bitC,
+                            size_t value, unsigned nbBits)
+{
+    DEBUG_STATIC_ASSERT(BIT_MASK_SIZE == 32);
+    assert(nbBits < BIT_MASK_SIZE);
+    assert(nbBits + bitC->bitPos < sizeof(bitC->bitContainer) * 8);
+    bitC->bitContainer |= BIT_getLowerBits(value, nbBits) << bitC->bitPos;
+    bitC->bitPos += nbBits;
+}
+
+/*! BIT_addBitsFast() :
+ *  works only if `value` is _clean_,
+ *  meaning all high bits above nbBits are 0 */
+MEM_STATIC void BIT_addBitsFast(BIT_CStream_t* bitC,
+                                size_t value, unsigned nbBits)
+{
+    assert((value>>nbBits) == 0);
+    assert(nbBits + bitC->bitPos < sizeof(bitC->bitContainer) * 8);
+    bitC->bitContainer |= value << bitC->bitPos;
+    bitC->bitPos += nbBits;
+}
+
+/*! BIT_flushBitsFast() :
+ *  assumption : bitContainer has not overflowed
+ *  unsafe version; does not check buffer overflow */
+MEM_STATIC void BIT_flushBitsFast(BIT_CStream_t* bitC)
+{
+    size_t const nbBytes = bitC->bitPos >> 3;
+    assert(bitC->bitPos < sizeof(bitC->bitContainer) * 8);
+    assert(bitC->ptr <= bitC->endPtr);
+    MEM_writeLEST(bitC->ptr, bitC->bitContainer);
+    bitC->ptr += nbBytes;
+    bitC->bitPos &= 7;
+    bitC->bitContainer >>= nbBytes*8;
+}
+
+/*! BIT_flushBits() :
+ *  assumption : bitContainer has not overflowed
+ *  safe version; check for buffer overflow, and prevents it.
+ *  note : does not signal buffer overflow.
+ *  overflow will be revealed later on using BIT_closeCStream() */
+MEM_STATIC void BIT_flushBits(BIT_CStream_t* bitC)
+{
+    size_t const nbBytes = bitC->bitPos >> 3;
+    assert(bitC->bitPos < sizeof(bitC->bitContainer) * 8);
+    assert(bitC->ptr <= bitC->endPtr);
+    MEM_writeLEST(bitC->ptr, bitC->bitContainer);
+    bitC->ptr += nbBytes;
+    if (bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;
+    bitC->bitPos &= 7;
+    bitC->bitContainer >>= nbBytes*8;
+}
+
+/*! BIT_closeCStream() :
+ *  @return : size of CStream, in bytes,
+ *            or 0 if it could not fit into dstBuffer */
+MEM_STATIC size_t BIT_closeCStream(BIT_CStream_t* bitC)
+{
+    BIT_addBitsFast(bitC, 1, 1);   /* endMark */
+    BIT_flushBits(bitC);
+    if (bitC->ptr >= bitC->endPtr) return 0; /* overflow detected */
+    return (bitC->ptr - bitC->startPtr) + (bitC->bitPos > 0);
+}
+
+
+/*-********************************************************
+*  bitStream decoding
+**********************************************************/
+/*! BIT_initDStream() :
+ *  Initialize a BIT_DStream_t.
+ * `bitD` : a pointer to an already allocated BIT_DStream_t structure.
+ * `srcSize` must be the *exact* size of the bitStream, in bytes.
+ * @return : size of stream (== srcSize), or an errorCode if a problem is detected
+ */
+MEM_STATIC size_t BIT_initDStream(BIT_DStream_t* bitD, const void* srcBuffer, size_t srcSize)
+{
+    if (srcSize < 1) { ZSTD_memset(bitD, 0, sizeof(*bitD)); return ERROR(srcSize_wrong); }
+
+    bitD->start = (const char*)srcBuffer;
+    bitD->limitPtr = bitD->start + sizeof(bitD->bitContainer);
+
+    if (srcSize >=  sizeof(bitD->bitContainer)) {  /* normal case */
+        bitD->ptr   = (const char*)srcBuffer + srcSize - sizeof(bitD->bitContainer);
+        bitD->bitContainer = MEM_readLEST(bitD->ptr);
+        { BYTE const lastByte = ((const BYTE*)srcBuffer)[srcSize-1];
+          bitD->bitsConsumed = lastByte ? 8 - ZSTD_highbit32(lastByte) : 0;  /* ensures bitsConsumed is always set */
+          if (lastByte == 0) return ERROR(GENERIC); /* endMark not present */ }
+    } else {
+        bitD->ptr   = bitD->start;
+        bitD->bitContainer = *(const BYTE*)(bitD->start);
+        switch(srcSize)
+        {
+        case 7: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[6]) << (sizeof(bitD->bitContainer)*8 - 16);
+                ZSTD_FALLTHROUGH;
+
+        case 6: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[5]) << (sizeof(bitD->bitContainer)*8 - 24);
+                ZSTD_FALLTHROUGH;
+
+        case 5: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[4]) << (sizeof(bitD->bitContainer)*8 - 32);
+                ZSTD_FALLTHROUGH;
+
+        case 4: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[3]) << 24;
+                ZSTD_FALLTHROUGH;
+
+        case 3: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[2]) << 16;
+                ZSTD_FALLTHROUGH;
+
+        case 2: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[1]) <<  8;
+                ZSTD_FALLTHROUGH;
+
+        default: break;
+        }
+        {   BYTE const lastByte = ((const BYTE*)srcBuffer)[srcSize-1];
+            bitD->bitsConsumed = lastByte ? 8 - ZSTD_highbit32(lastByte) : 0;
+            if (lastByte == 0) return ERROR(corruption_detected);  /* endMark not present */
+        }
+        bitD->bitsConsumed += (U32)(sizeof(bitD->bitContainer) - srcSize)*8;
+    }
+
+    return srcSize;
+}
+
+MEM_STATIC FORCE_INLINE_ATTR size_t BIT_getUpperBits(size_t bitContainer, U32 const start)
+{
+    return bitContainer >> start;
+}
+
+MEM_STATIC FORCE_INLINE_ATTR size_t BIT_getMiddleBits(size_t bitContainer, U32 const start, U32 const nbBits)
+{
+    U32 const regMask = sizeof(bitContainer)*8 - 1;
+    /* if start > regMask, bitstream is corrupted, and result is undefined */
+    assert(nbBits < BIT_MASK_SIZE);
+    /* x86 transform & ((1 << nbBits) - 1) to bzhi instruction, it is better
+     * than accessing memory. When bmi2 instruction is not present, we consider
+     * such cpus old (pre-Haswell, 2013) and their performance is not of that
+     * importance.
+     */
+#if defined(__x86_64__) || defined(_M_X86)
+    return (bitContainer >> (start & regMask)) & ((((U64)1) << nbBits) - 1);
+#else
+    return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];
+#endif
+}
+
+/*! BIT_lookBits() :
+ *  Provides next n bits from local register.
+ *  local register is not modified.
+ *  On 32-bits, maxNbBits==24.
+ *  On 64-bits, maxNbBits==56.
+ * @return : value extracted */
+MEM_STATIC  FORCE_INLINE_ATTR size_t BIT_lookBits(const BIT_DStream_t*  bitD, U32 nbBits)
+{
+    /* arbitrate between double-shift and shift+mask */
+#if 1
+    /* if bitD->bitsConsumed + nbBits > sizeof(bitD->bitContainer)*8,
+     * bitstream is likely corrupted, and result is undefined */
+    return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);
+#else
+    /* this code path is slower on my os-x laptop */
+    U32 const regMask = sizeof(bitD->bitContainer)*8 - 1;
+    return ((bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> 1) >> ((regMask-nbBits) & regMask);
+#endif
+}
+
+/*! BIT_lookBitsFast() :
+ *  unsafe version; only works if nbBits >= 1 */
+MEM_STATIC size_t BIT_lookBitsFast(const BIT_DStream_t* bitD, U32 nbBits)
+{
+    U32 const regMask = sizeof(bitD->bitContainer)*8 - 1;
+    assert(nbBits >= 1);
+    return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);
+}
+
+MEM_STATIC FORCE_INLINE_ATTR void BIT_skipBits(BIT_DStream_t* bitD, U32 nbBits)
+{
+    bitD->bitsConsumed += nbBits;
+}
+
+/*! BIT_readBits() :
+ *  Read (consume) next n bits from local register and update.
+ *  Pay attention to not read more than nbBits contained into local register.
+ * @return : extracted value. */
+MEM_STATIC FORCE_INLINE_ATTR size_t BIT_readBits(BIT_DStream_t* bitD, unsigned nbBits)
+{
+    size_t const value = BIT_lookBits(bitD, nbBits);
+    BIT_skipBits(bitD, nbBits);
+    return value;
+}
+
+/*! BIT_readBitsFast() :
+ *  unsafe version; only works if nbBits >= 1 */
+MEM_STATIC size_t BIT_readBitsFast(BIT_DStream_t* bitD, unsigned nbBits)
+{
+    size_t const value = BIT_lookBitsFast(bitD, nbBits);
+    assert(nbBits >= 1);
+    BIT_skipBits(bitD, nbBits);
+    return value;
+}
+
+/*! BIT_reloadDStreamFast() :
+ *  Similar to BIT_reloadDStream(), but with two differences:
+ *  1. bitsConsumed <= sizeof(bitD->bitContainer)*8 must hold!
+ *  2. Returns BIT_DStream_overflow when bitD->ptr < bitD->limitPtr, at this
+ *     point you must use BIT_reloadDStream() to reload.
+ */
+MEM_STATIC BIT_DStream_status BIT_reloadDStreamFast(BIT_DStream_t* bitD)
+{
+    if (UNLIKELY(bitD->ptr < bitD->limitPtr))
+        return BIT_DStream_overflow;
+    assert(bitD->bitsConsumed <= sizeof(bitD->bitContainer)*8);
+    bitD->ptr -= bitD->bitsConsumed >> 3;
+    bitD->bitsConsumed &= 7;
+    bitD->bitContainer = MEM_readLEST(bitD->ptr);
+    return BIT_DStream_unfinished;
+}
+
+/*! BIT_reloadDStream() :
+ *  Refill `bitD` from buffer previously set in BIT_initDStream() .
+ *  This function is safe, it guarantees it will not read beyond src buffer.
+ * @return : status of `BIT_DStream_t` internal register.
+ *           when status == BIT_DStream_unfinished, internal register is filled with at least 25 or 57 bits */
+MEM_STATIC FORCE_INLINE_ATTR BIT_DStream_status BIT_reloadDStream(BIT_DStream_t* bitD)
+{
+    if (bitD->bitsConsumed > (sizeof(bitD->bitContainer)*8))  /* overflow detected, like end of stream */
+        return BIT_DStream_overflow;
+
+    if (bitD->ptr >= bitD->limitPtr) {
+        return BIT_reloadDStreamFast(bitD);
+    }
+    if (bitD->ptr == bitD->start) {
+        if (bitD->bitsConsumed < sizeof(bitD->bitContainer)*8) return BIT_DStream_endOfBuffer;
+        return BIT_DStream_completed;
+    }
+    /* start < ptr < limitPtr */
+    {   U32 nbBytes = bitD->bitsConsumed >> 3;
+        BIT_DStream_status result = BIT_DStream_unfinished;
+        if (bitD->ptr - nbBytes < bitD->start) {
+            nbBytes = (U32)(bitD->ptr - bitD->start);  /* ptr > start */
+            result = BIT_DStream_endOfBuffer;
+        }
+        bitD->ptr -= nbBytes;
+        bitD->bitsConsumed -= nbBytes*8;
+        bitD->bitContainer = MEM_readLEST(bitD->ptr);   /* reminder : srcSize > sizeof(bitD->bitContainer), otherwise bitD->ptr == bitD->start */
+        return result;
+    }
+}
+
+/*! BIT_endOfDStream() :
+ * @return : 1 if DStream has _exactly_ reached its end (all bits consumed).
+ */
+MEM_STATIC unsigned BIT_endOfDStream(const BIT_DStream_t* DStream)
+{
+    return ((DStream->ptr == DStream->start) && (DStream->bitsConsumed == sizeof(DStream->bitContainer)*8));
+}
+
+#if defined (__cplusplus)
+}
+#endif
+
+#endif /* BITSTREAM_H_MODULE */
diff --git a/src/3rdparty/zstd/src/common/compiler.h b/src/3rdparty/zstd/src/common/compiler.h
new file mode 100644
index 0000000000..73f8d01998
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/compiler.h
@@ -0,0 +1,358 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_COMPILER_H
+#define ZSTD_COMPILER_H
+
+#include "portability_macros.h"
+
+/*-*******************************************************
+*  Compiler specifics
+*********************************************************/
+/* force inlining */
+
+#if !defined(ZSTD_NO_INLINE)
+#if (defined(__GNUC__) && !defined(__STRICT_ANSI__)) || defined(__cplusplus) || defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
+#  define INLINE_KEYWORD inline
+#else
+#  define INLINE_KEYWORD
+#endif
+
+#if defined(__GNUC__) || defined(__ICCARM__)
+#  define FORCE_INLINE_ATTR __attribute__((always_inline))
+#elif defined(_MSC_VER)
+#  define FORCE_INLINE_ATTR __forceinline
+#else
+#  define FORCE_INLINE_ATTR
+#endif
+
+#else
+
+#define INLINE_KEYWORD
+#define FORCE_INLINE_ATTR
+
+#endif
+
+/**
+  On MSVC qsort requires that functions passed into it use the __cdecl calling conversion(CC).
+  This explicitly marks such functions as __cdecl so that the code will still compile
+  if a CC other than __cdecl has been made the default.
+*/
+#if  defined(_MSC_VER)
+#  define WIN_CDECL __cdecl
+#else
+#  define WIN_CDECL
+#endif
+
+/**
+ * FORCE_INLINE_TEMPLATE is used to define C "templates", which take constant
+ * parameters. They must be inlined for the compiler to eliminate the constant
+ * branches.
+ */
+#define FORCE_INLINE_TEMPLATE static INLINE_KEYWORD FORCE_INLINE_ATTR
+/**
+ * HINT_INLINE is used to help the compiler generate better code. It is *not*
+ * used for "templates", so it can be tweaked based on the compilers
+ * performance.
+ *
+ * gcc-4.8 and gcc-4.9 have been shown to benefit from leaving off the
+ * always_inline attribute.
+ *
+ * clang up to 5.0.0 (trunk) benefit tremendously from the always_inline
+ * attribute.
+ */
+#if !defined(__clang__) && defined(__GNUC__) && __GNUC__ >= 4 && __GNUC_MINOR__ >= 8 && __GNUC__ < 5
+#  define HINT_INLINE static INLINE_KEYWORD
+#else
+#  define HINT_INLINE static INLINE_KEYWORD FORCE_INLINE_ATTR
+#endif
+
+/* UNUSED_ATTR tells the compiler it is okay if the function is unused. */
+#if defined(__GNUC__)
+#  define UNUSED_ATTR __attribute__((unused))
+#else
+#  define UNUSED_ATTR
+#endif
+
+/* force no inlining */
+#ifdef _MSC_VER
+#  define FORCE_NOINLINE static __declspec(noinline)
+#else
+#  if defined(__GNUC__) || defined(__ICCARM__)
+#    define FORCE_NOINLINE static __attribute__((__noinline__))
+#  else
+#    define FORCE_NOINLINE static
+#  endif
+#endif
+
+
+/* target attribute */
+#if defined(__GNUC__) || defined(__ICCARM__)
+#  define TARGET_ATTRIBUTE(target) __attribute__((__target__(target)))
+#else
+#  define TARGET_ATTRIBUTE(target)
+#endif
+
+/* Target attribute for BMI2 dynamic dispatch.
+ * Enable lzcnt, bmi, and bmi2.
+ * We test for bmi1 & bmi2. lzcnt is included in bmi1.
+ */
+#define BMI2_TARGET_ATTRIBUTE TARGET_ATTRIBUTE("lzcnt,bmi,bmi2")
+
+/* prefetch
+ * can be disabled, by declaring NO_PREFETCH build macro */
+#if defined(NO_PREFETCH)
+#  define PREFETCH_L1(ptr)  (void)(ptr)  /* disabled */
+#  define PREFETCH_L2(ptr)  (void)(ptr)  /* disabled */
+#else
+#  if defined(_MSC_VER) && (defined(_M_X64) || defined(_M_I86))  /* _mm_prefetch() is not defined outside of x86/x64 */
+#    include <mmintrin.h>   /* https://msdn.microsoft.com/fr-fr/library/84szxsww(v=vs.90).aspx */
+#    define PREFETCH_L1(ptr)  _mm_prefetch((const char*)(ptr), _MM_HINT_T0)
+#    define PREFETCH_L2(ptr)  _mm_prefetch((const char*)(ptr), _MM_HINT_T1)
+#  elif defined(__GNUC__) && ( (__GNUC__ >= 4) || ( (__GNUC__ == 3) && (__GNUC_MINOR__ >= 1) ) )
+#    define PREFETCH_L1(ptr)  __builtin_prefetch((ptr), 0 /* rw==read */, 3 /* locality */)
+#    define PREFETCH_L2(ptr)  __builtin_prefetch((ptr), 0 /* rw==read */, 2 /* locality */)
+#  elif defined(__aarch64__)
+#    define PREFETCH_L1(ptr)  __asm__ __volatile__("prfm pldl1keep, %0" ::"Q"(*(ptr)))
+#    define PREFETCH_L2(ptr)  __asm__ __volatile__("prfm pldl2keep, %0" ::"Q"(*(ptr)))
+#  else
+#    define PREFETCH_L1(ptr) (void)(ptr)  /* disabled */
+#    define PREFETCH_L2(ptr) (void)(ptr)  /* disabled */
+#  endif
+#endif  /* NO_PREFETCH */
+
+#define CACHELINE_SIZE 64
+
+#define PREFETCH_AREA(p, s)  {            \
+    const char* const _ptr = (const char*)(p);  \
+    size_t const _size = (size_t)(s);     \
+    size_t _pos;                          \
+    for (_pos=0; _pos<_size; _pos+=CACHELINE_SIZE) {  \
+        PREFETCH_L2(_ptr + _pos);         \
+    }                                     \
+}
+
+/* vectorization
+ * older GCC (pre gcc-4.3 picked as the cutoff) uses a different syntax,
+ * and some compilers, like Intel ICC and MCST LCC, do not support it at all. */
+#if !defined(__INTEL_COMPILER) && !defined(__clang__) && defined(__GNUC__) && !defined(__LCC__)
+#  if (__GNUC__ == 4 && __GNUC_MINOR__ > 3) || (__GNUC__ >= 5)
+#    define DONT_VECTORIZE __attribute__((optimize("no-tree-vectorize")))
+#  else
+#    define DONT_VECTORIZE _Pragma("GCC optimize(\"no-tree-vectorize\")")
+#  endif
+#else
+#  define DONT_VECTORIZE
+#endif
+
+/* Tell the compiler that a branch is likely or unlikely.
+ * Only use these macros if it causes the compiler to generate better code.
+ * If you can remove a LIKELY/UNLIKELY annotation without speed changes in gcc
+ * and clang, please do.
+ */
+#if defined(__GNUC__)
+#define LIKELY(x) (__builtin_expect((x), 1))
+#define UNLIKELY(x) (__builtin_expect((x), 0))
+#else
+#define LIKELY(x) (x)
+#define UNLIKELY(x) (x)
+#endif
+
+#if __has_builtin(__builtin_unreachable) || (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)))
+#  define ZSTD_UNREACHABLE { assert(0), __builtin_unreachable(); }
+#else
+#  define ZSTD_UNREACHABLE { assert(0); }
+#endif
+
+/* disable warnings */
+#ifdef _MSC_VER    /* Visual Studio */
+#  include <intrin.h>                    /* For Visual 2005 */
+#  pragma warning(disable : 4100)        /* disable: C4100: unreferenced formal parameter */
+#  pragma warning(disable : 4127)        /* disable: C4127: conditional expression is constant */
+#  pragma warning(disable : 4204)        /* disable: C4204: non-constant aggregate initializer */
+#  pragma warning(disable : 4214)        /* disable: C4214: non-int bitfields */
+#  pragma warning(disable : 4324)        /* disable: C4324: padded structure */
+#endif
+
+/*Like DYNAMIC_BMI2 but for compile time determination of BMI2 support*/
+#ifndef STATIC_BMI2
+#  if defined(_MSC_VER) && (defined(_M_X64) || defined(_M_I86))
+#    ifdef __AVX2__  //MSVC does not have a BMI2 specific flag, but every CPU that supports AVX2 also supports BMI2
+#       define STATIC_BMI2 1
+#    endif
+#  elif defined(__BMI2__) && defined(__x86_64__) && defined(__GNUC__)
+#    define STATIC_BMI2 1
+#  endif
+#endif
+
+#ifndef STATIC_BMI2
+    #define STATIC_BMI2 0
+#endif
+
+/* compile time determination of SIMD support */
+#if !defined(ZSTD_NO_INTRINSICS)
+#  if defined(__SSE2__) || defined(_M_AMD64) || (defined (_M_IX86) && defined(_M_IX86_FP) && (_M_IX86_FP >= 2))
+#    define ZSTD_ARCH_X86_SSE2
+#  endif
+#  if defined(__ARM_NEON) || defined(_M_ARM64)
+#    define ZSTD_ARCH_ARM_NEON
+#  endif
+#
+#  if defined(ZSTD_ARCH_X86_SSE2)
+#    include <emmintrin.h>
+#  elif defined(ZSTD_ARCH_ARM_NEON)
+#    include <arm_neon.h>
+#  endif
+#endif
+
+/* C-language Attributes are added in C23. */
+#if defined(__STDC_VERSION__) && (__STDC_VERSION__ > 201710L) && defined(__has_c_attribute)
+# define ZSTD_HAS_C_ATTRIBUTE(x) __has_c_attribute(x)
+#else
+# define ZSTD_HAS_C_ATTRIBUTE(x) 0
+#endif
+
+/* Only use C++ attributes in C++. Some compilers report support for C++
+ * attributes when compiling with C.
+ */
+#if defined(__cplusplus) && defined(__has_cpp_attribute)
+# define ZSTD_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)
+#else
+# define ZSTD_HAS_CPP_ATTRIBUTE(x) 0
+#endif
+
+/* Define ZSTD_FALLTHROUGH macro for annotating switch case with the 'fallthrough' attribute.
+ * - C23: https://en.cppreference.com/w/c/language/attributes/fallthrough
+ * - CPP17: https://en.cppreference.com/w/cpp/language/attributes/fallthrough
+ * - Else: __attribute__((__fallthrough__))
+ */
+#ifndef ZSTD_FALLTHROUGH
+# if ZSTD_HAS_C_ATTRIBUTE(fallthrough)
+#  define ZSTD_FALLTHROUGH [[fallthrough]]
+# elif ZSTD_HAS_CPP_ATTRIBUTE(fallthrough)
+#  define ZSTD_FALLTHROUGH [[fallthrough]]
+# elif __has_attribute(__fallthrough__)
+/* Leading semicolon is to satisfy gcc-11 with -pedantic. Without the semicolon
+ * gcc complains about: a label can only be part of a statement and a declaration is not a statement.
+ */
+#  define ZSTD_FALLTHROUGH ; __attribute__((__fallthrough__))
+# else
+#  define ZSTD_FALLTHROUGH
+# endif
+#endif
+
+/*-**************************************************************
+*  Alignment check
+*****************************************************************/
+
+/* this test was initially positioned in mem.h,
+ * but this file is removed (or replaced) for linux kernel
+ * so it's now hosted in compiler.h,
+ * which remains valid for both user & kernel spaces.
+ */
+
+#ifndef ZSTD_ALIGNOF
+# if defined(__GNUC__) || defined(_MSC_VER)
+/* covers gcc, clang & MSVC */
+/* note : this section must come first, before C11,
+ * due to a limitation in the kernel source generator */
+#  define ZSTD_ALIGNOF(T) __alignof(T)
+
+# elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)
+/* C11 support */
+#  include <stdalign.h>
+#  define ZSTD_ALIGNOF(T) alignof(T)
+
+# else
+/* No known support for alignof() - imperfect backup */
+#  define ZSTD_ALIGNOF(T) (sizeof(void*) < sizeof(T) ? sizeof(void*) : sizeof(T))
+
+# endif
+#endif /* ZSTD_ALIGNOF */
+
+/*-**************************************************************
+*  Sanitizer
+*****************************************************************/
+
+/* Issue #3240 reports an ASAN failure on an llvm-mingw build. Out of an
+ * abundance of caution, disable our custom poisoning on mingw. */
+#ifdef __MINGW32__
+#ifndef ZSTD_ASAN_DONT_POISON_WORKSPACE
+#define ZSTD_ASAN_DONT_POISON_WORKSPACE 1
+#endif
+#ifndef ZSTD_MSAN_DONT_POISON_WORKSPACE
+#define ZSTD_MSAN_DONT_POISON_WORKSPACE 1
+#endif
+#endif
+
+#if ZSTD_MEMORY_SANITIZER && !defined(ZSTD_MSAN_DONT_POISON_WORKSPACE)
+/* Not all platforms that support msan provide sanitizers/msan_interface.h.
+ * We therefore declare the functions we need ourselves, rather than trying to
+ * include the header file... */
+#include <stddef.h>  /* size_t */
+#define ZSTD_DEPS_NEED_STDINT
+#include "zstd_deps.h"  /* intptr_t */
+
+/* Make memory region fully initialized (without changing its contents). */
+void __msan_unpoison(const volatile void *a, size_t size);
+
+/* Make memory region fully uninitialized (without changing its contents).
+   This is a legacy interface that does not update origin information. Use
+   __msan_allocated_memory() instead. */
+void __msan_poison(const volatile void *a, size_t size);
+
+/* Returns the offset of the first (at least partially) poisoned byte in the
+   memory range, or -1 if the whole range is good. */
+intptr_t __msan_test_shadow(const volatile void *x, size_t size);
+
+/* Print shadow and origin for the memory range to stderr in a human-readable
+   format. */
+void __msan_print_shadow(const volatile void *x, size_t size);
+#endif
+
+#if ZSTD_ADDRESS_SANITIZER && !defined(ZSTD_ASAN_DONT_POISON_WORKSPACE)
+/* Not all platforms that support asan provide sanitizers/asan_interface.h.
+ * We therefore declare the functions we need ourselves, rather than trying to
+ * include the header file... */
+#include <stddef.h>  /* size_t */
+
+/**
+ * Marks a memory region (<c>[addr, addr+size)</c>) as unaddressable.
+ *
+ * This memory must be previously allocated by your program. Instrumented
+ * code is forbidden from accessing addresses in this region until it is
+ * unpoisoned. This function is not guaranteed to poison the entire region -
+ * it could poison only a subregion of <c>[addr, addr+size)</c> due to ASan
+ * alignment restrictions.
+ *
+ * \note This function is not thread-safe because no two threads can poison or
+ * unpoison memory in the same memory region simultaneously.
+ *
+ * \param addr Start of memory region.
+ * \param size Size of memory region. */
+void __asan_poison_memory_region(void const volatile *addr, size_t size);
+
+/**
+ * Marks a memory region (<c>[addr, addr+size)</c>) as addressable.
+ *
+ * This memory must be previously allocated by your program. Accessing
+ * addresses in this region is allowed until this region is poisoned again.
+ * This function could unpoison a super-region of <c>[addr, addr+size)</c> due
+ * to ASan alignment restrictions.
+ *
+ * \note This function is not thread-safe because no two threads can
+ * poison or unpoison memory in the same memory region simultaneously.
+ *
+ * \param addr Start of memory region.
+ * \param size Size of memory region. */
+void __asan_unpoison_memory_region(void const volatile *addr, size_t size);
+#endif
+
+#endif /* ZSTD_COMPILER_H */
diff --git a/src/3rdparty/zstd/src/common/cpu.h b/src/3rdparty/zstd/src/common/cpu.h
new file mode 100644
index 0000000000..8bc34a36da
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/cpu.h
@@ -0,0 +1,213 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_COMMON_CPU_H
+#define ZSTD_COMMON_CPU_H
+
+/**
+ * Implementation taken from folly/CpuId.h
+ * https://github.com/facebook/folly/blob/master/folly/CpuId.h
+ */
+
+#include "mem.h"
+
+#ifdef _MSC_VER
+#include <intrin.h>
+#endif
+
+typedef struct {
+    U32 f1c;
+    U32 f1d;
+    U32 f7b;
+    U32 f7c;
+} ZSTD_cpuid_t;
+
+MEM_STATIC ZSTD_cpuid_t ZSTD_cpuid(void) {
+    U32 f1c = 0;
+    U32 f1d = 0;
+    U32 f7b = 0;
+    U32 f7c = 0;
+#if defined(_MSC_VER) && (defined(_M_X64) || defined(_M_IX86))
+    int reg[4];
+    __cpuid((int*)reg, 0);
+    {
+        int const n = reg[0];
+        if (n >= 1) {
+            __cpuid((int*)reg, 1);
+            f1c = (U32)reg[2];
+            f1d = (U32)reg[3];
+        }
+        if (n >= 7) {
+            __cpuidex((int*)reg, 7, 0);
+            f7b = (U32)reg[1];
+            f7c = (U32)reg[2];
+        }
+    }
+#elif defined(__i386__) && defined(__PIC__) && !defined(__clang__) && defined(__GNUC__)
+    /* The following block like the normal cpuid branch below, but gcc
+     * reserves ebx for use of its pic register so we must specially
+     * handle the save and restore to avoid clobbering the register
+     */
+    U32 n;
+    __asm__(
+        "pushl %%ebx\n\t"
+        "cpuid\n\t"
+        "popl %%ebx\n\t"
+        : "=a"(n)
+        : "a"(0)
+        : "ecx", "edx");
+    if (n >= 1) {
+      U32 f1a;
+      __asm__(
+          "pushl %%ebx\n\t"
+          "cpuid\n\t"
+          "popl %%ebx\n\t"
+          : "=a"(f1a), "=c"(f1c), "=d"(f1d)
+          : "a"(1));
+    }
+    if (n >= 7) {
+      __asm__(
+          "pushl %%ebx\n\t"
+          "cpuid\n\t"
+          "movl %%ebx, %%eax\n\t"
+          "popl %%ebx"
+          : "=a"(f7b), "=c"(f7c)
+          : "a"(7), "c"(0)
+          : "edx");
+    }
+#elif defined(__x86_64__) || defined(_M_X64) || defined(__i386__)
+    U32 n;
+    __asm__("cpuid" : "=a"(n) : "a"(0) : "ebx", "ecx", "edx");
+    if (n >= 1) {
+      U32 f1a;
+      __asm__("cpuid" : "=a"(f1a), "=c"(f1c), "=d"(f1d) : "a"(1) : "ebx");
+    }
+    if (n >= 7) {
+      U32 f7a;
+      __asm__("cpuid"
+              : "=a"(f7a), "=b"(f7b), "=c"(f7c)
+              : "a"(7), "c"(0)
+              : "edx");
+    }
+#endif
+    {
+        ZSTD_cpuid_t cpuid;
+        cpuid.f1c = f1c;
+        cpuid.f1d = f1d;
+        cpuid.f7b = f7b;
+        cpuid.f7c = f7c;
+        return cpuid;
+    }
+}
+
+#define X(name, r, bit)                                                        \
+  MEM_STATIC int ZSTD_cpuid_##name(ZSTD_cpuid_t const cpuid) {                 \
+    return ((cpuid.r) & (1U << bit)) != 0;                                     \
+  }
+
+/* cpuid(1): Processor Info and Feature Bits. */
+#define C(name, bit) X(name, f1c, bit)
+  C(sse3, 0)
+  C(pclmuldq, 1)
+  C(dtes64, 2)
+  C(monitor, 3)
+  C(dscpl, 4)
+  C(vmx, 5)
+  C(smx, 6)
+  C(eist, 7)
+  C(tm2, 8)
+  C(ssse3, 9)
+  C(cnxtid, 10)
+  C(fma, 12)
+  C(cx16, 13)
+  C(xtpr, 14)
+  C(pdcm, 15)
+  C(pcid, 17)
+  C(dca, 18)
+  C(sse41, 19)
+  C(sse42, 20)
+  C(x2apic, 21)
+  C(movbe, 22)
+  C(popcnt, 23)
+  C(tscdeadline, 24)
+  C(aes, 25)
+  C(xsave, 26)
+  C(osxsave, 27)
+  C(avx, 28)
+  C(f16c, 29)
+  C(rdrand, 30)
+#undef C
+#define D(name, bit) X(name, f1d, bit)
+  D(fpu, 0)
+  D(vme, 1)
+  D(de, 2)
+  D(pse, 3)
+  D(tsc, 4)
+  D(msr, 5)
+  D(pae, 6)
+  D(mce, 7)
+  D(cx8, 8)
+  D(apic, 9)
+  D(sep, 11)
+  D(mtrr, 12)
+  D(pge, 13)
+  D(mca, 14)
+  D(cmov, 15)
+  D(pat, 16)
+  D(pse36, 17)
+  D(psn, 18)
+  D(clfsh, 19)
+  D(ds, 21)
+  D(acpi, 22)
+  D(mmx, 23)
+  D(fxsr, 24)
+  D(sse, 25)
+  D(sse2, 26)
+  D(ss, 27)
+  D(htt, 28)
+  D(tm, 29)
+  D(pbe, 31)
+#undef D
+
+/* cpuid(7): Extended Features. */
+#define B(name, bit) X(name, f7b, bit)
+  B(bmi1, 3)
+  B(hle, 4)
+  B(avx2, 5)
+  B(smep, 7)
+  B(bmi2, 8)
+  B(erms, 9)
+  B(invpcid, 10)
+  B(rtm, 11)
+  B(mpx, 14)
+  B(avx512f, 16)
+  B(avx512dq, 17)
+  B(rdseed, 18)
+  B(adx, 19)
+  B(smap, 20)
+  B(avx512ifma, 21)
+  B(pcommit, 22)
+  B(clflushopt, 23)
+  B(clwb, 24)
+  B(avx512pf, 26)
+  B(avx512er, 27)
+  B(avx512cd, 28)
+  B(sha, 29)
+  B(avx512bw, 30)
+  B(avx512vl, 31)
+#undef B
+#define C(name, bit) X(name, f7c, bit)
+  C(prefetchwt1, 0)
+  C(avx512vbmi, 1)
+#undef C
+
+#undef X
+
+#endif /* ZSTD_COMMON_CPU_H */
diff --git a/src/3rdparty/zstd/src/common/debug.c b/src/3rdparty/zstd/src/common/debug.c
new file mode 100644
index 0000000000..ebf7bfccfa
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/debug.c
@@ -0,0 +1,24 @@
+/* ******************************************************************
+ * debug
+ * Part of FSE library
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * You can contact the author at :
+ * - Source repository : https://github.com/Cyan4973/FiniteStateEntropy
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+****************************************************************** */
+
+
+/*
+ * This module only hosts one global variable
+ * which can be used to dynamically influence the verbosity of traces,
+ * such as DEBUGLOG and RAWLOG
+ */
+
+#include "debug.h"
+
+int g_debuglevel = DEBUGLEVEL;
diff --git a/src/3rdparty/zstd/src/common/debug.h b/src/3rdparty/zstd/src/common/debug.h
new file mode 100644
index 0000000000..0e9817ea6d
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/debug.h
@@ -0,0 +1,107 @@
+/* ******************************************************************
+ * debug
+ * Part of FSE library
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * You can contact the author at :
+ * - Source repository : https://github.com/Cyan4973/FiniteStateEntropy
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+****************************************************************** */
+
+
+/*
+ * The purpose of this header is to enable debug functions.
+ * They regroup assert(), DEBUGLOG() and RAWLOG() for run-time,
+ * and DEBUG_STATIC_ASSERT() for compile-time.
+ *
+ * By default, DEBUGLEVEL==0, which means run-time debug is disabled.
+ *
+ * Level 1 enables assert() only.
+ * Starting level 2, traces can be generated and pushed to stderr.
+ * The higher the level, the more verbose the traces.
+ *
+ * It's possible to dynamically adjust level using variable g_debug_level,
+ * which is only declared if DEBUGLEVEL>=2,
+ * and is a global variable, not multi-thread protected (use with care)
+ */
+
+#ifndef DEBUG_H_12987983217
+#define DEBUG_H_12987983217
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+
+/* static assert is triggered at compile time, leaving no runtime artefact.
+ * static assert only works with compile-time constants.
+ * Also, this variant can only be used inside a function. */
+#define DEBUG_STATIC_ASSERT(c) (void)sizeof(char[(c) ? 1 : -1])
+
+
+/* DEBUGLEVEL is expected to be defined externally,
+ * typically through compiler command line.
+ * Value must be a number. */
+#ifndef DEBUGLEVEL
+#  define DEBUGLEVEL 0
+#endif
+
+
+/* recommended values for DEBUGLEVEL :
+ * 0 : release mode, no debug, all run-time checks disabled
+ * 1 : enables assert() only, no display
+ * 2 : reserved, for currently active debug path
+ * 3 : events once per object lifetime (CCtx, CDict, etc.)
+ * 4 : events once per frame
+ * 5 : events once per block
+ * 6 : events once per sequence (verbose)
+ * 7+: events at every position (*very* verbose)
+ *
+ * It's generally inconvenient to output traces > 5.
+ * In which case, it's possible to selectively trigger high verbosity levels
+ * by modifying g_debug_level.
+ */
+
+#if (DEBUGLEVEL>=1)
+#  define ZSTD_DEPS_NEED_ASSERT
+#  include "zstd_deps.h"
+#else
+#  ifndef assert   /* assert may be already defined, due to prior #include <assert.h> */
+#    define assert(condition) ((void)0)   /* disable assert (default) */
+#  endif
+#endif
+
+#if (DEBUGLEVEL>=2)
+#  define ZSTD_DEPS_NEED_IO
+#  include "zstd_deps.h"
+extern int g_debuglevel; /* the variable is only declared,
+                            it actually lives in debug.c,
+                            and is shared by the whole process.
+                            It's not thread-safe.
+                            It's useful when enabling very verbose levels
+                            on selective conditions (such as position in src) */
+
+#  define RAWLOG(l, ...) {                                       \
+                if (l<=g_debuglevel) {                           \
+                    ZSTD_DEBUG_PRINT(__VA_ARGS__);               \
+            }   }
+#  define DEBUGLOG(l, ...) {                                     \
+                if (l<=g_debuglevel) {                           \
+                    ZSTD_DEBUG_PRINT(__FILE__ ": " __VA_ARGS__); \
+                    ZSTD_DEBUG_PRINT(" \n");                     \
+            }   }
+#else
+#  define RAWLOG(l, ...)      {}    /* disabled */
+#  define DEBUGLOG(l, ...)    {}    /* disabled */
+#endif
+
+
+#if defined (__cplusplus)
+}
+#endif
+
+#endif /* DEBUG_H_12987983217 */
diff --git a/src/3rdparty/zstd/src/common/entropy_common.c b/src/3rdparty/zstd/src/common/entropy_common.c
new file mode 100644
index 0000000000..e2173afb0a
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/entropy_common.c
@@ -0,0 +1,340 @@
+/* ******************************************************************
+ * Common functions of New Generation Entropy library
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ *  You can contact the author at :
+ *  - FSE+HUF source repository : https://github.com/Cyan4973/FiniteStateEntropy
+ *  - Public forum : https://groups.google.com/forum/#!forum/lz4c
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+****************************************************************** */
+
+/* *************************************
+*  Dependencies
+***************************************/
+#include "mem.h"
+#include "error_private.h"       /* ERR_*, ERROR */
+#define FSE_STATIC_LINKING_ONLY  /* FSE_MIN_TABLELOG */
+#include "fse.h"
+#include "huf.h"
+#include "bits.h"                /* ZSDT_highbit32, ZSTD_countTrailingZeros32 */
+
+
+/*===   Version   ===*/
+unsigned FSE_versionNumber(void) { return FSE_VERSION_NUMBER; }
+
+
+/*===   Error Management   ===*/
+unsigned FSE_isError(size_t code) { return ERR_isError(code); }
+const char* FSE_getErrorName(size_t code) { return ERR_getErrorName(code); }
+
+unsigned HUF_isError(size_t code) { return ERR_isError(code); }
+const char* HUF_getErrorName(size_t code) { return ERR_getErrorName(code); }
+
+
+/*-**************************************************************
+*  FSE NCount encoding-decoding
+****************************************************************/
+FORCE_INLINE_TEMPLATE
+size_t FSE_readNCount_body(short* normalizedCounter, unsigned* maxSVPtr, unsigned* tableLogPtr,
+                           const void* headerBuffer, size_t hbSize)
+{
+    const BYTE* const istart = (const BYTE*) headerBuffer;
+    const BYTE* const iend = istart + hbSize;
+    const BYTE* ip = istart;
+    int nbBits;
+    int remaining;
+    int threshold;
+    U32 bitStream;
+    int bitCount;
+    unsigned charnum = 0;
+    unsigned const maxSV1 = *maxSVPtr + 1;
+    int previous0 = 0;
+
+    if (hbSize < 8) {
+        /* This function only works when hbSize >= 8 */
+        char buffer[8] = {0};
+        ZSTD_memcpy(buffer, headerBuffer, hbSize);
+        {   size_t const countSize = FSE_readNCount(normalizedCounter, maxSVPtr, tableLogPtr,
+                                                    buffer, sizeof(buffer));
+            if (FSE_isError(countSize)) return countSize;
+            if (countSize > hbSize) return ERROR(corruption_detected);
+            return countSize;
+    }   }
+    assert(hbSize >= 8);
+
+    /* init */
+    ZSTD_memset(normalizedCounter, 0, (*maxSVPtr+1) * sizeof(normalizedCounter[0]));   /* all symbols not present in NCount have a frequency of 0 */
+    bitStream = MEM_readLE32(ip);
+    nbBits = (bitStream & 0xF) + FSE_MIN_TABLELOG;   /* extract tableLog */
+    if (nbBits > FSE_TABLELOG_ABSOLUTE_MAX) return ERROR(tableLog_tooLarge);
+    bitStream >>= 4;
+    bitCount = 4;
+    *tableLogPtr = nbBits;
+    remaining = (1<<nbBits)+1;
+    threshold = 1<<nbBits;
+    nbBits++;
+
+    for (;;) {
+        if (previous0) {
+            /* Count the number of repeats. Each time the
+             * 2-bit repeat code is 0b11 there is another
+             * repeat.
+             * Avoid UB by setting the high bit to 1.
+             */
+            int repeats = ZSTD_countTrailingZeros32(~bitStream | 0x80000000) >> 1;
+            while (repeats >= 12) {
+                charnum += 3 * 12;
+                if (LIKELY(ip <= iend-7)) {
+                    ip += 3;
+                } else {
+                    bitCount -= (int)(8 * (iend - 7 - ip));
+                    bitCount &= 31;
+                    ip = iend - 4;
+                }
+                bitStream = MEM_readLE32(ip) >> bitCount;
+                repeats = ZSTD_countTrailingZeros32(~bitStream | 0x80000000) >> 1;
+            }
+            charnum += 3 * repeats;
+            bitStream >>= 2 * repeats;
+            bitCount += 2 * repeats;
+
+            /* Add the final repeat which isn't 0b11. */
+            assert((bitStream & 3) < 3);
+            charnum += bitStream & 3;
+            bitCount += 2;
+
+            /* This is an error, but break and return an error
+             * at the end, because returning out of a loop makes
+             * it harder for the compiler to optimize.
+             */
+            if (charnum >= maxSV1) break;
+
+            /* We don't need to set the normalized count to 0
+             * because we already memset the whole buffer to 0.
+             */
+
+            if (LIKELY(ip <= iend-7) || (ip + (bitCount>>3) <= iend-4)) {
+                assert((bitCount >> 3) <= 3); /* For first condition to work */
+                ip += bitCount>>3;
+                bitCount &= 7;
+            } else {
+                bitCount -= (int)(8 * (iend - 4 - ip));
+                bitCount &= 31;
+                ip = iend - 4;
+            }
+            bitStream = MEM_readLE32(ip) >> bitCount;
+        }
+        {
+            int const max = (2*threshold-1) - remaining;
+            int count;
+
+            if ((bitStream & (threshold-1)) < (U32)max) {
+                count = bitStream & (threshold-1);
+                bitCount += nbBits-1;
+            } else {
+                count = bitStream & (2*threshold-1);
+                if (count >= threshold) count -= max;
+                bitCount += nbBits;
+            }
+
+            count--;   /* extra accuracy */
+            /* When it matters (small blocks), this is a
+             * predictable branch, because we don't use -1.
+             */
+            if (count >= 0) {
+                remaining -= count;
+            } else {
+                assert(count == -1);
+                remaining += count;
+            }
+            normalizedCounter[charnum++] = (short)count;
+            previous0 = !count;
+
+            assert(threshold > 1);
+            if (remaining < threshold) {
+                /* This branch can be folded into the
+                 * threshold update condition because we
+                 * know that threshold > 1.
+                 */
+                if (remaining <= 1) break;
+                nbBits = ZSTD_highbit32(remaining) + 1;
+                threshold = 1 << (nbBits - 1);
+            }
+            if (charnum >= maxSV1) break;
+
+            if (LIKELY(ip <= iend-7) || (ip + (bitCount>>3) <= iend-4)) {
+                ip += bitCount>>3;
+                bitCount &= 7;
+            } else {
+                bitCount -= (int)(8 * (iend - 4 - ip));
+                bitCount &= 31;
+                ip = iend - 4;
+            }
+            bitStream = MEM_readLE32(ip) >> bitCount;
+    }   }
+    if (remaining != 1) return ERROR(corruption_detected);
+    /* Only possible when there are too many zeros. */
+    if (charnum > maxSV1) return ERROR(maxSymbolValue_tooSmall);
+    if (bitCount > 32) return ERROR(corruption_detected);
+    *maxSVPtr = charnum-1;
+
+    ip += (bitCount+7)>>3;
+    return ip-istart;
+}
+
+/* Avoids the FORCE_INLINE of the _body() function. */
+static size_t FSE_readNCount_body_default(
+        short* normalizedCounter, unsigned* maxSVPtr, unsigned* tableLogPtr,
+        const void* headerBuffer, size_t hbSize)
+{
+    return FSE_readNCount_body(normalizedCounter, maxSVPtr, tableLogPtr, headerBuffer, hbSize);
+}
+
+#if DYNAMIC_BMI2
+BMI2_TARGET_ATTRIBUTE static size_t FSE_readNCount_body_bmi2(
+        short* normalizedCounter, unsigned* maxSVPtr, unsigned* tableLogPtr,
+        const void* headerBuffer, size_t hbSize)
+{
+    return FSE_readNCount_body(normalizedCounter, maxSVPtr, tableLogPtr, headerBuffer, hbSize);
+}
+#endif
+
+size_t FSE_readNCount_bmi2(
+        short* normalizedCounter, unsigned* maxSVPtr, unsigned* tableLogPtr,
+        const void* headerBuffer, size_t hbSize, int bmi2)
+{
+#if DYNAMIC_BMI2
+    if (bmi2) {
+        return FSE_readNCount_body_bmi2(normalizedCounter, maxSVPtr, tableLogPtr, headerBuffer, hbSize);
+    }
+#endif
+    (void)bmi2;
+    return FSE_readNCount_body_default(normalizedCounter, maxSVPtr, tableLogPtr, headerBuffer, hbSize);
+}
+
+size_t FSE_readNCount(
+        short* normalizedCounter, unsigned* maxSVPtr, unsigned* tableLogPtr,
+        const void* headerBuffer, size_t hbSize)
+{
+    return FSE_readNCount_bmi2(normalizedCounter, maxSVPtr, tableLogPtr, headerBuffer, hbSize, /* bmi2 */ 0);
+}
+
+
+/*! HUF_readStats() :
+    Read compact Huffman tree, saved by HUF_writeCTable().
+    `huffWeight` is destination buffer.
+    `rankStats` is assumed to be a table of at least HUF_TABLELOG_MAX U32.
+    @return : size read from `src` , or an error Code .
+    Note : Needed by HUF_readCTable() and HUF_readDTableX?() .
+*/
+size_t HUF_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,
+                     U32* nbSymbolsPtr, U32* tableLogPtr,
+                     const void* src, size_t srcSize)
+{
+    U32 wksp[HUF_READ_STATS_WORKSPACE_SIZE_U32];
+    return HUF_readStats_wksp(huffWeight, hwSize, rankStats, nbSymbolsPtr, tableLogPtr, src, srcSize, wksp, sizeof(wksp), /* flags */ 0);
+}
+
+FORCE_INLINE_TEMPLATE size_t
+HUF_readStats_body(BYTE* huffWeight, size_t hwSize, U32* rankStats,
+                   U32* nbSymbolsPtr, U32* tableLogPtr,
+                   const void* src, size_t srcSize,
+                   void* workSpace, size_t wkspSize,
+                   int bmi2)
+{
+    U32 weightTotal;
+    const BYTE* ip = (const BYTE*) src;
+    size_t iSize;
+    size_t oSize;
+
+    if (!srcSize) return ERROR(srcSize_wrong);
+    iSize = ip[0];
+    /* ZSTD_memset(huffWeight, 0, hwSize);   *//* is not necessary, even though some analyzer complain ... */
+
+    if (iSize >= 128) {  /* special header */
+        oSize = iSize - 127;
+        iSize = ((oSize+1)/2);
+        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
+        if (oSize >= hwSize) return ERROR(corruption_detected);
+        ip += 1;
+        {   U32 n;
+            for (n=0; n<oSize; n+=2) {
+                huffWeight[n]   = ip[n/2] >> 4;
+                huffWeight[n+1] = ip[n/2] & 15;
+    }   }   }
+    else  {   /* header compressed with FSE (normal case) */
+        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);
+        /* max (hwSize-1) values decoded, as last one is implied */
+        oSize = FSE_decompress_wksp_bmi2(huffWeight, hwSize-1, ip+1, iSize, 6, workSpace, wkspSize, bmi2);
+        if (FSE_isError(oSize)) return oSize;
+    }
+
+    /* collect weight stats */
+    ZSTD_memset(rankStats, 0, (HUF_TABLELOG_MAX + 1) * sizeof(U32));
+    weightTotal = 0;
+    {   U32 n; for (n=0; n<oSize; n++) {
+            if (huffWeight[n] > HUF_TABLELOG_MAX) return ERROR(corruption_detected);
+            rankStats[huffWeight[n]]++;
+            weightTotal += (1 << huffWeight[n]) >> 1;
+    }   }
+    if (weightTotal == 0) return ERROR(corruption_detected);
+
+    /* get last non-null symbol weight (implied, total must be 2^n) */
+    {   U32 const tableLog = ZSTD_highbit32(weightTotal) + 1;
+        if (tableLog > HUF_TABLELOG_MAX) return ERROR(corruption_detected);
+        *tableLogPtr = tableLog;
+        /* determine last weight */
+        {   U32 const total = 1 << tableLog;
+            U32 const rest = total - weightTotal;
+            U32 const verif = 1 << ZSTD_highbit32(rest);
+            U32 const lastWeight = ZSTD_highbit32(rest) + 1;
+            if (verif != rest) return ERROR(corruption_detected);    /* last value must be a clean power of 2 */
+            huffWeight[oSize] = (BYTE)lastWeight;
+            rankStats[lastWeight]++;
+    }   }
+
+    /* check tree construction validity */
+    if ((rankStats[1] < 2) || (rankStats[1] & 1)) return ERROR(corruption_detected);   /* by construction : at least 2 elts of rank 1, must be even */
+
+    /* results */
+    *nbSymbolsPtr = (U32)(oSize+1);
+    return iSize+1;
+}
+
+/* Avoids the FORCE_INLINE of the _body() function. */
+static size_t HUF_readStats_body_default(BYTE* huffWeight, size_t hwSize, U32* rankStats,
+                     U32* nbSymbolsPtr, U32* tableLogPtr,
+                     const void* src, size_t srcSize,
+                     void* workSpace, size_t wkspSize)
+{
+    return HUF_readStats_body(huffWeight, hwSize, rankStats, nbSymbolsPtr, tableLogPtr, src, srcSize, workSpace, wkspSize, 0);
+}
+
+#if DYNAMIC_BMI2
+static BMI2_TARGET_ATTRIBUTE size_t HUF_readStats_body_bmi2(BYTE* huffWeight, size_t hwSize, U32* rankStats,
+                     U32* nbSymbolsPtr, U32* tableLogPtr,
+                     const void* src, size_t srcSize,
+                     void* workSpace, size_t wkspSize)
+{
+    return HUF_readStats_body(huffWeight, hwSize, rankStats, nbSymbolsPtr, tableLogPtr, src, srcSize, workSpace, wkspSize, 1);
+}
+#endif
+
+size_t HUF_readStats_wksp(BYTE* huffWeight, size_t hwSize, U32* rankStats,
+                     U32* nbSymbolsPtr, U32* tableLogPtr,
+                     const void* src, size_t srcSize,
+                     void* workSpace, size_t wkspSize,
+                     int flags)
+{
+#if DYNAMIC_BMI2
+    if (flags & HUF_flags_bmi2) {
+        return HUF_readStats_body_bmi2(huffWeight, hwSize, rankStats, nbSymbolsPtr, tableLogPtr, src, srcSize, workSpace, wkspSize);
+    }
+#endif
+    (void)flags;
+    return HUF_readStats_body_default(huffWeight, hwSize, rankStats, nbSymbolsPtr, tableLogPtr, src, srcSize, workSpace, wkspSize);
+}
diff --git a/src/3rdparty/zstd/src/common/error_private.c b/src/3rdparty/zstd/src/common/error_private.c
new file mode 100644
index 0000000000..075fc5ef42
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/error_private.c
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+/* The purpose of this file is to have a single list of error strings embedded in binary */
+
+#include "error_private.h"
+
+const char* ERR_getErrorString(ERR_enum code)
+{
+#ifdef ZSTD_STRIP_ERROR_STRINGS
+    (void)code;
+    return "Error strings stripped";
+#else
+    static const char* const notErrorCode = "Unspecified error code";
+    switch( code )
+    {
+    case PREFIX(no_error): return "No error detected";
+    case PREFIX(GENERIC):  return "Error (generic)";
+    case PREFIX(prefix_unknown): return "Unknown frame descriptor";
+    case PREFIX(version_unsupported): return "Version not supported";
+    case PREFIX(frameParameter_unsupported): return "Unsupported frame parameter";
+    case PREFIX(frameParameter_windowTooLarge): return "Frame requires too much memory for decoding";
+    case PREFIX(corruption_detected): return "Data corruption detected";
+    case PREFIX(checksum_wrong): return "Restored data doesn't match checksum";
+    case PREFIX(literals_headerWrong): return "Header of Literals' block doesn't respect format specification";
+    case PREFIX(parameter_unsupported): return "Unsupported parameter";
+    case PREFIX(parameter_combination_unsupported): return "Unsupported combination of parameters";
+    case PREFIX(parameter_outOfBound): return "Parameter is out of bound";
+    case PREFIX(init_missing): return "Context should be init first";
+    case PREFIX(memory_allocation): return "Allocation error : not enough memory";
+    case PREFIX(workSpace_tooSmall): return "workSpace buffer is not large enough";
+    case PREFIX(stage_wrong): return "Operation not authorized at current processing stage";
+    case PREFIX(tableLog_tooLarge): return "tableLog requires too much memory : unsupported";
+    case PREFIX(maxSymbolValue_tooLarge): return "Unsupported max Symbol Value : too large";
+    case PREFIX(maxSymbolValue_tooSmall): return "Specified maxSymbolValue is too small";
+    case PREFIX(stabilityCondition_notRespected): return "pledged buffer stability condition is not respected";
+    case PREFIX(dictionary_corrupted): return "Dictionary is corrupted";
+    case PREFIX(dictionary_wrong): return "Dictionary mismatch";
+    case PREFIX(dictionaryCreation_failed): return "Cannot create Dictionary from provided samples";
+    case PREFIX(dstSize_tooSmall): return "Destination buffer is too small";
+    case PREFIX(srcSize_wrong): return "Src size is incorrect";
+    case PREFIX(dstBuffer_null): return "Operation on NULL destination buffer";
+    case PREFIX(noForwardProgress_destFull): return "Operation made no progress over multiple calls, due to output buffer being full";
+    case PREFIX(noForwardProgress_inputEmpty): return "Operation made no progress over multiple calls, due to input being empty";
+        /* following error codes are not stable and may be removed or changed in a future version */
+    case PREFIX(frameIndex_tooLarge): return "Frame index is too large";
+    case PREFIX(seekableIO): return "An I/O error occurred when reading/seeking";
+    case PREFIX(dstBuffer_wrong): return "Destination buffer is wrong";
+    case PREFIX(srcBuffer_wrong): return "Source buffer is wrong";
+    case PREFIX(sequenceProducer_failed): return "Block-level external sequence producer returned an error code";
+    case PREFIX(externalSequences_invalid): return "External sequences are not valid";
+    case PREFIX(maxCode):
+    default: return notErrorCode;
+    }
+#endif
+}
diff --git a/src/3rdparty/zstd/src/common/error_private.h b/src/3rdparty/zstd/src/common/error_private.h
new file mode 100644
index 0000000000..325daad404
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/error_private.h
@@ -0,0 +1,159 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+/* Note : this module is expected to remain private, do not expose it */
+
+#ifndef ERROR_H_MODULE
+#define ERROR_H_MODULE
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+
+/* ****************************************
+*  Dependencies
+******************************************/
+#include "../zstd_errors.h"  /* enum list */
+#include "compiler.h"
+#include "debug.h"
+#include "zstd_deps.h"       /* size_t */
+
+
+/* ****************************************
+*  Compiler-specific
+******************************************/
+#if defined(__GNUC__)
+#  define ERR_STATIC static __attribute__((unused))
+#elif defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */)
+#  define ERR_STATIC static inline
+#elif defined(_MSC_VER)
+#  define ERR_STATIC static __inline
+#else
+#  define ERR_STATIC static  /* this version may generate warnings for unused static functions; disable the relevant warning */
+#endif
+
+
+/*-****************************************
+*  Customization (error_public.h)
+******************************************/
+typedef ZSTD_ErrorCode ERR_enum;
+#define PREFIX(name) ZSTD_error_##name
+
+
+/*-****************************************
+*  Error codes handling
+******************************************/
+#undef ERROR   /* already defined on Visual Studio */
+#define ERROR(name) ZSTD_ERROR(name)
+#define ZSTD_ERROR(name) ((size_t)-PREFIX(name))
+
+ERR_STATIC unsigned ERR_isError(size_t code) { return (code > ERROR(maxCode)); }
+
+ERR_STATIC ERR_enum ERR_getErrorCode(size_t code) { if (!ERR_isError(code)) return (ERR_enum)0; return (ERR_enum) (0-code); }
+
+/* check and forward error code */
+#define CHECK_V_F(e, f) size_t const e = f; if (ERR_isError(e)) return e
+#define CHECK_F(f)   { CHECK_V_F(_var_err__, f); }
+
+
+/*-****************************************
+*  Error Strings
+******************************************/
+
+const char* ERR_getErrorString(ERR_enum code);   /* error_private.c */
+
+ERR_STATIC const char* ERR_getErrorName(size_t code)
+{
+    return ERR_getErrorString(ERR_getErrorCode(code));
+}
+
+/**
+ * Ignore: this is an internal helper.
+ *
+ * This is a helper function to help force C99-correctness during compilation.
+ * Under strict compilation modes, variadic macro arguments can't be empty.
+ * However, variadic function arguments can be. Using a function therefore lets
+ * us statically check that at least one (string) argument was passed,
+ * independent of the compilation flags.
+ */
+static INLINE_KEYWORD UNUSED_ATTR
+void _force_has_format_string(const char *format, ...) {
+  (void)format;
+}
+
+/**
+ * Ignore: this is an internal helper.
+ *
+ * We want to force this function invocation to be syntactically correct, but
+ * we don't want to force runtime evaluation of its arguments.
+ */
+#define _FORCE_HAS_FORMAT_STRING(...) \
+  if (0) { \
+    _force_has_format_string(__VA_ARGS__); \
+  }
+
+#define ERR_QUOTE(str) #str
+
+/**
+ * Return the specified error if the condition evaluates to true.
+ *
+ * In debug modes, prints additional information.
+ * In order to do that (particularly, printing the conditional that failed),
+ * this can't just wrap RETURN_ERROR().
+ */
+#define RETURN_ERROR_IF(cond, err, ...) \
+  if (cond) { \
+    RAWLOG(3, "%s:%d: ERROR!: check %s failed, returning %s", \
+           __FILE__, __LINE__, ERR_QUOTE(cond), ERR_QUOTE(ERROR(err))); \
+    _FORCE_HAS_FORMAT_STRING(__VA_ARGS__); \
+    RAWLOG(3, ": " __VA_ARGS__); \
+    RAWLOG(3, "\n"); \
+    return ERROR(err); \
+  }
+
+/**
+ * Unconditionally return the specified error.
+ *
+ * In debug modes, prints additional information.
+ */
+#define RETURN_ERROR(err, ...) \
+  do { \
+    RAWLOG(3, "%s:%d: ERROR!: unconditional check failed, returning %s", \
+           __FILE__, __LINE__, ERR_QUOTE(ERROR(err))); \
+    _FORCE_HAS_FORMAT_STRING(__VA_ARGS__); \
+    RAWLOG(3, ": " __VA_ARGS__); \
+    RAWLOG(3, "\n"); \
+    return ERROR(err); \
+  } while(0);
+
+/**
+ * If the provided expression evaluates to an error code, returns that error code.
+ *
+ * In debug modes, prints additional information.
+ */
+#define FORWARD_IF_ERROR(err, ...) \
+  do { \
+    size_t const err_code = (err); \
+    if (ERR_isError(err_code)) { \
+      RAWLOG(3, "%s:%d: ERROR!: forwarding error in %s: %s", \
+             __FILE__, __LINE__, ERR_QUOTE(err), ERR_getErrorName(err_code)); \
+      _FORCE_HAS_FORMAT_STRING(__VA_ARGS__); \
+      RAWLOG(3, ": " __VA_ARGS__); \
+      RAWLOG(3, "\n"); \
+      return err_code; \
+    } \
+  } while(0);
+
+#if defined (__cplusplus)
+}
+#endif
+
+#endif /* ERROR_H_MODULE */
diff --git a/src/3rdparty/zstd/src/common/fse.h b/src/3rdparty/zstd/src/common/fse.h
new file mode 100644
index 0000000000..02a1f0bc53
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/fse.h
@@ -0,0 +1,639 @@
+/* ******************************************************************
+ * FSE : Finite State Entropy codec
+ * Public Prototypes declaration
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * You can contact the author at :
+ * - Source repository : https://github.com/Cyan4973/FiniteStateEntropy
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+****************************************************************** */
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#ifndef FSE_H
+#define FSE_H
+
+
+/*-*****************************************
+*  Dependencies
+******************************************/
+#include "zstd_deps.h"    /* size_t, ptrdiff_t */
+
+
+/*-*****************************************
+*  FSE_PUBLIC_API : control library symbols visibility
+******************************************/
+#if defined(FSE_DLL_EXPORT) && (FSE_DLL_EXPORT==1) && defined(__GNUC__) && (__GNUC__ >= 4)
+#  define FSE_PUBLIC_API __attribute__ ((visibility ("default")))
+#elif defined(FSE_DLL_EXPORT) && (FSE_DLL_EXPORT==1)   /* Visual expected */
+#  define FSE_PUBLIC_API __declspec(dllexport)
+#elif defined(FSE_DLL_IMPORT) && (FSE_DLL_IMPORT==1)
+#  define FSE_PUBLIC_API __declspec(dllimport) /* It isn't required but allows to generate better code, saving a function pointer load from the IAT and an indirect jump.*/
+#else
+#  define FSE_PUBLIC_API
+#endif
+
+/*------   Version   ------*/
+#define FSE_VERSION_MAJOR    0
+#define FSE_VERSION_MINOR    9
+#define FSE_VERSION_RELEASE  0
+
+#define FSE_LIB_VERSION FSE_VERSION_MAJOR.FSE_VERSION_MINOR.FSE_VERSION_RELEASE
+#define FSE_QUOTE(str) #str
+#define FSE_EXPAND_AND_QUOTE(str) FSE_QUOTE(str)
+#define FSE_VERSION_STRING FSE_EXPAND_AND_QUOTE(FSE_LIB_VERSION)
+
+#define FSE_VERSION_NUMBER  (FSE_VERSION_MAJOR *100*100 + FSE_VERSION_MINOR *100 + FSE_VERSION_RELEASE)
+FSE_PUBLIC_API unsigned FSE_versionNumber(void);   /**< library version number; to be used when checking dll version */
+
+
+/*-*****************************************
+*  Tool functions
+******************************************/
+FSE_PUBLIC_API size_t FSE_compressBound(size_t size);       /* maximum compressed size */
+
+/* Error Management */
+FSE_PUBLIC_API unsigned    FSE_isError(size_t code);        /* tells if a return value is an error code */
+FSE_PUBLIC_API const char* FSE_getErrorName(size_t code);   /* provides error code string (useful for debugging) */
+
+
+/*-*****************************************
+*  FSE detailed API
+******************************************/
+/*!
+FSE_compress() does the following:
+1. count symbol occurrence from source[] into table count[] (see hist.h)
+2. normalize counters so that sum(count[]) == Power_of_2 (2^tableLog)
+3. save normalized counters to memory buffer using writeNCount()
+4. build encoding table 'CTable' from normalized counters
+5. encode the data stream using encoding table 'CTable'
+
+FSE_decompress() does the following:
+1. read normalized counters with readNCount()
+2. build decoding table 'DTable' from normalized counters
+3. decode the data stream using decoding table 'DTable'
+
+The following API allows targeting specific sub-functions for advanced tasks.
+For example, it's possible to compress several blocks using the same 'CTable',
+or to save and provide normalized distribution using external method.
+*/
+
+/* *** COMPRESSION *** */
+
+/*! FSE_optimalTableLog():
+    dynamically downsize 'tableLog' when conditions are met.
+    It saves CPU time, by using smaller tables, while preserving or even improving compression ratio.
+    @return : recommended tableLog (necessarily <= 'maxTableLog') */
+FSE_PUBLIC_API unsigned FSE_optimalTableLog(unsigned maxTableLog, size_t srcSize, unsigned maxSymbolValue);
+
+/*! FSE_normalizeCount():
+    normalize counts so that sum(count[]) == Power_of_2 (2^tableLog)
+    'normalizedCounter' is a table of short, of minimum size (maxSymbolValue+1).
+    useLowProbCount is a boolean parameter which trades off compressed size for
+    faster header decoding. When it is set to 1, the compressed data will be slightly
+    smaller. And when it is set to 0, FSE_readNCount() and FSE_buildDTable() will be
+    faster. If you are compressing a small amount of data (< 2 KB) then useLowProbCount=0
+    is a good default, since header deserialization makes a big speed difference.
+    Otherwise, useLowProbCount=1 is a good default, since the speed difference is small.
+    @return : tableLog,
+              or an errorCode, which can be tested using FSE_isError() */
+FSE_PUBLIC_API size_t FSE_normalizeCount(short* normalizedCounter, unsigned tableLog,
+                    const unsigned* count, size_t srcSize, unsigned maxSymbolValue, unsigned useLowProbCount);
+
+/*! FSE_NCountWriteBound():
+    Provides the maximum possible size of an FSE normalized table, given 'maxSymbolValue' and 'tableLog'.
+    Typically useful for allocation purpose. */
+FSE_PUBLIC_API size_t FSE_NCountWriteBound(unsigned maxSymbolValue, unsigned tableLog);
+
+/*! FSE_writeNCount():
+    Compactly save 'normalizedCounter' into 'buffer'.
+    @return : size of the compressed table,
+              or an errorCode, which can be tested using FSE_isError(). */
+FSE_PUBLIC_API size_t FSE_writeNCount (void* buffer, size_t bufferSize,
+                                 const short* normalizedCounter,
+                                 unsigned maxSymbolValue, unsigned tableLog);
+
+/*! Constructor and Destructor of FSE_CTable.
+    Note that FSE_CTable size depends on 'tableLog' and 'maxSymbolValue' */
+typedef unsigned FSE_CTable;   /* don't allocate that. It's only meant to be more restrictive than void* */
+
+/*! FSE_buildCTable():
+    Builds `ct`, which must be already allocated, using FSE_createCTable().
+    @return : 0, or an errorCode, which can be tested using FSE_isError() */
+FSE_PUBLIC_API size_t FSE_buildCTable(FSE_CTable* ct, const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog);
+
+/*! FSE_compress_usingCTable():
+    Compress `src` using `ct` into `dst` which must be already allocated.
+    @return : size of compressed data (<= `dstCapacity`),
+              or 0 if compressed data could not fit into `dst`,
+              or an errorCode, which can be tested using FSE_isError() */
+FSE_PUBLIC_API size_t FSE_compress_usingCTable (void* dst, size_t dstCapacity, const void* src, size_t srcSize, const FSE_CTable* ct);
+
+/*!
+Tutorial :
+----------
+The first step is to count all symbols. FSE_count() does this job very fast.
+Result will be saved into 'count', a table of unsigned int, which must be already allocated, and have 'maxSymbolValuePtr[0]+1' cells.
+'src' is a table of bytes of size 'srcSize'. All values within 'src' MUST be <= maxSymbolValuePtr[0]
+maxSymbolValuePtr[0] will be updated, with its real value (necessarily <= original value)
+FSE_count() will return the number of occurrence of the most frequent symbol.
+This can be used to know if there is a single symbol within 'src', and to quickly evaluate its compressibility.
+If there is an error, the function will return an ErrorCode (which can be tested using FSE_isError()).
+
+The next step is to normalize the frequencies.
+FSE_normalizeCount() will ensure that sum of frequencies is == 2 ^'tableLog'.
+It also guarantees a minimum of 1 to any Symbol with frequency >= 1.
+You can use 'tableLog'==0 to mean "use default tableLog value".
+If you are unsure of which tableLog value to use, you can ask FSE_optimalTableLog(),
+which will provide the optimal valid tableLog given sourceSize, maxSymbolValue, and a user-defined maximum (0 means "default").
+
+The result of FSE_normalizeCount() will be saved into a table,
+called 'normalizedCounter', which is a table of signed short.
+'normalizedCounter' must be already allocated, and have at least 'maxSymbolValue+1' cells.
+The return value is tableLog if everything proceeded as expected.
+It is 0 if there is a single symbol within distribution.
+If there is an error (ex: invalid tableLog value), the function will return an ErrorCode (which can be tested using FSE_isError()).
+
+'normalizedCounter' can be saved in a compact manner to a memory area using FSE_writeNCount().
+'buffer' must be already allocated.
+For guaranteed success, buffer size must be at least FSE_headerBound().
+The result of the function is the number of bytes written into 'buffer'.
+If there is an error, the function will return an ErrorCode (which can be tested using FSE_isError(); ex : buffer size too small).
+
+'normalizedCounter' can then be used to create the compression table 'CTable'.
+The space required by 'CTable' must be already allocated, using FSE_createCTable().
+You can then use FSE_buildCTable() to fill 'CTable'.
+If there is an error, both functions will return an ErrorCode (which can be tested using FSE_isError()).
+
+'CTable' can then be used to compress 'src', with FSE_compress_usingCTable().
+Similar to FSE_count(), the convention is that 'src' is assumed to be a table of char of size 'srcSize'
+The function returns the size of compressed data (without header), necessarily <= `dstCapacity`.
+If it returns '0', compressed data could not fit into 'dst'.
+If there is an error, the function will return an ErrorCode (which can be tested using FSE_isError()).
+*/
+
+
+/* *** DECOMPRESSION *** */
+
+/*! FSE_readNCount():
+    Read compactly saved 'normalizedCounter' from 'rBuffer'.
+    @return : size read from 'rBuffer',
+              or an errorCode, which can be tested using FSE_isError().
+              maxSymbolValuePtr[0] and tableLogPtr[0] will also be updated with their respective values */
+FSE_PUBLIC_API size_t FSE_readNCount (short* normalizedCounter,
+                           unsigned* maxSymbolValuePtr, unsigned* tableLogPtr,
+                           const void* rBuffer, size_t rBuffSize);
+
+/*! FSE_readNCount_bmi2():
+ * Same as FSE_readNCount() but pass bmi2=1 when your CPU supports BMI2 and 0 otherwise.
+ */
+FSE_PUBLIC_API size_t FSE_readNCount_bmi2(short* normalizedCounter,
+                           unsigned* maxSymbolValuePtr, unsigned* tableLogPtr,
+                           const void* rBuffer, size_t rBuffSize, int bmi2);
+
+typedef unsigned FSE_DTable;   /* don't allocate that. It's just a way to be more restrictive than void* */
+
+/*!
+Tutorial :
+----------
+(Note : these functions only decompress FSE-compressed blocks.
+ If block is uncompressed, use memcpy() instead
+ If block is a single repeated byte, use memset() instead )
+
+The first step is to obtain the normalized frequencies of symbols.
+This can be performed by FSE_readNCount() if it was saved using FSE_writeNCount().
+'normalizedCounter' must be already allocated, and have at least 'maxSymbolValuePtr[0]+1' cells of signed short.
+In practice, that means it's necessary to know 'maxSymbolValue' beforehand,
+or size the table to handle worst case situations (typically 256).
+FSE_readNCount() will provide 'tableLog' and 'maxSymbolValue'.
+The result of FSE_readNCount() is the number of bytes read from 'rBuffer'.
+Note that 'rBufferSize' must be at least 4 bytes, even if useful information is less than that.
+If there is an error, the function will return an error code, which can be tested using FSE_isError().
+
+The next step is to build the decompression tables 'FSE_DTable' from 'normalizedCounter'.
+This is performed by the function FSE_buildDTable().
+The space required by 'FSE_DTable' must be already allocated using FSE_createDTable().
+If there is an error, the function will return an error code, which can be tested using FSE_isError().
+
+`FSE_DTable` can then be used to decompress `cSrc`, with FSE_decompress_usingDTable().
+`cSrcSize` must be strictly correct, otherwise decompression will fail.
+FSE_decompress_usingDTable() result will tell how many bytes were regenerated (<=`dstCapacity`).
+If there is an error, the function will return an error code, which can be tested using FSE_isError(). (ex: dst buffer too small)
+*/
+
+#endif  /* FSE_H */
+
+#if defined(FSE_STATIC_LINKING_ONLY) && !defined(FSE_H_FSE_STATIC_LINKING_ONLY)
+#define FSE_H_FSE_STATIC_LINKING_ONLY
+
+/* *** Dependency *** */
+#include "bitstream.h"
+
+
+/* *****************************************
+*  Static allocation
+*******************************************/
+/* FSE buffer bounds */
+#define FSE_NCOUNTBOUND 512
+#define FSE_BLOCKBOUND(size) ((size) + ((size)>>7) + 4 /* fse states */ + sizeof(size_t) /* bitContainer */)
+#define FSE_COMPRESSBOUND(size) (FSE_NCOUNTBOUND + FSE_BLOCKBOUND(size))   /* Macro version, useful for static allocation */
+
+/* It is possible to statically allocate FSE CTable/DTable as a table of FSE_CTable/FSE_DTable using below macros */
+#define FSE_CTABLE_SIZE_U32(maxTableLog, maxSymbolValue)   (1 + (1<<((maxTableLog)-1)) + (((maxSymbolValue)+1)*2))
+#define FSE_DTABLE_SIZE_U32(maxTableLog)                   (1 + (1<<(maxTableLog)))
+
+/* or use the size to malloc() space directly. Pay attention to alignment restrictions though */
+#define FSE_CTABLE_SIZE(maxTableLog, maxSymbolValue)   (FSE_CTABLE_SIZE_U32(maxTableLog, maxSymbolValue) * sizeof(FSE_CTable))
+#define FSE_DTABLE_SIZE(maxTableLog)                   (FSE_DTABLE_SIZE_U32(maxTableLog) * sizeof(FSE_DTable))
+
+
+/* *****************************************
+ *  FSE advanced API
+ ***************************************** */
+
+unsigned FSE_optimalTableLog_internal(unsigned maxTableLog, size_t srcSize, unsigned maxSymbolValue, unsigned minus);
+/**< same as FSE_optimalTableLog(), which used `minus==2` */
+
+size_t FSE_buildCTable_rle (FSE_CTable* ct, unsigned char symbolValue);
+/**< build a fake FSE_CTable, designed to compress always the same symbolValue */
+
+/* FSE_buildCTable_wksp() :
+ * Same as FSE_buildCTable(), but using an externally allocated scratch buffer (`workSpace`).
+ * `wkspSize` must be >= `FSE_BUILD_CTABLE_WORKSPACE_SIZE_U32(maxSymbolValue, tableLog)` of `unsigned`.
+ * See FSE_buildCTable_wksp() for breakdown of workspace usage.
+ */
+#define FSE_BUILD_CTABLE_WORKSPACE_SIZE_U32(maxSymbolValue, tableLog) (((maxSymbolValue + 2) + (1ull << (tableLog)))/2 + sizeof(U64)/sizeof(U32) /* additional 8 bytes for potential table overwrite */)
+#define FSE_BUILD_CTABLE_WORKSPACE_SIZE(maxSymbolValue, tableLog) (sizeof(unsigned) * FSE_BUILD_CTABLE_WORKSPACE_SIZE_U32(maxSymbolValue, tableLog))
+size_t FSE_buildCTable_wksp(FSE_CTable* ct, const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog, void* workSpace, size_t wkspSize);
+
+#define FSE_BUILD_DTABLE_WKSP_SIZE(maxTableLog, maxSymbolValue) (sizeof(short) * (maxSymbolValue + 1) + (1ULL << maxTableLog) + 8)
+#define FSE_BUILD_DTABLE_WKSP_SIZE_U32(maxTableLog, maxSymbolValue) ((FSE_BUILD_DTABLE_WKSP_SIZE(maxTableLog, maxSymbolValue) + sizeof(unsigned) - 1) / sizeof(unsigned))
+FSE_PUBLIC_API size_t FSE_buildDTable_wksp(FSE_DTable* dt, const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog, void* workSpace, size_t wkspSize);
+/**< Same as FSE_buildDTable(), using an externally allocated `workspace` produced with `FSE_BUILD_DTABLE_WKSP_SIZE_U32(maxSymbolValue)` */
+
+#define FSE_DECOMPRESS_WKSP_SIZE_U32(maxTableLog, maxSymbolValue) (FSE_DTABLE_SIZE_U32(maxTableLog) + 1 + FSE_BUILD_DTABLE_WKSP_SIZE_U32(maxTableLog, maxSymbolValue) + (FSE_MAX_SYMBOL_VALUE + 1) / 2 + 1)
+#define FSE_DECOMPRESS_WKSP_SIZE(maxTableLog, maxSymbolValue) (FSE_DECOMPRESS_WKSP_SIZE_U32(maxTableLog, maxSymbolValue) * sizeof(unsigned))
+size_t FSE_decompress_wksp_bmi2(void* dst, size_t dstCapacity, const void* cSrc, size_t cSrcSize, unsigned maxLog, void* workSpace, size_t wkspSize, int bmi2);
+/**< same as FSE_decompress(), using an externally allocated `workSpace` produced with `FSE_DECOMPRESS_WKSP_SIZE_U32(maxLog, maxSymbolValue)`.
+ * Set bmi2 to 1 if your CPU supports BMI2 or 0 if it doesn't */
+
+typedef enum {
+   FSE_repeat_none,  /**< Cannot use the previous table */
+   FSE_repeat_check, /**< Can use the previous table but it must be checked */
+   FSE_repeat_valid  /**< Can use the previous table and it is assumed to be valid */
+ } FSE_repeat;
+
+/* *****************************************
+*  FSE symbol compression API
+*******************************************/
+/*!
+   This API consists of small unitary functions, which highly benefit from being inlined.
+   Hence their body are included in next section.
+*/
+typedef struct {
+    ptrdiff_t   value;
+    const void* stateTable;
+    const void* symbolTT;
+    unsigned    stateLog;
+} FSE_CState_t;
+
+static void FSE_initCState(FSE_CState_t* CStatePtr, const FSE_CTable* ct);
+
+static void FSE_encodeSymbol(BIT_CStream_t* bitC, FSE_CState_t* CStatePtr, unsigned symbol);
+
+static void FSE_flushCState(BIT_CStream_t* bitC, const FSE_CState_t* CStatePtr);
+
+/**<
+These functions are inner components of FSE_compress_usingCTable().
+They allow the creation of custom streams, mixing multiple tables and bit sources.
+
+A key property to keep in mind is that encoding and decoding are done **in reverse direction**.
+So the first symbol you will encode is the last you will decode, like a LIFO stack.
+
+You will need a few variables to track your CStream. They are :
+
+FSE_CTable    ct;         // Provided by FSE_buildCTable()
+BIT_CStream_t bitStream;  // bitStream tracking structure
+FSE_CState_t  state;      // State tracking structure (can have several)
+
+
+The first thing to do is to init bitStream and state.
+    size_t errorCode = BIT_initCStream(&bitStream, dstBuffer, maxDstSize);
+    FSE_initCState(&state, ct);
+
+Note that BIT_initCStream() can produce an error code, so its result should be tested, using FSE_isError();
+You can then encode your input data, byte after byte.
+FSE_encodeSymbol() outputs a maximum of 'tableLog' bits at a time.
+Remember decoding will be done in reverse direction.
+    FSE_encodeByte(&bitStream, &state, symbol);
+
+At any time, you can also add any bit sequence.
+Note : maximum allowed nbBits is 25, for compatibility with 32-bits decoders
+    BIT_addBits(&bitStream, bitField, nbBits);
+
+The above methods don't commit data to memory, they just store it into local register, for speed.
+Local register size is 64-bits on 64-bits systems, 32-bits on 32-bits systems (size_t).
+Writing data to memory is a manual operation, performed by the flushBits function.
+    BIT_flushBits(&bitStream);
+
+Your last FSE encoding operation shall be to flush your last state value(s).
+    FSE_flushState(&bitStream, &state);
+
+Finally, you must close the bitStream.
+The function returns the size of CStream in bytes.
+If data couldn't fit into dstBuffer, it will return a 0 ( == not compressible)
+If there is an error, it returns an errorCode (which can be tested using FSE_isError()).
+    size_t size = BIT_closeCStream(&bitStream);
+*/
+
+
+/* *****************************************
+*  FSE symbol decompression API
+*******************************************/
+typedef struct {
+    size_t      state;
+    const void* table;   /* precise table may vary, depending on U16 */
+} FSE_DState_t;
+
+
+static void     FSE_initDState(FSE_DState_t* DStatePtr, BIT_DStream_t* bitD, const FSE_DTable* dt);
+
+static unsigned char FSE_decodeSymbol(FSE_DState_t* DStatePtr, BIT_DStream_t* bitD);
+
+static unsigned FSE_endOfDState(const FSE_DState_t* DStatePtr);
+
+/**<
+Let's now decompose FSE_decompress_usingDTable() into its unitary components.
+You will decode FSE-encoded symbols from the bitStream,
+and also any other bitFields you put in, **in reverse order**.
+
+You will need a few variables to track your bitStream. They are :
+
+BIT_DStream_t DStream;    // Stream context
+FSE_DState_t  DState;     // State context. Multiple ones are possible
+FSE_DTable*   DTablePtr;  // Decoding table, provided by FSE_buildDTable()
+
+The first thing to do is to init the bitStream.
+    errorCode = BIT_initDStream(&DStream, srcBuffer, srcSize);
+
+You should then retrieve your initial state(s)
+(in reverse flushing order if you have several ones) :
+    errorCode = FSE_initDState(&DState, &DStream, DTablePtr);
+
+You can then decode your data, symbol after symbol.
+For information the maximum number of bits read by FSE_decodeSymbol() is 'tableLog'.
+Keep in mind that symbols are decoded in reverse order, like a LIFO stack (last in, first out).
+    unsigned char symbol = FSE_decodeSymbol(&DState, &DStream);
+
+You can retrieve any bitfield you eventually stored into the bitStream (in reverse order)
+Note : maximum allowed nbBits is 25, for 32-bits compatibility
+    size_t bitField = BIT_readBits(&DStream, nbBits);
+
+All above operations only read from local register (which size depends on size_t).
+Refueling the register from memory is manually performed by the reload method.
+    endSignal = FSE_reloadDStream(&DStream);
+
+BIT_reloadDStream() result tells if there is still some more data to read from DStream.
+BIT_DStream_unfinished : there is still some data left into the DStream.
+BIT_DStream_endOfBuffer : Dstream reached end of buffer. Its container may no longer be completely filled.
+BIT_DStream_completed : Dstream reached its exact end, corresponding in general to decompression completed.
+BIT_DStream_tooFar : Dstream went too far. Decompression result is corrupted.
+
+When reaching end of buffer (BIT_DStream_endOfBuffer), progress slowly, notably if you decode multiple symbols per loop,
+to properly detect the exact end of stream.
+After each decoded symbol, check if DStream is fully consumed using this simple test :
+    BIT_reloadDStream(&DStream) >= BIT_DStream_completed
+
+When it's done, verify decompression is fully completed, by checking both DStream and the relevant states.
+Checking if DStream has reached its end is performed by :
+    BIT_endOfDStream(&DStream);
+Check also the states. There might be some symbols left there, if some high probability ones (>50%) are possible.
+    FSE_endOfDState(&DState);
+*/
+
+
+/* *****************************************
+*  FSE unsafe API
+*******************************************/
+static unsigned char FSE_decodeSymbolFast(FSE_DState_t* DStatePtr, BIT_DStream_t* bitD);
+/* faster, but works only if nbBits is always >= 1 (otherwise, result will be corrupted) */
+
+
+/* *****************************************
+*  Implementation of inlined functions
+*******************************************/
+typedef struct {
+    int deltaFindState;
+    U32 deltaNbBits;
+} FSE_symbolCompressionTransform; /* total 8 bytes */
+
+MEM_STATIC void FSE_initCState(FSE_CState_t* statePtr, const FSE_CTable* ct)
+{
+    const void* ptr = ct;
+    const U16* u16ptr = (const U16*) ptr;
+    const U32 tableLog = MEM_read16(ptr);
+    statePtr->value = (ptrdiff_t)1<<tableLog;
+    statePtr->stateTable = u16ptr+2;
+    statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);
+    statePtr->stateLog = tableLog;
+}
+
+
+/*! FSE_initCState2() :
+*   Same as FSE_initCState(), but the first symbol to include (which will be the last to be read)
+*   uses the smallest state value possible, saving the cost of this symbol */
+MEM_STATIC void FSE_initCState2(FSE_CState_t* statePtr, const FSE_CTable* ct, U32 symbol)
+{
+    FSE_initCState(statePtr, ct);
+    {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];
+        const U16* stateTable = (const U16*)(statePtr->stateTable);
+        U32 nbBitsOut  = (U32)((symbolTT.deltaNbBits + (1<<15)) >> 16);
+        statePtr->value = (nbBitsOut << 16) - symbolTT.deltaNbBits;
+        statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];
+    }
+}
+
+MEM_STATIC void FSE_encodeSymbol(BIT_CStream_t* bitC, FSE_CState_t* statePtr, unsigned symbol)
+{
+    FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];
+    const U16* const stateTable = (const U16*)(statePtr->stateTable);
+    U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);
+    BIT_addBits(bitC, statePtr->value, nbBitsOut);
+    statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];
+}
+
+MEM_STATIC void FSE_flushCState(BIT_CStream_t* bitC, const FSE_CState_t* statePtr)
+{
+    BIT_addBits(bitC, statePtr->value, statePtr->stateLog);
+    BIT_flushBits(bitC);
+}
+
+
+/* FSE_getMaxNbBits() :
+ * Approximate maximum cost of a symbol, in bits.
+ * Fractional get rounded up (i.e. a symbol with a normalized frequency of 3 gives the same result as a frequency of 2)
+ * note 1 : assume symbolValue is valid (<= maxSymbolValue)
+ * note 2 : if freq[symbolValue]==0, @return a fake cost of tableLog+1 bits */
+MEM_STATIC U32 FSE_getMaxNbBits(const void* symbolTTPtr, U32 symbolValue)
+{
+    const FSE_symbolCompressionTransform* symbolTT = (const FSE_symbolCompressionTransform*) symbolTTPtr;
+    return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;
+}
+
+/* FSE_bitCost() :
+ * Approximate symbol cost, as fractional value, using fixed-point format (accuracyLog fractional bits)
+ * note 1 : assume symbolValue is valid (<= maxSymbolValue)
+ * note 2 : if freq[symbolValue]==0, @return a fake cost of tableLog+1 bits */
+MEM_STATIC U32 FSE_bitCost(const void* symbolTTPtr, U32 tableLog, U32 symbolValue, U32 accuracyLog)
+{
+    const FSE_symbolCompressionTransform* symbolTT = (const FSE_symbolCompressionTransform*) symbolTTPtr;
+    U32 const minNbBits = symbolTT[symbolValue].deltaNbBits >> 16;
+    U32 const threshold = (minNbBits+1) << 16;
+    assert(tableLog < 16);
+    assert(accuracyLog < 31-tableLog);  /* ensure enough room for renormalization double shift */
+    {   U32 const tableSize = 1 << tableLog;
+        U32 const deltaFromThreshold = threshold - (symbolTT[symbolValue].deltaNbBits + tableSize);
+        U32 const normalizedDeltaFromThreshold = (deltaFromThreshold << accuracyLog) >> tableLog;   /* linear interpolation (very approximate) */
+        U32 const bitMultiplier = 1 << accuracyLog;
+        assert(symbolTT[symbolValue].deltaNbBits + tableSize <= threshold);
+        assert(normalizedDeltaFromThreshold <= bitMultiplier);
+        return (minNbBits+1)*bitMultiplier - normalizedDeltaFromThreshold;
+    }
+}
+
+
+/* ======    Decompression    ====== */
+
+typedef struct {
+    U16 tableLog;
+    U16 fastMode;
+} FSE_DTableHeader;   /* sizeof U32 */
+
+typedef struct
+{
+    unsigned short newState;
+    unsigned char  symbol;
+    unsigned char  nbBits;
+} FSE_decode_t;   /* size == U32 */
+
+MEM_STATIC void FSE_initDState(FSE_DState_t* DStatePtr, BIT_DStream_t* bitD, const FSE_DTable* dt)
+{
+    const void* ptr = dt;
+    const FSE_DTableHeader* const DTableH = (const FSE_DTableHeader*)ptr;
+    DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);
+    BIT_reloadDStream(bitD);
+    DStatePtr->table = dt + 1;
+}
+
+MEM_STATIC BYTE FSE_peekSymbol(const FSE_DState_t* DStatePtr)
+{
+    FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];
+    return DInfo.symbol;
+}
+
+MEM_STATIC void FSE_updateState(FSE_DState_t* DStatePtr, BIT_DStream_t* bitD)
+{
+    FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];
+    U32 const nbBits = DInfo.nbBits;
+    size_t const lowBits = BIT_readBits(bitD, nbBits);
+    DStatePtr->state = DInfo.newState + lowBits;
+}
+
+MEM_STATIC BYTE FSE_decodeSymbol(FSE_DState_t* DStatePtr, BIT_DStream_t* bitD)
+{
+    FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];
+    U32 const nbBits = DInfo.nbBits;
+    BYTE const symbol = DInfo.symbol;
+    size_t const lowBits = BIT_readBits(bitD, nbBits);
+
+    DStatePtr->state = DInfo.newState + lowBits;
+    return symbol;
+}
+
+/*! FSE_decodeSymbolFast() :
+    unsafe, only works if no symbol has a probability > 50% */
+MEM_STATIC BYTE FSE_decodeSymbolFast(FSE_DState_t* DStatePtr, BIT_DStream_t* bitD)
+{
+    FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];
+    U32 const nbBits = DInfo.nbBits;
+    BYTE const symbol = DInfo.symbol;
+    size_t const lowBits = BIT_readBitsFast(bitD, nbBits);
+
+    DStatePtr->state = DInfo.newState + lowBits;
+    return symbol;
+}
+
+MEM_STATIC unsigned FSE_endOfDState(const FSE_DState_t* DStatePtr)
+{
+    return DStatePtr->state == 0;
+}
+
+
+
+#ifndef FSE_COMMONDEFS_ONLY
+
+/* **************************************************************
+*  Tuning parameters
+****************************************************************/
+/*!MEMORY_USAGE :
+*  Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.)
+*  Increasing memory usage improves compression ratio
+*  Reduced memory usage can improve speed, due to cache effect
+*  Recommended max value is 14, for 16KB, which nicely fits into Intel x86 L1 cache */
+#ifndef FSE_MAX_MEMORY_USAGE
+#  define FSE_MAX_MEMORY_USAGE 14
+#endif
+#ifndef FSE_DEFAULT_MEMORY_USAGE
+#  define FSE_DEFAULT_MEMORY_USAGE 13
+#endif
+#if (FSE_DEFAULT_MEMORY_USAGE > FSE_MAX_MEMORY_USAGE)
+#  error "FSE_DEFAULT_MEMORY_USAGE must be <= FSE_MAX_MEMORY_USAGE"
+#endif
+
+/*!FSE_MAX_SYMBOL_VALUE :
+*  Maximum symbol value authorized.
+*  Required for proper stack allocation */
+#ifndef FSE_MAX_SYMBOL_VALUE
+#  define FSE_MAX_SYMBOL_VALUE 255
+#endif
+
+/* **************************************************************
+*  template functions type & suffix
+****************************************************************/
+#define FSE_FUNCTION_TYPE BYTE
+#define FSE_FUNCTION_EXTENSION
+#define FSE_DECODE_TYPE FSE_decode_t
+
+
+#endif   /* !FSE_COMMONDEFS_ONLY */
+
+
+/* ***************************************************************
+*  Constants
+*****************************************************************/
+#define FSE_MAX_TABLELOG  (FSE_MAX_MEMORY_USAGE-2)
+#define FSE_MAX_TABLESIZE (1U<<FSE_MAX_TABLELOG)
+#define FSE_MAXTABLESIZE_MASK (FSE_MAX_TABLESIZE-1)
+#define FSE_DEFAULT_TABLELOG (FSE_DEFAULT_MEMORY_USAGE-2)
+#define FSE_MIN_TABLELOG 5
+
+#define FSE_TABLELOG_ABSOLUTE_MAX 15
+#if FSE_MAX_TABLELOG > FSE_TABLELOG_ABSOLUTE_MAX
+#  error "FSE_MAX_TABLELOG > FSE_TABLELOG_ABSOLUTE_MAX is not supported"
+#endif
+
+#define FSE_TABLESTEP(tableSize) (((tableSize)>>1) + ((tableSize)>>3) + 3)
+
+
+#endif /* FSE_STATIC_LINKING_ONLY */
+
+
+#if defined (__cplusplus)
+}
+#endif
diff --git a/src/3rdparty/zstd/src/common/fse_decompress.c b/src/3rdparty/zstd/src/common/fse_decompress.c
new file mode 100644
index 0000000000..1e1c9f92d6
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/fse_decompress.c
@@ -0,0 +1,311 @@
+/* ******************************************************************
+ * FSE : Finite State Entropy decoder
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ *  You can contact the author at :
+ *  - FSE source repository : https://github.com/Cyan4973/FiniteStateEntropy
+ *  - Public forum : https://groups.google.com/forum/#!forum/lz4c
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+****************************************************************** */
+
+
+/* **************************************************************
+*  Includes
+****************************************************************/
+#include "debug.h"      /* assert */
+#include "bitstream.h"
+#include "compiler.h"
+#define FSE_STATIC_LINKING_ONLY
+#include "fse.h"
+#include "error_private.h"
+#define ZSTD_DEPS_NEED_MALLOC
+#include "zstd_deps.h"
+#include "bits.h"       /* ZSTD_highbit32 */
+
+
+/* **************************************************************
+*  Error Management
+****************************************************************/
+#define FSE_isError ERR_isError
+#define FSE_STATIC_ASSERT(c) DEBUG_STATIC_ASSERT(c)   /* use only *after* variable declarations */
+
+
+/* **************************************************************
+*  Templates
+****************************************************************/
+/*
+  designed to be included
+  for type-specific functions (template emulation in C)
+  Objective is to write these functions only once, for improved maintenance
+*/
+
+/* safety checks */
+#ifndef FSE_FUNCTION_EXTENSION
+#  error "FSE_FUNCTION_EXTENSION must be defined"
+#endif
+#ifndef FSE_FUNCTION_TYPE
+#  error "FSE_FUNCTION_TYPE must be defined"
+#endif
+
+/* Function names */
+#define FSE_CAT(X,Y) X##Y
+#define FSE_FUNCTION_NAME(X,Y) FSE_CAT(X,Y)
+#define FSE_TYPE_NAME(X,Y) FSE_CAT(X,Y)
+
+static size_t FSE_buildDTable_internal(FSE_DTable* dt, const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog, void* workSpace, size_t wkspSize)
+{
+    void* const tdPtr = dt+1;   /* because *dt is unsigned, 32-bits aligned on 32-bits */
+    FSE_DECODE_TYPE* const tableDecode = (FSE_DECODE_TYPE*) (tdPtr);
+    U16* symbolNext = (U16*)workSpace;
+    BYTE* spread = (BYTE*)(symbolNext + maxSymbolValue + 1);
+
+    U32 const maxSV1 = maxSymbolValue + 1;
+    U32 const tableSize = 1 << tableLog;
+    U32 highThreshold = tableSize-1;
+
+    /* Sanity Checks */
+    if (FSE_BUILD_DTABLE_WKSP_SIZE(tableLog, maxSymbolValue) > wkspSize) return ERROR(maxSymbolValue_tooLarge);
+    if (maxSymbolValue > FSE_MAX_SYMBOL_VALUE) return ERROR(maxSymbolValue_tooLarge);
+    if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);
+
+    /* Init, lay down lowprob symbols */
+    {   FSE_DTableHeader DTableH;
+        DTableH.tableLog = (U16)tableLog;
+        DTableH.fastMode = 1;
+        {   S16 const largeLimit= (S16)(1 << (tableLog-1));
+            U32 s;
+            for (s=0; s<maxSV1; s++) {
+                if (normalizedCounter[s]==-1) {
+                    tableDecode[highThreshold--].symbol = (FSE_FUNCTION_TYPE)s;
+                    symbolNext[s] = 1;
+                } else {
+                    if (normalizedCounter[s] >= largeLimit) DTableH.fastMode=0;
+                    symbolNext[s] = normalizedCounter[s];
+        }   }   }
+        ZSTD_memcpy(dt, &DTableH, sizeof(DTableH));
+    }
+
+    /* Spread symbols */
+    if (highThreshold == tableSize - 1) {
+        size_t const tableMask = tableSize-1;
+        size_t const step = FSE_TABLESTEP(tableSize);
+        /* First lay down the symbols in order.
+         * We use a uint64_t to lay down 8 bytes at a time. This reduces branch
+         * misses since small blocks generally have small table logs, so nearly
+         * all symbols have counts <= 8. We ensure we have 8 bytes at the end of
+         * our buffer to handle the over-write.
+         */
+        {
+            U64 const add = 0x0101010101010101ull;
+            size_t pos = 0;
+            U64 sv = 0;
+            U32 s;
+            for (s=0; s<maxSV1; ++s, sv += add) {
+                int i;
+                int const n = normalizedCounter[s];
+                MEM_write64(spread + pos, sv);
+                for (i = 8; i < n; i += 8) {
+                    MEM_write64(spread + pos + i, sv);
+                }
+                pos += n;
+            }
+        }
+        /* Now we spread those positions across the table.
+         * The benefit of doing it in two stages is that we avoid the
+         * variable size inner loop, which caused lots of branch misses.
+         * Now we can run through all the positions without any branch misses.
+         * We unroll the loop twice, since that is what empirically worked best.
+         */
+        {
+            size_t position = 0;
+            size_t s;
+            size_t const unroll = 2;
+            assert(tableSize % unroll == 0); /* FSE_MIN_TABLELOG is 5 */
+            for (s = 0; s < (size_t)tableSize; s += unroll) {
+                size_t u;
+                for (u = 0; u < unroll; ++u) {
+                    size_t const uPosition = (position + (u * step)) & tableMask;
+                    tableDecode[uPosition].symbol = spread[s + u];
+                }
+                position = (position + (unroll * step)) & tableMask;
+            }
+            assert(position == 0);
+        }
+    } else {
+        U32 const tableMask = tableSize-1;
+        U32 const step = FSE_TABLESTEP(tableSize);
+        U32 s, position = 0;
+        for (s=0; s<maxSV1; s++) {
+            int i;
+            for (i=0; i<normalizedCounter[s]; i++) {
+                tableDecode[position].symbol = (FSE_FUNCTION_TYPE)s;
+                position = (position + step) & tableMask;
+                while (position > highThreshold) position = (position + step) & tableMask;   /* lowprob area */
+        }   }
+        if (position!=0) return ERROR(GENERIC);   /* position must reach all cells once, otherwise normalizedCounter is incorrect */
+    }
+
+    /* Build Decoding table */
+    {   U32 u;
+        for (u=0; u<tableSize; u++) {
+            FSE_FUNCTION_TYPE const symbol = (FSE_FUNCTION_TYPE)(tableDecode[u].symbol);
+            U32 const nextState = symbolNext[symbol]++;
+            tableDecode[u].nbBits = (BYTE) (tableLog - ZSTD_highbit32(nextState) );
+            tableDecode[u].newState = (U16) ( (nextState << tableDecode[u].nbBits) - tableSize);
+    }   }
+
+    return 0;
+}
+
+size_t FSE_buildDTable_wksp(FSE_DTable* dt, const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog, void* workSpace, size_t wkspSize)
+{
+    return FSE_buildDTable_internal(dt, normalizedCounter, maxSymbolValue, tableLog, workSpace, wkspSize);
+}
+
+
+#ifndef FSE_COMMONDEFS_ONLY
+
+/*-*******************************************************
+*  Decompression (Byte symbols)
+*********************************************************/
+
+FORCE_INLINE_TEMPLATE size_t FSE_decompress_usingDTable_generic(
+          void* dst, size_t maxDstSize,
+    const void* cSrc, size_t cSrcSize,
+    const FSE_DTable* dt, const unsigned fast)
+{
+    BYTE* const ostart = (BYTE*) dst;
+    BYTE* op = ostart;
+    BYTE* const omax = op + maxDstSize;
+    BYTE* const olimit = omax-3;
+
+    BIT_DStream_t bitD;
+    FSE_DState_t state1;
+    FSE_DState_t state2;
+
+    /* Init */
+    CHECK_F(BIT_initDStream(&bitD, cSrc, cSrcSize));
+
+    FSE_initDState(&state1, &bitD, dt);
+    FSE_initDState(&state2, &bitD, dt);
+
+#define FSE_GETSYMBOL(statePtr) fast ? FSE_decodeSymbolFast(statePtr, &bitD) : FSE_decodeSymbol(statePtr, &bitD)
+
+    /* 4 symbols per loop */
+    for ( ; (BIT_reloadDStream(&bitD)==BIT_DStream_unfinished) & (op<olimit) ; op+=4) {
+        op[0] = FSE_GETSYMBOL(&state1);
+
+        if (FSE_MAX_TABLELOG*2+7 > sizeof(bitD.bitContainer)*8)    /* This test must be static */
+            BIT_reloadDStream(&bitD);
+
+        op[1] = FSE_GETSYMBOL(&state2);
+
+        if (FSE_MAX_TABLELOG*4+7 > sizeof(bitD.bitContainer)*8)    /* This test must be static */
+            { if (BIT_reloadDStream(&bitD) > BIT_DStream_unfinished) { op+=2; break; } }
+
+        op[2] = FSE_GETSYMBOL(&state1);
+
+        if (FSE_MAX_TABLELOG*2+7 > sizeof(bitD.bitContainer)*8)    /* This test must be static */
+            BIT_reloadDStream(&bitD);
+
+        op[3] = FSE_GETSYMBOL(&state2);
+    }
+
+    /* tail */
+    /* note : BIT_reloadDStream(&bitD) >= FSE_DStream_partiallyFilled; Ends at exactly BIT_DStream_completed */
+    while (1) {
+        if (op>(omax-2)) return ERROR(dstSize_tooSmall);
+        *op++ = FSE_GETSYMBOL(&state1);
+        if (BIT_reloadDStream(&bitD)==BIT_DStream_overflow) {
+            *op++ = FSE_GETSYMBOL(&state2);
+            break;
+        }
+
+        if (op>(omax-2)) return ERROR(dstSize_tooSmall);
+        *op++ = FSE_GETSYMBOL(&state2);
+        if (BIT_reloadDStream(&bitD)==BIT_DStream_overflow) {
+            *op++ = FSE_GETSYMBOL(&state1);
+            break;
+    }   }
+
+    return op-ostart;
+}
+
+typedef struct {
+    short ncount[FSE_MAX_SYMBOL_VALUE + 1];
+    FSE_DTable dtable[1]; /* Dynamically sized */
+} FSE_DecompressWksp;
+
+
+FORCE_INLINE_TEMPLATE size_t FSE_decompress_wksp_body(
+        void* dst, size_t dstCapacity,
+        const void* cSrc, size_t cSrcSize,
+        unsigned maxLog, void* workSpace, size_t wkspSize,
+        int bmi2)
+{
+    const BYTE* const istart = (const BYTE*)cSrc;
+    const BYTE* ip = istart;
+    unsigned tableLog;
+    unsigned maxSymbolValue = FSE_MAX_SYMBOL_VALUE;
+    FSE_DecompressWksp* const wksp = (FSE_DecompressWksp*)workSpace;
+
+    DEBUG_STATIC_ASSERT((FSE_MAX_SYMBOL_VALUE + 1) % 2 == 0);
+    if (wkspSize < sizeof(*wksp)) return ERROR(GENERIC);
+
+    /* normal FSE decoding mode */
+    {
+        size_t const NCountLength = FSE_readNCount_bmi2(wksp->ncount, &maxSymbolValue, &tableLog, istart, cSrcSize, bmi2);
+        if (FSE_isError(NCountLength)) return NCountLength;
+        if (tableLog > maxLog) return ERROR(tableLog_tooLarge);
+        assert(NCountLength <= cSrcSize);
+        ip += NCountLength;
+        cSrcSize -= NCountLength;
+    }
+
+    if (FSE_DECOMPRESS_WKSP_SIZE(tableLog, maxSymbolValue) > wkspSize) return ERROR(tableLog_tooLarge);
+    assert(sizeof(*wksp) + FSE_DTABLE_SIZE(tableLog) <= wkspSize);
+    workSpace = (BYTE*)workSpace + sizeof(*wksp) + FSE_DTABLE_SIZE(tableLog);
+    wkspSize -= sizeof(*wksp) + FSE_DTABLE_SIZE(tableLog);
+
+    CHECK_F( FSE_buildDTable_internal(wksp->dtable, wksp->ncount, maxSymbolValue, tableLog, workSpace, wkspSize) );
+
+    {
+        const void* ptr = wksp->dtable;
+        const FSE_DTableHeader* DTableH = (const FSE_DTableHeader*)ptr;
+        const U32 fastMode = DTableH->fastMode;
+
+        /* select fast mode (static) */
+        if (fastMode) return FSE_decompress_usingDTable_generic(dst, dstCapacity, ip, cSrcSize, wksp->dtable, 1);
+        return FSE_decompress_usingDTable_generic(dst, dstCapacity, ip, cSrcSize, wksp->dtable, 0);
+    }
+}
+
+/* Avoids the FORCE_INLINE of the _body() function. */
+static size_t FSE_decompress_wksp_body_default(void* dst, size_t dstCapacity, const void* cSrc, size_t cSrcSize, unsigned maxLog, void* workSpace, size_t wkspSize)
+{
+    return FSE_decompress_wksp_body(dst, dstCapacity, cSrc, cSrcSize, maxLog, workSpace, wkspSize, 0);
+}
+
+#if DYNAMIC_BMI2
+BMI2_TARGET_ATTRIBUTE static size_t FSE_decompress_wksp_body_bmi2(void* dst, size_t dstCapacity, const void* cSrc, size_t cSrcSize, unsigned maxLog, void* workSpace, size_t wkspSize)
+{
+    return FSE_decompress_wksp_body(dst, dstCapacity, cSrc, cSrcSize, maxLog, workSpace, wkspSize, 1);
+}
+#endif
+
+size_t FSE_decompress_wksp_bmi2(void* dst, size_t dstCapacity, const void* cSrc, size_t cSrcSize, unsigned maxLog, void* workSpace, size_t wkspSize, int bmi2)
+{
+#if DYNAMIC_BMI2
+    if (bmi2) {
+        return FSE_decompress_wksp_body_bmi2(dst, dstCapacity, cSrc, cSrcSize, maxLog, workSpace, wkspSize);
+    }
+#endif
+    (void)bmi2;
+    return FSE_decompress_wksp_body_default(dst, dstCapacity, cSrc, cSrcSize, maxLog, workSpace, wkspSize);
+}
+
+#endif   /* FSE_COMMONDEFS_ONLY */
diff --git a/src/3rdparty/zstd/src/common/huf.h b/src/3rdparty/zstd/src/common/huf.h
new file mode 100644
index 0000000000..73d1ee5654
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/huf.h
@@ -0,0 +1,273 @@
+/* ******************************************************************
+ * huff0 huffman codec,
+ * part of Finite State Entropy library
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * You can contact the author at :
+ * - Source repository : https://github.com/Cyan4973/FiniteStateEntropy
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+****************************************************************** */
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#ifndef HUF_H_298734234
+#define HUF_H_298734234
+
+/* *** Dependencies *** */
+#include "zstd_deps.h"    /* size_t */
+#include "mem.h"          /* U32 */
+#define FSE_STATIC_LINKING_ONLY
+#include "fse.h"
+
+
+/* ***   Tool functions *** */
+#define HUF_BLOCKSIZE_MAX (128 * 1024)   /**< maximum input size for a single block compressed with HUF_compress */
+size_t HUF_compressBound(size_t size);   /**< maximum compressed size (worst case) */
+
+/* Error Management */
+unsigned    HUF_isError(size_t code);       /**< tells if a return value is an error code */
+const char* HUF_getErrorName(size_t code);  /**< provides error code string (useful for debugging) */
+
+
+#define HUF_WORKSPACE_SIZE ((8 << 10) + 512 /* sorting scratch space */)
+#define HUF_WORKSPACE_SIZE_U64 (HUF_WORKSPACE_SIZE / sizeof(U64))
+
+/* *** Constants *** */
+#define HUF_TABLELOG_MAX      12      /* max runtime value of tableLog (due to static allocation); can be modified up to HUF_TABLELOG_ABSOLUTEMAX */
+#define HUF_TABLELOG_DEFAULT  11      /* default tableLog value when none specified */
+#define HUF_SYMBOLVALUE_MAX  255
+
+#define HUF_TABLELOG_ABSOLUTEMAX  12  /* absolute limit of HUF_MAX_TABLELOG. Beyond that value, code does not work */
+#if (HUF_TABLELOG_MAX > HUF_TABLELOG_ABSOLUTEMAX)
+#  error "HUF_TABLELOG_MAX is too large !"
+#endif
+
+
+/* ****************************************
+*  Static allocation
+******************************************/
+/* HUF buffer bounds */
+#define HUF_CTABLEBOUND 129
+#define HUF_BLOCKBOUND(size) (size + (size>>8) + 8)   /* only true when incompressible is pre-filtered with fast heuristic */
+#define HUF_COMPRESSBOUND(size) (HUF_CTABLEBOUND + HUF_BLOCKBOUND(size))   /* Macro version, useful for static allocation */
+
+/* static allocation of HUF's Compression Table */
+/* this is a private definition, just exposed for allocation and strict aliasing purpose. never EVER access its members directly */
+typedef size_t HUF_CElt;   /* consider it an incomplete type */
+#define HUF_CTABLE_SIZE_ST(maxSymbolValue)   ((maxSymbolValue)+2)   /* Use tables of size_t, for proper alignment */
+#define HUF_CTABLE_SIZE(maxSymbolValue)       (HUF_CTABLE_SIZE_ST(maxSymbolValue) * sizeof(size_t))
+#define HUF_CREATE_STATIC_CTABLE(name, maxSymbolValue) \
+    HUF_CElt name[HUF_CTABLE_SIZE_ST(maxSymbolValue)] /* no final ; */
+
+/* static allocation of HUF's DTable */
+typedef U32 HUF_DTable;
+#define HUF_DTABLE_SIZE(maxTableLog)   (1 + (1<<(maxTableLog)))
+#define HUF_CREATE_STATIC_DTABLEX1(DTable, maxTableLog) \
+        HUF_DTable DTable[HUF_DTABLE_SIZE((maxTableLog)-1)] = { ((U32)((maxTableLog)-1) * 0x01000001) }
+#define HUF_CREATE_STATIC_DTABLEX2(DTable, maxTableLog) \
+        HUF_DTable DTable[HUF_DTABLE_SIZE(maxTableLog)] = { ((U32)(maxTableLog) * 0x01000001) }
+
+
+/* ****************************************
+*  Advanced decompression functions
+******************************************/
+
+/**
+ * Huffman flags bitset.
+ * For all flags, 0 is the default value.
+ */
+typedef enum {
+    /**
+     * If compiled with DYNAMIC_BMI2: Set flag only if the CPU supports BMI2 at runtime.
+     * Otherwise: Ignored.
+     */
+    HUF_flags_bmi2 = (1 << 0),
+    /**
+     * If set: Test possible table depths to find the one that produces the smallest header + encoded size.
+     * If unset: Use heuristic to find the table depth.
+     */
+    HUF_flags_optimalDepth = (1 << 1),
+    /**
+     * If set: If the previous table can encode the input, always reuse the previous table.
+     * If unset: If the previous table can encode the input, reuse the previous table if it results in a smaller output.
+     */
+    HUF_flags_preferRepeat = (1 << 2),
+    /**
+     * If set: Sample the input and check if the sample is uncompressible, if it is then don't attempt to compress.
+     * If unset: Always histogram the entire input.
+     */
+    HUF_flags_suspectUncompressible = (1 << 3),
+    /**
+     * If set: Don't use assembly implementations
+     * If unset: Allow using assembly implementations
+     */
+    HUF_flags_disableAsm = (1 << 4),
+    /**
+     * If set: Don't use the fast decoding loop, always use the fallback decoding loop.
+     * If unset: Use the fast decoding loop when possible.
+     */
+    HUF_flags_disableFast = (1 << 5)
+} HUF_flags_e;
+
+
+/* ****************************************
+ *  HUF detailed API
+ * ****************************************/
+#define HUF_OPTIMAL_DEPTH_THRESHOLD ZSTD_btultra
+
+/*! HUF_compress() does the following:
+ *  1. count symbol occurrence from source[] into table count[] using FSE_count() (exposed within "fse.h")
+ *  2. (optional) refine tableLog using HUF_optimalTableLog()
+ *  3. build Huffman table from count using HUF_buildCTable()
+ *  4. save Huffman table to memory buffer using HUF_writeCTable()
+ *  5. encode the data stream using HUF_compress4X_usingCTable()
+ *
+ *  The following API allows targeting specific sub-functions for advanced tasks.
+ *  For example, it's possible to compress several blocks using the same 'CTable',
+ *  or to save and regenerate 'CTable' using external methods.
+ */
+unsigned HUF_minTableLog(unsigned symbolCardinality);
+unsigned HUF_cardinality(const unsigned* count, unsigned maxSymbolValue);
+unsigned HUF_optimalTableLog(unsigned maxTableLog, size_t srcSize, unsigned maxSymbolValue, void* workSpace,
+ size_t wkspSize, HUF_CElt* table, const unsigned* count, int flags); /* table is used as scratch space for building and testing tables, not a return value */
+size_t HUF_writeCTable_wksp(void* dst, size_t maxDstSize, const HUF_CElt* CTable, unsigned maxSymbolValue, unsigned huffLog, void* workspace, size_t workspaceSize);
+size_t HUF_compress4X_usingCTable(void* dst, size_t dstSize, const void* src, size_t srcSize, const HUF_CElt* CTable, int flags);
+size_t HUF_estimateCompressedSize(const HUF_CElt* CTable, const unsigned* count, unsigned maxSymbolValue);
+int HUF_validateCTable(const HUF_CElt* CTable, const unsigned* count, unsigned maxSymbolValue);
+
+typedef enum {
+   HUF_repeat_none,  /**< Cannot use the previous table */
+   HUF_repeat_check, /**< Can use the previous table but it must be checked. Note : The previous table must have been constructed by HUF_compress{1, 4}X_repeat */
+   HUF_repeat_valid  /**< Can use the previous table and it is assumed to be valid */
+ } HUF_repeat;
+
+/** HUF_compress4X_repeat() :
+ *  Same as HUF_compress4X_wksp(), but considers using hufTable if *repeat != HUF_repeat_none.
+ *  If it uses hufTable it does not modify hufTable or repeat.
+ *  If it doesn't, it sets *repeat = HUF_repeat_none, and it sets hufTable to the table used.
+ *  If preferRepeat then the old table will always be used if valid.
+ *  If suspectUncompressible then some sampling checks will be run to potentially skip huffman coding */
+size_t HUF_compress4X_repeat(void* dst, size_t dstSize,
+                       const void* src, size_t srcSize,
+                       unsigned maxSymbolValue, unsigned tableLog,
+                       void* workSpace, size_t wkspSize,    /**< `workSpace` must be aligned on 4-bytes boundaries, `wkspSize` must be >= HUF_WORKSPACE_SIZE */
+                       HUF_CElt* hufTable, HUF_repeat* repeat, int flags);
+
+/** HUF_buildCTable_wksp() :
+ *  Same as HUF_buildCTable(), but using externally allocated scratch buffer.
+ * `workSpace` must be aligned on 4-bytes boundaries, and its size must be >= HUF_CTABLE_WORKSPACE_SIZE.
+ */
+#define HUF_CTABLE_WORKSPACE_SIZE_U32 ((4 * (HUF_SYMBOLVALUE_MAX + 1)) + 192)
+#define HUF_CTABLE_WORKSPACE_SIZE (HUF_CTABLE_WORKSPACE_SIZE_U32 * sizeof(unsigned))
+size_t HUF_buildCTable_wksp (HUF_CElt* tree,
+                       const unsigned* count, U32 maxSymbolValue, U32 maxNbBits,
+                             void* workSpace, size_t wkspSize);
+
+/*! HUF_readStats() :
+ *  Read compact Huffman tree, saved by HUF_writeCTable().
+ * `huffWeight` is destination buffer.
+ * @return : size read from `src` , or an error Code .
+ *  Note : Needed by HUF_readCTable() and HUF_readDTableXn() . */
+size_t HUF_readStats(BYTE* huffWeight, size_t hwSize,
+                     U32* rankStats, U32* nbSymbolsPtr, U32* tableLogPtr,
+                     const void* src, size_t srcSize);
+
+/*! HUF_readStats_wksp() :
+ * Same as HUF_readStats() but takes an external workspace which must be
+ * 4-byte aligned and its size must be >= HUF_READ_STATS_WORKSPACE_SIZE.
+ * If the CPU has BMI2 support, pass bmi2=1, otherwise pass bmi2=0.
+ */
+#define HUF_READ_STATS_WORKSPACE_SIZE_U32 FSE_DECOMPRESS_WKSP_SIZE_U32(6, HUF_TABLELOG_MAX-1)
+#define HUF_READ_STATS_WORKSPACE_SIZE (HUF_READ_STATS_WORKSPACE_SIZE_U32 * sizeof(unsigned))
+size_t HUF_readStats_wksp(BYTE* huffWeight, size_t hwSize,
+                          U32* rankStats, U32* nbSymbolsPtr, U32* tableLogPtr,
+                          const void* src, size_t srcSize,
+                          void* workspace, size_t wkspSize,
+                          int flags);
+
+/** HUF_readCTable() :
+ *  Loading a CTable saved with HUF_writeCTable() */
+size_t HUF_readCTable (HUF_CElt* CTable, unsigned* maxSymbolValuePtr, const void* src, size_t srcSize, unsigned *hasZeroWeights);
+
+/** HUF_getNbBitsFromCTable() :
+ *  Read nbBits from CTable symbolTable, for symbol `symbolValue` presumed <= HUF_SYMBOLVALUE_MAX
+ *  Note 1 : is not inlined, as HUF_CElt definition is private */
+U32 HUF_getNbBitsFromCTable(const HUF_CElt* symbolTable, U32 symbolValue);
+
+/*
+ * HUF_decompress() does the following:
+ * 1. select the decompression algorithm (X1, X2) based on pre-computed heuristics
+ * 2. build Huffman table from save, using HUF_readDTableX?()
+ * 3. decode 1 or 4 segments in parallel using HUF_decompress?X?_usingDTable()
+ */
+
+/** HUF_selectDecoder() :
+ *  Tells which decoder is likely to decode faster,
+ *  based on a set of pre-computed metrics.
+ * @return : 0==HUF_decompress4X1, 1==HUF_decompress4X2 .
+ *  Assumption : 0 < dstSize <= 128 KB */
+U32 HUF_selectDecoder (size_t dstSize, size_t cSrcSize);
+
+/**
+ *  The minimum workspace size for the `workSpace` used in
+ *  HUF_readDTableX1_wksp() and HUF_readDTableX2_wksp().
+ *
+ *  The space used depends on HUF_TABLELOG_MAX, ranging from ~1500 bytes when
+ *  HUF_TABLE_LOG_MAX=12 to ~1850 bytes when HUF_TABLE_LOG_MAX=15.
+ *  Buffer overflow errors may potentially occur if code modifications result in
+ *  a required workspace size greater than that specified in the following
+ *  macro.
+ */
+#define HUF_DECOMPRESS_WORKSPACE_SIZE ((2 << 10) + (1 << 9))
+#define HUF_DECOMPRESS_WORKSPACE_SIZE_U32 (HUF_DECOMPRESS_WORKSPACE_SIZE / sizeof(U32))
+
+
+/* ====================== */
+/* single stream variants */
+/* ====================== */
+
+size_t HUF_compress1X_usingCTable(void* dst, size_t dstSize, const void* src, size_t srcSize, const HUF_CElt* CTable, int flags);
+/** HUF_compress1X_repeat() :
+ *  Same as HUF_compress1X_wksp(), but considers using hufTable if *repeat != HUF_repeat_none.
+ *  If it uses hufTable it does not modify hufTable or repeat.
+ *  If it doesn't, it sets *repeat = HUF_repeat_none, and it sets hufTable to the table used.
+ *  If preferRepeat then the old table will always be used if valid.
+ *  If suspectUncompressible then some sampling checks will be run to potentially skip huffman coding */
+size_t HUF_compress1X_repeat(void* dst, size_t dstSize,
+                       const void* src, size_t srcSize,
+                       unsigned maxSymbolValue, unsigned tableLog,
+                       void* workSpace, size_t wkspSize,   /**< `workSpace` must be aligned on 4-bytes boundaries, `wkspSize` must be >= HUF_WORKSPACE_SIZE */
+                       HUF_CElt* hufTable, HUF_repeat* repeat, int flags);
+
+size_t HUF_decompress1X_DCtx_wksp(HUF_DTable* dctx, void* dst, size_t dstSize, const void* cSrc, size_t cSrcSize, void* workSpace, size_t wkspSize, int flags);
+#ifndef HUF_FORCE_DECOMPRESS_X1
+size_t HUF_decompress1X2_DCtx_wksp(HUF_DTable* dctx, void* dst, size_t dstSize, const void* cSrc, size_t cSrcSize, void* workSpace, size_t wkspSize, int flags);   /**< double-symbols decoder */
+#endif
+
+/* BMI2 variants.
+ * If the CPU has BMI2 support, pass bmi2=1, otherwise pass bmi2=0.
+ */
+size_t HUF_decompress1X_usingDTable(void* dst, size_t maxDstSize, const void* cSrc, size_t cSrcSize, const HUF_DTable* DTable, int flags);
+#ifndef HUF_FORCE_DECOMPRESS_X2
+size_t HUF_decompress1X1_DCtx_wksp(HUF_DTable* dctx, void* dst, size_t dstSize, const void* cSrc, size_t cSrcSize, void* workSpace, size_t wkspSize, int flags);
+#endif
+size_t HUF_decompress4X_usingDTable(void* dst, size_t maxDstSize, const void* cSrc, size_t cSrcSize, const HUF_DTable* DTable, int flags);
+size_t HUF_decompress4X_hufOnly_wksp(HUF_DTable* dctx, void* dst, size_t dstSize, const void* cSrc, size_t cSrcSize, void* workSpace, size_t wkspSize, int flags);
+#ifndef HUF_FORCE_DECOMPRESS_X2
+size_t HUF_readDTableX1_wksp(HUF_DTable* DTable, const void* src, size_t srcSize, void* workSpace, size_t wkspSize, int flags);
+#endif
+#ifndef HUF_FORCE_DECOMPRESS_X1
+size_t HUF_readDTableX2_wksp(HUF_DTable* DTable, const void* src, size_t srcSize, void* workSpace, size_t wkspSize, int flags);
+#endif
+
+#endif   /* HUF_H_298734234 */
+
+#if defined (__cplusplus)
+}
+#endif
diff --git a/src/3rdparty/zstd/src/common/mem.h b/src/3rdparty/zstd/src/common/mem.h
new file mode 100644
index 0000000000..98dd47a047
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/mem.h
@@ -0,0 +1,435 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef MEM_H_MODULE
+#define MEM_H_MODULE
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+/*-****************************************
+*  Dependencies
+******************************************/
+#include <stddef.h>  /* size_t, ptrdiff_t */
+#include "compiler.h"  /* __has_builtin */
+#include "debug.h"  /* DEBUG_STATIC_ASSERT */
+#include "zstd_deps.h"  /* ZSTD_memcpy */
+
+
+/*-****************************************
+*  Compiler specifics
+******************************************/
+#if defined(_MSC_VER)   /* Visual Studio */
+#   include <stdlib.h>  /* _byteswap_ulong */
+#   include <intrin.h>  /* _byteswap_* */
+#endif
+#if defined(__GNUC__)
+#  define MEM_STATIC static __inline __attribute__((unused))
+#elif defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */)
+#  define MEM_STATIC static inline
+#elif defined(_MSC_VER)
+#  define MEM_STATIC static __inline
+#else
+#  define MEM_STATIC static  /* this version may generate warnings for unused static functions; disable the relevant warning */
+#endif
+
+/*-**************************************************************
+*  Basic Types
+*****************************************************************/
+#if  !defined (__VMS) && (defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
+#  if defined(_AIX)
+#    include <inttypes.h>
+#  else
+#    include <stdint.h> /* intptr_t */
+#  endif
+  typedef   uint8_t BYTE;
+  typedef   uint8_t U8;
+  typedef    int8_t S8;
+  typedef  uint16_t U16;
+  typedef   int16_t S16;
+  typedef  uint32_t U32;
+  typedef   int32_t S32;
+  typedef  uint64_t U64;
+  typedef   int64_t S64;
+#else
+# include <limits.h>
+#if CHAR_BIT != 8
+#  error "this implementation requires char to be exactly 8-bit type"
+#endif
+  typedef unsigned char      BYTE;
+  typedef unsigned char      U8;
+  typedef   signed char      S8;
+#if USHRT_MAX != 65535
+#  error "this implementation requires short to be exactly 16-bit type"
+#endif
+  typedef unsigned short      U16;
+  typedef   signed short      S16;
+#if UINT_MAX != 4294967295
+#  error "this implementation requires int to be exactly 32-bit type"
+#endif
+  typedef unsigned int        U32;
+  typedef   signed int        S32;
+/* note : there are no limits defined for long long type in C90.
+ * limits exist in C99, however, in such case, <stdint.h> is preferred */
+  typedef unsigned long long  U64;
+  typedef   signed long long  S64;
+#endif
+
+
+/*-**************************************************************
+*  Memory I/O API
+*****************************************************************/
+/*=== Static platform detection ===*/
+MEM_STATIC unsigned MEM_32bits(void);
+MEM_STATIC unsigned MEM_64bits(void);
+MEM_STATIC unsigned MEM_isLittleEndian(void);
+
+/*=== Native unaligned read/write ===*/
+MEM_STATIC U16 MEM_read16(const void* memPtr);
+MEM_STATIC U32 MEM_read32(const void* memPtr);
+MEM_STATIC U64 MEM_read64(const void* memPtr);
+MEM_STATIC size_t MEM_readST(const void* memPtr);
+
+MEM_STATIC void MEM_write16(void* memPtr, U16 value);
+MEM_STATIC void MEM_write32(void* memPtr, U32 value);
+MEM_STATIC void MEM_write64(void* memPtr, U64 value);
+
+/*=== Little endian unaligned read/write ===*/
+MEM_STATIC U16 MEM_readLE16(const void* memPtr);
+MEM_STATIC U32 MEM_readLE24(const void* memPtr);
+MEM_STATIC U32 MEM_readLE32(const void* memPtr);
+MEM_STATIC U64 MEM_readLE64(const void* memPtr);
+MEM_STATIC size_t MEM_readLEST(const void* memPtr);
+
+MEM_STATIC void MEM_writeLE16(void* memPtr, U16 val);
+MEM_STATIC void MEM_writeLE24(void* memPtr, U32 val);
+MEM_STATIC void MEM_writeLE32(void* memPtr, U32 val32);
+MEM_STATIC void MEM_writeLE64(void* memPtr, U64 val64);
+MEM_STATIC void MEM_writeLEST(void* memPtr, size_t val);
+
+/*=== Big endian unaligned read/write ===*/
+MEM_STATIC U32 MEM_readBE32(const void* memPtr);
+MEM_STATIC U64 MEM_readBE64(const void* memPtr);
+MEM_STATIC size_t MEM_readBEST(const void* memPtr);
+
+MEM_STATIC void MEM_writeBE32(void* memPtr, U32 val32);
+MEM_STATIC void MEM_writeBE64(void* memPtr, U64 val64);
+MEM_STATIC void MEM_writeBEST(void* memPtr, size_t val);
+
+/*=== Byteswap ===*/
+MEM_STATIC U32 MEM_swap32(U32 in);
+MEM_STATIC U64 MEM_swap64(U64 in);
+MEM_STATIC size_t MEM_swapST(size_t in);
+
+
+/*-**************************************************************
+*  Memory I/O Implementation
+*****************************************************************/
+/* MEM_FORCE_MEMORY_ACCESS : For accessing unaligned memory:
+ * Method 0 : always use `memcpy()`. Safe and portable.
+ * Method 1 : Use compiler extension to set unaligned access.
+ * Method 2 : direct access. This method is portable but violate C standard.
+ *            It can generate buggy code on targets depending on alignment.
+ * Default  : method 1 if supported, else method 0
+ */
+#ifndef MEM_FORCE_MEMORY_ACCESS   /* can be defined externally, on command line for example */
+#  ifdef __GNUC__
+#    define MEM_FORCE_MEMORY_ACCESS 1
+#  endif
+#endif
+
+MEM_STATIC unsigned MEM_32bits(void) { return sizeof(size_t)==4; }
+MEM_STATIC unsigned MEM_64bits(void) { return sizeof(size_t)==8; }
+
+MEM_STATIC unsigned MEM_isLittleEndian(void)
+{
+#if defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
+    return 1;
+#elif defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
+    return 0;
+#elif defined(__clang__) && __LITTLE_ENDIAN__
+    return 1;
+#elif defined(__clang__) && __BIG_ENDIAN__
+    return 0;
+#elif defined(_MSC_VER) && (_M_AMD64 || _M_IX86)
+    return 1;
+#elif defined(__DMC__) && defined(_M_IX86)
+    return 1;
+#else
+    const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
+    return one.c[0];
+#endif
+}
+
+#if defined(MEM_FORCE_MEMORY_ACCESS) && (MEM_FORCE_MEMORY_ACCESS==2)
+
+/* violates C standard, by lying on structure alignment.
+Only use if no other choice to achieve best performance on target platform */
+MEM_STATIC U16 MEM_read16(const void* memPtr) { return *(const U16*) memPtr; }
+MEM_STATIC U32 MEM_read32(const void* memPtr) { return *(const U32*) memPtr; }
+MEM_STATIC U64 MEM_read64(const void* memPtr) { return *(const U64*) memPtr; }
+MEM_STATIC size_t MEM_readST(const void* memPtr) { return *(const size_t*) memPtr; }
+
+MEM_STATIC void MEM_write16(void* memPtr, U16 value) { *(U16*)memPtr = value; }
+MEM_STATIC void MEM_write32(void* memPtr, U32 value) { *(U32*)memPtr = value; }
+MEM_STATIC void MEM_write64(void* memPtr, U64 value) { *(U64*)memPtr = value; }
+
+#elif defined(MEM_FORCE_MEMORY_ACCESS) && (MEM_FORCE_MEMORY_ACCESS==1)
+
+typedef __attribute__((aligned(1))) U16 unalign16;
+typedef __attribute__((aligned(1))) U32 unalign32;
+typedef __attribute__((aligned(1))) U64 unalign64;
+typedef __attribute__((aligned(1))) size_t unalignArch;
+
+MEM_STATIC U16 MEM_read16(const void* ptr) { return *(const unalign16*)ptr; }
+MEM_STATIC U32 MEM_read32(const void* ptr) { return *(const unalign32*)ptr; }
+MEM_STATIC U64 MEM_read64(const void* ptr) { return *(const unalign64*)ptr; }
+MEM_STATIC size_t MEM_readST(const void* ptr) { return *(const unalignArch*)ptr; }
+
+MEM_STATIC void MEM_write16(void* memPtr, U16 value) { *(unalign16*)memPtr = value; }
+MEM_STATIC void MEM_write32(void* memPtr, U32 value) { *(unalign32*)memPtr = value; }
+MEM_STATIC void MEM_write64(void* memPtr, U64 value) { *(unalign64*)memPtr = value; }
+
+#else
+
+/* default method, safe and standard.
+   can sometimes prove slower */
+
+MEM_STATIC U16 MEM_read16(const void* memPtr)
+{
+    U16 val; ZSTD_memcpy(&val, memPtr, sizeof(val)); return val;
+}
+
+MEM_STATIC U32 MEM_read32(const void* memPtr)
+{
+    U32 val; ZSTD_memcpy(&val, memPtr, sizeof(val)); return val;
+}
+
+MEM_STATIC U64 MEM_read64(const void* memPtr)
+{
+    U64 val; ZSTD_memcpy(&val, memPtr, sizeof(val)); return val;
+}
+
+MEM_STATIC size_t MEM_readST(const void* memPtr)
+{
+    size_t val; ZSTD_memcpy(&val, memPtr, sizeof(val)); return val;
+}
+
+MEM_STATIC void MEM_write16(void* memPtr, U16 value)
+{
+    ZSTD_memcpy(memPtr, &value, sizeof(value));
+}
+
+MEM_STATIC void MEM_write32(void* memPtr, U32 value)
+{
+    ZSTD_memcpy(memPtr, &value, sizeof(value));
+}
+
+MEM_STATIC void MEM_write64(void* memPtr, U64 value)
+{
+    ZSTD_memcpy(memPtr, &value, sizeof(value));
+}
+
+#endif /* MEM_FORCE_MEMORY_ACCESS */
+
+MEM_STATIC U32 MEM_swap32_fallback(U32 in)
+{
+    return  ((in << 24) & 0xff000000 ) |
+            ((in <<  8) & 0x00ff0000 ) |
+            ((in >>  8) & 0x0000ff00 ) |
+            ((in >> 24) & 0x000000ff );
+}
+
+MEM_STATIC U32 MEM_swap32(U32 in)
+{
+#if defined(_MSC_VER)     /* Visual Studio */
+    return _byteswap_ulong(in);
+#elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
+  || (defined(__clang__) && __has_builtin(__builtin_bswap32))
+    return __builtin_bswap32(in);
+#else
+    return MEM_swap32_fallback(in);
+#endif
+}
+
+MEM_STATIC U64 MEM_swap64_fallback(U64 in)
+{
+     return  ((in << 56) & 0xff00000000000000ULL) |
+            ((in << 40) & 0x00ff000000000000ULL) |
+            ((in << 24) & 0x0000ff0000000000ULL) |
+            ((in << 8)  & 0x000000ff00000000ULL) |
+            ((in >> 8)  & 0x00000000ff000000ULL) |
+            ((in >> 24) & 0x0000000000ff0000ULL) |
+            ((in >> 40) & 0x000000000000ff00ULL) |
+            ((in >> 56) & 0x00000000000000ffULL);
+}
+
+MEM_STATIC U64 MEM_swap64(U64 in)
+{
+#if defined(_MSC_VER)     /* Visual Studio */
+    return _byteswap_uint64(in);
+#elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \
+  || (defined(__clang__) && __has_builtin(__builtin_bswap64))
+    return __builtin_bswap64(in);
+#else
+    return MEM_swap64_fallback(in);
+#endif
+}
+
+MEM_STATIC size_t MEM_swapST(size_t in)
+{
+    if (MEM_32bits())
+        return (size_t)MEM_swap32((U32)in);
+    else
+        return (size_t)MEM_swap64((U64)in);
+}
+
+/*=== Little endian r/w ===*/
+
+MEM_STATIC U16 MEM_readLE16(const void* memPtr)
+{
+    if (MEM_isLittleEndian())
+        return MEM_read16(memPtr);
+    else {
+        const BYTE* p = (const BYTE*)memPtr;
+        return (U16)(p[0] + (p[1]<<8));
+    }
+}
+
+MEM_STATIC void MEM_writeLE16(void* memPtr, U16 val)
+{
+    if (MEM_isLittleEndian()) {
+        MEM_write16(memPtr, val);
+    } else {
+        BYTE* p = (BYTE*)memPtr;
+        p[0] = (BYTE)val;
+        p[1] = (BYTE)(val>>8);
+    }
+}
+
+MEM_STATIC U32 MEM_readLE24(const void* memPtr)
+{
+    return (U32)MEM_readLE16(memPtr) + ((U32)(((const BYTE*)memPtr)[2]) << 16);
+}
+
+MEM_STATIC void MEM_writeLE24(void* memPtr, U32 val)
+{
+    MEM_writeLE16(memPtr, (U16)val);
+    ((BYTE*)memPtr)[2] = (BYTE)(val>>16);
+}
+
+MEM_STATIC U32 MEM_readLE32(const void* memPtr)
+{
+    if (MEM_isLittleEndian())
+        return MEM_read32(memPtr);
+    else
+        return MEM_swap32(MEM_read32(memPtr));
+}
+
+MEM_STATIC void MEM_writeLE32(void* memPtr, U32 val32)
+{
+    if (MEM_isLittleEndian())
+        MEM_write32(memPtr, val32);
+    else
+        MEM_write32(memPtr, MEM_swap32(val32));
+}
+
+MEM_STATIC U64 MEM_readLE64(const void* memPtr)
+{
+    if (MEM_isLittleEndian())
+        return MEM_read64(memPtr);
+    else
+        return MEM_swap64(MEM_read64(memPtr));
+}
+
+MEM_STATIC void MEM_writeLE64(void* memPtr, U64 val64)
+{
+    if (MEM_isLittleEndian())
+        MEM_write64(memPtr, val64);
+    else
+        MEM_write64(memPtr, MEM_swap64(val64));
+}
+
+MEM_STATIC size_t MEM_readLEST(const void* memPtr)
+{
+    if (MEM_32bits())
+        return (size_t)MEM_readLE32(memPtr);
+    else
+        return (size_t)MEM_readLE64(memPtr);
+}
+
+MEM_STATIC void MEM_writeLEST(void* memPtr, size_t val)
+{
+    if (MEM_32bits())
+        MEM_writeLE32(memPtr, (U32)val);
+    else
+        MEM_writeLE64(memPtr, (U64)val);
+}
+
+/*=== Big endian r/w ===*/
+
+MEM_STATIC U32 MEM_readBE32(const void* memPtr)
+{
+    if (MEM_isLittleEndian())
+        return MEM_swap32(MEM_read32(memPtr));
+    else
+        return MEM_read32(memPtr);
+}
+
+MEM_STATIC void MEM_writeBE32(void* memPtr, U32 val32)
+{
+    if (MEM_isLittleEndian())
+        MEM_write32(memPtr, MEM_swap32(val32));
+    else
+        MEM_write32(memPtr, val32);
+}
+
+MEM_STATIC U64 MEM_readBE64(const void* memPtr)
+{
+    if (MEM_isLittleEndian())
+        return MEM_swap64(MEM_read64(memPtr));
+    else
+        return MEM_read64(memPtr);
+}
+
+MEM_STATIC void MEM_writeBE64(void* memPtr, U64 val64)
+{
+    if (MEM_isLittleEndian())
+        MEM_write64(memPtr, MEM_swap64(val64));
+    else
+        MEM_write64(memPtr, val64);
+}
+
+MEM_STATIC size_t MEM_readBEST(const void* memPtr)
+{
+    if (MEM_32bits())
+        return (size_t)MEM_readBE32(memPtr);
+    else
+        return (size_t)MEM_readBE64(memPtr);
+}
+
+MEM_STATIC void MEM_writeBEST(void* memPtr, size_t val)
+{
+    if (MEM_32bits())
+        MEM_writeBE32(memPtr, (U32)val);
+    else
+        MEM_writeBE64(memPtr, (U64)val);
+}
+
+/* code only tested on 32 and 64 bits systems */
+MEM_STATIC void MEM_check(void) { DEBUG_STATIC_ASSERT((sizeof(size_t)==4) || (sizeof(size_t)==8)); }
+
+
+#if defined (__cplusplus)
+}
+#endif
+
+#endif /* MEM_H_MODULE */
diff --git a/src/3rdparty/zstd/src/common/pool.c b/src/3rdparty/zstd/src/common/pool.c
new file mode 100644
index 0000000000..d5ca5a7808
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/pool.c
@@ -0,0 +1,371 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+
+/* ======   Dependencies   ======= */
+#include "../common/allocations.h"  /* ZSTD_customCalloc, ZSTD_customFree */
+#include "zstd_deps.h" /* size_t */
+#include "debug.h"     /* assert */
+#include "pool.h"
+
+/* ======   Compiler specifics   ====== */
+#if defined(_MSC_VER)
+#  pragma warning(disable : 4204)        /* disable: C4204: non-constant aggregate initializer */
+#endif
+
+
+#ifdef ZSTD_MULTITHREAD
+
+#include "threading.h"   /* pthread adaptation */
+
+/* A job is a function and an opaque argument */
+typedef struct POOL_job_s {
+    POOL_function function;
+    void *opaque;
+} POOL_job;
+
+struct POOL_ctx_s {
+    ZSTD_customMem customMem;
+    /* Keep track of the threads */
+    ZSTD_pthread_t* threads;
+    size_t threadCapacity;
+    size_t threadLimit;
+
+    /* The queue is a circular buffer */
+    POOL_job *queue;
+    size_t queueHead;
+    size_t queueTail;
+    size_t queueSize;
+
+    /* The number of threads working on jobs */
+    size_t numThreadsBusy;
+    /* Indicates if the queue is empty */
+    int queueEmpty;
+
+    /* The mutex protects the queue */
+    ZSTD_pthread_mutex_t queueMutex;
+    /* Condition variable for pushers to wait on when the queue is full */
+    ZSTD_pthread_cond_t queuePushCond;
+    /* Condition variables for poppers to wait on when the queue is empty */
+    ZSTD_pthread_cond_t queuePopCond;
+    /* Indicates if the queue is shutting down */
+    int shutdown;
+};
+
+/* POOL_thread() :
+ * Work thread for the thread pool.
+ * Waits for jobs and executes them.
+ * @returns : NULL on failure else non-null.
+ */
+static void* POOL_thread(void* opaque) {
+    POOL_ctx* const ctx = (POOL_ctx*)opaque;
+    if (!ctx) { return NULL; }
+    for (;;) {
+        /* Lock the mutex and wait for a non-empty queue or until shutdown */
+        ZSTD_pthread_mutex_lock(&ctx->queueMutex);
+
+        while ( ctx->queueEmpty
+            || (ctx->numThreadsBusy >= ctx->threadLimit) ) {
+            if (ctx->shutdown) {
+                /* even if !queueEmpty, (possible if numThreadsBusy >= threadLimit),
+                 * a few threads will be shutdown while !queueEmpty,
+                 * but enough threads will remain active to finish the queue */
+                ZSTD_pthread_mutex_unlock(&ctx->queueMutex);
+                return opaque;
+            }
+            ZSTD_pthread_cond_wait(&ctx->queuePopCond, &ctx->queueMutex);
+        }
+        /* Pop a job off the queue */
+        {   POOL_job const job = ctx->queue[ctx->queueHead];
+            ctx->queueHead = (ctx->queueHead + 1) % ctx->queueSize;
+            ctx->numThreadsBusy++;
+            ctx->queueEmpty = (ctx->queueHead == ctx->queueTail);
+            /* Unlock the mutex, signal a pusher, and run the job */
+            ZSTD_pthread_cond_signal(&ctx->queuePushCond);
+            ZSTD_pthread_mutex_unlock(&ctx->queueMutex);
+
+            job.function(job.opaque);
+
+            /* If the intended queue size was 0, signal after finishing job */
+            ZSTD_pthread_mutex_lock(&ctx->queueMutex);
+            ctx->numThreadsBusy--;
+            ZSTD_pthread_cond_signal(&ctx->queuePushCond);
+            ZSTD_pthread_mutex_unlock(&ctx->queueMutex);
+        }
+    }  /* for (;;) */
+    assert(0);  /* Unreachable */
+}
+
+/* ZSTD_createThreadPool() : public access point */
+POOL_ctx* ZSTD_createThreadPool(size_t numThreads) {
+    return POOL_create (numThreads, 0);
+}
+
+POOL_ctx* POOL_create(size_t numThreads, size_t queueSize) {
+    return POOL_create_advanced(numThreads, queueSize, ZSTD_defaultCMem);
+}
+
+POOL_ctx* POOL_create_advanced(size_t numThreads, size_t queueSize,
+                               ZSTD_customMem customMem)
+{
+    POOL_ctx* ctx;
+    /* Check parameters */
+    if (!numThreads) { return NULL; }
+    /* Allocate the context and zero initialize */
+    ctx = (POOL_ctx*)ZSTD_customCalloc(sizeof(POOL_ctx), customMem);
+    if (!ctx) { return NULL; }
+    /* Initialize the job queue.
+     * It needs one extra space since one space is wasted to differentiate
+     * empty and full queues.
+     */
+    ctx->queueSize = queueSize + 1;
+    ctx->queue = (POOL_job*)ZSTD_customCalloc(ctx->queueSize * sizeof(POOL_job), customMem);
+    ctx->queueHead = 0;
+    ctx->queueTail = 0;
+    ctx->numThreadsBusy = 0;
+    ctx->queueEmpty = 1;
+    {
+        int error = 0;
+        error |= ZSTD_pthread_mutex_init(&ctx->queueMutex, NULL);
+        error |= ZSTD_pthread_cond_init(&ctx->queuePushCond, NULL);
+        error |= ZSTD_pthread_cond_init(&ctx->queuePopCond, NULL);
+        if (error) { POOL_free(ctx); return NULL; }
+    }
+    ctx->shutdown = 0;
+    /* Allocate space for the thread handles */
+    ctx->threads = (ZSTD_pthread_t*)ZSTD_customCalloc(numThreads * sizeof(ZSTD_pthread_t), customMem);
+    ctx->threadCapacity = 0;
+    ctx->customMem = customMem;
+    /* Check for errors */
+    if (!ctx->threads || !ctx->queue) { POOL_free(ctx); return NULL; }
+    /* Initialize the threads */
+    {   size_t i;
+        for (i = 0; i < numThreads; ++i) {
+            if (ZSTD_pthread_create(&ctx->threads[i], NULL, &POOL_thread, ctx)) {
+                ctx->threadCapacity = i;
+                POOL_free(ctx);
+                return NULL;
+        }   }
+        ctx->threadCapacity = numThreads;
+        ctx->threadLimit = numThreads;
+    }
+    return ctx;
+}
+
+/*! POOL_join() :
+    Shutdown the queue, wake any sleeping threads, and join all of the threads.
+*/
+static void POOL_join(POOL_ctx* ctx) {
+    /* Shut down the queue */
+    ZSTD_pthread_mutex_lock(&ctx->queueMutex);
+    ctx->shutdown = 1;
+    ZSTD_pthread_mutex_unlock(&ctx->queueMutex);
+    /* Wake up sleeping threads */
+    ZSTD_pthread_cond_broadcast(&ctx->queuePushCond);
+    ZSTD_pthread_cond_broadcast(&ctx->queuePopCond);
+    /* Join all of the threads */
+    {   size_t i;
+        for (i = 0; i < ctx->threadCapacity; ++i) {
+            ZSTD_pthread_join(ctx->threads[i]);  /* note : could fail */
+    }   }
+}
+
+void POOL_free(POOL_ctx *ctx) {
+    if (!ctx) { return; }
+    POOL_join(ctx);
+    ZSTD_pthread_mutex_destroy(&ctx->queueMutex);
+    ZSTD_pthread_cond_destroy(&ctx->queuePushCond);
+    ZSTD_pthread_cond_destroy(&ctx->queuePopCond);
+    ZSTD_customFree(ctx->queue, ctx->customMem);
+    ZSTD_customFree(ctx->threads, ctx->customMem);
+    ZSTD_customFree(ctx, ctx->customMem);
+}
+
+/*! POOL_joinJobs() :
+ *  Waits for all queued jobs to finish executing.
+ */
+void POOL_joinJobs(POOL_ctx* ctx) {
+    ZSTD_pthread_mutex_lock(&ctx->queueMutex);
+    while(!ctx->queueEmpty || ctx->numThreadsBusy > 0) {
+        ZSTD_pthread_cond_wait(&ctx->queuePushCond, &ctx->queueMutex);
+    }
+    ZSTD_pthread_mutex_unlock(&ctx->queueMutex);
+}
+
+void ZSTD_freeThreadPool (ZSTD_threadPool* pool) {
+  POOL_free (pool);
+}
+
+size_t POOL_sizeof(const POOL_ctx* ctx) {
+    if (ctx==NULL) return 0;  /* supports sizeof NULL */
+    return sizeof(*ctx)
+        + ctx->queueSize * sizeof(POOL_job)
+        + ctx->threadCapacity * sizeof(ZSTD_pthread_t);
+}
+
+
+/* @return : 0 on success, 1 on error */
+static int POOL_resize_internal(POOL_ctx* ctx, size_t numThreads)
+{
+    if (numThreads <= ctx->threadCapacity) {
+        if (!numThreads) return 1;
+        ctx->threadLimit = numThreads;
+        return 0;
+    }
+    /* numThreads > threadCapacity */
+    {   ZSTD_pthread_t* const threadPool = (ZSTD_pthread_t*)ZSTD_customCalloc(numThreads * sizeof(ZSTD_pthread_t), ctx->customMem);
+        if (!threadPool) return 1;
+        /* replace existing thread pool */
+        ZSTD_memcpy(threadPool, ctx->threads, ctx->threadCapacity * sizeof(*threadPool));
+        ZSTD_customFree(ctx->threads, ctx->customMem);
+        ctx->threads = threadPool;
+        /* Initialize additional threads */
+        {   size_t threadId;
+            for (threadId = ctx->threadCapacity; threadId < numThreads; ++threadId) {
+                if (ZSTD_pthread_create(&threadPool[threadId], NULL, &POOL_thread, ctx)) {
+                    ctx->threadCapacity = threadId;
+                    return 1;
+            }   }
+    }   }
+    /* successfully expanded */
+    ctx->threadCapacity = numThreads;
+    ctx->threadLimit = numThreads;
+    return 0;
+}
+
+/* @return : 0 on success, 1 on error */
+int POOL_resize(POOL_ctx* ctx, size_t numThreads)
+{
+    int result;
+    if (ctx==NULL) return 1;
+    ZSTD_pthread_mutex_lock(&ctx->queueMutex);
+    result = POOL_resize_internal(ctx, numThreads);
+    ZSTD_pthread_cond_broadcast(&ctx->queuePopCond);
+    ZSTD_pthread_mutex_unlock(&ctx->queueMutex);
+    return result;
+}
+
+/**
+ * Returns 1 if the queue is full and 0 otherwise.
+ *
+ * When queueSize is 1 (pool was created with an intended queueSize of 0),
+ * then a queue is empty if there is a thread free _and_ no job is waiting.
+ */
+static int isQueueFull(POOL_ctx const* ctx) {
+    if (ctx->queueSize > 1) {
+        return ctx->queueHead == ((ctx->queueTail + 1) % ctx->queueSize);
+    } else {
+        return (ctx->numThreadsBusy == ctx->threadLimit) ||
+               !ctx->queueEmpty;
+    }
+}
+
+
+static void
+POOL_add_internal(POOL_ctx* ctx, POOL_function function, void *opaque)
+{
+    POOL_job job;
+    job.function = function;
+    job.opaque = opaque;
+    assert(ctx != NULL);
+    if (ctx->shutdown) return;
+
+    ctx->queueEmpty = 0;
+    ctx->queue[ctx->queueTail] = job;
+    ctx->queueTail = (ctx->queueTail + 1) % ctx->queueSize;
+    ZSTD_pthread_cond_signal(&ctx->queuePopCond);
+}
+
+void POOL_add(POOL_ctx* ctx, POOL_function function, void* opaque)
+{
+    assert(ctx != NULL);
+    ZSTD_pthread_mutex_lock(&ctx->queueMutex);
+    /* Wait until there is space in the queue for the new job */
+    while (isQueueFull(ctx) && (!ctx->shutdown)) {
+        ZSTD_pthread_cond_wait(&ctx->queuePushCond, &ctx->queueMutex);
+    }
+    POOL_add_internal(ctx, function, opaque);
+    ZSTD_pthread_mutex_unlock(&ctx->queueMutex);
+}
+
+
+int POOL_tryAdd(POOL_ctx* ctx, POOL_function function, void* opaque)
+{
+    assert(ctx != NULL);
+    ZSTD_pthread_mutex_lock(&ctx->queueMutex);
+    if (isQueueFull(ctx)) {
+        ZSTD_pthread_mutex_unlock(&ctx->queueMutex);
+        return 0;
+    }
+    POOL_add_internal(ctx, function, opaque);
+    ZSTD_pthread_mutex_unlock(&ctx->queueMutex);
+    return 1;
+}
+
+
+#else  /* ZSTD_MULTITHREAD  not defined */
+
+/* ========================== */
+/* No multi-threading support */
+/* ========================== */
+
+
+/* We don't need any data, but if it is empty, malloc() might return NULL. */
+struct POOL_ctx_s {
+    int dummy;
+};
+static POOL_ctx g_poolCtx;
+
+POOL_ctx* POOL_create(size_t numThreads, size_t queueSize) {
+    return POOL_create_advanced(numThreads, queueSize, ZSTD_defaultCMem);
+}
+
+POOL_ctx*
+POOL_create_advanced(size_t numThreads, size_t queueSize, ZSTD_customMem customMem)
+{
+    (void)numThreads;
+    (void)queueSize;
+    (void)customMem;
+    return &g_poolCtx;
+}
+
+void POOL_free(POOL_ctx* ctx) {
+    assert(!ctx || ctx == &g_poolCtx);
+    (void)ctx;
+}
+
+void POOL_joinJobs(POOL_ctx* ctx){
+    assert(!ctx || ctx == &g_poolCtx);
+    (void)ctx;
+}
+
+int POOL_resize(POOL_ctx* ctx, size_t numThreads) {
+    (void)ctx; (void)numThreads;
+    return 0;
+}
+
+void POOL_add(POOL_ctx* ctx, POOL_function function, void* opaque) {
+    (void)ctx;
+    function(opaque);
+}
+
+int POOL_tryAdd(POOL_ctx* ctx, POOL_function function, void* opaque) {
+    (void)ctx;
+    function(opaque);
+    return 1;
+}
+
+size_t POOL_sizeof(const POOL_ctx* ctx) {
+    if (ctx==NULL) return 0;  /* supports sizeof NULL */
+    assert(ctx == &g_poolCtx);
+    return sizeof(*ctx);
+}
+
+#endif  /* ZSTD_MULTITHREAD */
diff --git a/src/3rdparty/zstd/src/common/pool.h b/src/3rdparty/zstd/src/common/pool.h
new file mode 100644
index 0000000000..eb22ff509f
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/pool.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef POOL_H
+#define POOL_H
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+
+#include "zstd_deps.h"
+#define ZSTD_STATIC_LINKING_ONLY   /* ZSTD_customMem */
+#include "../zstd.h"
+
+typedef struct POOL_ctx_s POOL_ctx;
+
+/*! POOL_create() :
+ *  Create a thread pool with at most `numThreads` threads.
+ * `numThreads` must be at least 1.
+ *  The maximum number of queued jobs before blocking is `queueSize`.
+ * @return : POOL_ctx pointer on success, else NULL.
+*/
+POOL_ctx* POOL_create(size_t numThreads, size_t queueSize);
+
+POOL_ctx* POOL_create_advanced(size_t numThreads, size_t queueSize,
+                               ZSTD_customMem customMem);
+
+/*! POOL_free() :
+ *  Free a thread pool returned by POOL_create().
+ */
+void POOL_free(POOL_ctx* ctx);
+
+
+/*! POOL_joinJobs() :
+ *  Waits for all queued jobs to finish executing.
+ */
+void POOL_joinJobs(POOL_ctx* ctx);
+
+/*! POOL_resize() :
+ *  Expands or shrinks pool's number of threads.
+ *  This is more efficient than releasing + creating a new context,
+ *  since it tries to preserve and re-use existing threads.
+ * `numThreads` must be at least 1.
+ * @return : 0 when resize was successful,
+ *           !0 (typically 1) if there is an error.
+ *    note : only numThreads can be resized, queueSize remains unchanged.
+ */
+int POOL_resize(POOL_ctx* ctx, size_t numThreads);
+
+/*! POOL_sizeof() :
+ * @return threadpool memory usage
+ *  note : compatible with NULL (returns 0 in this case)
+ */
+size_t POOL_sizeof(const POOL_ctx* ctx);
+
+/*! POOL_function :
+ *  The function type that can be added to a thread pool.
+ */
+typedef void (*POOL_function)(void*);
+
+/*! POOL_add() :
+ *  Add the job `function(opaque)` to the thread pool. `ctx` must be valid.
+ *  Possibly blocks until there is room in the queue.
+ *  Note : The function may be executed asynchronously,
+ *         therefore, `opaque` must live until function has been completed.
+ */
+void POOL_add(POOL_ctx* ctx, POOL_function function, void* opaque);
+
+
+/*! POOL_tryAdd() :
+ *  Add the job `function(opaque)` to thread pool _if_ a queue slot is available.
+ *  Returns immediately even if not (does not block).
+ * @return : 1 if successful, 0 if not.
+ */
+int POOL_tryAdd(POOL_ctx* ctx, POOL_function function, void* opaque);
+
+
+#if defined (__cplusplus)
+}
+#endif
+
+#endif
diff --git a/src/3rdparty/zstd/src/common/portability_macros.h b/src/3rdparty/zstd/src/common/portability_macros.h
new file mode 100644
index 0000000000..8fd6ea82d1
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/portability_macros.h
@@ -0,0 +1,156 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_PORTABILITY_MACROS_H
+#define ZSTD_PORTABILITY_MACROS_H
+
+/**
+ * This header file contains macro definitions to support portability.
+ * This header is shared between C and ASM code, so it MUST only
+ * contain macro definitions. It MUST not contain any C code.
+ *
+ * This header ONLY defines macros to detect platforms/feature support.
+ *
+ */
+
+
+/* compat. with non-clang compilers */
+#ifndef __has_attribute
+  #define __has_attribute(x) 0
+#endif
+
+/* compat. with non-clang compilers */
+#ifndef __has_builtin
+#  define __has_builtin(x) 0
+#endif
+
+/* compat. with non-clang compilers */
+#ifndef __has_feature
+#  define __has_feature(x) 0
+#endif
+
+/* detects whether we are being compiled under msan */
+#ifndef ZSTD_MEMORY_SANITIZER
+#  if __has_feature(memory_sanitizer)
+#    define ZSTD_MEMORY_SANITIZER 1
+#  else
+#    define ZSTD_MEMORY_SANITIZER 0
+#  endif
+#endif
+
+/* detects whether we are being compiled under asan */
+#ifndef ZSTD_ADDRESS_SANITIZER
+#  if __has_feature(address_sanitizer)
+#    define ZSTD_ADDRESS_SANITIZER 1
+#  elif defined(__SANITIZE_ADDRESS__)
+#    define ZSTD_ADDRESS_SANITIZER 1
+#  else
+#    define ZSTD_ADDRESS_SANITIZER 0
+#  endif
+#endif
+
+/* detects whether we are being compiled under dfsan */
+#ifndef ZSTD_DATAFLOW_SANITIZER
+# if __has_feature(dataflow_sanitizer)
+#  define ZSTD_DATAFLOW_SANITIZER 1
+# else
+#  define ZSTD_DATAFLOW_SANITIZER 0
+# endif
+#endif
+
+/* Mark the internal assembly functions as hidden  */
+#ifdef __ELF__
+# define ZSTD_HIDE_ASM_FUNCTION(func) .hidden func
+#else
+# define ZSTD_HIDE_ASM_FUNCTION(func)
+#endif
+
+/* Enable runtime BMI2 dispatch based on the CPU.
+ * Enabled for clang & gcc >=4.8 on x86 when BMI2 isn't enabled by default.
+ */
+#ifndef DYNAMIC_BMI2
+  #if ((defined(__clang__) && __has_attribute(__target__)) \
+      || (defined(__GNUC__) \
+          && (__GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)))) \
+      && (defined(__x86_64__) || defined(_M_X64)) \
+      && !defined(__BMI2__)
+  #  define DYNAMIC_BMI2 1
+  #else
+  #  define DYNAMIC_BMI2 0
+  #endif
+#endif
+
+/**
+ * Only enable assembly for GNUC compatible compilers,
+ * because other platforms may not support GAS assembly syntax.
+ *
+ * Only enable assembly for Linux / MacOS, other platforms may
+ * work, but they haven't been tested. This could likely be
+ * extended to BSD systems.
+ *
+ * Disable assembly when MSAN is enabled, because MSAN requires
+ * 100% of code to be instrumented to work.
+ */
+#if defined(__GNUC__)
+#  if defined(__linux__) || defined(__linux) || defined(__APPLE__)
+#    if ZSTD_MEMORY_SANITIZER
+#      define ZSTD_ASM_SUPPORTED 0
+#    elif ZSTD_DATAFLOW_SANITIZER
+#      define ZSTD_ASM_SUPPORTED 0
+#    else
+#      define ZSTD_ASM_SUPPORTED 1
+#    endif
+#  else
+#    define ZSTD_ASM_SUPPORTED 0
+#  endif
+#else
+#  define ZSTD_ASM_SUPPORTED 0
+#endif
+
+/**
+ * Determines whether we should enable assembly for x86-64
+ * with BMI2.
+ *
+ * Enable if all of the following conditions hold:
+ * - ASM hasn't been explicitly disabled by defining ZSTD_DISABLE_ASM
+ * - Assembly is supported
+ * - We are compiling for x86-64 and either:
+ *   - DYNAMIC_BMI2 is enabled
+ *   - BMI2 is supported at compile time
+ */
+#if !defined(ZSTD_DISABLE_ASM) &&                                 \
+    ZSTD_ASM_SUPPORTED &&                                         \
+    defined(__x86_64__) &&                                        \
+    (DYNAMIC_BMI2 || defined(__BMI2__))
+# define ZSTD_ENABLE_ASM_X86_64_BMI2 1
+#else
+# define ZSTD_ENABLE_ASM_X86_64_BMI2 0
+#endif
+
+/*
+ * For x86 ELF targets, add .note.gnu.property section for Intel CET in
+ * assembly sources when CET is enabled.
+ *
+ * Additionally, any function that may be called indirectly must begin
+ * with ZSTD_CET_ENDBRANCH.
+ */
+#if defined(__ELF__) && (defined(__x86_64__) || defined(__i386__)) \
+    && defined(__has_include)
+# if __has_include(<cet.h>)
+#  include <cet.h>
+#  define ZSTD_CET_ENDBRANCH _CET_ENDBR
+# endif
+#endif
+
+#ifndef ZSTD_CET_ENDBRANCH
+# define ZSTD_CET_ENDBRANCH
+#endif
+
+#endif /* ZSTD_PORTABILITY_MACROS_H */
diff --git a/src/3rdparty/zstd/src/common/threading.c b/src/3rdparty/zstd/src/common/threading.c
new file mode 100644
index 0000000000..ca155b9b9d
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/threading.c
@@ -0,0 +1,176 @@
+/**
+ * Copyright (c) 2016 Tino Reichardt
+ * All rights reserved.
+ *
+ * You can contact the author at:
+ * - zstdmt source repository: https://github.com/mcmilk/zstdmt
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+/**
+ * This file will hold wrapper for systems, which do not support pthreads
+ */
+
+#include "threading.h"
+
+/* create fake symbol to avoid empty translation unit warning */
+int g_ZSTD_threading_useless_symbol;
+
+#if defined(ZSTD_MULTITHREAD) && defined(_WIN32)
+
+/**
+ * Windows minimalist Pthread Wrapper
+ */
+
+
+/* ===  Dependencies  === */
+#include <process.h>
+#include <errno.h>
+
+
+/* ===  Implementation  === */
+
+typedef struct {
+    void* (*start_routine)(void*);
+    void* arg;
+    int initialized;
+    ZSTD_pthread_cond_t initialized_cond;
+    ZSTD_pthread_mutex_t initialized_mutex;
+} ZSTD_thread_params_t;
+
+static unsigned __stdcall worker(void *arg)
+{
+    void* (*start_routine)(void*);
+    void* thread_arg;
+
+    /* Initialized thread_arg and start_routine and signal main thread that we don't need it
+     * to wait any longer.
+     */
+    {
+        ZSTD_thread_params_t*  thread_param = (ZSTD_thread_params_t*)arg;
+        thread_arg = thread_param->arg;
+        start_routine = thread_param->start_routine;
+
+        /* Signal main thread that we are running and do not depend on its memory anymore */
+        ZSTD_pthread_mutex_lock(&thread_param->initialized_mutex);
+        thread_param->initialized = 1;
+        ZSTD_pthread_cond_signal(&thread_param->initialized_cond);
+        ZSTD_pthread_mutex_unlock(&thread_param->initialized_mutex);
+    }
+
+    start_routine(thread_arg);
+
+    return 0;
+}
+
+int ZSTD_pthread_create(ZSTD_pthread_t* thread, const void* unused,
+            void* (*start_routine) (void*), void* arg)
+{
+    ZSTD_thread_params_t thread_param;
+    (void)unused;
+
+    thread_param.start_routine = start_routine;
+    thread_param.arg = arg;
+    thread_param.initialized = 0;
+    *thread = NULL;
+
+    /* Setup thread initialization synchronization */
+    if(ZSTD_pthread_cond_init(&thread_param.initialized_cond, NULL)) {
+        /* Should never happen on Windows */
+        return -1;
+    }
+    if(ZSTD_pthread_mutex_init(&thread_param.initialized_mutex, NULL)) {
+        /* Should never happen on Windows */
+        ZSTD_pthread_cond_destroy(&thread_param.initialized_cond);
+        return -1;
+    }
+
+    /* Spawn thread */
+    *thread = (HANDLE)_beginthreadex(NULL, 0, worker, &thread_param, 0, NULL);
+    if (!thread) {
+        ZSTD_pthread_mutex_destroy(&thread_param.initialized_mutex);
+        ZSTD_pthread_cond_destroy(&thread_param.initialized_cond);
+        return errno;
+    }
+
+    /* Wait for thread to be initialized */
+    ZSTD_pthread_mutex_lock(&thread_param.initialized_mutex);
+    while(!thread_param.initialized) {
+        ZSTD_pthread_cond_wait(&thread_param.initialized_cond, &thread_param.initialized_mutex);
+    }
+    ZSTD_pthread_mutex_unlock(&thread_param.initialized_mutex);
+    ZSTD_pthread_mutex_destroy(&thread_param.initialized_mutex);
+    ZSTD_pthread_cond_destroy(&thread_param.initialized_cond);
+
+    return 0;
+}
+
+int ZSTD_pthread_join(ZSTD_pthread_t thread)
+{
+    DWORD result;
+
+    if (!thread) return 0;
+
+    result = WaitForSingleObject(thread, INFINITE);
+    CloseHandle(thread);
+
+    switch (result) {
+    case WAIT_OBJECT_0:
+        return 0;
+    case WAIT_ABANDONED:
+        return EINVAL;
+    default:
+        return GetLastError();
+    }
+}
+
+#endif   /* ZSTD_MULTITHREAD */
+
+#if defined(ZSTD_MULTITHREAD) && DEBUGLEVEL >= 1 && !defined(_WIN32)
+
+#define ZSTD_DEPS_NEED_MALLOC
+#include "zstd_deps.h"
+
+int ZSTD_pthread_mutex_init(ZSTD_pthread_mutex_t* mutex, pthread_mutexattr_t const* attr)
+{
+    *mutex = (pthread_mutex_t*)ZSTD_malloc(sizeof(pthread_mutex_t));
+    if (!*mutex)
+        return 1;
+    return pthread_mutex_init(*mutex, attr);
+}
+
+int ZSTD_pthread_mutex_destroy(ZSTD_pthread_mutex_t* mutex)
+{
+    if (!*mutex)
+        return 0;
+    {
+        int const ret = pthread_mutex_destroy(*mutex);
+        ZSTD_free(*mutex);
+        return ret;
+    }
+}
+
+int ZSTD_pthread_cond_init(ZSTD_pthread_cond_t* cond, pthread_condattr_t const* attr)
+{
+    *cond = (pthread_cond_t*)ZSTD_malloc(sizeof(pthread_cond_t));
+    if (!*cond)
+        return 1;
+    return pthread_cond_init(*cond, attr);
+}
+
+int ZSTD_pthread_cond_destroy(ZSTD_pthread_cond_t* cond)
+{
+    if (!*cond)
+        return 0;
+    {
+        int const ret = pthread_cond_destroy(*cond);
+        ZSTD_free(*cond);
+        return ret;
+    }
+}
+
+#endif
diff --git a/src/3rdparty/zstd/src/common/threading.h b/src/3rdparty/zstd/src/common/threading.h
new file mode 100644
index 0000000000..fb5c1c8787
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/threading.h
@@ -0,0 +1,150 @@
+/**
+ * Copyright (c) 2016 Tino Reichardt
+ * All rights reserved.
+ *
+ * You can contact the author at:
+ * - zstdmt source repository: https://github.com/mcmilk/zstdmt
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef THREADING_H_938743
+#define THREADING_H_938743
+
+#include "debug.h"
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#if defined(ZSTD_MULTITHREAD) && defined(_WIN32)
+
+/**
+ * Windows minimalist Pthread Wrapper
+ */
+#ifdef WINVER
+#  undef WINVER
+#endif
+#define WINVER       0x0600
+
+#ifdef _WIN32_WINNT
+#  undef _WIN32_WINNT
+#endif
+#define _WIN32_WINNT 0x0600
+
+#ifndef WIN32_LEAN_AND_MEAN
+#  define WIN32_LEAN_AND_MEAN
+#endif
+
+#undef ERROR   /* reported already defined on VS 2015 (Rich Geldreich) */
+#include <windows.h>
+#undef ERROR
+#define ERROR(name) ZSTD_ERROR(name)
+
+
+/* mutex */
+#define ZSTD_pthread_mutex_t           CRITICAL_SECTION
+#define ZSTD_pthread_mutex_init(a, b)  ((void)(b), InitializeCriticalSection((a)), 0)
+#define ZSTD_pthread_mutex_destroy(a)  DeleteCriticalSection((a))
+#define ZSTD_pthread_mutex_lock(a)     EnterCriticalSection((a))
+#define ZSTD_pthread_mutex_unlock(a)   LeaveCriticalSection((a))
+
+/* condition variable */
+#define ZSTD_pthread_cond_t             CONDITION_VARIABLE
+#define ZSTD_pthread_cond_init(a, b)    ((void)(b), InitializeConditionVariable((a)), 0)
+#define ZSTD_pthread_cond_destroy(a)    ((void)(a))
+#define ZSTD_pthread_cond_wait(a, b)    SleepConditionVariableCS((a), (b), INFINITE)
+#define ZSTD_pthread_cond_signal(a)     WakeConditionVariable((a))
+#define ZSTD_pthread_cond_broadcast(a)  WakeAllConditionVariable((a))
+
+/* ZSTD_pthread_create() and ZSTD_pthread_join() */
+typedef HANDLE ZSTD_pthread_t;
+
+int ZSTD_pthread_create(ZSTD_pthread_t* thread, const void* unused,
+                   void* (*start_routine) (void*), void* arg);
+
+int ZSTD_pthread_join(ZSTD_pthread_t thread);
+
+/**
+ * add here more wrappers as required
+ */
+
+
+#elif defined(ZSTD_MULTITHREAD)    /* posix assumed ; need a better detection method */
+/* ===   POSIX Systems   === */
+#  include <pthread.h>
+
+#if DEBUGLEVEL < 1
+
+#define ZSTD_pthread_mutex_t            pthread_mutex_t
+#define ZSTD_pthread_mutex_init(a, b)   pthread_mutex_init((a), (b))
+#define ZSTD_pthread_mutex_destroy(a)   pthread_mutex_destroy((a))
+#define ZSTD_pthread_mutex_lock(a)      pthread_mutex_lock((a))
+#define ZSTD_pthread_mutex_unlock(a)    pthread_mutex_unlock((a))
+
+#define ZSTD_pthread_cond_t             pthread_cond_t
+#define ZSTD_pthread_cond_init(a, b)    pthread_cond_init((a), (b))
+#define ZSTD_pthread_cond_destroy(a)    pthread_cond_destroy((a))
+#define ZSTD_pthread_cond_wait(a, b)    pthread_cond_wait((a), (b))
+#define ZSTD_pthread_cond_signal(a)     pthread_cond_signal((a))
+#define ZSTD_pthread_cond_broadcast(a)  pthread_cond_broadcast((a))
+
+#define ZSTD_pthread_t                  pthread_t
+#define ZSTD_pthread_create(a, b, c, d) pthread_create((a), (b), (c), (d))
+#define ZSTD_pthread_join(a)         pthread_join((a),NULL)
+
+#else /* DEBUGLEVEL >= 1 */
+
+/* Debug implementation of threading.
+ * In this implementation we use pointers for mutexes and condition variables.
+ * This way, if we forget to init/destroy them the program will crash or ASAN
+ * will report leaks.
+ */
+
+#define ZSTD_pthread_mutex_t            pthread_mutex_t*
+int ZSTD_pthread_mutex_init(ZSTD_pthread_mutex_t* mutex, pthread_mutexattr_t const* attr);
+int ZSTD_pthread_mutex_destroy(ZSTD_pthread_mutex_t* mutex);
+#define ZSTD_pthread_mutex_lock(a)      pthread_mutex_lock(*(a))
+#define ZSTD_pthread_mutex_unlock(a)    pthread_mutex_unlock(*(a))
+
+#define ZSTD_pthread_cond_t             pthread_cond_t*
+int ZSTD_pthread_cond_init(ZSTD_pthread_cond_t* cond, pthread_condattr_t const* attr);
+int ZSTD_pthread_cond_destroy(ZSTD_pthread_cond_t* cond);
+#define ZSTD_pthread_cond_wait(a, b)    pthread_cond_wait(*(a), *(b))
+#define ZSTD_pthread_cond_signal(a)     pthread_cond_signal(*(a))
+#define ZSTD_pthread_cond_broadcast(a)  pthread_cond_broadcast(*(a))
+
+#define ZSTD_pthread_t                  pthread_t
+#define ZSTD_pthread_create(a, b, c, d) pthread_create((a), (b), (c), (d))
+#define ZSTD_pthread_join(a)         pthread_join((a),NULL)
+
+#endif
+
+#else  /* ZSTD_MULTITHREAD not defined */
+/* No multithreading support */
+
+typedef int ZSTD_pthread_mutex_t;
+#define ZSTD_pthread_mutex_init(a, b)   ((void)(a), (void)(b), 0)
+#define ZSTD_pthread_mutex_destroy(a)   ((void)(a))
+#define ZSTD_pthread_mutex_lock(a)      ((void)(a))
+#define ZSTD_pthread_mutex_unlock(a)    ((void)(a))
+
+typedef int ZSTD_pthread_cond_t;
+#define ZSTD_pthread_cond_init(a, b)    ((void)(a), (void)(b), 0)
+#define ZSTD_pthread_cond_destroy(a)    ((void)(a))
+#define ZSTD_pthread_cond_wait(a, b)    ((void)(a), (void)(b))
+#define ZSTD_pthread_cond_signal(a)     ((void)(a))
+#define ZSTD_pthread_cond_broadcast(a)  ((void)(a))
+
+/* do not use ZSTD_pthread_t */
+
+#endif /* ZSTD_MULTITHREAD */
+
+#if defined (__cplusplus)
+}
+#endif
+
+#endif /* THREADING_H_938743 */
diff --git a/src/3rdparty/zstd/src/common/xxhash.c b/src/3rdparty/zstd/src/common/xxhash.c
new file mode 100644
index 0000000000..fd237c9062
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/xxhash.c
@@ -0,0 +1,24 @@
+/*
+ *  xxHash - Fast Hash algorithm
+ *  Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ *  You can contact the author at :
+ *  - xxHash homepage: https://cyan4973.github.io/xxHash/
+ *  - xxHash source repository : https://github.com/Cyan4973/xxHash
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+*/
+
+
+
+/*
+ * xxhash.c instantiates functions defined in xxhash.h
+ */
+
+#define XXH_STATIC_LINKING_ONLY   /* access advanced declarations */
+#define XXH_IMPLEMENTATION   /* access definitions */
+
+#include "xxhash.h"
diff --git a/src/3rdparty/zstd/src/common/xxhash.h b/src/3rdparty/zstd/src/common/xxhash.h
new file mode 100644
index 0000000000..b8b73290bb
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/xxhash.h
@@ -0,0 +1,5686 @@
+/*
+ *  xxHash - Fast Hash algorithm
+ *  Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ *  You can contact the author at :
+ *  - xxHash homepage: https://cyan4973.github.io/xxHash/
+ *  - xxHash source repository : https://github.com/Cyan4973/xxHash
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+*/
+
+
+#ifndef XXH_NO_XXH3
+# define XXH_NO_XXH3
+#endif
+
+#ifndef XXH_NAMESPACE
+# define XXH_NAMESPACE ZSTD_
+#endif
+
+/*!
+ * @mainpage xxHash
+ *
+ * @file xxhash.h
+ * xxHash prototypes and implementation
+ */
+/* TODO: update */
+/* Notice extracted from xxHash homepage:
+
+xxHash is an extremely fast hash algorithm, running at RAM speed limits.
+It also successfully passes all tests from the SMHasher suite.
+
+Comparison (single thread, Windows Seven 32 bits, using SMHasher on a Core 2 Duo @3GHz)
+
+Name            Speed       Q.Score   Author
+xxHash          5.4 GB/s     10
+CrapWow         3.2 GB/s      2       Andrew
+MurmurHash 3a   2.7 GB/s     10       Austin Appleby
+SpookyHash      2.0 GB/s     10       Bob Jenkins
+SBox            1.4 GB/s      9       Bret Mulvey
+Lookup3         1.2 GB/s      9       Bob Jenkins
+SuperFastHash   1.2 GB/s      1       Paul Hsieh
+CityHash64      1.05 GB/s    10       Pike & Alakuijala
+FNV             0.55 GB/s     5       Fowler, Noll, Vo
+CRC32           0.43 GB/s     9
+MD5-32          0.33 GB/s    10       Ronald L. Rivest
+SHA1-32         0.28 GB/s    10
+
+Q.Score is a measure of quality of the hash function.
+It depends on successfully passing SMHasher test set.
+10 is a perfect score.
+
+Note: SMHasher's CRC32 implementation is not the fastest one.
+Other speed-oriented implementations can be faster,
+especially in combination with PCLMUL instruction:
+https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html?showComment=1552696407071#c3490092340461170735
+
+A 64-bit version, named XXH64, is available since r35.
+It offers much better speed, but for 64-bit applications only.
+Name     Speed on 64 bits    Speed on 32 bits
+XXH64       13.8 GB/s            1.9 GB/s
+XXH32        6.8 GB/s            6.0 GB/s
+*/
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+/* ****************************
+ *  INLINE mode
+ ******************************/
+/*!
+ * XXH_INLINE_ALL (and XXH_PRIVATE_API)
+ * Use these build macros to inline xxhash into the target unit.
+ * Inlining improves performance on small inputs, especially when the length is
+ * expressed as a compile-time constant:
+ *
+ *      https://fastcompression.blogspot.com/2018/03/xxhash-for-small-keys-impressive-power.html
+ *
+ * It also keeps xxHash symbols private to the unit, so they are not exported.
+ *
+ * Usage:
+ *     #define XXH_INLINE_ALL
+ *     #include "xxhash.h"
+ *
+ * Do not compile and link xxhash.o as a separate object, as it is not useful.
+ */
+#if (defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)) \
+    && !defined(XXH_INLINE_ALL_31684351384)
+   /* this section should be traversed only once */
+#  define XXH_INLINE_ALL_31684351384
+   /* give access to the advanced API, required to compile implementations */
+#  undef XXH_STATIC_LINKING_ONLY   /* avoid macro redef */
+#  define XXH_STATIC_LINKING_ONLY
+   /* make all functions private */
+#  undef XXH_PUBLIC_API
+#  if defined(__GNUC__)
+#    define XXH_PUBLIC_API static __inline __attribute__((unused))
+#  elif defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */)
+#    define XXH_PUBLIC_API static inline
+#  elif defined(_MSC_VER)
+#    define XXH_PUBLIC_API static __inline
+#  else
+     /* note: this version may generate warnings for unused static functions */
+#    define XXH_PUBLIC_API static
+#  endif
+
+   /*
+    * This part deals with the special case where a unit wants to inline xxHash,
+    * but "xxhash.h" has previously been included without XXH_INLINE_ALL,
+    * such as part of some previously included *.h header file.
+    * Without further action, the new include would just be ignored,
+    * and functions would effectively _not_ be inlined (silent failure).
+    * The following macros solve this situation by prefixing all inlined names,
+    * avoiding naming collision with previous inclusions.
+    */
+   /* Before that, we unconditionally #undef all symbols,
+    * in case they were already defined with XXH_NAMESPACE.
+    * They will then be redefined for XXH_INLINE_ALL
+    */
+#  undef XXH_versionNumber
+    /* XXH32 */
+#  undef XXH32
+#  undef XXH32_createState
+#  undef XXH32_freeState
+#  undef XXH32_reset
+#  undef XXH32_update
+#  undef XXH32_digest
+#  undef XXH32_copyState
+#  undef XXH32_canonicalFromHash
+#  undef XXH32_hashFromCanonical
+    /* XXH64 */
+#  undef XXH64
+#  undef XXH64_createState
+#  undef XXH64_freeState
+#  undef XXH64_reset
+#  undef XXH64_update
+#  undef XXH64_digest
+#  undef XXH64_copyState
+#  undef XXH64_canonicalFromHash
+#  undef XXH64_hashFromCanonical
+    /* XXH3_64bits */
+#  undef XXH3_64bits
+#  undef XXH3_64bits_withSecret
+#  undef XXH3_64bits_withSeed
+#  undef XXH3_64bits_withSecretandSeed
+#  undef XXH3_createState
+#  undef XXH3_freeState
+#  undef XXH3_copyState
+#  undef XXH3_64bits_reset
+#  undef XXH3_64bits_reset_withSeed
+#  undef XXH3_64bits_reset_withSecret
+#  undef XXH3_64bits_update
+#  undef XXH3_64bits_digest
+#  undef XXH3_generateSecret
+    /* XXH3_128bits */
+#  undef XXH128
+#  undef XXH3_128bits
+#  undef XXH3_128bits_withSeed
+#  undef XXH3_128bits_withSecret
+#  undef XXH3_128bits_reset
+#  undef XXH3_128bits_reset_withSeed
+#  undef XXH3_128bits_reset_withSecret
+#  undef XXH3_128bits_reset_withSecretandSeed
+#  undef XXH3_128bits_update
+#  undef XXH3_128bits_digest
+#  undef XXH128_isEqual
+#  undef XXH128_cmp
+#  undef XXH128_canonicalFromHash
+#  undef XXH128_hashFromCanonical
+    /* Finally, free the namespace itself */
+#  undef XXH_NAMESPACE
+
+    /* employ the namespace for XXH_INLINE_ALL */
+#  define XXH_NAMESPACE XXH_INLINE_
+   /*
+    * Some identifiers (enums, type names) are not symbols,
+    * but they must nonetheless be renamed to avoid redeclaration.
+    * Alternative solution: do not redeclare them.
+    * However, this requires some #ifdefs, and has a more dispersed impact.
+    * Meanwhile, renaming can be achieved in a single place.
+    */
+#  define XXH_IPREF(Id)   XXH_NAMESPACE ## Id
+#  define XXH_OK XXH_IPREF(XXH_OK)
+#  define XXH_ERROR XXH_IPREF(XXH_ERROR)
+#  define XXH_errorcode XXH_IPREF(XXH_errorcode)
+#  define XXH32_canonical_t  XXH_IPREF(XXH32_canonical_t)
+#  define XXH64_canonical_t  XXH_IPREF(XXH64_canonical_t)
+#  define XXH128_canonical_t XXH_IPREF(XXH128_canonical_t)
+#  define XXH32_state_s XXH_IPREF(XXH32_state_s)
+#  define XXH32_state_t XXH_IPREF(XXH32_state_t)
+#  define XXH64_state_s XXH_IPREF(XXH64_state_s)
+#  define XXH64_state_t XXH_IPREF(XXH64_state_t)
+#  define XXH3_state_s  XXH_IPREF(XXH3_state_s)
+#  define XXH3_state_t  XXH_IPREF(XXH3_state_t)
+#  define XXH128_hash_t XXH_IPREF(XXH128_hash_t)
+   /* Ensure the header is parsed again, even if it was previously included */
+#  undef XXHASH_H_5627135585666179
+#  undef XXHASH_H_STATIC_13879238742
+#endif /* XXH_INLINE_ALL || XXH_PRIVATE_API */
+
+
+
+/* ****************************************************************
+ *  Stable API
+ *****************************************************************/
+#ifndef XXHASH_H_5627135585666179
+#define XXHASH_H_5627135585666179 1
+
+
+/*!
+ * @defgroup public Public API
+ * Contains details on the public xxHash functions.
+ * @{
+ */
+/* specific declaration modes for Windows */
+#if !defined(XXH_INLINE_ALL) && !defined(XXH_PRIVATE_API)
+#  if defined(WIN32) && defined(_MSC_VER) && (defined(XXH_IMPORT) || defined(XXH_EXPORT))
+#    ifdef XXH_EXPORT
+#      define XXH_PUBLIC_API __declspec(dllexport)
+#    elif XXH_IMPORT
+#      define XXH_PUBLIC_API __declspec(dllimport)
+#    endif
+#  else
+#    define XXH_PUBLIC_API   /* do nothing */
+#  endif
+#endif
+
+#ifdef XXH_DOXYGEN
+/*!
+ * @brief Emulate a namespace by transparently prefixing all symbols.
+ *
+ * If you want to include _and expose_ xxHash functions from within your own
+ * library, but also want to avoid symbol collisions with other libraries which
+ * may also include xxHash, you can use XXH_NAMESPACE to automatically prefix
+ * any public symbol from xxhash library with the value of XXH_NAMESPACE
+ * (therefore, avoid empty or numeric values).
+ *
+ * Note that no change is required within the calling program as long as it
+ * includes `xxhash.h`: Regular symbol names will be automatically translated
+ * by this header.
+ */
+#  define XXH_NAMESPACE /* YOUR NAME HERE */
+#  undef XXH_NAMESPACE
+#endif
+
+#ifdef XXH_NAMESPACE
+#  define XXH_CAT(A,B) A##B
+#  define XXH_NAME2(A,B) XXH_CAT(A,B)
+#  define XXH_versionNumber XXH_NAME2(XXH_NAMESPACE, XXH_versionNumber)
+/* XXH32 */
+#  define XXH32 XXH_NAME2(XXH_NAMESPACE, XXH32)
+#  define XXH32_createState XXH_NAME2(XXH_NAMESPACE, XXH32_createState)
+#  define XXH32_freeState XXH_NAME2(XXH_NAMESPACE, XXH32_freeState)
+#  define XXH32_reset XXH_NAME2(XXH_NAMESPACE, XXH32_reset)
+#  define XXH32_update XXH_NAME2(XXH_NAMESPACE, XXH32_update)
+#  define XXH32_digest XXH_NAME2(XXH_NAMESPACE, XXH32_digest)
+#  define XXH32_copyState XXH_NAME2(XXH_NAMESPACE, XXH32_copyState)
+#  define XXH32_canonicalFromHash XXH_NAME2(XXH_NAMESPACE, XXH32_canonicalFromHash)
+#  define XXH32_hashFromCanonical XXH_NAME2(XXH_NAMESPACE, XXH32_hashFromCanonical)
+/* XXH64 */
+#  define XXH64 XXH_NAME2(XXH_NAMESPACE, XXH64)
+#  define XXH64_createState XXH_NAME2(XXH_NAMESPACE, XXH64_createState)
+#  define XXH64_freeState XXH_NAME2(XXH_NAMESPACE, XXH64_freeState)
+#  define XXH64_reset XXH_NAME2(XXH_NAMESPACE, XXH64_reset)
+#  define XXH64_update XXH_NAME2(XXH_NAMESPACE, XXH64_update)
+#  define XXH64_digest XXH_NAME2(XXH_NAMESPACE, XXH64_digest)
+#  define XXH64_copyState XXH_NAME2(XXH_NAMESPACE, XXH64_copyState)
+#  define XXH64_canonicalFromHash XXH_NAME2(XXH_NAMESPACE, XXH64_canonicalFromHash)
+#  define XXH64_hashFromCanonical XXH_NAME2(XXH_NAMESPACE, XXH64_hashFromCanonical)
+/* XXH3_64bits */
+#  define XXH3_64bits XXH_NAME2(XXH_NAMESPACE, XXH3_64bits)
+#  define XXH3_64bits_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSecret)
+#  define XXH3_64bits_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSeed)
+#  define XXH3_64bits_withSecretandSeed XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSecretandSeed)
+#  define XXH3_createState XXH_NAME2(XXH_NAMESPACE, XXH3_createState)
+#  define XXH3_freeState XXH_NAME2(XXH_NAMESPACE, XXH3_freeState)
+#  define XXH3_copyState XXH_NAME2(XXH_NAMESPACE, XXH3_copyState)
+#  define XXH3_64bits_reset XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset)
+#  define XXH3_64bits_reset_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSeed)
+#  define XXH3_64bits_reset_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSecret)
+#  define XXH3_64bits_reset_withSecretandSeed XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSecretandSeed)
+#  define XXH3_64bits_update XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_update)
+#  define XXH3_64bits_digest XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_digest)
+#  define XXH3_generateSecret XXH_NAME2(XXH_NAMESPACE, XXH3_generateSecret)
+#  define XXH3_generateSecret_fromSeed XXH_NAME2(XXH_NAMESPACE, XXH3_generateSecret_fromSeed)
+/* XXH3_128bits */
+#  define XXH128 XXH_NAME2(XXH_NAMESPACE, XXH128)
+#  define XXH3_128bits XXH_NAME2(XXH_NAMESPACE, XXH3_128bits)
+#  define XXH3_128bits_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSeed)
+#  define XXH3_128bits_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSecret)
+#  define XXH3_128bits_withSecretandSeed XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSecretandSeed)
+#  define XXH3_128bits_reset XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset)
+#  define XXH3_128bits_reset_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSeed)
+#  define XXH3_128bits_reset_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSecret)
+#  define XXH3_128bits_reset_withSecretandSeed XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSecretandSeed)
+#  define XXH3_128bits_update XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_update)
+#  define XXH3_128bits_digest XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_digest)
+#  define XXH128_isEqual XXH_NAME2(XXH_NAMESPACE, XXH128_isEqual)
+#  define XXH128_cmp     XXH_NAME2(XXH_NAMESPACE, XXH128_cmp)
+#  define XXH128_canonicalFromHash XXH_NAME2(XXH_NAMESPACE, XXH128_canonicalFromHash)
+#  define XXH128_hashFromCanonical XXH_NAME2(XXH_NAMESPACE, XXH128_hashFromCanonical)
+#endif
+
+
+/* *************************************
+*  Version
+***************************************/
+#define XXH_VERSION_MAJOR    0
+#define XXH_VERSION_MINOR    8
+#define XXH_VERSION_RELEASE  1
+#define XXH_VERSION_NUMBER  (XXH_VERSION_MAJOR *100*100 + XXH_VERSION_MINOR *100 + XXH_VERSION_RELEASE)
+
+/*!
+ * @brief Obtains the xxHash version.
+ *
+ * This is mostly useful when xxHash is compiled as a shared library,
+ * since the returned value comes from the library, as opposed to header file.
+ *
+ * @return `XXH_VERSION_NUMBER` of the invoked library.
+ */
+XXH_PUBLIC_API unsigned XXH_versionNumber (void);
+
+
+/* ****************************
+*  Common basic types
+******************************/
+#include <stddef.h>   /* size_t */
+typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;
+
+
+/*-**********************************************************************
+*  32-bit hash
+************************************************************************/
+#if defined(XXH_DOXYGEN) /* Don't show <stdint.h> include */
+/*!
+ * @brief An unsigned 32-bit integer.
+ *
+ * Not necessarily defined to `uint32_t` but functionally equivalent.
+ */
+typedef uint32_t XXH32_hash_t;
+
+#elif !defined (__VMS) \
+  && (defined (__cplusplus) \
+  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
+#   include <stdint.h>
+    typedef uint32_t XXH32_hash_t;
+
+#else
+#   include <limits.h>
+#   if UINT_MAX == 0xFFFFFFFFUL
+      typedef unsigned int XXH32_hash_t;
+#   else
+#     if ULONG_MAX == 0xFFFFFFFFUL
+        typedef unsigned long XXH32_hash_t;
+#     else
+#       error "unsupported platform: need a 32-bit type"
+#     endif
+#   endif
+#endif
+
+/*!
+ * @}
+ *
+ * @defgroup xxh32_family XXH32 family
+ * @ingroup public
+ * Contains functions used in the classic 32-bit xxHash algorithm.
+ *
+ * @note
+ *   XXH32 is useful for older platforms, with no or poor 64-bit performance.
+ *   Note that @ref xxh3_family provides competitive speed
+ *   for both 32-bit and 64-bit systems, and offers true 64/128 bit hash results.
+ *
+ * @see @ref xxh64_family, @ref xxh3_family : Other xxHash families
+ * @see @ref xxh32_impl for implementation details
+ * @{
+ */
+
+/*!
+ * @brief Calculates the 32-bit hash of @p input using xxHash32.
+ *
+ * Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark): 5.4 GB/s
+ *
+ * @param input The block of data to be hashed, at least @p length bytes in size.
+ * @param length The length of @p input, in bytes.
+ * @param seed The 32-bit seed to alter the hash's output predictably.
+ *
+ * @pre
+ *   The memory between @p input and @p input + @p length must be valid,
+ *   readable, contiguous memory. However, if @p length is `0`, @p input may be
+ *   `NULL`. In C++, this also must be *TriviallyCopyable*.
+ *
+ * @return The calculated 32-bit hash value.
+ *
+ * @see
+ *    XXH64(), XXH3_64bits_withSeed(), XXH3_128bits_withSeed(), XXH128():
+ *    Direct equivalents for the other variants of xxHash.
+ * @see
+ *    XXH32_createState(), XXH32_update(), XXH32_digest(): Streaming version.
+ */
+XXH_PUBLIC_API XXH32_hash_t XXH32 (const void* input, size_t length, XXH32_hash_t seed);
+
+/*!
+ * Streaming functions generate the xxHash value from an incremental input.
+ * This method is slower than single-call functions, due to state management.
+ * For small inputs, prefer `XXH32()` and `XXH64()`, which are better optimized.
+ *
+ * An XXH state must first be allocated using `XXH*_createState()`.
+ *
+ * Start a new hash by initializing the state with a seed using `XXH*_reset()`.
+ *
+ * Then, feed the hash state by calling `XXH*_update()` as many times as necessary.
+ *
+ * The function returns an error code, with 0 meaning OK, and any other value
+ * meaning there is an error.
+ *
+ * Finally, a hash value can be produced anytime, by using `XXH*_digest()`.
+ * This function returns the nn-bits hash as an int or long long.
+ *
+ * It's still possible to continue inserting input into the hash state after a
+ * digest, and generate new hash values later on by invoking `XXH*_digest()`.
+ *
+ * When done, release the state using `XXH*_freeState()`.
+ *
+ * Example code for incrementally hashing a file:
+ * @code{.c}
+ *    #include <stdio.h>
+ *    #include <xxhash.h>
+ *    #define BUFFER_SIZE 256
+ *
+ *    // Note: XXH64 and XXH3 use the same interface.
+ *    XXH32_hash_t
+ *    hashFile(FILE* stream)
+ *    {
+ *        XXH32_state_t* state;
+ *        unsigned char buf[BUFFER_SIZE];
+ *        size_t amt;
+ *        XXH32_hash_t hash;
+ *
+ *        state = XXH32_createState();       // Create a state
+ *        assert(state != NULL);             // Error check here
+ *        XXH32_reset(state, 0xbaad5eed);    // Reset state with our seed
+ *        while ((amt = fread(buf, 1, sizeof(buf), stream)) != 0) {
+ *            XXH32_update(state, buf, amt); // Hash the file in chunks
+ *        }
+ *        hash = XXH32_digest(state);        // Finalize the hash
+ *        XXH32_freeState(state);            // Clean up
+ *        return hash;
+ *    }
+ * @endcode
+ */
+
+/*!
+ * @typedef struct XXH32_state_s XXH32_state_t
+ * @brief The opaque state struct for the XXH32 streaming API.
+ *
+ * @see XXH32_state_s for details.
+ */
+typedef struct XXH32_state_s XXH32_state_t;
+
+/*!
+ * @brief Allocates an @ref XXH32_state_t.
+ *
+ * Must be freed with XXH32_freeState().
+ * @return An allocated XXH32_state_t on success, `NULL` on failure.
+ */
+XXH_PUBLIC_API XXH32_state_t* XXH32_createState(void);
+/*!
+ * @brief Frees an @ref XXH32_state_t.
+ *
+ * Must be allocated with XXH32_createState().
+ * @param statePtr A pointer to an @ref XXH32_state_t allocated with @ref XXH32_createState().
+ * @return XXH_OK.
+ */
+XXH_PUBLIC_API XXH_errorcode  XXH32_freeState(XXH32_state_t* statePtr);
+/*!
+ * @brief Copies one @ref XXH32_state_t to another.
+ *
+ * @param dst_state The state to copy to.
+ * @param src_state The state to copy from.
+ * @pre
+ *   @p dst_state and @p src_state must not be `NULL` and must not overlap.
+ */
+XXH_PUBLIC_API void XXH32_copyState(XXH32_state_t* dst_state, const XXH32_state_t* src_state);
+
+/*!
+ * @brief Resets an @ref XXH32_state_t to begin a new hash.
+ *
+ * This function resets and seeds a state. Call it before @ref XXH32_update().
+ *
+ * @param statePtr The state struct to reset.
+ * @param seed The 32-bit seed to alter the hash result predictably.
+ *
+ * @pre
+ *   @p statePtr must not be `NULL`.
+ *
+ * @return @ref XXH_OK on success, @ref XXH_ERROR on failure.
+ */
+XXH_PUBLIC_API XXH_errorcode XXH32_reset  (XXH32_state_t* statePtr, XXH32_hash_t seed);
+
+/*!
+ * @brief Consumes a block of @p input to an @ref XXH32_state_t.
+ *
+ * Call this to incrementally consume blocks of data.
+ *
+ * @param statePtr The state struct to update.
+ * @param input The block of data to be hashed, at least @p length bytes in size.
+ * @param length The length of @p input, in bytes.
+ *
+ * @pre
+ *   @p statePtr must not be `NULL`.
+ * @pre
+ *   The memory between @p input and @p input + @p length must be valid,
+ *   readable, contiguous memory. However, if @p length is `0`, @p input may be
+ *   `NULL`. In C++, this also must be *TriviallyCopyable*.
+ *
+ * @return @ref XXH_OK on success, @ref XXH_ERROR on failure.
+ */
+XXH_PUBLIC_API XXH_errorcode XXH32_update (XXH32_state_t* statePtr, const void* input, size_t length);
+
+/*!
+ * @brief Returns the calculated hash value from an @ref XXH32_state_t.
+ *
+ * @note
+ *   Calling XXH32_digest() will not affect @p statePtr, so you can update,
+ *   digest, and update again.
+ *
+ * @param statePtr The state struct to calculate the hash from.
+ *
+ * @pre
+ *  @p statePtr must not be `NULL`.
+ *
+ * @return The calculated xxHash32 value from that state.
+ */
+XXH_PUBLIC_API XXH32_hash_t  XXH32_digest (const XXH32_state_t* statePtr);
+
+/*******   Canonical representation   *******/
+
+/*
+ * The default return values from XXH functions are unsigned 32 and 64 bit
+ * integers.
+ * This the simplest and fastest format for further post-processing.
+ *
+ * However, this leaves open the question of what is the order on the byte level,
+ * since little and big endian conventions will store the same number differently.
+ *
+ * The canonical representation settles this issue by mandating big-endian
+ * convention, the same convention as human-readable numbers (large digits first).
+ *
+ * When writing hash values to storage, sending them over a network, or printing
+ * them, it's highly recommended to use the canonical representation to ensure
+ * portability across a wider range of systems, present and future.
+ *
+ * The following functions allow transformation of hash values to and from
+ * canonical format.
+ */
+
+/*!
+ * @brief Canonical (big endian) representation of @ref XXH32_hash_t.
+ */
+typedef struct {
+    unsigned char digest[4]; /*!< Hash bytes, big endian */
+} XXH32_canonical_t;
+
+/*!
+ * @brief Converts an @ref XXH32_hash_t to a big endian @ref XXH32_canonical_t.
+ *
+ * @param dst The @ref XXH32_canonical_t pointer to be stored to.
+ * @param hash The @ref XXH32_hash_t to be converted.
+ *
+ * @pre
+ *   @p dst must not be `NULL`.
+ */
+XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash);
+
+/*!
+ * @brief Converts an @ref XXH32_canonical_t to a native @ref XXH32_hash_t.
+ *
+ * @param src The @ref XXH32_canonical_t to convert.
+ *
+ * @pre
+ *   @p src must not be `NULL`.
+ *
+ * @return The converted hash.
+ */
+XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src);
+
+
+#ifdef __has_attribute
+# define XXH_HAS_ATTRIBUTE(x) __has_attribute(x)
+#else
+# define XXH_HAS_ATTRIBUTE(x) 0
+#endif
+
+/* C-language Attributes are added in C23. */
+#if defined(__STDC_VERSION__) && (__STDC_VERSION__ > 201710L) && defined(__has_c_attribute)
+# define XXH_HAS_C_ATTRIBUTE(x) __has_c_attribute(x)
+#else
+# define XXH_HAS_C_ATTRIBUTE(x) 0
+#endif
+
+#if defined(__cplusplus) && defined(__has_cpp_attribute)
+# define XXH_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)
+#else
+# define XXH_HAS_CPP_ATTRIBUTE(x) 0
+#endif
+
+/*
+Define XXH_FALLTHROUGH macro for annotating switch case with the 'fallthrough' attribute
+introduced in CPP17 and C23.
+CPP17 : https://en.cppreference.com/w/cpp/language/attributes/fallthrough
+C23   : https://en.cppreference.com/w/c/language/attributes/fallthrough
+*/
+#if XXH_HAS_C_ATTRIBUTE(x)
+# define XXH_FALLTHROUGH [[fallthrough]]
+#elif XXH_HAS_CPP_ATTRIBUTE(x)
+# define XXH_FALLTHROUGH [[fallthrough]]
+#elif XXH_HAS_ATTRIBUTE(__fallthrough__)
+# define XXH_FALLTHROUGH __attribute__ ((fallthrough))
+#else
+# define XXH_FALLTHROUGH
+#endif
+
+/*!
+ * @}
+ * @ingroup public
+ * @{
+ */
+
+#ifndef XXH_NO_LONG_LONG
+/*-**********************************************************************
+*  64-bit hash
+************************************************************************/
+#if defined(XXH_DOXYGEN) /* don't include <stdint.h> */
+/*!
+ * @brief An unsigned 64-bit integer.
+ *
+ * Not necessarily defined to `uint64_t` but functionally equivalent.
+ */
+typedef uint64_t XXH64_hash_t;
+#elif !defined (__VMS) \
+  && (defined (__cplusplus) \
+  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
+#  include <stdint.h>
+   typedef uint64_t XXH64_hash_t;
+#else
+#  include <limits.h>
+#  if defined(__LP64__) && ULONG_MAX == 0xFFFFFFFFFFFFFFFFULL
+     /* LP64 ABI says uint64_t is unsigned long */
+     typedef unsigned long XXH64_hash_t;
+#  else
+     /* the following type must have a width of 64-bit */
+     typedef unsigned long long XXH64_hash_t;
+#  endif
+#endif
+
+/*!
+ * @}
+ *
+ * @defgroup xxh64_family XXH64 family
+ * @ingroup public
+ * @{
+ * Contains functions used in the classic 64-bit xxHash algorithm.
+ *
+ * @note
+ *   XXH3 provides competitive speed for both 32-bit and 64-bit systems,
+ *   and offers true 64/128 bit hash results.
+ *   It provides better speed for systems with vector processing capabilities.
+ */
+
+
+/*!
+ * @brief Calculates the 64-bit hash of @p input using xxHash64.
+ *
+ * This function usually runs faster on 64-bit systems, but slower on 32-bit
+ * systems (see benchmark).
+ *
+ * @param input The block of data to be hashed, at least @p length bytes in size.
+ * @param length The length of @p input, in bytes.
+ * @param seed The 64-bit seed to alter the hash's output predictably.
+ *
+ * @pre
+ *   The memory between @p input and @p input + @p length must be valid,
+ *   readable, contiguous memory. However, if @p length is `0`, @p input may be
+ *   `NULL`. In C++, this also must be *TriviallyCopyable*.
+ *
+ * @return The calculated 64-bit hash.
+ *
+ * @see
+ *    XXH32(), XXH3_64bits_withSeed(), XXH3_128bits_withSeed(), XXH128():
+ *    Direct equivalents for the other variants of xxHash.
+ * @see
+ *    XXH64_createState(), XXH64_update(), XXH64_digest(): Streaming version.
+ */
+XXH_PUBLIC_API XXH64_hash_t XXH64(const void* input, size_t length, XXH64_hash_t seed);
+
+/*******   Streaming   *******/
+/*!
+ * @brief The opaque state struct for the XXH64 streaming API.
+ *
+ * @see XXH64_state_s for details.
+ */
+typedef struct XXH64_state_s XXH64_state_t;   /* incomplete type */
+XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void);
+XXH_PUBLIC_API XXH_errorcode  XXH64_freeState(XXH64_state_t* statePtr);
+XXH_PUBLIC_API void XXH64_copyState(XXH64_state_t* dst_state, const XXH64_state_t* src_state);
+
+XXH_PUBLIC_API XXH_errorcode XXH64_reset  (XXH64_state_t* statePtr, XXH64_hash_t seed);
+XXH_PUBLIC_API XXH_errorcode XXH64_update (XXH64_state_t* statePtr, const void* input, size_t length);
+XXH_PUBLIC_API XXH64_hash_t  XXH64_digest (const XXH64_state_t* statePtr);
+
+/*******   Canonical representation   *******/
+typedef struct { unsigned char digest[sizeof(XXH64_hash_t)]; } XXH64_canonical_t;
+XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash);
+XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src);
+
+#ifndef XXH_NO_XXH3
+/*!
+ * @}
+ * ************************************************************************
+ * @defgroup xxh3_family XXH3 family
+ * @ingroup public
+ * @{
+ *
+ * XXH3 is a more recent hash algorithm featuring:
+ *  - Improved speed for both small and large inputs
+ *  - True 64-bit and 128-bit outputs
+ *  - SIMD acceleration
+ *  - Improved 32-bit viability
+ *
+ * Speed analysis methodology is explained here:
+ *
+ *    https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html
+ *
+ * Compared to XXH64, expect XXH3 to run approximately
+ * ~2x faster on large inputs and >3x faster on small ones,
+ * exact differences vary depending on platform.
+ *
+ * XXH3's speed benefits greatly from SIMD and 64-bit arithmetic,
+ * but does not require it.
+ * Any 32-bit and 64-bit targets that can run XXH32 smoothly
+ * can run XXH3 at competitive speeds, even without vector support.
+ * Further details are explained in the implementation.
+ *
+ * Optimized implementations are provided for AVX512, AVX2, SSE2, NEON, POWER8,
+ * ZVector and scalar targets. This can be controlled via the XXH_VECTOR macro.
+ *
+ * XXH3 implementation is portable:
+ * it has a generic C90 formulation that can be compiled on any platform,
+ * all implementations generage exactly the same hash value on all platforms.
+ * Starting from v0.8.0, it's also labelled "stable", meaning that
+ * any future version will also generate the same hash value.
+ *
+ * XXH3 offers 2 variants, _64bits and _128bits.
+ *
+ * When only 64 bits are needed, prefer invoking the _64bits variant, as it
+ * reduces the amount of mixing, resulting in faster speed on small inputs.
+ * It's also generally simpler to manipulate a scalar return type than a struct.
+ *
+ * The API supports one-shot hashing, streaming mode, and custom secrets.
+ */
+
+/*-**********************************************************************
+*  XXH3 64-bit variant
+************************************************************************/
+
+/* XXH3_64bits():
+ * default 64-bit variant, using default secret and default seed of 0.
+ * It's the fastest variant. */
+XXH_PUBLIC_API XXH64_hash_t XXH3_64bits(const void* data, size_t len);
+
+/*
+ * XXH3_64bits_withSeed():
+ * This variant generates a custom secret on the fly
+ * based on default secret altered using the `seed` value.
+ * While this operation is decently fast, note that it's not completely free.
+ * Note: seed==0 produces the same results as XXH3_64bits().
+ */
+XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_withSeed(const void* data, size_t len, XXH64_hash_t seed);
+
+/*!
+ * The bare minimum size for a custom secret.
+ *
+ * @see
+ *  XXH3_64bits_withSecret(), XXH3_64bits_reset_withSecret(),
+ *  XXH3_128bits_withSecret(), XXH3_128bits_reset_withSecret().
+ */
+#define XXH3_SECRET_SIZE_MIN 136
+
+/*
+ * XXH3_64bits_withSecret():
+ * It's possible to provide any blob of bytes as a "secret" to generate the hash.
+ * This makes it more difficult for an external actor to prepare an intentional collision.
+ * The main condition is that secretSize *must* be large enough (>= XXH3_SECRET_SIZE_MIN).
+ * However, the quality of the secret impacts the dispersion of the hash algorithm.
+ * Therefore, the secret _must_ look like a bunch of random bytes.
+ * Avoid "trivial" or structured data such as repeated sequences or a text document.
+ * Whenever in doubt about the "randomness" of the blob of bytes,
+ * consider employing "XXH3_generateSecret()" instead (see below).
+ * It will generate a proper high entropy secret derived from the blob of bytes.
+ * Another advantage of using XXH3_generateSecret() is that
+ * it guarantees that all bits within the initial blob of bytes
+ * will impact every bit of the output.
+ * This is not necessarily the case when using the blob of bytes directly
+ * because, when hashing _small_ inputs, only a portion of the secret is employed.
+ */
+XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);
+
+
+/*******   Streaming   *******/
+/*
+ * Streaming requires state maintenance.
+ * This operation costs memory and CPU.
+ * As a consequence, streaming is slower than one-shot hashing.
+ * For better performance, prefer one-shot functions whenever applicable.
+ */
+
+/*!
+ * @brief The state struct for the XXH3 streaming API.
+ *
+ * @see XXH3_state_s for details.
+ */
+typedef struct XXH3_state_s XXH3_state_t;
+XXH_PUBLIC_API XXH3_state_t* XXH3_createState(void);
+XXH_PUBLIC_API XXH_errorcode XXH3_freeState(XXH3_state_t* statePtr);
+XXH_PUBLIC_API void XXH3_copyState(XXH3_state_t* dst_state, const XXH3_state_t* src_state);
+
+/*
+ * XXH3_64bits_reset():
+ * Initialize with default parameters.
+ * digest will be equivalent to `XXH3_64bits()`.
+ */
+XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset(XXH3_state_t* statePtr);
+/*
+ * XXH3_64bits_reset_withSeed():
+ * Generate a custom secret from `seed`, and store it into `statePtr`.
+ * digest will be equivalent to `XXH3_64bits_withSeed()`.
+ */
+XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);
+/*
+ * XXH3_64bits_reset_withSecret():
+ * `secret` is referenced, it _must outlive_ the hash streaming session.
+ * Similar to one-shot API, `secretSize` must be >= `XXH3_SECRET_SIZE_MIN`,
+ * and the quality of produced hash values depends on secret's entropy
+ * (secret's content should look like a bunch of random bytes).
+ * When in doubt about the randomness of a candidate `secret`,
+ * consider employing `XXH3_generateSecret()` instead (see below).
+ */
+XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);
+
+XXH_PUBLIC_API XXH_errorcode XXH3_64bits_update (XXH3_state_t* statePtr, const void* input, size_t length);
+XXH_PUBLIC_API XXH64_hash_t  XXH3_64bits_digest (const XXH3_state_t* statePtr);
+
+/* note : canonical representation of XXH3 is the same as XXH64
+ * since they both produce XXH64_hash_t values */
+
+
+/*-**********************************************************************
+*  XXH3 128-bit variant
+************************************************************************/
+
+/*!
+ * @brief The return value from 128-bit hashes.
+ *
+ * Stored in little endian order, although the fields themselves are in native
+ * endianness.
+ */
+typedef struct {
+    XXH64_hash_t low64;   /*!< `value & 0xFFFFFFFFFFFFFFFF` */
+    XXH64_hash_t high64;  /*!< `value >> 64` */
+} XXH128_hash_t;
+
+XXH_PUBLIC_API XXH128_hash_t XXH3_128bits(const void* data, size_t len);
+XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_withSeed(const void* data, size_t len, XXH64_hash_t seed);
+XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);
+
+/*******   Streaming   *******/
+/*
+ * Streaming requires state maintenance.
+ * This operation costs memory and CPU.
+ * As a consequence, streaming is slower than one-shot hashing.
+ * For better performance, prefer one-shot functions whenever applicable.
+ *
+ * XXH3_128bits uses the same XXH3_state_t as XXH3_64bits().
+ * Use already declared XXH3_createState() and XXH3_freeState().
+ *
+ * All reset and streaming functions have same meaning as their 64-bit counterpart.
+ */
+
+XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset(XXH3_state_t* statePtr);
+XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);
+XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);
+
+XXH_PUBLIC_API XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const void* input, size_t length);
+XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_digest (const XXH3_state_t* statePtr);
+
+/* Following helper functions make it possible to compare XXH128_hast_t values.
+ * Since XXH128_hash_t is a structure, this capability is not offered by the language.
+ * Note: For better performance, these functions can be inlined using XXH_INLINE_ALL */
+
+/*!
+ * XXH128_isEqual():
+ * Return: 1 if `h1` and `h2` are equal, 0 if they are not.
+ */
+XXH_PUBLIC_API int XXH128_isEqual(XXH128_hash_t h1, XXH128_hash_t h2);
+
+/*!
+ * XXH128_cmp():
+ *
+ * This comparator is compatible with stdlib's `qsort()`/`bsearch()`.
+ *
+ * return: >0 if *h128_1  > *h128_2
+ *         =0 if *h128_1 == *h128_2
+ *         <0 if *h128_1  < *h128_2
+ */
+XXH_PUBLIC_API int XXH128_cmp(const void* h128_1, const void* h128_2);
+
+
+/*******   Canonical representation   *******/
+typedef struct { unsigned char digest[sizeof(XXH128_hash_t)]; } XXH128_canonical_t;
+XXH_PUBLIC_API void XXH128_canonicalFromHash(XXH128_canonical_t* dst, XXH128_hash_t hash);
+XXH_PUBLIC_API XXH128_hash_t XXH128_hashFromCanonical(const XXH128_canonical_t* src);
+
+
+#endif  /* !XXH_NO_XXH3 */
+#endif  /* XXH_NO_LONG_LONG */
+
+/*!
+ * @}
+ */
+#endif /* XXHASH_H_5627135585666179 */
+
+
+
+#if defined(XXH_STATIC_LINKING_ONLY) && !defined(XXHASH_H_STATIC_13879238742)
+#define XXHASH_H_STATIC_13879238742
+/* ****************************************************************************
+ * This section contains declarations which are not guaranteed to remain stable.
+ * They may change in future versions, becoming incompatible with a different
+ * version of the library.
+ * These declarations should only be used with static linking.
+ * Never use them in association with dynamic linking!
+ ***************************************************************************** */
+
+/*
+ * These definitions are only present to allow static allocation
+ * of XXH states, on stack or in a struct, for example.
+ * Never **ever** access their members directly.
+ */
+
+/*!
+ * @internal
+ * @brief Structure for XXH32 streaming API.
+ *
+ * @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,
+ * @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined. Otherwise it is
+ * an opaque type. This allows fields to safely be changed.
+ *
+ * Typedef'd to @ref XXH32_state_t.
+ * Do not access the members of this struct directly.
+ * @see XXH64_state_s, XXH3_state_s
+ */
+struct XXH32_state_s {
+   XXH32_hash_t total_len_32; /*!< Total length hashed, modulo 2^32 */
+   XXH32_hash_t large_len;    /*!< Whether the hash is >= 16 (handles @ref total_len_32 overflow) */
+   XXH32_hash_t v[4];         /*!< Accumulator lanes */
+   XXH32_hash_t mem32[4];     /*!< Internal buffer for partial reads. Treated as unsigned char[16]. */
+   XXH32_hash_t memsize;      /*!< Amount of data in @ref mem32 */
+   XXH32_hash_t reserved;     /*!< Reserved field. Do not read nor write to it. */
+};   /* typedef'd to XXH32_state_t */
+
+
+#ifndef XXH_NO_LONG_LONG  /* defined when there is no 64-bit support */
+
+/*!
+ * @internal
+ * @brief Structure for XXH64 streaming API.
+ *
+ * @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,
+ * @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined. Otherwise it is
+ * an opaque type. This allows fields to safely be changed.
+ *
+ * Typedef'd to @ref XXH64_state_t.
+ * Do not access the members of this struct directly.
+ * @see XXH32_state_s, XXH3_state_s
+ */
+struct XXH64_state_s {
+   XXH64_hash_t total_len;    /*!< Total length hashed. This is always 64-bit. */
+   XXH64_hash_t v[4];         /*!< Accumulator lanes */
+   XXH64_hash_t mem64[4];     /*!< Internal buffer for partial reads. Treated as unsigned char[32]. */
+   XXH32_hash_t memsize;      /*!< Amount of data in @ref mem64 */
+   XXH32_hash_t reserved32;   /*!< Reserved field, needed for padding anyways*/
+   XXH64_hash_t reserved64;   /*!< Reserved field. Do not read or write to it. */
+};   /* typedef'd to XXH64_state_t */
+
+
+#ifndef XXH_NO_XXH3
+
+#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) /* >= C11 */
+#  include <stdalign.h>
+#  define XXH_ALIGN(n)      alignas(n)
+#elif defined(__cplusplus) && (__cplusplus >= 201103L) /* >= C++11 */
+/* In C++ alignas() is a keyword */
+#  define XXH_ALIGN(n)      alignas(n)
+#elif defined(__GNUC__)
+#  define XXH_ALIGN(n)      __attribute__ ((aligned(n)))
+#elif defined(_MSC_VER)
+#  define XXH_ALIGN(n)      __declspec(align(n))
+#else
+#  define XXH_ALIGN(n)   /* disabled */
+#endif
+
+/* Old GCC versions only accept the attribute after the type in structures. */
+#if !(defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L))   /* C11+ */ \
+    && ! (defined(__cplusplus) && (__cplusplus >= 201103L)) /* >= C++11 */ \
+    && defined(__GNUC__)
+#   define XXH_ALIGN_MEMBER(align, type) type XXH_ALIGN(align)
+#else
+#   define XXH_ALIGN_MEMBER(align, type) XXH_ALIGN(align) type
+#endif
+
+/*!
+ * @brief The size of the internal XXH3 buffer.
+ *
+ * This is the optimal update size for incremental hashing.
+ *
+ * @see XXH3_64b_update(), XXH3_128b_update().
+ */
+#define XXH3_INTERNALBUFFER_SIZE 256
+
+/*!
+ * @brief Default size of the secret buffer (and @ref XXH3_kSecret).
+ *
+ * This is the size used in @ref XXH3_kSecret and the seeded functions.
+ *
+ * Not to be confused with @ref XXH3_SECRET_SIZE_MIN.
+ */
+#define XXH3_SECRET_DEFAULT_SIZE 192
+
+/*!
+ * @internal
+ * @brief Structure for XXH3 streaming API.
+ *
+ * @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,
+ * @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined.
+ * Otherwise it is an opaque type.
+ * Never use this definition in combination with dynamic library.
+ * This allows fields to safely be changed in the future.
+ *
+ * @note ** This structure has a strict alignment requirement of 64 bytes!! **
+ * Do not allocate this with `malloc()` or `new`,
+ * it will not be sufficiently aligned.
+ * Use @ref XXH3_createState() and @ref XXH3_freeState(), or stack allocation.
+ *
+ * Typedef'd to @ref XXH3_state_t.
+ * Do never access the members of this struct directly.
+ *
+ * @see XXH3_INITSTATE() for stack initialization.
+ * @see XXH3_createState(), XXH3_freeState().
+ * @see XXH32_state_s, XXH64_state_s
+ */
+struct XXH3_state_s {
+   XXH_ALIGN_MEMBER(64, XXH64_hash_t acc[8]);
+       /*!< The 8 accumulators. Similar to `vN` in @ref XXH32_state_s::v1 and @ref XXH64_state_s */
+   XXH_ALIGN_MEMBER(64, unsigned char customSecret[XXH3_SECRET_DEFAULT_SIZE]);
+       /*!< Used to store a custom secret generated from a seed. */
+   XXH_ALIGN_MEMBER(64, unsigned char buffer[XXH3_INTERNALBUFFER_SIZE]);
+       /*!< The internal buffer. @see XXH32_state_s::mem32 */
+   XXH32_hash_t bufferedSize;
+       /*!< The amount of memory in @ref buffer, @see XXH32_state_s::memsize */
+   XXH32_hash_t useSeed;
+       /*!< Reserved field. Needed for padding on 64-bit. */
+   size_t nbStripesSoFar;
+       /*!< Number or stripes processed. */
+   XXH64_hash_t totalLen;
+       /*!< Total length hashed. 64-bit even on 32-bit targets. */
+   size_t nbStripesPerBlock;
+       /*!< Number of stripes per block. */
+   size_t secretLimit;
+       /*!< Size of @ref customSecret or @ref extSecret */
+   XXH64_hash_t seed;
+       /*!< Seed for _withSeed variants. Must be zero otherwise, @see XXH3_INITSTATE() */
+   XXH64_hash_t reserved64;
+       /*!< Reserved field. */
+   const unsigned char* extSecret;
+       /*!< Reference to an external secret for the _withSecret variants, NULL
+        *   for other variants. */
+   /* note: there may be some padding at the end due to alignment on 64 bytes */
+}; /* typedef'd to XXH3_state_t */
+
+#undef XXH_ALIGN_MEMBER
+
+/*!
+ * @brief Initializes a stack-allocated `XXH3_state_s`.
+ *
+ * When the @ref XXH3_state_t structure is merely emplaced on stack,
+ * it should be initialized with XXH3_INITSTATE() or a memset()
+ * in case its first reset uses XXH3_NNbits_reset_withSeed().
+ * This init can be omitted if the first reset uses default or _withSecret mode.
+ * This operation isn't necessary when the state is created with XXH3_createState().
+ * Note that this doesn't prepare the state for a streaming operation,
+ * it's still necessary to use XXH3_NNbits_reset*() afterwards.
+ */
+#define XXH3_INITSTATE(XXH3_state_ptr)   { (XXH3_state_ptr)->seed = 0; }
+
+
+/* XXH128() :
+ * simple alias to pre-selected XXH3_128bits variant
+ */
+XXH_PUBLIC_API XXH128_hash_t XXH128(const void* data, size_t len, XXH64_hash_t seed);
+
+
+/* ===   Experimental API   === */
+/* Symbols defined below must be considered tied to a specific library version. */
+
+/*
+ * XXH3_generateSecret():
+ *
+ * Derive a high-entropy secret from any user-defined content, named customSeed.
+ * The generated secret can be used in combination with `*_withSecret()` functions.
+ * The `_withSecret()` variants are useful to provide a higher level of protection than 64-bit seed,
+ * as it becomes much more difficult for an external actor to guess how to impact the calculation logic.
+ *
+ * The function accepts as input a custom seed of any length and any content,
+ * and derives from it a high-entropy secret of length @secretSize
+ * into an already allocated buffer @secretBuffer.
+ * @secretSize must be >= XXH3_SECRET_SIZE_MIN
+ *
+ * The generated secret can then be used with any `*_withSecret()` variant.
+ * Functions `XXH3_128bits_withSecret()`, `XXH3_64bits_withSecret()`,
+ * `XXH3_128bits_reset_withSecret()` and `XXH3_64bits_reset_withSecret()`
+ * are part of this list. They all accept a `secret` parameter
+ * which must be large enough for implementation reasons (>= XXH3_SECRET_SIZE_MIN)
+ * _and_ feature very high entropy (consist of random-looking bytes).
+ * These conditions can be a high bar to meet, so
+ * XXH3_generateSecret() can be employed to ensure proper quality.
+ *
+ * customSeed can be anything. It can have any size, even small ones,
+ * and its content can be anything, even "poor entropy" sources such as a bunch of zeroes.
+ * The resulting `secret` will nonetheless provide all required qualities.
+ *
+ * When customSeedSize > 0, supplying NULL as customSeed is undefined behavior.
+ */
+XXH_PUBLIC_API XXH_errorcode XXH3_generateSecret(void* secretBuffer, size_t secretSize, const void* customSeed, size_t customSeedSize);
+
+
+/*
+ * XXH3_generateSecret_fromSeed():
+ *
+ * Generate the same secret as the _withSeed() variants.
+ *
+ * The resulting secret has a length of XXH3_SECRET_DEFAULT_SIZE (necessarily).
+ * @secretBuffer must be already allocated, of size at least XXH3_SECRET_DEFAULT_SIZE bytes.
+ *
+ * The generated secret can be used in combination with
+ *`*_withSecret()` and `_withSecretandSeed()` variants.
+ * This generator is notably useful in combination with `_withSecretandSeed()`,
+ * as a way to emulate a faster `_withSeed()` variant.
+ */
+XXH_PUBLIC_API void XXH3_generateSecret_fromSeed(void* secretBuffer, XXH64_hash_t seed);
+
+/*
+ * *_withSecretandSeed() :
+ * These variants generate hash values using either
+ * @seed for "short" keys (< XXH3_MIDSIZE_MAX = 240 bytes)
+ * or @secret for "large" keys (>= XXH3_MIDSIZE_MAX).
+ *
+ * This generally benefits speed, compared to `_withSeed()` or `_withSecret()`.
+ * `_withSeed()` has to generate the secret on the fly for "large" keys.
+ * It's fast, but can be perceptible for "not so large" keys (< 1 KB).
+ * `_withSecret()` has to generate the masks on the fly for "small" keys,
+ * which requires more instructions than _withSeed() variants.
+ * Therefore, _withSecretandSeed variant combines the best of both worlds.
+ *
+ * When @secret has been generated by XXH3_generateSecret_fromSeed(),
+ * this variant produces *exactly* the same results as `_withSeed()` variant,
+ * hence offering only a pure speed benefit on "large" input,
+ * by skipping the need to regenerate the secret for every large input.
+ *
+ * Another usage scenario is to hash the secret to a 64-bit hash value,
+ * for example with XXH3_64bits(), which then becomes the seed,
+ * and then employ both the seed and the secret in _withSecretandSeed().
+ * On top of speed, an added benefit is that each bit in the secret
+ * has a 50% chance to swap each bit in the output,
+ * via its impact to the seed.
+ * This is not guaranteed when using the secret directly in "small data" scenarios,
+ * because only portions of the secret are employed for small data.
+ */
+XXH_PUBLIC_API XXH64_hash_t
+XXH3_64bits_withSecretandSeed(const void* data, size_t len,
+                              const void* secret, size_t secretSize,
+                              XXH64_hash_t seed);
+
+XXH_PUBLIC_API XXH128_hash_t
+XXH3_128bits_withSecretandSeed(const void* data, size_t len,
+                               const void* secret, size_t secretSize,
+                               XXH64_hash_t seed64);
+
+XXH_PUBLIC_API XXH_errorcode
+XXH3_64bits_reset_withSecretandSeed(XXH3_state_t* statePtr,
+                                    const void* secret, size_t secretSize,
+                                    XXH64_hash_t seed64);
+
+XXH_PUBLIC_API XXH_errorcode
+XXH3_128bits_reset_withSecretandSeed(XXH3_state_t* statePtr,
+                                     const void* secret, size_t secretSize,
+                                     XXH64_hash_t seed64);
+
+
+#endif  /* XXH_NO_XXH3 */
+#endif  /* XXH_NO_LONG_LONG */
+#if defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)
+#  define XXH_IMPLEMENTATION
+#endif
+
+#endif  /* defined(XXH_STATIC_LINKING_ONLY) && !defined(XXHASH_H_STATIC_13879238742) */
+
+
+/* ======================================================================== */
+/* ======================================================================== */
+/* ======================================================================== */
+
+
+/*-**********************************************************************
+ * xxHash implementation
+ *-**********************************************************************
+ * xxHash's implementation used to be hosted inside xxhash.c.
+ *
+ * However, inlining requires implementation to be visible to the compiler,
+ * hence be included alongside the header.
+ * Previously, implementation was hosted inside xxhash.c,
+ * which was then #included when inlining was activated.
+ * This construction created issues with a few build and install systems,
+ * as it required xxhash.c to be stored in /include directory.
+ *
+ * xxHash implementation is now directly integrated within xxhash.h.
+ * As a consequence, xxhash.c is no longer needed in /include.
+ *
+ * xxhash.c is still available and is still useful.
+ * In a "normal" setup, when xxhash is not inlined,
+ * xxhash.h only exposes the prototypes and public symbols,
+ * while xxhash.c can be built into an object file xxhash.o
+ * which can then be linked into the final binary.
+ ************************************************************************/
+
+#if ( defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API) \
+   || defined(XXH_IMPLEMENTATION) ) && !defined(XXH_IMPLEM_13a8737387)
+#  define XXH_IMPLEM_13a8737387
+
+/* *************************************
+*  Tuning parameters
+***************************************/
+
+/*!
+ * @defgroup tuning Tuning parameters
+ * @{
+ *
+ * Various macros to control xxHash's behavior.
+ */
+#ifdef XXH_DOXYGEN
+/*!
+ * @brief Define this to disable 64-bit code.
+ *
+ * Useful if only using the @ref xxh32_family and you have a strict C90 compiler.
+ */
+#  define XXH_NO_LONG_LONG
+#  undef XXH_NO_LONG_LONG /* don't actually */
+/*!
+ * @brief Controls how unaligned memory is accessed.
+ *
+ * By default, access to unaligned memory is controlled by `memcpy()`, which is
+ * safe and portable.
+ *
+ * Unfortunately, on some target/compiler combinations, the generated assembly
+ * is sub-optimal.
+ *
+ * The below switch allow selection of a different access method
+ * in the search for improved performance.
+ *
+ * @par Possible options:
+ *
+ *  - `XXH_FORCE_MEMORY_ACCESS=0` (default): `memcpy`
+ *   @par
+ *     Use `memcpy()`. Safe and portable. Note that most modern compilers will
+ *     eliminate the function call and treat it as an unaligned access.
+ *
+ *  - `XXH_FORCE_MEMORY_ACCESS=1`: `__attribute__((packed))`
+ *   @par
+ *     Depends on compiler extensions and is therefore not portable.
+ *     This method is safe _if_ your compiler supports it,
+ *     and *generally* as fast or faster than `memcpy`.
+ *
+ *  - `XXH_FORCE_MEMORY_ACCESS=2`: Direct cast
+ *  @par
+ *     Casts directly and dereferences. This method doesn't depend on the
+ *     compiler, but it violates the C standard as it directly dereferences an
+ *     unaligned pointer. It can generate buggy code on targets which do not
+ *     support unaligned memory accesses, but in some circumstances, it's the
+ *     only known way to get the most performance.
+ *
+ *  - `XXH_FORCE_MEMORY_ACCESS=3`: Byteshift
+ *  @par
+ *     Also portable. This can generate the best code on old compilers which don't
+ *     inline small `memcpy()` calls, and it might also be faster on big-endian
+ *     systems which lack a native byteswap instruction. However, some compilers
+ *     will emit literal byteshifts even if the target supports unaligned access.
+ *  .
+ *
+ * @warning
+ *   Methods 1 and 2 rely on implementation-defined behavior. Use these with
+ *   care, as what works on one compiler/platform/optimization level may cause
+ *   another to read garbage data or even crash.
+ *
+ * See https://fastcompression.blogspot.com/2015/08/accessing-unaligned-memory.html for details.
+ *
+ * Prefer these methods in priority order (0 > 3 > 1 > 2)
+ */
+#  define XXH_FORCE_MEMORY_ACCESS 0
+
+/*!
+ * @def XXH_FORCE_ALIGN_CHECK
+ * @brief If defined to non-zero, adds a special path for aligned inputs (XXH32()
+ * and XXH64() only).
+ *
+ * This is an important performance trick for architectures without decent
+ * unaligned memory access performance.
+ *
+ * It checks for input alignment, and when conditions are met, uses a "fast
+ * path" employing direct 32-bit/64-bit reads, resulting in _dramatically
+ * faster_ read speed.
+ *
+ * The check costs one initial branch per hash, which is generally negligible,
+ * but not zero.
+ *
+ * Moreover, it's not useful to generate an additional code path if memory
+ * access uses the same instruction for both aligned and unaligned
+ * addresses (e.g. x86 and aarch64).
+ *
+ * In these cases, the alignment check can be removed by setting this macro to 0.
+ * Then the code will always use unaligned memory access.
+ * Align check is automatically disabled on x86, x64 & arm64,
+ * which are platforms known to offer good unaligned memory accesses performance.
+ *
+ * This option does not affect XXH3 (only XXH32 and XXH64).
+ */
+#  define XXH_FORCE_ALIGN_CHECK 0
+
+/*!
+ * @def XXH_NO_INLINE_HINTS
+ * @brief When non-zero, sets all functions to `static`.
+ *
+ * By default, xxHash tries to force the compiler to inline almost all internal
+ * functions.
+ *
+ * This can usually improve performance due to reduced jumping and improved
+ * constant folding, but significantly increases the size of the binary which
+ * might not be favorable.
+ *
+ * Additionally, sometimes the forced inlining can be detrimental to performance,
+ * depending on the architecture.
+ *
+ * XXH_NO_INLINE_HINTS marks all internal functions as static, giving the
+ * compiler full control on whether to inline or not.
+ *
+ * When not optimizing (-O0), optimizing for size (-Os, -Oz), or using
+ * -fno-inline with GCC or Clang, this will automatically be defined.
+ */
+#  define XXH_NO_INLINE_HINTS 0
+
+/*!
+ * @def XXH32_ENDJMP
+ * @brief Whether to use a jump for `XXH32_finalize`.
+ *
+ * For performance, `XXH32_finalize` uses multiple branches in the finalizer.
+ * This is generally preferable for performance,
+ * but depending on exact architecture, a jmp may be preferable.
+ *
+ * This setting is only possibly making a difference for very small inputs.
+ */
+#  define XXH32_ENDJMP 0
+
+/*!
+ * @internal
+ * @brief Redefines old internal names.
+ *
+ * For compatibility with code that uses xxHash's internals before the names
+ * were changed to improve namespacing. There is no other reason to use this.
+ */
+#  define XXH_OLD_NAMES
+#  undef XXH_OLD_NAMES /* don't actually use, it is ugly. */
+#endif /* XXH_DOXYGEN */
+/*!
+ * @}
+ */
+
+#ifndef XXH_FORCE_MEMORY_ACCESS   /* can be defined externally, on command line for example */
+   /* prefer __packed__ structures (method 1) for gcc on armv7+ and mips */
+#  if !defined(__clang__) && \
+( \
+    (defined(__INTEL_COMPILER) && !defined(_WIN32)) || \
+    ( \
+        defined(__GNUC__) && ( \
+            (defined(__ARM_ARCH) && __ARM_ARCH >= 7) || \
+            ( \
+                defined(__mips__) && \
+                (__mips <= 5 || __mips_isa_rev < 6) && \
+                (!defined(__mips16) || defined(__mips_mips16e2)) \
+            ) \
+        ) \
+    ) \
+)
+#    define XXH_FORCE_MEMORY_ACCESS 1
+#  endif
+#endif
+
+#ifndef XXH_FORCE_ALIGN_CHECK  /* can be defined externally */
+#  if defined(__i386)  || defined(__x86_64__) || defined(__aarch64__) \
+   || defined(_M_IX86) || defined(_M_X64)     || defined(_M_ARM64) /* visual */
+#    define XXH_FORCE_ALIGN_CHECK 0
+#  else
+#    define XXH_FORCE_ALIGN_CHECK 1
+#  endif
+#endif
+
+#ifndef XXH_NO_INLINE_HINTS
+#  if defined(__OPTIMIZE_SIZE__) /* -Os, -Oz */ \
+   || defined(__NO_INLINE__)     /* -O0, -fno-inline */
+#    define XXH_NO_INLINE_HINTS 1
+#  else
+#    define XXH_NO_INLINE_HINTS 0
+#  endif
+#endif
+
+#ifndef XXH32_ENDJMP
+/* generally preferable for performance */
+#  define XXH32_ENDJMP 0
+#endif
+
+/*!
+ * @defgroup impl Implementation
+ * @{
+ */
+
+
+/* *************************************
+*  Includes & Memory related functions
+***************************************/
+/* Modify the local functions below should you wish to use some other memory routines */
+/* for ZSTD_malloc(), ZSTD_free() */
+#define ZSTD_DEPS_NEED_MALLOC
+#include "zstd_deps.h"  /* size_t, ZSTD_malloc, ZSTD_free, ZSTD_memcpy */
+static void* XXH_malloc(size_t s) { return ZSTD_malloc(s); }
+static void  XXH_free  (void* p)  { ZSTD_free(p); }
+static void* XXH_memcpy(void* dest, const void* src, size_t size) { return ZSTD_memcpy(dest,src,size); }
+
+
+/* *************************************
+*  Compiler Specific Options
+***************************************/
+#ifdef _MSC_VER /* Visual Studio warning fix */
+#  pragma warning(disable : 4127) /* disable: C4127: conditional expression is constant */
+#endif
+
+#if XXH_NO_INLINE_HINTS  /* disable inlining hints */
+#  if defined(__GNUC__) || defined(__clang__)
+#    define XXH_FORCE_INLINE static __attribute__((unused))
+#  else
+#    define XXH_FORCE_INLINE static
+#  endif
+#  define XXH_NO_INLINE static
+/* enable inlining hints */
+#elif defined(__GNUC__) || defined(__clang__)
+#  define XXH_FORCE_INLINE static __inline__ __attribute__((always_inline, unused))
+#  define XXH_NO_INLINE static __attribute__((noinline))
+#elif defined(_MSC_VER)  /* Visual Studio */
+#  define XXH_FORCE_INLINE static __forceinline
+#  define XXH_NO_INLINE static __declspec(noinline)
+#elif defined (__cplusplus) \
+  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L))   /* C99 */
+#  define XXH_FORCE_INLINE static inline
+#  define XXH_NO_INLINE static
+#else
+#  define XXH_FORCE_INLINE static
+#  define XXH_NO_INLINE static
+#endif
+
+
+
+/* *************************************
+*  Debug
+***************************************/
+/*!
+ * @ingroup tuning
+ * @def XXH_DEBUGLEVEL
+ * @brief Sets the debugging level.
+ *
+ * XXH_DEBUGLEVEL is expected to be defined externally, typically via the
+ * compiler's command line options. The value must be a number.
+ */
+#ifndef XXH_DEBUGLEVEL
+#  ifdef DEBUGLEVEL /* backwards compat */
+#    define XXH_DEBUGLEVEL DEBUGLEVEL
+#  else
+#    define XXH_DEBUGLEVEL 0
+#  endif
+#endif
+
+#if (XXH_DEBUGLEVEL>=1)
+#  include <assert.h>   /* note: can still be disabled with NDEBUG */
+#  define XXH_ASSERT(c)   assert(c)
+#else
+#  define XXH_ASSERT(c)   ((void)0)
+#endif
+
+/* note: use after variable declarations */
+#ifndef XXH_STATIC_ASSERT
+#  if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)    /* C11 */
+#    include <assert.h>
+#    define XXH_STATIC_ASSERT_WITH_MESSAGE(c,m) do { static_assert((c),m); } while(0)
+#  elif defined(__cplusplus) && (__cplusplus >= 201103L)            /* C++11 */
+#    define XXH_STATIC_ASSERT_WITH_MESSAGE(c,m) do { static_assert((c),m); } while(0)
+#  else
+#    define XXH_STATIC_ASSERT_WITH_MESSAGE(c,m) do { struct xxh_sa { char x[(c) ? 1 : -1]; }; } while(0)
+#  endif
+#  define XXH_STATIC_ASSERT(c) XXH_STATIC_ASSERT_WITH_MESSAGE((c),#c)
+#endif
+
+/*!
+ * @internal
+ * @def XXH_COMPILER_GUARD(var)
+ * @brief Used to prevent unwanted optimizations for @p var.
+ *
+ * It uses an empty GCC inline assembly statement with a register constraint
+ * which forces @p var into a general purpose register (e.g. eax, ebx, ecx
+ * on x86) and marks it as modified.
+ *
+ * This is used in a few places to avoid unwanted autovectorization (e.g.
+ * XXH32_round()). All vectorization we want is explicit via intrinsics,
+ * and _usually_ isn't wanted elsewhere.
+ *
+ * We also use it to prevent unwanted constant folding for AArch64 in
+ * XXH3_initCustomSecret_scalar().
+ */
+#if defined(__GNUC__) || defined(__clang__)
+#  define XXH_COMPILER_GUARD(var) __asm__ __volatile__("" : "+r" (var))
+#else
+#  define XXH_COMPILER_GUARD(var) ((void)0)
+#endif
+
+/* *************************************
+*  Basic Types
+***************************************/
+#if !defined (__VMS) \
+ && (defined (__cplusplus) \
+ || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
+# include <stdint.h>
+  typedef uint8_t xxh_u8;
+#else
+  typedef unsigned char xxh_u8;
+#endif
+typedef XXH32_hash_t xxh_u32;
+
+#ifdef XXH_OLD_NAMES
+#  define BYTE xxh_u8
+#  define U8   xxh_u8
+#  define U32  xxh_u32
+#endif
+
+/* ***   Memory access   *** */
+
+/*!
+ * @internal
+ * @fn xxh_u32 XXH_read32(const void* ptr)
+ * @brief Reads an unaligned 32-bit integer from @p ptr in native endianness.
+ *
+ * Affected by @ref XXH_FORCE_MEMORY_ACCESS.
+ *
+ * @param ptr The pointer to read from.
+ * @return The 32-bit native endian integer from the bytes at @p ptr.
+ */
+
+/*!
+ * @internal
+ * @fn xxh_u32 XXH_readLE32(const void* ptr)
+ * @brief Reads an unaligned 32-bit little endian integer from @p ptr.
+ *
+ * Affected by @ref XXH_FORCE_MEMORY_ACCESS.
+ *
+ * @param ptr The pointer to read from.
+ * @return The 32-bit little endian integer from the bytes at @p ptr.
+ */
+
+/*!
+ * @internal
+ * @fn xxh_u32 XXH_readBE32(const void* ptr)
+ * @brief Reads an unaligned 32-bit big endian integer from @p ptr.
+ *
+ * Affected by @ref XXH_FORCE_MEMORY_ACCESS.
+ *
+ * @param ptr The pointer to read from.
+ * @return The 32-bit big endian integer from the bytes at @p ptr.
+ */
+
+/*!
+ * @internal
+ * @fn xxh_u32 XXH_readLE32_align(const void* ptr, XXH_alignment align)
+ * @brief Like @ref XXH_readLE32(), but has an option for aligned reads.
+ *
+ * Affected by @ref XXH_FORCE_MEMORY_ACCESS.
+ * Note that when @ref XXH_FORCE_ALIGN_CHECK == 0, the @p align parameter is
+ * always @ref XXH_alignment::XXH_unaligned.
+ *
+ * @param ptr The pointer to read from.
+ * @param align Whether @p ptr is aligned.
+ * @pre
+ *   If @p align == @ref XXH_alignment::XXH_aligned, @p ptr must be 4 byte
+ *   aligned.
+ * @return The 32-bit little endian integer from the bytes at @p ptr.
+ */
+
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+/*
+ * Manual byteshift. Best for old compilers which don't inline memcpy.
+ * We actually directly use XXH_readLE32 and XXH_readBE32.
+ */
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
+
+/*
+ * Force direct memory access. Only works on CPU which support unaligned memory
+ * access in hardware.
+ */
+static xxh_u32 XXH_read32(const void* memPtr) { return *(const xxh_u32*) memPtr; }
+
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
+
+/*
+ * __pack instructions are safer but compiler specific, hence potentially
+ * problematic for some compilers.
+ *
+ * Currently only defined for GCC and ICC.
+ */
+#ifdef XXH_OLD_NAMES
+typedef union { xxh_u32 u32; } __attribute__((packed)) unalign;
+#endif
+static xxh_u32 XXH_read32(const void* ptr)
+{
+    typedef union { xxh_u32 u32; } __attribute__((packed)) xxh_unalign;
+    return ((const xxh_unalign*)ptr)->u32;
+}
+
+#else
+
+/*
+ * Portable and safe solution. Generally efficient.
+ * see: https://fastcompression.blogspot.com/2015/08/accessing-unaligned-memory.html
+ */
+static xxh_u32 XXH_read32(const void* memPtr)
+{
+    xxh_u32 val;
+    XXH_memcpy(&val, memPtr, sizeof(val));
+    return val;
+}
+
+#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
+
+
+/* ***   Endianness   *** */
+
+/*!
+ * @ingroup tuning
+ * @def XXH_CPU_LITTLE_ENDIAN
+ * @brief Whether the target is little endian.
+ *
+ * Defined to 1 if the target is little endian, or 0 if it is big endian.
+ * It can be defined externally, for example on the compiler command line.
+ *
+ * If it is not defined,
+ * a runtime check (which is usually constant folded) is used instead.
+ *
+ * @note
+ *   This is not necessarily defined to an integer constant.
+ *
+ * @see XXH_isLittleEndian() for the runtime check.
+ */
+#ifndef XXH_CPU_LITTLE_ENDIAN
+/*
+ * Try to detect endianness automatically, to avoid the nonstandard behavior
+ * in `XXH_isLittleEndian()`
+ */
+#  if defined(_WIN32) /* Windows is always little endian */ \
+     || defined(__LITTLE_ENDIAN__) \
+     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
+#    define XXH_CPU_LITTLE_ENDIAN 1
+#  elif defined(__BIG_ENDIAN__) \
+     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
+#    define XXH_CPU_LITTLE_ENDIAN 0
+#  else
+/*!
+ * @internal
+ * @brief Runtime check for @ref XXH_CPU_LITTLE_ENDIAN.
+ *
+ * Most compilers will constant fold this.
+ */
+static int XXH_isLittleEndian(void)
+{
+    /*
+     * Portable and well-defined behavior.
+     * Don't use static: it is detrimental to performance.
+     */
+    const union { xxh_u32 u; xxh_u8 c[4]; } one = { 1 };
+    return one.c[0];
+}
+#   define XXH_CPU_LITTLE_ENDIAN   XXH_isLittleEndian()
+#  endif
+#endif
+
+
+
+
+/* ****************************************
+*  Compiler-specific Functions and Macros
+******************************************/
+#define XXH_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
+
+#ifdef __has_builtin
+#  define XXH_HAS_BUILTIN(x) __has_builtin(x)
+#else
+#  define XXH_HAS_BUILTIN(x) 0
+#endif
+
+/*!
+ * @internal
+ * @def XXH_rotl32(x,r)
+ * @brief 32-bit rotate left.
+ *
+ * @param x The 32-bit integer to be rotated.
+ * @param r The number of bits to rotate.
+ * @pre
+ *   @p r > 0 && @p r < 32
+ * @note
+ *   @p x and @p r may be evaluated multiple times.
+ * @return The rotated result.
+ */
+#if !defined(NO_CLANG_BUILTIN) && XXH_HAS_BUILTIN(__builtin_rotateleft32) \
+                               && XXH_HAS_BUILTIN(__builtin_rotateleft64)
+#  define XXH_rotl32 __builtin_rotateleft32
+#  define XXH_rotl64 __builtin_rotateleft64
+/* Note: although _rotl exists for minGW (GCC under windows), performance seems poor */
+#elif defined(_MSC_VER)
+#  define XXH_rotl32(x,r) _rotl(x,r)
+#  define XXH_rotl64(x,r) _rotl64(x,r)
+#else
+#  define XXH_rotl32(x,r) (((x) << (r)) | ((x) >> (32 - (r))))
+#  define XXH_rotl64(x,r) (((x) << (r)) | ((x) >> (64 - (r))))
+#endif
+
+/*!
+ * @internal
+ * @fn xxh_u32 XXH_swap32(xxh_u32 x)
+ * @brief A 32-bit byteswap.
+ *
+ * @param x The 32-bit integer to byteswap.
+ * @return @p x, byteswapped.
+ */
+#if defined(_MSC_VER)     /* Visual Studio */
+#  define XXH_swap32 _byteswap_ulong
+#elif XXH_GCC_VERSION >= 403
+#  define XXH_swap32 __builtin_bswap32
+#else
+static xxh_u32 XXH_swap32 (xxh_u32 x)
+{
+    return  ((x << 24) & 0xff000000 ) |
+            ((x <<  8) & 0x00ff0000 ) |
+            ((x >>  8) & 0x0000ff00 ) |
+            ((x >> 24) & 0x000000ff );
+}
+#endif
+
+
+/* ***************************
+*  Memory reads
+*****************************/
+
+/*!
+ * @internal
+ * @brief Enum to indicate whether a pointer is aligned.
+ */
+typedef enum {
+    XXH_aligned,  /*!< Aligned */
+    XXH_unaligned /*!< Possibly unaligned */
+} XXH_alignment;
+
+/*
+ * XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load.
+ *
+ * This is ideal for older compilers which don't inline memcpy.
+ */
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+
+XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[0]
+         | ((xxh_u32)bytePtr[1] << 8)
+         | ((xxh_u32)bytePtr[2] << 16)
+         | ((xxh_u32)bytePtr[3] << 24);
+}
+
+XXH_FORCE_INLINE xxh_u32 XXH_readBE32(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[3]
+         | ((xxh_u32)bytePtr[2] << 8)
+         | ((xxh_u32)bytePtr[1] << 16)
+         | ((xxh_u32)bytePtr[0] << 24);
+}
+
+#else
+XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));
+}
+
+static xxh_u32 XXH_readBE32(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap32(XXH_read32(ptr)) : XXH_read32(ptr);
+}
+#endif
+
+XXH_FORCE_INLINE xxh_u32
+XXH_readLE32_align(const void* ptr, XXH_alignment align)
+{
+    if (align==XXH_unaligned) {
+        return XXH_readLE32(ptr);
+    } else {
+        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u32*)ptr : XXH_swap32(*(const xxh_u32*)ptr);
+    }
+}
+
+
+/* *************************************
+*  Misc
+***************************************/
+/*! @ingroup public */
+XXH_PUBLIC_API unsigned XXH_versionNumber (void) { return XXH_VERSION_NUMBER; }
+
+
+/* *******************************************************************
+*  32-bit hash functions
+*********************************************************************/
+/*!
+ * @}
+ * @defgroup xxh32_impl XXH32 implementation
+ * @ingroup impl
+ * @{
+ */
+ /* #define instead of static const, to be used as initializers */
+#define XXH_PRIME32_1  0x9E3779B1U  /*!< 0b10011110001101110111100110110001 */
+#define XXH_PRIME32_2  0x85EBCA77U  /*!< 0b10000101111010111100101001110111 */
+#define XXH_PRIME32_3  0xC2B2AE3DU  /*!< 0b11000010101100101010111000111101 */
+#define XXH_PRIME32_4  0x27D4EB2FU  /*!< 0b00100111110101001110101100101111 */
+#define XXH_PRIME32_5  0x165667B1U  /*!< 0b00010110010101100110011110110001 */
+
+#ifdef XXH_OLD_NAMES
+#  define PRIME32_1 XXH_PRIME32_1
+#  define PRIME32_2 XXH_PRIME32_2
+#  define PRIME32_3 XXH_PRIME32_3
+#  define PRIME32_4 XXH_PRIME32_4
+#  define PRIME32_5 XXH_PRIME32_5
+#endif
+
+/*!
+ * @internal
+ * @brief Normal stripe processing routine.
+ *
+ * This shuffles the bits so that any bit from @p input impacts several bits in
+ * @p acc.
+ *
+ * @param acc The accumulator lane.
+ * @param input The stripe of input to mix.
+ * @return The mixed accumulator lane.
+ */
+static xxh_u32 XXH32_round(xxh_u32 acc, xxh_u32 input)
+{
+    acc += input * XXH_PRIME32_2;
+    acc  = XXH_rotl32(acc, 13);
+    acc *= XXH_PRIME32_1;
+#if (defined(__SSE4_1__) || defined(__aarch64__)) && !defined(XXH_ENABLE_AUTOVECTORIZE)
+    /*
+     * UGLY HACK:
+     * A compiler fence is the only thing that prevents GCC and Clang from
+     * autovectorizing the XXH32 loop (pragmas and attributes don't work for some
+     * reason) without globally disabling SSE4.1.
+     *
+     * The reason we want to avoid vectorization is because despite working on
+     * 4 integers at a time, there are multiple factors slowing XXH32 down on
+     * SSE4:
+     * - There's a ridiculous amount of lag from pmulld (10 cycles of latency on
+     *   newer chips!) making it slightly slower to multiply four integers at
+     *   once compared to four integers independently. Even when pmulld was
+     *   fastest, Sandy/Ivy Bridge, it is still not worth it to go into SSE
+     *   just to multiply unless doing a long operation.
+     *
+     * - Four instructions are required to rotate,
+     *      movqda tmp,  v // not required with VEX encoding
+     *      pslld  tmp, 13 // tmp <<= 13
+     *      psrld  v,   19 // x >>= 19
+     *      por    v,  tmp // x |= tmp
+     *   compared to one for scalar:
+     *      roll   v, 13    // reliably fast across the board
+     *      shldl  v, v, 13 // Sandy Bridge and later prefer this for some reason
+     *
+     * - Instruction level parallelism is actually more beneficial here because
+     *   the SIMD actually serializes this operation: While v1 is rotating, v2
+     *   can load data, while v3 can multiply. SSE forces them to operate
+     *   together.
+     *
+     * This is also enabled on AArch64, as Clang autovectorizes it incorrectly
+     * and it is pointless writing a NEON implementation that is basically the
+     * same speed as scalar for XXH32.
+     */
+    XXH_COMPILER_GUARD(acc);
+#endif
+    return acc;
+}
+
+/*!
+ * @internal
+ * @brief Mixes all bits to finalize the hash.
+ *
+ * The final mix ensures that all input bits have a chance to impact any bit in
+ * the output digest, resulting in an unbiased distribution.
+ *
+ * @param h32 The hash to avalanche.
+ * @return The avalanched hash.
+ */
+static xxh_u32 XXH32_avalanche(xxh_u32 h32)
+{
+    h32 ^= h32 >> 15;
+    h32 *= XXH_PRIME32_2;
+    h32 ^= h32 >> 13;
+    h32 *= XXH_PRIME32_3;
+    h32 ^= h32 >> 16;
+    return(h32);
+}
+
+#define XXH_get32bits(p) XXH_readLE32_align(p, align)
+
+/*!
+ * @internal
+ * @brief Processes the last 0-15 bytes of @p ptr.
+ *
+ * There may be up to 15 bytes remaining to consume from the input.
+ * This final stage will digest them to ensure that all input bytes are present
+ * in the final mix.
+ *
+ * @param h32 The hash to finalize.
+ * @param ptr The pointer to the remaining input.
+ * @param len The remaining length, modulo 16.
+ * @param align Whether @p ptr is aligned.
+ * @return The finalized hash.
+ */
+static xxh_u32
+XXH32_finalize(xxh_u32 h32, const xxh_u8* ptr, size_t len, XXH_alignment align)
+{
+#define XXH_PROCESS1 do {                           \
+    h32 += (*ptr++) * XXH_PRIME32_5;                \
+    h32 = XXH_rotl32(h32, 11) * XXH_PRIME32_1;      \
+} while (0)
+
+#define XXH_PROCESS4 do {                           \
+    h32 += XXH_get32bits(ptr) * XXH_PRIME32_3;      \
+    ptr += 4;                                   \
+    h32  = XXH_rotl32(h32, 17) * XXH_PRIME32_4;     \
+} while (0)
+
+    if (ptr==NULL) XXH_ASSERT(len == 0);
+
+    /* Compact rerolled version; generally faster */
+    if (!XXH32_ENDJMP) {
+        len &= 15;
+        while (len >= 4) {
+            XXH_PROCESS4;
+            len -= 4;
+        }
+        while (len > 0) {
+            XXH_PROCESS1;
+            --len;
+        }
+        return XXH32_avalanche(h32);
+    } else {
+         switch(len&15) /* or switch(bEnd - p) */ {
+           case 12:      XXH_PROCESS4;
+                         XXH_FALLTHROUGH;
+           case 8:       XXH_PROCESS4;
+                         XXH_FALLTHROUGH;
+           case 4:       XXH_PROCESS4;
+                         return XXH32_avalanche(h32);
+
+           case 13:      XXH_PROCESS4;
+                         XXH_FALLTHROUGH;
+           case 9:       XXH_PROCESS4;
+                         XXH_FALLTHROUGH;
+           case 5:       XXH_PROCESS4;
+                         XXH_PROCESS1;
+                         return XXH32_avalanche(h32);
+
+           case 14:      XXH_PROCESS4;
+                         XXH_FALLTHROUGH;
+           case 10:      XXH_PROCESS4;
+                         XXH_FALLTHROUGH;
+           case 6:       XXH_PROCESS4;
+                         XXH_PROCESS1;
+                         XXH_PROCESS1;
+                         return XXH32_avalanche(h32);
+
+           case 15:      XXH_PROCESS4;
+                         XXH_FALLTHROUGH;
+           case 11:      XXH_PROCESS4;
+                         XXH_FALLTHROUGH;
+           case 7:       XXH_PROCESS4;
+                         XXH_FALLTHROUGH;
+           case 3:       XXH_PROCESS1;
+                         XXH_FALLTHROUGH;
+           case 2:       XXH_PROCESS1;
+                         XXH_FALLTHROUGH;
+           case 1:       XXH_PROCESS1;
+                         XXH_FALLTHROUGH;
+           case 0:       return XXH32_avalanche(h32);
+        }
+        XXH_ASSERT(0);
+        return h32;   /* reaching this point is deemed impossible */
+    }
+}
+
+#ifdef XXH_OLD_NAMES
+#  define PROCESS1 XXH_PROCESS1
+#  define PROCESS4 XXH_PROCESS4
+#else
+#  undef XXH_PROCESS1
+#  undef XXH_PROCESS4
+#endif
+
+/*!
+ * @internal
+ * @brief The implementation for @ref XXH32().
+ *
+ * @param input , len , seed Directly passed from @ref XXH32().
+ * @param align Whether @p input is aligned.
+ * @return The calculated hash.
+ */
+XXH_FORCE_INLINE xxh_u32
+XXH32_endian_align(const xxh_u8* input, size_t len, xxh_u32 seed, XXH_alignment align)
+{
+    xxh_u32 h32;
+
+    if (input==NULL) XXH_ASSERT(len == 0);
+
+    if (len>=16) {
+        const xxh_u8* const bEnd = input + len;
+        const xxh_u8* const limit = bEnd - 15;
+        xxh_u32 v1 = seed + XXH_PRIME32_1 + XXH_PRIME32_2;
+        xxh_u32 v2 = seed + XXH_PRIME32_2;
+        xxh_u32 v3 = seed + 0;
+        xxh_u32 v4 = seed - XXH_PRIME32_1;
+
+        do {
+            v1 = XXH32_round(v1, XXH_get32bits(input)); input += 4;
+            v2 = XXH32_round(v2, XXH_get32bits(input)); input += 4;
+            v3 = XXH32_round(v3, XXH_get32bits(input)); input += 4;
+            v4 = XXH32_round(v4, XXH_get32bits(input)); input += 4;
+        } while (input < limit);
+
+        h32 = XXH_rotl32(v1, 1)  + XXH_rotl32(v2, 7)
+            + XXH_rotl32(v3, 12) + XXH_rotl32(v4, 18);
+    } else {
+        h32  = seed + XXH_PRIME32_5;
+    }
+
+    h32 += (xxh_u32)len;
+
+    return XXH32_finalize(h32, input, len&15, align);
+}
+
+/*! @ingroup xxh32_family */
+XXH_PUBLIC_API XXH32_hash_t XXH32 (const void* input, size_t len, XXH32_hash_t seed)
+{
+#if 0
+    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
+    XXH32_state_t state;
+    XXH32_reset(&state, seed);
+    XXH32_update(&state, (const xxh_u8*)input, len);
+    return XXH32_digest(&state);
+#else
+    if (XXH_FORCE_ALIGN_CHECK) {
+        if ((((size_t)input) & 3) == 0) {   /* Input is 4-bytes aligned, leverage the speed benefit */
+            return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
+    }   }
+
+    return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);
+#endif
+}
+
+
+
+/*******   Hash streaming   *******/
+/*!
+ * @ingroup xxh32_family
+ */
+XXH_PUBLIC_API XXH32_state_t* XXH32_createState(void)
+{
+    return (XXH32_state_t*)XXH_malloc(sizeof(XXH32_state_t));
+}
+/*! @ingroup xxh32_family */
+XXH_PUBLIC_API XXH_errorcode XXH32_freeState(XXH32_state_t* statePtr)
+{
+    XXH_free(statePtr);
+    return XXH_OK;
+}
+
+/*! @ingroup xxh32_family */
+XXH_PUBLIC_API void XXH32_copyState(XXH32_state_t* dstState, const XXH32_state_t* srcState)
+{
+    XXH_memcpy(dstState, srcState, sizeof(*dstState));
+}
+
+/*! @ingroup xxh32_family */
+XXH_PUBLIC_API XXH_errorcode XXH32_reset(XXH32_state_t* statePtr, XXH32_hash_t seed)
+{
+    XXH_ASSERT(statePtr != NULL);
+    memset(statePtr, 0, sizeof(*statePtr));
+    statePtr->v[0] = seed + XXH_PRIME32_1 + XXH_PRIME32_2;
+    statePtr->v[1] = seed + XXH_PRIME32_2;
+    statePtr->v[2] = seed + 0;
+    statePtr->v[3] = seed - XXH_PRIME32_1;
+    return XXH_OK;
+}
+
+
+/*! @ingroup xxh32_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH32_update(XXH32_state_t* state, const void* input, size_t len)
+{
+    if (input==NULL) {
+        XXH_ASSERT(len == 0);
+        return XXH_OK;
+    }
+
+    {   const xxh_u8* p = (const xxh_u8*)input;
+        const xxh_u8* const bEnd = p + len;
+
+        state->total_len_32 += (XXH32_hash_t)len;
+        state->large_len |= (XXH32_hash_t)((len>=16) | (state->total_len_32>=16));
+
+        if (state->memsize + len < 16)  {   /* fill in tmp buffer */
+            XXH_memcpy((xxh_u8*)(state->mem32) + state->memsize, input, len);
+            state->memsize += (XXH32_hash_t)len;
+            return XXH_OK;
+        }
+
+        if (state->memsize) {   /* some data left from previous update */
+            XXH_memcpy((xxh_u8*)(state->mem32) + state->memsize, input, 16-state->memsize);
+            {   const xxh_u32* p32 = state->mem32;
+                state->v[0] = XXH32_round(state->v[0], XXH_readLE32(p32)); p32++;
+                state->v[1] = XXH32_round(state->v[1], XXH_readLE32(p32)); p32++;
+                state->v[2] = XXH32_round(state->v[2], XXH_readLE32(p32)); p32++;
+                state->v[3] = XXH32_round(state->v[3], XXH_readLE32(p32));
+            }
+            p += 16-state->memsize;
+            state->memsize = 0;
+        }
+
+        if (p <= bEnd-16) {
+            const xxh_u8* const limit = bEnd - 16;
+
+            do {
+                state->v[0] = XXH32_round(state->v[0], XXH_readLE32(p)); p+=4;
+                state->v[1] = XXH32_round(state->v[1], XXH_readLE32(p)); p+=4;
+                state->v[2] = XXH32_round(state->v[2], XXH_readLE32(p)); p+=4;
+                state->v[3] = XXH32_round(state->v[3], XXH_readLE32(p)); p+=4;
+            } while (p<=limit);
+
+        }
+
+        if (p < bEnd) {
+            XXH_memcpy(state->mem32, p, (size_t)(bEnd-p));
+            state->memsize = (unsigned)(bEnd-p);
+        }
+    }
+
+    return XXH_OK;
+}
+
+
+/*! @ingroup xxh32_family */
+XXH_PUBLIC_API XXH32_hash_t XXH32_digest(const XXH32_state_t* state)
+{
+    xxh_u32 h32;
+
+    if (state->large_len) {
+        h32 = XXH_rotl32(state->v[0], 1)
+            + XXH_rotl32(state->v[1], 7)
+            + XXH_rotl32(state->v[2], 12)
+            + XXH_rotl32(state->v[3], 18);
+    } else {
+        h32 = state->v[2] /* == seed */ + XXH_PRIME32_5;
+    }
+
+    h32 += state->total_len_32;
+
+    return XXH32_finalize(h32, (const xxh_u8*)state->mem32, state->memsize, XXH_aligned);
+}
+
+
+/*******   Canonical representation   *******/
+
+/*!
+ * @ingroup xxh32_family
+ * The default return values from XXH functions are unsigned 32 and 64 bit
+ * integers.
+ *
+ * The canonical representation uses big endian convention, the same convention
+ * as human-readable numbers (large digits first).
+ *
+ * This way, hash values can be written into a file or buffer, remaining
+ * comparable across different systems.
+ *
+ * The following functions allow transformation of hash values to and from their
+ * canonical format.
+ */
+XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash)
+{
+    /* XXH_STATIC_ASSERT(sizeof(XXH32_canonical_t) == sizeof(XXH32_hash_t)); */
+    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap32(hash);
+    XXH_memcpy(dst, &hash, sizeof(*dst));
+}
+/*! @ingroup xxh32_family */
+XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src)
+{
+    return XXH_readBE32(src);
+}
+
+
+#ifndef XXH_NO_LONG_LONG
+
+/* *******************************************************************
+*  64-bit hash functions
+*********************************************************************/
+/*!
+ * @}
+ * @ingroup impl
+ * @{
+ */
+/*******   Memory access   *******/
+
+typedef XXH64_hash_t xxh_u64;
+
+#ifdef XXH_OLD_NAMES
+#  define U64 xxh_u64
+#endif
+
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+/*
+ * Manual byteshift. Best for old compilers which don't inline memcpy.
+ * We actually directly use XXH_readLE64 and XXH_readBE64.
+ */
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
+
+/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
+static xxh_u64 XXH_read64(const void* memPtr)
+{
+    return *(const xxh_u64*) memPtr;
+}
+
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
+
+/*
+ * __pack instructions are safer, but compiler specific, hence potentially
+ * problematic for some compilers.
+ *
+ * Currently only defined for GCC and ICC.
+ */
+#ifdef XXH_OLD_NAMES
+typedef union { xxh_u32 u32; xxh_u64 u64; } __attribute__((packed)) unalign64;
+#endif
+static xxh_u64 XXH_read64(const void* ptr)
+{
+    typedef union { xxh_u32 u32; xxh_u64 u64; } __attribute__((packed)) xxh_unalign64;
+    return ((const xxh_unalign64*)ptr)->u64;
+}
+
+#else
+
+/*
+ * Portable and safe solution. Generally efficient.
+ * see: https://fastcompression.blogspot.com/2015/08/accessing-unaligned-memory.html
+ */
+static xxh_u64 XXH_read64(const void* memPtr)
+{
+    xxh_u64 val;
+    XXH_memcpy(&val, memPtr, sizeof(val));
+    return val;
+}
+
+#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
+
+#if defined(_MSC_VER)     /* Visual Studio */
+#  define XXH_swap64 _byteswap_uint64
+#elif XXH_GCC_VERSION >= 403
+#  define XXH_swap64 __builtin_bswap64
+#else
+static xxh_u64 XXH_swap64(xxh_u64 x)
+{
+    return  ((x << 56) & 0xff00000000000000ULL) |
+            ((x << 40) & 0x00ff000000000000ULL) |
+            ((x << 24) & 0x0000ff0000000000ULL) |
+            ((x << 8)  & 0x000000ff00000000ULL) |
+            ((x >> 8)  & 0x00000000ff000000ULL) |
+            ((x >> 24) & 0x0000000000ff0000ULL) |
+            ((x >> 40) & 0x000000000000ff00ULL) |
+            ((x >> 56) & 0x00000000000000ffULL);
+}
+#endif
+
+
+/* XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load. */
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+
+XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[0]
+         | ((xxh_u64)bytePtr[1] << 8)
+         | ((xxh_u64)bytePtr[2] << 16)
+         | ((xxh_u64)bytePtr[3] << 24)
+         | ((xxh_u64)bytePtr[4] << 32)
+         | ((xxh_u64)bytePtr[5] << 40)
+         | ((xxh_u64)bytePtr[6] << 48)
+         | ((xxh_u64)bytePtr[7] << 56);
+}
+
+XXH_FORCE_INLINE xxh_u64 XXH_readBE64(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[7]
+         | ((xxh_u64)bytePtr[6] << 8)
+         | ((xxh_u64)bytePtr[5] << 16)
+         | ((xxh_u64)bytePtr[4] << 24)
+         | ((xxh_u64)bytePtr[3] << 32)
+         | ((xxh_u64)bytePtr[2] << 40)
+         | ((xxh_u64)bytePtr[1] << 48)
+         | ((xxh_u64)bytePtr[0] << 56);
+}
+
+#else
+XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));
+}
+
+static xxh_u64 XXH_readBE64(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap64(XXH_read64(ptr)) : XXH_read64(ptr);
+}
+#endif
+
+XXH_FORCE_INLINE xxh_u64
+XXH_readLE64_align(const void* ptr, XXH_alignment align)
+{
+    if (align==XXH_unaligned)
+        return XXH_readLE64(ptr);
+    else
+        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u64*)ptr : XXH_swap64(*(const xxh_u64*)ptr);
+}
+
+
+/*******   xxh64   *******/
+/*!
+ * @}
+ * @defgroup xxh64_impl XXH64 implementation
+ * @ingroup impl
+ * @{
+ */
+/* #define rather that static const, to be used as initializers */
+#define XXH_PRIME64_1  0x9E3779B185EBCA87ULL  /*!< 0b1001111000110111011110011011000110000101111010111100101010000111 */
+#define XXH_PRIME64_2  0xC2B2AE3D27D4EB4FULL  /*!< 0b1100001010110010101011100011110100100111110101001110101101001111 */
+#define XXH_PRIME64_3  0x165667B19E3779F9ULL  /*!< 0b0001011001010110011001111011000110011110001101110111100111111001 */
+#define XXH_PRIME64_4  0x85EBCA77C2B2AE63ULL  /*!< 0b1000010111101011110010100111011111000010101100101010111001100011 */
+#define XXH_PRIME64_5  0x27D4EB2F165667C5ULL  /*!< 0b0010011111010100111010110010111100010110010101100110011111000101 */
+
+#ifdef XXH_OLD_NAMES
+#  define PRIME64_1 XXH_PRIME64_1
+#  define PRIME64_2 XXH_PRIME64_2
+#  define PRIME64_3 XXH_PRIME64_3
+#  define PRIME64_4 XXH_PRIME64_4
+#  define PRIME64_5 XXH_PRIME64_5
+#endif
+
+static xxh_u64 XXH64_round(xxh_u64 acc, xxh_u64 input)
+{
+    acc += input * XXH_PRIME64_2;
+    acc  = XXH_rotl64(acc, 31);
+    acc *= XXH_PRIME64_1;
+    return acc;
+}
+
+static xxh_u64 XXH64_mergeRound(xxh_u64 acc, xxh_u64 val)
+{
+    val  = XXH64_round(0, val);
+    acc ^= val;
+    acc  = acc * XXH_PRIME64_1 + XXH_PRIME64_4;
+    return acc;
+}
+
+static xxh_u64 XXH64_avalanche(xxh_u64 h64)
+{
+    h64 ^= h64 >> 33;
+    h64 *= XXH_PRIME64_2;
+    h64 ^= h64 >> 29;
+    h64 *= XXH_PRIME64_3;
+    h64 ^= h64 >> 32;
+    return h64;
+}
+
+
+#define XXH_get64bits(p) XXH_readLE64_align(p, align)
+
+static xxh_u64
+XXH64_finalize(xxh_u64 h64, const xxh_u8* ptr, size_t len, XXH_alignment align)
+{
+    if (ptr==NULL) XXH_ASSERT(len == 0);
+    len &= 31;
+    while (len >= 8) {
+        xxh_u64 const k1 = XXH64_round(0, XXH_get64bits(ptr));
+        ptr += 8;
+        h64 ^= k1;
+        h64  = XXH_rotl64(h64,27) * XXH_PRIME64_1 + XXH_PRIME64_4;
+        len -= 8;
+    }
+    if (len >= 4) {
+        h64 ^= (xxh_u64)(XXH_get32bits(ptr)) * XXH_PRIME64_1;
+        ptr += 4;
+        h64 = XXH_rotl64(h64, 23) * XXH_PRIME64_2 + XXH_PRIME64_3;
+        len -= 4;
+    }
+    while (len > 0) {
+        h64 ^= (*ptr++) * XXH_PRIME64_5;
+        h64 = XXH_rotl64(h64, 11) * XXH_PRIME64_1;
+        --len;
+    }
+    return  XXH64_avalanche(h64);
+}
+
+#ifdef XXH_OLD_NAMES
+#  define PROCESS1_64 XXH_PROCESS1_64
+#  define PROCESS4_64 XXH_PROCESS4_64
+#  define PROCESS8_64 XXH_PROCESS8_64
+#else
+#  undef XXH_PROCESS1_64
+#  undef XXH_PROCESS4_64
+#  undef XXH_PROCESS8_64
+#endif
+
+XXH_FORCE_INLINE xxh_u64
+XXH64_endian_align(const xxh_u8* input, size_t len, xxh_u64 seed, XXH_alignment align)
+{
+    xxh_u64 h64;
+    if (input==NULL) XXH_ASSERT(len == 0);
+
+    if (len>=32) {
+        const xxh_u8* const bEnd = input + len;
+        const xxh_u8* const limit = bEnd - 31;
+        xxh_u64 v1 = seed + XXH_PRIME64_1 + XXH_PRIME64_2;
+        xxh_u64 v2 = seed + XXH_PRIME64_2;
+        xxh_u64 v3 = seed + 0;
+        xxh_u64 v4 = seed - XXH_PRIME64_1;
+
+        do {
+            v1 = XXH64_round(v1, XXH_get64bits(input)); input+=8;
+            v2 = XXH64_round(v2, XXH_get64bits(input)); input+=8;
+            v3 = XXH64_round(v3, XXH_get64bits(input)); input+=8;
+            v4 = XXH64_round(v4, XXH_get64bits(input)); input+=8;
+        } while (input<limit);
+
+        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
+        h64 = XXH64_mergeRound(h64, v1);
+        h64 = XXH64_mergeRound(h64, v2);
+        h64 = XXH64_mergeRound(h64, v3);
+        h64 = XXH64_mergeRound(h64, v4);
+
+    } else {
+        h64  = seed + XXH_PRIME64_5;
+    }
+
+    h64 += (xxh_u64) len;
+
+    return XXH64_finalize(h64, input, len, align);
+}
+
+
+/*! @ingroup xxh64_family */
+XXH_PUBLIC_API XXH64_hash_t XXH64 (const void* input, size_t len, XXH64_hash_t seed)
+{
+#if 0
+    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
+    XXH64_state_t state;
+    XXH64_reset(&state, seed);
+    XXH64_update(&state, (const xxh_u8*)input, len);
+    return XXH64_digest(&state);
+#else
+    if (XXH_FORCE_ALIGN_CHECK) {
+        if ((((size_t)input) & 7)==0) {  /* Input is aligned, let's leverage the speed advantage */
+            return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
+    }   }
+
+    return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);
+
+#endif
+}
+
+/*******   Hash Streaming   *******/
+
+/*! @ingroup xxh64_family*/
+XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void)
+{
+    return (XXH64_state_t*)XXH_malloc(sizeof(XXH64_state_t));
+}
+/*! @ingroup xxh64_family */
+XXH_PUBLIC_API XXH_errorcode XXH64_freeState(XXH64_state_t* statePtr)
+{
+    XXH_free(statePtr);
+    return XXH_OK;
+}
+
+/*! @ingroup xxh64_family */
+XXH_PUBLIC_API void XXH64_copyState(XXH64_state_t* dstState, const XXH64_state_t* srcState)
+{
+    XXH_memcpy(dstState, srcState, sizeof(*dstState));
+}
+
+/*! @ingroup xxh64_family */
+XXH_PUBLIC_API XXH_errorcode XXH64_reset(XXH64_state_t* statePtr, XXH64_hash_t seed)
+{
+    XXH_ASSERT(statePtr != NULL);
+    memset(statePtr, 0, sizeof(*statePtr));
+    statePtr->v[0] = seed + XXH_PRIME64_1 + XXH_PRIME64_2;
+    statePtr->v[1] = seed + XXH_PRIME64_2;
+    statePtr->v[2] = seed + 0;
+    statePtr->v[3] = seed - XXH_PRIME64_1;
+    return XXH_OK;
+}
+
+/*! @ingroup xxh64_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH64_update (XXH64_state_t* state, const void* input, size_t len)
+{
+    if (input==NULL) {
+        XXH_ASSERT(len == 0);
+        return XXH_OK;
+    }
+
+    {   const xxh_u8* p = (const xxh_u8*)input;
+        const xxh_u8* const bEnd = p + len;
+
+        state->total_len += len;
+
+        if (state->memsize + len < 32) {  /* fill in tmp buffer */
+            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, len);
+            state->memsize += (xxh_u32)len;
+            return XXH_OK;
+        }
+
+        if (state->memsize) {   /* tmp buffer is full */
+            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, 32-state->memsize);
+            state->v[0] = XXH64_round(state->v[0], XXH_readLE64(state->mem64+0));
+            state->v[1] = XXH64_round(state->v[1], XXH_readLE64(state->mem64+1));
+            state->v[2] = XXH64_round(state->v[2], XXH_readLE64(state->mem64+2));
+            state->v[3] = XXH64_round(state->v[3], XXH_readLE64(state->mem64+3));
+            p += 32 - state->memsize;
+            state->memsize = 0;
+        }
+
+        if (p+32 <= bEnd) {
+            const xxh_u8* const limit = bEnd - 32;
+
+            do {
+                state->v[0] = XXH64_round(state->v[0], XXH_readLE64(p)); p+=8;
+                state->v[1] = XXH64_round(state->v[1], XXH_readLE64(p)); p+=8;
+                state->v[2] = XXH64_round(state->v[2], XXH_readLE64(p)); p+=8;
+                state->v[3] = XXH64_round(state->v[3], XXH_readLE64(p)); p+=8;
+            } while (p<=limit);
+
+        }
+
+        if (p < bEnd) {
+            XXH_memcpy(state->mem64, p, (size_t)(bEnd-p));
+            state->memsize = (unsigned)(bEnd-p);
+        }
+    }
+
+    return XXH_OK;
+}
+
+
+/*! @ingroup xxh64_family */
+XXH_PUBLIC_API XXH64_hash_t XXH64_digest(const XXH64_state_t* state)
+{
+    xxh_u64 h64;
+
+    if (state->total_len >= 32) {
+        h64 = XXH_rotl64(state->v[0], 1) + XXH_rotl64(state->v[1], 7) + XXH_rotl64(state->v[2], 12) + XXH_rotl64(state->v[3], 18);
+        h64 = XXH64_mergeRound(h64, state->v[0]);
+        h64 = XXH64_mergeRound(h64, state->v[1]);
+        h64 = XXH64_mergeRound(h64, state->v[2]);
+        h64 = XXH64_mergeRound(h64, state->v[3]);
+    } else {
+        h64  = state->v[2] /*seed*/ + XXH_PRIME64_5;
+    }
+
+    h64 += (xxh_u64) state->total_len;
+
+    return XXH64_finalize(h64, (const xxh_u8*)state->mem64, (size_t)state->total_len, XXH_aligned);
+}
+
+
+/******* Canonical representation   *******/
+
+/*! @ingroup xxh64_family */
+XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash)
+{
+    /* XXH_STATIC_ASSERT(sizeof(XXH64_canonical_t) == sizeof(XXH64_hash_t)); */
+    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap64(hash);
+    XXH_memcpy(dst, &hash, sizeof(*dst));
+}
+
+/*! @ingroup xxh64_family */
+XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src)
+{
+    return XXH_readBE64(src);
+}
+
+#ifndef XXH_NO_XXH3
+
+/* *********************************************************************
+*  XXH3
+*  New generation hash designed for speed on small keys and vectorization
+************************************************************************ */
+/*!
+ * @}
+ * @defgroup xxh3_impl XXH3 implementation
+ * @ingroup impl
+ * @{
+ */
+
+/* ===   Compiler specifics   === */
+
+#if ((defined(sun) || defined(__sun)) && __cplusplus) /* Solaris includes __STDC_VERSION__ with C++. Tested with GCC 5.5 */
+#  define XXH_RESTRICT /* disable */
+#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* >= C99 */
+#  define XXH_RESTRICT   restrict
+#else
+/* Note: it might be useful to define __restrict or __restrict__ for some C++ compilers */
+#  define XXH_RESTRICT   /* disable */
+#endif
+
+#if (defined(__GNUC__) && (__GNUC__ >= 3))  \
+  || (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 800)) \
+  || defined(__clang__)
+#    define XXH_likely(x) __builtin_expect(x, 1)
+#    define XXH_unlikely(x) __builtin_expect(x, 0)
+#else
+#    define XXH_likely(x) (x)
+#    define XXH_unlikely(x) (x)
+#endif
+
+#if defined(__GNUC__) || defined(__clang__)
+#  if defined(__ARM_NEON__) || defined(__ARM_NEON) \
+   || defined(__aarch64__)  || defined(_M_ARM) \
+   || defined(_M_ARM64)     || defined(_M_ARM64EC)
+#    define inline __inline__  /* circumvent a clang bug */
+#    include <arm_neon.h>
+#    undef inline
+#  elif defined(__AVX2__)
+#    include <immintrin.h>
+#  elif defined(__SSE2__)
+#    include <emmintrin.h>
+#  endif
+#endif
+
+#if defined(_MSC_VER)
+#  include <intrin.h>
+#endif
+
+/*
+ * One goal of XXH3 is to make it fast on both 32-bit and 64-bit, while
+ * remaining a true 64-bit/128-bit hash function.
+ *
+ * This is done by prioritizing a subset of 64-bit operations that can be
+ * emulated without too many steps on the average 32-bit machine.
+ *
+ * For example, these two lines seem similar, and run equally fast on 64-bit:
+ *
+ *   xxh_u64 x;
+ *   x ^= (x >> 47); // good
+ *   x ^= (x >> 13); // bad
+ *
+ * However, to a 32-bit machine, there is a major difference.
+ *
+ * x ^= (x >> 47) looks like this:
+ *
+ *   x.lo ^= (x.hi >> (47 - 32));
+ *
+ * while x ^= (x >> 13) looks like this:
+ *
+ *   // note: funnel shifts are not usually cheap.
+ *   x.lo ^= (x.lo >> 13) | (x.hi << (32 - 13));
+ *   x.hi ^= (x.hi >> 13);
+ *
+ * The first one is significantly faster than the second, simply because the
+ * shift is larger than 32. This means:
+ *  - All the bits we need are in the upper 32 bits, so we can ignore the lower
+ *    32 bits in the shift.
+ *  - The shift result will always fit in the lower 32 bits, and therefore,
+ *    we can ignore the upper 32 bits in the xor.
+ *
+ * Thanks to this optimization, XXH3 only requires these features to be efficient:
+ *
+ *  - Usable unaligned access
+ *  - A 32-bit or 64-bit ALU
+ *      - If 32-bit, a decent ADC instruction
+ *  - A 32 or 64-bit multiply with a 64-bit result
+ *  - For the 128-bit variant, a decent byteswap helps short inputs.
+ *
+ * The first two are already required by XXH32, and almost all 32-bit and 64-bit
+ * platforms which can run XXH32 can run XXH3 efficiently.
+ *
+ * Thumb-1, the classic 16-bit only subset of ARM's instruction set, is one
+ * notable exception.
+ *
+ * First of all, Thumb-1 lacks support for the UMULL instruction which
+ * performs the important long multiply. This means numerous __aeabi_lmul
+ * calls.
+ *
+ * Second of all, the 8 functional registers are just not enough.
+ * Setup for __aeabi_lmul, byteshift loads, pointers, and all arithmetic need
+ * Lo registers, and this shuffling results in thousands more MOVs than A32.
+ *
+ * A32 and T32 don't have this limitation. They can access all 14 registers,
+ * do a 32->64 multiply with UMULL, and the flexible operand allowing free
+ * shifts is helpful, too.
+ *
+ * Therefore, we do a quick sanity check.
+ *
+ * If compiling Thumb-1 for a target which supports ARM instructions, we will
+ * emit a warning, as it is not a "sane" platform to compile for.
+ *
+ * Usually, if this happens, it is because of an accident and you probably need
+ * to specify -march, as you likely meant to compile for a newer architecture.
+ *
+ * Credit: large sections of the vectorial and asm source code paths
+ *         have been contributed by @easyaspi314
+ */
+#if defined(__thumb__) && !defined(__thumb2__) && defined(__ARM_ARCH_ISA_ARM)
+#   warning "XXH3 is highly inefficient without ARM or Thumb-2."
+#endif
+
+/* ==========================================
+ * Vectorization detection
+ * ========================================== */
+
+#ifdef XXH_DOXYGEN
+/*!
+ * @ingroup tuning
+ * @brief Overrides the vectorization implementation chosen for XXH3.
+ *
+ * Can be defined to 0 to disable SIMD or any of the values mentioned in
+ * @ref XXH_VECTOR_TYPE.
+ *
+ * If this is not defined, it uses predefined macros to determine the best
+ * implementation.
+ */
+#  define XXH_VECTOR XXH_SCALAR
+/*!
+ * @ingroup tuning
+ * @brief Possible values for @ref XXH_VECTOR.
+ *
+ * Note that these are actually implemented as macros.
+ *
+ * If this is not defined, it is detected automatically.
+ * @ref XXH_X86DISPATCH overrides this.
+ */
+enum XXH_VECTOR_TYPE /* fake enum */ {
+    XXH_SCALAR = 0,  /*!< Portable scalar version */
+    XXH_SSE2   = 1,  /*!<
+                      * SSE2 for Pentium 4, Opteron, all x86_64.
+                      *
+                      * @note SSE2 is also guaranteed on Windows 10, macOS, and
+                      * Android x86.
+                      */
+    XXH_AVX2   = 2,  /*!< AVX2 for Haswell and Bulldozer */
+    XXH_AVX512 = 3,  /*!< AVX512 for Skylake and Icelake */
+    XXH_NEON   = 4,  /*!< NEON for most ARMv7-A and all AArch64 */
+    XXH_VSX    = 5,  /*!< VSX and ZVector for POWER8/z13 (64-bit) */
+};
+/*!
+ * @ingroup tuning
+ * @brief Selects the minimum alignment for XXH3's accumulators.
+ *
+ * When using SIMD, this should match the alignment required for said vector
+ * type, so, for example, 32 for AVX2.
+ *
+ * Default: Auto detected.
+ */
+#  define XXH_ACC_ALIGN 8
+#endif
+
+/* Actual definition */
+#ifndef XXH_DOXYGEN
+#  define XXH_SCALAR 0
+#  define XXH_SSE2   1
+#  define XXH_AVX2   2
+#  define XXH_AVX512 3
+#  define XXH_NEON   4
+#  define XXH_VSX    5
+#endif
+
+#ifndef XXH_VECTOR    /* can be defined on command line */
+#  if ( \
+        defined(__ARM_NEON__) || defined(__ARM_NEON) /* gcc */ \
+     || defined(_M_ARM) || defined(_M_ARM64) || defined(_M_ARM64EC) /* msvc */ \
+   ) && ( \
+        defined(_WIN32) || defined(__LITTLE_ENDIAN__) /* little endian only */ \
+    || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) \
+   )
+#    define XXH_VECTOR XXH_NEON
+#  elif defined(__AVX512F__)
+#    define XXH_VECTOR XXH_AVX512
+#  elif defined(__AVX2__)
+#    define XXH_VECTOR XXH_AVX2
+#  elif defined(__SSE2__) || defined(_M_AMD64) || defined(_M_X64) || (defined(_M_IX86_FP) && (_M_IX86_FP == 2))
+#    define XXH_VECTOR XXH_SSE2
+#  elif (defined(__PPC64__) && defined(__POWER8_VECTOR__)) \
+     || (defined(__s390x__) && defined(__VEC__)) \
+     && defined(__GNUC__) /* TODO: IBM XL */
+#    define XXH_VECTOR XXH_VSX
+#  else
+#    define XXH_VECTOR XXH_SCALAR
+#  endif
+#endif
+
+/*
+ * Controls the alignment of the accumulator,
+ * for compatibility with aligned vector loads, which are usually faster.
+ */
+#ifndef XXH_ACC_ALIGN
+#  if defined(XXH_X86DISPATCH)
+#     define XXH_ACC_ALIGN 64  /* for compatibility with avx512 */
+#  elif XXH_VECTOR == XXH_SCALAR  /* scalar */
+#     define XXH_ACC_ALIGN 8
+#  elif XXH_VECTOR == XXH_SSE2  /* sse2 */
+#     define XXH_ACC_ALIGN 16
+#  elif XXH_VECTOR == XXH_AVX2  /* avx2 */
+#     define XXH_ACC_ALIGN 32
+#  elif XXH_VECTOR == XXH_NEON  /* neon */
+#     define XXH_ACC_ALIGN 16
+#  elif XXH_VECTOR == XXH_VSX   /* vsx */
+#     define XXH_ACC_ALIGN 16
+#  elif XXH_VECTOR == XXH_AVX512  /* avx512 */
+#     define XXH_ACC_ALIGN 64
+#  endif
+#endif
+
+#if defined(XXH_X86DISPATCH) || XXH_VECTOR == XXH_SSE2 \
+    || XXH_VECTOR == XXH_AVX2 || XXH_VECTOR == XXH_AVX512
+#  define XXH_SEC_ALIGN XXH_ACC_ALIGN
+#else
+#  define XXH_SEC_ALIGN 8
+#endif
+
+/*
+ * UGLY HACK:
+ * GCC usually generates the best code with -O3 for xxHash.
+ *
+ * However, when targeting AVX2, it is overzealous in its unrolling resulting
+ * in code roughly 3/4 the speed of Clang.
+ *
+ * There are other issues, such as GCC splitting _mm256_loadu_si256 into
+ * _mm_loadu_si128 + _mm256_inserti128_si256. This is an optimization which
+ * only applies to Sandy and Ivy Bridge... which don't even support AVX2.
+ *
+ * That is why when compiling the AVX2 version, it is recommended to use either
+ *   -O2 -mavx2 -march=haswell
+ * or
+ *   -O2 -mavx2 -mno-avx256-split-unaligned-load
+ * for decent performance, or to use Clang instead.
+ *
+ * Fortunately, we can control the first one with a pragma that forces GCC into
+ * -O2, but the other one we can't control without "failed to inline always
+ * inline function due to target mismatch" warnings.
+ */
+#if XXH_VECTOR == XXH_AVX2 /* AVX2 */ \
+  && defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
+  && defined(__OPTIMIZE__) && !defined(__OPTIMIZE_SIZE__) /* respect -O0 and -Os */
+#  pragma GCC push_options
+#  pragma GCC optimize("-O2")
+#endif
+
+
+#if XXH_VECTOR == XXH_NEON
+/*
+ * NEON's setup for vmlal_u32 is a little more complicated than it is on
+ * SSE2, AVX2, and VSX.
+ *
+ * While PMULUDQ and VMULEUW both perform a mask, VMLAL.U32 performs an upcast.
+ *
+ * To do the same operation, the 128-bit 'Q' register needs to be split into
+ * two 64-bit 'D' registers, performing this operation::
+ *
+ *   [                a                 |                 b                ]
+ *            |              '---------. .--------'                |
+ *            |                         x                          |
+ *            |              .---------' '--------.                |
+ *   [ a & 0xFFFFFFFF | b & 0xFFFFFFFF ],[    a >> 32     |     b >> 32    ]
+ *
+ * Due to significant changes in aarch64, the fastest method for aarch64 is
+ * completely different than the fastest method for ARMv7-A.
+ *
+ * ARMv7-A treats D registers as unions overlaying Q registers, so modifying
+ * D11 will modify the high half of Q5. This is similar to how modifying AH
+ * will only affect bits 8-15 of AX on x86.
+ *
+ * VZIP takes two registers, and puts even lanes in one register and odd lanes
+ * in the other.
+ *
+ * On ARMv7-A, this strangely modifies both parameters in place instead of
+ * taking the usual 3-operand form.
+ *
+ * Therefore, if we want to do this, we can simply use a D-form VZIP.32 on the
+ * lower and upper halves of the Q register to end up with the high and low
+ * halves where we want - all in one instruction.
+ *
+ *   vzip.32   d10, d11       @ d10 = { d10[0], d11[0] }; d11 = { d10[1], d11[1] }
+ *
+ * Unfortunately we need inline assembly for this: Instructions modifying two
+ * registers at once is not possible in GCC or Clang's IR, and they have to
+ * create a copy.
+ *
+ * aarch64 requires a different approach.
+ *
+ * In order to make it easier to write a decent compiler for aarch64, many
+ * quirks were removed, such as conditional execution.
+ *
+ * NEON was also affected by this.
+ *
+ * aarch64 cannot access the high bits of a Q-form register, and writes to a
+ * D-form register zero the high bits, similar to how writes to W-form scalar
+ * registers (or DWORD registers on x86_64) work.
+ *
+ * The formerly free vget_high intrinsics now require a vext (with a few
+ * exceptions)
+ *
+ * Additionally, VZIP was replaced by ZIP1 and ZIP2, which are the equivalent
+ * of PUNPCKL* and PUNPCKH* in SSE, respectively, in order to only modify one
+ * operand.
+ *
+ * The equivalent of the VZIP.32 on the lower and upper halves would be this
+ * mess:
+ *
+ *   ext     v2.4s, v0.4s, v0.4s, #2 // v2 = { v0[2], v0[3], v0[0], v0[1] }
+ *   zip1    v1.2s, v0.2s, v2.2s     // v1 = { v0[0], v2[0] }
+ *   zip2    v0.2s, v0.2s, v1.2s     // v0 = { v0[1], v2[1] }
+ *
+ * Instead, we use a literal downcast, vmovn_u64 (XTN), and vshrn_n_u64 (SHRN):
+ *
+ *   shrn    v1.2s, v0.2d, #32  // v1 = (uint32x2_t)(v0 >> 32);
+ *   xtn     v0.2s, v0.2d       // v0 = (uint32x2_t)(v0 & 0xFFFFFFFF);
+ *
+ * This is available on ARMv7-A, but is less efficient than a single VZIP.32.
+ */
+
+/*!
+ * Function-like macro:
+ * void XXH_SPLIT_IN_PLACE(uint64x2_t &in, uint32x2_t &outLo, uint32x2_t &outHi)
+ * {
+ *     outLo = (uint32x2_t)(in & 0xFFFFFFFF);
+ *     outHi = (uint32x2_t)(in >> 32);
+ *     in = UNDEFINED;
+ * }
+ */
+# if !defined(XXH_NO_VZIP_HACK) /* define to disable */ \
+   && (defined(__GNUC__) || defined(__clang__)) \
+   && (defined(__arm__) || defined(__thumb__) || defined(_M_ARM))
+#  define XXH_SPLIT_IN_PLACE(in, outLo, outHi)                                              \
+    do {                                                                                    \
+      /* Undocumented GCC/Clang operand modifier: %e0 = lower D half, %f0 = upper D half */ \
+      /* https://github.com/gcc-mirror/gcc/blob/38cf91e5/gcc/config/arm/arm.c#L22486 */     \
+      /* https://github.com/llvm-mirror/llvm/blob/2c4ca683/lib/Target/ARM/ARMAsmPrinter.cpp#L399 */ \
+      __asm__("vzip.32  %e0, %f0" : "+w" (in));                                             \
+      (outLo) = vget_low_u32 (vreinterpretq_u32_u64(in));                                   \
+      (outHi) = vget_high_u32(vreinterpretq_u32_u64(in));                                   \
+   } while (0)
+# else
+#  define XXH_SPLIT_IN_PLACE(in, outLo, outHi)                                            \
+    do {                                                                                  \
+      (outLo) = vmovn_u64    (in);                                                        \
+      (outHi) = vshrn_n_u64  ((in), 32);                                                  \
+    } while (0)
+# endif
+
+/*!
+ * @ingroup tuning
+ * @brief Controls the NEON to scalar ratio for XXH3
+ *
+ * On AArch64 when not optimizing for size, XXH3 will run 6 lanes using NEON and
+ * 2 lanes on scalar by default.
+ *
+ * This can be set to 2, 4, 6, or 8. ARMv7 will default to all 8 NEON lanes, as the
+ * emulated 64-bit arithmetic is too slow.
+ *
+ * Modern ARM CPUs are _very_ sensitive to how their pipelines are used.
+ *
+ * For example, the Cortex-A73 can dispatch 3 micro-ops per cycle, but it can't
+ * have more than 2 NEON (F0/F1) micro-ops. If you are only using NEON instructions,
+ * you are only using 2/3 of the CPU bandwidth.
+ *
+ * This is even more noticeable on the more advanced cores like the A76 which
+ * can dispatch 8 micro-ops per cycle, but still only 2 NEON micro-ops at once.
+ *
+ * Therefore, @ref XXH3_NEON_LANES lanes will be processed using NEON, and the
+ * remaining lanes will use scalar instructions. This improves the bandwidth
+ * and also gives the integer pipelines something to do besides twiddling loop
+ * counters and pointers.
+ *
+ * This change benefits CPUs with large micro-op buffers without negatively affecting
+ * other CPUs:
+ *
+ *  | Chipset               | Dispatch type       | NEON only | 6:2 hybrid | Diff. |
+ *  |:----------------------|:--------------------|----------:|-----------:|------:|
+ *  | Snapdragon 730 (A76)  | 2 NEON/8 micro-ops  |  8.8 GB/s |  10.1 GB/s |  ~16% |
+ *  | Snapdragon 835 (A73)  | 2 NEON/3 micro-ops  |  5.1 GB/s |   5.3 GB/s |   ~5% |
+ *  | Marvell PXA1928 (A53) | In-order dual-issue |  1.9 GB/s |   1.9 GB/s |    0% |
+ *
+ * It also seems to fix some bad codegen on GCC, making it almost as fast as clang.
+ *
+ * @see XXH3_accumulate_512_neon()
+ */
+# ifndef XXH3_NEON_LANES
+#  if (defined(__aarch64__) || defined(__arm64__) || defined(_M_ARM64) || defined(_M_ARM64EC)) \
+   && !defined(__OPTIMIZE_SIZE__)
+#   define XXH3_NEON_LANES 6
+#  else
+#   define XXH3_NEON_LANES XXH_ACC_NB
+#  endif
+# endif
+#endif  /* XXH_VECTOR == XXH_NEON */
+
+/*
+ * VSX and Z Vector helpers.
+ *
+ * This is very messy, and any pull requests to clean this up are welcome.
+ *
+ * There are a lot of problems with supporting VSX and s390x, due to
+ * inconsistent intrinsics, spotty coverage, and multiple endiannesses.
+ */
+#if XXH_VECTOR == XXH_VSX
+#  if defined(__s390x__)
+#    include <s390intrin.h>
+#  else
+/* gcc's altivec.h can have the unwanted consequence to unconditionally
+ * #define bool, vector, and pixel keywords,
+ * with bad consequences for programs already using these keywords for other purposes.
+ * The paragraph defining these macros is skipped when __APPLE_ALTIVEC__ is defined.
+ * __APPLE_ALTIVEC__ is _generally_ defined automatically by the compiler,
+ * but it seems that, in some cases, it isn't.
+ * Force the build macro to be defined, so that keywords are not altered.
+ */
+#    if defined(__GNUC__) && !defined(__APPLE_ALTIVEC__)
+#      define __APPLE_ALTIVEC__
+#    endif
+#    include <altivec.h>
+#  endif
+
+typedef __vector unsigned long long xxh_u64x2;
+typedef __vector unsigned char xxh_u8x16;
+typedef __vector unsigned xxh_u32x4;
+
+# ifndef XXH_VSX_BE
+#  if defined(__BIG_ENDIAN__) \
+  || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
+#    define XXH_VSX_BE 1
+#  elif defined(__VEC_ELEMENT_REG_ORDER__) && __VEC_ELEMENT_REG_ORDER__ == __ORDER_BIG_ENDIAN__
+#    warning "-maltivec=be is not recommended. Please use native endianness."
+#    define XXH_VSX_BE 1
+#  else
+#    define XXH_VSX_BE 0
+#  endif
+# endif /* !defined(XXH_VSX_BE) */
+
+# if XXH_VSX_BE
+#  if defined(__POWER9_VECTOR__) || (defined(__clang__) && defined(__s390x__))
+#    define XXH_vec_revb vec_revb
+#  else
+/*!
+ * A polyfill for POWER9's vec_revb().
+ */
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_revb(xxh_u64x2 val)
+{
+    xxh_u8x16 const vByteSwap = { 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,
+                                  0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08 };
+    return vec_perm(val, val, vByteSwap);
+}
+#  endif
+# endif /* XXH_VSX_BE */
+
+/*!
+ * Performs an unaligned vector load and byte swaps it on big endian.
+ */
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_loadu(const void *ptr)
+{
+    xxh_u64x2 ret;
+    XXH_memcpy(&ret, ptr, sizeof(xxh_u64x2));
+# if XXH_VSX_BE
+    ret = XXH_vec_revb(ret);
+# endif
+    return ret;
+}
+
+/*
+ * vec_mulo and vec_mule are very problematic intrinsics on PowerPC
+ *
+ * These intrinsics weren't added until GCC 8, despite existing for a while,
+ * and they are endian dependent. Also, their meaning swap depending on version.
+ * */
+# if defined(__s390x__)
+ /* s390x is always big endian, no issue on this platform */
+#  define XXH_vec_mulo vec_mulo
+#  define XXH_vec_mule vec_mule
+# elif defined(__clang__) && XXH_HAS_BUILTIN(__builtin_altivec_vmuleuw)
+/* Clang has a better way to control this, we can just use the builtin which doesn't swap. */
+#  define XXH_vec_mulo __builtin_altivec_vmulouw
+#  define XXH_vec_mule __builtin_altivec_vmuleuw
+# else
+/* gcc needs inline assembly */
+/* Adapted from https://github.com/google/highwayhash/blob/master/highwayhash/hh_vsx.h. */
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mulo(xxh_u32x4 a, xxh_u32x4 b)
+{
+    xxh_u64x2 result;
+    __asm__("vmulouw %0, %1, %2" : "=v" (result) : "v" (a), "v" (b));
+    return result;
+}
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mule(xxh_u32x4 a, xxh_u32x4 b)
+{
+    xxh_u64x2 result;
+    __asm__("vmuleuw %0, %1, %2" : "=v" (result) : "v" (a), "v" (b));
+    return result;
+}
+# endif /* XXH_vec_mulo, XXH_vec_mule */
+#endif /* XXH_VECTOR == XXH_VSX */
+
+
+/* prefetch
+ * can be disabled, by declaring XXH_NO_PREFETCH build macro */
+#if defined(XXH_NO_PREFETCH)
+#  define XXH_PREFETCH(ptr)  (void)(ptr)  /* disabled */
+#else
+#  if defined(_MSC_VER) && (defined(_M_X64) || defined(_M_IX86))  /* _mm_prefetch() not defined outside of x86/x64 */
+#    include <mmintrin.h>   /* https://msdn.microsoft.com/fr-fr/library/84szxsww(v=vs.90).aspx */
+#    define XXH_PREFETCH(ptr)  _mm_prefetch((const char*)(ptr), _MM_HINT_T0)
+#  elif defined(__GNUC__) && ( (__GNUC__ >= 4) || ( (__GNUC__ == 3) && (__GNUC_MINOR__ >= 1) ) )
+#    define XXH_PREFETCH(ptr)  __builtin_prefetch((ptr), 0 /* rw==read */, 3 /* locality */)
+#  else
+#    define XXH_PREFETCH(ptr) (void)(ptr)  /* disabled */
+#  endif
+#endif  /* XXH_NO_PREFETCH */
+
+
+/* ==========================================
+ * XXH3 default settings
+ * ========================================== */
+
+#define XXH_SECRET_DEFAULT_SIZE 192   /* minimum XXH3_SECRET_SIZE_MIN */
+
+#if (XXH_SECRET_DEFAULT_SIZE < XXH3_SECRET_SIZE_MIN)
+#  error "default keyset is not large enough"
+#endif
+
+/*! Pseudorandom secret taken directly from FARSH. */
+XXH_ALIGN(64) static const xxh_u8 XXH3_kSecret[XXH_SECRET_DEFAULT_SIZE] = {
+    0xb8, 0xfe, 0x6c, 0x39, 0x23, 0xa4, 0x4b, 0xbe, 0x7c, 0x01, 0x81, 0x2c, 0xf7, 0x21, 0xad, 0x1c,
+    0xde, 0xd4, 0x6d, 0xe9, 0x83, 0x90, 0x97, 0xdb, 0x72, 0x40, 0xa4, 0xa4, 0xb7, 0xb3, 0x67, 0x1f,
+    0xcb, 0x79, 0xe6, 0x4e, 0xcc, 0xc0, 0xe5, 0x78, 0x82, 0x5a, 0xd0, 0x7d, 0xcc, 0xff, 0x72, 0x21,
+    0xb8, 0x08, 0x46, 0x74, 0xf7, 0x43, 0x24, 0x8e, 0xe0, 0x35, 0x90, 0xe6, 0x81, 0x3a, 0x26, 0x4c,
+    0x3c, 0x28, 0x52, 0xbb, 0x91, 0xc3, 0x00, 0xcb, 0x88, 0xd0, 0x65, 0x8b, 0x1b, 0x53, 0x2e, 0xa3,
+    0x71, 0x64, 0x48, 0x97, 0xa2, 0x0d, 0xf9, 0x4e, 0x38, 0x19, 0xef, 0x46, 0xa9, 0xde, 0xac, 0xd8,
+    0xa8, 0xfa, 0x76, 0x3f, 0xe3, 0x9c, 0x34, 0x3f, 0xf9, 0xdc, 0xbb, 0xc7, 0xc7, 0x0b, 0x4f, 0x1d,
+    0x8a, 0x51, 0xe0, 0x4b, 0xcd, 0xb4, 0x59, 0x31, 0xc8, 0x9f, 0x7e, 0xc9, 0xd9, 0x78, 0x73, 0x64,
+    0xea, 0xc5, 0xac, 0x83, 0x34, 0xd3, 0xeb, 0xc3, 0xc5, 0x81, 0xa0, 0xff, 0xfa, 0x13, 0x63, 0xeb,
+    0x17, 0x0d, 0xdd, 0x51, 0xb7, 0xf0, 0xda, 0x49, 0xd3, 0x16, 0x55, 0x26, 0x29, 0xd4, 0x68, 0x9e,
+    0x2b, 0x16, 0xbe, 0x58, 0x7d, 0x47, 0xa1, 0xfc, 0x8f, 0xf8, 0xb8, 0xd1, 0x7a, 0xd0, 0x31, 0xce,
+    0x45, 0xcb, 0x3a, 0x8f, 0x95, 0x16, 0x04, 0x28, 0xaf, 0xd7, 0xfb, 0xca, 0xbb, 0x4b, 0x40, 0x7e,
+};
+
+
+#ifdef XXH_OLD_NAMES
+#  define kSecret XXH3_kSecret
+#endif
+
+#ifdef XXH_DOXYGEN
+/*!
+ * @brief Calculates a 32-bit to 64-bit long multiply.
+ *
+ * Implemented as a macro.
+ *
+ * Wraps `__emulu` on MSVC x86 because it tends to call `__allmul` when it doesn't
+ * need to (but it shouldn't need to anyways, it is about 7 instructions to do
+ * a 64x64 multiply...). Since we know that this will _always_ emit `MULL`, we
+ * use that instead of the normal method.
+ *
+ * If you are compiling for platforms like Thumb-1 and don't have a better option,
+ * you may also want to write your own long multiply routine here.
+ *
+ * @param x, y Numbers to be multiplied
+ * @return 64-bit product of the low 32 bits of @p x and @p y.
+ */
+XXH_FORCE_INLINE xxh_u64
+XXH_mult32to64(xxh_u64 x, xxh_u64 y)
+{
+   return (x & 0xFFFFFFFF) * (y & 0xFFFFFFFF);
+}
+#elif defined(_MSC_VER) && defined(_M_IX86)
+#    define XXH_mult32to64(x, y) __emulu((unsigned)(x), (unsigned)(y))
+#else
+/*
+ * Downcast + upcast is usually better than masking on older compilers like
+ * GCC 4.2 (especially 32-bit ones), all without affecting newer compilers.
+ *
+ * The other method, (x & 0xFFFFFFFF) * (y & 0xFFFFFFFF), will AND both operands
+ * and perform a full 64x64 multiply -- entirely redundant on 32-bit.
+ */
+#    define XXH_mult32to64(x, y) ((xxh_u64)(xxh_u32)(x) * (xxh_u64)(xxh_u32)(y))
+#endif
+
+/*!
+ * @brief Calculates a 64->128-bit long multiply.
+ *
+ * Uses `__uint128_t` and `_umul128` if available, otherwise uses a scalar
+ * version.
+ *
+ * @param lhs , rhs The 64-bit integers to be multiplied
+ * @return The 128-bit result represented in an @ref XXH128_hash_t.
+ */
+static XXH128_hash_t
+XXH_mult64to128(xxh_u64 lhs, xxh_u64 rhs)
+{
+    /*
+     * GCC/Clang __uint128_t method.
+     *
+     * On most 64-bit targets, GCC and Clang define a __uint128_t type.
+     * This is usually the best way as it usually uses a native long 64-bit
+     * multiply, such as MULQ on x86_64 or MUL + UMULH on aarch64.
+     *
+     * Usually.
+     *
+     * Despite being a 32-bit platform, Clang (and emscripten) define this type
+     * despite not having the arithmetic for it. This results in a laggy
+     * compiler builtin call which calculates a full 128-bit multiply.
+     * In that case it is best to use the portable one.
+     * https://github.com/Cyan4973/xxHash/issues/211#issuecomment-515575677
+     */
+#if (defined(__GNUC__) || defined(__clang__)) && !defined(__wasm__) \
+    && defined(__SIZEOF_INT128__) \
+    || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 128)
+
+    __uint128_t const product = (__uint128_t)lhs * (__uint128_t)rhs;
+    XXH128_hash_t r128;
+    r128.low64  = (xxh_u64)(product);
+    r128.high64 = (xxh_u64)(product >> 64);
+    return r128;
+
+    /*
+     * MSVC for x64's _umul128 method.
+     *
+     * xxh_u64 _umul128(xxh_u64 Multiplier, xxh_u64 Multiplicand, xxh_u64 *HighProduct);
+     *
+     * This compiles to single operand MUL on x64.
+     */
+#elif (defined(_M_X64) || defined(_M_IA64)) && !defined(_M_ARM64EC)
+
+#ifndef _MSC_VER
+#   pragma intrinsic(_umul128)
+#endif
+    xxh_u64 product_high;
+    xxh_u64 const product_low = _umul128(lhs, rhs, &product_high);
+    XXH128_hash_t r128;
+    r128.low64  = product_low;
+    r128.high64 = product_high;
+    return r128;
+
+    /*
+     * MSVC for ARM64's __umulh method.
+     *
+     * This compiles to the same MUL + UMULH as GCC/Clang's __uint128_t method.
+     */
+#elif defined(_M_ARM64) || defined(_M_ARM64EC)
+
+#ifndef _MSC_VER
+#   pragma intrinsic(__umulh)
+#endif
+    XXH128_hash_t r128;
+    r128.low64  = lhs * rhs;
+    r128.high64 = __umulh(lhs, rhs);
+    return r128;
+
+#else
+    /*
+     * Portable scalar method. Optimized for 32-bit and 64-bit ALUs.
+     *
+     * This is a fast and simple grade school multiply, which is shown below
+     * with base 10 arithmetic instead of base 0x100000000.
+     *
+     *           9 3 // D2 lhs = 93
+     *         x 7 5 // D2 rhs = 75
+     *     ----------
+     *           1 5 // D2 lo_lo = (93 % 10) * (75 % 10) = 15
+     *         4 5 | // D2 hi_lo = (93 / 10) * (75 % 10) = 45
+     *         2 1 | // D2 lo_hi = (93 % 10) * (75 / 10) = 21
+     *     + 6 3 | | // D2 hi_hi = (93 / 10) * (75 / 10) = 63
+     *     ---------
+     *         2 7 | // D2 cross = (15 / 10) + (45 % 10) + 21 = 27
+     *     + 6 7 | | // D2 upper = (27 / 10) + (45 / 10) + 63 = 67
+     *     ---------
+     *       6 9 7 5 // D4 res = (27 * 10) + (15 % 10) + (67 * 100) = 6975
+     *
+     * The reasons for adding the products like this are:
+     *  1. It avoids manual carry tracking. Just like how
+     *     (9 * 9) + 9 + 9 = 99, the same applies with this for UINT64_MAX.
+     *     This avoids a lot of complexity.
+     *
+     *  2. It hints for, and on Clang, compiles to, the powerful UMAAL
+     *     instruction available in ARM's Digital Signal Processing extension
+     *     in 32-bit ARMv6 and later, which is shown below:
+     *
+     *         void UMAAL(xxh_u32 *RdLo, xxh_u32 *RdHi, xxh_u32 Rn, xxh_u32 Rm)
+     *         {
+     *             xxh_u64 product = (xxh_u64)*RdLo * (xxh_u64)*RdHi + Rn + Rm;
+     *             *RdLo = (xxh_u32)(product & 0xFFFFFFFF);
+     *             *RdHi = (xxh_u32)(product >> 32);
+     *         }
+     *
+     *     This instruction was designed for efficient long multiplication, and
+     *     allows this to be calculated in only 4 instructions at speeds
+     *     comparable to some 64-bit ALUs.
+     *
+     *  3. It isn't terrible on other platforms. Usually this will be a couple
+     *     of 32-bit ADD/ADCs.
+     */
+
+    /* First calculate all of the cross products. */
+    xxh_u64 const lo_lo = XXH_mult32to64(lhs & 0xFFFFFFFF, rhs & 0xFFFFFFFF);
+    xxh_u64 const hi_lo = XXH_mult32to64(lhs >> 32,        rhs & 0xFFFFFFFF);
+    xxh_u64 const lo_hi = XXH_mult32to64(lhs & 0xFFFFFFFF, rhs >> 32);
+    xxh_u64 const hi_hi = XXH_mult32to64(lhs >> 32,        rhs >> 32);
+
+    /* Now add the products together. These will never overflow. */
+    xxh_u64 const cross = (lo_lo >> 32) + (hi_lo & 0xFFFFFFFF) + lo_hi;
+    xxh_u64 const upper = (hi_lo >> 32) + (cross >> 32)        + hi_hi;
+    xxh_u64 const lower = (cross << 32) | (lo_lo & 0xFFFFFFFF);
+
+    XXH128_hash_t r128;
+    r128.low64  = lower;
+    r128.high64 = upper;
+    return r128;
+#endif
+}
+
+/*!
+ * @brief Calculates a 64-bit to 128-bit multiply, then XOR folds it.
+ *
+ * The reason for the separate function is to prevent passing too many structs
+ * around by value. This will hopefully inline the multiply, but we don't force it.
+ *
+ * @param lhs , rhs The 64-bit integers to multiply
+ * @return The low 64 bits of the product XOR'd by the high 64 bits.
+ * @see XXH_mult64to128()
+ */
+static xxh_u64
+XXH3_mul128_fold64(xxh_u64 lhs, xxh_u64 rhs)
+{
+    XXH128_hash_t product = XXH_mult64to128(lhs, rhs);
+    return product.low64 ^ product.high64;
+}
+
+/*! Seems to produce slightly better code on GCC for some reason. */
+XXH_FORCE_INLINE xxh_u64 XXH_xorshift64(xxh_u64 v64, int shift)
+{
+    XXH_ASSERT(0 <= shift && shift < 64);
+    return v64 ^ (v64 >> shift);
+}
+
+/*
+ * This is a fast avalanche stage,
+ * suitable when input bits are already partially mixed
+ */
+static XXH64_hash_t XXH3_avalanche(xxh_u64 h64)
+{
+    h64 = XXH_xorshift64(h64, 37);
+    h64 *= 0x165667919E3779F9ULL;
+    h64 = XXH_xorshift64(h64, 32);
+    return h64;
+}
+
+/*
+ * This is a stronger avalanche,
+ * inspired by Pelle Evensen's rrmxmx
+ * preferable when input has not been previously mixed
+ */
+static XXH64_hash_t XXH3_rrmxmx(xxh_u64 h64, xxh_u64 len)
+{
+    /* this mix is inspired by Pelle Evensen's rrmxmx */
+    h64 ^= XXH_rotl64(h64, 49) ^ XXH_rotl64(h64, 24);
+    h64 *= 0x9FB21C651E98DF25ULL;
+    h64 ^= (h64 >> 35) + len ;
+    h64 *= 0x9FB21C651E98DF25ULL;
+    return XXH_xorshift64(h64, 28);
+}
+
+
+/* ==========================================
+ * Short keys
+ * ==========================================
+ * One of the shortcomings of XXH32 and XXH64 was that their performance was
+ * sub-optimal on short lengths. It used an iterative algorithm which strongly
+ * favored lengths that were a multiple of 4 or 8.
+ *
+ * Instead of iterating over individual inputs, we use a set of single shot
+ * functions which piece together a range of lengths and operate in constant time.
+ *
+ * Additionally, the number of multiplies has been significantly reduced. This
+ * reduces latency, especially when emulating 64-bit multiplies on 32-bit.
+ *
+ * Depending on the platform, this may or may not be faster than XXH32, but it
+ * is almost guaranteed to be faster than XXH64.
+ */
+
+/*
+ * At very short lengths, there isn't enough input to fully hide secrets, or use
+ * the entire secret.
+ *
+ * There is also only a limited amount of mixing we can do before significantly
+ * impacting performance.
+ *
+ * Therefore, we use different sections of the secret and always mix two secret
+ * samples with an XOR. This should have no effect on performance on the
+ * seedless or withSeed variants because everything _should_ be constant folded
+ * by modern compilers.
+ *
+ * The XOR mixing hides individual parts of the secret and increases entropy.
+ *
+ * This adds an extra layer of strength for custom secrets.
+ */
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_len_1to3_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(1 <= len && len <= 3);
+    XXH_ASSERT(secret != NULL);
+    /*
+     * len = 1: combined = { input[0], 0x01, input[0], input[0] }
+     * len = 2: combined = { input[1], 0x02, input[0], input[1] }
+     * len = 3: combined = { input[2], 0x03, input[0], input[1] }
+     */
+    {   xxh_u8  const c1 = input[0];
+        xxh_u8  const c2 = input[len >> 1];
+        xxh_u8  const c3 = input[len - 1];
+        xxh_u32 const combined = ((xxh_u32)c1 << 16) | ((xxh_u32)c2  << 24)
+                               | ((xxh_u32)c3 <<  0) | ((xxh_u32)len << 8);
+        xxh_u64 const bitflip = (XXH_readLE32(secret) ^ XXH_readLE32(secret+4)) + seed;
+        xxh_u64 const keyed = (xxh_u64)combined ^ bitflip;
+        return XXH64_avalanche(keyed);
+    }
+}
+
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_len_4to8_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(secret != NULL);
+    XXH_ASSERT(4 <= len && len <= 8);
+    seed ^= (xxh_u64)XXH_swap32((xxh_u32)seed) << 32;
+    {   xxh_u32 const input1 = XXH_readLE32(input);
+        xxh_u32 const input2 = XXH_readLE32(input + len - 4);
+        xxh_u64 const bitflip = (XXH_readLE64(secret+8) ^ XXH_readLE64(secret+16)) - seed;
+        xxh_u64 const input64 = input2 + (((xxh_u64)input1) << 32);
+        xxh_u64 const keyed = input64 ^ bitflip;
+        return XXH3_rrmxmx(keyed, len);
+    }
+}
+
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_len_9to16_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(secret != NULL);
+    XXH_ASSERT(9 <= len && len <= 16);
+    {   xxh_u64 const bitflip1 = (XXH_readLE64(secret+24) ^ XXH_readLE64(secret+32)) + seed;
+        xxh_u64 const bitflip2 = (XXH_readLE64(secret+40) ^ XXH_readLE64(secret+48)) - seed;
+        xxh_u64 const input_lo = XXH_readLE64(input)           ^ bitflip1;
+        xxh_u64 const input_hi = XXH_readLE64(input + len - 8) ^ bitflip2;
+        xxh_u64 const acc = len
+                          + XXH_swap64(input_lo) + input_hi
+                          + XXH3_mul128_fold64(input_lo, input_hi);
+        return XXH3_avalanche(acc);
+    }
+}
+
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_len_0to16_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(len <= 16);
+    {   if (XXH_likely(len >  8)) return XXH3_len_9to16_64b(input, len, secret, seed);
+        if (XXH_likely(len >= 4)) return XXH3_len_4to8_64b(input, len, secret, seed);
+        if (len) return XXH3_len_1to3_64b(input, len, secret, seed);
+        return XXH64_avalanche(seed ^ (XXH_readLE64(secret+56) ^ XXH_readLE64(secret+64)));
+    }
+}
+
+/*
+ * DISCLAIMER: There are known *seed-dependent* multicollisions here due to
+ * multiplication by zero, affecting hashes of lengths 17 to 240.
+ *
+ * However, they are very unlikely.
+ *
+ * Keep this in mind when using the unseeded XXH3_64bits() variant: As with all
+ * unseeded non-cryptographic hashes, it does not attempt to defend itself
+ * against specially crafted inputs, only random inputs.
+ *
+ * Compared to classic UMAC where a 1 in 2^31 chance of 4 consecutive bytes
+ * cancelling out the secret is taken an arbitrary number of times (addressed
+ * in XXH3_accumulate_512), this collision is very unlikely with random inputs
+ * and/or proper seeding:
+ *
+ * This only has a 1 in 2^63 chance of 8 consecutive bytes cancelling out, in a
+ * function that is only called up to 16 times per hash with up to 240 bytes of
+ * input.
+ *
+ * This is not too bad for a non-cryptographic hash function, especially with
+ * only 64 bit outputs.
+ *
+ * The 128-bit variant (which trades some speed for strength) is NOT affected
+ * by this, although it is always a good idea to use a proper seed if you care
+ * about strength.
+ */
+XXH_FORCE_INLINE xxh_u64 XXH3_mix16B(const xxh_u8* XXH_RESTRICT input,
+                                     const xxh_u8* XXH_RESTRICT secret, xxh_u64 seed64)
+{
+#if defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
+  && defined(__i386__) && defined(__SSE2__)  /* x86 + SSE2 */ \
+  && !defined(XXH_ENABLE_AUTOVECTORIZE)      /* Define to disable like XXH32 hack */
+    /*
+     * UGLY HACK:
+     * GCC for x86 tends to autovectorize the 128-bit multiply, resulting in
+     * slower code.
+     *
+     * By forcing seed64 into a register, we disrupt the cost model and
+     * cause it to scalarize. See `XXH32_round()`
+     *
+     * FIXME: Clang's output is still _much_ faster -- On an AMD Ryzen 3600,
+     * XXH3_64bits @ len=240 runs at 4.6 GB/s with Clang 9, but 3.3 GB/s on
+     * GCC 9.2, despite both emitting scalar code.
+     *
+     * GCC generates much better scalar code than Clang for the rest of XXH3,
+     * which is why finding a more optimal codepath is an interest.
+     */
+    XXH_COMPILER_GUARD(seed64);
+#endif
+    {   xxh_u64 const input_lo = XXH_readLE64(input);
+        xxh_u64 const input_hi = XXH_readLE64(input+8);
+        return XXH3_mul128_fold64(
+            input_lo ^ (XXH_readLE64(secret)   + seed64),
+            input_hi ^ (XXH_readLE64(secret+8) - seed64)
+        );
+    }
+}
+
+/* For mid range keys, XXH3 uses a Mum-hash variant. */
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_len_17to128_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                     const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                     XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(16 < len && len <= 128);
+
+    {   xxh_u64 acc = len * XXH_PRIME64_1;
+        if (len > 32) {
+            if (len > 64) {
+                if (len > 96) {
+                    acc += XXH3_mix16B(input+48, secret+96, seed);
+                    acc += XXH3_mix16B(input+len-64, secret+112, seed);
+                }
+                acc += XXH3_mix16B(input+32, secret+64, seed);
+                acc += XXH3_mix16B(input+len-48, secret+80, seed);
+            }
+            acc += XXH3_mix16B(input+16, secret+32, seed);
+            acc += XXH3_mix16B(input+len-32, secret+48, seed);
+        }
+        acc += XXH3_mix16B(input+0, secret+0, seed);
+        acc += XXH3_mix16B(input+len-16, secret+16, seed);
+
+        return XXH3_avalanche(acc);
+    }
+}
+
+#define XXH3_MIDSIZE_MAX 240
+
+XXH_NO_INLINE XXH64_hash_t
+XXH3_len_129to240_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                      XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(128 < len && len <= XXH3_MIDSIZE_MAX);
+
+    #define XXH3_MIDSIZE_STARTOFFSET 3
+    #define XXH3_MIDSIZE_LASTOFFSET  17
+
+    {   xxh_u64 acc = len * XXH_PRIME64_1;
+        int const nbRounds = (int)len / 16;
+        int i;
+        for (i=0; i<8; i++) {
+            acc += XXH3_mix16B(input+(16*i), secret+(16*i), seed);
+        }
+        acc = XXH3_avalanche(acc);
+        XXH_ASSERT(nbRounds >= 8);
+#if defined(__clang__)                                /* Clang */ \
+    && (defined(__ARM_NEON) || defined(__ARM_NEON__)) /* NEON */ \
+    && !defined(XXH_ENABLE_AUTOVECTORIZE)             /* Define to disable */
+        /*
+         * UGLY HACK:
+         * Clang for ARMv7-A tries to vectorize this loop, similar to GCC x86.
+         * In everywhere else, it uses scalar code.
+         *
+         * For 64->128-bit multiplies, even if the NEON was 100% optimal, it
+         * would still be slower than UMAAL (see XXH_mult64to128).
+         *
+         * Unfortunately, Clang doesn't handle the long multiplies properly and
+         * converts them to the nonexistent "vmulq_u64" intrinsic, which is then
+         * scalarized into an ugly mess of VMOV.32 instructions.
+         *
+         * This mess is difficult to avoid without turning autovectorization
+         * off completely, but they are usually relatively minor and/or not
+         * worth it to fix.
+         *
+         * This loop is the easiest to fix, as unlike XXH32, this pragma
+         * _actually works_ because it is a loop vectorization instead of an
+         * SLP vectorization.
+         */
+        #pragma clang loop vectorize(disable)
+#endif
+        for (i=8 ; i < nbRounds; i++) {
+            acc += XXH3_mix16B(input+(16*i), secret+(16*(i-8)) + XXH3_MIDSIZE_STARTOFFSET, seed);
+        }
+        /* last bytes */
+        acc += XXH3_mix16B(input + len - 16, secret + XXH3_SECRET_SIZE_MIN - XXH3_MIDSIZE_LASTOFFSET, seed);
+        return XXH3_avalanche(acc);
+    }
+}
+
+
+/* =======     Long Keys     ======= */
+
+#define XXH_STRIPE_LEN 64
+#define XXH_SECRET_CONSUME_RATE 8   /* nb of secret bytes consumed at each accumulation */
+#define XXH_ACC_NB (XXH_STRIPE_LEN / sizeof(xxh_u64))
+
+#ifdef XXH_OLD_NAMES
+#  define STRIPE_LEN XXH_STRIPE_LEN
+#  define ACC_NB XXH_ACC_NB
+#endif
+
+XXH_FORCE_INLINE void XXH_writeLE64(void* dst, xxh_u64 v64)
+{
+    if (!XXH_CPU_LITTLE_ENDIAN) v64 = XXH_swap64(v64);
+    XXH_memcpy(dst, &v64, sizeof(v64));
+}
+
+/* Several intrinsic functions below are supposed to accept __int64 as argument,
+ * as documented in https://software.intel.com/sites/landingpage/IntrinsicsGuide/ .
+ * However, several environments do not define __int64 type,
+ * requiring a workaround.
+ */
+#if !defined (__VMS) \
+  && (defined (__cplusplus) \
+  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
+    typedef int64_t xxh_i64;
+#else
+    /* the following type must have a width of 64-bit */
+    typedef long long xxh_i64;
+#endif
+
+
+/*
+ * XXH3_accumulate_512 is the tightest loop for long inputs, and it is the most optimized.
+ *
+ * It is a hardened version of UMAC, based off of FARSH's implementation.
+ *
+ * This was chosen because it adapts quite well to 32-bit, 64-bit, and SIMD
+ * implementations, and it is ridiculously fast.
+ *
+ * We harden it by mixing the original input to the accumulators as well as the product.
+ *
+ * This means that in the (relatively likely) case of a multiply by zero, the
+ * original input is preserved.
+ *
+ * On 128-bit inputs, we swap 64-bit pairs when we add the input to improve
+ * cross-pollination, as otherwise the upper and lower halves would be
+ * essentially independent.
+ *
+ * This doesn't matter on 64-bit hashes since they all get merged together in
+ * the end, so we skip the extra step.
+ *
+ * Both XXH3_64bits and XXH3_128bits use this subroutine.
+ */
+
+#if (XXH_VECTOR == XXH_AVX512) \
+     || (defined(XXH_DISPATCH_AVX512) && XXH_DISPATCH_AVX512 != 0)
+
+#ifndef XXH_TARGET_AVX512
+# define XXH_TARGET_AVX512  /* disable attribute target */
+#endif
+
+XXH_FORCE_INLINE XXH_TARGET_AVX512 void
+XXH3_accumulate_512_avx512(void* XXH_RESTRICT acc,
+                     const void* XXH_RESTRICT input,
+                     const void* XXH_RESTRICT secret)
+{
+    __m512i* const xacc = (__m512i *) acc;
+    XXH_ASSERT((((size_t)acc) & 63) == 0);
+    XXH_STATIC_ASSERT(XXH_STRIPE_LEN == sizeof(__m512i));
+
+    {
+        /* data_vec    = input[0]; */
+        __m512i const data_vec    = _mm512_loadu_si512   (input);
+        /* key_vec     = secret[0]; */
+        __m512i const key_vec     = _mm512_loadu_si512   (secret);
+        /* data_key    = data_vec ^ key_vec; */
+        __m512i const data_key    = _mm512_xor_si512     (data_vec, key_vec);
+        /* data_key_lo = data_key >> 32; */
+        __m512i const data_key_lo = _mm512_shuffle_epi32 (data_key, (_MM_PERM_ENUM)_MM_SHUFFLE(0, 3, 0, 1));
+        /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
+        __m512i const product     = _mm512_mul_epu32     (data_key, data_key_lo);
+        /* xacc[0] += swap(data_vec); */
+        __m512i const data_swap = _mm512_shuffle_epi32(data_vec, (_MM_PERM_ENUM)_MM_SHUFFLE(1, 0, 3, 2));
+        __m512i const sum       = _mm512_add_epi64(*xacc, data_swap);
+        /* xacc[0] += product; */
+        *xacc = _mm512_add_epi64(product, sum);
+    }
+}
+
+/*
+ * XXH3_scrambleAcc: Scrambles the accumulators to improve mixing.
+ *
+ * Multiplication isn't perfect, as explained by Google in HighwayHash:
+ *
+ *  // Multiplication mixes/scrambles bytes 0-7 of the 64-bit result to
+ *  // varying degrees. In descending order of goodness, bytes
+ *  // 3 4 2 5 1 6 0 7 have quality 228 224 164 160 100 96 36 32.
+ *  // As expected, the upper and lower bytes are much worse.
+ *
+ * Source: https://github.com/google/highwayhash/blob/0aaf66b/highwayhash/hh_avx2.h#L291
+ *
+ * Since our algorithm uses a pseudorandom secret to add some variance into the
+ * mix, we don't need to (or want to) mix as often or as much as HighwayHash does.
+ *
+ * This isn't as tight as XXH3_accumulate, but still written in SIMD to avoid
+ * extraction.
+ *
+ * Both XXH3_64bits and XXH3_128bits use this subroutine.
+ */
+
+XXH_FORCE_INLINE XXH_TARGET_AVX512 void
+XXH3_scrambleAcc_avx512(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
+{
+    XXH_ASSERT((((size_t)acc) & 63) == 0);
+    XXH_STATIC_ASSERT(XXH_STRIPE_LEN == sizeof(__m512i));
+    {   __m512i* const xacc = (__m512i*) acc;
+        const __m512i prime32 = _mm512_set1_epi32((int)XXH_PRIME32_1);
+
+        /* xacc[0] ^= (xacc[0] >> 47) */
+        __m512i const acc_vec     = *xacc;
+        __m512i const shifted     = _mm512_srli_epi64    (acc_vec, 47);
+        __m512i const data_vec    = _mm512_xor_si512     (acc_vec, shifted);
+        /* xacc[0] ^= secret; */
+        __m512i const key_vec     = _mm512_loadu_si512   (secret);
+        __m512i const data_key    = _mm512_xor_si512     (data_vec, key_vec);
+
+        /* xacc[0] *= XXH_PRIME32_1; */
+        __m512i const data_key_hi = _mm512_shuffle_epi32 (data_key, (_MM_PERM_ENUM)_MM_SHUFFLE(0, 3, 0, 1));
+        __m512i const prod_lo     = _mm512_mul_epu32     (data_key, prime32);
+        __m512i const prod_hi     = _mm512_mul_epu32     (data_key_hi, prime32);
+        *xacc = _mm512_add_epi64(prod_lo, _mm512_slli_epi64(prod_hi, 32));
+    }
+}
+
+XXH_FORCE_INLINE XXH_TARGET_AVX512 void
+XXH3_initCustomSecret_avx512(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
+{
+    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 63) == 0);
+    XXH_STATIC_ASSERT(XXH_SEC_ALIGN == 64);
+    XXH_ASSERT(((size_t)customSecret & 63) == 0);
+    (void)(&XXH_writeLE64);
+    {   int const nbRounds = XXH_SECRET_DEFAULT_SIZE / sizeof(__m512i);
+        __m512i const seed = _mm512_mask_set1_epi64(_mm512_set1_epi64((xxh_i64)seed64), 0xAA, (xxh_i64)(0U - seed64));
+
+        const __m512i* const src  = (const __m512i*) ((const void*) XXH3_kSecret);
+              __m512i* const dest = (      __m512i*) customSecret;
+        int i;
+        XXH_ASSERT(((size_t)src & 63) == 0); /* control alignment */
+        XXH_ASSERT(((size_t)dest & 63) == 0);
+        for (i=0; i < nbRounds; ++i) {
+            /* GCC has a bug, _mm512_stream_load_si512 accepts 'void*', not 'void const*',
+             * this will warn "discards 'const' qualifier". */
+            union {
+                const __m512i* cp;
+                void* p;
+            } remote_const_void;
+            remote_const_void.cp = src + i;
+            dest[i] = _mm512_add_epi64(_mm512_stream_load_si512(remote_const_void.p), seed);
+    }   }
+}
+
+#endif
+
+#if (XXH_VECTOR == XXH_AVX2) \
+    || (defined(XXH_DISPATCH_AVX2) && XXH_DISPATCH_AVX2 != 0)
+
+#ifndef XXH_TARGET_AVX2
+# define XXH_TARGET_AVX2  /* disable attribute target */
+#endif
+
+XXH_FORCE_INLINE XXH_TARGET_AVX2 void
+XXH3_accumulate_512_avx2( void* XXH_RESTRICT acc,
+                    const void* XXH_RESTRICT input,
+                    const void* XXH_RESTRICT secret)
+{
+    XXH_ASSERT((((size_t)acc) & 31) == 0);
+    {   __m256i* const xacc    =       (__m256i *) acc;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm256_loadu_si256 requires  a const __m256i * pointer for some reason. */
+        const         __m256i* const xinput  = (const __m256i *) input;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. */
+        const         __m256i* const xsecret = (const __m256i *) secret;
+
+        size_t i;
+        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m256i); i++) {
+            /* data_vec    = xinput[i]; */
+            __m256i const data_vec    = _mm256_loadu_si256    (xinput+i);
+            /* key_vec     = xsecret[i]; */
+            __m256i const key_vec     = _mm256_loadu_si256   (xsecret+i);
+            /* data_key    = data_vec ^ key_vec; */
+            __m256i const data_key    = _mm256_xor_si256     (data_vec, key_vec);
+            /* data_key_lo = data_key >> 32; */
+            __m256i const data_key_lo = _mm256_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
+            /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
+            __m256i const product     = _mm256_mul_epu32     (data_key, data_key_lo);
+            /* xacc[i] += swap(data_vec); */
+            __m256i const data_swap = _mm256_shuffle_epi32(data_vec, _MM_SHUFFLE(1, 0, 3, 2));
+            __m256i const sum       = _mm256_add_epi64(xacc[i], data_swap);
+            /* xacc[i] += product; */
+            xacc[i] = _mm256_add_epi64(product, sum);
+    }   }
+}
+
+XXH_FORCE_INLINE XXH_TARGET_AVX2 void
+XXH3_scrambleAcc_avx2(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
+{
+    XXH_ASSERT((((size_t)acc) & 31) == 0);
+    {   __m256i* const xacc = (__m256i*) acc;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. */
+        const         __m256i* const xsecret = (const __m256i *) secret;
+        const __m256i prime32 = _mm256_set1_epi32((int)XXH_PRIME32_1);
+
+        size_t i;
+        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m256i); i++) {
+            /* xacc[i] ^= (xacc[i] >> 47) */
+            __m256i const acc_vec     = xacc[i];
+            __m256i const shifted     = _mm256_srli_epi64    (acc_vec, 47);
+            __m256i const data_vec    = _mm256_xor_si256     (acc_vec, shifted);
+            /* xacc[i] ^= xsecret; */
+            __m256i const key_vec     = _mm256_loadu_si256   (xsecret+i);
+            __m256i const data_key    = _mm256_xor_si256     (data_vec, key_vec);
+
+            /* xacc[i] *= XXH_PRIME32_1; */
+            __m256i const data_key_hi = _mm256_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
+            __m256i const prod_lo     = _mm256_mul_epu32     (data_key, prime32);
+            __m256i const prod_hi     = _mm256_mul_epu32     (data_key_hi, prime32);
+            xacc[i] = _mm256_add_epi64(prod_lo, _mm256_slli_epi64(prod_hi, 32));
+        }
+    }
+}
+
+XXH_FORCE_INLINE XXH_TARGET_AVX2 void XXH3_initCustomSecret_avx2(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
+{
+    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 31) == 0);
+    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE / sizeof(__m256i)) == 6);
+    XXH_STATIC_ASSERT(XXH_SEC_ALIGN <= 64);
+    (void)(&XXH_writeLE64);
+    XXH_PREFETCH(customSecret);
+    {   __m256i const seed = _mm256_set_epi64x((xxh_i64)(0U - seed64), (xxh_i64)seed64, (xxh_i64)(0U - seed64), (xxh_i64)seed64);
+
+        const __m256i* const src  = (const __m256i*) ((const void*) XXH3_kSecret);
+              __m256i*       dest = (      __m256i*) customSecret;
+
+#       if defined(__GNUC__) || defined(__clang__)
+        /*
+         * On GCC & Clang, marking 'dest' as modified will cause the compiler:
+         *   - do not extract the secret from sse registers in the internal loop
+         *   - use less common registers, and avoid pushing these reg into stack
+         */
+        XXH_COMPILER_GUARD(dest);
+#       endif
+        XXH_ASSERT(((size_t)src & 31) == 0); /* control alignment */
+        XXH_ASSERT(((size_t)dest & 31) == 0);
+
+        /* GCC -O2 need unroll loop manually */
+        dest[0] = _mm256_add_epi64(_mm256_stream_load_si256(src+0), seed);
+        dest[1] = _mm256_add_epi64(_mm256_stream_load_si256(src+1), seed);
+        dest[2] = _mm256_add_epi64(_mm256_stream_load_si256(src+2), seed);
+        dest[3] = _mm256_add_epi64(_mm256_stream_load_si256(src+3), seed);
+        dest[4] = _mm256_add_epi64(_mm256_stream_load_si256(src+4), seed);
+        dest[5] = _mm256_add_epi64(_mm256_stream_load_si256(src+5), seed);
+    }
+}
+
+#endif
+
+/* x86dispatch always generates SSE2 */
+#if (XXH_VECTOR == XXH_SSE2) || defined(XXH_X86DISPATCH)
+
+#ifndef XXH_TARGET_SSE2
+# define XXH_TARGET_SSE2  /* disable attribute target */
+#endif
+
+XXH_FORCE_INLINE XXH_TARGET_SSE2 void
+XXH3_accumulate_512_sse2( void* XXH_RESTRICT acc,
+                    const void* XXH_RESTRICT input,
+                    const void* XXH_RESTRICT secret)
+{
+    /* SSE2 is just a half-scale version of the AVX2 version. */
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
+    {   __m128i* const xacc    =       (__m128i *) acc;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
+        const         __m128i* const xinput  = (const __m128i *) input;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
+        const         __m128i* const xsecret = (const __m128i *) secret;
+
+        size_t i;
+        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m128i); i++) {
+            /* data_vec    = xinput[i]; */
+            __m128i const data_vec    = _mm_loadu_si128   (xinput+i);
+            /* key_vec     = xsecret[i]; */
+            __m128i const key_vec     = _mm_loadu_si128   (xsecret+i);
+            /* data_key    = data_vec ^ key_vec; */
+            __m128i const data_key    = _mm_xor_si128     (data_vec, key_vec);
+            /* data_key_lo = data_key >> 32; */
+            __m128i const data_key_lo = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
+            /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
+            __m128i const product     = _mm_mul_epu32     (data_key, data_key_lo);
+            /* xacc[i] += swap(data_vec); */
+            __m128i const data_swap = _mm_shuffle_epi32(data_vec, _MM_SHUFFLE(1,0,3,2));
+            __m128i const sum       = _mm_add_epi64(xacc[i], data_swap);
+            /* xacc[i] += product; */
+            xacc[i] = _mm_add_epi64(product, sum);
+    }   }
+}
+
+XXH_FORCE_INLINE XXH_TARGET_SSE2 void
+XXH3_scrambleAcc_sse2(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
+{
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
+    {   __m128i* const xacc = (__m128i*) acc;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
+        const         __m128i* const xsecret = (const __m128i *) secret;
+        const __m128i prime32 = _mm_set1_epi32((int)XXH_PRIME32_1);
+
+        size_t i;
+        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m128i); i++) {
+            /* xacc[i] ^= (xacc[i] >> 47) */
+            __m128i const acc_vec     = xacc[i];
+            __m128i const shifted     = _mm_srli_epi64    (acc_vec, 47);
+            __m128i const data_vec    = _mm_xor_si128     (acc_vec, shifted);
+            /* xacc[i] ^= xsecret[i]; */
+            __m128i const key_vec     = _mm_loadu_si128   (xsecret+i);
+            __m128i const data_key    = _mm_xor_si128     (data_vec, key_vec);
+
+            /* xacc[i] *= XXH_PRIME32_1; */
+            __m128i const data_key_hi = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
+            __m128i const prod_lo     = _mm_mul_epu32     (data_key, prime32);
+            __m128i const prod_hi     = _mm_mul_epu32     (data_key_hi, prime32);
+            xacc[i] = _mm_add_epi64(prod_lo, _mm_slli_epi64(prod_hi, 32));
+        }
+    }
+}
+
+XXH_FORCE_INLINE XXH_TARGET_SSE2 void XXH3_initCustomSecret_sse2(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
+{
+    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 15) == 0);
+    (void)(&XXH_writeLE64);
+    {   int const nbRounds = XXH_SECRET_DEFAULT_SIZE / sizeof(__m128i);
+
+#       if defined(_MSC_VER) && defined(_M_IX86) && _MSC_VER < 1900
+        /* MSVC 32bit mode does not support _mm_set_epi64x before 2015 */
+        XXH_ALIGN(16) const xxh_i64 seed64x2[2] = { (xxh_i64)seed64, (xxh_i64)(0U - seed64) };
+        __m128i const seed = _mm_load_si128((__m128i const*)seed64x2);
+#       else
+        __m128i const seed = _mm_set_epi64x((xxh_i64)(0U - seed64), (xxh_i64)seed64);
+#       endif
+        int i;
+
+        const void* const src16 = XXH3_kSecret;
+        __m128i* dst16 = (__m128i*) customSecret;
+#       if defined(__GNUC__) || defined(__clang__)
+        /*
+         * On GCC & Clang, marking 'dest' as modified will cause the compiler:
+         *   - do not extract the secret from sse registers in the internal loop
+         *   - use less common registers, and avoid pushing these reg into stack
+         */
+        XXH_COMPILER_GUARD(dst16);
+#       endif
+        XXH_ASSERT(((size_t)src16 & 15) == 0); /* control alignment */
+        XXH_ASSERT(((size_t)dst16 & 15) == 0);
+
+        for (i=0; i < nbRounds; ++i) {
+            dst16[i] = _mm_add_epi64(_mm_load_si128((const __m128i *)src16+i), seed);
+    }   }
+}
+
+#endif
+
+#if (XXH_VECTOR == XXH_NEON)
+
+/* forward declarations for the scalar routines */
+XXH_FORCE_INLINE void
+XXH3_scalarRound(void* XXH_RESTRICT acc, void const* XXH_RESTRICT input,
+                 void const* XXH_RESTRICT secret, size_t lane);
+
+XXH_FORCE_INLINE void
+XXH3_scalarScrambleRound(void* XXH_RESTRICT acc,
+                         void const* XXH_RESTRICT secret, size_t lane);
+
+/*!
+ * @internal
+ * @brief The bulk processing loop for NEON.
+ *
+ * The NEON code path is actually partially scalar when running on AArch64. This
+ * is to optimize the pipelining and can have up to 15% speedup depending on the
+ * CPU, and it also mitigates some GCC codegen issues.
+ *
+ * @see XXH3_NEON_LANES for configuring this and details about this optimization.
+ */
+XXH_FORCE_INLINE void
+XXH3_accumulate_512_neon( void* XXH_RESTRICT acc,
+                    const void* XXH_RESTRICT input,
+                    const void* XXH_RESTRICT secret)
+{
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
+    XXH_STATIC_ASSERT(XXH3_NEON_LANES > 0 && XXH3_NEON_LANES <= XXH_ACC_NB && XXH3_NEON_LANES % 2 == 0);
+    {
+        uint64x2_t* const xacc = (uint64x2_t *) acc;
+        /* We don't use a uint32x4_t pointer because it causes bus errors on ARMv7. */
+        uint8_t const* const xinput = (const uint8_t *) input;
+        uint8_t const* const xsecret  = (const uint8_t *) secret;
+
+        size_t i;
+        /* NEON for the first few lanes (these loops are normally interleaved) */
+        for (i=0; i < XXH3_NEON_LANES / 2; i++) {
+            /* data_vec = xinput[i]; */
+            uint8x16_t data_vec    = vld1q_u8(xinput  + (i * 16));
+            /* key_vec  = xsecret[i];  */
+            uint8x16_t key_vec     = vld1q_u8(xsecret + (i * 16));
+            uint64x2_t data_key;
+            uint32x2_t data_key_lo, data_key_hi;
+            /* xacc[i] += swap(data_vec); */
+            uint64x2_t const data64  = vreinterpretq_u64_u8(data_vec);
+            uint64x2_t const swapped = vextq_u64(data64, data64, 1);
+            xacc[i] = vaddq_u64 (xacc[i], swapped);
+            /* data_key = data_vec ^ key_vec; */
+            data_key = vreinterpretq_u64_u8(veorq_u8(data_vec, key_vec));
+            /* data_key_lo = (uint32x2_t) (data_key & 0xFFFFFFFF);
+             * data_key_hi = (uint32x2_t) (data_key >> 32);
+             * data_key = UNDEFINED; */
+            XXH_SPLIT_IN_PLACE(data_key, data_key_lo, data_key_hi);
+            /* xacc[i] += (uint64x2_t) data_key_lo * (uint64x2_t) data_key_hi; */
+            xacc[i] = vmlal_u32 (xacc[i], data_key_lo, data_key_hi);
+
+        }
+        /* Scalar for the remainder. This may be a zero iteration loop. */
+        for (i = XXH3_NEON_LANES; i < XXH_ACC_NB; i++) {
+            XXH3_scalarRound(acc, input, secret, i);
+        }
+    }
+}
+
+XXH_FORCE_INLINE void
+XXH3_scrambleAcc_neon(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
+{
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
+
+    {   uint64x2_t* xacc       = (uint64x2_t*) acc;
+        uint8_t const* xsecret = (uint8_t const*) secret;
+        uint32x2_t prime       = vdup_n_u32 (XXH_PRIME32_1);
+
+        size_t i;
+        /* NEON for the first few lanes (these loops are normally interleaved) */
+        for (i=0; i < XXH3_NEON_LANES / 2; i++) {
+            /* xacc[i] ^= (xacc[i] >> 47); */
+            uint64x2_t acc_vec  = xacc[i];
+            uint64x2_t shifted  = vshrq_n_u64 (acc_vec, 47);
+            uint64x2_t data_vec = veorq_u64   (acc_vec, shifted);
+
+            /* xacc[i] ^= xsecret[i]; */
+            uint8x16_t key_vec  = vld1q_u8    (xsecret + (i * 16));
+            uint64x2_t data_key = veorq_u64   (data_vec, vreinterpretq_u64_u8(key_vec));
+
+            /* xacc[i] *= XXH_PRIME32_1 */
+            uint32x2_t data_key_lo, data_key_hi;
+            /* data_key_lo = (uint32x2_t) (xacc[i] & 0xFFFFFFFF);
+             * data_key_hi = (uint32x2_t) (xacc[i] >> 32);
+             * xacc[i] = UNDEFINED; */
+            XXH_SPLIT_IN_PLACE(data_key, data_key_lo, data_key_hi);
+            {   /*
+                 * prod_hi = (data_key >> 32) * XXH_PRIME32_1;
+                 *
+                 * Avoid vmul_u32 + vshll_n_u32 since Clang 6 and 7 will
+                 * incorrectly "optimize" this:
+                 *   tmp     = vmul_u32(vmovn_u64(a), vmovn_u64(b));
+                 *   shifted = vshll_n_u32(tmp, 32);
+                 * to this:
+                 *   tmp     = "vmulq_u64"(a, b); // no such thing!
+                 *   shifted = vshlq_n_u64(tmp, 32);
+                 *
+                 * However, unlike SSE, Clang lacks a 64-bit multiply routine
+                 * for NEON, and it scalarizes two 64-bit multiplies instead.
+                 *
+                 * vmull_u32 has the same timing as vmul_u32, and it avoids
+                 * this bug completely.
+                 * See https://bugs.llvm.org/show_bug.cgi?id=39967
+                 */
+                uint64x2_t prod_hi = vmull_u32 (data_key_hi, prime);
+                /* xacc[i] = prod_hi << 32; */
+                xacc[i] = vshlq_n_u64(prod_hi, 32);
+                /* xacc[i] += (prod_hi & 0xFFFFFFFF) * XXH_PRIME32_1; */
+                xacc[i] = vmlal_u32(xacc[i], data_key_lo, prime);
+            }
+        }
+        /* Scalar for the remainder. This may be a zero iteration loop. */
+        for (i = XXH3_NEON_LANES; i < XXH_ACC_NB; i++) {
+            XXH3_scalarScrambleRound(acc, secret, i);
+        }
+    }
+}
+
+#endif
+
+#if (XXH_VECTOR == XXH_VSX)
+
+XXH_FORCE_INLINE void
+XXH3_accumulate_512_vsx(  void* XXH_RESTRICT acc,
+                    const void* XXH_RESTRICT input,
+                    const void* XXH_RESTRICT secret)
+{
+    /* presumed aligned */
+    unsigned int* const xacc = (unsigned int*) acc;
+    xxh_u64x2 const* const xinput   = (xxh_u64x2 const*) input;   /* no alignment restriction */
+    xxh_u64x2 const* const xsecret  = (xxh_u64x2 const*) secret;    /* no alignment restriction */
+    xxh_u64x2 const v32 = { 32, 32 };
+    size_t i;
+    for (i = 0; i < XXH_STRIPE_LEN / sizeof(xxh_u64x2); i++) {
+        /* data_vec = xinput[i]; */
+        xxh_u64x2 const data_vec = XXH_vec_loadu(xinput + i);
+        /* key_vec = xsecret[i]; */
+        xxh_u64x2 const key_vec  = XXH_vec_loadu(xsecret + i);
+        xxh_u64x2 const data_key = data_vec ^ key_vec;
+        /* shuffled = (data_key << 32) | (data_key >> 32); */
+        xxh_u32x4 const shuffled = (xxh_u32x4)vec_rl(data_key, v32);
+        /* product = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)shuffled & 0xFFFFFFFF); */
+        xxh_u64x2 const product  = XXH_vec_mulo((xxh_u32x4)data_key, shuffled);
+        /* acc_vec = xacc[i]; */
+        xxh_u64x2 acc_vec        = (xxh_u64x2)vec_xl(0, xacc + 4 * i);
+        acc_vec += product;
+
+        /* swap high and low halves */
+#ifdef __s390x__
+        acc_vec += vec_permi(data_vec, data_vec, 2);
+#else
+        acc_vec += vec_xxpermdi(data_vec, data_vec, 2);
+#endif
+        /* xacc[i] = acc_vec; */
+        vec_xst((xxh_u32x4)acc_vec, 0, xacc + 4 * i);
+    }
+}
+
+XXH_FORCE_INLINE void
+XXH3_scrambleAcc_vsx(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
+{
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
+
+    {         xxh_u64x2* const xacc    =       (xxh_u64x2*) acc;
+        const xxh_u64x2* const xsecret = (const xxh_u64x2*) secret;
+        /* constants */
+        xxh_u64x2 const v32  = { 32, 32 };
+        xxh_u64x2 const v47 = { 47, 47 };
+        xxh_u32x4 const prime = { XXH_PRIME32_1, XXH_PRIME32_1, XXH_PRIME32_1, XXH_PRIME32_1 };
+        size_t i;
+        for (i = 0; i < XXH_STRIPE_LEN / sizeof(xxh_u64x2); i++) {
+            /* xacc[i] ^= (xacc[i] >> 47); */
+            xxh_u64x2 const acc_vec  = xacc[i];
+            xxh_u64x2 const data_vec = acc_vec ^ (acc_vec >> v47);
+
+            /* xacc[i] ^= xsecret[i]; */
+            xxh_u64x2 const key_vec  = XXH_vec_loadu(xsecret + i);
+            xxh_u64x2 const data_key = data_vec ^ key_vec;
+
+            /* xacc[i] *= XXH_PRIME32_1 */
+            /* prod_lo = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)prime & 0xFFFFFFFF);  */
+            xxh_u64x2 const prod_even  = XXH_vec_mule((xxh_u32x4)data_key, prime);
+            /* prod_hi = ((xxh_u64x2)data_key >> 32) * ((xxh_u64x2)prime >> 32);  */
+            xxh_u64x2 const prod_odd  = XXH_vec_mulo((xxh_u32x4)data_key, prime);
+            xacc[i] = prod_odd + (prod_even << v32);
+    }   }
+}
+
+#endif
+
+/* scalar variants - universal */
+
+/*!
+ * @internal
+ * @brief Scalar round for @ref XXH3_accumulate_512_scalar().
+ *
+ * This is extracted to its own function because the NEON path uses a combination
+ * of NEON and scalar.
+ */
+XXH_FORCE_INLINE void
+XXH3_scalarRound(void* XXH_RESTRICT acc,
+                 void const* XXH_RESTRICT input,
+                 void const* XXH_RESTRICT secret,
+                 size_t lane)
+{
+    xxh_u64* xacc = (xxh_u64*) acc;
+    xxh_u8 const* xinput  = (xxh_u8 const*) input;
+    xxh_u8 const* xsecret = (xxh_u8 const*) secret;
+    XXH_ASSERT(lane < XXH_ACC_NB);
+    XXH_ASSERT(((size_t)acc & (XXH_ACC_ALIGN-1)) == 0);
+    {
+        xxh_u64 const data_val = XXH_readLE64(xinput + lane * 8);
+        xxh_u64 const data_key = data_val ^ XXH_readLE64(xsecret + lane * 8);
+        xacc[lane ^ 1] += data_val; /* swap adjacent lanes */
+        xacc[lane] += XXH_mult32to64(data_key & 0xFFFFFFFF, data_key >> 32);
+    }
+}
+
+/*!
+ * @internal
+ * @brief Processes a 64 byte block of data using the scalar path.
+ */
+XXH_FORCE_INLINE void
+XXH3_accumulate_512_scalar(void* XXH_RESTRICT acc,
+                     const void* XXH_RESTRICT input,
+                     const void* XXH_RESTRICT secret)
+{
+    size_t i;
+    for (i=0; i < XXH_ACC_NB; i++) {
+        XXH3_scalarRound(acc, input, secret, i);
+    }
+}
+
+/*!
+ * @internal
+ * @brief Scalar scramble step for @ref XXH3_scrambleAcc_scalar().
+ *
+ * This is extracted to its own function because the NEON path uses a combination
+ * of NEON and scalar.
+ */
+XXH_FORCE_INLINE void
+XXH3_scalarScrambleRound(void* XXH_RESTRICT acc,
+                         void const* XXH_RESTRICT secret,
+                         size_t lane)
+{
+    xxh_u64* const xacc = (xxh_u64*) acc;   /* presumed aligned */
+    const xxh_u8* const xsecret = (const xxh_u8*) secret;   /* no alignment restriction */
+    XXH_ASSERT((((size_t)acc) & (XXH_ACC_ALIGN-1)) == 0);
+    XXH_ASSERT(lane < XXH_ACC_NB);
+    {
+        xxh_u64 const key64 = XXH_readLE64(xsecret + lane * 8);
+        xxh_u64 acc64 = xacc[lane];
+        acc64 = XXH_xorshift64(acc64, 47);
+        acc64 ^= key64;
+        acc64 *= XXH_PRIME32_1;
+        xacc[lane] = acc64;
+    }
+}
+
+/*!
+ * @internal
+ * @brief Scrambles the accumulators after a large chunk has been read
+ */
+XXH_FORCE_INLINE void
+XXH3_scrambleAcc_scalar(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
+{
+    size_t i;
+    for (i=0; i < XXH_ACC_NB; i++) {
+        XXH3_scalarScrambleRound(acc, secret, i);
+    }
+}
+
+XXH_FORCE_INLINE void
+XXH3_initCustomSecret_scalar(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
+{
+    /*
+     * We need a separate pointer for the hack below,
+     * which requires a non-const pointer.
+     * Any decent compiler will optimize this out otherwise.
+     */
+    const xxh_u8* kSecretPtr = XXH3_kSecret;
+    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 15) == 0);
+
+#if defined(__clang__) && defined(__aarch64__)
+    /*
+     * UGLY HACK:
+     * Clang generates a bunch of MOV/MOVK pairs for aarch64, and they are
+     * placed sequentially, in order, at the top of the unrolled loop.
+     *
+     * While MOVK is great for generating constants (2 cycles for a 64-bit
+     * constant compared to 4 cycles for LDR), it fights for bandwidth with
+     * the arithmetic instructions.
+     *
+     *   I   L   S
+     * MOVK
+     * MOVK
+     * MOVK
+     * MOVK
+     * ADD
+     * SUB      STR
+     *          STR
+     * By forcing loads from memory (as the asm line causes Clang to assume
+     * that XXH3_kSecretPtr has been changed), the pipelines are used more
+     * efficiently:
+     *   I   L   S
+     *      LDR
+     *  ADD LDR
+     *  SUB     STR
+     *          STR
+     *
+     * See XXH3_NEON_LANES for details on the pipsline.
+     *
+     * XXH3_64bits_withSeed, len == 256, Snapdragon 835
+     *   without hack: 2654.4 MB/s
+     *   with hack:    3202.9 MB/s
+     */
+    XXH_COMPILER_GUARD(kSecretPtr);
+#endif
+    /*
+     * Note: in debug mode, this overrides the asm optimization
+     * and Clang will emit MOVK chains again.
+     */
+    XXH_ASSERT(kSecretPtr == XXH3_kSecret);
+
+    {   int const nbRounds = XXH_SECRET_DEFAULT_SIZE / 16;
+        int i;
+        for (i=0; i < nbRounds; i++) {
+            /*
+             * The asm hack causes Clang to assume that kSecretPtr aliases with
+             * customSecret, and on aarch64, this prevented LDP from merging two
+             * loads together for free. Putting the loads together before the stores
+             * properly generates LDP.
+             */
+            xxh_u64 lo = XXH_readLE64(kSecretPtr + 16*i)     + seed64;
+            xxh_u64 hi = XXH_readLE64(kSecretPtr + 16*i + 8) - seed64;
+            XXH_writeLE64((xxh_u8*)customSecret + 16*i,     lo);
+            XXH_writeLE64((xxh_u8*)customSecret + 16*i + 8, hi);
+    }   }
+}
+
+
+typedef void (*XXH3_f_accumulate_512)(void* XXH_RESTRICT, const void*, const void*);
+typedef void (*XXH3_f_scrambleAcc)(void* XXH_RESTRICT, const void*);
+typedef void (*XXH3_f_initCustomSecret)(void* XXH_RESTRICT, xxh_u64);
+
+
+#if (XXH_VECTOR == XXH_AVX512)
+
+#define XXH3_accumulate_512 XXH3_accumulate_512_avx512
+#define XXH3_scrambleAcc    XXH3_scrambleAcc_avx512
+#define XXH3_initCustomSecret XXH3_initCustomSecret_avx512
+
+#elif (XXH_VECTOR == XXH_AVX2)
+
+#define XXH3_accumulate_512 XXH3_accumulate_512_avx2
+#define XXH3_scrambleAcc    XXH3_scrambleAcc_avx2
+#define XXH3_initCustomSecret XXH3_initCustomSecret_avx2
+
+#elif (XXH_VECTOR == XXH_SSE2)
+
+#define XXH3_accumulate_512 XXH3_accumulate_512_sse2
+#define XXH3_scrambleAcc    XXH3_scrambleAcc_sse2
+#define XXH3_initCustomSecret XXH3_initCustomSecret_sse2
+
+#elif (XXH_VECTOR == XXH_NEON)
+
+#define XXH3_accumulate_512 XXH3_accumulate_512_neon
+#define XXH3_scrambleAcc    XXH3_scrambleAcc_neon
+#define XXH3_initCustomSecret XXH3_initCustomSecret_scalar
+
+#elif (XXH_VECTOR == XXH_VSX)
+
+#define XXH3_accumulate_512 XXH3_accumulate_512_vsx
+#define XXH3_scrambleAcc    XXH3_scrambleAcc_vsx
+#define XXH3_initCustomSecret XXH3_initCustomSecret_scalar
+
+#else /* scalar */
+
+#define XXH3_accumulate_512 XXH3_accumulate_512_scalar
+#define XXH3_scrambleAcc    XXH3_scrambleAcc_scalar
+#define XXH3_initCustomSecret XXH3_initCustomSecret_scalar
+
+#endif
+
+
+
+#ifndef XXH_PREFETCH_DIST
+#  ifdef __clang__
+#    define XXH_PREFETCH_DIST 320
+#  else
+#    if (XXH_VECTOR == XXH_AVX512)
+#      define XXH_PREFETCH_DIST 512
+#    else
+#      define XXH_PREFETCH_DIST 384
+#    endif
+#  endif  /* __clang__ */
+#endif  /* XXH_PREFETCH_DIST */
+
+/*
+ * XXH3_accumulate()
+ * Loops over XXH3_accumulate_512().
+ * Assumption: nbStripes will not overflow the secret size
+ */
+XXH_FORCE_INLINE void
+XXH3_accumulate(     xxh_u64* XXH_RESTRICT acc,
+                const xxh_u8* XXH_RESTRICT input,
+                const xxh_u8* XXH_RESTRICT secret,
+                      size_t nbStripes,
+                      XXH3_f_accumulate_512 f_acc512)
+{
+    size_t n;
+    for (n = 0; n < nbStripes; n++ ) {
+        const xxh_u8* const in = input + n*XXH_STRIPE_LEN;
+        XXH_PREFETCH(in + XXH_PREFETCH_DIST);
+        f_acc512(acc,
+                 in,
+                 secret + n*XXH_SECRET_CONSUME_RATE);
+    }
+}
+
+XXH_FORCE_INLINE void
+XXH3_hashLong_internal_loop(xxh_u64* XXH_RESTRICT acc,
+                      const xxh_u8* XXH_RESTRICT input, size_t len,
+                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                            XXH3_f_accumulate_512 f_acc512,
+                            XXH3_f_scrambleAcc f_scramble)
+{
+    size_t const nbStripesPerBlock = (secretSize - XXH_STRIPE_LEN) / XXH_SECRET_CONSUME_RATE;
+    size_t const block_len = XXH_STRIPE_LEN * nbStripesPerBlock;
+    size_t const nb_blocks = (len - 1) / block_len;
+
+    size_t n;
+
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
+
+    for (n = 0; n < nb_blocks; n++) {
+        XXH3_accumulate(acc, input + n*block_len, secret, nbStripesPerBlock, f_acc512);
+        f_scramble(acc, secret + secretSize - XXH_STRIPE_LEN);
+    }
+
+    /* last partial block */
+    XXH_ASSERT(len > XXH_STRIPE_LEN);
+    {   size_t const nbStripes = ((len - 1) - (block_len * nb_blocks)) / XXH_STRIPE_LEN;
+        XXH_ASSERT(nbStripes <= (secretSize / XXH_SECRET_CONSUME_RATE));
+        XXH3_accumulate(acc, input + nb_blocks*block_len, secret, nbStripes, f_acc512);
+
+        /* last stripe */
+        {   const xxh_u8* const p = input + len - XXH_STRIPE_LEN;
+#define XXH_SECRET_LASTACC_START 7  /* not aligned on 8, last secret is different from acc & scrambler */
+            f_acc512(acc, p, secret + secretSize - XXH_STRIPE_LEN - XXH_SECRET_LASTACC_START);
+    }   }
+}
+
+XXH_FORCE_INLINE xxh_u64
+XXH3_mix2Accs(const xxh_u64* XXH_RESTRICT acc, const xxh_u8* XXH_RESTRICT secret)
+{
+    return XXH3_mul128_fold64(
+               acc[0] ^ XXH_readLE64(secret),
+               acc[1] ^ XXH_readLE64(secret+8) );
+}
+
+static XXH64_hash_t
+XXH3_mergeAccs(const xxh_u64* XXH_RESTRICT acc, const xxh_u8* XXH_RESTRICT secret, xxh_u64 start)
+{
+    xxh_u64 result64 = start;
+    size_t i = 0;
+
+    for (i = 0; i < 4; i++) {
+        result64 += XXH3_mix2Accs(acc+2*i, secret + 16*i);
+#if defined(__clang__)                                /* Clang */ \
+    && (defined(__arm__) || defined(__thumb__))       /* ARMv7 */ \
+    && (defined(__ARM_NEON) || defined(__ARM_NEON__)) /* NEON */  \
+    && !defined(XXH_ENABLE_AUTOVECTORIZE)             /* Define to disable */
+        /*
+         * UGLY HACK:
+         * Prevent autovectorization on Clang ARMv7-a. Exact same problem as
+         * the one in XXH3_len_129to240_64b. Speeds up shorter keys > 240b.
+         * XXH3_64bits, len == 256, Snapdragon 835:
+         *   without hack: 2063.7 MB/s
+         *   with hack:    2560.7 MB/s
+         */
+        XXH_COMPILER_GUARD(result64);
+#endif
+    }
+
+    return XXH3_avalanche(result64);
+}
+
+#define XXH3_INIT_ACC { XXH_PRIME32_3, XXH_PRIME64_1, XXH_PRIME64_2, XXH_PRIME64_3, \
+                        XXH_PRIME64_4, XXH_PRIME32_2, XXH_PRIME64_5, XXH_PRIME32_1 }
+
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_hashLong_64b_internal(const void* XXH_RESTRICT input, size_t len,
+                           const void* XXH_RESTRICT secret, size_t secretSize,
+                           XXH3_f_accumulate_512 f_acc512,
+                           XXH3_f_scrambleAcc f_scramble)
+{
+    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[XXH_ACC_NB] = XXH3_INIT_ACC;
+
+    XXH3_hashLong_internal_loop(acc, (const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, f_acc512, f_scramble);
+
+    /* converge into final hash */
+    XXH_STATIC_ASSERT(sizeof(acc) == 64);
+    /* do not align on 8, so that the secret is different from the accumulator */
+#define XXH_SECRET_MERGEACCS_START 11
+    XXH_ASSERT(secretSize >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
+    return XXH3_mergeAccs(acc, (const xxh_u8*)secret + XXH_SECRET_MERGEACCS_START, (xxh_u64)len * XXH_PRIME64_1);
+}
+
+/*
+ * It's important for performance to transmit secret's size (when it's static)
+ * so that the compiler can properly optimize the vectorized loop.
+ * This makes a big performance difference for "medium" keys (<1 KB) when using AVX instruction set.
+ */
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_hashLong_64b_withSecret(const void* XXH_RESTRICT input, size_t len,
+                             XXH64_hash_t seed64, const xxh_u8* XXH_RESTRICT secret, size_t secretLen)
+{
+    (void)seed64;
+    return XXH3_hashLong_64b_internal(input, len, secret, secretLen, XXH3_accumulate_512, XXH3_scrambleAcc);
+}
+
+/*
+ * It's preferable for performance that XXH3_hashLong is not inlined,
+ * as it results in a smaller function for small data, easier to the instruction cache.
+ * Note that inside this no_inline function, we do inline the internal loop,
+ * and provide a statically defined secret size to allow optimization of vector loop.
+ */
+XXH_NO_INLINE XXH64_hash_t
+XXH3_hashLong_64b_default(const void* XXH_RESTRICT input, size_t len,
+                          XXH64_hash_t seed64, const xxh_u8* XXH_RESTRICT secret, size_t secretLen)
+{
+    (void)seed64; (void)secret; (void)secretLen;
+    return XXH3_hashLong_64b_internal(input, len, XXH3_kSecret, sizeof(XXH3_kSecret), XXH3_accumulate_512, XXH3_scrambleAcc);
+}
+
+/*
+ * XXH3_hashLong_64b_withSeed():
+ * Generate a custom key based on alteration of default XXH3_kSecret with the seed,
+ * and then use this key for long mode hashing.
+ *
+ * This operation is decently fast but nonetheless costs a little bit of time.
+ * Try to avoid it whenever possible (typically when seed==0).
+ *
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_hashLong_64b_withSeed_internal(const void* input, size_t len,
+                                    XXH64_hash_t seed,
+                                    XXH3_f_accumulate_512 f_acc512,
+                                    XXH3_f_scrambleAcc f_scramble,
+                                    XXH3_f_initCustomSecret f_initSec)
+{
+    if (seed == 0)
+        return XXH3_hashLong_64b_internal(input, len,
+                                          XXH3_kSecret, sizeof(XXH3_kSecret),
+                                          f_acc512, f_scramble);
+    {   XXH_ALIGN(XXH_SEC_ALIGN) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
+        f_initSec(secret, seed);
+        return XXH3_hashLong_64b_internal(input, len, secret, sizeof(secret),
+                                          f_acc512, f_scramble);
+    }
+}
+
+/*
+ * It's important for performance that XXH3_hashLong is not inlined.
+ */
+XXH_NO_INLINE XXH64_hash_t
+XXH3_hashLong_64b_withSeed(const void* input, size_t len,
+                           XXH64_hash_t seed, const xxh_u8* secret, size_t secretLen)
+{
+    (void)secret; (void)secretLen;
+    return XXH3_hashLong_64b_withSeed_internal(input, len, seed,
+                XXH3_accumulate_512, XXH3_scrambleAcc, XXH3_initCustomSecret);
+}
+
+
+typedef XXH64_hash_t (*XXH3_hashLong64_f)(const void* XXH_RESTRICT, size_t,
+                                          XXH64_hash_t, const xxh_u8* XXH_RESTRICT, size_t);
+
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_64bits_internal(const void* XXH_RESTRICT input, size_t len,
+                     XXH64_hash_t seed64, const void* XXH_RESTRICT secret, size_t secretLen,
+                     XXH3_hashLong64_f f_hashLong)
+{
+    XXH_ASSERT(secretLen >= XXH3_SECRET_SIZE_MIN);
+    /*
+     * If an action is to be taken if `secretLen` condition is not respected,
+     * it should be done here.
+     * For now, it's a contract pre-condition.
+     * Adding a check and a branch here would cost performance at every hash.
+     * Also, note that function signature doesn't offer room to return an error.
+     */
+    if (len <= 16)
+        return XXH3_len_0to16_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, seed64);
+    if (len <= 128)
+        return XXH3_len_17to128_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
+    if (len <= XXH3_MIDSIZE_MAX)
+        return XXH3_len_129to240_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
+    return f_hashLong(input, len, seed64, (const xxh_u8*)secret, secretLen);
+}
+
+
+/* ===   Public entry point   === */
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH64_hash_t XXH3_64bits(const void* input, size_t len)
+{
+    return XXH3_64bits_internal(input, len, 0, XXH3_kSecret, sizeof(XXH3_kSecret), XXH3_hashLong_64b_default);
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH64_hash_t
+XXH3_64bits_withSecret(const void* input, size_t len, const void* secret, size_t secretSize)
+{
+    return XXH3_64bits_internal(input, len, 0, secret, secretSize, XXH3_hashLong_64b_withSecret);
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH64_hash_t
+XXH3_64bits_withSeed(const void* input, size_t len, XXH64_hash_t seed)
+{
+    return XXH3_64bits_internal(input, len, seed, XXH3_kSecret, sizeof(XXH3_kSecret), XXH3_hashLong_64b_withSeed);
+}
+
+XXH_PUBLIC_API XXH64_hash_t
+XXH3_64bits_withSecretandSeed(const void* input, size_t len, const void* secret, size_t secretSize, XXH64_hash_t seed)
+{
+    if (len <= XXH3_MIDSIZE_MAX)
+        return XXH3_64bits_internal(input, len, seed, XXH3_kSecret, sizeof(XXH3_kSecret), NULL);
+    return XXH3_hashLong_64b_withSecret(input, len, seed, (const xxh_u8*)secret, secretSize);
+}
+
+
+/* ===   XXH3 streaming   === */
+
+/*
+ * Malloc's a pointer that is always aligned to align.
+ *
+ * This must be freed with `XXH_alignedFree()`.
+ *
+ * malloc typically guarantees 16 byte alignment on 64-bit systems and 8 byte
+ * alignment on 32-bit. This isn't enough for the 32 byte aligned loads in AVX2
+ * or on 32-bit, the 16 byte aligned loads in SSE2 and NEON.
+ *
+ * This underalignment previously caused a rather obvious crash which went
+ * completely unnoticed due to XXH3_createState() not actually being tested.
+ * Credit to RedSpah for noticing this bug.
+ *
+ * The alignment is done manually: Functions like posix_memalign or _mm_malloc
+ * are avoided: To maintain portability, we would have to write a fallback
+ * like this anyways, and besides, testing for the existence of library
+ * functions without relying on external build tools is impossible.
+ *
+ * The method is simple: Overallocate, manually align, and store the offset
+ * to the original behind the returned pointer.
+ *
+ * Align must be a power of 2 and 8 <= align <= 128.
+ */
+static void* XXH_alignedMalloc(size_t s, size_t align)
+{
+    XXH_ASSERT(align <= 128 && align >= 8); /* range check */
+    XXH_ASSERT((align & (align-1)) == 0);   /* power of 2 */
+    XXH_ASSERT(s != 0 && s < (s + align));  /* empty/overflow */
+    {   /* Overallocate to make room for manual realignment and an offset byte */
+        xxh_u8* base = (xxh_u8*)XXH_malloc(s + align);
+        if (base != NULL) {
+            /*
+             * Get the offset needed to align this pointer.
+             *
+             * Even if the returned pointer is aligned, there will always be
+             * at least one byte to store the offset to the original pointer.
+             */
+            size_t offset = align - ((size_t)base & (align - 1)); /* base % align */
+            /* Add the offset for the now-aligned pointer */
+            xxh_u8* ptr = base + offset;
+
+            XXH_ASSERT((size_t)ptr % align == 0);
+
+            /* Store the offset immediately before the returned pointer. */
+            ptr[-1] = (xxh_u8)offset;
+            return ptr;
+        }
+        return NULL;
+    }
+}
+/*
+ * Frees an aligned pointer allocated by XXH_alignedMalloc(). Don't pass
+ * normal malloc'd pointers, XXH_alignedMalloc has a specific data layout.
+ */
+static void XXH_alignedFree(void* p)
+{
+    if (p != NULL) {
+        xxh_u8* ptr = (xxh_u8*)p;
+        /* Get the offset byte we added in XXH_malloc. */
+        xxh_u8 offset = ptr[-1];
+        /* Free the original malloc'd pointer */
+        xxh_u8* base = ptr - offset;
+        XXH_free(base);
+    }
+}
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH3_state_t* XXH3_createState(void)
+{
+    XXH3_state_t* const state = (XXH3_state_t*)XXH_alignedMalloc(sizeof(XXH3_state_t), 64);
+    if (state==NULL) return NULL;
+    XXH3_INITSTATE(state);
+    return state;
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH_errorcode XXH3_freeState(XXH3_state_t* statePtr)
+{
+    XXH_alignedFree(statePtr);
+    return XXH_OK;
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API void
+XXH3_copyState(XXH3_state_t* dst_state, const XXH3_state_t* src_state)
+{
+    XXH_memcpy(dst_state, src_state, sizeof(*dst_state));
+}
+
+static void
+XXH3_reset_internal(XXH3_state_t* statePtr,
+                    XXH64_hash_t seed,
+                    const void* secret, size_t secretSize)
+{
+    size_t const initStart = offsetof(XXH3_state_t, bufferedSize);
+    size_t const initLength = offsetof(XXH3_state_t, nbStripesPerBlock) - initStart;
+    XXH_ASSERT(offsetof(XXH3_state_t, nbStripesPerBlock) > initStart);
+    XXH_ASSERT(statePtr != NULL);
+    /* set members from bufferedSize to nbStripesPerBlock (excluded) to 0 */
+    memset((char*)statePtr + initStart, 0, initLength);
+    statePtr->acc[0] = XXH_PRIME32_3;
+    statePtr->acc[1] = XXH_PRIME64_1;
+    statePtr->acc[2] = XXH_PRIME64_2;
+    statePtr->acc[3] = XXH_PRIME64_3;
+    statePtr->acc[4] = XXH_PRIME64_4;
+    statePtr->acc[5] = XXH_PRIME32_2;
+    statePtr->acc[6] = XXH_PRIME64_5;
+    statePtr->acc[7] = XXH_PRIME32_1;
+    statePtr->seed = seed;
+    statePtr->useSeed = (seed != 0);
+    statePtr->extSecret = (const unsigned char*)secret;
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
+    statePtr->secretLimit = secretSize - XXH_STRIPE_LEN;
+    statePtr->nbStripesPerBlock = statePtr->secretLimit / XXH_SECRET_CONSUME_RATE;
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_64bits_reset(XXH3_state_t* statePtr)
+{
+    if (statePtr == NULL) return XXH_ERROR;
+    XXH3_reset_internal(statePtr, 0, XXH3_kSecret, XXH_SECRET_DEFAULT_SIZE);
+    return XXH_OK;
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_64bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize)
+{
+    if (statePtr == NULL) return XXH_ERROR;
+    XXH3_reset_internal(statePtr, 0, secret, secretSize);
+    if (secret == NULL) return XXH_ERROR;
+    if (secretSize < XXH3_SECRET_SIZE_MIN) return XXH_ERROR;
+    return XXH_OK;
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_64bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed)
+{
+    if (statePtr == NULL) return XXH_ERROR;
+    if (seed==0) return XXH3_64bits_reset(statePtr);
+    if ((seed != statePtr->seed) || (statePtr->extSecret != NULL))
+        XXH3_initCustomSecret(statePtr->customSecret, seed);
+    XXH3_reset_internal(statePtr, seed, NULL, XXH_SECRET_DEFAULT_SIZE);
+    return XXH_OK;
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_64bits_reset_withSecretandSeed(XXH3_state_t* statePtr, const void* secret, size_t secretSize, XXH64_hash_t seed64)
+{
+    if (statePtr == NULL) return XXH_ERROR;
+    if (secret == NULL) return XXH_ERROR;
+    if (secretSize < XXH3_SECRET_SIZE_MIN) return XXH_ERROR;
+    XXH3_reset_internal(statePtr, seed64, secret, secretSize);
+    statePtr->useSeed = 1; /* always, even if seed64==0 */
+    return XXH_OK;
+}
+
+/* Note : when XXH3_consumeStripes() is invoked,
+ * there must be a guarantee that at least one more byte must be consumed from input
+ * so that the function can blindly consume all stripes using the "normal" secret segment */
+XXH_FORCE_INLINE void
+XXH3_consumeStripes(xxh_u64* XXH_RESTRICT acc,
+                    size_t* XXH_RESTRICT nbStripesSoFarPtr, size_t nbStripesPerBlock,
+                    const xxh_u8* XXH_RESTRICT input, size_t nbStripes,
+                    const xxh_u8* XXH_RESTRICT secret, size_t secretLimit,
+                    XXH3_f_accumulate_512 f_acc512,
+                    XXH3_f_scrambleAcc f_scramble)
+{
+    XXH_ASSERT(nbStripes <= nbStripesPerBlock);  /* can handle max 1 scramble per invocation */
+    XXH_ASSERT(*nbStripesSoFarPtr < nbStripesPerBlock);
+    if (nbStripesPerBlock - *nbStripesSoFarPtr <= nbStripes) {
+        /* need a scrambling operation */
+        size_t const nbStripesToEndofBlock = nbStripesPerBlock - *nbStripesSoFarPtr;
+        size_t const nbStripesAfterBlock = nbStripes - nbStripesToEndofBlock;
+        XXH3_accumulate(acc, input, secret + nbStripesSoFarPtr[0] * XXH_SECRET_CONSUME_RATE, nbStripesToEndofBlock, f_acc512);
+        f_scramble(acc, secret + secretLimit);
+        XXH3_accumulate(acc, input + nbStripesToEndofBlock * XXH_STRIPE_LEN, secret, nbStripesAfterBlock, f_acc512);
+        *nbStripesSoFarPtr = nbStripesAfterBlock;
+    } else {
+        XXH3_accumulate(acc, input, secret + nbStripesSoFarPtr[0] * XXH_SECRET_CONSUME_RATE, nbStripes, f_acc512);
+        *nbStripesSoFarPtr += nbStripes;
+    }
+}
+
+#ifndef XXH3_STREAM_USE_STACK
+# ifndef __clang__ /* clang doesn't need additional stack space */
+#   define XXH3_STREAM_USE_STACK 1
+# endif
+#endif
+/*
+ * Both XXH3_64bits_update and XXH3_128bits_update use this routine.
+ */
+XXH_FORCE_INLINE XXH_errorcode
+XXH3_update(XXH3_state_t* XXH_RESTRICT const state,
+            const xxh_u8* XXH_RESTRICT input, size_t len,
+            XXH3_f_accumulate_512 f_acc512,
+            XXH3_f_scrambleAcc f_scramble)
+{
+    if (input==NULL) {
+        XXH_ASSERT(len == 0);
+        return XXH_OK;
+    }
+
+    XXH_ASSERT(state != NULL);
+    {   const xxh_u8* const bEnd = input + len;
+        const unsigned char* const secret = (state->extSecret == NULL) ? state->customSecret : state->extSecret;
+#if defined(XXH3_STREAM_USE_STACK) && XXH3_STREAM_USE_STACK >= 1
+        /* For some reason, gcc and MSVC seem to suffer greatly
+         * when operating accumulators directly into state.
+         * Operating into stack space seems to enable proper optimization.
+         * clang, on the other hand, doesn't seem to need this trick */
+        XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[8]; memcpy(acc, state->acc, sizeof(acc));
+#else
+        xxh_u64* XXH_RESTRICT const acc = state->acc;
+#endif
+        state->totalLen += len;
+        XXH_ASSERT(state->bufferedSize <= XXH3_INTERNALBUFFER_SIZE);
+
+        /* small input : just fill in tmp buffer */
+        if (state->bufferedSize + len <= XXH3_INTERNALBUFFER_SIZE) {
+            XXH_memcpy(state->buffer + state->bufferedSize, input, len);
+            state->bufferedSize += (XXH32_hash_t)len;
+            return XXH_OK;
+        }
+
+        /* total input is now > XXH3_INTERNALBUFFER_SIZE */
+        #define XXH3_INTERNALBUFFER_STRIPES (XXH3_INTERNALBUFFER_SIZE / XXH_STRIPE_LEN)
+        XXH_STATIC_ASSERT(XXH3_INTERNALBUFFER_SIZE % XXH_STRIPE_LEN == 0);   /* clean multiple */
+
+        /*
+         * Internal buffer is partially filled (always, except at beginning)
+         * Complete it, then consume it.
+         */
+        if (state->bufferedSize) {
+            size_t const loadSize = XXH3_INTERNALBUFFER_SIZE - state->bufferedSize;
+            XXH_memcpy(state->buffer + state->bufferedSize, input, loadSize);
+            input += loadSize;
+            XXH3_consumeStripes(acc,
+                               &state->nbStripesSoFar, state->nbStripesPerBlock,
+                                state->buffer, XXH3_INTERNALBUFFER_STRIPES,
+                                secret, state->secretLimit,
+                                f_acc512, f_scramble);
+            state->bufferedSize = 0;
+        }
+        XXH_ASSERT(input < bEnd);
+
+        /* large input to consume : ingest per full block */
+        if ((size_t)(bEnd - input) > state->nbStripesPerBlock * XXH_STRIPE_LEN) {
+            size_t nbStripes = (size_t)(bEnd - 1 - input) / XXH_STRIPE_LEN;
+            XXH_ASSERT(state->nbStripesPerBlock >= state->nbStripesSoFar);
+            /* join to current block's end */
+            {   size_t const nbStripesToEnd = state->nbStripesPerBlock - state->nbStripesSoFar;
+                XXH_ASSERT(nbStripesToEnd <= nbStripes);
+                XXH3_accumulate(acc, input, secret + state->nbStripesSoFar * XXH_SECRET_CONSUME_RATE, nbStripesToEnd, f_acc512);
+                f_scramble(acc, secret + state->secretLimit);
+                state->nbStripesSoFar = 0;
+                input += nbStripesToEnd * XXH_STRIPE_LEN;
+                nbStripes -= nbStripesToEnd;
+            }
+            /* consume per entire blocks */
+            while(nbStripes >= state->nbStripesPerBlock) {
+                XXH3_accumulate(acc, input, secret, state->nbStripesPerBlock, f_acc512);
+                f_scramble(acc, secret + state->secretLimit);
+                input += state->nbStripesPerBlock * XXH_STRIPE_LEN;
+                nbStripes -= state->nbStripesPerBlock;
+            }
+            /* consume last partial block */
+            XXH3_accumulate(acc, input, secret, nbStripes, f_acc512);
+            input += nbStripes * XXH_STRIPE_LEN;
+            XXH_ASSERT(input < bEnd);  /* at least some bytes left */
+            state->nbStripesSoFar = nbStripes;
+            /* buffer predecessor of last partial stripe */
+            XXH_memcpy(state->buffer + sizeof(state->buffer) - XXH_STRIPE_LEN, input - XXH_STRIPE_LEN, XXH_STRIPE_LEN);
+            XXH_ASSERT(bEnd - input <= XXH_STRIPE_LEN);
+        } else {
+            /* content to consume <= block size */
+            /* Consume input by a multiple of internal buffer size */
+            if (bEnd - input > XXH3_INTERNALBUFFER_SIZE) {
+                const xxh_u8* const limit = bEnd - XXH3_INTERNALBUFFER_SIZE;
+                do {
+                    XXH3_consumeStripes(acc,
+                                       &state->nbStripesSoFar, state->nbStripesPerBlock,
+                                        input, XXH3_INTERNALBUFFER_STRIPES,
+                                        secret, state->secretLimit,
+                                        f_acc512, f_scramble);
+                    input += XXH3_INTERNALBUFFER_SIZE;
+                } while (input<limit);
+                /* buffer predecessor of last partial stripe */
+                XXH_memcpy(state->buffer + sizeof(state->buffer) - XXH_STRIPE_LEN, input - XXH_STRIPE_LEN, XXH_STRIPE_LEN);
+            }
+        }
+
+        /* Some remaining input (always) : buffer it */
+        XXH_ASSERT(input < bEnd);
+        XXH_ASSERT(bEnd - input <= XXH3_INTERNALBUFFER_SIZE);
+        XXH_ASSERT(state->bufferedSize == 0);
+        XXH_memcpy(state->buffer, input, (size_t)(bEnd-input));
+        state->bufferedSize = (XXH32_hash_t)(bEnd-input);
+#if defined(XXH3_STREAM_USE_STACK) && XXH3_STREAM_USE_STACK >= 1
+        /* save stack accumulators into state */
+        memcpy(state->acc, acc, sizeof(acc));
+#endif
+    }
+
+    return XXH_OK;
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_64bits_update(XXH3_state_t* state, const void* input, size_t len)
+{
+    return XXH3_update(state, (const xxh_u8*)input, len,
+                       XXH3_accumulate_512, XXH3_scrambleAcc);
+}
+
+
+XXH_FORCE_INLINE void
+XXH3_digest_long (XXH64_hash_t* acc,
+                  const XXH3_state_t* state,
+                  const unsigned char* secret)
+{
+    /*
+     * Digest on a local copy. This way, the state remains unaltered, and it can
+     * continue ingesting more input afterwards.
+     */
+    XXH_memcpy(acc, state->acc, sizeof(state->acc));
+    if (state->bufferedSize >= XXH_STRIPE_LEN) {
+        size_t const nbStripes = (state->bufferedSize - 1) / XXH_STRIPE_LEN;
+        size_t nbStripesSoFar = state->nbStripesSoFar;
+        XXH3_consumeStripes(acc,
+                           &nbStripesSoFar, state->nbStripesPerBlock,
+                            state->buffer, nbStripes,
+                            secret, state->secretLimit,
+                            XXH3_accumulate_512, XXH3_scrambleAcc);
+        /* last stripe */
+        XXH3_accumulate_512(acc,
+                            state->buffer + state->bufferedSize - XXH_STRIPE_LEN,
+                            secret + state->secretLimit - XXH_SECRET_LASTACC_START);
+    } else {  /* bufferedSize < XXH_STRIPE_LEN */
+        xxh_u8 lastStripe[XXH_STRIPE_LEN];
+        size_t const catchupSize = XXH_STRIPE_LEN - state->bufferedSize;
+        XXH_ASSERT(state->bufferedSize > 0);  /* there is always some input buffered */
+        XXH_memcpy(lastStripe, state->buffer + sizeof(state->buffer) - catchupSize, catchupSize);
+        XXH_memcpy(lastStripe + catchupSize, state->buffer, state->bufferedSize);
+        XXH3_accumulate_512(acc,
+                            lastStripe,
+                            secret + state->secretLimit - XXH_SECRET_LASTACC_START);
+    }
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_digest (const XXH3_state_t* state)
+{
+    const unsigned char* const secret = (state->extSecret == NULL) ? state->customSecret : state->extSecret;
+    if (state->totalLen > XXH3_MIDSIZE_MAX) {
+        XXH_ALIGN(XXH_ACC_ALIGN) XXH64_hash_t acc[XXH_ACC_NB];
+        XXH3_digest_long(acc, state, secret);
+        return XXH3_mergeAccs(acc,
+                              secret + XXH_SECRET_MERGEACCS_START,
+                              (xxh_u64)state->totalLen * XXH_PRIME64_1);
+    }
+    /* totalLen <= XXH3_MIDSIZE_MAX: digesting a short input */
+    if (state->useSeed)
+        return XXH3_64bits_withSeed(state->buffer, (size_t)state->totalLen, state->seed);
+    return XXH3_64bits_withSecret(state->buffer, (size_t)(state->totalLen),
+                                  secret, state->secretLimit + XXH_STRIPE_LEN);
+}
+
+
+
+/* ==========================================
+ * XXH3 128 bits (a.k.a XXH128)
+ * ==========================================
+ * XXH3's 128-bit variant has better mixing and strength than the 64-bit variant,
+ * even without counting the significantly larger output size.
+ *
+ * For example, extra steps are taken to avoid the seed-dependent collisions
+ * in 17-240 byte inputs (See XXH3_mix16B and XXH128_mix32B).
+ *
+ * This strength naturally comes at the cost of some speed, especially on short
+ * lengths. Note that longer hashes are about as fast as the 64-bit version
+ * due to it using only a slight modification of the 64-bit loop.
+ *
+ * XXH128 is also more oriented towards 64-bit machines. It is still extremely
+ * fast for a _128-bit_ hash on 32-bit (it usually clears XXH64).
+ */
+
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_len_1to3_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    /* A doubled version of 1to3_64b with different constants. */
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(1 <= len && len <= 3);
+    XXH_ASSERT(secret != NULL);
+    /*
+     * len = 1: combinedl = { input[0], 0x01, input[0], input[0] }
+     * len = 2: combinedl = { input[1], 0x02, input[0], input[1] }
+     * len = 3: combinedl = { input[2], 0x03, input[0], input[1] }
+     */
+    {   xxh_u8 const c1 = input[0];
+        xxh_u8 const c2 = input[len >> 1];
+        xxh_u8 const c3 = input[len - 1];
+        xxh_u32 const combinedl = ((xxh_u32)c1 <<16) | ((xxh_u32)c2 << 24)
+                                | ((xxh_u32)c3 << 0) | ((xxh_u32)len << 8);
+        xxh_u32 const combinedh = XXH_rotl32(XXH_swap32(combinedl), 13);
+        xxh_u64 const bitflipl = (XXH_readLE32(secret) ^ XXH_readLE32(secret+4)) + seed;
+        xxh_u64 const bitfliph = (XXH_readLE32(secret+8) ^ XXH_readLE32(secret+12)) - seed;
+        xxh_u64 const keyed_lo = (xxh_u64)combinedl ^ bitflipl;
+        xxh_u64 const keyed_hi = (xxh_u64)combinedh ^ bitfliph;
+        XXH128_hash_t h128;
+        h128.low64  = XXH64_avalanche(keyed_lo);
+        h128.high64 = XXH64_avalanche(keyed_hi);
+        return h128;
+    }
+}
+
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_len_4to8_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(secret != NULL);
+    XXH_ASSERT(4 <= len && len <= 8);
+    seed ^= (xxh_u64)XXH_swap32((xxh_u32)seed) << 32;
+    {   xxh_u32 const input_lo = XXH_readLE32(input);
+        xxh_u32 const input_hi = XXH_readLE32(input + len - 4);
+        xxh_u64 const input_64 = input_lo + ((xxh_u64)input_hi << 32);
+        xxh_u64 const bitflip = (XXH_readLE64(secret+16) ^ XXH_readLE64(secret+24)) + seed;
+        xxh_u64 const keyed = input_64 ^ bitflip;
+
+        /* Shift len to the left to ensure it is even, this avoids even multiplies. */
+        XXH128_hash_t m128 = XXH_mult64to128(keyed, XXH_PRIME64_1 + (len << 2));
+
+        m128.high64 += (m128.low64 << 1);
+        m128.low64  ^= (m128.high64 >> 3);
+
+        m128.low64   = XXH_xorshift64(m128.low64, 35);
+        m128.low64  *= 0x9FB21C651E98DF25ULL;
+        m128.low64   = XXH_xorshift64(m128.low64, 28);
+        m128.high64  = XXH3_avalanche(m128.high64);
+        return m128;
+    }
+}
+
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_len_9to16_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(secret != NULL);
+    XXH_ASSERT(9 <= len && len <= 16);
+    {   xxh_u64 const bitflipl = (XXH_readLE64(secret+32) ^ XXH_readLE64(secret+40)) - seed;
+        xxh_u64 const bitfliph = (XXH_readLE64(secret+48) ^ XXH_readLE64(secret+56)) + seed;
+        xxh_u64 const input_lo = XXH_readLE64(input);
+        xxh_u64       input_hi = XXH_readLE64(input + len - 8);
+        XXH128_hash_t m128 = XXH_mult64to128(input_lo ^ input_hi ^ bitflipl, XXH_PRIME64_1);
+        /*
+         * Put len in the middle of m128 to ensure that the length gets mixed to
+         * both the low and high bits in the 128x64 multiply below.
+         */
+        m128.low64 += (xxh_u64)(len - 1) << 54;
+        input_hi   ^= bitfliph;
+        /*
+         * Add the high 32 bits of input_hi to the high 32 bits of m128, then
+         * add the long product of the low 32 bits of input_hi and XXH_PRIME32_2 to
+         * the high 64 bits of m128.
+         *
+         * The best approach to this operation is different on 32-bit and 64-bit.
+         */
+        if (sizeof(void *) < sizeof(xxh_u64)) { /* 32-bit */
+            /*
+             * 32-bit optimized version, which is more readable.
+             *
+             * On 32-bit, it removes an ADC and delays a dependency between the two
+             * halves of m128.high64, but it generates an extra mask on 64-bit.
+             */
+            m128.high64 += (input_hi & 0xFFFFFFFF00000000ULL) + XXH_mult32to64((xxh_u32)input_hi, XXH_PRIME32_2);
+        } else {
+            /*
+             * 64-bit optimized (albeit more confusing) version.
+             *
+             * Uses some properties of addition and multiplication to remove the mask:
+             *
+             * Let:
+             *    a = input_hi.lo = (input_hi & 0x00000000FFFFFFFF)
+             *    b = input_hi.hi = (input_hi & 0xFFFFFFFF00000000)
+             *    c = XXH_PRIME32_2
+             *
+             *    a + (b * c)
+             * Inverse Property: x + y - x == y
+             *    a + (b * (1 + c - 1))
+             * Distributive Property: x * (y + z) == (x * y) + (x * z)
+             *    a + (b * 1) + (b * (c - 1))
+             * Identity Property: x * 1 == x
+             *    a + b + (b * (c - 1))
+             *
+             * Substitute a, b, and c:
+             *    input_hi.hi + input_hi.lo + ((xxh_u64)input_hi.lo * (XXH_PRIME32_2 - 1))
+             *
+             * Since input_hi.hi + input_hi.lo == input_hi, we get this:
+             *    input_hi + ((xxh_u64)input_hi.lo * (XXH_PRIME32_2 - 1))
+             */
+            m128.high64 += input_hi + XXH_mult32to64((xxh_u32)input_hi, XXH_PRIME32_2 - 1);
+        }
+        /* m128 ^= XXH_swap64(m128 >> 64); */
+        m128.low64  ^= XXH_swap64(m128.high64);
+
+        {   /* 128x64 multiply: h128 = m128 * XXH_PRIME64_2; */
+            XXH128_hash_t h128 = XXH_mult64to128(m128.low64, XXH_PRIME64_2);
+            h128.high64 += m128.high64 * XXH_PRIME64_2;
+
+            h128.low64   = XXH3_avalanche(h128.low64);
+            h128.high64  = XXH3_avalanche(h128.high64);
+            return h128;
+    }   }
+}
+
+/*
+ * Assumption: `secret` size is >= XXH3_SECRET_SIZE_MIN
+ */
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_len_0to16_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(len <= 16);
+    {   if (len > 8) return XXH3_len_9to16_128b(input, len, secret, seed);
+        if (len >= 4) return XXH3_len_4to8_128b(input, len, secret, seed);
+        if (len) return XXH3_len_1to3_128b(input, len, secret, seed);
+        {   XXH128_hash_t h128;
+            xxh_u64 const bitflipl = XXH_readLE64(secret+64) ^ XXH_readLE64(secret+72);
+            xxh_u64 const bitfliph = XXH_readLE64(secret+80) ^ XXH_readLE64(secret+88);
+            h128.low64 = XXH64_avalanche(seed ^ bitflipl);
+            h128.high64 = XXH64_avalanche( seed ^ bitfliph);
+            return h128;
+    }   }
+}
+
+/*
+ * A bit slower than XXH3_mix16B, but handles multiply by zero better.
+ */
+XXH_FORCE_INLINE XXH128_hash_t
+XXH128_mix32B(XXH128_hash_t acc, const xxh_u8* input_1, const xxh_u8* input_2,
+              const xxh_u8* secret, XXH64_hash_t seed)
+{
+    acc.low64  += XXH3_mix16B (input_1, secret+0, seed);
+    acc.low64  ^= XXH_readLE64(input_2) + XXH_readLE64(input_2 + 8);
+    acc.high64 += XXH3_mix16B (input_2, secret+16, seed);
+    acc.high64 ^= XXH_readLE64(input_1) + XXH_readLE64(input_1 + 8);
+    return acc;
+}
+
+
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_len_17to128_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                      XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(16 < len && len <= 128);
+
+    {   XXH128_hash_t acc;
+        acc.low64 = len * XXH_PRIME64_1;
+        acc.high64 = 0;
+        if (len > 32) {
+            if (len > 64) {
+                if (len > 96) {
+                    acc = XXH128_mix32B(acc, input+48, input+len-64, secret+96, seed);
+                }
+                acc = XXH128_mix32B(acc, input+32, input+len-48, secret+64, seed);
+            }
+            acc = XXH128_mix32B(acc, input+16, input+len-32, secret+32, seed);
+        }
+        acc = XXH128_mix32B(acc, input, input+len-16, secret, seed);
+        {   XXH128_hash_t h128;
+            h128.low64  = acc.low64 + acc.high64;
+            h128.high64 = (acc.low64    * XXH_PRIME64_1)
+                        + (acc.high64   * XXH_PRIME64_4)
+                        + ((len - seed) * XXH_PRIME64_2);
+            h128.low64  = XXH3_avalanche(h128.low64);
+            h128.high64 = (XXH64_hash_t)0 - XXH3_avalanche(h128.high64);
+            return h128;
+        }
+    }
+}
+
+XXH_NO_INLINE XXH128_hash_t
+XXH3_len_129to240_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                       const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                       XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(128 < len && len <= XXH3_MIDSIZE_MAX);
+
+    {   XXH128_hash_t acc;
+        int const nbRounds = (int)len / 32;
+        int i;
+        acc.low64 = len * XXH_PRIME64_1;
+        acc.high64 = 0;
+        for (i=0; i<4; i++) {
+            acc = XXH128_mix32B(acc,
+                                input  + (32 * i),
+                                input  + (32 * i) + 16,
+                                secret + (32 * i),
+                                seed);
+        }
+        acc.low64 = XXH3_avalanche(acc.low64);
+        acc.high64 = XXH3_avalanche(acc.high64);
+        XXH_ASSERT(nbRounds >= 4);
+        for (i=4 ; i < nbRounds; i++) {
+            acc = XXH128_mix32B(acc,
+                                input + (32 * i),
+                                input + (32 * i) + 16,
+                                secret + XXH3_MIDSIZE_STARTOFFSET + (32 * (i - 4)),
+                                seed);
+        }
+        /* last bytes */
+        acc = XXH128_mix32B(acc,
+                            input + len - 16,
+                            input + len - 32,
+                            secret + XXH3_SECRET_SIZE_MIN - XXH3_MIDSIZE_LASTOFFSET - 16,
+                            0ULL - seed);
+
+        {   XXH128_hash_t h128;
+            h128.low64  = acc.low64 + acc.high64;
+            h128.high64 = (acc.low64    * XXH_PRIME64_1)
+                        + (acc.high64   * XXH_PRIME64_4)
+                        + ((len - seed) * XXH_PRIME64_2);
+            h128.low64  = XXH3_avalanche(h128.low64);
+            h128.high64 = (XXH64_hash_t)0 - XXH3_avalanche(h128.high64);
+            return h128;
+        }
+    }
+}
+
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_hashLong_128b_internal(const void* XXH_RESTRICT input, size_t len,
+                            const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                            XXH3_f_accumulate_512 f_acc512,
+                            XXH3_f_scrambleAcc f_scramble)
+{
+    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[XXH_ACC_NB] = XXH3_INIT_ACC;
+
+    XXH3_hashLong_internal_loop(acc, (const xxh_u8*)input, len, secret, secretSize, f_acc512, f_scramble);
+
+    /* converge into final hash */
+    XXH_STATIC_ASSERT(sizeof(acc) == 64);
+    XXH_ASSERT(secretSize >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
+    {   XXH128_hash_t h128;
+        h128.low64  = XXH3_mergeAccs(acc,
+                                     secret + XXH_SECRET_MERGEACCS_START,
+                                     (xxh_u64)len * XXH_PRIME64_1);
+        h128.high64 = XXH3_mergeAccs(acc,
+                                     secret + secretSize
+                                            - sizeof(acc) - XXH_SECRET_MERGEACCS_START,
+                                     ~((xxh_u64)len * XXH_PRIME64_2));
+        return h128;
+    }
+}
+
+/*
+ * It's important for performance that XXH3_hashLong is not inlined.
+ */
+XXH_NO_INLINE XXH128_hash_t
+XXH3_hashLong_128b_default(const void* XXH_RESTRICT input, size_t len,
+                           XXH64_hash_t seed64,
+                           const void* XXH_RESTRICT secret, size_t secretLen)
+{
+    (void)seed64; (void)secret; (void)secretLen;
+    return XXH3_hashLong_128b_internal(input, len, XXH3_kSecret, sizeof(XXH3_kSecret),
+                                       XXH3_accumulate_512, XXH3_scrambleAcc);
+}
+
+/*
+ * It's important for performance to pass @secretLen (when it's static)
+ * to the compiler, so that it can properly optimize the vectorized loop.
+ */
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_hashLong_128b_withSecret(const void* XXH_RESTRICT input, size_t len,
+                              XXH64_hash_t seed64,
+                              const void* XXH_RESTRICT secret, size_t secretLen)
+{
+    (void)seed64;
+    return XXH3_hashLong_128b_internal(input, len, (const xxh_u8*)secret, secretLen,
+                                       XXH3_accumulate_512, XXH3_scrambleAcc);
+}
+
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_hashLong_128b_withSeed_internal(const void* XXH_RESTRICT input, size_t len,
+                                XXH64_hash_t seed64,
+                                XXH3_f_accumulate_512 f_acc512,
+                                XXH3_f_scrambleAcc f_scramble,
+                                XXH3_f_initCustomSecret f_initSec)
+{
+    if (seed64 == 0)
+        return XXH3_hashLong_128b_internal(input, len,
+                                           XXH3_kSecret, sizeof(XXH3_kSecret),
+                                           f_acc512, f_scramble);
+    {   XXH_ALIGN(XXH_SEC_ALIGN) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
+        f_initSec(secret, seed64);
+        return XXH3_hashLong_128b_internal(input, len, (const xxh_u8*)secret, sizeof(secret),
+                                           f_acc512, f_scramble);
+    }
+}
+
+/*
+ * It's important for performance that XXH3_hashLong is not inlined.
+ */
+XXH_NO_INLINE XXH128_hash_t
+XXH3_hashLong_128b_withSeed(const void* input, size_t len,
+                            XXH64_hash_t seed64, const void* XXH_RESTRICT secret, size_t secretLen)
+{
+    (void)secret; (void)secretLen;
+    return XXH3_hashLong_128b_withSeed_internal(input, len, seed64,
+                XXH3_accumulate_512, XXH3_scrambleAcc, XXH3_initCustomSecret);
+}
+
+typedef XXH128_hash_t (*XXH3_hashLong128_f)(const void* XXH_RESTRICT, size_t,
+                                            XXH64_hash_t, const void* XXH_RESTRICT, size_t);
+
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_128bits_internal(const void* input, size_t len,
+                      XXH64_hash_t seed64, const void* XXH_RESTRICT secret, size_t secretLen,
+                      XXH3_hashLong128_f f_hl128)
+{
+    XXH_ASSERT(secretLen >= XXH3_SECRET_SIZE_MIN);
+    /*
+     * If an action is to be taken if `secret` conditions are not respected,
+     * it should be done here.
+     * For now, it's a contract pre-condition.
+     * Adding a check and a branch here would cost performance at every hash.
+     */
+    if (len <= 16)
+        return XXH3_len_0to16_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, seed64);
+    if (len <= 128)
+        return XXH3_len_17to128_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
+    if (len <= XXH3_MIDSIZE_MAX)
+        return XXH3_len_129to240_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
+    return f_hl128(input, len, seed64, secret, secretLen);
+}
+
+
+/* ===   Public XXH128 API   === */
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH128_hash_t XXH3_128bits(const void* input, size_t len)
+{
+    return XXH3_128bits_internal(input, len, 0,
+                                 XXH3_kSecret, sizeof(XXH3_kSecret),
+                                 XXH3_hashLong_128b_default);
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH128_hash_t
+XXH3_128bits_withSecret(const void* input, size_t len, const void* secret, size_t secretSize)
+{
+    return XXH3_128bits_internal(input, len, 0,
+                                 (const xxh_u8*)secret, secretSize,
+                                 XXH3_hashLong_128b_withSecret);
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH128_hash_t
+XXH3_128bits_withSeed(const void* input, size_t len, XXH64_hash_t seed)
+{
+    return XXH3_128bits_internal(input, len, seed,
+                                 XXH3_kSecret, sizeof(XXH3_kSecret),
+                                 XXH3_hashLong_128b_withSeed);
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH128_hash_t
+XXH3_128bits_withSecretandSeed(const void* input, size_t len, const void* secret, size_t secretSize, XXH64_hash_t seed)
+{
+    if (len <= XXH3_MIDSIZE_MAX)
+        return XXH3_128bits_internal(input, len, seed, XXH3_kSecret, sizeof(XXH3_kSecret), NULL);
+    return XXH3_hashLong_128b_withSecret(input, len, seed, secret, secretSize);
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH128_hash_t
+XXH128(const void* input, size_t len, XXH64_hash_t seed)
+{
+    return XXH3_128bits_withSeed(input, len, seed);
+}
+
+
+/* ===   XXH3 128-bit streaming   === */
+
+/*
+ * All initialization and update functions are identical to 64-bit streaming variant.
+ * The only difference is the finalization routine.
+ */
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_128bits_reset(XXH3_state_t* statePtr)
+{
+    return XXH3_64bits_reset(statePtr);
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize)
+{
+    return XXH3_64bits_reset_withSecret(statePtr, secret, secretSize);
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed)
+{
+    return XXH3_64bits_reset_withSeed(statePtr, seed);
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_128bits_reset_withSecretandSeed(XXH3_state_t* statePtr, const void* secret, size_t secretSize, XXH64_hash_t seed)
+{
+    return XXH3_64bits_reset_withSecretandSeed(statePtr, secret, secretSize, seed);
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_128bits_update(XXH3_state_t* state, const void* input, size_t len)
+{
+    return XXH3_update(state, (const xxh_u8*)input, len,
+                       XXH3_accumulate_512, XXH3_scrambleAcc);
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_digest (const XXH3_state_t* state)
+{
+    const unsigned char* const secret = (state->extSecret == NULL) ? state->customSecret : state->extSecret;
+    if (state->totalLen > XXH3_MIDSIZE_MAX) {
+        XXH_ALIGN(XXH_ACC_ALIGN) XXH64_hash_t acc[XXH_ACC_NB];
+        XXH3_digest_long(acc, state, secret);
+        XXH_ASSERT(state->secretLimit + XXH_STRIPE_LEN >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
+        {   XXH128_hash_t h128;
+            h128.low64  = XXH3_mergeAccs(acc,
+                                         secret + XXH_SECRET_MERGEACCS_START,
+                                         (xxh_u64)state->totalLen * XXH_PRIME64_1);
+            h128.high64 = XXH3_mergeAccs(acc,
+                                         secret + state->secretLimit + XXH_STRIPE_LEN
+                                                - sizeof(acc) - XXH_SECRET_MERGEACCS_START,
+                                         ~((xxh_u64)state->totalLen * XXH_PRIME64_2));
+            return h128;
+        }
+    }
+    /* len <= XXH3_MIDSIZE_MAX : short code */
+    if (state->seed)
+        return XXH3_128bits_withSeed(state->buffer, (size_t)state->totalLen, state->seed);
+    return XXH3_128bits_withSecret(state->buffer, (size_t)(state->totalLen),
+                                   secret, state->secretLimit + XXH_STRIPE_LEN);
+}
+
+/* 128-bit utility functions */
+
+#include <string.h>   /* memcmp, memcpy */
+
+/* return : 1 is equal, 0 if different */
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API int XXH128_isEqual(XXH128_hash_t h1, XXH128_hash_t h2)
+{
+    /* note : XXH128_hash_t is compact, it has no padding byte */
+    return !(memcmp(&h1, &h2, sizeof(h1)));
+}
+
+/* This prototype is compatible with stdlib's qsort().
+ * return : >0 if *h128_1  > *h128_2
+ *          <0 if *h128_1  < *h128_2
+ *          =0 if *h128_1 == *h128_2  */
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API int XXH128_cmp(const void* h128_1, const void* h128_2)
+{
+    XXH128_hash_t const h1 = *(const XXH128_hash_t*)h128_1;
+    XXH128_hash_t const h2 = *(const XXH128_hash_t*)h128_2;
+    int const hcmp = (h1.high64 > h2.high64) - (h2.high64 > h1.high64);
+    /* note : bets that, in most cases, hash values are different */
+    if (hcmp) return hcmp;
+    return (h1.low64 > h2.low64) - (h2.low64 > h1.low64);
+}
+
+
+/*======   Canonical representation   ======*/
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API void
+XXH128_canonicalFromHash(XXH128_canonical_t* dst, XXH128_hash_t hash)
+{
+    XXH_STATIC_ASSERT(sizeof(XXH128_canonical_t) == sizeof(XXH128_hash_t));
+    if (XXH_CPU_LITTLE_ENDIAN) {
+        hash.high64 = XXH_swap64(hash.high64);
+        hash.low64  = XXH_swap64(hash.low64);
+    }
+    XXH_memcpy(dst, &hash.high64, sizeof(hash.high64));
+    XXH_memcpy((char*)dst + sizeof(hash.high64), &hash.low64, sizeof(hash.low64));
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH128_hash_t
+XXH128_hashFromCanonical(const XXH128_canonical_t* src)
+{
+    XXH128_hash_t h;
+    h.high64 = XXH_readBE64(src);
+    h.low64  = XXH_readBE64(src->digest + 8);
+    return h;
+}
+
+
+
+/* ==========================================
+ * Secret generators
+ * ==========================================
+ */
+#define XXH_MIN(x, y) (((x) > (y)) ? (y) : (x))
+
+XXH_FORCE_INLINE void XXH3_combine16(void* dst, XXH128_hash_t h128)
+{
+    XXH_writeLE64( dst, XXH_readLE64(dst) ^ h128.low64 );
+    XXH_writeLE64( (char*)dst+8, XXH_readLE64((char*)dst+8) ^ h128.high64 );
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API XXH_errorcode
+XXH3_generateSecret(void* secretBuffer, size_t secretSize, const void* customSeed, size_t customSeedSize)
+{
+#if (XXH_DEBUGLEVEL >= 1)
+    XXH_ASSERT(secretBuffer != NULL);
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
+#else
+    /* production mode, assert() are disabled */
+    if (secretBuffer == NULL) return XXH_ERROR;
+    if (secretSize < XXH3_SECRET_SIZE_MIN) return XXH_ERROR;
+#endif
+
+    if (customSeedSize == 0) {
+        customSeed = XXH3_kSecret;
+        customSeedSize = XXH_SECRET_DEFAULT_SIZE;
+    }
+#if (XXH_DEBUGLEVEL >= 1)
+    XXH_ASSERT(customSeed != NULL);
+#else
+    if (customSeed == NULL) return XXH_ERROR;
+#endif
+
+    /* Fill secretBuffer with a copy of customSeed - repeat as needed */
+    {   size_t pos = 0;
+        while (pos < secretSize) {
+            size_t const toCopy = XXH_MIN((secretSize - pos), customSeedSize);
+            memcpy((char*)secretBuffer + pos, customSeed, toCopy);
+            pos += toCopy;
+    }   }
+
+    {   size_t const nbSeg16 = secretSize / 16;
+        size_t n;
+        XXH128_canonical_t scrambler;
+        XXH128_canonicalFromHash(&scrambler, XXH128(customSeed, customSeedSize, 0));
+        for (n=0; n<nbSeg16; n++) {
+            XXH128_hash_t const h128 = XXH128(&scrambler, sizeof(scrambler), n);
+            XXH3_combine16((char*)secretBuffer + n*16, h128);
+        }
+        /* last segment */
+        XXH3_combine16((char*)secretBuffer + secretSize - 16, XXH128_hashFromCanonical(&scrambler));
+    }
+    return XXH_OK;
+}
+
+/*! @ingroup xxh3_family */
+XXH_PUBLIC_API void
+XXH3_generateSecret_fromSeed(void* secretBuffer, XXH64_hash_t seed)
+{
+    XXH_ALIGN(XXH_SEC_ALIGN) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
+    XXH3_initCustomSecret(secret, seed);
+    XXH_ASSERT(secretBuffer != NULL);
+    memcpy(secretBuffer, secret, XXH_SECRET_DEFAULT_SIZE);
+}
+
+
+
+/* Pop our optimization override from above */
+#if XXH_VECTOR == XXH_AVX2 /* AVX2 */ \
+  && defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
+  && defined(__OPTIMIZE__) && !defined(__OPTIMIZE_SIZE__) /* respect -O0 and -Os */
+#  pragma GCC pop_options
+#endif
+
+#endif  /* XXH_NO_LONG_LONG */
+
+#endif  /* XXH_NO_XXH3 */
+
+/*!
+ * @}
+ */
+#endif  /* XXH_IMPLEMENTATION */
+
+
+#if defined (__cplusplus)
+}
+#endif
diff --git a/src/3rdparty/zstd/src/common/zstd_common.c b/src/3rdparty/zstd/src/common/zstd_common.c
new file mode 100644
index 0000000000..3f04c22abf
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/zstd_common.c
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+
+
+/*-*************************************
+*  Dependencies
+***************************************/
+#define ZSTD_DEPS_NEED_MALLOC
+#include "error_private.h"
+#include "zstd_internal.h"
+
+
+/*-****************************************
+*  Version
+******************************************/
+unsigned ZSTD_versionNumber(void) { return ZSTD_VERSION_NUMBER; }
+
+const char* ZSTD_versionString(void) { return ZSTD_VERSION_STRING; }
+
+
+/*-****************************************
+*  ZSTD Error Management
+******************************************/
+#undef ZSTD_isError   /* defined within zstd_internal.h */
+/*! ZSTD_isError() :
+ *  tells if a return value is an error code
+ *  symbol is required for external callers */
+unsigned ZSTD_isError(size_t code) { return ERR_isError(code); }
+
+/*! ZSTD_getErrorName() :
+ *  provides error code string from function result (useful for debugging) */
+const char* ZSTD_getErrorName(size_t code) { return ERR_getErrorName(code); }
+
+/*! ZSTD_getError() :
+ *  convert a `size_t` function result into a proper ZSTD_errorCode enum */
+ZSTD_ErrorCode ZSTD_getErrorCode(size_t code) { return ERR_getErrorCode(code); }
+
+/*! ZSTD_getErrorString() :
+ *  provides error code string from enum */
+const char* ZSTD_getErrorString(ZSTD_ErrorCode code) { return ERR_getErrorString(code); }
diff --git a/src/3rdparty/zstd/src/common/zstd_deps.h b/src/3rdparty/zstd/src/common/zstd_deps.h
new file mode 100644
index 0000000000..4d767ae9b0
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/zstd_deps.h
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+/* This file provides common libc dependencies that zstd requires.
+ * The purpose is to allow replacing this file with a custom implementation
+ * to compile zstd without libc support.
+ */
+
+/* Need:
+ * NULL
+ * INT_MAX
+ * UINT_MAX
+ * ZSTD_memcpy()
+ * ZSTD_memset()
+ * ZSTD_memmove()
+ */
+#ifndef ZSTD_DEPS_COMMON
+#define ZSTD_DEPS_COMMON
+
+#include <limits.h>
+#include <stddef.h>
+#include <string.h>
+
+#if defined(__GNUC__) && __GNUC__ >= 4
+# define ZSTD_memcpy(d,s,l) __builtin_memcpy((d),(s),(l))
+# define ZSTD_memmove(d,s,l) __builtin_memmove((d),(s),(l))
+# define ZSTD_memset(p,v,l) __builtin_memset((p),(v),(l))
+#else
+# define ZSTD_memcpy(d,s,l) memcpy((d),(s),(l))
+# define ZSTD_memmove(d,s,l) memmove((d),(s),(l))
+# define ZSTD_memset(p,v,l) memset((p),(v),(l))
+#endif
+
+#endif /* ZSTD_DEPS_COMMON */
+
+/* Need:
+ * ZSTD_malloc()
+ * ZSTD_free()
+ * ZSTD_calloc()
+ */
+#ifdef ZSTD_DEPS_NEED_MALLOC
+#ifndef ZSTD_DEPS_MALLOC
+#define ZSTD_DEPS_MALLOC
+
+#include <stdlib.h>
+
+#define ZSTD_malloc(s) malloc(s)
+#define ZSTD_calloc(n,s) calloc((n), (s))
+#define ZSTD_free(p) free((p))
+
+#endif /* ZSTD_DEPS_MALLOC */
+#endif /* ZSTD_DEPS_NEED_MALLOC */
+
+/*
+ * Provides 64-bit math support.
+ * Need:
+ * U64 ZSTD_div64(U64 dividend, U32 divisor)
+ */
+#ifdef ZSTD_DEPS_NEED_MATH64
+#ifndef ZSTD_DEPS_MATH64
+#define ZSTD_DEPS_MATH64
+
+#define ZSTD_div64(dividend, divisor) ((dividend) / (divisor))
+
+#endif /* ZSTD_DEPS_MATH64 */
+#endif /* ZSTD_DEPS_NEED_MATH64 */
+
+/* Need:
+ * assert()
+ */
+#ifdef ZSTD_DEPS_NEED_ASSERT
+#ifndef ZSTD_DEPS_ASSERT
+#define ZSTD_DEPS_ASSERT
+
+#include <assert.h>
+
+#endif /* ZSTD_DEPS_ASSERT */
+#endif /* ZSTD_DEPS_NEED_ASSERT */
+
+/* Need:
+ * ZSTD_DEBUG_PRINT()
+ */
+#ifdef ZSTD_DEPS_NEED_IO
+#ifndef ZSTD_DEPS_IO
+#define ZSTD_DEPS_IO
+
+#include <stdio.h>
+#define ZSTD_DEBUG_PRINT(...) fprintf(stderr, __VA_ARGS__)
+
+#endif /* ZSTD_DEPS_IO */
+#endif /* ZSTD_DEPS_NEED_IO */
+
+/* Only requested when <stdint.h> is known to be present.
+ * Need:
+ * intptr_t
+ */
+#ifdef ZSTD_DEPS_NEED_STDINT
+#ifndef ZSTD_DEPS_STDINT
+#define ZSTD_DEPS_STDINT
+
+#include <stdint.h>
+
+#endif /* ZSTD_DEPS_STDINT */
+#endif /* ZSTD_DEPS_NEED_STDINT */
diff --git a/src/3rdparty/zstd/src/common/zstd_internal.h b/src/3rdparty/zstd/src/common/zstd_internal.h
new file mode 100644
index 0000000000..1f942f27bf
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/zstd_internal.h
@@ -0,0 +1,392 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_CCOMMON_H_MODULE
+#define ZSTD_CCOMMON_H_MODULE
+
+/* this module contains definitions which must be identical
+ * across compression, decompression and dictBuilder.
+ * It also contains a few functions useful to at least 2 of them
+ * and which benefit from being inlined */
+
+/*-*************************************
+*  Dependencies
+***************************************/
+#include "compiler.h"
+#include "cpu.h"
+#include "mem.h"
+#include "debug.h"                 /* assert, DEBUGLOG, RAWLOG, g_debuglevel */
+#include "error_private.h"
+#define ZSTD_STATIC_LINKING_ONLY
+#include "../zstd.h"
+#define FSE_STATIC_LINKING_ONLY
+#include "fse.h"
+#include "huf.h"
+#ifndef XXH_STATIC_LINKING_ONLY
+#  define XXH_STATIC_LINKING_ONLY  /* XXH64_state_t */
+#endif
+#include "xxhash.h"                /* XXH_reset, update, digest */
+#ifndef ZSTD_NO_TRACE
+#  include "zstd_trace.h"
+#else
+#  define ZSTD_TRACE 0
+#endif
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+/* ---- static assert (debug) --- */
+#define ZSTD_STATIC_ASSERT(c) DEBUG_STATIC_ASSERT(c)
+#define ZSTD_isError ERR_isError   /* for inlining */
+#define FSE_isError  ERR_isError
+#define HUF_isError  ERR_isError
+
+
+/*-*************************************
+*  shared macros
+***************************************/
+#undef MIN
+#undef MAX
+#define MIN(a,b) ((a)<(b) ? (a) : (b))
+#define MAX(a,b) ((a)>(b) ? (a) : (b))
+#define BOUNDED(min,val,max) (MAX(min,MIN(val,max)))
+
+
+/*-*************************************
+*  Common constants
+***************************************/
+#define ZSTD_OPT_NUM    (1<<12)
+
+#define ZSTD_REP_NUM      3                 /* number of repcodes */
+static UNUSED_ATTR const U32 repStartValue[ZSTD_REP_NUM] = { 1, 4, 8 };
+
+#define KB *(1 <<10)
+#define MB *(1 <<20)
+#define GB *(1U<<30)
+
+#define BIT7 128
+#define BIT6  64
+#define BIT5  32
+#define BIT4  16
+#define BIT1   2
+#define BIT0   1
+
+#define ZSTD_WINDOWLOG_ABSOLUTEMIN 10
+static UNUSED_ATTR const size_t ZSTD_fcs_fieldSize[4] = { 0, 2, 4, 8 };
+static UNUSED_ATTR const size_t ZSTD_did_fieldSize[4] = { 0, 1, 2, 4 };
+
+#define ZSTD_FRAMEIDSIZE 4   /* magic number size */
+
+#define ZSTD_BLOCKHEADERSIZE 3   /* C standard doesn't allow `static const` variable to be init using another `static const` variable */
+static UNUSED_ATTR const size_t ZSTD_blockHeaderSize = ZSTD_BLOCKHEADERSIZE;
+typedef enum { bt_raw, bt_rle, bt_compressed, bt_reserved } blockType_e;
+
+#define ZSTD_FRAMECHECKSUMSIZE 4
+
+#define MIN_SEQUENCES_SIZE 1 /* nbSeq==0 */
+#define MIN_CBLOCK_SIZE (1 /*litCSize*/ + 1 /* RLE or RAW */)   /* for a non-null block */
+#define MIN_LITERALS_FOR_4_STREAMS 6
+
+typedef enum { set_basic, set_rle, set_compressed, set_repeat } symbolEncodingType_e;
+
+#define LONGNBSEQ 0x7F00
+
+#define MINMATCH 3
+
+#define Litbits  8
+#define LitHufLog 11
+#define MaxLit ((1<<Litbits) - 1)
+#define MaxML   52
+#define MaxLL   35
+#define DefaultMaxOff 28
+#define MaxOff  31
+#define MaxSeq MAX(MaxLL, MaxML)   /* Assumption : MaxOff < MaxLL,MaxML */
+#define MLFSELog    9
+#define LLFSELog    9
+#define OffFSELog   8
+#define MaxFSELog  MAX(MAX(MLFSELog, LLFSELog), OffFSELog)
+#define MaxMLBits 16
+#define MaxLLBits 16
+
+#define ZSTD_MAX_HUF_HEADER_SIZE 128 /* header + <= 127 byte tree description */
+/* Each table cannot take more than #symbols * FSELog bits */
+#define ZSTD_MAX_FSE_HEADERS_SIZE (((MaxML + 1) * MLFSELog + (MaxLL + 1) * LLFSELog + (MaxOff + 1) * OffFSELog + 7) / 8)
+
+static UNUSED_ATTR const U8 LL_bits[MaxLL+1] = {
+     0, 0, 0, 0, 0, 0, 0, 0,
+     0, 0, 0, 0, 0, 0, 0, 0,
+     1, 1, 1, 1, 2, 2, 3, 3,
+     4, 6, 7, 8, 9,10,11,12,
+    13,14,15,16
+};
+static UNUSED_ATTR const S16 LL_defaultNorm[MaxLL+1] = {
+     4, 3, 2, 2, 2, 2, 2, 2,
+     2, 2, 2, 2, 2, 1, 1, 1,
+     2, 2, 2, 2, 2, 2, 2, 2,
+     2, 3, 2, 1, 1, 1, 1, 1,
+    -1,-1,-1,-1
+};
+#define LL_DEFAULTNORMLOG 6  /* for static allocation */
+static UNUSED_ATTR const U32 LL_defaultNormLog = LL_DEFAULTNORMLOG;
+
+static UNUSED_ATTR const U8 ML_bits[MaxML+1] = {
+     0, 0, 0, 0, 0, 0, 0, 0,
+     0, 0, 0, 0, 0, 0, 0, 0,
+     0, 0, 0, 0, 0, 0, 0, 0,
+     0, 0, 0, 0, 0, 0, 0, 0,
+     1, 1, 1, 1, 2, 2, 3, 3,
+     4, 4, 5, 7, 8, 9,10,11,
+    12,13,14,15,16
+};
+static UNUSED_ATTR const S16 ML_defaultNorm[MaxML+1] = {
+     1, 4, 3, 2, 2, 2, 2, 2,
+     2, 1, 1, 1, 1, 1, 1, 1,
+     1, 1, 1, 1, 1, 1, 1, 1,
+     1, 1, 1, 1, 1, 1, 1, 1,
+     1, 1, 1, 1, 1, 1, 1, 1,
+     1, 1, 1, 1, 1, 1,-1,-1,
+    -1,-1,-1,-1,-1
+};
+#define ML_DEFAULTNORMLOG 6  /* for static allocation */
+static UNUSED_ATTR const U32 ML_defaultNormLog = ML_DEFAULTNORMLOG;
+
+static UNUSED_ATTR const S16 OF_defaultNorm[DefaultMaxOff+1] = {
+     1, 1, 1, 1, 1, 1, 2, 2,
+     2, 1, 1, 1, 1, 1, 1, 1,
+     1, 1, 1, 1, 1, 1, 1, 1,
+    -1,-1,-1,-1,-1
+};
+#define OF_DEFAULTNORMLOG 5  /* for static allocation */
+static UNUSED_ATTR const U32 OF_defaultNormLog = OF_DEFAULTNORMLOG;
+
+
+/*-*******************************************
+*  Shared functions to include for inlining
+*********************************************/
+static void ZSTD_copy8(void* dst, const void* src) {
+#if defined(ZSTD_ARCH_ARM_NEON)
+    vst1_u8((uint8_t*)dst, vld1_u8((const uint8_t*)src));
+#else
+    ZSTD_memcpy(dst, src, 8);
+#endif
+}
+#define COPY8(d,s) { ZSTD_copy8(d,s); d+=8; s+=8; }
+
+/* Need to use memmove here since the literal buffer can now be located within
+   the dst buffer. In circumstances where the op "catches up" to where the
+   literal buffer is, there can be partial overlaps in this call on the final
+   copy if the literal is being shifted by less than 16 bytes. */
+static void ZSTD_copy16(void* dst, const void* src) {
+#if defined(ZSTD_ARCH_ARM_NEON)
+    vst1q_u8((uint8_t*)dst, vld1q_u8((const uint8_t*)src));
+#elif defined(ZSTD_ARCH_X86_SSE2)
+    _mm_storeu_si128((__m128i*)dst, _mm_loadu_si128((const __m128i*)src));
+#elif defined(__clang__)
+    ZSTD_memmove(dst, src, 16);
+#else
+    /* ZSTD_memmove is not inlined properly by gcc */
+    BYTE copy16_buf[16];
+    ZSTD_memcpy(copy16_buf, src, 16);
+    ZSTD_memcpy(dst, copy16_buf, 16);
+#endif
+}
+#define COPY16(d,s) { ZSTD_copy16(d,s); d+=16; s+=16; }
+
+#define WILDCOPY_OVERLENGTH 32
+#define WILDCOPY_VECLEN 16
+
+typedef enum {
+    ZSTD_no_overlap,
+    ZSTD_overlap_src_before_dst
+    /*  ZSTD_overlap_dst_before_src, */
+} ZSTD_overlap_e;
+
+/*! ZSTD_wildcopy() :
+ *  Custom version of ZSTD_memcpy(), can over read/write up to WILDCOPY_OVERLENGTH bytes (if length==0)
+ *  @param ovtype controls the overlap detection
+ *         - ZSTD_no_overlap: The source and destination are guaranteed to be at least WILDCOPY_VECLEN bytes apart.
+ *         - ZSTD_overlap_src_before_dst: The src and dst may overlap, but they MUST be at least 8 bytes apart.
+ *           The src buffer must be before the dst buffer.
+ */
+MEM_STATIC FORCE_INLINE_ATTR
+void ZSTD_wildcopy(void* dst, const void* src, ptrdiff_t length, ZSTD_overlap_e const ovtype)
+{
+    ptrdiff_t diff = (BYTE*)dst - (const BYTE*)src;
+    const BYTE* ip = (const BYTE*)src;
+    BYTE* op = (BYTE*)dst;
+    BYTE* const oend = op + length;
+
+    if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {
+        /* Handle short offset copies. */
+        do {
+            COPY8(op, ip)
+        } while (op < oend);
+    } else {
+        assert(diff >= WILDCOPY_VECLEN || diff <= -WILDCOPY_VECLEN);
+        /* Separate out the first COPY16() call because the copy length is
+         * almost certain to be short, so the branches have different
+         * probabilities. Since it is almost certain to be short, only do
+         * one COPY16() in the first call. Then, do two calls per loop since
+         * at that point it is more likely to have a high trip count.
+         */
+        ZSTD_copy16(op, ip);
+        if (16 >= length) return;
+        op += 16;
+        ip += 16;
+        do {
+            COPY16(op, ip);
+            COPY16(op, ip);
+        }
+        while (op < oend);
+    }
+}
+
+MEM_STATIC size_t ZSTD_limitCopy(void* dst, size_t dstCapacity, const void* src, size_t srcSize)
+{
+    size_t const length = MIN(dstCapacity, srcSize);
+    if (length > 0) {
+        ZSTD_memcpy(dst, src, length);
+    }
+    return length;
+}
+
+/* define "workspace is too large" as this number of times larger than needed */
+#define ZSTD_WORKSPACETOOLARGE_FACTOR 3
+
+/* when workspace is continuously too large
+ * during at least this number of times,
+ * context's memory usage is considered wasteful,
+ * because it's sized to handle a worst case scenario which rarely happens.
+ * In which case, resize it down to free some memory */
+#define ZSTD_WORKSPACETOOLARGE_MAXDURATION 128
+
+/* Controls whether the input/output buffer is buffered or stable. */
+typedef enum {
+    ZSTD_bm_buffered = 0,  /* Buffer the input/output */
+    ZSTD_bm_stable = 1     /* ZSTD_inBuffer/ZSTD_outBuffer is stable */
+} ZSTD_bufferMode_e;
+
+
+/*-*******************************************
+*  Private declarations
+*********************************************/
+typedef struct seqDef_s {
+    U32 offBase;   /* offBase == Offset + ZSTD_REP_NUM, or repcode 1,2,3 */
+    U16 litLength;
+    U16 mlBase;    /* mlBase == matchLength - MINMATCH */
+} seqDef;
+
+/* Controls whether seqStore has a single "long" litLength or matchLength. See seqStore_t. */
+typedef enum {
+    ZSTD_llt_none = 0,             /* no longLengthType */
+    ZSTD_llt_literalLength = 1,    /* represents a long literal */
+    ZSTD_llt_matchLength = 2       /* represents a long match */
+} ZSTD_longLengthType_e;
+
+typedef struct {
+    seqDef* sequencesStart;
+    seqDef* sequences;      /* ptr to end of sequences */
+    BYTE*  litStart;
+    BYTE*  lit;             /* ptr to end of literals */
+    BYTE*  llCode;
+    BYTE*  mlCode;
+    BYTE*  ofCode;
+    size_t maxNbSeq;
+    size_t maxNbLit;
+
+    /* longLengthPos and longLengthType to allow us to represent either a single litLength or matchLength
+     * in the seqStore that has a value larger than U16 (if it exists). To do so, we increment
+     * the existing value of the litLength or matchLength by 0x10000.
+     */
+    ZSTD_longLengthType_e longLengthType;
+    U32                   longLengthPos;  /* Index of the sequence to apply long length modification to */
+} seqStore_t;
+
+typedef struct {
+    U32 litLength;
+    U32 matchLength;
+} ZSTD_sequenceLength;
+
+/**
+ * Returns the ZSTD_sequenceLength for the given sequences. It handles the decoding of long sequences
+ * indicated by longLengthPos and longLengthType, and adds MINMATCH back to matchLength.
+ */
+MEM_STATIC ZSTD_sequenceLength ZSTD_getSequenceLength(seqStore_t const* seqStore, seqDef const* seq)
+{
+    ZSTD_sequenceLength seqLen;
+    seqLen.litLength = seq->litLength;
+    seqLen.matchLength = seq->mlBase + MINMATCH;
+    if (seqStore->longLengthPos == (U32)(seq - seqStore->sequencesStart)) {
+        if (seqStore->longLengthType == ZSTD_llt_literalLength) {
+            seqLen.litLength += 0x10000;
+        }
+        if (seqStore->longLengthType == ZSTD_llt_matchLength) {
+            seqLen.matchLength += 0x10000;
+        }
+    }
+    return seqLen;
+}
+
+/**
+ * Contains the compressed frame size and an upper-bound for the decompressed frame size.
+ * Note: before using `compressedSize`, check for errors using ZSTD_isError().
+ *       similarly, before using `decompressedBound`, check for errors using:
+ *          `decompressedBound != ZSTD_CONTENTSIZE_ERROR`
+ */
+typedef struct {
+    size_t nbBlocks;
+    size_t compressedSize;
+    unsigned long long decompressedBound;
+} ZSTD_frameSizeInfo;   /* decompress & legacy */
+
+const seqStore_t* ZSTD_getSeqStore(const ZSTD_CCtx* ctx);   /* compress & dictBuilder */
+int ZSTD_seqToCodes(const seqStore_t* seqStorePtr);   /* compress, dictBuilder, decodeCorpus (shouldn't get its definition from here) */
+
+
+/* ZSTD_invalidateRepCodes() :
+ * ensures next compression will not use repcodes from previous block.
+ * Note : only works with regular variant;
+ *        do not use with extDict variant ! */
+void ZSTD_invalidateRepCodes(ZSTD_CCtx* cctx);   /* zstdmt, adaptive_compression (shouldn't get this definition from here) */
+
+
+typedef struct {
+    blockType_e blockType;
+    U32 lastBlock;
+    U32 origSize;
+} blockProperties_t;   /* declared here for decompress and fullbench */
+
+/*! ZSTD_getcBlockSize() :
+ *  Provides the size of compressed block from block header `src` */
+/* Used by: decompress, fullbench (does not get its definition from here) */
+size_t ZSTD_getcBlockSize(const void* src, size_t srcSize,
+                          blockProperties_t* bpPtr);
+
+/*! ZSTD_decodeSeqHeaders() :
+ *  decode sequence header from src */
+/* Used by: decompress, fullbench (does not get its definition from here) */
+size_t ZSTD_decodeSeqHeaders(ZSTD_DCtx* dctx, int* nbSeqPtr,
+                       const void* src, size_t srcSize);
+
+/**
+ * @returns true iff the CPU supports dynamic BMI2 dispatch.
+ */
+MEM_STATIC int ZSTD_cpuSupportsBmi2(void)
+{
+    ZSTD_cpuid_t cpuid = ZSTD_cpuid();
+    return ZSTD_cpuid_bmi1(cpuid) && ZSTD_cpuid_bmi2(cpuid);
+}
+
+#if defined (__cplusplus)
+}
+#endif
+
+#endif   /* ZSTD_CCOMMON_H_MODULE */
diff --git a/src/3rdparty/zstd/src/common/zstd_trace.h b/src/3rdparty/zstd/src/common/zstd_trace.h
new file mode 100644
index 0000000000..da20534ebd
--- /dev/null
+++ b/src/3rdparty/zstd/src/common/zstd_trace.h
@@ -0,0 +1,163 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_TRACE_H
+#define ZSTD_TRACE_H
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#include <stddef.h>
+
+/* weak symbol support
+ * For now, enable conservatively:
+ * - Only GNUC
+ * - Only ELF
+ * - Only x86-64, i386 and aarch64
+ * Also, explicitly disable on platforms known not to work so they aren't
+ * forgotten in the future.
+ */
+#if !defined(ZSTD_HAVE_WEAK_SYMBOLS) && \
+    defined(__GNUC__) && defined(__ELF__) && \
+    (defined(__x86_64__) || defined(_M_X64) || defined(__i386__) || defined(_M_IX86) || defined(__aarch64__)) && \
+    !defined(__APPLE__) && !defined(_WIN32) && !defined(__MINGW32__) && \
+    !defined(__CYGWIN__) && !defined(_AIX)
+#  define ZSTD_HAVE_WEAK_SYMBOLS 1
+#else
+#  define ZSTD_HAVE_WEAK_SYMBOLS 0
+#endif
+#if ZSTD_HAVE_WEAK_SYMBOLS
+#  define ZSTD_WEAK_ATTR __attribute__((__weak__))
+#else
+#  define ZSTD_WEAK_ATTR
+#endif
+
+/* Only enable tracing when weak symbols are available. */
+#ifndef ZSTD_TRACE
+#  define ZSTD_TRACE ZSTD_HAVE_WEAK_SYMBOLS
+#endif
+
+#if ZSTD_TRACE
+
+struct ZSTD_CCtx_s;
+struct ZSTD_DCtx_s;
+struct ZSTD_CCtx_params_s;
+
+typedef struct {
+    /**
+     * ZSTD_VERSION_NUMBER
+     *
+     * This is guaranteed to be the first member of ZSTD_trace.
+     * Otherwise, this struct is not stable between versions. If
+     * the version number does not match your expectation, you
+     * should not interpret the rest of the struct.
+     */
+    unsigned version;
+    /**
+     * Non-zero if streaming (de)compression is used.
+     */
+    unsigned streaming;
+    /**
+     * The dictionary ID.
+     */
+    unsigned dictionaryID;
+    /**
+     * Is the dictionary cold?
+     * Only set on decompression.
+     */
+    unsigned dictionaryIsCold;
+    /**
+     * The dictionary size or zero if no dictionary.
+     */
+    size_t dictionarySize;
+    /**
+     * The uncompressed size of the data.
+     */
+    size_t uncompressedSize;
+    /**
+     * The compressed size of the data.
+     */
+    size_t compressedSize;
+    /**
+     * The fully resolved CCtx parameters (NULL on decompression).
+     */
+    struct ZSTD_CCtx_params_s const* params;
+    /**
+     * The ZSTD_CCtx pointer (NULL on decompression).
+     */
+    struct ZSTD_CCtx_s const* cctx;
+    /**
+     * The ZSTD_DCtx pointer (NULL on compression).
+     */
+    struct ZSTD_DCtx_s const* dctx;
+} ZSTD_Trace;
+
+/**
+ * A tracing context. It must be 0 when tracing is disabled.
+ * Otherwise, any non-zero value returned by a tracing begin()
+ * function is presented to any subsequent calls to end().
+ *
+ * Any non-zero value is treated as tracing is enabled and not
+ * interpreted by the library.
+ *
+ * Two possible uses are:
+ * * A timestamp for when the begin() function was called.
+ * * A unique key identifying the (de)compression, like the
+ *   address of the [dc]ctx pointer if you need to track
+ *   more information than just a timestamp.
+ */
+typedef unsigned long long ZSTD_TraceCtx;
+
+/**
+ * Trace the beginning of a compression call.
+ * @param cctx The dctx pointer for the compression.
+ *             It can be used as a key to map begin() to end().
+ * @returns Non-zero if tracing is enabled. The return value is
+ *          passed to ZSTD_trace_compress_end().
+ */
+ZSTD_WEAK_ATTR ZSTD_TraceCtx ZSTD_trace_compress_begin(
+    struct ZSTD_CCtx_s const* cctx);
+
+/**
+ * Trace the end of a compression call.
+ * @param ctx The return value of ZSTD_trace_compress_begin().
+ * @param trace The zstd tracing info.
+ */
+ZSTD_WEAK_ATTR void ZSTD_trace_compress_end(
+    ZSTD_TraceCtx ctx,
+    ZSTD_Trace const* trace);
+
+/**
+ * Trace the beginning of a decompression call.
+ * @param dctx The dctx pointer for the decompression.
+ *             It can be used as a key to map begin() to end().
+ * @returns Non-zero if tracing is enabled. The return value is
+ *          passed to ZSTD_trace_compress_end().
+ */
+ZSTD_WEAK_ATTR ZSTD_TraceCtx ZSTD_trace_decompress_begin(
+    struct ZSTD_DCtx_s const* dctx);
+
+/**
+ * Trace the end of a decompression call.
+ * @param ctx The return value of ZSTD_trace_decompress_begin().
+ * @param trace The zstd tracing info.
+ */
+ZSTD_WEAK_ATTR void ZSTD_trace_decompress_end(
+    ZSTD_TraceCtx ctx,
+    ZSTD_Trace const* trace);
+
+#endif /* ZSTD_TRACE */
+
+#if defined (__cplusplus)
+}
+#endif
+
+#endif /* ZSTD_TRACE_H */
diff --git a/src/3rdparty/zstd/src/compress/clevels.h b/src/3rdparty/zstd/src/compress/clevels.h
new file mode 100644
index 0000000000..c18da465f3
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/clevels.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_CLEVELS_H
+#define ZSTD_CLEVELS_H
+
+#define ZSTD_STATIC_LINKING_ONLY  /* ZSTD_compressionParameters  */
+#include "../zstd.h"
+
+/*-=====  Pre-defined compression levels  =====-*/
+
+#define ZSTD_MAX_CLEVEL     22
+
+#ifdef __GNUC__
+__attribute__((__unused__))
+#endif
+
+static const ZSTD_compressionParameters ZSTD_defaultCParameters[4][ZSTD_MAX_CLEVEL+1] = {
+{   /* "default" - for any srcSize > 256 KB */
+    /* W,  C,  H,  S,  L, TL, strat */
+    { 19, 12, 13,  1,  6,  1, ZSTD_fast    },  /* base for negative levels */
+    { 19, 13, 14,  1,  7,  0, ZSTD_fast    },  /* level  1 */
+    { 20, 15, 16,  1,  6,  0, ZSTD_fast    },  /* level  2 */
+    { 21, 16, 17,  1,  5,  0, ZSTD_dfast   },  /* level  3 */
+    { 21, 18, 18,  1,  5,  0, ZSTD_dfast   },  /* level  4 */
+    { 21, 18, 19,  3,  5,  2, ZSTD_greedy  },  /* level  5 */
+    { 21, 18, 19,  3,  5,  4, ZSTD_lazy    },  /* level  6 */
+    { 21, 19, 20,  4,  5,  8, ZSTD_lazy    },  /* level  7 */
+    { 21, 19, 20,  4,  5, 16, ZSTD_lazy2   },  /* level  8 */
+    { 22, 20, 21,  4,  5, 16, ZSTD_lazy2   },  /* level  9 */
+    { 22, 21, 22,  5,  5, 16, ZSTD_lazy2   },  /* level 10 */
+    { 22, 21, 22,  6,  5, 16, ZSTD_lazy2   },  /* level 11 */
+    { 22, 22, 23,  6,  5, 32, ZSTD_lazy2   },  /* level 12 */
+    { 22, 22, 22,  4,  5, 32, ZSTD_btlazy2 },  /* level 13 */
+    { 22, 22, 23,  5,  5, 32, ZSTD_btlazy2 },  /* level 14 */
+    { 22, 23, 23,  6,  5, 32, ZSTD_btlazy2 },  /* level 15 */
+    { 22, 22, 22,  5,  5, 48, ZSTD_btopt   },  /* level 16 */
+    { 23, 23, 22,  5,  4, 64, ZSTD_btopt   },  /* level 17 */
+    { 23, 23, 22,  6,  3, 64, ZSTD_btultra },  /* level 18 */
+    { 23, 24, 22,  7,  3,256, ZSTD_btultra2},  /* level 19 */
+    { 25, 25, 23,  7,  3,256, ZSTD_btultra2},  /* level 20 */
+    { 26, 26, 24,  7,  3,512, ZSTD_btultra2},  /* level 21 */
+    { 27, 27, 25,  9,  3,999, ZSTD_btultra2},  /* level 22 */
+},
+{   /* for srcSize <= 256 KB */
+    /* W,  C,  H,  S,  L,  T, strat */
+    { 18, 12, 13,  1,  5,  1, ZSTD_fast    },  /* base for negative levels */
+    { 18, 13, 14,  1,  6,  0, ZSTD_fast    },  /* level  1 */
+    { 18, 14, 14,  1,  5,  0, ZSTD_dfast   },  /* level  2 */
+    { 18, 16, 16,  1,  4,  0, ZSTD_dfast   },  /* level  3 */
+    { 18, 16, 17,  3,  5,  2, ZSTD_greedy  },  /* level  4.*/
+    { 18, 17, 18,  5,  5,  2, ZSTD_greedy  },  /* level  5.*/
+    { 18, 18, 19,  3,  5,  4, ZSTD_lazy    },  /* level  6.*/
+    { 18, 18, 19,  4,  4,  4, ZSTD_lazy    },  /* level  7 */
+    { 18, 18, 19,  4,  4,  8, ZSTD_lazy2   },  /* level  8 */
+    { 18, 18, 19,  5,  4,  8, ZSTD_lazy2   },  /* level  9 */
+    { 18, 18, 19,  6,  4,  8, ZSTD_lazy2   },  /* level 10 */
+    { 18, 18, 19,  5,  4, 12, ZSTD_btlazy2 },  /* level 11.*/
+    { 18, 19, 19,  7,  4, 12, ZSTD_btlazy2 },  /* level 12.*/
+    { 18, 18, 19,  4,  4, 16, ZSTD_btopt   },  /* level 13 */
+    { 18, 18, 19,  4,  3, 32, ZSTD_btopt   },  /* level 14.*/
+    { 18, 18, 19,  6,  3,128, ZSTD_btopt   },  /* level 15.*/
+    { 18, 19, 19,  6,  3,128, ZSTD_btultra },  /* level 16.*/
+    { 18, 19, 19,  8,  3,256, ZSTD_btultra },  /* level 17.*/
+    { 18, 19, 19,  6,  3,128, ZSTD_btultra2},  /* level 18.*/
+    { 18, 19, 19,  8,  3,256, ZSTD_btultra2},  /* level 19.*/
+    { 18, 19, 19, 10,  3,512, ZSTD_btultra2},  /* level 20.*/
+    { 18, 19, 19, 12,  3,512, ZSTD_btultra2},  /* level 21.*/
+    { 18, 19, 19, 13,  3,999, ZSTD_btultra2},  /* level 22.*/
+},
+{   /* for srcSize <= 128 KB */
+    /* W,  C,  H,  S,  L,  T, strat */
+    { 17, 12, 12,  1,  5,  1, ZSTD_fast    },  /* base for negative levels */
+    { 17, 12, 13,  1,  6,  0, ZSTD_fast    },  /* level  1 */
+    { 17, 13, 15,  1,  5,  0, ZSTD_fast    },  /* level  2 */
+    { 17, 15, 16,  2,  5,  0, ZSTD_dfast   },  /* level  3 */
+    { 17, 17, 17,  2,  4,  0, ZSTD_dfast   },  /* level  4 */
+    { 17, 16, 17,  3,  4,  2, ZSTD_greedy  },  /* level  5 */
+    { 17, 16, 17,  3,  4,  4, ZSTD_lazy    },  /* level  6 */
+    { 17, 16, 17,  3,  4,  8, ZSTD_lazy2   },  /* level  7 */
+    { 17, 16, 17,  4,  4,  8, ZSTD_lazy2   },  /* level  8 */
+    { 17, 16, 17,  5,  4,  8, ZSTD_lazy2   },  /* level  9 */
+    { 17, 16, 17,  6,  4,  8, ZSTD_lazy2   },  /* level 10 */
+    { 17, 17, 17,  5,  4,  8, ZSTD_btlazy2 },  /* level 11 */
+    { 17, 18, 17,  7,  4, 12, ZSTD_btlazy2 },  /* level 12 */
+    { 17, 18, 17,  3,  4, 12, ZSTD_btopt   },  /* level 13.*/
+    { 17, 18, 17,  4,  3, 32, ZSTD_btopt   },  /* level 14.*/
+    { 17, 18, 17,  6,  3,256, ZSTD_btopt   },  /* level 15.*/
+    { 17, 18, 17,  6,  3,128, ZSTD_btultra },  /* level 16.*/
+    { 17, 18, 17,  8,  3,256, ZSTD_btultra },  /* level 17.*/
+    { 17, 18, 17, 10,  3,512, ZSTD_btultra },  /* level 18.*/
+    { 17, 18, 17,  5,  3,256, ZSTD_btultra2},  /* level 19.*/
+    { 17, 18, 17,  7,  3,512, ZSTD_btultra2},  /* level 20.*/
+    { 17, 18, 17,  9,  3,512, ZSTD_btultra2},  /* level 21.*/
+    { 17, 18, 17, 11,  3,999, ZSTD_btultra2},  /* level 22.*/
+},
+{   /* for srcSize <= 16 KB */
+    /* W,  C,  H,  S,  L,  T, strat */
+    { 14, 12, 13,  1,  5,  1, ZSTD_fast    },  /* base for negative levels */
+    { 14, 14, 15,  1,  5,  0, ZSTD_fast    },  /* level  1 */
+    { 14, 14, 15,  1,  4,  0, ZSTD_fast    },  /* level  2 */
+    { 14, 14, 15,  2,  4,  0, ZSTD_dfast   },  /* level  3 */
+    { 14, 14, 14,  4,  4,  2, ZSTD_greedy  },  /* level  4 */
+    { 14, 14, 14,  3,  4,  4, ZSTD_lazy    },  /* level  5.*/
+    { 14, 14, 14,  4,  4,  8, ZSTD_lazy2   },  /* level  6 */
+    { 14, 14, 14,  6,  4,  8, ZSTD_lazy2   },  /* level  7 */
+    { 14, 14, 14,  8,  4,  8, ZSTD_lazy2   },  /* level  8.*/
+    { 14, 15, 14,  5,  4,  8, ZSTD_btlazy2 },  /* level  9.*/
+    { 14, 15, 14,  9,  4,  8, ZSTD_btlazy2 },  /* level 10.*/
+    { 14, 15, 14,  3,  4, 12, ZSTD_btopt   },  /* level 11.*/
+    { 14, 15, 14,  4,  3, 24, ZSTD_btopt   },  /* level 12.*/
+    { 14, 15, 14,  5,  3, 32, ZSTD_btultra },  /* level 13.*/
+    { 14, 15, 15,  6,  3, 64, ZSTD_btultra },  /* level 14.*/
+    { 14, 15, 15,  7,  3,256, ZSTD_btultra },  /* level 15.*/
+    { 14, 15, 15,  5,  3, 48, ZSTD_btultra2},  /* level 16.*/
+    { 14, 15, 15,  6,  3,128, ZSTD_btultra2},  /* level 17.*/
+    { 14, 15, 15,  7,  3,256, ZSTD_btultra2},  /* level 18.*/
+    { 14, 15, 15,  8,  3,256, ZSTD_btultra2},  /* level 19.*/
+    { 14, 15, 15,  8,  3,512, ZSTD_btultra2},  /* level 20.*/
+    { 14, 15, 15,  9,  3,512, ZSTD_btultra2},  /* level 21.*/
+    { 14, 15, 15, 10,  3,999, ZSTD_btultra2},  /* level 22.*/
+},
+};
+
+
+
+#endif  /* ZSTD_CLEVELS_H */
diff --git a/src/3rdparty/zstd/src/compress/fse_compress.c b/src/3rdparty/zstd/src/compress/fse_compress.c
new file mode 100644
index 0000000000..5d3770808d
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/fse_compress.c
@@ -0,0 +1,624 @@
+/* ******************************************************************
+ * FSE : Finite State Entropy encoder
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ *  You can contact the author at :
+ *  - FSE source repository : https://github.com/Cyan4973/FiniteStateEntropy
+ *  - Public forum : https://groups.google.com/forum/#!forum/lz4c
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+****************************************************************** */
+
+/* **************************************************************
+*  Includes
+****************************************************************/
+#include "../common/compiler.h"
+#include "../common/mem.h"        /* U32, U16, etc. */
+#include "../common/debug.h"      /* assert, DEBUGLOG */
+#include "hist.h"       /* HIST_count_wksp */
+#include "../common/bitstream.h"
+#define FSE_STATIC_LINKING_ONLY
+#include "../common/fse.h"
+#include "../common/error_private.h"
+#define ZSTD_DEPS_NEED_MALLOC
+#define ZSTD_DEPS_NEED_MATH64
+#include "../common/zstd_deps.h"  /* ZSTD_malloc, ZSTD_free, ZSTD_memcpy, ZSTD_memset */
+#include "../common/bits.h" /* ZSTD_highbit32 */
+
+
+/* **************************************************************
+*  Error Management
+****************************************************************/
+#define FSE_isError ERR_isError
+
+
+/* **************************************************************
+*  Templates
+****************************************************************/
+/*
+  designed to be included
+  for type-specific functions (template emulation in C)
+  Objective is to write these functions only once, for improved maintenance
+*/
+
+/* safety checks */
+#ifndef FSE_FUNCTION_EXTENSION
+#  error "FSE_FUNCTION_EXTENSION must be defined"
+#endif
+#ifndef FSE_FUNCTION_TYPE
+#  error "FSE_FUNCTION_TYPE must be defined"
+#endif
+
+/* Function names */
+#define FSE_CAT(X,Y) X##Y
+#define FSE_FUNCTION_NAME(X,Y) FSE_CAT(X,Y)
+#define FSE_TYPE_NAME(X,Y) FSE_CAT(X,Y)
+
+
+/* Function templates */
+
+/* FSE_buildCTable_wksp() :
+ * Same as FSE_buildCTable(), but using an externally allocated scratch buffer (`workSpace`).
+ * wkspSize should be sized to handle worst case situation, which is `1<<max_tableLog * sizeof(FSE_FUNCTION_TYPE)`
+ * workSpace must also be properly aligned with FSE_FUNCTION_TYPE requirements
+ */
+size_t FSE_buildCTable_wksp(FSE_CTable* ct,
+                      const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog,
+                            void* workSpace, size_t wkspSize)
+{
+    U32 const tableSize = 1 << tableLog;
+    U32 const tableMask = tableSize - 1;
+    void* const ptr = ct;
+    U16* const tableU16 = ( (U16*) ptr) + 2;
+    void* const FSCT = ((U32*)ptr) + 1 /* header */ + (tableLog ? tableSize>>1 : 1) ;
+    FSE_symbolCompressionTransform* const symbolTT = (FSE_symbolCompressionTransform*) (FSCT);
+    U32 const step = FSE_TABLESTEP(tableSize);
+    U32 const maxSV1 = maxSymbolValue+1;
+
+    U16* cumul = (U16*)workSpace;   /* size = maxSV1 */
+    FSE_FUNCTION_TYPE* const tableSymbol = (FSE_FUNCTION_TYPE*)(cumul + (maxSV1+1));  /* size = tableSize */
+
+    U32 highThreshold = tableSize-1;
+
+    assert(((size_t)workSpace & 1) == 0);  /* Must be 2 bytes-aligned */
+    if (FSE_BUILD_CTABLE_WORKSPACE_SIZE(maxSymbolValue, tableLog) > wkspSize) return ERROR(tableLog_tooLarge);
+    /* CTable header */
+    tableU16[-2] = (U16) tableLog;
+    tableU16[-1] = (U16) maxSymbolValue;
+    assert(tableLog < 16);   /* required for threshold strategy to work */
+
+    /* For explanations on how to distribute symbol values over the table :
+     * https://fastcompression.blogspot.fr/2014/02/fse-distributing-symbol-values.html */
+
+     #ifdef __clang_analyzer__
+     ZSTD_memset(tableSymbol, 0, sizeof(*tableSymbol) * tableSize);   /* useless initialization, just to keep scan-build happy */
+     #endif
+
+    /* symbol start positions */
+    {   U32 u;
+        cumul[0] = 0;
+        for (u=1; u <= maxSV1; u++) {
+            if (normalizedCounter[u-1]==-1) {  /* Low proba symbol */
+                cumul[u] = cumul[u-1] + 1;
+                tableSymbol[highThreshold--] = (FSE_FUNCTION_TYPE)(u-1);
+            } else {
+                assert(normalizedCounter[u-1] >= 0);
+                cumul[u] = cumul[u-1] + (U16)normalizedCounter[u-1];
+                assert(cumul[u] >= cumul[u-1]);  /* no overflow */
+        }   }
+        cumul[maxSV1] = (U16)(tableSize+1);
+    }
+
+    /* Spread symbols */
+    if (highThreshold == tableSize - 1) {
+        /* Case for no low prob count symbols. Lay down 8 bytes at a time
+         * to reduce branch misses since we are operating on a small block
+         */
+        BYTE* const spread = tableSymbol + tableSize; /* size = tableSize + 8 (may write beyond tableSize) */
+        {   U64 const add = 0x0101010101010101ull;
+            size_t pos = 0;
+            U64 sv = 0;
+            U32 s;
+            for (s=0; s<maxSV1; ++s, sv += add) {
+                int i;
+                int const n = normalizedCounter[s];
+                MEM_write64(spread + pos, sv);
+                for (i = 8; i < n; i += 8) {
+                    MEM_write64(spread + pos + i, sv);
+                }
+                assert(n>=0);
+                pos += (size_t)n;
+            }
+        }
+        /* Spread symbols across the table. Lack of lowprob symbols means that
+         * we don't need variable sized inner loop, so we can unroll the loop and
+         * reduce branch misses.
+         */
+        {   size_t position = 0;
+            size_t s;
+            size_t const unroll = 2; /* Experimentally determined optimal unroll */
+            assert(tableSize % unroll == 0); /* FSE_MIN_TABLELOG is 5 */
+            for (s = 0; s < (size_t)tableSize; s += unroll) {
+                size_t u;
+                for (u = 0; u < unroll; ++u) {
+                    size_t const uPosition = (position + (u * step)) & tableMask;
+                    tableSymbol[uPosition] = spread[s + u];
+                }
+                position = (position + (unroll * step)) & tableMask;
+            }
+            assert(position == 0);   /* Must have initialized all positions */
+        }
+    } else {
+        U32 position = 0;
+        U32 symbol;
+        for (symbol=0; symbol<maxSV1; symbol++) {
+            int nbOccurrences;
+            int const freq = normalizedCounter[symbol];
+            for (nbOccurrences=0; nbOccurrences<freq; nbOccurrences++) {
+                tableSymbol[position] = (FSE_FUNCTION_TYPE)symbol;
+                position = (position + step) & tableMask;
+                while (position > highThreshold)
+                    position = (position + step) & tableMask;   /* Low proba area */
+        }   }
+        assert(position==0);  /* Must have initialized all positions */
+    }
+
+    /* Build table */
+    {   U32 u; for (u=0; u<tableSize; u++) {
+        FSE_FUNCTION_TYPE s = tableSymbol[u];   /* note : static analyzer may not understand tableSymbol is properly initialized */
+        tableU16[cumul[s]++] = (U16) (tableSize+u);   /* TableU16 : sorted by symbol order; gives next state value */
+    }   }
+
+    /* Build Symbol Transformation Table */
+    {   unsigned total = 0;
+        unsigned s;
+        for (s=0; s<=maxSymbolValue; s++) {
+            switch (normalizedCounter[s])
+            {
+            case  0:
+                /* filling nonetheless, for compatibility with FSE_getMaxNbBits() */
+                symbolTT[s].deltaNbBits = ((tableLog+1) << 16) - (1<<tableLog);
+                break;
+
+            case -1:
+            case  1:
+                symbolTT[s].deltaNbBits = (tableLog << 16) - (1<<tableLog);
+                assert(total <= INT_MAX);
+                symbolTT[s].deltaFindState = (int)(total - 1);
+                total ++;
+                break;
+            default :
+                assert(normalizedCounter[s] > 1);
+                {   U32 const maxBitsOut = tableLog - ZSTD_highbit32 ((U32)normalizedCounter[s]-1);
+                    U32 const minStatePlus = (U32)normalizedCounter[s] << maxBitsOut;
+                    symbolTT[s].deltaNbBits = (maxBitsOut << 16) - minStatePlus;
+                    symbolTT[s].deltaFindState = (int)(total - (unsigned)normalizedCounter[s]);
+                    total +=  (unsigned)normalizedCounter[s];
+    }   }   }   }
+
+#if 0  /* debug : symbol costs */
+    DEBUGLOG(5, "\n --- table statistics : ");
+    {   U32 symbol;
+        for (symbol=0; symbol<=maxSymbolValue; symbol++) {
+            DEBUGLOG(5, "%3u: w=%3i,   maxBits=%u, fracBits=%.2f",
+                symbol, normalizedCounter[symbol],
+                FSE_getMaxNbBits(symbolTT, symbol),
+                (double)FSE_bitCost(symbolTT, tableLog, symbol, 8) / 256);
+    }   }
+#endif
+
+    return 0;
+}
+
+
+
+#ifndef FSE_COMMONDEFS_ONLY
+
+/*-**************************************************************
+*  FSE NCount encoding
+****************************************************************/
+size_t FSE_NCountWriteBound(unsigned maxSymbolValue, unsigned tableLog)
+{
+    size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog
+                                   + 4 /* bitCount initialized at 4 */
+                                   + 2 /* first two symbols may use one additional bit each */) / 8)
+                                    + 1 /* round up to whole nb bytes */
+                                    + 2 /* additional two bytes for bitstream flush */;
+    return maxSymbolValue ? maxHeaderSize : FSE_NCOUNTBOUND;  /* maxSymbolValue==0 ? use default */
+}
+
+static size_t
+FSE_writeNCount_generic (void* header, size_t headerBufferSize,
+                   const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog,
+                         unsigned writeIsSafe)
+{
+    BYTE* const ostart = (BYTE*) header;
+    BYTE* out = ostart;
+    BYTE* const oend = ostart + headerBufferSize;
+    int nbBits;
+    const int tableSize = 1 << tableLog;
+    int remaining;
+    int threshold;
+    U32 bitStream = 0;
+    int bitCount = 0;
+    unsigned symbol = 0;
+    unsigned const alphabetSize = maxSymbolValue + 1;
+    int previousIs0 = 0;
+
+    /* Table Size */
+    bitStream += (tableLog-FSE_MIN_TABLELOG) << bitCount;
+    bitCount  += 4;
+
+    /* Init */
+    remaining = tableSize+1;   /* +1 for extra accuracy */
+    threshold = tableSize;
+    nbBits = tableLog+1;
+
+    while ((symbol < alphabetSize) && (remaining>1)) {  /* stops at 1 */
+        if (previousIs0) {
+            unsigned start = symbol;
+            while ((symbol < alphabetSize) && !normalizedCounter[symbol]) symbol++;
+            if (symbol == alphabetSize) break;   /* incorrect distribution */
+            while (symbol >= start+24) {
+                start+=24;
+                bitStream += 0xFFFFU << bitCount;
+                if ((!writeIsSafe) && (out > oend-2))
+                    return ERROR(dstSize_tooSmall);   /* Buffer overflow */
+                out[0] = (BYTE) bitStream;
+                out[1] = (BYTE)(bitStream>>8);
+                out+=2;
+                bitStream>>=16;
+            }
+            while (symbol >= start+3) {
+                start+=3;
+                bitStream += 3 << bitCount;
+                bitCount += 2;
+            }
+            bitStream += (symbol-start) << bitCount;
+            bitCount += 2;
+            if (bitCount>16) {
+                if ((!writeIsSafe) && (out > oend - 2))
+                    return ERROR(dstSize_tooSmall);   /* Buffer overflow */
+                out[0] = (BYTE)bitStream;
+                out[1] = (BYTE)(bitStream>>8);
+                out += 2;
+                bitStream >>= 16;
+                bitCount -= 16;
+        }   }
+        {   int count = normalizedCounter[symbol++];
+            int const max = (2*threshold-1) - remaining;
+            remaining -= count < 0 ? -count : count;
+            count++;   /* +1 for extra accuracy */
+            if (count>=threshold)
+                count += max;   /* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ */
+            bitStream += count << bitCount;
+            bitCount  += nbBits;
+            bitCount  -= (count<max);
+            previousIs0  = (count==1);
+            if (remaining<1) return ERROR(GENERIC);
+            while (remaining<threshold) { nbBits--; threshold>>=1; }
+        }
+        if (bitCount>16) {
+            if ((!writeIsSafe) && (out > oend - 2))
+                return ERROR(dstSize_tooSmall);   /* Buffer overflow */
+            out[0] = (BYTE)bitStream;
+            out[1] = (BYTE)(bitStream>>8);
+            out += 2;
+            bitStream >>= 16;
+            bitCount -= 16;
+    }   }
+
+    if (remaining != 1)
+        return ERROR(GENERIC);  /* incorrect normalized distribution */
+    assert(symbol <= alphabetSize);
+
+    /* flush remaining bitStream */
+    if ((!writeIsSafe) && (out > oend - 2))
+        return ERROR(dstSize_tooSmall);   /* Buffer overflow */
+    out[0] = (BYTE)bitStream;
+    out[1] = (BYTE)(bitStream>>8);
+    out+= (bitCount+7) /8;
+
+    return (out-ostart);
+}
+
+
+size_t FSE_writeNCount (void* buffer, size_t bufferSize,
+                  const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog)
+{
+    if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);   /* Unsupported */
+    if (tableLog < FSE_MIN_TABLELOG) return ERROR(GENERIC);   /* Unsupported */
+
+    if (bufferSize < FSE_NCountWriteBound(maxSymbolValue, tableLog))
+        return FSE_writeNCount_generic(buffer, bufferSize, normalizedCounter, maxSymbolValue, tableLog, 0);
+
+    return FSE_writeNCount_generic(buffer, bufferSize, normalizedCounter, maxSymbolValue, tableLog, 1 /* write in buffer is safe */);
+}
+
+
+/*-**************************************************************
+*  FSE Compression Code
+****************************************************************/
+
+/* provides the minimum logSize to safely represent a distribution */
+static unsigned FSE_minTableLog(size_t srcSize, unsigned maxSymbolValue)
+{
+    U32 minBitsSrc = ZSTD_highbit32((U32)(srcSize)) + 1;
+    U32 minBitsSymbols = ZSTD_highbit32(maxSymbolValue) + 2;
+    U32 minBits = minBitsSrc < minBitsSymbols ? minBitsSrc : minBitsSymbols;
+    assert(srcSize > 1); /* Not supported, RLE should be used instead */
+    return minBits;
+}
+
+unsigned FSE_optimalTableLog_internal(unsigned maxTableLog, size_t srcSize, unsigned maxSymbolValue, unsigned minus)
+{
+    U32 maxBitsSrc = ZSTD_highbit32((U32)(srcSize - 1)) - minus;
+    U32 tableLog = maxTableLog;
+    U32 minBits = FSE_minTableLog(srcSize, maxSymbolValue);
+    assert(srcSize > 1); /* Not supported, RLE should be used instead */
+    if (tableLog==0) tableLog = FSE_DEFAULT_TABLELOG;
+    if (maxBitsSrc < tableLog) tableLog = maxBitsSrc;   /* Accuracy can be reduced */
+    if (minBits > tableLog) tableLog = minBits;   /* Need a minimum to safely represent all symbol values */
+    if (tableLog < FSE_MIN_TABLELOG) tableLog = FSE_MIN_TABLELOG;
+    if (tableLog > FSE_MAX_TABLELOG) tableLog = FSE_MAX_TABLELOG;
+    return tableLog;
+}
+
+unsigned FSE_optimalTableLog(unsigned maxTableLog, size_t srcSize, unsigned maxSymbolValue)
+{
+    return FSE_optimalTableLog_internal(maxTableLog, srcSize, maxSymbolValue, 2);
+}
+
+/* Secondary normalization method.
+   To be used when primary method fails. */
+
+static size_t FSE_normalizeM2(short* norm, U32 tableLog, const unsigned* count, size_t total, U32 maxSymbolValue, short lowProbCount)
+{
+    short const NOT_YET_ASSIGNED = -2;
+    U32 s;
+    U32 distributed = 0;
+    U32 ToDistribute;
+
+    /* Init */
+    U32 const lowThreshold = (U32)(total >> tableLog);
+    U32 lowOne = (U32)((total * 3) >> (tableLog + 1));
+
+    for (s=0; s<=maxSymbolValue; s++) {
+        if (count[s] == 0) {
+            norm[s]=0;
+            continue;
+        }
+        if (count[s] <= lowThreshold) {
+            norm[s] = lowProbCount;
+            distributed++;
+            total -= count[s];
+            continue;
+        }
+        if (count[s] <= lowOne) {
+            norm[s] = 1;
+            distributed++;
+            total -= count[s];
+            continue;
+        }
+
+        norm[s]=NOT_YET_ASSIGNED;
+    }
+    ToDistribute = (1 << tableLog) - distributed;
+
+    if (ToDistribute == 0)
+        return 0;
+
+    if ((total / ToDistribute) > lowOne) {
+        /* risk of rounding to zero */
+        lowOne = (U32)((total * 3) / (ToDistribute * 2));
+        for (s=0; s<=maxSymbolValue; s++) {
+            if ((norm[s] == NOT_YET_ASSIGNED) && (count[s] <= lowOne)) {
+                norm[s] = 1;
+                distributed++;
+                total -= count[s];
+                continue;
+        }   }
+        ToDistribute = (1 << tableLog) - distributed;
+    }
+
+    if (distributed == maxSymbolValue+1) {
+        /* all values are pretty poor;
+           probably incompressible data (should have already been detected);
+           find max, then give all remaining points to max */
+        U32 maxV = 0, maxC = 0;
+        for (s=0; s<=maxSymbolValue; s++)
+            if (count[s] > maxC) { maxV=s; maxC=count[s]; }
+        norm[maxV] += (short)ToDistribute;
+        return 0;
+    }
+
+    if (total == 0) {
+        /* all of the symbols were low enough for the lowOne or lowThreshold */
+        for (s=0; ToDistribute > 0; s = (s+1)%(maxSymbolValue+1))
+            if (norm[s] > 0) { ToDistribute--; norm[s]++; }
+        return 0;
+    }
+
+    {   U64 const vStepLog = 62 - tableLog;
+        U64 const mid = (1ULL << (vStepLog-1)) - 1;
+        U64 const rStep = ZSTD_div64((((U64)1<<vStepLog) * ToDistribute) + mid, (U32)total);   /* scale on remaining */
+        U64 tmpTotal = mid;
+        for (s=0; s<=maxSymbolValue; s++) {
+            if (norm[s]==NOT_YET_ASSIGNED) {
+                U64 const end = tmpTotal + (count[s] * rStep);
+                U32 const sStart = (U32)(tmpTotal >> vStepLog);
+                U32 const sEnd = (U32)(end >> vStepLog);
+                U32 const weight = sEnd - sStart;
+                if (weight < 1)
+                    return ERROR(GENERIC);
+                norm[s] = (short)weight;
+                tmpTotal = end;
+    }   }   }
+
+    return 0;
+}
+
+size_t FSE_normalizeCount (short* normalizedCounter, unsigned tableLog,
+                           const unsigned* count, size_t total,
+                           unsigned maxSymbolValue, unsigned useLowProbCount)
+{
+    /* Sanity checks */
+    if (tableLog==0) tableLog = FSE_DEFAULT_TABLELOG;
+    if (tableLog < FSE_MIN_TABLELOG) return ERROR(GENERIC);   /* Unsupported size */
+    if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);   /* Unsupported size */
+    if (tableLog < FSE_minTableLog(total, maxSymbolValue)) return ERROR(GENERIC);   /* Too small tableLog, compression potentially impossible */
+
+    {   static U32 const rtbTable[] = {     0, 473195, 504333, 520860, 550000, 700000, 750000, 830000 };
+        short const lowProbCount = useLowProbCount ? -1 : 1;
+        U64 const scale = 62 - tableLog;
+        U64 const step = ZSTD_div64((U64)1<<62, (U32)total);   /* <== here, one division ! */
+        U64 const vStep = 1ULL<<(scale-20);
+        int stillToDistribute = 1<<tableLog;
+        unsigned s;
+        unsigned largest=0;
+        short largestP=0;
+        U32 lowThreshold = (U32)(total >> tableLog);
+
+        for (s=0; s<=maxSymbolValue; s++) {
+            if (count[s] == total) return 0;   /* rle special case */
+            if (count[s] == 0) { normalizedCounter[s]=0; continue; }
+            if (count[s] <= lowThreshold) {
+                normalizedCounter[s] = lowProbCount;
+                stillToDistribute--;
+            } else {
+                short proba = (short)((count[s]*step) >> scale);
+                if (proba<8) {
+                    U64 restToBeat = vStep * rtbTable[proba];
+                    proba += (count[s]*step) - ((U64)proba<<scale) > restToBeat;
+                }
+                if (proba > largestP) { largestP=proba; largest=s; }
+                normalizedCounter[s] = proba;
+                stillToDistribute -= proba;
+        }   }
+        if (-stillToDistribute >= (normalizedCounter[largest] >> 1)) {
+            /* corner case, need another normalization method */
+            size_t const errorCode = FSE_normalizeM2(normalizedCounter, tableLog, count, total, maxSymbolValue, lowProbCount);
+            if (FSE_isError(errorCode)) return errorCode;
+        }
+        else normalizedCounter[largest] += (short)stillToDistribute;
+    }
+
+#if 0
+    {   /* Print Table (debug) */
+        U32 s;
+        U32 nTotal = 0;
+        for (s=0; s<=maxSymbolValue; s++)
+            RAWLOG(2, "%3i: %4i \n", s, normalizedCounter[s]);
+        for (s=0; s<=maxSymbolValue; s++)
+            nTotal += abs(normalizedCounter[s]);
+        if (nTotal != (1U<<tableLog))
+            RAWLOG(2, "Warning !!! Total == %u != %u !!!", nTotal, 1U<<tableLog);
+        getchar();
+    }
+#endif
+
+    return tableLog;
+}
+
+/* fake FSE_CTable, for rle input (always same symbol) */
+size_t FSE_buildCTable_rle (FSE_CTable* ct, BYTE symbolValue)
+{
+    void* ptr = ct;
+    U16* tableU16 = ( (U16*) ptr) + 2;
+    void* FSCTptr = (U32*)ptr + 2;
+    FSE_symbolCompressionTransform* symbolTT = (FSE_symbolCompressionTransform*) FSCTptr;
+
+    /* header */
+    tableU16[-2] = (U16) 0;
+    tableU16[-1] = (U16) symbolValue;
+
+    /* Build table */
+    tableU16[0] = 0;
+    tableU16[1] = 0;   /* just in case */
+
+    /* Build Symbol Transformation Table */
+    symbolTT[symbolValue].deltaNbBits = 0;
+    symbolTT[symbolValue].deltaFindState = 0;
+
+    return 0;
+}
+
+
+static size_t FSE_compress_usingCTable_generic (void* dst, size_t dstSize,
+                           const void* src, size_t srcSize,
+                           const FSE_CTable* ct, const unsigned fast)
+{
+    const BYTE* const istart = (const BYTE*) src;
+    const BYTE* const iend = istart + srcSize;
+    const BYTE* ip=iend;
+
+    BIT_CStream_t bitC;
+    FSE_CState_t CState1, CState2;
+
+    /* init */
+    if (srcSize <= 2) return 0;
+    { size_t const initError = BIT_initCStream(&bitC, dst, dstSize);
+      if (FSE_isError(initError)) return 0; /* not enough space available to write a bitstream */ }
+
+#define FSE_FLUSHBITS(s)  (fast ? BIT_flushBitsFast(s) : BIT_flushBits(s))
+
+    if (srcSize & 1) {
+        FSE_initCState2(&CState1, ct, *--ip);
+        FSE_initCState2(&CState2, ct, *--ip);
+        FSE_encodeSymbol(&bitC, &CState1, *--ip);
+        FSE_FLUSHBITS(&bitC);
+    } else {
+        FSE_initCState2(&CState2, ct, *--ip);
+        FSE_initCState2(&CState1, ct, *--ip);
+    }
+
+    /* join to mod 4 */
+    srcSize -= 2;
+    if ((sizeof(bitC.bitContainer)*8 > FSE_MAX_TABLELOG*4+7 ) && (srcSize & 2)) {  /* test bit 2 */
+        FSE_encodeSymbol(&bitC, &CState2, *--ip);
+        FSE_encodeSymbol(&bitC, &CState1, *--ip);
+        FSE_FLUSHBITS(&bitC);
+    }
+
+    /* 2 or 4 encoding per loop */
+    while ( ip>istart ) {
+
+        FSE_encodeSymbol(&bitC, &CState2, *--ip);
+
+        if (sizeof(bitC.bitContainer)*8 < FSE_MAX_TABLELOG*2+7 )   /* this test must be static */
+            FSE_FLUSHBITS(&bitC);
+
+        FSE_encodeSymbol(&bitC, &CState1, *--ip);
+
+        if (sizeof(bitC.bitContainer)*8 > FSE_MAX_TABLELOG*4+7 ) {  /* this test must be static */
+            FSE_encodeSymbol(&bitC, &CState2, *--ip);
+            FSE_encodeSymbol(&bitC, &CState1, *--ip);
+        }
+
+        FSE_FLUSHBITS(&bitC);
+    }
+
+    FSE_flushCState(&bitC, &CState2);
+    FSE_flushCState(&bitC, &CState1);
+    return BIT_closeCStream(&bitC);
+}
+
+size_t FSE_compress_usingCTable (void* dst, size_t dstSize,
+                           const void* src, size_t srcSize,
+                           const FSE_CTable* ct)
+{
+    unsigned const fast = (dstSize >= FSE_BLOCKBOUND(srcSize));
+
+    if (fast)
+        return FSE_compress_usingCTable_generic(dst, dstSize, src, srcSize, ct, 1);
+    else
+        return FSE_compress_usingCTable_generic(dst, dstSize, src, srcSize, ct, 0);
+}
+
+
+size_t FSE_compressBound(size_t size) { return FSE_COMPRESSBOUND(size); }
+
+#endif   /* FSE_COMMONDEFS_ONLY */
diff --git a/src/3rdparty/zstd/src/compress/hist.c b/src/3rdparty/zstd/src/compress/hist.c
new file mode 100644
index 0000000000..e2fb431f03
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/hist.c
@@ -0,0 +1,181 @@
+/* ******************************************************************
+ * hist : Histogram functions
+ * part of Finite State Entropy project
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ *  You can contact the author at :
+ *  - FSE source repository : https://github.com/Cyan4973/FiniteStateEntropy
+ *  - Public forum : https://groups.google.com/forum/#!forum/lz4c
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+****************************************************************** */
+
+/* --- dependencies --- */
+#include "../common/mem.h"             /* U32, BYTE, etc. */
+#include "../common/debug.h"           /* assert, DEBUGLOG */
+#include "../common/error_private.h"   /* ERROR */
+#include "hist.h"
+
+
+/* --- Error management --- */
+unsigned HIST_isError(size_t code) { return ERR_isError(code); }
+
+/*-**************************************************************
+ *  Histogram functions
+ ****************************************************************/
+unsigned HIST_count_simple(unsigned* count, unsigned* maxSymbolValuePtr,
+                           const void* src, size_t srcSize)
+{
+    const BYTE* ip = (const BYTE*)src;
+    const BYTE* const end = ip + srcSize;
+    unsigned maxSymbolValue = *maxSymbolValuePtr;
+    unsigned largestCount=0;
+
+    ZSTD_memset(count, 0, (maxSymbolValue+1) * sizeof(*count));
+    if (srcSize==0) { *maxSymbolValuePtr = 0; return 0; }
+
+    while (ip<end) {
+        assert(*ip <= maxSymbolValue);
+        count[*ip++]++;
+    }
+
+    while (!count[maxSymbolValue]) maxSymbolValue--;
+    *maxSymbolValuePtr = maxSymbolValue;
+
+    {   U32 s;
+        for (s=0; s<=maxSymbolValue; s++)
+            if (count[s] > largestCount) largestCount = count[s];
+    }
+
+    return largestCount;
+}
+
+typedef enum { trustInput, checkMaxSymbolValue } HIST_checkInput_e;
+
+/* HIST_count_parallel_wksp() :
+ * store histogram into 4 intermediate tables, recombined at the end.
+ * this design makes better use of OoO cpus,
+ * and is noticeably faster when some values are heavily repeated.
+ * But it needs some additional workspace for intermediate tables.
+ * `workSpace` must be a U32 table of size >= HIST_WKSP_SIZE_U32.
+ * @return : largest histogram frequency,
+ *           or an error code (notably when histogram's alphabet is larger than *maxSymbolValuePtr) */
+static size_t HIST_count_parallel_wksp(
+                                unsigned* count, unsigned* maxSymbolValuePtr,
+                                const void* source, size_t sourceSize,
+                                HIST_checkInput_e check,
+                                U32* const workSpace)
+{
+    const BYTE* ip = (const BYTE*)source;
+    const BYTE* const iend = ip+sourceSize;
+    size_t const countSize = (*maxSymbolValuePtr + 1) * sizeof(*count);
+    unsigned max=0;
+    U32* const Counting1 = workSpace;
+    U32* const Counting2 = Counting1 + 256;
+    U32* const Counting3 = Counting2 + 256;
+    U32* const Counting4 = Counting3 + 256;
+
+    /* safety checks */
+    assert(*maxSymbolValuePtr <= 255);
+    if (!sourceSize) {
+        ZSTD_memset(count, 0, countSize);
+        *maxSymbolValuePtr = 0;
+        return 0;
+    }
+    ZSTD_memset(workSpace, 0, 4*256*sizeof(unsigned));
+
+    /* by stripes of 16 bytes */
+    {   U32 cached = MEM_read32(ip); ip += 4;
+        while (ip < iend-15) {
+            U32 c = cached; cached = MEM_read32(ip); ip += 4;
+            Counting1[(BYTE) c     ]++;
+            Counting2[(BYTE)(c>>8) ]++;
+            Counting3[(BYTE)(c>>16)]++;
+            Counting4[       c>>24 ]++;
+            c = cached; cached = MEM_read32(ip); ip += 4;
+            Counting1[(BYTE) c     ]++;
+            Counting2[(BYTE)(c>>8) ]++;
+            Counting3[(BYTE)(c>>16)]++;
+            Counting4[       c>>24 ]++;
+            c = cached; cached = MEM_read32(ip); ip += 4;
+            Counting1[(BYTE) c     ]++;
+            Counting2[(BYTE)(c>>8) ]++;
+            Counting3[(BYTE)(c>>16)]++;
+            Counting4[       c>>24 ]++;
+            c = cached; cached = MEM_read32(ip); ip += 4;
+            Counting1[(BYTE) c     ]++;
+            Counting2[(BYTE)(c>>8) ]++;
+            Counting3[(BYTE)(c>>16)]++;
+            Counting4[       c>>24 ]++;
+        }
+        ip-=4;
+    }
+
+    /* finish last symbols */
+    while (ip<iend) Counting1[*ip++]++;
+
+    {   U32 s;
+        for (s=0; s<256; s++) {
+            Counting1[s] += Counting2[s] + Counting3[s] + Counting4[s];
+            if (Counting1[s] > max) max = Counting1[s];
+    }   }
+
+    {   unsigned maxSymbolValue = 255;
+        while (!Counting1[maxSymbolValue]) maxSymbolValue--;
+        if (check && maxSymbolValue > *maxSymbolValuePtr) return ERROR(maxSymbolValue_tooSmall);
+        *maxSymbolValuePtr = maxSymbolValue;
+        ZSTD_memmove(count, Counting1, countSize);   /* in case count & Counting1 are overlapping */
+    }
+    return (size_t)max;
+}
+
+/* HIST_countFast_wksp() :
+ * Same as HIST_countFast(), but using an externally provided scratch buffer.
+ * `workSpace` is a writable buffer which must be 4-bytes aligned,
+ * `workSpaceSize` must be >= HIST_WKSP_SIZE
+ */
+size_t HIST_countFast_wksp(unsigned* count, unsigned* maxSymbolValuePtr,
+                          const void* source, size_t sourceSize,
+                          void* workSpace, size_t workSpaceSize)
+{
+    if (sourceSize < 1500) /* heuristic threshold */
+        return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);
+    if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */
+    if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
+    return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);
+}
+
+/* HIST_count_wksp() :
+ * Same as HIST_count(), but using an externally provided scratch buffer.
+ * `workSpace` size must be table of >= HIST_WKSP_SIZE_U32 unsigned */
+size_t HIST_count_wksp(unsigned* count, unsigned* maxSymbolValuePtr,
+                       const void* source, size_t sourceSize,
+                       void* workSpace, size_t workSpaceSize)
+{
+    if ((size_t)workSpace & 3) return ERROR(GENERIC);  /* must be aligned on 4-bytes boundaries */
+    if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);
+    if (*maxSymbolValuePtr < 255)
+        return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, checkMaxSymbolValue, (U32*)workSpace);
+    *maxSymbolValuePtr = 255;
+    return HIST_countFast_wksp(count, maxSymbolValuePtr, source, sourceSize, workSpace, workSpaceSize);
+}
+
+#ifndef ZSTD_NO_UNUSED_FUNCTIONS
+/* fast variant (unsafe : won't check if src contains values beyond count[] limit) */
+size_t HIST_countFast(unsigned* count, unsigned* maxSymbolValuePtr,
+                     const void* source, size_t sourceSize)
+{
+    unsigned tmpCounters[HIST_WKSP_SIZE_U32];
+    return HIST_countFast_wksp(count, maxSymbolValuePtr, source, sourceSize, tmpCounters, sizeof(tmpCounters));
+}
+
+size_t HIST_count(unsigned* count, unsigned* maxSymbolValuePtr,
+                 const void* src, size_t srcSize)
+{
+    unsigned tmpCounters[HIST_WKSP_SIZE_U32];
+    return HIST_count_wksp(count, maxSymbolValuePtr, src, srcSize, tmpCounters, sizeof(tmpCounters));
+}
+#endif
diff --git a/src/3rdparty/zstd/src/compress/hist.h b/src/3rdparty/zstd/src/compress/hist.h
new file mode 100644
index 0000000000..887896b813
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/hist.h
@@ -0,0 +1,75 @@
+/* ******************************************************************
+ * hist : Histogram functions
+ * part of Finite State Entropy project
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ *  You can contact the author at :
+ *  - FSE source repository : https://github.com/Cyan4973/FiniteStateEntropy
+ *  - Public forum : https://groups.google.com/forum/#!forum/lz4c
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+****************************************************************** */
+
+/* --- dependencies --- */
+#include "../common/zstd_deps.h"   /* size_t */
+
+
+/* --- simple histogram functions --- */
+
+/*! HIST_count():
+ *  Provides the precise count of each byte within a table 'count'.
+ * 'count' is a table of unsigned int, of minimum size (*maxSymbolValuePtr+1).
+ *  Updates *maxSymbolValuePtr with actual largest symbol value detected.
+ * @return : count of the most frequent symbol (which isn't identified).
+ *           or an error code, which can be tested using HIST_isError().
+ *           note : if return == srcSize, there is only one symbol.
+ */
+size_t HIST_count(unsigned* count, unsigned* maxSymbolValuePtr,
+                  const void* src, size_t srcSize);
+
+unsigned HIST_isError(size_t code);  /**< tells if a return value is an error code */
+
+
+/* --- advanced histogram functions --- */
+
+#define HIST_WKSP_SIZE_U32 1024
+#define HIST_WKSP_SIZE    (HIST_WKSP_SIZE_U32 * sizeof(unsigned))
+/** HIST_count_wksp() :
+ *  Same as HIST_count(), but using an externally provided scratch buffer.
+ *  Benefit is this function will use very little stack space.
+ * `workSpace` is a writable buffer which must be 4-bytes aligned,
+ * `workSpaceSize` must be >= HIST_WKSP_SIZE
+ */
+size_t HIST_count_wksp(unsigned* count, unsigned* maxSymbolValuePtr,
+                       const void* src, size_t srcSize,
+                       void* workSpace, size_t workSpaceSize);
+
+/** HIST_countFast() :
+ *  same as HIST_count(), but blindly trusts that all byte values within src are <= *maxSymbolValuePtr.
+ *  This function is unsafe, and will segfault if any value within `src` is `> *maxSymbolValuePtr`
+ */
+size_t HIST_countFast(unsigned* count, unsigned* maxSymbolValuePtr,
+                      const void* src, size_t srcSize);
+
+/** HIST_countFast_wksp() :
+ *  Same as HIST_countFast(), but using an externally provided scratch buffer.
+ * `workSpace` is a writable buffer which must be 4-bytes aligned,
+ * `workSpaceSize` must be >= HIST_WKSP_SIZE
+ */
+size_t HIST_countFast_wksp(unsigned* count, unsigned* maxSymbolValuePtr,
+                           const void* src, size_t srcSize,
+                           void* workSpace, size_t workSpaceSize);
+
+/*! HIST_count_simple() :
+ *  Same as HIST_countFast(), this function is unsafe,
+ *  and will segfault if any value within `src` is `> *maxSymbolValuePtr`.
+ *  It is also a bit slower for large inputs.
+ *  However, it does not need any additional memory (not even on stack).
+ * @return : count of the most frequent symbol.
+ *  Note this function doesn't produce any error (i.e. it must succeed).
+ */
+unsigned HIST_count_simple(unsigned* count, unsigned* maxSymbolValuePtr,
+                           const void* src, size_t srcSize);
diff --git a/src/3rdparty/zstd/src/compress/huf_compress.c b/src/3rdparty/zstd/src/compress/huf_compress.c
new file mode 100644
index 0000000000..29871877a7
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/huf_compress.c
@@ -0,0 +1,1435 @@
+/* ******************************************************************
+ * Huffman encoder, part of New Generation Entropy library
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ *  You can contact the author at :
+ *  - FSE+HUF source repository : https://github.com/Cyan4973/FiniteStateEntropy
+ *  - Public forum : https://groups.google.com/forum/#!forum/lz4c
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+****************************************************************** */
+
+/* **************************************************************
+*  Compiler specifics
+****************************************************************/
+#ifdef _MSC_VER    /* Visual Studio */
+#  pragma warning(disable : 4127)        /* disable: C4127: conditional expression is constant */
+#endif
+
+
+/* **************************************************************
+*  Includes
+****************************************************************/
+#include "../common/zstd_deps.h"     /* ZSTD_memcpy, ZSTD_memset */
+#include "../common/compiler.h"
+#include "../common/bitstream.h"
+#include "hist.h"
+#define FSE_STATIC_LINKING_ONLY   /* FSE_optimalTableLog_internal */
+#include "../common/fse.h"        /* header compression */
+#include "../common/huf.h"
+#include "../common/error_private.h"
+#include "../common/bits.h"       /* ZSTD_highbit32 */
+
+
+/* **************************************************************
+*  Error Management
+****************************************************************/
+#define HUF_isError ERR_isError
+#define HUF_STATIC_ASSERT(c) DEBUG_STATIC_ASSERT(c)   /* use only *after* variable declarations */
+
+
+/* **************************************************************
+*  Required declarations
+****************************************************************/
+typedef struct nodeElt_s {
+    U32 count;
+    U16 parent;
+    BYTE byte;
+    BYTE nbBits;
+} nodeElt;
+
+
+/* **************************************************************
+*  Debug Traces
+****************************************************************/
+
+#if DEBUGLEVEL >= 2
+
+static size_t showU32(const U32* arr, size_t size)
+{
+    size_t u;
+    for (u=0; u<size; u++) {
+        RAWLOG(6, " %u", arr[u]); (void)arr;
+    }
+    RAWLOG(6, " \n");
+    return size;
+}
+
+static size_t HUF_getNbBits(HUF_CElt elt);
+
+static size_t showCTableBits(const HUF_CElt* ctable, size_t size)
+{
+    size_t u;
+    for (u=0; u<size; u++) {
+        RAWLOG(6, " %zu", HUF_getNbBits(ctable[u])); (void)ctable;
+    }
+    RAWLOG(6, " \n");
+    return size;
+
+}
+
+static size_t showHNodeSymbols(const nodeElt* hnode, size_t size)
+{
+    size_t u;
+    for (u=0; u<size; u++) {
+        RAWLOG(6, " %u", hnode[u].byte); (void)hnode;
+    }
+    RAWLOG(6, " \n");
+    return size;
+}
+
+static size_t showHNodeBits(const nodeElt* hnode, size_t size)
+{
+    size_t u;
+    for (u=0; u<size; u++) {
+        RAWLOG(6, " %u", hnode[u].nbBits); (void)hnode;
+    }
+    RAWLOG(6, " \n");
+    return size;
+}
+
+#endif
+
+
+/* *******************************************************
+*  HUF : Huffman block compression
+*********************************************************/
+#define HUF_WORKSPACE_MAX_ALIGNMENT 8
+
+static void* HUF_alignUpWorkspace(void* workspace, size_t* workspaceSizePtr, size_t align)
+{
+    size_t const mask = align - 1;
+    size_t const rem = (size_t)workspace & mask;
+    size_t const add = (align - rem) & mask;
+    BYTE* const aligned = (BYTE*)workspace + add;
+    assert((align & (align - 1)) == 0); /* pow 2 */
+    assert(align <= HUF_WORKSPACE_MAX_ALIGNMENT);
+    if (*workspaceSizePtr >= add) {
+        assert(add < align);
+        assert(((size_t)aligned & mask) == 0);
+        *workspaceSizePtr -= add;
+        return aligned;
+    } else {
+        *workspaceSizePtr = 0;
+        return NULL;
+    }
+}
+
+
+/* HUF_compressWeights() :
+ * Same as FSE_compress(), but dedicated to huff0's weights compression.
+ * The use case needs much less stack memory.
+ * Note : all elements within weightTable are supposed to be <= HUF_TABLELOG_MAX.
+ */
+#define MAX_FSE_TABLELOG_FOR_HUFF_HEADER 6
+
+typedef struct {
+    FSE_CTable CTable[FSE_CTABLE_SIZE_U32(MAX_FSE_TABLELOG_FOR_HUFF_HEADER, HUF_TABLELOG_MAX)];
+    U32 scratchBuffer[FSE_BUILD_CTABLE_WORKSPACE_SIZE_U32(HUF_TABLELOG_MAX, MAX_FSE_TABLELOG_FOR_HUFF_HEADER)];
+    unsigned count[HUF_TABLELOG_MAX+1];
+    S16 norm[HUF_TABLELOG_MAX+1];
+} HUF_CompressWeightsWksp;
+
+static size_t
+HUF_compressWeights(void* dst, size_t dstSize,
+              const void* weightTable, size_t wtSize,
+                    void* workspace, size_t workspaceSize)
+{
+    BYTE* const ostart = (BYTE*) dst;
+    BYTE* op = ostart;
+    BYTE* const oend = ostart + dstSize;
+
+    unsigned maxSymbolValue = HUF_TABLELOG_MAX;
+    U32 tableLog = MAX_FSE_TABLELOG_FOR_HUFF_HEADER;
+    HUF_CompressWeightsWksp* wksp = (HUF_CompressWeightsWksp*)HUF_alignUpWorkspace(workspace, &workspaceSize, ZSTD_ALIGNOF(U32));
+
+    if (workspaceSize < sizeof(HUF_CompressWeightsWksp)) return ERROR(GENERIC);
+
+    /* init conditions */
+    if (wtSize <= 1) return 0;  /* Not compressible */
+
+    /* Scan input and build symbol stats */
+    {   unsigned const maxCount = HIST_count_simple(wksp->count, &maxSymbolValue, weightTable, wtSize);   /* never fails */
+        if (maxCount == wtSize) return 1;   /* only a single symbol in src : rle */
+        if (maxCount == 1) return 0;        /* each symbol present maximum once => not compressible */
+    }
+
+    tableLog = FSE_optimalTableLog(tableLog, wtSize, maxSymbolValue);
+    CHECK_F( FSE_normalizeCount(wksp->norm, tableLog, wksp->count, wtSize, maxSymbolValue, /* useLowProbCount */ 0) );
+
+    /* Write table description header */
+    {   CHECK_V_F(hSize, FSE_writeNCount(op, (size_t)(oend-op), wksp->norm, maxSymbolValue, tableLog) );
+        op += hSize;
+    }
+
+    /* Compress */
+    CHECK_F( FSE_buildCTable_wksp(wksp->CTable, wksp->norm, maxSymbolValue, tableLog, wksp->scratchBuffer, sizeof(wksp->scratchBuffer)) );
+    {   CHECK_V_F(cSize, FSE_compress_usingCTable(op, (size_t)(oend - op), weightTable, wtSize, wksp->CTable) );
+        if (cSize == 0) return 0;   /* not enough space for compressed data */
+        op += cSize;
+    }
+
+    return (size_t)(op-ostart);
+}
+
+static size_t HUF_getNbBits(HUF_CElt elt)
+{
+    return elt & 0xFF;
+}
+
+static size_t HUF_getNbBitsFast(HUF_CElt elt)
+{
+    return elt;
+}
+
+static size_t HUF_getValue(HUF_CElt elt)
+{
+    return elt & ~(size_t)0xFF;
+}
+
+static size_t HUF_getValueFast(HUF_CElt elt)
+{
+    return elt;
+}
+
+static void HUF_setNbBits(HUF_CElt* elt, size_t nbBits)
+{
+    assert(nbBits <= HUF_TABLELOG_ABSOLUTEMAX);
+    *elt = nbBits;
+}
+
+static void HUF_setValue(HUF_CElt* elt, size_t value)
+{
+    size_t const nbBits = HUF_getNbBits(*elt);
+    if (nbBits > 0) {
+        assert((value >> nbBits) == 0);
+        *elt |= value << (sizeof(HUF_CElt) * 8 - nbBits);
+    }
+}
+
+typedef struct {
+    HUF_CompressWeightsWksp wksp;
+    BYTE bitsToWeight[HUF_TABLELOG_MAX + 1];   /* precomputed conversion table */
+    BYTE huffWeight[HUF_SYMBOLVALUE_MAX];
+} HUF_WriteCTableWksp;
+
+size_t HUF_writeCTable_wksp(void* dst, size_t maxDstSize,
+                            const HUF_CElt* CTable, unsigned maxSymbolValue, unsigned huffLog,
+                            void* workspace, size_t workspaceSize)
+{
+    HUF_CElt const* const ct = CTable + 1;
+    BYTE* op = (BYTE*)dst;
+    U32 n;
+    HUF_WriteCTableWksp* wksp = (HUF_WriteCTableWksp*)HUF_alignUpWorkspace(workspace, &workspaceSize, ZSTD_ALIGNOF(U32));
+
+    HUF_STATIC_ASSERT(HUF_CTABLE_WORKSPACE_SIZE >= sizeof(HUF_WriteCTableWksp));
+
+    /* check conditions */
+    if (workspaceSize < sizeof(HUF_WriteCTableWksp)) return ERROR(GENERIC);
+    if (maxSymbolValue > HUF_SYMBOLVALUE_MAX) return ERROR(maxSymbolValue_tooLarge);
+
+    /* convert to weight */
+    wksp->bitsToWeight[0] = 0;
+    for (n=1; n<huffLog+1; n++)
+        wksp->bitsToWeight[n] = (BYTE)(huffLog + 1 - n);
+    for (n=0; n<maxSymbolValue; n++)
+        wksp->huffWeight[n] = wksp->bitsToWeight[HUF_getNbBits(ct[n])];
+
+    /* attempt weights compression by FSE */
+    if (maxDstSize < 1) return ERROR(dstSize_tooSmall);
+    {   CHECK_V_F(hSize, HUF_compressWeights(op+1, maxDstSize-1, wksp->huffWeight, maxSymbolValue, &wksp->wksp, sizeof(wksp->wksp)) );
+        if ((hSize>1) & (hSize < maxSymbolValue/2)) {   /* FSE compressed */
+            op[0] = (BYTE)hSize;
+            return hSize+1;
+    }   }
+
+    /* write raw values as 4-bits (max : 15) */
+    if (maxSymbolValue > (256-128)) return ERROR(GENERIC);   /* should not happen : likely means source cannot be compressed */
+    if (((maxSymbolValue+1)/2) + 1 > maxDstSize) return ERROR(dstSize_tooSmall);   /* not enough space within dst buffer */
+    op[0] = (BYTE)(128 /*special case*/ + (maxSymbolValue-1));
+    wksp->huffWeight[maxSymbolValue] = 0;   /* to be sure it doesn't cause msan issue in final combination */
+    for (n=0; n<maxSymbolValue; n+=2)
+        op[(n/2)+1] = (BYTE)((wksp->huffWeight[n] << 4) + wksp->huffWeight[n+1]);
+    return ((maxSymbolValue+1)/2) + 1;
+}
+
+
+size_t HUF_readCTable (HUF_CElt* CTable, unsigned* maxSymbolValuePtr, const void* src, size_t srcSize, unsigned* hasZeroWeights)
+{
+    BYTE huffWeight[HUF_SYMBOLVALUE_MAX + 1];   /* init not required, even though some static analyzer may complain */
+    U32 rankVal[HUF_TABLELOG_ABSOLUTEMAX + 1];   /* large enough for values from 0 to 16 */
+    U32 tableLog = 0;
+    U32 nbSymbols = 0;
+    HUF_CElt* const ct = CTable + 1;
+
+    /* get symbol weights */
+    CHECK_V_F(readSize, HUF_readStats(huffWeight, HUF_SYMBOLVALUE_MAX+1, rankVal, &nbSymbols, &tableLog, src, srcSize));
+    *hasZeroWeights = (rankVal[0] > 0);
+
+    /* check result */
+    if (tableLog > HUF_TABLELOG_MAX) return ERROR(tableLog_tooLarge);
+    if (nbSymbols > *maxSymbolValuePtr+1) return ERROR(maxSymbolValue_tooSmall);
+
+    CTable[0] = tableLog;
+
+    /* Prepare base value per rank */
+    {   U32 n, nextRankStart = 0;
+        for (n=1; n<=tableLog; n++) {
+            U32 curr = nextRankStart;
+            nextRankStart += (rankVal[n] << (n-1));
+            rankVal[n] = curr;
+    }   }
+
+    /* fill nbBits */
+    {   U32 n; for (n=0; n<nbSymbols; n++) {
+            const U32 w = huffWeight[n];
+            HUF_setNbBits(ct + n, (BYTE)(tableLog + 1 - w) & -(w != 0));
+    }   }
+
+    /* fill val */
+    {   U16 nbPerRank[HUF_TABLELOG_MAX+2]  = {0};  /* support w=0=>n=tableLog+1 */
+        U16 valPerRank[HUF_TABLELOG_MAX+2] = {0};
+        { U32 n; for (n=0; n<nbSymbols; n++) nbPerRank[HUF_getNbBits(ct[n])]++; }
+        /* determine stating value per rank */
+        valPerRank[tableLog+1] = 0;   /* for w==0 */
+        {   U16 min = 0;
+            U32 n; for (n=tableLog; n>0; n--) {  /* start at n=tablelog <-> w=1 */
+                valPerRank[n] = min;     /* get starting value within each rank */
+                min += nbPerRank[n];
+                min >>= 1;
+        }   }
+        /* assign value within rank, symbol order */
+        { U32 n; for (n=0; n<nbSymbols; n++) HUF_setValue(ct + n, valPerRank[HUF_getNbBits(ct[n])]++); }
+    }
+
+    *maxSymbolValuePtr = nbSymbols - 1;
+    return readSize;
+}
+
+U32 HUF_getNbBitsFromCTable(HUF_CElt const* CTable, U32 symbolValue)
+{
+    const HUF_CElt* const ct = CTable + 1;
+    assert(symbolValue <= HUF_SYMBOLVALUE_MAX);
+    return (U32)HUF_getNbBits(ct[symbolValue]);
+}
+
+
+/**
+ * HUF_setMaxHeight():
+ * Try to enforce @targetNbBits on the Huffman tree described in @huffNode.
+ *
+ * It attempts to convert all nodes with nbBits > @targetNbBits
+ * to employ @targetNbBits instead. Then it adjusts the tree
+ * so that it remains a valid canonical Huffman tree.
+ *
+ * @pre               The sum of the ranks of each symbol == 2^largestBits,
+ *                    where largestBits == huffNode[lastNonNull].nbBits.
+ * @post              The sum of the ranks of each symbol == 2^largestBits,
+ *                    where largestBits is the return value (expected <= targetNbBits).
+ *
+ * @param huffNode    The Huffman tree modified in place to enforce targetNbBits.
+ *                    It's presumed sorted, from most frequent to rarest symbol.
+ * @param lastNonNull The symbol with the lowest count in the Huffman tree.
+ * @param targetNbBits  The allowed number of bits, which the Huffman tree
+ *                    may not respect. After this function the Huffman tree will
+ *                    respect targetNbBits.
+ * @return            The maximum number of bits of the Huffman tree after adjustment.
+ */
+static U32 HUF_setMaxHeight(nodeElt* huffNode, U32 lastNonNull, U32 targetNbBits)
+{
+    const U32 largestBits = huffNode[lastNonNull].nbBits;
+    /* early exit : no elt > targetNbBits, so the tree is already valid. */
+    if (largestBits <= targetNbBits) return largestBits;
+
+    DEBUGLOG(5, "HUF_setMaxHeight (targetNbBits = %u)", targetNbBits);
+
+    /* there are several too large elements (at least >= 2) */
+    {   int totalCost = 0;
+        const U32 baseCost = 1 << (largestBits - targetNbBits);
+        int n = (int)lastNonNull;
+
+        /* Adjust any ranks > targetNbBits to targetNbBits.
+         * Compute totalCost, which is how far the sum of the ranks is
+         * we are over 2^largestBits after adjust the offending ranks.
+         */
+        while (huffNode[n].nbBits > targetNbBits) {
+            totalCost += baseCost - (1 << (largestBits - huffNode[n].nbBits));
+            huffNode[n].nbBits = (BYTE)targetNbBits;
+            n--;
+        }
+        /* n stops at huffNode[n].nbBits <= targetNbBits */
+        assert(huffNode[n].nbBits <= targetNbBits);
+        /* n end at index of smallest symbol using < targetNbBits */
+        while (huffNode[n].nbBits == targetNbBits) --n;
+
+        /* renorm totalCost from 2^largestBits to 2^targetNbBits
+         * note : totalCost is necessarily a multiple of baseCost */
+        assert(((U32)totalCost & (baseCost - 1)) == 0);
+        totalCost >>= (largestBits - targetNbBits);
+        assert(totalCost > 0);
+
+        /* repay normalized cost */
+        {   U32 const noSymbol = 0xF0F0F0F0;
+            U32 rankLast[HUF_TABLELOG_MAX+2];
+
+            /* Get pos of last (smallest = lowest cum. count) symbol per rank */
+            ZSTD_memset(rankLast, 0xF0, sizeof(rankLast));
+            {   U32 currentNbBits = targetNbBits;
+                int pos;
+                for (pos=n ; pos >= 0; pos--) {
+                    if (huffNode[pos].nbBits >= currentNbBits) continue;
+                    currentNbBits = huffNode[pos].nbBits;   /* < targetNbBits */
+                    rankLast[targetNbBits-currentNbBits] = (U32)pos;
+            }   }
+
+            while (totalCost > 0) {
+                /* Try to reduce the next power of 2 above totalCost because we
+                 * gain back half the rank.
+                 */
+                U32 nBitsToDecrease = ZSTD_highbit32((U32)totalCost) + 1;
+                for ( ; nBitsToDecrease > 1; nBitsToDecrease--) {
+                    U32 const highPos = rankLast[nBitsToDecrease];
+                    U32 const lowPos = rankLast[nBitsToDecrease-1];
+                    if (highPos == noSymbol) continue;
+                    /* Decrease highPos if no symbols of lowPos or if it is
+                     * not cheaper to remove 2 lowPos than highPos.
+                     */
+                    if (lowPos == noSymbol) break;
+                    {   U32 const highTotal = huffNode[highPos].count;
+                        U32 const lowTotal = 2 * huffNode[lowPos].count;
+                        if (highTotal <= lowTotal) break;
+                }   }
+                /* only triggered when no more rank 1 symbol left => find closest one (note : there is necessarily at least one !) */
+                assert(rankLast[nBitsToDecrease] != noSymbol || nBitsToDecrease == 1);
+                /* HUF_MAX_TABLELOG test just to please gcc 5+; but it should not be necessary */
+                while ((nBitsToDecrease<=HUF_TABLELOG_MAX) && (rankLast[nBitsToDecrease] == noSymbol))
+                    nBitsToDecrease++;
+                assert(rankLast[nBitsToDecrease] != noSymbol);
+                /* Increase the number of bits to gain back half the rank cost. */
+                totalCost -= 1 << (nBitsToDecrease-1);
+                huffNode[rankLast[nBitsToDecrease]].nbBits++;
+
+                /* Fix up the new rank.
+                 * If the new rank was empty, this symbol is now its smallest.
+                 * Otherwise, this symbol will be the largest in the new rank so no adjustment.
+                 */
+                if (rankLast[nBitsToDecrease-1] == noSymbol)
+                    rankLast[nBitsToDecrease-1] = rankLast[nBitsToDecrease];
+                /* Fix up the old rank.
+                 * If the symbol was at position 0, meaning it was the highest weight symbol in the tree,
+                 * it must be the only symbol in its rank, so the old rank now has no symbols.
+                 * Otherwise, since the Huffman nodes are sorted by count, the previous position is now
+                 * the smallest node in the rank. If the previous position belongs to a different rank,
+                 * then the rank is now empty.
+                 */
+                if (rankLast[nBitsToDecrease] == 0)    /* special case, reached largest symbol */
+                    rankLast[nBitsToDecrease] = noSymbol;
+                else {
+                    rankLast[nBitsToDecrease]--;
+                    if (huffNode[rankLast[nBitsToDecrease]].nbBits != targetNbBits-nBitsToDecrease)
+                        rankLast[nBitsToDecrease] = noSymbol;   /* this rank is now empty */
+                }
+            }   /* while (totalCost > 0) */
+
+            /* If we've removed too much weight, then we have to add it back.
+             * To avoid overshooting again, we only adjust the smallest rank.
+             * We take the largest nodes from the lowest rank 0 and move them
+             * to rank 1. There's guaranteed to be enough rank 0 symbols because
+             * TODO.
+             */
+            while (totalCost < 0) {  /* Sometimes, cost correction overshoot */
+                /* special case : no rank 1 symbol (using targetNbBits-1);
+                 * let's create one from largest rank 0 (using targetNbBits).
+                 */
+                if (rankLast[1] == noSymbol) {
+                    while (huffNode[n].nbBits == targetNbBits) n--;
+                    huffNode[n+1].nbBits--;
+                    assert(n >= 0);
+                    rankLast[1] = (U32)(n+1);
+                    totalCost++;
+                    continue;
+                }
+                huffNode[ rankLast[1] + 1 ].nbBits--;
+                rankLast[1]++;
+                totalCost ++;
+            }
+        }   /* repay normalized cost */
+    }   /* there are several too large elements (at least >= 2) */
+
+    return targetNbBits;
+}
+
+typedef struct {
+    U16 base;
+    U16 curr;
+} rankPos;
+
+typedef nodeElt huffNodeTable[2 * (HUF_SYMBOLVALUE_MAX + 1)];
+
+/* Number of buckets available for HUF_sort() */
+#define RANK_POSITION_TABLE_SIZE 192
+
+typedef struct {
+  huffNodeTable huffNodeTbl;
+  rankPos rankPosition[RANK_POSITION_TABLE_SIZE];
+} HUF_buildCTable_wksp_tables;
+
+/* RANK_POSITION_DISTINCT_COUNT_CUTOFF == Cutoff point in HUF_sort() buckets for which we use log2 bucketing.
+ * Strategy is to use as many buckets as possible for representing distinct
+ * counts while using the remainder to represent all "large" counts.
+ *
+ * To satisfy this requirement for 192 buckets, we can do the following:
+ * Let buckets 0-166 represent distinct counts of [0, 166]
+ * Let buckets 166 to 192 represent all remaining counts up to RANK_POSITION_MAX_COUNT_LOG using log2 bucketing.
+ */
+#define RANK_POSITION_MAX_COUNT_LOG 32
+#define RANK_POSITION_LOG_BUCKETS_BEGIN ((RANK_POSITION_TABLE_SIZE - 1) - RANK_POSITION_MAX_COUNT_LOG - 1 /* == 158 */)
+#define RANK_POSITION_DISTINCT_COUNT_CUTOFF (RANK_POSITION_LOG_BUCKETS_BEGIN + ZSTD_highbit32(RANK_POSITION_LOG_BUCKETS_BEGIN) /* == 166 */)
+
+/* Return the appropriate bucket index for a given count. See definition of
+ * RANK_POSITION_DISTINCT_COUNT_CUTOFF for explanation of bucketing strategy.
+ */
+static U32 HUF_getIndex(U32 const count) {
+    return (count < RANK_POSITION_DISTINCT_COUNT_CUTOFF)
+        ? count
+        : ZSTD_highbit32(count) + RANK_POSITION_LOG_BUCKETS_BEGIN;
+}
+
+/* Helper swap function for HUF_quickSortPartition() */
+static void HUF_swapNodes(nodeElt* a, nodeElt* b) {
+	nodeElt tmp = *a;
+	*a = *b;
+	*b = tmp;
+}
+
+/* Returns 0 if the huffNode array is not sorted by descending count */
+MEM_STATIC int HUF_isSorted(nodeElt huffNode[], U32 const maxSymbolValue1) {
+    U32 i;
+    for (i = 1; i < maxSymbolValue1; ++i) {
+        if (huffNode[i].count > huffNode[i-1].count) {
+            return 0;
+        }
+    }
+    return 1;
+}
+
+/* Insertion sort by descending order */
+HINT_INLINE void HUF_insertionSort(nodeElt huffNode[], int const low, int const high) {
+    int i;
+    int const size = high-low+1;
+    huffNode += low;
+    for (i = 1; i < size; ++i) {
+        nodeElt const key = huffNode[i];
+        int j = i - 1;
+        while (j >= 0 && huffNode[j].count < key.count) {
+            huffNode[j + 1] = huffNode[j];
+            j--;
+        }
+        huffNode[j + 1] = key;
+    }
+}
+
+/* Pivot helper function for quicksort. */
+static int HUF_quickSortPartition(nodeElt arr[], int const low, int const high) {
+    /* Simply select rightmost element as pivot. "Better" selectors like
+     * median-of-three don't experimentally appear to have any benefit.
+     */
+    U32 const pivot = arr[high].count;
+    int i = low - 1;
+    int j = low;
+    for ( ; j < high; j++) {
+        if (arr[j].count > pivot) {
+            i++;
+            HUF_swapNodes(&arr[i], &arr[j]);
+        }
+    }
+    HUF_swapNodes(&arr[i + 1], &arr[high]);
+    return i + 1;
+}
+
+/* Classic quicksort by descending with partially iterative calls
+ * to reduce worst case callstack size.
+ */
+static void HUF_simpleQuickSort(nodeElt arr[], int low, int high) {
+    int const kInsertionSortThreshold = 8;
+    if (high - low < kInsertionSortThreshold) {
+        HUF_insertionSort(arr, low, high);
+        return;
+    }
+    while (low < high) {
+        int const idx = HUF_quickSortPartition(arr, low, high);
+        if (idx - low < high - idx) {
+            HUF_simpleQuickSort(arr, low, idx - 1);
+            low = idx + 1;
+        } else {
+            HUF_simpleQuickSort(arr, idx + 1, high);
+            high = idx - 1;
+        }
+    }
+}
+
+/**
+ * HUF_sort():
+ * Sorts the symbols [0, maxSymbolValue] by count[symbol] in decreasing order.
+ * This is a typical bucket sorting strategy that uses either quicksort or insertion sort to sort each bucket.
+ *
+ * @param[out] huffNode       Sorted symbols by decreasing count. Only members `.count` and `.byte` are filled.
+ *                            Must have (maxSymbolValue + 1) entries.
+ * @param[in]  count          Histogram of the symbols.
+ * @param[in]  maxSymbolValue Maximum symbol value.
+ * @param      rankPosition   This is a scratch workspace. Must have RANK_POSITION_TABLE_SIZE entries.
+ */
+static void HUF_sort(nodeElt huffNode[], const unsigned count[], U32 const maxSymbolValue, rankPos rankPosition[]) {
+    U32 n;
+    U32 const maxSymbolValue1 = maxSymbolValue+1;
+
+    /* Compute base and set curr to base.
+     * For symbol s let lowerRank = HUF_getIndex(count[n]) and rank = lowerRank + 1.
+     * See HUF_getIndex to see bucketing strategy.
+     * We attribute each symbol to lowerRank's base value, because we want to know where
+     * each rank begins in the output, so for rank R we want to count ranks R+1 and above.
+     */
+    ZSTD_memset(rankPosition, 0, sizeof(*rankPosition) * RANK_POSITION_TABLE_SIZE);
+    for (n = 0; n < maxSymbolValue1; ++n) {
+        U32 lowerRank = HUF_getIndex(count[n]);
+        assert(lowerRank < RANK_POSITION_TABLE_SIZE - 1);
+        rankPosition[lowerRank].base++;
+    }
+
+    assert(rankPosition[RANK_POSITION_TABLE_SIZE - 1].base == 0);
+    /* Set up the rankPosition table */
+    for (n = RANK_POSITION_TABLE_SIZE - 1; n > 0; --n) {
+        rankPosition[n-1].base += rankPosition[n].base;
+        rankPosition[n-1].curr = rankPosition[n-1].base;
+    }
+
+    /* Insert each symbol into their appropriate bucket, setting up rankPosition table. */
+    for (n = 0; n < maxSymbolValue1; ++n) {
+        U32 const c = count[n];
+        U32 const r = HUF_getIndex(c) + 1;
+        U32 const pos = rankPosition[r].curr++;
+        assert(pos < maxSymbolValue1);
+        huffNode[pos].count = c;
+        huffNode[pos].byte  = (BYTE)n;
+    }
+
+    /* Sort each bucket. */
+    for (n = RANK_POSITION_DISTINCT_COUNT_CUTOFF; n < RANK_POSITION_TABLE_SIZE - 1; ++n) {
+        int const bucketSize = rankPosition[n].curr - rankPosition[n].base;
+        U32 const bucketStartIdx = rankPosition[n].base;
+        if (bucketSize > 1) {
+            assert(bucketStartIdx < maxSymbolValue1);
+            HUF_simpleQuickSort(huffNode + bucketStartIdx, 0, bucketSize-1);
+        }
+    }
+
+    assert(HUF_isSorted(huffNode, maxSymbolValue1));
+}
+
+
+/** HUF_buildCTable_wksp() :
+ *  Same as HUF_buildCTable(), but using externally allocated scratch buffer.
+ *  `workSpace` must be aligned on 4-bytes boundaries, and be at least as large as sizeof(HUF_buildCTable_wksp_tables).
+ */
+#define STARTNODE (HUF_SYMBOLVALUE_MAX+1)
+
+/* HUF_buildTree():
+ * Takes the huffNode array sorted by HUF_sort() and builds an unlimited-depth Huffman tree.
+ *
+ * @param huffNode        The array sorted by HUF_sort(). Builds the Huffman tree in this array.
+ * @param maxSymbolValue  The maximum symbol value.
+ * @return                The smallest node in the Huffman tree (by count).
+ */
+static int HUF_buildTree(nodeElt* huffNode, U32 maxSymbolValue)
+{
+    nodeElt* const huffNode0 = huffNode - 1;
+    int nonNullRank;
+    int lowS, lowN;
+    int nodeNb = STARTNODE;
+    int n, nodeRoot;
+    DEBUGLOG(5, "HUF_buildTree (alphabet size = %u)", maxSymbolValue + 1);
+    /* init for parents */
+    nonNullRank = (int)maxSymbolValue;
+    while(huffNode[nonNullRank].count == 0) nonNullRank--;
+    lowS = nonNullRank; nodeRoot = nodeNb + lowS - 1; lowN = nodeNb;
+    huffNode[nodeNb].count = huffNode[lowS].count + huffNode[lowS-1].count;
+    huffNode[lowS].parent = huffNode[lowS-1].parent = (U16)nodeNb;
+    nodeNb++; lowS-=2;
+    for (n=nodeNb; n<=nodeRoot; n++) huffNode[n].count = (U32)(1U<<30);
+    huffNode0[0].count = (U32)(1U<<31);  /* fake entry, strong barrier */
+
+    /* create parents */
+    while (nodeNb <= nodeRoot) {
+        int const n1 = (huffNode[lowS].count < huffNode[lowN].count) ? lowS-- : lowN++;
+        int const n2 = (huffNode[lowS].count < huffNode[lowN].count) ? lowS-- : lowN++;
+        huffNode[nodeNb].count = huffNode[n1].count + huffNode[n2].count;
+        huffNode[n1].parent = huffNode[n2].parent = (U16)nodeNb;
+        nodeNb++;
+    }
+
+    /* distribute weights (unlimited tree height) */
+    huffNode[nodeRoot].nbBits = 0;
+    for (n=nodeRoot-1; n>=STARTNODE; n--)
+        huffNode[n].nbBits = huffNode[ huffNode[n].parent ].nbBits + 1;
+    for (n=0; n<=nonNullRank; n++)
+        huffNode[n].nbBits = huffNode[ huffNode[n].parent ].nbBits + 1;
+
+    DEBUGLOG(6, "Initial distribution of bits completed (%zu sorted symbols)", showHNodeBits(huffNode, maxSymbolValue+1));
+
+    return nonNullRank;
+}
+
+/**
+ * HUF_buildCTableFromTree():
+ * Build the CTable given the Huffman tree in huffNode.
+ *
+ * @param[out] CTable         The output Huffman CTable.
+ * @param      huffNode       The Huffman tree.
+ * @param      nonNullRank    The last and smallest node in the Huffman tree.
+ * @param      maxSymbolValue The maximum symbol value.
+ * @param      maxNbBits      The exact maximum number of bits used in the Huffman tree.
+ */
+static void HUF_buildCTableFromTree(HUF_CElt* CTable, nodeElt const* huffNode, int nonNullRank, U32 maxSymbolValue, U32 maxNbBits)
+{
+    HUF_CElt* const ct = CTable + 1;
+    /* fill result into ctable (val, nbBits) */
+    int n;
+    U16 nbPerRank[HUF_TABLELOG_MAX+1] = {0};
+    U16 valPerRank[HUF_TABLELOG_MAX+1] = {0};
+    int const alphabetSize = (int)(maxSymbolValue + 1);
+    for (n=0; n<=nonNullRank; n++)
+        nbPerRank[huffNode[n].nbBits]++;
+    /* determine starting value per rank */
+    {   U16 min = 0;
+        for (n=(int)maxNbBits; n>0; n--) {
+            valPerRank[n] = min;      /* get starting value within each rank */
+            min += nbPerRank[n];
+            min >>= 1;
+    }   }
+    for (n=0; n<alphabetSize; n++)
+        HUF_setNbBits(ct + huffNode[n].byte, huffNode[n].nbBits);   /* push nbBits per symbol, symbol order */
+    for (n=0; n<alphabetSize; n++)
+        HUF_setValue(ct + n, valPerRank[HUF_getNbBits(ct[n])]++);   /* assign value within rank, symbol order */
+    CTable[0] = maxNbBits;
+}
+
+size_t
+HUF_buildCTable_wksp(HUF_CElt* CTable, const unsigned* count, U32 maxSymbolValue, U32 maxNbBits,
+                     void* workSpace, size_t wkspSize)
+{
+    HUF_buildCTable_wksp_tables* const wksp_tables =
+        (HUF_buildCTable_wksp_tables*)HUF_alignUpWorkspace(workSpace, &wkspSize, ZSTD_ALIGNOF(U32));
+    nodeElt* const huffNode0 = wksp_tables->huffNodeTbl;
+    nodeElt* const huffNode = huffNode0+1;
+    int nonNullRank;
+
+    HUF_STATIC_ASSERT(HUF_CTABLE_WORKSPACE_SIZE == sizeof(HUF_buildCTable_wksp_tables));
+
+    DEBUGLOG(5, "HUF_buildCTable_wksp (alphabet size = %u)", maxSymbolValue+1);
+
+    /* safety checks */
+    if (wkspSize < sizeof(HUF_buildCTable_wksp_tables))
+        return ERROR(workSpace_tooSmall);
+    if (maxNbBits == 0) maxNbBits = HUF_TABLELOG_DEFAULT;
+    if (maxSymbolValue > HUF_SYMBOLVALUE_MAX)
+        return ERROR(maxSymbolValue_tooLarge);
+    ZSTD_memset(huffNode0, 0, sizeof(huffNodeTable));
+
+    /* sort, decreasing order */
+    HUF_sort(huffNode, count, maxSymbolValue, wksp_tables->rankPosition);
+    DEBUGLOG(6, "sorted symbols completed (%zu symbols)", showHNodeSymbols(huffNode, maxSymbolValue+1));
+
+    /* build tree */
+    nonNullRank = HUF_buildTree(huffNode, maxSymbolValue);
+
+    /* determine and enforce maxTableLog */
+    maxNbBits = HUF_setMaxHeight(huffNode, (U32)nonNullRank, maxNbBits);
+    if (maxNbBits > HUF_TABLELOG_MAX) return ERROR(GENERIC);   /* check fit into table */
+
+    HUF_buildCTableFromTree(CTable, huffNode, nonNullRank, maxSymbolValue, maxNbBits);
+
+    return maxNbBits;
+}
+
+size_t HUF_estimateCompressedSize(const HUF_CElt* CTable, const unsigned* count, unsigned maxSymbolValue)
+{
+    HUF_CElt const* ct = CTable + 1;
+    size_t nbBits = 0;
+    int s;
+    for (s = 0; s <= (int)maxSymbolValue; ++s) {
+        nbBits += HUF_getNbBits(ct[s]) * count[s];
+    }
+    return nbBits >> 3;
+}
+
+int HUF_validateCTable(const HUF_CElt* CTable, const unsigned* count, unsigned maxSymbolValue) {
+  HUF_CElt const* ct = CTable + 1;
+  int bad = 0;
+  int s;
+  for (s = 0; s <= (int)maxSymbolValue; ++s) {
+    bad |= (count[s] != 0) & (HUF_getNbBits(ct[s]) == 0);
+  }
+  return !bad;
+}
+
+size_t HUF_compressBound(size_t size) { return HUF_COMPRESSBOUND(size); }
+
+/** HUF_CStream_t:
+ * Huffman uses its own BIT_CStream_t implementation.
+ * There are three major differences from BIT_CStream_t:
+ *   1. HUF_addBits() takes a HUF_CElt (size_t) which is
+ *      the pair (nbBits, value) in the format:
+ *      format:
+ *        - Bits [0, 4)            = nbBits
+ *        - Bits [4, 64 - nbBits)  = 0
+ *        - Bits [64 - nbBits, 64) = value
+ *   2. The bitContainer is built from the upper bits and
+ *      right shifted. E.g. to add a new value of N bits
+ *      you right shift the bitContainer by N, then or in
+ *      the new value into the N upper bits.
+ *   3. The bitstream has two bit containers. You can add
+ *      bits to the second container and merge them into
+ *      the first container.
+ */
+
+#define HUF_BITS_IN_CONTAINER (sizeof(size_t) * 8)
+
+typedef struct {
+    size_t bitContainer[2];
+    size_t bitPos[2];
+
+    BYTE* startPtr;
+    BYTE* ptr;
+    BYTE* endPtr;
+} HUF_CStream_t;
+
+/**! HUF_initCStream():
+ * Initializes the bitstream.
+ * @returns 0 or an error code.
+ */
+static size_t HUF_initCStream(HUF_CStream_t* bitC,
+                                  void* startPtr, size_t dstCapacity)
+{
+    ZSTD_memset(bitC, 0, sizeof(*bitC));
+    bitC->startPtr = (BYTE*)startPtr;
+    bitC->ptr = bitC->startPtr;
+    bitC->endPtr = bitC->startPtr + dstCapacity - sizeof(bitC->bitContainer[0]);
+    if (dstCapacity <= sizeof(bitC->bitContainer[0])) return ERROR(dstSize_tooSmall);
+    return 0;
+}
+
+/*! HUF_addBits():
+ * Adds the symbol stored in HUF_CElt elt to the bitstream.
+ *
+ * @param elt   The element we're adding. This is a (nbBits, value) pair.
+ *              See the HUF_CStream_t docs for the format.
+ * @param idx   Insert into the bitstream at this idx.
+ * @param kFast This is a template parameter. If the bitstream is guaranteed
+ *              to have at least 4 unused bits after this call it may be 1,
+ *              otherwise it must be 0. HUF_addBits() is faster when fast is set.
+ */
+FORCE_INLINE_TEMPLATE void HUF_addBits(HUF_CStream_t* bitC, HUF_CElt elt, int idx, int kFast)
+{
+    assert(idx <= 1);
+    assert(HUF_getNbBits(elt) <= HUF_TABLELOG_ABSOLUTEMAX);
+    /* This is efficient on x86-64 with BMI2 because shrx
+     * only reads the low 6 bits of the register. The compiler
+     * knows this and elides the mask. When fast is set,
+     * every operation can use the same value loaded from elt.
+     */
+    bitC->bitContainer[idx] >>= HUF_getNbBits(elt);
+    bitC->bitContainer[idx] |= kFast ? HUF_getValueFast(elt) : HUF_getValue(elt);
+    /* We only read the low 8 bits of bitC->bitPos[idx] so it
+     * doesn't matter that the high bits have noise from the value.
+     */
+    bitC->bitPos[idx] += HUF_getNbBitsFast(elt);
+    assert((bitC->bitPos[idx] & 0xFF) <= HUF_BITS_IN_CONTAINER);
+    /* The last 4-bits of elt are dirty if fast is set,
+     * so we must not be overwriting bits that have already been
+     * inserted into the bit container.
+     */
+#if DEBUGLEVEL >= 1
+    {
+        size_t const nbBits = HUF_getNbBits(elt);
+        size_t const dirtyBits = nbBits == 0 ? 0 : ZSTD_highbit32((U32)nbBits) + 1;
+        (void)dirtyBits;
+        /* Middle bits are 0. */
+        assert(((elt >> dirtyBits) << (dirtyBits + nbBits)) == 0);
+        /* We didn't overwrite any bits in the bit container. */
+        assert(!kFast || (bitC->bitPos[idx] & 0xFF) <= HUF_BITS_IN_CONTAINER);
+        (void)dirtyBits;
+    }
+#endif
+}
+
+FORCE_INLINE_TEMPLATE void HUF_zeroIndex1(HUF_CStream_t* bitC)
+{
+    bitC->bitContainer[1] = 0;
+    bitC->bitPos[1] = 0;
+}
+
+/*! HUF_mergeIndex1() :
+ * Merges the bit container @ index 1 into the bit container @ index 0
+ * and zeros the bit container @ index 1.
+ */
+FORCE_INLINE_TEMPLATE void HUF_mergeIndex1(HUF_CStream_t* bitC)
+{
+    assert((bitC->bitPos[1] & 0xFF) < HUF_BITS_IN_CONTAINER);
+    bitC->bitContainer[0] >>= (bitC->bitPos[1] & 0xFF);
+    bitC->bitContainer[0] |= bitC->bitContainer[1];
+    bitC->bitPos[0] += bitC->bitPos[1];
+    assert((bitC->bitPos[0] & 0xFF) <= HUF_BITS_IN_CONTAINER);
+}
+
+/*! HUF_flushBits() :
+* Flushes the bits in the bit container @ index 0.
+*
+* @post bitPos will be < 8.
+* @param kFast If kFast is set then we must know a-priori that
+*              the bit container will not overflow.
+*/
+FORCE_INLINE_TEMPLATE void HUF_flushBits(HUF_CStream_t* bitC, int kFast)
+{
+    /* The upper bits of bitPos are noisy, so we must mask by 0xFF. */
+    size_t const nbBits = bitC->bitPos[0] & 0xFF;
+    size_t const nbBytes = nbBits >> 3;
+    /* The top nbBits bits of bitContainer are the ones we need. */
+    size_t const bitContainer = bitC->bitContainer[0] >> (HUF_BITS_IN_CONTAINER - nbBits);
+    /* Mask bitPos to account for the bytes we consumed. */
+    bitC->bitPos[0] &= 7;
+    assert(nbBits > 0);
+    assert(nbBits <= sizeof(bitC->bitContainer[0]) * 8);
+    assert(bitC->ptr <= bitC->endPtr);
+    MEM_writeLEST(bitC->ptr, bitContainer);
+    bitC->ptr += nbBytes;
+    assert(!kFast || bitC->ptr <= bitC->endPtr);
+    if (!kFast && bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;
+    /* bitContainer doesn't need to be modified because the leftover
+     * bits are already the top bitPos bits. And we don't care about
+     * noise in the lower values.
+     */
+}
+
+/*! HUF_endMark()
+ * @returns The Huffman stream end mark: A 1-bit value = 1.
+ */
+static HUF_CElt HUF_endMark(void)
+{
+    HUF_CElt endMark;
+    HUF_setNbBits(&endMark, 1);
+    HUF_setValue(&endMark, 1);
+    return endMark;
+}
+
+/*! HUF_closeCStream() :
+ *  @return Size of CStream, in bytes,
+ *          or 0 if it could not fit into dstBuffer */
+static size_t HUF_closeCStream(HUF_CStream_t* bitC)
+{
+    HUF_addBits(bitC, HUF_endMark(), /* idx */ 0, /* kFast */ 0);
+    HUF_flushBits(bitC, /* kFast */ 0);
+    {
+        size_t const nbBits = bitC->bitPos[0] & 0xFF;
+        if (bitC->ptr >= bitC->endPtr) return 0; /* overflow detected */
+        return (size_t)(bitC->ptr - bitC->startPtr) + (nbBits > 0);
+    }
+}
+
+FORCE_INLINE_TEMPLATE void
+HUF_encodeSymbol(HUF_CStream_t* bitCPtr, U32 symbol, const HUF_CElt* CTable, int idx, int fast)
+{
+    HUF_addBits(bitCPtr, CTable[symbol], idx, fast);
+}
+
+FORCE_INLINE_TEMPLATE void
+HUF_compress1X_usingCTable_internal_body_loop(HUF_CStream_t* bitC,
+                                   const BYTE* ip, size_t srcSize,
+                                   const HUF_CElt* ct,
+                                   int kUnroll, int kFastFlush, int kLastFast)
+{
+    /* Join to kUnroll */
+    int n = (int)srcSize;
+    int rem = n % kUnroll;
+    if (rem > 0) {
+        for (; rem > 0; --rem) {
+            HUF_encodeSymbol(bitC, ip[--n], ct, 0, /* fast */ 0);
+        }
+        HUF_flushBits(bitC, kFastFlush);
+    }
+    assert(n % kUnroll == 0);
+
+    /* Join to 2 * kUnroll */
+    if (n % (2 * kUnroll)) {
+        int u;
+        for (u = 1; u < kUnroll; ++u) {
+            HUF_encodeSymbol(bitC, ip[n - u], ct, 0, 1);
+        }
+        HUF_encodeSymbol(bitC, ip[n - kUnroll], ct, 0, kLastFast);
+        HUF_flushBits(bitC, kFastFlush);
+        n -= kUnroll;
+    }
+    assert(n % (2 * kUnroll) == 0);
+
+    for (; n>0; n-= 2 * kUnroll) {
+        /* Encode kUnroll symbols into the bitstream @ index 0. */
+        int u;
+        for (u = 1; u < kUnroll; ++u) {
+            HUF_encodeSymbol(bitC, ip[n - u], ct, /* idx */ 0, /* fast */ 1);
+        }
+        HUF_encodeSymbol(bitC, ip[n - kUnroll], ct, /* idx */ 0, /* fast */ kLastFast);
+        HUF_flushBits(bitC, kFastFlush);
+        /* Encode kUnroll symbols into the bitstream @ index 1.
+         * This allows us to start filling the bit container
+         * without any data dependencies.
+         */
+        HUF_zeroIndex1(bitC);
+        for (u = 1; u < kUnroll; ++u) {
+            HUF_encodeSymbol(bitC, ip[n - kUnroll - u], ct, /* idx */ 1, /* fast */ 1);
+        }
+        HUF_encodeSymbol(bitC, ip[n - kUnroll - kUnroll], ct, /* idx */ 1, /* fast */ kLastFast);
+        /* Merge bitstream @ index 1 into the bitstream @ index 0 */
+        HUF_mergeIndex1(bitC);
+        HUF_flushBits(bitC, kFastFlush);
+    }
+    assert(n == 0);
+
+}
+
+/**
+ * Returns a tight upper bound on the output space needed by Huffman
+ * with 8 bytes buffer to handle over-writes. If the output is at least
+ * this large we don't need to do bounds checks during Huffman encoding.
+ */
+static size_t HUF_tightCompressBound(size_t srcSize, size_t tableLog)
+{
+    return ((srcSize * tableLog) >> 3) + 8;
+}
+
+
+FORCE_INLINE_TEMPLATE size_t
+HUF_compress1X_usingCTable_internal_body(void* dst, size_t dstSize,
+                                   const void* src, size_t srcSize,
+                                   const HUF_CElt* CTable)
+{
+    U32 const tableLog = (U32)CTable[0];
+    HUF_CElt const* ct = CTable + 1;
+    const BYTE* ip = (const BYTE*) src;
+    BYTE* const ostart = (BYTE*)dst;
+    BYTE* const oend = ostart + dstSize;
+    BYTE* op = ostart;
+    HUF_CStream_t bitC;
+
+    /* init */
+    if (dstSize < 8) return 0;   /* not enough space to compress */
+    { size_t const initErr = HUF_initCStream(&bitC, op, (size_t)(oend-op));
+      if (HUF_isError(initErr)) return 0; }
+
+    if (dstSize < HUF_tightCompressBound(srcSize, (size_t)tableLog) || tableLog > 11)
+        HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct, /* kUnroll */ MEM_32bits() ? 2 : 4, /* kFast */ 0, /* kLastFast */ 0);
+    else {
+        if (MEM_32bits()) {
+            switch (tableLog) {
+            case 11:
+                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct, /* kUnroll */ 2, /* kFastFlush */ 1, /* kLastFast */ 0);
+                break;
+            case 10: ZSTD_FALLTHROUGH;
+            case 9: ZSTD_FALLTHROUGH;
+            case 8:
+                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct, /* kUnroll */ 2, /* kFastFlush */ 1, /* kLastFast */ 1);
+                break;
+            case 7: ZSTD_FALLTHROUGH;
+            default:
+                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct, /* kUnroll */ 3, /* kFastFlush */ 1, /* kLastFast */ 1);
+                break;
+            }
+        } else {
+            switch (tableLog) {
+            case 11:
+                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct, /* kUnroll */ 5, /* kFastFlush */ 1, /* kLastFast */ 0);
+                break;
+            case 10:
+                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct, /* kUnroll */ 5, /* kFastFlush */ 1, /* kLastFast */ 1);
+                break;
+            case 9:
+                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct, /* kUnroll */ 6, /* kFastFlush */ 1, /* kLastFast */ 0);
+                break;
+            case 8:
+                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct, /* kUnroll */ 7, /* kFastFlush */ 1, /* kLastFast */ 0);
+                break;
+            case 7:
+                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct, /* kUnroll */ 8, /* kFastFlush */ 1, /* kLastFast */ 0);
+                break;
+            case 6: ZSTD_FALLTHROUGH;
+            default:
+                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct, /* kUnroll */ 9, /* kFastFlush */ 1, /* kLastFast */ 1);
+                break;
+            }
+        }
+    }
+    assert(bitC.ptr <= bitC.endPtr);
+
+    return HUF_closeCStream(&bitC);
+}
+
+#if DYNAMIC_BMI2
+
+static BMI2_TARGET_ATTRIBUTE size_t
+HUF_compress1X_usingCTable_internal_bmi2(void* dst, size_t dstSize,
+                                   const void* src, size_t srcSize,
+                                   const HUF_CElt* CTable)
+{
+    return HUF_compress1X_usingCTable_internal_body(dst, dstSize, src, srcSize, CTable);
+}
+
+static size_t
+HUF_compress1X_usingCTable_internal_default(void* dst, size_t dstSize,
+                                      const void* src, size_t srcSize,
+                                      const HUF_CElt* CTable)
+{
+    return HUF_compress1X_usingCTable_internal_body(dst, dstSize, src, srcSize, CTable);
+}
+
+static size_t
+HUF_compress1X_usingCTable_internal(void* dst, size_t dstSize,
+                              const void* src, size_t srcSize,
+                              const HUF_CElt* CTable, const int flags)
+{
+    if (flags & HUF_flags_bmi2) {
+        return HUF_compress1X_usingCTable_internal_bmi2(dst, dstSize, src, srcSize, CTable);
+    }
+    return HUF_compress1X_usingCTable_internal_default(dst, dstSize, src, srcSize, CTable);
+}
+
+#else
+
+static size_t
+HUF_compress1X_usingCTable_internal(void* dst, size_t dstSize,
+                              const void* src, size_t srcSize,
+                              const HUF_CElt* CTable, const int flags)
+{
+    (void)flags;
+    return HUF_compress1X_usingCTable_internal_body(dst, dstSize, src, srcSize, CTable);
+}
+
+#endif
+
+size_t HUF_compress1X_usingCTable(void* dst, size_t dstSize, const void* src, size_t srcSize, const HUF_CElt* CTable, int flags)
+{
+    return HUF_compress1X_usingCTable_internal(dst, dstSize, src, srcSize, CTable, flags);
+}
+
+static size_t
+HUF_compress4X_usingCTable_internal(void* dst, size_t dstSize,
+                              const void* src, size_t srcSize,
+                              const HUF_CElt* CTable, int flags)
+{
+    size_t const segmentSize = (srcSize+3)/4;   /* first 3 segments */
+    const BYTE* ip = (const BYTE*) src;
+    const BYTE* const iend = ip + srcSize;
+    BYTE* const ostart = (BYTE*) dst;
+    BYTE* const oend = ostart + dstSize;
+    BYTE* op = ostart;
+
+    if (dstSize < 6 + 1 + 1 + 1 + 8) return 0;   /* minimum space to compress successfully */
+    if (srcSize < 12) return 0;   /* no saving possible : too small input */
+    op += 6;   /* jumpTable */
+
+    assert(op <= oend);
+    {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, segmentSize, CTable, flags) );
+        if (cSize == 0 || cSize > 65535) return 0;
+        MEM_writeLE16(ostart, (U16)cSize);
+        op += cSize;
+    }
+
+    ip += segmentSize;
+    assert(op <= oend);
+    {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, segmentSize, CTable, flags) );
+        if (cSize == 0 || cSize > 65535) return 0;
+        MEM_writeLE16(ostart+2, (U16)cSize);
+        op += cSize;
+    }
+
+    ip += segmentSize;
+    assert(op <= oend);
+    {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, segmentSize, CTable, flags) );
+        if (cSize == 0 || cSize > 65535) return 0;
+        MEM_writeLE16(ostart+4, (U16)cSize);
+        op += cSize;
+    }
+
+    ip += segmentSize;
+    assert(op <= oend);
+    assert(ip <= iend);
+    {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, (size_t)(iend-ip), CTable, flags) );
+        if (cSize == 0 || cSize > 65535) return 0;
+        op += cSize;
+    }
+
+    return (size_t)(op-ostart);
+}
+
+size_t HUF_compress4X_usingCTable(void* dst, size_t dstSize, const void* src, size_t srcSize, const HUF_CElt* CTable, int flags)
+{
+    return HUF_compress4X_usingCTable_internal(dst, dstSize, src, srcSize, CTable, flags);
+}
+
+typedef enum { HUF_singleStream, HUF_fourStreams } HUF_nbStreams_e;
+
+static size_t HUF_compressCTable_internal(
+                BYTE* const ostart, BYTE* op, BYTE* const oend,
+                const void* src, size_t srcSize,
+                HUF_nbStreams_e nbStreams, const HUF_CElt* CTable, const int flags)
+{
+    size_t const cSize = (nbStreams==HUF_singleStream) ?
+                         HUF_compress1X_usingCTable_internal(op, (size_t)(oend - op), src, srcSize, CTable, flags) :
+                         HUF_compress4X_usingCTable_internal(op, (size_t)(oend - op), src, srcSize, CTable, flags);
+    if (HUF_isError(cSize)) { return cSize; }
+    if (cSize==0) { return 0; }   /* uncompressible */
+    op += cSize;
+    /* check compressibility */
+    assert(op >= ostart);
+    if ((size_t)(op-ostart) >= srcSize-1) { return 0; }
+    return (size_t)(op-ostart);
+}
+
+typedef struct {
+    unsigned count[HUF_SYMBOLVALUE_MAX + 1];
+    HUF_CElt CTable[HUF_CTABLE_SIZE_ST(HUF_SYMBOLVALUE_MAX)];
+    union {
+        HUF_buildCTable_wksp_tables buildCTable_wksp;
+        HUF_WriteCTableWksp writeCTable_wksp;
+        U32 hist_wksp[HIST_WKSP_SIZE_U32];
+    } wksps;
+} HUF_compress_tables_t;
+
+#define SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE 4096
+#define SUSPECT_INCOMPRESSIBLE_SAMPLE_RATIO 10  /* Must be >= 2 */
+
+unsigned HUF_cardinality(const unsigned* count, unsigned maxSymbolValue)
+{
+    unsigned cardinality = 0;
+    unsigned i;
+
+    for (i = 0; i < maxSymbolValue + 1; i++) {
+        if (count[i] != 0) cardinality += 1;
+    }
+
+    return cardinality;
+}
+
+unsigned HUF_minTableLog(unsigned symbolCardinality)
+{
+    U32 minBitsSymbols = ZSTD_highbit32(symbolCardinality) + 1;
+    return minBitsSymbols;
+}
+
+unsigned HUF_optimalTableLog(
+            unsigned maxTableLog,
+            size_t srcSize,
+            unsigned maxSymbolValue,
+            void* workSpace, size_t wkspSize,
+            HUF_CElt* table,
+      const unsigned* count,
+            int flags)
+{
+    assert(srcSize > 1); /* Not supported, RLE should be used instead */
+    assert(wkspSize >= sizeof(HUF_buildCTable_wksp_tables));
+
+    if (!(flags & HUF_flags_optimalDepth)) {
+        /* cheap evaluation, based on FSE */
+        return FSE_optimalTableLog_internal(maxTableLog, srcSize, maxSymbolValue, 1);
+    }
+
+    {   BYTE* dst = (BYTE*)workSpace + sizeof(HUF_WriteCTableWksp);
+        size_t dstSize = wkspSize - sizeof(HUF_WriteCTableWksp);
+        size_t maxBits, hSize, newSize;
+        const unsigned symbolCardinality = HUF_cardinality(count, maxSymbolValue);
+        const unsigned minTableLog = HUF_minTableLog(symbolCardinality);
+        size_t optSize = ((size_t) ~0) - 1;
+        unsigned optLog = maxTableLog, optLogGuess;
+
+        DEBUGLOG(6, "HUF_optimalTableLog: probing huf depth (srcSize=%zu)", srcSize);
+
+        /* Search until size increases */
+        for (optLogGuess = minTableLog; optLogGuess <= maxTableLog; optLogGuess++) {
+            DEBUGLOG(7, "checking for huffLog=%u", optLogGuess);
+            maxBits = HUF_buildCTable_wksp(table, count, maxSymbolValue, optLogGuess, workSpace, wkspSize);
+            if (ERR_isError(maxBits)) continue;
+
+            if (maxBits < optLogGuess && optLogGuess > minTableLog) break;
+
+            hSize = HUF_writeCTable_wksp(dst, dstSize, table, maxSymbolValue, (U32)maxBits, workSpace, wkspSize);
+
+            if (ERR_isError(hSize)) continue;
+
+            newSize = HUF_estimateCompressedSize(table, count, maxSymbolValue) + hSize;
+
+            if (newSize > optSize + 1) {
+                break;
+            }
+
+            if (newSize < optSize) {
+                optSize = newSize;
+                optLog = optLogGuess;
+            }
+        }
+        assert(optLog <= HUF_TABLELOG_MAX);
+        return optLog;
+    }
+}
+
+/* HUF_compress_internal() :
+ * `workSpace_align4` must be aligned on 4-bytes boundaries,
+ * and occupies the same space as a table of HUF_WORKSPACE_SIZE_U64 unsigned */
+static size_t
+HUF_compress_internal (void* dst, size_t dstSize,
+                 const void* src, size_t srcSize,
+                       unsigned maxSymbolValue, unsigned huffLog,
+                       HUF_nbStreams_e nbStreams,
+                       void* workSpace, size_t wkspSize,
+                       HUF_CElt* oldHufTable, HUF_repeat* repeat, int flags)
+{
+    HUF_compress_tables_t* const table = (HUF_compress_tables_t*)HUF_alignUpWorkspace(workSpace, &wkspSize, ZSTD_ALIGNOF(size_t));
+    BYTE* const ostart = (BYTE*)dst;
+    BYTE* const oend = ostart + dstSize;
+    BYTE* op = ostart;
+
+    DEBUGLOG(5, "HUF_compress_internal (srcSize=%zu)", srcSize);
+    HUF_STATIC_ASSERT(sizeof(*table) + HUF_WORKSPACE_MAX_ALIGNMENT <= HUF_WORKSPACE_SIZE);
+
+    /* checks & inits */
+    if (wkspSize < sizeof(*table)) return ERROR(workSpace_tooSmall);
+    if (!srcSize) return 0;  /* Uncompressed */
+    if (!dstSize) return 0;  /* cannot fit anything within dst budget */
+    if (srcSize > HUF_BLOCKSIZE_MAX) return ERROR(srcSize_wrong);   /* current block size limit */
+    if (huffLog > HUF_TABLELOG_MAX) return ERROR(tableLog_tooLarge);
+    if (maxSymbolValue > HUF_SYMBOLVALUE_MAX) return ERROR(maxSymbolValue_tooLarge);
+    if (!maxSymbolValue) maxSymbolValue = HUF_SYMBOLVALUE_MAX;
+    if (!huffLog) huffLog = HUF_TABLELOG_DEFAULT;
+
+    /* Heuristic : If old table is valid, use it for small inputs */
+    if ((flags & HUF_flags_preferRepeat) && repeat && *repeat == HUF_repeat_valid) {
+        return HUF_compressCTable_internal(ostart, op, oend,
+                                           src, srcSize,
+                                           nbStreams, oldHufTable, flags);
+    }
+
+    /* If uncompressible data is suspected, do a smaller sampling first */
+    DEBUG_STATIC_ASSERT(SUSPECT_INCOMPRESSIBLE_SAMPLE_RATIO >= 2);
+    if ((flags & HUF_flags_suspectUncompressible) && srcSize >= (SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE * SUSPECT_INCOMPRESSIBLE_SAMPLE_RATIO)) {
+        size_t largestTotal = 0;
+        DEBUGLOG(5, "input suspected incompressible : sampling to check");
+        {   unsigned maxSymbolValueBegin = maxSymbolValue;
+            CHECK_V_F(largestBegin, HIST_count_simple (table->count, &maxSymbolValueBegin, (const BYTE*)src, SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE) );
+            largestTotal += largestBegin;
+        }
+        {   unsigned maxSymbolValueEnd = maxSymbolValue;
+            CHECK_V_F(largestEnd, HIST_count_simple (table->count, &maxSymbolValueEnd, (const BYTE*)src + srcSize - SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE, SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE) );
+            largestTotal += largestEnd;
+        }
+        if (largestTotal <= ((2 * SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE) >> 7)+4) return 0;   /* heuristic : probably not compressible enough */
+    }
+
+    /* Scan input and build symbol stats */
+    {   CHECK_V_F(largest, HIST_count_wksp (table->count, &maxSymbolValue, (const BYTE*)src, srcSize, table->wksps.hist_wksp, sizeof(table->wksps.hist_wksp)) );
+        if (largest == srcSize) { *ostart = ((const BYTE*)src)[0]; return 1; }   /* single symbol, rle */
+        if (largest <= (srcSize >> 7)+4) return 0;   /* heuristic : probably not compressible enough */
+    }
+    DEBUGLOG(6, "histogram detail completed (%zu symbols)", showU32(table->count, maxSymbolValue+1));
+
+    /* Check validity of previous table */
+    if ( repeat
+      && *repeat == HUF_repeat_check
+      && !HUF_validateCTable(oldHufTable, table->count, maxSymbolValue)) {
+        *repeat = HUF_repeat_none;
+    }
+    /* Heuristic : use existing table for small inputs */
+    if ((flags & HUF_flags_preferRepeat) && repeat && *repeat != HUF_repeat_none) {
+        return HUF_compressCTable_internal(ostart, op, oend,
+                                           src, srcSize,
+                                           nbStreams, oldHufTable, flags);
+    }
+
+    /* Build Huffman Tree */
+    huffLog = HUF_optimalTableLog(huffLog, srcSize, maxSymbolValue, &table->wksps, sizeof(table->wksps), table->CTable, table->count, flags);
+    {   size_t const maxBits = HUF_buildCTable_wksp(table->CTable, table->count,
+                                            maxSymbolValue, huffLog,
+                                            &table->wksps.buildCTable_wksp, sizeof(table->wksps.buildCTable_wksp));
+        CHECK_F(maxBits);
+        huffLog = (U32)maxBits;
+        DEBUGLOG(6, "bit distribution completed (%zu symbols)", showCTableBits(table->CTable + 1, maxSymbolValue+1));
+    }
+    /* Zero unused symbols in CTable, so we can check it for validity */
+    {
+        size_t const ctableSize = HUF_CTABLE_SIZE_ST(maxSymbolValue);
+        size_t const unusedSize = sizeof(table->CTable) - ctableSize * sizeof(HUF_CElt);
+        ZSTD_memset(table->CTable + ctableSize, 0, unusedSize);
+    }
+
+    /* Write table description header */
+    {   CHECK_V_F(hSize, HUF_writeCTable_wksp(op, dstSize, table->CTable, maxSymbolValue, huffLog,
+                                              &table->wksps.writeCTable_wksp, sizeof(table->wksps.writeCTable_wksp)) );
+        /* Check if using previous huffman table is beneficial */
+        if (repeat && *repeat != HUF_repeat_none) {
+            size_t const oldSize = HUF_estimateCompressedSize(oldHufTable, table->count, maxSymbolValue);
+            size_t const newSize = HUF_estimateCompressedSize(table->CTable, table->count, maxSymbolValue);
+            if (oldSize <= hSize + newSize || hSize + 12 >= srcSize) {
+                return HUF_compressCTable_internal(ostart, op, oend,
+                                                   src, srcSize,
+                                                   nbStreams, oldHufTable, flags);
+        }   }
+
+        /* Use the new huffman table */
+        if (hSize + 12ul >= srcSize) { return 0; }
+        op += hSize;
+        if (repeat) { *repeat = HUF_repeat_none; }
+        if (oldHufTable)
+            ZSTD_memcpy(oldHufTable, table->CTable, sizeof(table->CTable));  /* Save new table */
+    }
+    return HUF_compressCTable_internal(ostart, op, oend,
+                                       src, srcSize,
+                                       nbStreams, table->CTable, flags);
+}
+
+size_t HUF_compress1X_repeat (void* dst, size_t dstSize,
+                      const void* src, size_t srcSize,
+                      unsigned maxSymbolValue, unsigned huffLog,
+                      void* workSpace, size_t wkspSize,
+                      HUF_CElt* hufTable, HUF_repeat* repeat, int flags)
+{
+    DEBUGLOG(5, "HUF_compress1X_repeat (srcSize = %zu)", srcSize);
+    return HUF_compress_internal(dst, dstSize, src, srcSize,
+                                 maxSymbolValue, huffLog, HUF_singleStream,
+                                 workSpace, wkspSize, hufTable,
+                                 repeat, flags);
+}
+
+/* HUF_compress4X_repeat():
+ * compress input using 4 streams.
+ * consider skipping quickly
+ * re-use an existing huffman compression table */
+size_t HUF_compress4X_repeat (void* dst, size_t dstSize,
+                      const void* src, size_t srcSize,
+                      unsigned maxSymbolValue, unsigned huffLog,
+                      void* workSpace, size_t wkspSize,
+                      HUF_CElt* hufTable, HUF_repeat* repeat, int flags)
+{
+    DEBUGLOG(5, "HUF_compress4X_repeat (srcSize = %zu)", srcSize);
+    return HUF_compress_internal(dst, dstSize, src, srcSize,
+                                 maxSymbolValue, huffLog, HUF_fourStreams,
+                                 workSpace, wkspSize,
+                                 hufTable, repeat, flags);
+}
diff --git a/src/3rdparty/zstd/src/compress/zstd_compress.c b/src/3rdparty/zstd/src/compress/zstd_compress.c
new file mode 100644
index 0000000000..d6133e70b4
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_compress.c
@@ -0,0 +1,7032 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+/*-*************************************
+*  Dependencies
+***************************************/
+#include "../common/allocations.h"  /* ZSTD_customMalloc, ZSTD_customCalloc, ZSTD_customFree */
+#include "../common/zstd_deps.h"  /* INT_MAX, ZSTD_memset, ZSTD_memcpy */
+#include "../common/mem.h"
+#include "hist.h"           /* HIST_countFast_wksp */
+#define FSE_STATIC_LINKING_ONLY   /* FSE_encodeSymbol */
+#include "../common/fse.h"
+#include "../common/huf.h"
+#include "zstd_compress_internal.h"
+#include "zstd_compress_sequences.h"
+#include "zstd_compress_literals.h"
+#include "zstd_fast.h"
+#include "zstd_double_fast.h"
+#include "zstd_lazy.h"
+#include "zstd_opt.h"
+#include "zstd_ldm.h"
+#include "zstd_compress_superblock.h"
+#include  "../common/bits.h"      /* ZSTD_highbit32, ZSTD_rotateRight_U64 */
+
+/* ***************************************************************
+*  Tuning parameters
+*****************************************************************/
+/*!
+ * COMPRESS_HEAPMODE :
+ * Select how default decompression function ZSTD_compress() allocates its context,
+ * on stack (0, default), or into heap (1).
+ * Note that functions with explicit context such as ZSTD_compressCCtx() are unaffected.
+ */
+#ifndef ZSTD_COMPRESS_HEAPMODE
+#  define ZSTD_COMPRESS_HEAPMODE 0
+#endif
+
+/*!
+ * ZSTD_HASHLOG3_MAX :
+ * Maximum size of the hash table dedicated to find 3-bytes matches,
+ * in log format, aka 17 => 1 << 17 == 128Ki positions.
+ * This structure is only used in zstd_opt.
+ * Since allocation is centralized for all strategies, it has to be known here.
+ * The actual (selected) size of the hash table is then stored in ZSTD_matchState_t.hashLog3,
+ * so that zstd_opt.c doesn't need to know about this constant.
+ */
+#ifndef ZSTD_HASHLOG3_MAX
+#  define ZSTD_HASHLOG3_MAX 17
+#endif
+
+/*-*************************************
+*  Helper functions
+***************************************/
+/* ZSTD_compressBound()
+ * Note that the result from this function is only valid for
+ * the one-pass compression functions.
+ * When employing the streaming mode,
+ * if flushes are frequently altering the size of blocks,
+ * the overhead from block headers can make the compressed data larger
+ * than the return value of ZSTD_compressBound().
+ */
+size_t ZSTD_compressBound(size_t srcSize) {
+    size_t const r = ZSTD_COMPRESSBOUND(srcSize);
+    if (r==0) return ERROR(srcSize_wrong);
+    return r;
+}
+
+
+/*-*************************************
+*  Context memory management
+***************************************/
+struct ZSTD_CDict_s {
+    const void* dictContent;
+    size_t dictContentSize;
+    ZSTD_dictContentType_e dictContentType; /* The dictContentType the CDict was created with */
+    U32* entropyWorkspace; /* entropy workspace of HUF_WORKSPACE_SIZE bytes */
+    ZSTD_cwksp workspace;
+    ZSTD_matchState_t matchState;
+    ZSTD_compressedBlockState_t cBlockState;
+    ZSTD_customMem customMem;
+    U32 dictID;
+    int compressionLevel; /* 0 indicates that advanced API was used to select CDict params */
+    ZSTD_paramSwitch_e useRowMatchFinder; /* Indicates whether the CDict was created with params that would use
+                                           * row-based matchfinder. Unless the cdict is reloaded, we will use
+                                           * the same greedy/lazy matchfinder at compression time.
+                                           */
+};  /* typedef'd to ZSTD_CDict within "zstd.h" */
+
+ZSTD_CCtx* ZSTD_createCCtx(void)
+{
+    return ZSTD_createCCtx_advanced(ZSTD_defaultCMem);
+}
+
+static void ZSTD_initCCtx(ZSTD_CCtx* cctx, ZSTD_customMem memManager)
+{
+    assert(cctx != NULL);
+    ZSTD_memset(cctx, 0, sizeof(*cctx));
+    cctx->customMem = memManager;
+    cctx->bmi2 = ZSTD_cpuSupportsBmi2();
+    {   size_t const err = ZSTD_CCtx_reset(cctx, ZSTD_reset_parameters);
+        assert(!ZSTD_isError(err));
+        (void)err;
+    }
+}
+
+ZSTD_CCtx* ZSTD_createCCtx_advanced(ZSTD_customMem customMem)
+{
+    ZSTD_STATIC_ASSERT(zcss_init==0);
+    ZSTD_STATIC_ASSERT(ZSTD_CONTENTSIZE_UNKNOWN==(0ULL - 1));
+    if ((!customMem.customAlloc) ^ (!customMem.customFree)) return NULL;
+    {   ZSTD_CCtx* const cctx = (ZSTD_CCtx*)ZSTD_customMalloc(sizeof(ZSTD_CCtx), customMem);
+        if (!cctx) return NULL;
+        ZSTD_initCCtx(cctx, customMem);
+        return cctx;
+    }
+}
+
+ZSTD_CCtx* ZSTD_initStaticCCtx(void* workspace, size_t workspaceSize)
+{
+    ZSTD_cwksp ws;
+    ZSTD_CCtx* cctx;
+    if (workspaceSize <= sizeof(ZSTD_CCtx)) return NULL;  /* minimum size */
+    if ((size_t)workspace & 7) return NULL;  /* must be 8-aligned */
+    ZSTD_cwksp_init(&ws, workspace, workspaceSize, ZSTD_cwksp_static_alloc);
+
+    cctx = (ZSTD_CCtx*)ZSTD_cwksp_reserve_object(&ws, sizeof(ZSTD_CCtx));
+    if (cctx == NULL) return NULL;
+
+    ZSTD_memset(cctx, 0, sizeof(ZSTD_CCtx));
+    ZSTD_cwksp_move(&cctx->workspace, &ws);
+    cctx->staticSize = workspaceSize;
+
+    /* statically sized space. entropyWorkspace never moves (but prev/next block swap places) */
+    if (!ZSTD_cwksp_check_available(&cctx->workspace, ENTROPY_WORKSPACE_SIZE + 2 * sizeof(ZSTD_compressedBlockState_t))) return NULL;
+    cctx->blockState.prevCBlock = (ZSTD_compressedBlockState_t*)ZSTD_cwksp_reserve_object(&cctx->workspace, sizeof(ZSTD_compressedBlockState_t));
+    cctx->blockState.nextCBlock = (ZSTD_compressedBlockState_t*)ZSTD_cwksp_reserve_object(&cctx->workspace, sizeof(ZSTD_compressedBlockState_t));
+    cctx->entropyWorkspace = (U32*)ZSTD_cwksp_reserve_object(&cctx->workspace, ENTROPY_WORKSPACE_SIZE);
+    cctx->bmi2 = ZSTD_cpuid_bmi2(ZSTD_cpuid());
+    return cctx;
+}
+
+/**
+ * Clears and frees all of the dictionaries in the CCtx.
+ */
+static void ZSTD_clearAllDicts(ZSTD_CCtx* cctx)
+{
+    ZSTD_customFree(cctx->localDict.dictBuffer, cctx->customMem);
+    ZSTD_freeCDict(cctx->localDict.cdict);
+    ZSTD_memset(&cctx->localDict, 0, sizeof(cctx->localDict));
+    ZSTD_memset(&cctx->prefixDict, 0, sizeof(cctx->prefixDict));
+    cctx->cdict = NULL;
+}
+
+static size_t ZSTD_sizeof_localDict(ZSTD_localDict dict)
+{
+    size_t const bufferSize = dict.dictBuffer != NULL ? dict.dictSize : 0;
+    size_t const cdictSize = ZSTD_sizeof_CDict(dict.cdict);
+    return bufferSize + cdictSize;
+}
+
+static void ZSTD_freeCCtxContent(ZSTD_CCtx* cctx)
+{
+    assert(cctx != NULL);
+    assert(cctx->staticSize == 0);
+    ZSTD_clearAllDicts(cctx);
+#ifdef ZSTD_MULTITHREAD
+    ZSTDMT_freeCCtx(cctx->mtctx); cctx->mtctx = NULL;
+#endif
+    ZSTD_cwksp_free(&cctx->workspace, cctx->customMem);
+}
+
+size_t ZSTD_freeCCtx(ZSTD_CCtx* cctx)
+{
+    if (cctx==NULL) return 0;   /* support free on NULL */
+    RETURN_ERROR_IF(cctx->staticSize, memory_allocation,
+                    "not compatible with static CCtx");
+    {   int cctxInWorkspace = ZSTD_cwksp_owns_buffer(&cctx->workspace, cctx);
+        ZSTD_freeCCtxContent(cctx);
+        if (!cctxInWorkspace) ZSTD_customFree(cctx, cctx->customMem);
+    }
+    return 0;
+}
+
+
+static size_t ZSTD_sizeof_mtctx(const ZSTD_CCtx* cctx)
+{
+#ifdef ZSTD_MULTITHREAD
+    return ZSTDMT_sizeof_CCtx(cctx->mtctx);
+#else
+    (void)cctx;
+    return 0;
+#endif
+}
+
+
+size_t ZSTD_sizeof_CCtx(const ZSTD_CCtx* cctx)
+{
+    if (cctx==NULL) return 0;   /* support sizeof on NULL */
+    /* cctx may be in the workspace */
+    return (cctx->workspace.workspace == cctx ? 0 : sizeof(*cctx))
+           + ZSTD_cwksp_sizeof(&cctx->workspace)
+           + ZSTD_sizeof_localDict(cctx->localDict)
+           + ZSTD_sizeof_mtctx(cctx);
+}
+
+size_t ZSTD_sizeof_CStream(const ZSTD_CStream* zcs)
+{
+    return ZSTD_sizeof_CCtx(zcs);  /* same object */
+}
+
+/* private API call, for dictBuilder only */
+const seqStore_t* ZSTD_getSeqStore(const ZSTD_CCtx* ctx) { return &(ctx->seqStore); }
+
+/* Returns true if the strategy supports using a row based matchfinder */
+static int ZSTD_rowMatchFinderSupported(const ZSTD_strategy strategy) {
+    return (strategy >= ZSTD_greedy && strategy <= ZSTD_lazy2);
+}
+
+/* Returns true if the strategy and useRowMatchFinder mode indicate that we will use the row based matchfinder
+ * for this compression.
+ */
+static int ZSTD_rowMatchFinderUsed(const ZSTD_strategy strategy, const ZSTD_paramSwitch_e mode) {
+    assert(mode != ZSTD_ps_auto);
+    return ZSTD_rowMatchFinderSupported(strategy) && (mode == ZSTD_ps_enable);
+}
+
+/* Returns row matchfinder usage given an initial mode and cParams */
+static ZSTD_paramSwitch_e ZSTD_resolveRowMatchFinderMode(ZSTD_paramSwitch_e mode,
+                                                         const ZSTD_compressionParameters* const cParams) {
+#if defined(ZSTD_ARCH_X86_SSE2) || defined(ZSTD_ARCH_ARM_NEON)
+    int const kHasSIMD128 = 1;
+#else
+    int const kHasSIMD128 = 0;
+#endif
+    if (mode != ZSTD_ps_auto) return mode; /* if requested enabled, but no SIMD, we still will use row matchfinder */
+    mode = ZSTD_ps_disable;
+    if (!ZSTD_rowMatchFinderSupported(cParams->strategy)) return mode;
+    if (kHasSIMD128) {
+        if (cParams->windowLog > 14) mode = ZSTD_ps_enable;
+    } else {
+        if (cParams->windowLog > 17) mode = ZSTD_ps_enable;
+    }
+    return mode;
+}
+
+/* Returns block splitter usage (generally speaking, when using slower/stronger compression modes) */
+static ZSTD_paramSwitch_e ZSTD_resolveBlockSplitterMode(ZSTD_paramSwitch_e mode,
+                                                        const ZSTD_compressionParameters* const cParams) {
+    if (mode != ZSTD_ps_auto) return mode;
+    return (cParams->strategy >= ZSTD_btopt && cParams->windowLog >= 17) ? ZSTD_ps_enable : ZSTD_ps_disable;
+}
+
+/* Returns 1 if the arguments indicate that we should allocate a chainTable, 0 otherwise */
+static int ZSTD_allocateChainTable(const ZSTD_strategy strategy,
+                                   const ZSTD_paramSwitch_e useRowMatchFinder,
+                                   const U32 forDDSDict) {
+    assert(useRowMatchFinder != ZSTD_ps_auto);
+    /* We always should allocate a chaintable if we are allocating a matchstate for a DDS dictionary matchstate.
+     * We do not allocate a chaintable if we are using ZSTD_fast, or are using the row-based matchfinder.
+     */
+    return forDDSDict || ((strategy != ZSTD_fast) && !ZSTD_rowMatchFinderUsed(strategy, useRowMatchFinder));
+}
+
+/* Returns ZSTD_ps_enable if compression parameters are such that we should
+ * enable long distance matching (wlog >= 27, strategy >= btopt).
+ * Returns ZSTD_ps_disable otherwise.
+ */
+static ZSTD_paramSwitch_e ZSTD_resolveEnableLdm(ZSTD_paramSwitch_e mode,
+                                 const ZSTD_compressionParameters* const cParams) {
+    if (mode != ZSTD_ps_auto) return mode;
+    return (cParams->strategy >= ZSTD_btopt && cParams->windowLog >= 27) ? ZSTD_ps_enable : ZSTD_ps_disable;
+}
+
+static int ZSTD_resolveExternalSequenceValidation(int mode) {
+    return mode;
+}
+
+/* Resolves maxBlockSize to the default if no value is present. */
+static size_t ZSTD_resolveMaxBlockSize(size_t maxBlockSize) {
+    if (maxBlockSize == 0) {
+        return ZSTD_BLOCKSIZE_MAX;
+    } else {
+        return maxBlockSize;
+    }
+}
+
+static ZSTD_paramSwitch_e ZSTD_resolveExternalRepcodeSearch(ZSTD_paramSwitch_e value, int cLevel) {
+    if (value != ZSTD_ps_auto) return value;
+    if (cLevel < 10) {
+        return ZSTD_ps_disable;
+    } else {
+        return ZSTD_ps_enable;
+    }
+}
+
+/* Returns 1 if compression parameters are such that CDict hashtable and chaintable indices are tagged.
+ * If so, the tags need to be removed in ZSTD_resetCCtx_byCopyingCDict. */
+static int ZSTD_CDictIndicesAreTagged(const ZSTD_compressionParameters* const cParams) {
+    return cParams->strategy == ZSTD_fast || cParams->strategy == ZSTD_dfast;
+}
+
+static ZSTD_CCtx_params ZSTD_makeCCtxParamsFromCParams(
+        ZSTD_compressionParameters cParams)
+{
+    ZSTD_CCtx_params cctxParams;
+    /* should not matter, as all cParams are presumed properly defined */
+    ZSTD_CCtxParams_init(&cctxParams, ZSTD_CLEVEL_DEFAULT);
+    cctxParams.cParams = cParams;
+
+    /* Adjust advanced params according to cParams */
+    cctxParams.ldmParams.enableLdm = ZSTD_resolveEnableLdm(cctxParams.ldmParams.enableLdm, &cParams);
+    if (cctxParams.ldmParams.enableLdm == ZSTD_ps_enable) {
+        ZSTD_ldm_adjustParameters(&cctxParams.ldmParams, &cParams);
+        assert(cctxParams.ldmParams.hashLog >= cctxParams.ldmParams.bucketSizeLog);
+        assert(cctxParams.ldmParams.hashRateLog < 32);
+    }
+    cctxParams.useBlockSplitter = ZSTD_resolveBlockSplitterMode(cctxParams.useBlockSplitter, &cParams);
+    cctxParams.useRowMatchFinder = ZSTD_resolveRowMatchFinderMode(cctxParams.useRowMatchFinder, &cParams);
+    cctxParams.validateSequences = ZSTD_resolveExternalSequenceValidation(cctxParams.validateSequences);
+    cctxParams.maxBlockSize = ZSTD_resolveMaxBlockSize(cctxParams.maxBlockSize);
+    cctxParams.searchForExternalRepcodes = ZSTD_resolveExternalRepcodeSearch(cctxParams.searchForExternalRepcodes,
+                                                                             cctxParams.compressionLevel);
+    assert(!ZSTD_checkCParams(cParams));
+    return cctxParams;
+}
+
+static ZSTD_CCtx_params* ZSTD_createCCtxParams_advanced(
+        ZSTD_customMem customMem)
+{
+    ZSTD_CCtx_params* params;
+    if ((!customMem.customAlloc) ^ (!customMem.customFree)) return NULL;
+    params = (ZSTD_CCtx_params*)ZSTD_customCalloc(
+            sizeof(ZSTD_CCtx_params), customMem);
+    if (!params) { return NULL; }
+    ZSTD_CCtxParams_init(params, ZSTD_CLEVEL_DEFAULT);
+    params->customMem = customMem;
+    return params;
+}
+
+ZSTD_CCtx_params* ZSTD_createCCtxParams(void)
+{
+    return ZSTD_createCCtxParams_advanced(ZSTD_defaultCMem);
+}
+
+size_t ZSTD_freeCCtxParams(ZSTD_CCtx_params* params)
+{
+    if (params == NULL) { return 0; }
+    ZSTD_customFree(params, params->customMem);
+    return 0;
+}
+
+size_t ZSTD_CCtxParams_reset(ZSTD_CCtx_params* params)
+{
+    return ZSTD_CCtxParams_init(params, ZSTD_CLEVEL_DEFAULT);
+}
+
+size_t ZSTD_CCtxParams_init(ZSTD_CCtx_params* cctxParams, int compressionLevel) {
+    RETURN_ERROR_IF(!cctxParams, GENERIC, "NULL pointer!");
+    ZSTD_memset(cctxParams, 0, sizeof(*cctxParams));
+    cctxParams->compressionLevel = compressionLevel;
+    cctxParams->fParams.contentSizeFlag = 1;
+    return 0;
+}
+
+#define ZSTD_NO_CLEVEL 0
+
+/**
+ * Initializes `cctxParams` from `params` and `compressionLevel`.
+ * @param compressionLevel If params are derived from a compression level then that compression level, otherwise ZSTD_NO_CLEVEL.
+ */
+static void
+ZSTD_CCtxParams_init_internal(ZSTD_CCtx_params* cctxParams,
+                        const ZSTD_parameters* params,
+                              int compressionLevel)
+{
+    assert(!ZSTD_checkCParams(params->cParams));
+    ZSTD_memset(cctxParams, 0, sizeof(*cctxParams));
+    cctxParams->cParams = params->cParams;
+    cctxParams->fParams = params->fParams;
+    /* Should not matter, as all cParams are presumed properly defined.
+     * But, set it for tracing anyway.
+     */
+    cctxParams->compressionLevel = compressionLevel;
+    cctxParams->useRowMatchFinder = ZSTD_resolveRowMatchFinderMode(cctxParams->useRowMatchFinder, &params->cParams);
+    cctxParams->useBlockSplitter = ZSTD_resolveBlockSplitterMode(cctxParams->useBlockSplitter, &params->cParams);
+    cctxParams->ldmParams.enableLdm = ZSTD_resolveEnableLdm(cctxParams->ldmParams.enableLdm, &params->cParams);
+    cctxParams->validateSequences = ZSTD_resolveExternalSequenceValidation(cctxParams->validateSequences);
+    cctxParams->maxBlockSize = ZSTD_resolveMaxBlockSize(cctxParams->maxBlockSize);
+    cctxParams->searchForExternalRepcodes = ZSTD_resolveExternalRepcodeSearch(cctxParams->searchForExternalRepcodes, compressionLevel);
+    DEBUGLOG(4, "ZSTD_CCtxParams_init_internal: useRowMatchFinder=%d, useBlockSplitter=%d ldm=%d",
+                cctxParams->useRowMatchFinder, cctxParams->useBlockSplitter, cctxParams->ldmParams.enableLdm);
+}
+
+size_t ZSTD_CCtxParams_init_advanced(ZSTD_CCtx_params* cctxParams, ZSTD_parameters params)
+{
+    RETURN_ERROR_IF(!cctxParams, GENERIC, "NULL pointer!");
+    FORWARD_IF_ERROR( ZSTD_checkCParams(params.cParams) , "");
+    ZSTD_CCtxParams_init_internal(cctxParams, &params, ZSTD_NO_CLEVEL);
+    return 0;
+}
+
+/**
+ * Sets cctxParams' cParams and fParams from params, but otherwise leaves them alone.
+ * @param params Validated zstd parameters.
+ */
+static void ZSTD_CCtxParams_setZstdParams(
+        ZSTD_CCtx_params* cctxParams, const ZSTD_parameters* params)
+{
+    assert(!ZSTD_checkCParams(params->cParams));
+    cctxParams->cParams = params->cParams;
+    cctxParams->fParams = params->fParams;
+    /* Should not matter, as all cParams are presumed properly defined.
+     * But, set it for tracing anyway.
+     */
+    cctxParams->compressionLevel = ZSTD_NO_CLEVEL;
+}
+
+ZSTD_bounds ZSTD_cParam_getBounds(ZSTD_cParameter param)
+{
+    ZSTD_bounds bounds = { 0, 0, 0 };
+
+    switch(param)
+    {
+    case ZSTD_c_compressionLevel:
+        bounds.lowerBound = ZSTD_minCLevel();
+        bounds.upperBound = ZSTD_maxCLevel();
+        return bounds;
+
+    case ZSTD_c_windowLog:
+        bounds.lowerBound = ZSTD_WINDOWLOG_MIN;
+        bounds.upperBound = ZSTD_WINDOWLOG_MAX;
+        return bounds;
+
+    case ZSTD_c_hashLog:
+        bounds.lowerBound = ZSTD_HASHLOG_MIN;
+        bounds.upperBound = ZSTD_HASHLOG_MAX;
+        return bounds;
+
+    case ZSTD_c_chainLog:
+        bounds.lowerBound = ZSTD_CHAINLOG_MIN;
+        bounds.upperBound = ZSTD_CHAINLOG_MAX;
+        return bounds;
+
+    case ZSTD_c_searchLog:
+        bounds.lowerBound = ZSTD_SEARCHLOG_MIN;
+        bounds.upperBound = ZSTD_SEARCHLOG_MAX;
+        return bounds;
+
+    case ZSTD_c_minMatch:
+        bounds.lowerBound = ZSTD_MINMATCH_MIN;
+        bounds.upperBound = ZSTD_MINMATCH_MAX;
+        return bounds;
+
+    case ZSTD_c_targetLength:
+        bounds.lowerBound = ZSTD_TARGETLENGTH_MIN;
+        bounds.upperBound = ZSTD_TARGETLENGTH_MAX;
+        return bounds;
+
+    case ZSTD_c_strategy:
+        bounds.lowerBound = ZSTD_STRATEGY_MIN;
+        bounds.upperBound = ZSTD_STRATEGY_MAX;
+        return bounds;
+
+    case ZSTD_c_contentSizeFlag:
+        bounds.lowerBound = 0;
+        bounds.upperBound = 1;
+        return bounds;
+
+    case ZSTD_c_checksumFlag:
+        bounds.lowerBound = 0;
+        bounds.upperBound = 1;
+        return bounds;
+
+    case ZSTD_c_dictIDFlag:
+        bounds.lowerBound = 0;
+        bounds.upperBound = 1;
+        return bounds;
+
+    case ZSTD_c_nbWorkers:
+        bounds.lowerBound = 0;
+#ifdef ZSTD_MULTITHREAD
+        bounds.upperBound = ZSTDMT_NBWORKERS_MAX;
+#else
+        bounds.upperBound = 0;
+#endif
+        return bounds;
+
+    case ZSTD_c_jobSize:
+        bounds.lowerBound = 0;
+#ifdef ZSTD_MULTITHREAD
+        bounds.upperBound = ZSTDMT_JOBSIZE_MAX;
+#else
+        bounds.upperBound = 0;
+#endif
+        return bounds;
+
+    case ZSTD_c_overlapLog:
+#ifdef ZSTD_MULTITHREAD
+        bounds.lowerBound = ZSTD_OVERLAPLOG_MIN;
+        bounds.upperBound = ZSTD_OVERLAPLOG_MAX;
+#else
+        bounds.lowerBound = 0;
+        bounds.upperBound = 0;
+#endif
+        return bounds;
+
+    case ZSTD_c_enableDedicatedDictSearch:
+        bounds.lowerBound = 0;
+        bounds.upperBound = 1;
+        return bounds;
+
+    case ZSTD_c_enableLongDistanceMatching:
+        bounds.lowerBound = (int)ZSTD_ps_auto;
+        bounds.upperBound = (int)ZSTD_ps_disable;
+        return bounds;
+
+    case ZSTD_c_ldmHashLog:
+        bounds.lowerBound = ZSTD_LDM_HASHLOG_MIN;
+        bounds.upperBound = ZSTD_LDM_HASHLOG_MAX;
+        return bounds;
+
+    case ZSTD_c_ldmMinMatch:
+        bounds.lowerBound = ZSTD_LDM_MINMATCH_MIN;
+        bounds.upperBound = ZSTD_LDM_MINMATCH_MAX;
+        return bounds;
+
+    case ZSTD_c_ldmBucketSizeLog:
+        bounds.lowerBound = ZSTD_LDM_BUCKETSIZELOG_MIN;
+        bounds.upperBound = ZSTD_LDM_BUCKETSIZELOG_MAX;
+        return bounds;
+
+    case ZSTD_c_ldmHashRateLog:
+        bounds.lowerBound = ZSTD_LDM_HASHRATELOG_MIN;
+        bounds.upperBound = ZSTD_LDM_HASHRATELOG_MAX;
+        return bounds;
+
+    /* experimental parameters */
+    case ZSTD_c_rsyncable:
+        bounds.lowerBound = 0;
+        bounds.upperBound = 1;
+        return bounds;
+
+    case ZSTD_c_forceMaxWindow :
+        bounds.lowerBound = 0;
+        bounds.upperBound = 1;
+        return bounds;
+
+    case ZSTD_c_format:
+        ZSTD_STATIC_ASSERT(ZSTD_f_zstd1 < ZSTD_f_zstd1_magicless);
+        bounds.lowerBound = ZSTD_f_zstd1;
+        bounds.upperBound = ZSTD_f_zstd1_magicless;   /* note : how to ensure at compile time that this is the highest value enum ? */
+        return bounds;
+
+    case ZSTD_c_forceAttachDict:
+        ZSTD_STATIC_ASSERT(ZSTD_dictDefaultAttach < ZSTD_dictForceLoad);
+        bounds.lowerBound = ZSTD_dictDefaultAttach;
+        bounds.upperBound = ZSTD_dictForceLoad;       /* note : how to ensure at compile time that this is the highest value enum ? */
+        return bounds;
+
+    case ZSTD_c_literalCompressionMode:
+        ZSTD_STATIC_ASSERT(ZSTD_ps_auto < ZSTD_ps_enable && ZSTD_ps_enable < ZSTD_ps_disable);
+        bounds.lowerBound = (int)ZSTD_ps_auto;
+        bounds.upperBound = (int)ZSTD_ps_disable;
+        return bounds;
+
+    case ZSTD_c_targetCBlockSize:
+        bounds.lowerBound = ZSTD_TARGETCBLOCKSIZE_MIN;
+        bounds.upperBound = ZSTD_TARGETCBLOCKSIZE_MAX;
+        return bounds;
+
+    case ZSTD_c_srcSizeHint:
+        bounds.lowerBound = ZSTD_SRCSIZEHINT_MIN;
+        bounds.upperBound = ZSTD_SRCSIZEHINT_MAX;
+        return bounds;
+
+    case ZSTD_c_stableInBuffer:
+    case ZSTD_c_stableOutBuffer:
+        bounds.lowerBound = (int)ZSTD_bm_buffered;
+        bounds.upperBound = (int)ZSTD_bm_stable;
+        return bounds;
+
+    case ZSTD_c_blockDelimiters:
+        bounds.lowerBound = (int)ZSTD_sf_noBlockDelimiters;
+        bounds.upperBound = (int)ZSTD_sf_explicitBlockDelimiters;
+        return bounds;
+
+    case ZSTD_c_validateSequences:
+        bounds.lowerBound = 0;
+        bounds.upperBound = 1;
+        return bounds;
+
+    case ZSTD_c_useBlockSplitter:
+        bounds.lowerBound = (int)ZSTD_ps_auto;
+        bounds.upperBound = (int)ZSTD_ps_disable;
+        return bounds;
+
+    case ZSTD_c_useRowMatchFinder:
+        bounds.lowerBound = (int)ZSTD_ps_auto;
+        bounds.upperBound = (int)ZSTD_ps_disable;
+        return bounds;
+
+    case ZSTD_c_deterministicRefPrefix:
+        bounds.lowerBound = 0;
+        bounds.upperBound = 1;
+        return bounds;
+
+    case ZSTD_c_prefetchCDictTables:
+        bounds.lowerBound = (int)ZSTD_ps_auto;
+        bounds.upperBound = (int)ZSTD_ps_disable;
+        return bounds;
+
+    case ZSTD_c_enableSeqProducerFallback:
+        bounds.lowerBound = 0;
+        bounds.upperBound = 1;
+        return bounds;
+
+    case ZSTD_c_maxBlockSize:
+        bounds.lowerBound = ZSTD_BLOCKSIZE_MAX_MIN;
+        bounds.upperBound = ZSTD_BLOCKSIZE_MAX;
+        return bounds;
+
+    case ZSTD_c_searchForExternalRepcodes:
+        bounds.lowerBound = (int)ZSTD_ps_auto;
+        bounds.upperBound = (int)ZSTD_ps_disable;
+        return bounds;
+
+    default:
+        bounds.error = ERROR(parameter_unsupported);
+        return bounds;
+    }
+}
+
+/* ZSTD_cParam_clampBounds:
+ * Clamps the value into the bounded range.
+ */
+static size_t ZSTD_cParam_clampBounds(ZSTD_cParameter cParam, int* value)
+{
+    ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);
+    if (ZSTD_isError(bounds.error)) return bounds.error;
+    if (*value < bounds.lowerBound) *value = bounds.lowerBound;
+    if (*value > bounds.upperBound) *value = bounds.upperBound;
+    return 0;
+}
+
+#define BOUNDCHECK(cParam, val) { \
+    RETURN_ERROR_IF(!ZSTD_cParam_withinBounds(cParam,val), \
+                    parameter_outOfBound, "Param out of bounds"); \
+}
+
+
+static int ZSTD_isUpdateAuthorized(ZSTD_cParameter param)
+{
+    switch(param)
+    {
+    case ZSTD_c_compressionLevel:
+    case ZSTD_c_hashLog:
+    case ZSTD_c_chainLog:
+    case ZSTD_c_searchLog:
+    case ZSTD_c_minMatch:
+    case ZSTD_c_targetLength:
+    case ZSTD_c_strategy:
+        return 1;
+
+    case ZSTD_c_format:
+    case ZSTD_c_windowLog:
+    case ZSTD_c_contentSizeFlag:
+    case ZSTD_c_checksumFlag:
+    case ZSTD_c_dictIDFlag:
+    case ZSTD_c_forceMaxWindow :
+    case ZSTD_c_nbWorkers:
+    case ZSTD_c_jobSize:
+    case ZSTD_c_overlapLog:
+    case ZSTD_c_rsyncable:
+    case ZSTD_c_enableDedicatedDictSearch:
+    case ZSTD_c_enableLongDistanceMatching:
+    case ZSTD_c_ldmHashLog:
+    case ZSTD_c_ldmMinMatch:
+    case ZSTD_c_ldmBucketSizeLog:
+    case ZSTD_c_ldmHashRateLog:
+    case ZSTD_c_forceAttachDict:
+    case ZSTD_c_literalCompressionMode:
+    case ZSTD_c_targetCBlockSize:
+    case ZSTD_c_srcSizeHint:
+    case ZSTD_c_stableInBuffer:
+    case ZSTD_c_stableOutBuffer:
+    case ZSTD_c_blockDelimiters:
+    case ZSTD_c_validateSequences:
+    case ZSTD_c_useBlockSplitter:
+    case ZSTD_c_useRowMatchFinder:
+    case ZSTD_c_deterministicRefPrefix:
+    case ZSTD_c_prefetchCDictTables:
+    case ZSTD_c_enableSeqProducerFallback:
+    case ZSTD_c_maxBlockSize:
+    case ZSTD_c_searchForExternalRepcodes:
+    default:
+        return 0;
+    }
+}
+
+size_t ZSTD_CCtx_setParameter(ZSTD_CCtx* cctx, ZSTD_cParameter param, int value)
+{
+    DEBUGLOG(4, "ZSTD_CCtx_setParameter (%i, %i)", (int)param, value);
+    if (cctx->streamStage != zcss_init) {
+        if (ZSTD_isUpdateAuthorized(param)) {
+            cctx->cParamsChanged = 1;
+        } else {
+            RETURN_ERROR(stage_wrong, "can only set params in cctx init stage");
+    }   }
+
+    switch(param)
+    {
+    case ZSTD_c_nbWorkers:
+        RETURN_ERROR_IF((value!=0) && cctx->staticSize, parameter_unsupported,
+                        "MT not compatible with static alloc");
+        break;
+
+    case ZSTD_c_compressionLevel:
+    case ZSTD_c_windowLog:
+    case ZSTD_c_hashLog:
+    case ZSTD_c_chainLog:
+    case ZSTD_c_searchLog:
+    case ZSTD_c_minMatch:
+    case ZSTD_c_targetLength:
+    case ZSTD_c_strategy:
+    case ZSTD_c_ldmHashRateLog:
+    case ZSTD_c_format:
+    case ZSTD_c_contentSizeFlag:
+    case ZSTD_c_checksumFlag:
+    case ZSTD_c_dictIDFlag:
+    case ZSTD_c_forceMaxWindow:
+    case ZSTD_c_forceAttachDict:
+    case ZSTD_c_literalCompressionMode:
+    case ZSTD_c_jobSize:
+    case ZSTD_c_overlapLog:
+    case ZSTD_c_rsyncable:
+    case ZSTD_c_enableDedicatedDictSearch:
+    case ZSTD_c_enableLongDistanceMatching:
+    case ZSTD_c_ldmHashLog:
+    case ZSTD_c_ldmMinMatch:
+    case ZSTD_c_ldmBucketSizeLog:
+    case ZSTD_c_targetCBlockSize:
+    case ZSTD_c_srcSizeHint:
+    case ZSTD_c_stableInBuffer:
+    case ZSTD_c_stableOutBuffer:
+    case ZSTD_c_blockDelimiters:
+    case ZSTD_c_validateSequences:
+    case ZSTD_c_useBlockSplitter:
+    case ZSTD_c_useRowMatchFinder:
+    case ZSTD_c_deterministicRefPrefix:
+    case ZSTD_c_prefetchCDictTables:
+    case ZSTD_c_enableSeqProducerFallback:
+    case ZSTD_c_maxBlockSize:
+    case ZSTD_c_searchForExternalRepcodes:
+        break;
+
+    default: RETURN_ERROR(parameter_unsupported, "unknown parameter");
+    }
+    return ZSTD_CCtxParams_setParameter(&cctx->requestedParams, param, value);
+}
+
+size_t ZSTD_CCtxParams_setParameter(ZSTD_CCtx_params* CCtxParams,
+                                    ZSTD_cParameter param, int value)
+{
+    DEBUGLOG(4, "ZSTD_CCtxParams_setParameter (%i, %i)", (int)param, value);
+    switch(param)
+    {
+    case ZSTD_c_format :
+        BOUNDCHECK(ZSTD_c_format, value);
+        CCtxParams->format = (ZSTD_format_e)value;
+        return (size_t)CCtxParams->format;
+
+    case ZSTD_c_compressionLevel : {
+        FORWARD_IF_ERROR(ZSTD_cParam_clampBounds(param, &value), "");
+        if (value == 0)
+            CCtxParams->compressionLevel = ZSTD_CLEVEL_DEFAULT; /* 0 == default */
+        else
+            CCtxParams->compressionLevel = value;
+        if (CCtxParams->compressionLevel >= 0) return (size_t)CCtxParams->compressionLevel;
+        return 0;  /* return type (size_t) cannot represent negative values */
+    }
+
+    case ZSTD_c_windowLog :
+        if (value!=0)   /* 0 => use default */
+            BOUNDCHECK(ZSTD_c_windowLog, value);
+        CCtxParams->cParams.windowLog = (U32)value;
+        return CCtxParams->cParams.windowLog;
+
+    case ZSTD_c_hashLog :
+        if (value!=0)   /* 0 => use default */
+            BOUNDCHECK(ZSTD_c_hashLog, value);
+        CCtxParams->cParams.hashLog = (U32)value;
+        return CCtxParams->cParams.hashLog;
+
+    case ZSTD_c_chainLog :
+        if (value!=0)   /* 0 => use default */
+            BOUNDCHECK(ZSTD_c_chainLog, value);
+        CCtxParams->cParams.chainLog = (U32)value;
+        return CCtxParams->cParams.chainLog;
+
+    case ZSTD_c_searchLog :
+        if (value!=0)   /* 0 => use default */
+            BOUNDCHECK(ZSTD_c_searchLog, value);
+        CCtxParams->cParams.searchLog = (U32)value;
+        return (size_t)value;
+
+    case ZSTD_c_minMatch :
+        if (value!=0)   /* 0 => use default */
+            BOUNDCHECK(ZSTD_c_minMatch, value);
+        CCtxParams->cParams.minMatch = (U32)value;
+        return CCtxParams->cParams.minMatch;
+
+    case ZSTD_c_targetLength :
+        BOUNDCHECK(ZSTD_c_targetLength, value);
+        CCtxParams->cParams.targetLength = (U32)value;
+        return CCtxParams->cParams.targetLength;
+
+    case ZSTD_c_strategy :
+        if (value!=0)   /* 0 => use default */
+            BOUNDCHECK(ZSTD_c_strategy, value);
+        CCtxParams->cParams.strategy = (ZSTD_strategy)value;
+        return (size_t)CCtxParams->cParams.strategy;
+
+    case ZSTD_c_contentSizeFlag :
+        /* Content size written in frame header _when known_ (default:1) */
+        DEBUGLOG(4, "set content size flag = %u", (value!=0));
+        CCtxParams->fParams.contentSizeFlag = value != 0;
+        return (size_t)CCtxParams->fParams.contentSizeFlag;
+
+    case ZSTD_c_checksumFlag :
+        /* A 32-bits content checksum will be calculated and written at end of frame (default:0) */
+        CCtxParams->fParams.checksumFlag = value != 0;
+        return (size_t)CCtxParams->fParams.checksumFlag;
+
+    case ZSTD_c_dictIDFlag : /* When applicable, dictionary's dictID is provided in frame header (default:1) */
+        DEBUGLOG(4, "set dictIDFlag = %u", (value!=0));
+        CCtxParams->fParams.noDictIDFlag = !value;
+        return !CCtxParams->fParams.noDictIDFlag;
+
+    case ZSTD_c_forceMaxWindow :
+        CCtxParams->forceWindow = (value != 0);
+        return (size_t)CCtxParams->forceWindow;
+
+    case ZSTD_c_forceAttachDict : {
+        const ZSTD_dictAttachPref_e pref = (ZSTD_dictAttachPref_e)value;
+        BOUNDCHECK(ZSTD_c_forceAttachDict, (int)pref);
+        CCtxParams->attachDictPref = pref;
+        return CCtxParams->attachDictPref;
+    }
+
+    case ZSTD_c_literalCompressionMode : {
+        const ZSTD_paramSwitch_e lcm = (ZSTD_paramSwitch_e)value;
+        BOUNDCHECK(ZSTD_c_literalCompressionMode, (int)lcm);
+        CCtxParams->literalCompressionMode = lcm;
+        return CCtxParams->literalCompressionMode;
+    }
+
+    case ZSTD_c_nbWorkers :
+#ifndef ZSTD_MULTITHREAD
+        RETURN_ERROR_IF(value!=0, parameter_unsupported, "not compiled with multithreading");
+        return 0;
+#else
+        FORWARD_IF_ERROR(ZSTD_cParam_clampBounds(param, &value), "");
+        CCtxParams->nbWorkers = value;
+        return CCtxParams->nbWorkers;
+#endif
+
+    case ZSTD_c_jobSize :
+#ifndef ZSTD_MULTITHREAD
+        RETURN_ERROR_IF(value!=0, parameter_unsupported, "not compiled with multithreading");
+        return 0;
+#else
+        /* Adjust to the minimum non-default value. */
+        if (value != 0 && value < ZSTDMT_JOBSIZE_MIN)
+            value = ZSTDMT_JOBSIZE_MIN;
+        FORWARD_IF_ERROR(ZSTD_cParam_clampBounds(param, &value), "");
+        assert(value >= 0);
+        CCtxParams->jobSize = value;
+        return CCtxParams->jobSize;
+#endif
+
+    case ZSTD_c_overlapLog :
+#ifndef ZSTD_MULTITHREAD
+        RETURN_ERROR_IF(value!=0, parameter_unsupported, "not compiled with multithreading");
+        return 0;
+#else
+        FORWARD_IF_ERROR(ZSTD_cParam_clampBounds(ZSTD_c_overlapLog, &value), "");
+        CCtxParams->overlapLog = value;
+        return CCtxParams->overlapLog;
+#endif
+
+    case ZSTD_c_rsyncable :
+#ifndef ZSTD_MULTITHREAD
+        RETURN_ERROR_IF(value!=0, parameter_unsupported, "not compiled with multithreading");
+        return 0;
+#else
+        FORWARD_IF_ERROR(ZSTD_cParam_clampBounds(ZSTD_c_overlapLog, &value), "");
+        CCtxParams->rsyncable = value;
+        return CCtxParams->rsyncable;
+#endif
+
+    case ZSTD_c_enableDedicatedDictSearch :
+        CCtxParams->enableDedicatedDictSearch = (value!=0);
+        return (size_t)CCtxParams->enableDedicatedDictSearch;
+
+    case ZSTD_c_enableLongDistanceMatching :
+        BOUNDCHECK(ZSTD_c_enableLongDistanceMatching, value);
+        CCtxParams->ldmParams.enableLdm = (ZSTD_paramSwitch_e)value;
+        return CCtxParams->ldmParams.enableLdm;
+
+    case ZSTD_c_ldmHashLog :
+        if (value!=0)   /* 0 ==> auto */
+            BOUNDCHECK(ZSTD_c_ldmHashLog, value);
+        CCtxParams->ldmParams.hashLog = (U32)value;
+        return CCtxParams->ldmParams.hashLog;
+
+    case ZSTD_c_ldmMinMatch :
+        if (value!=0)   /* 0 ==> default */
+            BOUNDCHECK(ZSTD_c_ldmMinMatch, value);
+        CCtxParams->ldmParams.minMatchLength = (U32)value;
+        return CCtxParams->ldmParams.minMatchLength;
+
+    case ZSTD_c_ldmBucketSizeLog :
+        if (value!=0)   /* 0 ==> default */
+            BOUNDCHECK(ZSTD_c_ldmBucketSizeLog, value);
+        CCtxParams->ldmParams.bucketSizeLog = (U32)value;
+        return CCtxParams->ldmParams.bucketSizeLog;
+
+    case ZSTD_c_ldmHashRateLog :
+        if (value!=0)   /* 0 ==> default */
+            BOUNDCHECK(ZSTD_c_ldmHashRateLog, value);
+        CCtxParams->ldmParams.hashRateLog = (U32)value;
+        return CCtxParams->ldmParams.hashRateLog;
+
+    case ZSTD_c_targetCBlockSize :
+        if (value!=0)   /* 0 ==> default */
+            BOUNDCHECK(ZSTD_c_targetCBlockSize, value);
+        CCtxParams->targetCBlockSize = (U32)value;
+        return CCtxParams->targetCBlockSize;
+
+    case ZSTD_c_srcSizeHint :
+        if (value!=0)    /* 0 ==> default */
+            BOUNDCHECK(ZSTD_c_srcSizeHint, value);
+        CCtxParams->srcSizeHint = value;
+        return (size_t)CCtxParams->srcSizeHint;
+
+    case ZSTD_c_stableInBuffer:
+        BOUNDCHECK(ZSTD_c_stableInBuffer, value);
+        CCtxParams->inBufferMode = (ZSTD_bufferMode_e)value;
+        return CCtxParams->inBufferMode;
+
+    case ZSTD_c_stableOutBuffer:
+        BOUNDCHECK(ZSTD_c_stableOutBuffer, value);
+        CCtxParams->outBufferMode = (ZSTD_bufferMode_e)value;
+        return CCtxParams->outBufferMode;
+
+    case ZSTD_c_blockDelimiters:
+        BOUNDCHECK(ZSTD_c_blockDelimiters, value);
+        CCtxParams->blockDelimiters = (ZSTD_sequenceFormat_e)value;
+        return CCtxParams->blockDelimiters;
+
+    case ZSTD_c_validateSequences:
+        BOUNDCHECK(ZSTD_c_validateSequences, value);
+        CCtxParams->validateSequences = value;
+        return CCtxParams->validateSequences;
+
+    case ZSTD_c_useBlockSplitter:
+        BOUNDCHECK(ZSTD_c_useBlockSplitter, value);
+        CCtxParams->useBlockSplitter = (ZSTD_paramSwitch_e)value;
+        return CCtxParams->useBlockSplitter;
+
+    case ZSTD_c_useRowMatchFinder:
+        BOUNDCHECK(ZSTD_c_useRowMatchFinder, value);
+        CCtxParams->useRowMatchFinder = (ZSTD_paramSwitch_e)value;
+        return CCtxParams->useRowMatchFinder;
+
+    case ZSTD_c_deterministicRefPrefix:
+        BOUNDCHECK(ZSTD_c_deterministicRefPrefix, value);
+        CCtxParams->deterministicRefPrefix = !!value;
+        return CCtxParams->deterministicRefPrefix;
+
+    case ZSTD_c_prefetchCDictTables:
+        BOUNDCHECK(ZSTD_c_prefetchCDictTables, value);
+        CCtxParams->prefetchCDictTables = (ZSTD_paramSwitch_e)value;
+        return CCtxParams->prefetchCDictTables;
+
+    case ZSTD_c_enableSeqProducerFallback:
+        BOUNDCHECK(ZSTD_c_enableSeqProducerFallback, value);
+        CCtxParams->enableMatchFinderFallback = value;
+        return CCtxParams->enableMatchFinderFallback;
+
+    case ZSTD_c_maxBlockSize:
+        if (value!=0)    /* 0 ==> default */
+            BOUNDCHECK(ZSTD_c_maxBlockSize, value);
+        CCtxParams->maxBlockSize = value;
+        return CCtxParams->maxBlockSize;
+
+    case ZSTD_c_searchForExternalRepcodes:
+        BOUNDCHECK(ZSTD_c_searchForExternalRepcodes, value);
+        CCtxParams->searchForExternalRepcodes = (ZSTD_paramSwitch_e)value;
+        return CCtxParams->searchForExternalRepcodes;
+
+    default: RETURN_ERROR(parameter_unsupported, "unknown parameter");
+    }
+}
+
+size_t ZSTD_CCtx_getParameter(ZSTD_CCtx const* cctx, ZSTD_cParameter param, int* value)
+{
+    return ZSTD_CCtxParams_getParameter(&cctx->requestedParams, param, value);
+}
+
+size_t ZSTD_CCtxParams_getParameter(
+        ZSTD_CCtx_params const* CCtxParams, ZSTD_cParameter param, int* value)
+{
+    switch(param)
+    {
+    case ZSTD_c_format :
+        *value = CCtxParams->format;
+        break;
+    case ZSTD_c_compressionLevel :
+        *value = CCtxParams->compressionLevel;
+        break;
+    case ZSTD_c_windowLog :
+        *value = (int)CCtxParams->cParams.windowLog;
+        break;
+    case ZSTD_c_hashLog :
+        *value = (int)CCtxParams->cParams.hashLog;
+        break;
+    case ZSTD_c_chainLog :
+        *value = (int)CCtxParams->cParams.chainLog;
+        break;
+    case ZSTD_c_searchLog :
+        *value = CCtxParams->cParams.searchLog;
+        break;
+    case ZSTD_c_minMatch :
+        *value = CCtxParams->cParams.minMatch;
+        break;
+    case ZSTD_c_targetLength :
+        *value = CCtxParams->cParams.targetLength;
+        break;
+    case ZSTD_c_strategy :
+        *value = (unsigned)CCtxParams->cParams.strategy;
+        break;
+    case ZSTD_c_contentSizeFlag :
+        *value = CCtxParams->fParams.contentSizeFlag;
+        break;
+    case ZSTD_c_checksumFlag :
+        *value = CCtxParams->fParams.checksumFlag;
+        break;
+    case ZSTD_c_dictIDFlag :
+        *value = !CCtxParams->fParams.noDictIDFlag;
+        break;
+    case ZSTD_c_forceMaxWindow :
+        *value = CCtxParams->forceWindow;
+        break;
+    case ZSTD_c_forceAttachDict :
+        *value = CCtxParams->attachDictPref;
+        break;
+    case ZSTD_c_literalCompressionMode :
+        *value = CCtxParams->literalCompressionMode;
+        break;
+    case ZSTD_c_nbWorkers :
+#ifndef ZSTD_MULTITHREAD
+        assert(CCtxParams->nbWorkers == 0);
+#endif
+        *value = CCtxParams->nbWorkers;
+        break;
+    case ZSTD_c_jobSize :
+#ifndef ZSTD_MULTITHREAD
+        RETURN_ERROR(parameter_unsupported, "not compiled with multithreading");
+#else
+        assert(CCtxParams->jobSize <= INT_MAX);
+        *value = (int)CCtxParams->jobSize;
+        break;
+#endif
+    case ZSTD_c_overlapLog :
+#ifndef ZSTD_MULTITHREAD
+        RETURN_ERROR(parameter_unsupported, "not compiled with multithreading");
+#else
+        *value = CCtxParams->overlapLog;
+        break;
+#endif
+    case ZSTD_c_rsyncable :
+#ifndef ZSTD_MULTITHREAD
+        RETURN_ERROR(parameter_unsupported, "not compiled with multithreading");
+#else
+        *value = CCtxParams->rsyncable;
+        break;
+#endif
+    case ZSTD_c_enableDedicatedDictSearch :
+        *value = CCtxParams->enableDedicatedDictSearch;
+        break;
+    case ZSTD_c_enableLongDistanceMatching :
+        *value = CCtxParams->ldmParams.enableLdm;
+        break;
+    case ZSTD_c_ldmHashLog :
+        *value = CCtxParams->ldmParams.hashLog;
+        break;
+    case ZSTD_c_ldmMinMatch :
+        *value = CCtxParams->ldmParams.minMatchLength;
+        break;
+    case ZSTD_c_ldmBucketSizeLog :
+        *value = CCtxParams->ldmParams.bucketSizeLog;
+        break;
+    case ZSTD_c_ldmHashRateLog :
+        *value = CCtxParams->ldmParams.hashRateLog;
+        break;
+    case ZSTD_c_targetCBlockSize :
+        *value = (int)CCtxParams->targetCBlockSize;
+        break;
+    case ZSTD_c_srcSizeHint :
+        *value = (int)CCtxParams->srcSizeHint;
+        break;
+    case ZSTD_c_stableInBuffer :
+        *value = (int)CCtxParams->inBufferMode;
+        break;
+    case ZSTD_c_stableOutBuffer :
+        *value = (int)CCtxParams->outBufferMode;
+        break;
+    case ZSTD_c_blockDelimiters :
+        *value = (int)CCtxParams->blockDelimiters;
+        break;
+    case ZSTD_c_validateSequences :
+        *value = (int)CCtxParams->validateSequences;
+        break;
+    case ZSTD_c_useBlockSplitter :
+        *value = (int)CCtxParams->useBlockSplitter;
+        break;
+    case ZSTD_c_useRowMatchFinder :
+        *value = (int)CCtxParams->useRowMatchFinder;
+        break;
+    case ZSTD_c_deterministicRefPrefix:
+        *value = (int)CCtxParams->deterministicRefPrefix;
+        break;
+    case ZSTD_c_prefetchCDictTables:
+        *value = (int)CCtxParams->prefetchCDictTables;
+        break;
+    case ZSTD_c_enableSeqProducerFallback:
+        *value = CCtxParams->enableMatchFinderFallback;
+        break;
+    case ZSTD_c_maxBlockSize:
+        *value = (int)CCtxParams->maxBlockSize;
+        break;
+    case ZSTD_c_searchForExternalRepcodes:
+        *value = (int)CCtxParams->searchForExternalRepcodes;
+        break;
+    default: RETURN_ERROR(parameter_unsupported, "unknown parameter");
+    }
+    return 0;
+}
+
+/** ZSTD_CCtx_setParametersUsingCCtxParams() :
+ *  just applies `params` into `cctx`
+ *  no action is performed, parameters are merely stored.
+ *  If ZSTDMT is enabled, parameters are pushed to cctx->mtctx.
+ *    This is possible even if a compression is ongoing.
+ *    In which case, new parameters will be applied on the fly, starting with next compression job.
+ */
+size_t ZSTD_CCtx_setParametersUsingCCtxParams(
+        ZSTD_CCtx* cctx, const ZSTD_CCtx_params* params)
+{
+    DEBUGLOG(4, "ZSTD_CCtx_setParametersUsingCCtxParams");
+    RETURN_ERROR_IF(cctx->streamStage != zcss_init, stage_wrong,
+                    "The context is in the wrong stage!");
+    RETURN_ERROR_IF(cctx->cdict, stage_wrong,
+                    "Can't override parameters with cdict attached (some must "
+                    "be inherited from the cdict).");
+
+    cctx->requestedParams = *params;
+    return 0;
+}
+
+size_t ZSTD_CCtx_setCParams(ZSTD_CCtx* cctx, ZSTD_compressionParameters cparams)
+{
+    ZSTD_STATIC_ASSERT(sizeof(cparams) == 7 * 4 /* all params are listed below */);
+    DEBUGLOG(4, "ZSTD_CCtx_setCParams");
+    /* only update if all parameters are valid */
+    FORWARD_IF_ERROR(ZSTD_checkCParams(cparams), "");
+    FORWARD_IF_ERROR(ZSTD_CCtx_setParameter(cctx, ZSTD_c_windowLog, cparams.windowLog), "");
+    FORWARD_IF_ERROR(ZSTD_CCtx_setParameter(cctx, ZSTD_c_chainLog, cparams.chainLog), "");
+    FORWARD_IF_ERROR(ZSTD_CCtx_setParameter(cctx, ZSTD_c_hashLog, cparams.hashLog), "");
+    FORWARD_IF_ERROR(ZSTD_CCtx_setParameter(cctx, ZSTD_c_searchLog, cparams.searchLog), "");
+    FORWARD_IF_ERROR(ZSTD_CCtx_setParameter(cctx, ZSTD_c_minMatch, cparams.minMatch), "");
+    FORWARD_IF_ERROR(ZSTD_CCtx_setParameter(cctx, ZSTD_c_targetLength, cparams.targetLength), "");
+    FORWARD_IF_ERROR(ZSTD_CCtx_setParameter(cctx, ZSTD_c_strategy, cparams.strategy), "");
+    return 0;
+}
+
+size_t ZSTD_CCtx_setFParams(ZSTD_CCtx* cctx, ZSTD_frameParameters fparams)
+{
+    ZSTD_STATIC_ASSERT(sizeof(fparams) == 3 * 4 /* all params are listed below */);
+    DEBUGLOG(4, "ZSTD_CCtx_setFParams");
+    FORWARD_IF_ERROR(ZSTD_CCtx_setParameter(cctx, ZSTD_c_contentSizeFlag, fparams.contentSizeFlag != 0), "");
+    FORWARD_IF_ERROR(ZSTD_CCtx_setParameter(cctx, ZSTD_c_checksumFlag, fparams.checksumFlag != 0), "");
+    FORWARD_IF_ERROR(ZSTD_CCtx_setParameter(cctx, ZSTD_c_dictIDFlag, fparams.noDictIDFlag == 0), "");
+    return 0;
+}
+
+size_t ZSTD_CCtx_setParams(ZSTD_CCtx* cctx, ZSTD_parameters params)
+{
+    DEBUGLOG(4, "ZSTD_CCtx_setParams");
+    /* First check cParams, because we want to update all or none. */
+    FORWARD_IF_ERROR(ZSTD_checkCParams(params.cParams), "");
+    /* Next set fParams, because this could fail if the cctx isn't in init stage. */
+    FORWARD_IF_ERROR(ZSTD_CCtx_setFParams(cctx, params.fParams), "");
+    /* Finally set cParams, which should succeed. */
+    FORWARD_IF_ERROR(ZSTD_CCtx_setCParams(cctx, params.cParams), "");
+    return 0;
+}
+
+size_t ZSTD_CCtx_setPledgedSrcSize(ZSTD_CCtx* cctx, unsigned long long pledgedSrcSize)
+{
+    DEBUGLOG(4, "ZSTD_CCtx_setPledgedSrcSize to %llu bytes", pledgedSrcSize);
+    RETURN_ERROR_IF(cctx->streamStage != zcss_init, stage_wrong,
+                    "Can't set pledgedSrcSize when not in init stage.");
+    cctx->pledgedSrcSizePlusOne = pledgedSrcSize+1;
+    return 0;
+}
+
+static ZSTD_compressionParameters ZSTD_dedicatedDictSearch_getCParams(
+        int const compressionLevel,
+        size_t const dictSize);
+static int ZSTD_dedicatedDictSearch_isSupported(
+        const ZSTD_compressionParameters* cParams);
+static void ZSTD_dedicatedDictSearch_revertCParams(
+        ZSTD_compressionParameters* cParams);
+
+/**
+ * Initializes the local dictionary using requested parameters.
+ * NOTE: Initialization does not employ the pledged src size,
+ * because the dictionary may be used for multiple compressions.
+ */
+static size_t ZSTD_initLocalDict(ZSTD_CCtx* cctx)
+{
+    ZSTD_localDict* const dl = &cctx->localDict;
+    if (dl->dict == NULL) {
+        /* No local dictionary. */
+        assert(dl->dictBuffer == NULL);
+        assert(dl->cdict == NULL);
+        assert(dl->dictSize == 0);
+        return 0;
+    }
+    if (dl->cdict != NULL) {
+        /* Local dictionary already initialized. */
+        assert(cctx->cdict == dl->cdict);
+        return 0;
+    }
+    assert(dl->dictSize > 0);
+    assert(cctx->cdict == NULL);
+    assert(cctx->prefixDict.dict == NULL);
+
+    dl->cdict = ZSTD_createCDict_advanced2(
+            dl->dict,
+            dl->dictSize,
+            ZSTD_dlm_byRef,
+            dl->dictContentType,
+            &cctx->requestedParams,
+            cctx->customMem);
+    RETURN_ERROR_IF(!dl->cdict, memory_allocation, "ZSTD_createCDict_advanced failed");
+    cctx->cdict = dl->cdict;
+    return 0;
+}
+
+size_t ZSTD_CCtx_loadDictionary_advanced(
+        ZSTD_CCtx* cctx,
+        const void* dict, size_t dictSize,
+        ZSTD_dictLoadMethod_e dictLoadMethod,
+        ZSTD_dictContentType_e dictContentType)
+{
+    DEBUGLOG(4, "ZSTD_CCtx_loadDictionary_advanced (size: %u)", (U32)dictSize);
+    RETURN_ERROR_IF(cctx->streamStage != zcss_init, stage_wrong,
+                    "Can't load a dictionary when cctx is not in init stage.");
+    ZSTD_clearAllDicts(cctx);  /* erase any previously set dictionary */
+    if (dict == NULL || dictSize == 0)  /* no dictionary */
+        return 0;
+    if (dictLoadMethod == ZSTD_dlm_byRef) {
+        cctx->localDict.dict = dict;
+    } else {
+        /* copy dictionary content inside CCtx to own its lifetime */
+        void* dictBuffer;
+        RETURN_ERROR_IF(cctx->staticSize, memory_allocation,
+                        "static CCtx can't allocate for an internal copy of dictionary");
+        dictBuffer = ZSTD_customMalloc(dictSize, cctx->customMem);
+        RETURN_ERROR_IF(dictBuffer==NULL, memory_allocation,
+                        "allocation failed for dictionary content");
+        ZSTD_memcpy(dictBuffer, dict, dictSize);
+        cctx->localDict.dictBuffer = dictBuffer;  /* owned ptr to free */
+        cctx->localDict.dict = dictBuffer;        /* read-only reference */
+    }
+    cctx->localDict.dictSize = dictSize;
+    cctx->localDict.dictContentType = dictContentType;
+    return 0;
+}
+
+size_t ZSTD_CCtx_loadDictionary_byReference(
+      ZSTD_CCtx* cctx, const void* dict, size_t dictSize)
+{
+    return ZSTD_CCtx_loadDictionary_advanced(
+            cctx, dict, dictSize, ZSTD_dlm_byRef, ZSTD_dct_auto);
+}
+
+size_t ZSTD_CCtx_loadDictionary(ZSTD_CCtx* cctx, const void* dict, size_t dictSize)
+{
+    return ZSTD_CCtx_loadDictionary_advanced(
+            cctx, dict, dictSize, ZSTD_dlm_byCopy, ZSTD_dct_auto);
+}
+
+
+size_t ZSTD_CCtx_refCDict(ZSTD_CCtx* cctx, const ZSTD_CDict* cdict)
+{
+    RETURN_ERROR_IF(cctx->streamStage != zcss_init, stage_wrong,
+                    "Can't ref a dict when ctx not in init stage.");
+    /* Free the existing local cdict (if any) to save memory. */
+    ZSTD_clearAllDicts(cctx);
+    cctx->cdict = cdict;
+    return 0;
+}
+
+size_t ZSTD_CCtx_refThreadPool(ZSTD_CCtx* cctx, ZSTD_threadPool* pool)
+{
+    RETURN_ERROR_IF(cctx->streamStage != zcss_init, stage_wrong,
+                    "Can't ref a pool when ctx not in init stage.");
+    cctx->pool = pool;
+    return 0;
+}
+
+size_t ZSTD_CCtx_refPrefix(ZSTD_CCtx* cctx, const void* prefix, size_t prefixSize)
+{
+    return ZSTD_CCtx_refPrefix_advanced(cctx, prefix, prefixSize, ZSTD_dct_rawContent);
+}
+
+size_t ZSTD_CCtx_refPrefix_advanced(
+        ZSTD_CCtx* cctx, const void* prefix, size_t prefixSize, ZSTD_dictContentType_e dictContentType)
+{
+    RETURN_ERROR_IF(cctx->streamStage != zcss_init, stage_wrong,
+                    "Can't ref a prefix when ctx not in init stage.");
+    ZSTD_clearAllDicts(cctx);
+    if (prefix != NULL && prefixSize > 0) {
+        cctx->prefixDict.dict = prefix;
+        cctx->prefixDict.dictSize = prefixSize;
+        cctx->prefixDict.dictContentType = dictContentType;
+    }
+    return 0;
+}
+
+/*! ZSTD_CCtx_reset() :
+ *  Also dumps dictionary */
+size_t ZSTD_CCtx_reset(ZSTD_CCtx* cctx, ZSTD_ResetDirective reset)
+{
+    if ( (reset == ZSTD_reset_session_only)
+      || (reset == ZSTD_reset_session_and_parameters) ) {
+        cctx->streamStage = zcss_init;
+        cctx->pledgedSrcSizePlusOne = 0;
+    }
+    if ( (reset == ZSTD_reset_parameters)
+      || (reset == ZSTD_reset_session_and_parameters) ) {
+        RETURN_ERROR_IF(cctx->streamStage != zcss_init, stage_wrong,
+                        "Reset parameters is only possible during init stage.");
+        ZSTD_clearAllDicts(cctx);
+        ZSTD_memset(&cctx->externalMatchCtx, 0, sizeof(cctx->externalMatchCtx));
+        return ZSTD_CCtxParams_reset(&cctx->requestedParams);
+    }
+    return 0;
+}
+
+
+/** ZSTD_checkCParams() :
+    control CParam values remain within authorized range.
+    @return : 0, or an error code if one value is beyond authorized range */
+size_t ZSTD_checkCParams(ZSTD_compressionParameters cParams)
+{
+    BOUNDCHECK(ZSTD_c_windowLog, (int)cParams.windowLog);
+    BOUNDCHECK(ZSTD_c_chainLog,  (int)cParams.chainLog);
+    BOUNDCHECK(ZSTD_c_hashLog,   (int)cParams.hashLog);
+    BOUNDCHECK(ZSTD_c_searchLog, (int)cParams.searchLog);
+    BOUNDCHECK(ZSTD_c_minMatch,  (int)cParams.minMatch);
+    BOUNDCHECK(ZSTD_c_targetLength,(int)cParams.targetLength);
+    BOUNDCHECK(ZSTD_c_strategy,  cParams.strategy);
+    return 0;
+}
+
+/** ZSTD_clampCParams() :
+ *  make CParam values within valid range.
+ *  @return : valid CParams */
+static ZSTD_compressionParameters
+ZSTD_clampCParams(ZSTD_compressionParameters cParams)
+{
+#   define CLAMP_TYPE(cParam, val, type) {                                \
+        ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);         \
+        if ((int)val<bounds.lowerBound) val=(type)bounds.lowerBound;      \
+        else if ((int)val>bounds.upperBound) val=(type)bounds.upperBound; \
+    }
+#   define CLAMP(cParam, val) CLAMP_TYPE(cParam, val, unsigned)
+    CLAMP(ZSTD_c_windowLog, cParams.windowLog);
+    CLAMP(ZSTD_c_chainLog,  cParams.chainLog);
+    CLAMP(ZSTD_c_hashLog,   cParams.hashLog);
+    CLAMP(ZSTD_c_searchLog, cParams.searchLog);
+    CLAMP(ZSTD_c_minMatch,  cParams.minMatch);
+    CLAMP(ZSTD_c_targetLength,cParams.targetLength);
+    CLAMP_TYPE(ZSTD_c_strategy,cParams.strategy, ZSTD_strategy);
+    return cParams;
+}
+
+/** ZSTD_cycleLog() :
+ *  condition for correct operation : hashLog > 1 */
+U32 ZSTD_cycleLog(U32 hashLog, ZSTD_strategy strat)
+{
+    U32 const btScale = ((U32)strat >= (U32)ZSTD_btlazy2);
+    return hashLog - btScale;
+}
+
+/** ZSTD_dictAndWindowLog() :
+ * Returns an adjusted window log that is large enough to fit the source and the dictionary.
+ * The zstd format says that the entire dictionary is valid if one byte of the dictionary
+ * is within the window. So the hashLog and chainLog should be large enough to reference both
+ * the dictionary and the window. So we must use this adjusted dictAndWindowLog when downsizing
+ * the hashLog and windowLog.
+ * NOTE: srcSize must not be ZSTD_CONTENTSIZE_UNKNOWN.
+ */
+static U32 ZSTD_dictAndWindowLog(U32 windowLog, U64 srcSize, U64 dictSize)
+{
+    const U64 maxWindowSize = 1ULL << ZSTD_WINDOWLOG_MAX;
+    /* No dictionary ==> No change */
+    if (dictSize == 0) {
+        return windowLog;
+    }
+    assert(windowLog <= ZSTD_WINDOWLOG_MAX);
+    assert(srcSize != ZSTD_CONTENTSIZE_UNKNOWN); /* Handled in ZSTD_adjustCParams_internal() */
+    {
+        U64 const windowSize = 1ULL << windowLog;
+        U64 const dictAndWindowSize = dictSize + windowSize;
+        /* If the window size is already large enough to fit both the source and the dictionary
+         * then just use the window size. Otherwise adjust so that it fits the dictionary and
+         * the window.
+         */
+        if (windowSize >= dictSize + srcSize) {
+            return windowLog; /* Window size large enough already */
+        } else if (dictAndWindowSize >= maxWindowSize) {
+            return ZSTD_WINDOWLOG_MAX; /* Larger than max window log */
+        } else  {
+            return ZSTD_highbit32((U32)dictAndWindowSize - 1) + 1;
+        }
+    }
+}
+
+/** ZSTD_adjustCParams_internal() :
+ *  optimize `cPar` for a specified input (`srcSize` and `dictSize`).
+ *  mostly downsize to reduce memory consumption and initialization latency.
+ * `srcSize` can be ZSTD_CONTENTSIZE_UNKNOWN when not known.
+ * `mode` is the mode for parameter adjustment. See docs for `ZSTD_cParamMode_e`.
+ *  note : `srcSize==0` means 0!
+ *  condition : cPar is presumed validated (can be checked using ZSTD_checkCParams()). */
+static ZSTD_compressionParameters
+ZSTD_adjustCParams_internal(ZSTD_compressionParameters cPar,
+                            unsigned long long srcSize,
+                            size_t dictSize,
+                            ZSTD_cParamMode_e mode,
+                            ZSTD_paramSwitch_e useRowMatchFinder)
+{
+    const U64 minSrcSize = 513; /* (1<<9) + 1 */
+    const U64 maxWindowResize = 1ULL << (ZSTD_WINDOWLOG_MAX-1);
+    assert(ZSTD_checkCParams(cPar)==0);
+
+    switch (mode) {
+    case ZSTD_cpm_unknown:
+    case ZSTD_cpm_noAttachDict:
+        /* If we don't know the source size, don't make any
+         * assumptions about it. We will already have selected
+         * smaller parameters if a dictionary is in use.
+         */
+        break;
+    case ZSTD_cpm_createCDict:
+        /* Assume a small source size when creating a dictionary
+         * with an unknown source size.
+         */
+        if (dictSize && srcSize == ZSTD_CONTENTSIZE_UNKNOWN)
+            srcSize = minSrcSize;
+        break;
+    case ZSTD_cpm_attachDict:
+        /* Dictionary has its own dedicated parameters which have
+         * already been selected. We are selecting parameters
+         * for only the source.
+         */
+        dictSize = 0;
+        break;
+    default:
+        assert(0);
+        break;
+    }
+
+    /* resize windowLog if input is small enough, to use less memory */
+    if ( (srcSize <= maxWindowResize)
+      && (dictSize <= maxWindowResize) )  {
+        U32 const tSize = (U32)(srcSize + dictSize);
+        static U32 const hashSizeMin = 1 << ZSTD_HASHLOG_MIN;
+        U32 const srcLog = (tSize < hashSizeMin) ? ZSTD_HASHLOG_MIN :
+                            ZSTD_highbit32(tSize-1) + 1;
+        if (cPar.windowLog > srcLog) cPar.windowLog = srcLog;
+    }
+    if (srcSize != ZSTD_CONTENTSIZE_UNKNOWN) {
+        U32 const dictAndWindowLog = ZSTD_dictAndWindowLog(cPar.windowLog, (U64)srcSize, (U64)dictSize);
+        U32 const cycleLog = ZSTD_cycleLog(cPar.chainLog, cPar.strategy);
+        if (cPar.hashLog > dictAndWindowLog+1) cPar.hashLog = dictAndWindowLog+1;
+        if (cycleLog > dictAndWindowLog)
+            cPar.chainLog -= (cycleLog - dictAndWindowLog);
+    }
+
+    if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)
+        cPar.windowLog = ZSTD_WINDOWLOG_ABSOLUTEMIN;  /* minimum wlog required for valid frame header */
+
+    /* We can't use more than 32 bits of hash in total, so that means that we require:
+     * (hashLog + 8) <= 32 && (chainLog + 8) <= 32
+     */
+    if (mode == ZSTD_cpm_createCDict && ZSTD_CDictIndicesAreTagged(&cPar)) {
+        U32 const maxShortCacheHashLog = 32 - ZSTD_SHORT_CACHE_TAG_BITS;
+        if (cPar.hashLog > maxShortCacheHashLog) {
+            cPar.hashLog = maxShortCacheHashLog;
+        }
+        if (cPar.chainLog > maxShortCacheHashLog) {
+            cPar.chainLog = maxShortCacheHashLog;
+        }
+    }
+
+
+    /* At this point, we aren't 100% sure if we are using the row match finder.
+     * Unless it is explicitly disabled, conservatively assume that it is enabled.
+     * In this case it will only be disabled for small sources, so shrinking the
+     * hash log a little bit shouldn't result in any ratio loss.
+     */
+    if (useRowMatchFinder == ZSTD_ps_auto)
+        useRowMatchFinder = ZSTD_ps_enable;
+
+    /* We can't hash more than 32-bits in total. So that means that we require:
+     * (hashLog - rowLog + 8) <= 32
+     */
+    if (ZSTD_rowMatchFinderUsed(cPar.strategy, useRowMatchFinder)) {
+        /* Switch to 32-entry rows if searchLog is 5 (or more) */
+        U32 const rowLog = BOUNDED(4, cPar.searchLog, 6);
+        U32 const maxRowHashLog = 32 - ZSTD_ROW_HASH_TAG_BITS;
+        U32 const maxHashLog = maxRowHashLog + rowLog;
+        assert(cPar.hashLog >= rowLog);
+        if (cPar.hashLog > maxHashLog) {
+            cPar.hashLog = maxHashLog;
+        }
+    }
+
+    return cPar;
+}
+
+ZSTD_compressionParameters
+ZSTD_adjustCParams(ZSTD_compressionParameters cPar,
+                   unsigned long long srcSize,
+                   size_t dictSize)
+{
+    cPar = ZSTD_clampCParams(cPar);   /* resulting cPar is necessarily valid (all parameters within range) */
+    if (srcSize == 0) srcSize = ZSTD_CONTENTSIZE_UNKNOWN;
+    return ZSTD_adjustCParams_internal(cPar, srcSize, dictSize, ZSTD_cpm_unknown, ZSTD_ps_auto);
+}
+
+static ZSTD_compressionParameters ZSTD_getCParams_internal(int compressionLevel, unsigned long long srcSizeHint, size_t dictSize, ZSTD_cParamMode_e mode);
+static ZSTD_parameters ZSTD_getParams_internal(int compressionLevel, unsigned long long srcSizeHint, size_t dictSize, ZSTD_cParamMode_e mode);
+
+static void ZSTD_overrideCParams(
+              ZSTD_compressionParameters* cParams,
+        const ZSTD_compressionParameters* overrides)
+{
+    if (overrides->windowLog)    cParams->windowLog    = overrides->windowLog;
+    if (overrides->hashLog)      cParams->hashLog      = overrides->hashLog;
+    if (overrides->chainLog)     cParams->chainLog     = overrides->chainLog;
+    if (overrides->searchLog)    cParams->searchLog    = overrides->searchLog;
+    if (overrides->minMatch)     cParams->minMatch     = overrides->minMatch;
+    if (overrides->targetLength) cParams->targetLength = overrides->targetLength;
+    if (overrides->strategy)     cParams->strategy     = overrides->strategy;
+}
+
+ZSTD_compressionParameters ZSTD_getCParamsFromCCtxParams(
+        const ZSTD_CCtx_params* CCtxParams, U64 srcSizeHint, size_t dictSize, ZSTD_cParamMode_e mode)
+{
+    ZSTD_compressionParameters cParams;
+    if (srcSizeHint == ZSTD_CONTENTSIZE_UNKNOWN && CCtxParams->srcSizeHint > 0) {
+      srcSizeHint = CCtxParams->srcSizeHint;
+    }
+    cParams = ZSTD_getCParams_internal(CCtxParams->compressionLevel, srcSizeHint, dictSize, mode);
+    if (CCtxParams->ldmParams.enableLdm == ZSTD_ps_enable) cParams.windowLog = ZSTD_LDM_DEFAULT_WINDOW_LOG;
+    ZSTD_overrideCParams(&cParams, &CCtxParams->cParams);
+    assert(!ZSTD_checkCParams(cParams));
+    /* srcSizeHint == 0 means 0 */
+    return ZSTD_adjustCParams_internal(cParams, srcSizeHint, dictSize, mode, CCtxParams->useRowMatchFinder);
+}
+
+static size_t
+ZSTD_sizeof_matchState(const ZSTD_compressionParameters* const cParams,
+                       const ZSTD_paramSwitch_e useRowMatchFinder,
+                       const U32 enableDedicatedDictSearch,
+                       const U32 forCCtx)
+{
+    /* chain table size should be 0 for fast or row-hash strategies */
+    size_t const chainSize = ZSTD_allocateChainTable(cParams->strategy, useRowMatchFinder, enableDedicatedDictSearch && !forCCtx)
+                                ? ((size_t)1 << cParams->chainLog)
+                                : 0;
+    size_t const hSize = ((size_t)1) << cParams->hashLog;
+    U32    const hashLog3 = (forCCtx && cParams->minMatch==3) ? MIN(ZSTD_HASHLOG3_MAX, cParams->windowLog) : 0;
+    size_t const h3Size = hashLog3 ? ((size_t)1) << hashLog3 : 0;
+    /* We don't use ZSTD_cwksp_alloc_size() here because the tables aren't
+     * surrounded by redzones in ASAN. */
+    size_t const tableSpace = chainSize * sizeof(U32)
+                            + hSize * sizeof(U32)
+                            + h3Size * sizeof(U32);
+    size_t const optPotentialSpace =
+        ZSTD_cwksp_aligned_alloc_size((MaxML+1) * sizeof(U32))
+      + ZSTD_cwksp_aligned_alloc_size((MaxLL+1) * sizeof(U32))
+      + ZSTD_cwksp_aligned_alloc_size((MaxOff+1) * sizeof(U32))
+      + ZSTD_cwksp_aligned_alloc_size((1<<Litbits) * sizeof(U32))
+      + ZSTD_cwksp_aligned_alloc_size((ZSTD_OPT_NUM+1) * sizeof(ZSTD_match_t))
+      + ZSTD_cwksp_aligned_alloc_size((ZSTD_OPT_NUM+1) * sizeof(ZSTD_optimal_t));
+    size_t const lazyAdditionalSpace = ZSTD_rowMatchFinderUsed(cParams->strategy, useRowMatchFinder)
+                                            ? ZSTD_cwksp_aligned_alloc_size(hSize)
+                                            : 0;
+    size_t const optSpace = (forCCtx && (cParams->strategy >= ZSTD_btopt))
+                                ? optPotentialSpace
+                                : 0;
+    size_t const slackSpace = ZSTD_cwksp_slack_space_required();
+
+    /* tables are guaranteed to be sized in multiples of 64 bytes (or 16 uint32_t) */
+    ZSTD_STATIC_ASSERT(ZSTD_HASHLOG_MIN >= 4 && ZSTD_WINDOWLOG_MIN >= 4 && ZSTD_CHAINLOG_MIN >= 4);
+    assert(useRowMatchFinder != ZSTD_ps_auto);
+
+    DEBUGLOG(4, "chainSize: %u - hSize: %u - h3Size: %u",
+                (U32)chainSize, (U32)hSize, (U32)h3Size);
+    return tableSpace + optSpace + slackSpace + lazyAdditionalSpace;
+}
+
+/* Helper function for calculating memory requirements.
+ * Gives a tighter bound than ZSTD_sequenceBound() by taking minMatch into account. */
+static size_t ZSTD_maxNbSeq(size_t blockSize, unsigned minMatch, int useSequenceProducer) {
+    U32 const divider = (minMatch==3 || useSequenceProducer) ? 3 : 4;
+    return blockSize / divider;
+}
+
+static size_t ZSTD_estimateCCtxSize_usingCCtxParams_internal(
+        const ZSTD_compressionParameters* cParams,
+        const ldmParams_t* ldmParams,
+        const int isStatic,
+        const ZSTD_paramSwitch_e useRowMatchFinder,
+        const size_t buffInSize,
+        const size_t buffOutSize,
+        const U64 pledgedSrcSize,
+        int useSequenceProducer,
+        size_t maxBlockSize)
+{
+    size_t const windowSize = (size_t) BOUNDED(1ULL, 1ULL << cParams->windowLog, pledgedSrcSize);
+    size_t const blockSize = MIN(ZSTD_resolveMaxBlockSize(maxBlockSize), windowSize);
+    size_t const maxNbSeq = ZSTD_maxNbSeq(blockSize, cParams->minMatch, useSequenceProducer);
+    size_t const tokenSpace = ZSTD_cwksp_alloc_size(WILDCOPY_OVERLENGTH + blockSize)
+                            + ZSTD_cwksp_aligned_alloc_size(maxNbSeq * sizeof(seqDef))
+                            + 3 * ZSTD_cwksp_alloc_size(maxNbSeq * sizeof(BYTE));
+    size_t const entropySpace = ZSTD_cwksp_alloc_size(ENTROPY_WORKSPACE_SIZE);
+    size_t const blockStateSpace = 2 * ZSTD_cwksp_alloc_size(sizeof(ZSTD_compressedBlockState_t));
+    size_t const matchStateSize = ZSTD_sizeof_matchState(cParams, useRowMatchFinder, /* enableDedicatedDictSearch */ 0, /* forCCtx */ 1);
+
+    size_t const ldmSpace = ZSTD_ldm_getTableSize(*ldmParams);
+    size_t const maxNbLdmSeq = ZSTD_ldm_getMaxNbSeq(*ldmParams, blockSize);
+    size_t const ldmSeqSpace = ldmParams->enableLdm == ZSTD_ps_enable ?
+        ZSTD_cwksp_aligned_alloc_size(maxNbLdmSeq * sizeof(rawSeq)) : 0;
+
+
+    size_t const bufferSpace = ZSTD_cwksp_alloc_size(buffInSize)
+                             + ZSTD_cwksp_alloc_size(buffOutSize);
+
+    size_t const cctxSpace = isStatic ? ZSTD_cwksp_alloc_size(sizeof(ZSTD_CCtx)) : 0;
+
+    size_t const maxNbExternalSeq = ZSTD_sequenceBound(blockSize);
+    size_t const externalSeqSpace = useSequenceProducer
+        ? ZSTD_cwksp_aligned_alloc_size(maxNbExternalSeq * sizeof(ZSTD_Sequence))
+        : 0;
+
+    size_t const neededSpace =
+        cctxSpace +
+        entropySpace +
+        blockStateSpace +
+        ldmSpace +
+        ldmSeqSpace +
+        matchStateSize +
+        tokenSpace +
+        bufferSpace +
+        externalSeqSpace;
+
+    DEBUGLOG(5, "estimate workspace : %u", (U32)neededSpace);
+    return neededSpace;
+}
+
+size_t ZSTD_estimateCCtxSize_usingCCtxParams(const ZSTD_CCtx_params* params)
+{
+    ZSTD_compressionParameters const cParams =
+                ZSTD_getCParamsFromCCtxParams(params, ZSTD_CONTENTSIZE_UNKNOWN, 0, ZSTD_cpm_noAttachDict);
+    ZSTD_paramSwitch_e const useRowMatchFinder = ZSTD_resolveRowMatchFinderMode(params->useRowMatchFinder,
+                                                                               &cParams);
+
+    RETURN_ERROR_IF(params->nbWorkers > 0, GENERIC, "Estimate CCtx size is supported for single-threaded compression only.");
+    /* estimateCCtxSize is for one-shot compression. So no buffers should
+     * be needed. However, we still allocate two 0-sized buffers, which can
+     * take space under ASAN. */
+    return ZSTD_estimateCCtxSize_usingCCtxParams_internal(
+        &cParams, &params->ldmParams, 1, useRowMatchFinder, 0, 0, ZSTD_CONTENTSIZE_UNKNOWN, params->useSequenceProducer, params->maxBlockSize);
+}
+
+size_t ZSTD_estimateCCtxSize_usingCParams(ZSTD_compressionParameters cParams)
+{
+    ZSTD_CCtx_params initialParams = ZSTD_makeCCtxParamsFromCParams(cParams);
+    if (ZSTD_rowMatchFinderSupported(cParams.strategy)) {
+        /* Pick bigger of not using and using row-based matchfinder for greedy and lazy strategies */
+        size_t noRowCCtxSize;
+        size_t rowCCtxSize;
+        initialParams.useRowMatchFinder = ZSTD_ps_disable;
+        noRowCCtxSize = ZSTD_estimateCCtxSize_usingCCtxParams(&initialParams);
+        initialParams.useRowMatchFinder = ZSTD_ps_enable;
+        rowCCtxSize = ZSTD_estimateCCtxSize_usingCCtxParams(&initialParams);
+        return MAX(noRowCCtxSize, rowCCtxSize);
+    } else {
+        return ZSTD_estimateCCtxSize_usingCCtxParams(&initialParams);
+    }
+}
+
+static size_t ZSTD_estimateCCtxSize_internal(int compressionLevel)
+{
+    int tier = 0;
+    size_t largestSize = 0;
+    static const unsigned long long srcSizeTiers[4] = {16 KB, 128 KB, 256 KB, ZSTD_CONTENTSIZE_UNKNOWN};
+    for (; tier < 4; ++tier) {
+        /* Choose the set of cParams for a given level across all srcSizes that give the largest cctxSize */
+        ZSTD_compressionParameters const cParams = ZSTD_getCParams_internal(compressionLevel, srcSizeTiers[tier], 0, ZSTD_cpm_noAttachDict);
+        largestSize = MAX(ZSTD_estimateCCtxSize_usingCParams(cParams), largestSize);
+    }
+    return largestSize;
+}
+
+size_t ZSTD_estimateCCtxSize(int compressionLevel)
+{
+    int level;
+    size_t memBudget = 0;
+    for (level=MIN(compressionLevel, 1); level<=compressionLevel; level++) {
+        /* Ensure monotonically increasing memory usage as compression level increases */
+        size_t const newMB = ZSTD_estimateCCtxSize_internal(level);
+        if (newMB > memBudget) memBudget = newMB;
+    }
+    return memBudget;
+}
+
+size_t ZSTD_estimateCStreamSize_usingCCtxParams(const ZSTD_CCtx_params* params)
+{
+    RETURN_ERROR_IF(params->nbWorkers > 0, GENERIC, "Estimate CCtx size is supported for single-threaded compression only.");
+    {   ZSTD_compressionParameters const cParams =
+                ZSTD_getCParamsFromCCtxParams(params, ZSTD_CONTENTSIZE_UNKNOWN, 0, ZSTD_cpm_noAttachDict);
+        size_t const blockSize = MIN(ZSTD_resolveMaxBlockSize(params->maxBlockSize), (size_t)1 << cParams.windowLog);
+        size_t const inBuffSize = (params->inBufferMode == ZSTD_bm_buffered)
+                ? ((size_t)1 << cParams.windowLog) + blockSize
+                : 0;
+        size_t const outBuffSize = (params->outBufferMode == ZSTD_bm_buffered)
+                ? ZSTD_compressBound(blockSize) + 1
+                : 0;
+        ZSTD_paramSwitch_e const useRowMatchFinder = ZSTD_resolveRowMatchFinderMode(params->useRowMatchFinder, &params->cParams);
+
+        return ZSTD_estimateCCtxSize_usingCCtxParams_internal(
+            &cParams, &params->ldmParams, 1, useRowMatchFinder, inBuffSize, outBuffSize,
+            ZSTD_CONTENTSIZE_UNKNOWN, params->useSequenceProducer, params->maxBlockSize);
+    }
+}
+
+size_t ZSTD_estimateCStreamSize_usingCParams(ZSTD_compressionParameters cParams)
+{
+    ZSTD_CCtx_params initialParams = ZSTD_makeCCtxParamsFromCParams(cParams);
+    if (ZSTD_rowMatchFinderSupported(cParams.strategy)) {
+        /* Pick bigger of not using and using row-based matchfinder for greedy and lazy strategies */
+        size_t noRowCCtxSize;
+        size_t rowCCtxSize;
+        initialParams.useRowMatchFinder = ZSTD_ps_disable;
+        noRowCCtxSize = ZSTD_estimateCStreamSize_usingCCtxParams(&initialParams);
+        initialParams.useRowMatchFinder = ZSTD_ps_enable;
+        rowCCtxSize = ZSTD_estimateCStreamSize_usingCCtxParams(&initialParams);
+        return MAX(noRowCCtxSize, rowCCtxSize);
+    } else {
+        return ZSTD_estimateCStreamSize_usingCCtxParams(&initialParams);
+    }
+}
+
+static size_t ZSTD_estimateCStreamSize_internal(int compressionLevel)
+{
+    ZSTD_compressionParameters const cParams = ZSTD_getCParams_internal(compressionLevel, ZSTD_CONTENTSIZE_UNKNOWN, 0, ZSTD_cpm_noAttachDict);
+    return ZSTD_estimateCStreamSize_usingCParams(cParams);
+}
+
+size_t ZSTD_estimateCStreamSize(int compressionLevel)
+{
+    int level;
+    size_t memBudget = 0;
+    for (level=MIN(compressionLevel, 1); level<=compressionLevel; level++) {
+        size_t const newMB = ZSTD_estimateCStreamSize_internal(level);
+        if (newMB > memBudget) memBudget = newMB;
+    }
+    return memBudget;
+}
+
+/* ZSTD_getFrameProgression():
+ * tells how much data has been consumed (input) and produced (output) for current frame.
+ * able to count progression inside worker threads (non-blocking mode).
+ */
+ZSTD_frameProgression ZSTD_getFrameProgression(const ZSTD_CCtx* cctx)
+{
+#ifdef ZSTD_MULTITHREAD
+    if (cctx->appliedParams.nbWorkers > 0) {
+        return ZSTDMT_getFrameProgression(cctx->mtctx);
+    }
+#endif
+    {   ZSTD_frameProgression fp;
+        size_t const buffered = (cctx->inBuff == NULL) ? 0 :
+                                cctx->inBuffPos - cctx->inToCompress;
+        if (buffered) assert(cctx->inBuffPos >= cctx->inToCompress);
+        assert(buffered <= ZSTD_BLOCKSIZE_MAX);
+        fp.ingested = cctx->consumedSrcSize + buffered;
+        fp.consumed = cctx->consumedSrcSize;
+        fp.produced = cctx->producedCSize;
+        fp.flushed  = cctx->producedCSize;   /* simplified; some data might still be left within streaming output buffer */
+        fp.currentJobID = 0;
+        fp.nbActiveWorkers = 0;
+        return fp;
+}   }
+
+/*! ZSTD_toFlushNow()
+ *  Only useful for multithreading scenarios currently (nbWorkers >= 1).
+ */
+size_t ZSTD_toFlushNow(ZSTD_CCtx* cctx)
+{
+#ifdef ZSTD_MULTITHREAD
+    if (cctx->appliedParams.nbWorkers > 0) {
+        return ZSTDMT_toFlushNow(cctx->mtctx);
+    }
+#endif
+    (void)cctx;
+    return 0;   /* over-simplification; could also check if context is currently running in streaming mode, and in which case, report how many bytes are left to be flushed within output buffer */
+}
+
+static void ZSTD_assertEqualCParams(ZSTD_compressionParameters cParams1,
+                                    ZSTD_compressionParameters cParams2)
+{
+    (void)cParams1;
+    (void)cParams2;
+    assert(cParams1.windowLog    == cParams2.windowLog);
+    assert(cParams1.chainLog     == cParams2.chainLog);
+    assert(cParams1.hashLog      == cParams2.hashLog);
+    assert(cParams1.searchLog    == cParams2.searchLog);
+    assert(cParams1.minMatch     == cParams2.minMatch);
+    assert(cParams1.targetLength == cParams2.targetLength);
+    assert(cParams1.strategy     == cParams2.strategy);
+}
+
+void ZSTD_reset_compressedBlockState(ZSTD_compressedBlockState_t* bs)
+{
+    int i;
+    for (i = 0; i < ZSTD_REP_NUM; ++i)
+        bs->rep[i] = repStartValue[i];
+    bs->entropy.huf.repeatMode = HUF_repeat_none;
+    bs->entropy.fse.offcode_repeatMode = FSE_repeat_none;
+    bs->entropy.fse.matchlength_repeatMode = FSE_repeat_none;
+    bs->entropy.fse.litlength_repeatMode = FSE_repeat_none;
+}
+
+/*! ZSTD_invalidateMatchState()
+ *  Invalidate all the matches in the match finder tables.
+ *  Requires nextSrc and base to be set (can be NULL).
+ */
+static void ZSTD_invalidateMatchState(ZSTD_matchState_t* ms)
+{
+    ZSTD_window_clear(&ms->window);
+
+    ms->nextToUpdate = ms->window.dictLimit;
+    ms->loadedDictEnd = 0;
+    ms->opt.litLengthSum = 0;  /* force reset of btopt stats */
+    ms->dictMatchState = NULL;
+}
+
+/**
+ * Controls, for this matchState reset, whether the tables need to be cleared /
+ * prepared for the coming compression (ZSTDcrp_makeClean), or whether the
+ * tables can be left unclean (ZSTDcrp_leaveDirty), because we know that a
+ * subsequent operation will overwrite the table space anyways (e.g., copying
+ * the matchState contents in from a CDict).
+ */
+typedef enum {
+    ZSTDcrp_makeClean,
+    ZSTDcrp_leaveDirty
+} ZSTD_compResetPolicy_e;
+
+/**
+ * Controls, for this matchState reset, whether indexing can continue where it
+ * left off (ZSTDirp_continue), or whether it needs to be restarted from zero
+ * (ZSTDirp_reset).
+ */
+typedef enum {
+    ZSTDirp_continue,
+    ZSTDirp_reset
+} ZSTD_indexResetPolicy_e;
+
+typedef enum {
+    ZSTD_resetTarget_CDict,
+    ZSTD_resetTarget_CCtx
+} ZSTD_resetTarget_e;
+
+/* Mixes bits in a 64 bits in a value, based on XXH3_rrmxmx */
+static U64 ZSTD_bitmix(U64 val, U64 len) {
+    val ^= ZSTD_rotateRight_U64(val, 49) ^ ZSTD_rotateRight_U64(val, 24);
+    val *= 0x9FB21C651E98DF25ULL;
+    val ^= (val >> 35) + len ;
+    val *= 0x9FB21C651E98DF25ULL;
+    return val ^ (val >> 28);
+}
+
+/* Mixes in the hashSalt and hashSaltEntropy to create a new hashSalt */
+static void ZSTD_advanceHashSalt(ZSTD_matchState_t* ms) {
+    ms->hashSalt = ZSTD_bitmix(ms->hashSalt, 8) ^ ZSTD_bitmix((U64) ms->hashSaltEntropy, 4);
+}
+
+static size_t
+ZSTD_reset_matchState(ZSTD_matchState_t* ms,
+                      ZSTD_cwksp* ws,
+                const ZSTD_compressionParameters* cParams,
+                const ZSTD_paramSwitch_e useRowMatchFinder,
+                const ZSTD_compResetPolicy_e crp,
+                const ZSTD_indexResetPolicy_e forceResetIndex,
+                const ZSTD_resetTarget_e forWho)
+{
+    /* disable chain table allocation for fast or row-based strategies */
+    size_t const chainSize = ZSTD_allocateChainTable(cParams->strategy, useRowMatchFinder,
+                                                     ms->dedicatedDictSearch && (forWho == ZSTD_resetTarget_CDict))
+                                ? ((size_t)1 << cParams->chainLog)
+                                : 0;
+    size_t const hSize = ((size_t)1) << cParams->hashLog;
+    U32    const hashLog3 = ((forWho == ZSTD_resetTarget_CCtx) && cParams->minMatch==3) ? MIN(ZSTD_HASHLOG3_MAX, cParams->windowLog) : 0;
+    size_t const h3Size = hashLog3 ? ((size_t)1) << hashLog3 : 0;
+
+    DEBUGLOG(4, "reset indices : %u", forceResetIndex == ZSTDirp_reset);
+    assert(useRowMatchFinder != ZSTD_ps_auto);
+    if (forceResetIndex == ZSTDirp_reset) {
+        ZSTD_window_init(&ms->window);
+        ZSTD_cwksp_mark_tables_dirty(ws);
+    }
+
+    ms->hashLog3 = hashLog3;
+    ms->lazySkipping = 0;
+
+    ZSTD_invalidateMatchState(ms);
+
+    assert(!ZSTD_cwksp_reserve_failed(ws)); /* check that allocation hasn't already failed */
+
+    ZSTD_cwksp_clear_tables(ws);
+
+    DEBUGLOG(5, "reserving table space");
+    /* table Space */
+    ms->hashTable = (U32*)ZSTD_cwksp_reserve_table(ws, hSize * sizeof(U32));
+    ms->chainTable = (U32*)ZSTD_cwksp_reserve_table(ws, chainSize * sizeof(U32));
+    ms->hashTable3 = (U32*)ZSTD_cwksp_reserve_table(ws, h3Size * sizeof(U32));
+    RETURN_ERROR_IF(ZSTD_cwksp_reserve_failed(ws), memory_allocation,
+                    "failed a workspace allocation in ZSTD_reset_matchState");
+
+    DEBUGLOG(4, "reset table : %u", crp!=ZSTDcrp_leaveDirty);
+    if (crp!=ZSTDcrp_leaveDirty) {
+        /* reset tables only */
+        ZSTD_cwksp_clean_tables(ws);
+    }
+
+    if (ZSTD_rowMatchFinderUsed(cParams->strategy, useRowMatchFinder)) {
+        /* Row match finder needs an additional table of hashes ("tags") */
+        size_t const tagTableSize = hSize;
+        /* We want to generate a new salt in case we reset a Cctx, but we always want to use
+         * 0 when we reset a Cdict */
+        if(forWho == ZSTD_resetTarget_CCtx) {
+            ms->tagTable = (BYTE*) ZSTD_cwksp_reserve_aligned_init_once(ws, tagTableSize);
+            ZSTD_advanceHashSalt(ms);
+        } else {
+            /* When we are not salting we want to always memset the memory */
+            ms->tagTable = (BYTE*) ZSTD_cwksp_reserve_aligned(ws, tagTableSize);
+            ZSTD_memset(ms->tagTable, 0, tagTableSize);
+            ms->hashSalt = 0;
+        }
+        {   /* Switch to 32-entry rows if searchLog is 5 (or more) */
+            U32 const rowLog = BOUNDED(4, cParams->searchLog, 6);
+            assert(cParams->hashLog >= rowLog);
+            ms->rowHashLog = cParams->hashLog - rowLog;
+        }
+    }
+
+    /* opt parser space */
+    if ((forWho == ZSTD_resetTarget_CCtx) && (cParams->strategy >= ZSTD_btopt)) {
+        DEBUGLOG(4, "reserving optimal parser space");
+        ms->opt.litFreq = (unsigned*)ZSTD_cwksp_reserve_aligned(ws, (1<<Litbits) * sizeof(unsigned));
+        ms->opt.litLengthFreq = (unsigned*)ZSTD_cwksp_reserve_aligned(ws, (MaxLL+1) * sizeof(unsigned));
+        ms->opt.matchLengthFreq = (unsigned*)ZSTD_cwksp_reserve_aligned(ws, (MaxML+1) * sizeof(unsigned));
+        ms->opt.offCodeFreq = (unsigned*)ZSTD_cwksp_reserve_aligned(ws, (MaxOff+1) * sizeof(unsigned));
+        ms->opt.matchTable = (ZSTD_match_t*)ZSTD_cwksp_reserve_aligned(ws, (ZSTD_OPT_NUM+1) * sizeof(ZSTD_match_t));
+        ms->opt.priceTable = (ZSTD_optimal_t*)ZSTD_cwksp_reserve_aligned(ws, (ZSTD_OPT_NUM+1) * sizeof(ZSTD_optimal_t));
+    }
+
+    ms->cParams = *cParams;
+
+    RETURN_ERROR_IF(ZSTD_cwksp_reserve_failed(ws), memory_allocation,
+                    "failed a workspace allocation in ZSTD_reset_matchState");
+    return 0;
+}
+
+/* ZSTD_indexTooCloseToMax() :
+ * minor optimization : prefer memset() rather than reduceIndex()
+ * which is measurably slow in some circumstances (reported for Visual Studio).
+ * Works when re-using a context for a lot of smallish inputs :
+ * if all inputs are smaller than ZSTD_INDEXOVERFLOW_MARGIN,
+ * memset() will be triggered before reduceIndex().
+ */
+#define ZSTD_INDEXOVERFLOW_MARGIN (16 MB)
+static int ZSTD_indexTooCloseToMax(ZSTD_window_t w)
+{
+    return (size_t)(w.nextSrc - w.base) > (ZSTD_CURRENT_MAX - ZSTD_INDEXOVERFLOW_MARGIN);
+}
+
+/** ZSTD_dictTooBig():
+ * When dictionaries are larger than ZSTD_CHUNKSIZE_MAX they can't be loaded in
+ * one go generically. So we ensure that in that case we reset the tables to zero,
+ * so that we can load as much of the dictionary as possible.
+ */
+static int ZSTD_dictTooBig(size_t const loadedDictSize)
+{
+    return loadedDictSize > ZSTD_CHUNKSIZE_MAX;
+}
+
+/*! ZSTD_resetCCtx_internal() :
+ * @param loadedDictSize The size of the dictionary to be loaded
+ * into the context, if any. If no dictionary is used, or the
+ * dictionary is being attached / copied, then pass 0.
+ * note : `params` are assumed fully validated at this stage.
+ */
+static size_t ZSTD_resetCCtx_internal(ZSTD_CCtx* zc,
+                                      ZSTD_CCtx_params const* params,
+                                      U64 const pledgedSrcSize,
+                                      size_t const loadedDictSize,
+                                      ZSTD_compResetPolicy_e const crp,
+                                      ZSTD_buffered_policy_e const zbuff)
+{
+    ZSTD_cwksp* const ws = &zc->workspace;
+    DEBUGLOG(4, "ZSTD_resetCCtx_internal: pledgedSrcSize=%u, wlog=%u, useRowMatchFinder=%d useBlockSplitter=%d",
+                (U32)pledgedSrcSize, params->cParams.windowLog, (int)params->useRowMatchFinder, (int)params->useBlockSplitter);
+    assert(!ZSTD_isError(ZSTD_checkCParams(params->cParams)));
+
+    zc->isFirstBlock = 1;
+
+    /* Set applied params early so we can modify them for LDM,
+     * and point params at the applied params.
+     */
+    zc->appliedParams = *params;
+    params = &zc->appliedParams;
+
+    assert(params->useRowMatchFinder != ZSTD_ps_auto);
+    assert(params->useBlockSplitter != ZSTD_ps_auto);
+    assert(params->ldmParams.enableLdm != ZSTD_ps_auto);
+    assert(params->maxBlockSize != 0);
+    if (params->ldmParams.enableLdm == ZSTD_ps_enable) {
+        /* Adjust long distance matching parameters */
+        ZSTD_ldm_adjustParameters(&zc->appliedParams.ldmParams, &params->cParams);
+        assert(params->ldmParams.hashLog >= params->ldmParams.bucketSizeLog);
+        assert(params->ldmParams.hashRateLog < 32);
+    }
+
+    {   size_t const windowSize = MAX(1, (size_t)MIN(((U64)1 << params->cParams.windowLog), pledgedSrcSize));
+        size_t const blockSize = MIN(params->maxBlockSize, windowSize);
+        size_t const maxNbSeq = ZSTD_maxNbSeq(blockSize, params->cParams.minMatch, params->useSequenceProducer);
+        size_t const buffOutSize = (zbuff == ZSTDb_buffered && params->outBufferMode == ZSTD_bm_buffered)
+                ? ZSTD_compressBound(blockSize) + 1
+                : 0;
+        size_t const buffInSize = (zbuff == ZSTDb_buffered && params->inBufferMode == ZSTD_bm_buffered)
+                ? windowSize + blockSize
+                : 0;
+        size_t const maxNbLdmSeq = ZSTD_ldm_getMaxNbSeq(params->ldmParams, blockSize);
+
+        int const indexTooClose = ZSTD_indexTooCloseToMax(zc->blockState.matchState.window);
+        int const dictTooBig = ZSTD_dictTooBig(loadedDictSize);
+        ZSTD_indexResetPolicy_e needsIndexReset =
+            (indexTooClose || dictTooBig || !zc->initialized) ? ZSTDirp_reset : ZSTDirp_continue;
+
+        size_t const neededSpace =
+            ZSTD_estimateCCtxSize_usingCCtxParams_internal(
+                &params->cParams, &params->ldmParams, zc->staticSize != 0, params->useRowMatchFinder,
+                buffInSize, buffOutSize, pledgedSrcSize, params->useSequenceProducer, params->maxBlockSize);
+        int resizeWorkspace;
+
+        FORWARD_IF_ERROR(neededSpace, "cctx size estimate failed!");
+
+        if (!zc->staticSize) ZSTD_cwksp_bump_oversized_duration(ws, 0);
+
+        {   /* Check if workspace is large enough, alloc a new one if needed */
+            int const workspaceTooSmall = ZSTD_cwksp_sizeof(ws) < neededSpace;
+            int const workspaceWasteful = ZSTD_cwksp_check_wasteful(ws, neededSpace);
+            resizeWorkspace = workspaceTooSmall || workspaceWasteful;
+            DEBUGLOG(4, "Need %zu B workspace", neededSpace);
+            DEBUGLOG(4, "windowSize: %zu - blockSize: %zu", windowSize, blockSize);
+
+            if (resizeWorkspace) {
+                DEBUGLOG(4, "Resize workspaceSize from %zuKB to %zuKB",
+                            ZSTD_cwksp_sizeof(ws) >> 10,
+                            neededSpace >> 10);
+
+                RETURN_ERROR_IF(zc->staticSize, memory_allocation, "static cctx : no resize");
+
+                needsIndexReset = ZSTDirp_reset;
+
+                ZSTD_cwksp_free(ws, zc->customMem);
+                FORWARD_IF_ERROR(ZSTD_cwksp_create(ws, neededSpace, zc->customMem), "");
+
+                DEBUGLOG(5, "reserving object space");
+                /* Statically sized space.
+                 * entropyWorkspace never moves,
+                 * though prev/next block swap places */
+                assert(ZSTD_cwksp_check_available(ws, 2 * sizeof(ZSTD_compressedBlockState_t)));
+                zc->blockState.prevCBlock = (ZSTD_compressedBlockState_t*) ZSTD_cwksp_reserve_object(ws, sizeof(ZSTD_compressedBlockState_t));
+                RETURN_ERROR_IF(zc->blockState.prevCBlock == NULL, memory_allocation, "couldn't allocate prevCBlock");
+                zc->blockState.nextCBlock = (ZSTD_compressedBlockState_t*) ZSTD_cwksp_reserve_object(ws, sizeof(ZSTD_compressedBlockState_t));
+                RETURN_ERROR_IF(zc->blockState.nextCBlock == NULL, memory_allocation, "couldn't allocate nextCBlock");
+                zc->entropyWorkspace = (U32*) ZSTD_cwksp_reserve_object(ws, ENTROPY_WORKSPACE_SIZE);
+                RETURN_ERROR_IF(zc->entropyWorkspace == NULL, memory_allocation, "couldn't allocate entropyWorkspace");
+        }   }
+
+        ZSTD_cwksp_clear(ws);
+
+        /* init params */
+        zc->blockState.matchState.cParams = params->cParams;
+        zc->blockState.matchState.prefetchCDictTables = params->prefetchCDictTables == ZSTD_ps_enable;
+        zc->pledgedSrcSizePlusOne = pledgedSrcSize+1;
+        zc->consumedSrcSize = 0;
+        zc->producedCSize = 0;
+        if (pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN)
+            zc->appliedParams.fParams.contentSizeFlag = 0;
+        DEBUGLOG(4, "pledged content size : %u ; flag : %u",
+            (unsigned)pledgedSrcSize, zc->appliedParams.fParams.contentSizeFlag);
+        zc->blockSize = blockSize;
+
+        XXH64_reset(&zc->xxhState, 0);
+        zc->stage = ZSTDcs_init;
+        zc->dictID = 0;
+        zc->dictContentSize = 0;
+
+        ZSTD_reset_compressedBlockState(zc->blockState.prevCBlock);
+
+        FORWARD_IF_ERROR(ZSTD_reset_matchState(
+                &zc->blockState.matchState,
+                ws,
+                &params->cParams,
+                params->useRowMatchFinder,
+                crp,
+                needsIndexReset,
+                ZSTD_resetTarget_CCtx), "");
+
+        zc->seqStore.sequencesStart = (seqDef*)ZSTD_cwksp_reserve_aligned(ws, maxNbSeq * sizeof(seqDef));
+
+        /* ldm hash table */
+        if (params->ldmParams.enableLdm == ZSTD_ps_enable) {
+            /* TODO: avoid memset? */
+            size_t const ldmHSize = ((size_t)1) << params->ldmParams.hashLog;
+            zc->ldmState.hashTable = (ldmEntry_t*)ZSTD_cwksp_reserve_aligned(ws, ldmHSize * sizeof(ldmEntry_t));
+            ZSTD_memset(zc->ldmState.hashTable, 0, ldmHSize * sizeof(ldmEntry_t));
+            zc->ldmSequences = (rawSeq*)ZSTD_cwksp_reserve_aligned(ws, maxNbLdmSeq * sizeof(rawSeq));
+            zc->maxNbLdmSequences = maxNbLdmSeq;
+
+            ZSTD_window_init(&zc->ldmState.window);
+            zc->ldmState.loadedDictEnd = 0;
+        }
+
+        /* reserve space for block-level external sequences */
+        if (params->useSequenceProducer) {
+            size_t const maxNbExternalSeq = ZSTD_sequenceBound(blockSize);
+            zc->externalMatchCtx.seqBufferCapacity = maxNbExternalSeq;
+            zc->externalMatchCtx.seqBuffer =
+                (ZSTD_Sequence*)ZSTD_cwksp_reserve_aligned(ws, maxNbExternalSeq * sizeof(ZSTD_Sequence));
+        }
+
+        /* buffers */
+
+        /* ZSTD_wildcopy() is used to copy into the literals buffer,
+         * so we have to oversize the buffer by WILDCOPY_OVERLENGTH bytes.
+         */
+        zc->seqStore.litStart = ZSTD_cwksp_reserve_buffer(ws, blockSize + WILDCOPY_OVERLENGTH);
+        zc->seqStore.maxNbLit = blockSize;
+
+        zc->bufferedPolicy = zbuff;
+        zc->inBuffSize = buffInSize;
+        zc->inBuff = (char*)ZSTD_cwksp_reserve_buffer(ws, buffInSize);
+        zc->outBuffSize = buffOutSize;
+        zc->outBuff = (char*)ZSTD_cwksp_reserve_buffer(ws, buffOutSize);
+
+        /* ldm bucketOffsets table */
+        if (params->ldmParams.enableLdm == ZSTD_ps_enable) {
+            /* TODO: avoid memset? */
+            size_t const numBuckets =
+                  ((size_t)1) << (params->ldmParams.hashLog -
+                                  params->ldmParams.bucketSizeLog);
+            zc->ldmState.bucketOffsets = ZSTD_cwksp_reserve_buffer(ws, numBuckets);
+            ZSTD_memset(zc->ldmState.bucketOffsets, 0, numBuckets);
+        }
+
+        /* sequences storage */
+        ZSTD_referenceExternalSequences(zc, NULL, 0);
+        zc->seqStore.maxNbSeq = maxNbSeq;
+        zc->seqStore.llCode = ZSTD_cwksp_reserve_buffer(ws, maxNbSeq * sizeof(BYTE));
+        zc->seqStore.mlCode = ZSTD_cwksp_reserve_buffer(ws, maxNbSeq * sizeof(BYTE));
+        zc->seqStore.ofCode = ZSTD_cwksp_reserve_buffer(ws, maxNbSeq * sizeof(BYTE));
+
+        DEBUGLOG(3, "wksp: finished allocating, %zd bytes remain available", ZSTD_cwksp_available_space(ws));
+        assert(ZSTD_cwksp_estimated_space_within_bounds(ws, neededSpace));
+
+        zc->initialized = 1;
+
+        return 0;
+    }
+}
+
+/* ZSTD_invalidateRepCodes() :
+ * ensures next compression will not use repcodes from previous block.
+ * Note : only works with regular variant;
+ *        do not use with extDict variant ! */
+void ZSTD_invalidateRepCodes(ZSTD_CCtx* cctx) {
+    int i;
+    for (i=0; i<ZSTD_REP_NUM; i++) cctx->blockState.prevCBlock->rep[i] = 0;
+    assert(!ZSTD_window_hasExtDict(cctx->blockState.matchState.window));
+}
+
+/* These are the approximate sizes for each strategy past which copying the
+ * dictionary tables into the working context is faster than using them
+ * in-place.
+ */
+static const size_t attachDictSizeCutoffs[ZSTD_STRATEGY_MAX+1] = {
+    8 KB,  /* unused */
+    8 KB,  /* ZSTD_fast */
+    16 KB, /* ZSTD_dfast */
+    32 KB, /* ZSTD_greedy */
+    32 KB, /* ZSTD_lazy */
+    32 KB, /* ZSTD_lazy2 */
+    32 KB, /* ZSTD_btlazy2 */
+    32 KB, /* ZSTD_btopt */
+    8 KB,  /* ZSTD_btultra */
+    8 KB   /* ZSTD_btultra2 */
+};
+
+static int ZSTD_shouldAttachDict(const ZSTD_CDict* cdict,
+                                 const ZSTD_CCtx_params* params,
+                                 U64 pledgedSrcSize)
+{
+    size_t cutoff = attachDictSizeCutoffs[cdict->matchState.cParams.strategy];
+    int const dedicatedDictSearch = cdict->matchState.dedicatedDictSearch;
+    return dedicatedDictSearch
+        || ( ( pledgedSrcSize <= cutoff
+            || pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN
+            || params->attachDictPref == ZSTD_dictForceAttach )
+          && params->attachDictPref != ZSTD_dictForceCopy
+          && !params->forceWindow ); /* dictMatchState isn't correctly
+                                      * handled in _enforceMaxDist */
+}
+
+static size_t
+ZSTD_resetCCtx_byAttachingCDict(ZSTD_CCtx* cctx,
+                        const ZSTD_CDict* cdict,
+                        ZSTD_CCtx_params params,
+                        U64 pledgedSrcSize,
+                        ZSTD_buffered_policy_e zbuff)
+{
+    DEBUGLOG(4, "ZSTD_resetCCtx_byAttachingCDict() pledgedSrcSize=%llu",
+                (unsigned long long)pledgedSrcSize);
+    {
+        ZSTD_compressionParameters adjusted_cdict_cParams = cdict->matchState.cParams;
+        unsigned const windowLog = params.cParams.windowLog;
+        assert(windowLog != 0);
+        /* Resize working context table params for input only, since the dict
+         * has its own tables. */
+        /* pledgedSrcSize == 0 means 0! */
+
+        if (cdict->matchState.dedicatedDictSearch) {
+            ZSTD_dedicatedDictSearch_revertCParams(&adjusted_cdict_cParams);
+        }
+
+        params.cParams = ZSTD_adjustCParams_internal(adjusted_cdict_cParams, pledgedSrcSize,
+                                                     cdict->dictContentSize, ZSTD_cpm_attachDict,
+                                                     params.useRowMatchFinder);
+        params.cParams.windowLog = windowLog;
+        params.useRowMatchFinder = cdict->useRowMatchFinder;    /* cdict overrides */
+        FORWARD_IF_ERROR(ZSTD_resetCCtx_internal(cctx, &params, pledgedSrcSize,
+                                                 /* loadedDictSize */ 0,
+                                                 ZSTDcrp_makeClean, zbuff), "");
+        assert(cctx->appliedParams.cParams.strategy == adjusted_cdict_cParams.strategy);
+    }
+
+    {   const U32 cdictEnd = (U32)( cdict->matchState.window.nextSrc
+                                  - cdict->matchState.window.base);
+        const U32 cdictLen = cdictEnd - cdict->matchState.window.dictLimit;
+        if (cdictLen == 0) {
+            /* don't even attach dictionaries with no contents */
+            DEBUGLOG(4, "skipping attaching empty dictionary");
+        } else {
+            DEBUGLOG(4, "attaching dictionary into context");
+            cctx->blockState.matchState.dictMatchState = &cdict->matchState;
+
+            /* prep working match state so dict matches never have negative indices
+             * when they are translated to the working context's index space. */
+            if (cctx->blockState.matchState.window.dictLimit < cdictEnd) {
+                cctx->blockState.matchState.window.nextSrc =
+                    cctx->blockState.matchState.window.base + cdictEnd;
+                ZSTD_window_clear(&cctx->blockState.matchState.window);
+            }
+            /* loadedDictEnd is expressed within the referential of the active context */
+            cctx->blockState.matchState.loadedDictEnd = cctx->blockState.matchState.window.dictLimit;
+    }   }
+
+    cctx->dictID = cdict->dictID;
+    cctx->dictContentSize = cdict->dictContentSize;
+
+    /* copy block state */
+    ZSTD_memcpy(cctx->blockState.prevCBlock, &cdict->cBlockState, sizeof(cdict->cBlockState));
+
+    return 0;
+}
+
+static void ZSTD_copyCDictTableIntoCCtx(U32* dst, U32 const* src, size_t tableSize,
+                                        ZSTD_compressionParameters const* cParams) {
+    if (ZSTD_CDictIndicesAreTagged(cParams)){
+        /* Remove tags from the CDict table if they are present.
+         * See docs on "short cache" in zstd_compress_internal.h for context. */
+        size_t i;
+        for (i = 0; i < tableSize; i++) {
+            U32 const taggedIndex = src[i];
+            U32 const index = taggedIndex >> ZSTD_SHORT_CACHE_TAG_BITS;
+            dst[i] = index;
+        }
+    } else {
+        ZSTD_memcpy(dst, src, tableSize * sizeof(U32));
+    }
+}
+
+static size_t ZSTD_resetCCtx_byCopyingCDict(ZSTD_CCtx* cctx,
+                            const ZSTD_CDict* cdict,
+                            ZSTD_CCtx_params params,
+                            U64 pledgedSrcSize,
+                            ZSTD_buffered_policy_e zbuff)
+{
+    const ZSTD_compressionParameters *cdict_cParams = &cdict->matchState.cParams;
+
+    assert(!cdict->matchState.dedicatedDictSearch);
+    DEBUGLOG(4, "ZSTD_resetCCtx_byCopyingCDict() pledgedSrcSize=%llu",
+                (unsigned long long)pledgedSrcSize);
+
+    {   unsigned const windowLog = params.cParams.windowLog;
+        assert(windowLog != 0);
+        /* Copy only compression parameters related to tables. */
+        params.cParams = *cdict_cParams;
+        params.cParams.windowLog = windowLog;
+        params.useRowMatchFinder = cdict->useRowMatchFinder;
+        FORWARD_IF_ERROR(ZSTD_resetCCtx_internal(cctx, &params, pledgedSrcSize,
+                                                 /* loadedDictSize */ 0,
+                                                 ZSTDcrp_leaveDirty, zbuff), "");
+        assert(cctx->appliedParams.cParams.strategy == cdict_cParams->strategy);
+        assert(cctx->appliedParams.cParams.hashLog == cdict_cParams->hashLog);
+        assert(cctx->appliedParams.cParams.chainLog == cdict_cParams->chainLog);
+    }
+
+    ZSTD_cwksp_mark_tables_dirty(&cctx->workspace);
+    assert(params.useRowMatchFinder != ZSTD_ps_auto);
+
+    /* copy tables */
+    {   size_t const chainSize = ZSTD_allocateChainTable(cdict_cParams->strategy, cdict->useRowMatchFinder, 0 /* DDS guaranteed disabled */)
+                                                            ? ((size_t)1 << cdict_cParams->chainLog)
+                                                            : 0;
+        size_t const hSize =  (size_t)1 << cdict_cParams->hashLog;
+
+        ZSTD_copyCDictTableIntoCCtx(cctx->blockState.matchState.hashTable,
+                                cdict->matchState.hashTable,
+                                hSize, cdict_cParams);
+
+        /* Do not copy cdict's chainTable if cctx has parameters such that it would not use chainTable */
+        if (ZSTD_allocateChainTable(cctx->appliedParams.cParams.strategy, cctx->appliedParams.useRowMatchFinder, 0 /* forDDSDict */)) {
+            ZSTD_copyCDictTableIntoCCtx(cctx->blockState.matchState.chainTable,
+                                    cdict->matchState.chainTable,
+                                    chainSize, cdict_cParams);
+        }
+        /* copy tag table */
+        if (ZSTD_rowMatchFinderUsed(cdict_cParams->strategy, cdict->useRowMatchFinder)) {
+            size_t const tagTableSize = hSize;
+            ZSTD_memcpy(cctx->blockState.matchState.tagTable,
+                        cdict->matchState.tagTable,
+                        tagTableSize);
+            cctx->blockState.matchState.hashSalt = cdict->matchState.hashSalt;
+        }
+    }
+
+    /* Zero the hashTable3, since the cdict never fills it */
+    {   int const h3log = cctx->blockState.matchState.hashLog3;
+        size_t const h3Size = h3log ? ((size_t)1 << h3log) : 0;
+        assert(cdict->matchState.hashLog3 == 0);
+        ZSTD_memset(cctx->blockState.matchState.hashTable3, 0, h3Size * sizeof(U32));
+    }
+
+    ZSTD_cwksp_mark_tables_clean(&cctx->workspace);
+
+    /* copy dictionary offsets */
+    {   ZSTD_matchState_t const* srcMatchState = &cdict->matchState;
+        ZSTD_matchState_t* dstMatchState = &cctx->blockState.matchState;
+        dstMatchState->window       = srcMatchState->window;
+        dstMatchState->nextToUpdate = srcMatchState->nextToUpdate;
+        dstMatchState->loadedDictEnd= srcMatchState->loadedDictEnd;
+    }
+
+    cctx->dictID = cdict->dictID;
+    cctx->dictContentSize = cdict->dictContentSize;
+
+    /* copy block state */
+    ZSTD_memcpy(cctx->blockState.prevCBlock, &cdict->cBlockState, sizeof(cdict->cBlockState));
+
+    return 0;
+}
+
+/* We have a choice between copying the dictionary context into the working
+ * context, or referencing the dictionary context from the working context
+ * in-place. We decide here which strategy to use. */
+static size_t ZSTD_resetCCtx_usingCDict(ZSTD_CCtx* cctx,
+                            const ZSTD_CDict* cdict,
+                            const ZSTD_CCtx_params* params,
+                            U64 pledgedSrcSize,
+                            ZSTD_buffered_policy_e zbuff)
+{
+
+    DEBUGLOG(4, "ZSTD_resetCCtx_usingCDict (pledgedSrcSize=%u)",
+                (unsigned)pledgedSrcSize);
+
+    if (ZSTD_shouldAttachDict(cdict, params, pledgedSrcSize)) {
+        return ZSTD_resetCCtx_byAttachingCDict(
+            cctx, cdict, *params, pledgedSrcSize, zbuff);
+    } else {
+        return ZSTD_resetCCtx_byCopyingCDict(
+            cctx, cdict, *params, pledgedSrcSize, zbuff);
+    }
+}
+
+/*! ZSTD_copyCCtx_internal() :
+ *  Duplicate an existing context `srcCCtx` into another one `dstCCtx`.
+ *  Only works during stage ZSTDcs_init (i.e. after creation, but before first call to ZSTD_compressContinue()).
+ *  The "context", in this case, refers to the hash and chain tables,
+ *  entropy tables, and dictionary references.
+ * `windowLog` value is enforced if != 0, otherwise value is copied from srcCCtx.
+ * @return : 0, or an error code */
+static size_t ZSTD_copyCCtx_internal(ZSTD_CCtx* dstCCtx,
+                            const ZSTD_CCtx* srcCCtx,
+                            ZSTD_frameParameters fParams,
+                            U64 pledgedSrcSize,
+                            ZSTD_buffered_policy_e zbuff)
+{
+    RETURN_ERROR_IF(srcCCtx->stage!=ZSTDcs_init, stage_wrong,
+                    "Can't copy a ctx that's not in init stage.");
+    DEBUGLOG(5, "ZSTD_copyCCtx_internal");
+    ZSTD_memcpy(&dstCCtx->customMem, &srcCCtx->customMem, sizeof(ZSTD_customMem));
+    {   ZSTD_CCtx_params params = dstCCtx->requestedParams;
+        /* Copy only compression parameters related to tables. */
+        params.cParams = srcCCtx->appliedParams.cParams;
+        assert(srcCCtx->appliedParams.useRowMatchFinder != ZSTD_ps_auto);
+        assert(srcCCtx->appliedParams.useBlockSplitter != ZSTD_ps_auto);
+        assert(srcCCtx->appliedParams.ldmParams.enableLdm != ZSTD_ps_auto);
+        params.useRowMatchFinder = srcCCtx->appliedParams.useRowMatchFinder;
+        params.useBlockSplitter = srcCCtx->appliedParams.useBlockSplitter;
+        params.ldmParams = srcCCtx->appliedParams.ldmParams;
+        params.fParams = fParams;
+        params.maxBlockSize = srcCCtx->appliedParams.maxBlockSize;
+        ZSTD_resetCCtx_internal(dstCCtx, &params, pledgedSrcSize,
+                                /* loadedDictSize */ 0,
+                                ZSTDcrp_leaveDirty, zbuff);
+        assert(dstCCtx->appliedParams.cParams.windowLog == srcCCtx->appliedParams.cParams.windowLog);
+        assert(dstCCtx->appliedParams.cParams.strategy == srcCCtx->appliedParams.cParams.strategy);
+        assert(dstCCtx->appliedParams.cParams.hashLog == srcCCtx->appliedParams.cParams.hashLog);
+        assert(dstCCtx->appliedParams.cParams.chainLog == srcCCtx->appliedParams.cParams.chainLog);
+        assert(dstCCtx->blockState.matchState.hashLog3 == srcCCtx->blockState.matchState.hashLog3);
+    }
+
+    ZSTD_cwksp_mark_tables_dirty(&dstCCtx->workspace);
+
+    /* copy tables */
+    {   size_t const chainSize = ZSTD_allocateChainTable(srcCCtx->appliedParams.cParams.strategy,
+                                                         srcCCtx->appliedParams.useRowMatchFinder,
+                                                         0 /* forDDSDict */)
+                                    ? ((size_t)1 << srcCCtx->appliedParams.cParams.chainLog)
+                                    : 0;
+        size_t const hSize =  (size_t)1 << srcCCtx->appliedParams.cParams.hashLog;
+        int const h3log = srcCCtx->blockState.matchState.hashLog3;
+        size_t const h3Size = h3log ? ((size_t)1 << h3log) : 0;
+
+        ZSTD_memcpy(dstCCtx->blockState.matchState.hashTable,
+               srcCCtx->blockState.matchState.hashTable,
+               hSize * sizeof(U32));
+        ZSTD_memcpy(dstCCtx->blockState.matchState.chainTable,
+               srcCCtx->blockState.matchState.chainTable,
+               chainSize * sizeof(U32));
+        ZSTD_memcpy(dstCCtx->blockState.matchState.hashTable3,
+               srcCCtx->blockState.matchState.hashTable3,
+               h3Size * sizeof(U32));
+    }
+
+    ZSTD_cwksp_mark_tables_clean(&dstCCtx->workspace);
+
+    /* copy dictionary offsets */
+    {
+        const ZSTD_matchState_t* srcMatchState = &srcCCtx->blockState.matchState;
+        ZSTD_matchState_t* dstMatchState = &dstCCtx->blockState.matchState;
+        dstMatchState->window       = srcMatchState->window;
+        dstMatchState->nextToUpdate = srcMatchState->nextToUpdate;
+        dstMatchState->loadedDictEnd= srcMatchState->loadedDictEnd;
+    }
+    dstCCtx->dictID = srcCCtx->dictID;
+    dstCCtx->dictContentSize = srcCCtx->dictContentSize;
+
+    /* copy block state */
+    ZSTD_memcpy(dstCCtx->blockState.prevCBlock, srcCCtx->blockState.prevCBlock, sizeof(*srcCCtx->blockState.prevCBlock));
+
+    return 0;
+}
+
+/*! ZSTD_copyCCtx() :
+ *  Duplicate an existing context `srcCCtx` into another one `dstCCtx`.
+ *  Only works during stage ZSTDcs_init (i.e. after creation, but before first call to ZSTD_compressContinue()).
+ *  pledgedSrcSize==0 means "unknown".
+*   @return : 0, or an error code */
+size_t ZSTD_copyCCtx(ZSTD_CCtx* dstCCtx, const ZSTD_CCtx* srcCCtx, unsigned long long pledgedSrcSize)
+{
+    ZSTD_frameParameters fParams = { 1 /*content*/, 0 /*checksum*/, 0 /*noDictID*/ };
+    ZSTD_buffered_policy_e const zbuff = srcCCtx->bufferedPolicy;
+    ZSTD_STATIC_ASSERT((U32)ZSTDb_buffered==1);
+    if (pledgedSrcSize==0) pledgedSrcSize = ZSTD_CONTENTSIZE_UNKNOWN;
+    fParams.contentSizeFlag = (pledgedSrcSize != ZSTD_CONTENTSIZE_UNKNOWN);
+
+    return ZSTD_copyCCtx_internal(dstCCtx, srcCCtx,
+                                fParams, pledgedSrcSize,
+                                zbuff);
+}
+
+
+#define ZSTD_ROWSIZE 16
+/*! ZSTD_reduceTable() :
+ *  reduce table indexes by `reducerValue`, or squash to zero.
+ *  PreserveMark preserves "unsorted mark" for btlazy2 strategy.
+ *  It must be set to a clear 0/1 value, to remove branch during inlining.
+ *  Presume table size is a multiple of ZSTD_ROWSIZE
+ *  to help auto-vectorization */
+FORCE_INLINE_TEMPLATE void
+ZSTD_reduceTable_internal (U32* const table, U32 const size, U32 const reducerValue, int const preserveMark)
+{
+    int const nbRows = (int)size / ZSTD_ROWSIZE;
+    int cellNb = 0;
+    int rowNb;
+    /* Protect special index values < ZSTD_WINDOW_START_INDEX. */
+    U32 const reducerThreshold = reducerValue + ZSTD_WINDOW_START_INDEX;
+    assert((size & (ZSTD_ROWSIZE-1)) == 0);  /* multiple of ZSTD_ROWSIZE */
+    assert(size < (1U<<31));   /* can be casted to int */
+
+#if ZSTD_MEMORY_SANITIZER && !defined (ZSTD_MSAN_DONT_POISON_WORKSPACE)
+    /* To validate that the table re-use logic is sound, and that we don't
+     * access table space that we haven't cleaned, we re-"poison" the table
+     * space every time we mark it dirty.
+     *
+     * This function however is intended to operate on those dirty tables and
+     * re-clean them. So when this function is used correctly, we can unpoison
+     * the memory it operated on. This introduces a blind spot though, since
+     * if we now try to operate on __actually__ poisoned memory, we will not
+     * detect that. */
+    __msan_unpoison(table, size * sizeof(U32));
+#endif
+
+    for (rowNb=0 ; rowNb < nbRows ; rowNb++) {
+        int column;
+        for (column=0; column<ZSTD_ROWSIZE; column++) {
+            U32 newVal;
+            if (preserveMark && table[cellNb] == ZSTD_DUBT_UNSORTED_MARK) {
+                /* This write is pointless, but is required(?) for the compiler
+                 * to auto-vectorize the loop. */
+                newVal = ZSTD_DUBT_UNSORTED_MARK;
+            } else if (table[cellNb] < reducerThreshold) {
+                newVal = 0;
+            } else {
+                newVal = table[cellNb] - reducerValue;
+            }
+            table[cellNb] = newVal;
+            cellNb++;
+    }   }
+}
+
+static void ZSTD_reduceTable(U32* const table, U32 const size, U32 const reducerValue)
+{
+    ZSTD_reduceTable_internal(table, size, reducerValue, 0);
+}
+
+static void ZSTD_reduceTable_btlazy2(U32* const table, U32 const size, U32 const reducerValue)
+{
+    ZSTD_reduceTable_internal(table, size, reducerValue, 1);
+}
+
+/*! ZSTD_reduceIndex() :
+*   rescale all indexes to avoid future overflow (indexes are U32) */
+static void ZSTD_reduceIndex (ZSTD_matchState_t* ms, ZSTD_CCtx_params const* params, const U32 reducerValue)
+{
+    {   U32 const hSize = (U32)1 << params->cParams.hashLog;
+        ZSTD_reduceTable(ms->hashTable, hSize, reducerValue);
+    }
+
+    if (ZSTD_allocateChainTable(params->cParams.strategy, params->useRowMatchFinder, (U32)ms->dedicatedDictSearch)) {
+        U32 const chainSize = (U32)1 << params->cParams.chainLog;
+        if (params->cParams.strategy == ZSTD_btlazy2)
+            ZSTD_reduceTable_btlazy2(ms->chainTable, chainSize, reducerValue);
+        else
+            ZSTD_reduceTable(ms->chainTable, chainSize, reducerValue);
+    }
+
+    if (ms->hashLog3) {
+        U32 const h3Size = (U32)1 << ms->hashLog3;
+        ZSTD_reduceTable(ms->hashTable3, h3Size, reducerValue);
+    }
+}
+
+
+/*-*******************************************************
+*  Block entropic compression
+*********************************************************/
+
+/* See doc/zstd_compression_format.md for detailed format description */
+
+int ZSTD_seqToCodes(const seqStore_t* seqStorePtr)
+{
+    const seqDef* const sequences = seqStorePtr->sequencesStart;
+    BYTE* const llCodeTable = seqStorePtr->llCode;
+    BYTE* const ofCodeTable = seqStorePtr->ofCode;
+    BYTE* const mlCodeTable = seqStorePtr->mlCode;
+    U32 const nbSeq = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);
+    U32 u;
+    int longOffsets = 0;
+    assert(nbSeq <= seqStorePtr->maxNbSeq);
+    for (u=0; u<nbSeq; u++) {
+        U32 const llv = sequences[u].litLength;
+        U32 const ofCode = ZSTD_highbit32(sequences[u].offBase);
+        U32 const mlv = sequences[u].mlBase;
+        llCodeTable[u] = (BYTE)ZSTD_LLcode(llv);
+        ofCodeTable[u] = (BYTE)ofCode;
+        mlCodeTable[u] = (BYTE)ZSTD_MLcode(mlv);
+        assert(!(MEM_64bits() && ofCode >= STREAM_ACCUMULATOR_MIN));
+        if (MEM_32bits() && ofCode >= STREAM_ACCUMULATOR_MIN)
+            longOffsets = 1;
+    }
+    if (seqStorePtr->longLengthType==ZSTD_llt_literalLength)
+        llCodeTable[seqStorePtr->longLengthPos] = MaxLL;
+    if (seqStorePtr->longLengthType==ZSTD_llt_matchLength)
+        mlCodeTable[seqStorePtr->longLengthPos] = MaxML;
+    return longOffsets;
+}
+
+/* ZSTD_useTargetCBlockSize():
+ * Returns if target compressed block size param is being used.
+ * If used, compression will do best effort to make a compressed block size to be around targetCBlockSize.
+ * Returns 1 if true, 0 otherwise. */
+static int ZSTD_useTargetCBlockSize(const ZSTD_CCtx_params* cctxParams)
+{
+    DEBUGLOG(5, "ZSTD_useTargetCBlockSize (targetCBlockSize=%zu)", cctxParams->targetCBlockSize);
+    return (cctxParams->targetCBlockSize != 0);
+}
+
+/* ZSTD_blockSplitterEnabled():
+ * Returns if block splitting param is being used
+ * If used, compression will do best effort to split a block in order to improve compression ratio.
+ * At the time this function is called, the parameter must be finalized.
+ * Returns 1 if true, 0 otherwise. */
+static int ZSTD_blockSplitterEnabled(ZSTD_CCtx_params* cctxParams)
+{
+    DEBUGLOG(5, "ZSTD_blockSplitterEnabled (useBlockSplitter=%d)", cctxParams->useBlockSplitter);
+    assert(cctxParams->useBlockSplitter != ZSTD_ps_auto);
+    return (cctxParams->useBlockSplitter == ZSTD_ps_enable);
+}
+
+/* Type returned by ZSTD_buildSequencesStatistics containing finalized symbol encoding types
+ * and size of the sequences statistics
+ */
+typedef struct {
+    U32 LLtype;
+    U32 Offtype;
+    U32 MLtype;
+    size_t size;
+    size_t lastCountSize; /* Accounts for bug in 1.3.4. More detail in ZSTD_entropyCompressSeqStore_internal() */
+    int longOffsets;
+} ZSTD_symbolEncodingTypeStats_t;
+
+/* ZSTD_buildSequencesStatistics():
+ * Returns a ZSTD_symbolEncodingTypeStats_t, or a zstd error code in the `size` field.
+ * Modifies `nextEntropy` to have the appropriate values as a side effect.
+ * nbSeq must be greater than 0.
+ *
+ * entropyWkspSize must be of size at least ENTROPY_WORKSPACE_SIZE - (MaxSeq + 1)*sizeof(U32)
+ */
+static ZSTD_symbolEncodingTypeStats_t
+ZSTD_buildSequencesStatistics(
+                const seqStore_t* seqStorePtr, size_t nbSeq,
+                const ZSTD_fseCTables_t* prevEntropy, ZSTD_fseCTables_t* nextEntropy,
+                      BYTE* dst, const BYTE* const dstEnd,
+                      ZSTD_strategy strategy, unsigned* countWorkspace,
+                      void* entropyWorkspace, size_t entropyWkspSize)
+{
+    BYTE* const ostart = dst;
+    const BYTE* const oend = dstEnd;
+    BYTE* op = ostart;
+    FSE_CTable* CTable_LitLength = nextEntropy->litlengthCTable;
+    FSE_CTable* CTable_OffsetBits = nextEntropy->offcodeCTable;
+    FSE_CTable* CTable_MatchLength = nextEntropy->matchlengthCTable;
+    const BYTE* const ofCodeTable = seqStorePtr->ofCode;
+    const BYTE* const llCodeTable = seqStorePtr->llCode;
+    const BYTE* const mlCodeTable = seqStorePtr->mlCode;
+    ZSTD_symbolEncodingTypeStats_t stats;
+
+    stats.lastCountSize = 0;
+    /* convert length/distances into codes */
+    stats.longOffsets = ZSTD_seqToCodes(seqStorePtr);
+    assert(op <= oend);
+    assert(nbSeq != 0); /* ZSTD_selectEncodingType() divides by nbSeq */
+    /* build CTable for Literal Lengths */
+    {   unsigned max = MaxLL;
+        size_t const mostFrequent = HIST_countFast_wksp(countWorkspace, &max, llCodeTable, nbSeq, entropyWorkspace, entropyWkspSize);   /* can't fail */
+        DEBUGLOG(5, "Building LL table");
+        nextEntropy->litlength_repeatMode = prevEntropy->litlength_repeatMode;
+        stats.LLtype = ZSTD_selectEncodingType(&nextEntropy->litlength_repeatMode,
+                                        countWorkspace, max, mostFrequent, nbSeq,
+                                        LLFSELog, prevEntropy->litlengthCTable,
+                                        LL_defaultNorm, LL_defaultNormLog,
+                                        ZSTD_defaultAllowed, strategy);
+        assert(set_basic < set_compressed && set_rle < set_compressed);
+        assert(!(stats.LLtype < set_compressed && nextEntropy->litlength_repeatMode != FSE_repeat_none)); /* We don't copy tables */
+        {   size_t const countSize = ZSTD_buildCTable(
+                op, (size_t)(oend - op),
+                CTable_LitLength, LLFSELog, (symbolEncodingType_e)stats.LLtype,
+                countWorkspace, max, llCodeTable, nbSeq,
+                LL_defaultNorm, LL_defaultNormLog, MaxLL,
+                prevEntropy->litlengthCTable,
+                sizeof(prevEntropy->litlengthCTable),
+                entropyWorkspace, entropyWkspSize);
+            if (ZSTD_isError(countSize)) {
+                DEBUGLOG(3, "ZSTD_buildCTable for LitLens failed");
+                stats.size = countSize;
+                return stats;
+            }
+            if (stats.LLtype == set_compressed)
+                stats.lastCountSize = countSize;
+            op += countSize;
+            assert(op <= oend);
+    }   }
+    /* build CTable for Offsets */
+    {   unsigned max = MaxOff;
+        size_t const mostFrequent = HIST_countFast_wksp(
+            countWorkspace, &max, ofCodeTable, nbSeq, entropyWorkspace, entropyWkspSize);  /* can't fail */
+        /* We can only use the basic table if max <= DefaultMaxOff, otherwise the offsets are too large */
+        ZSTD_defaultPolicy_e const defaultPolicy = (max <= DefaultMaxOff) ? ZSTD_defaultAllowed : ZSTD_defaultDisallowed;
+        DEBUGLOG(5, "Building OF table");
+        nextEntropy->offcode_repeatMode = prevEntropy->offcode_repeatMode;
+        stats.Offtype = ZSTD_selectEncodingType(&nextEntropy->offcode_repeatMode,
+                                        countWorkspace, max, mostFrequent, nbSeq,
+                                        OffFSELog, prevEntropy->offcodeCTable,
+                                        OF_defaultNorm, OF_defaultNormLog,
+                                        defaultPolicy, strategy);
+        assert(!(stats.Offtype < set_compressed && nextEntropy->offcode_repeatMode != FSE_repeat_none)); /* We don't copy tables */
+        {   size_t const countSize = ZSTD_buildCTable(
+                op, (size_t)(oend - op),
+                CTable_OffsetBits, OffFSELog, (symbolEncodingType_e)stats.Offtype,
+                countWorkspace, max, ofCodeTable, nbSeq,
+                OF_defaultNorm, OF_defaultNormLog, DefaultMaxOff,
+                prevEntropy->offcodeCTable,
+                sizeof(prevEntropy->offcodeCTable),
+                entropyWorkspace, entropyWkspSize);
+            if (ZSTD_isError(countSize)) {
+                DEBUGLOG(3, "ZSTD_buildCTable for Offsets failed");
+                stats.size = countSize;
+                return stats;
+            }
+            if (stats.Offtype == set_compressed)
+                stats.lastCountSize = countSize;
+            op += countSize;
+            assert(op <= oend);
+    }   }
+    /* build CTable for MatchLengths */
+    {   unsigned max = MaxML;
+        size_t const mostFrequent = HIST_countFast_wksp(
+            countWorkspace, &max, mlCodeTable, nbSeq, entropyWorkspace, entropyWkspSize);   /* can't fail */
+        DEBUGLOG(5, "Building ML table (remaining space : %i)", (int)(oend-op));
+        nextEntropy->matchlength_repeatMode = prevEntropy->matchlength_repeatMode;
+        stats.MLtype = ZSTD_selectEncodingType(&nextEntropy->matchlength_repeatMode,
+                                        countWorkspace, max, mostFrequent, nbSeq,
+                                        MLFSELog, prevEntropy->matchlengthCTable,
+                                        ML_defaultNorm, ML_defaultNormLog,
+                                        ZSTD_defaultAllowed, strategy);
+        assert(!(stats.MLtype < set_compressed && nextEntropy->matchlength_repeatMode != FSE_repeat_none)); /* We don't copy tables */
+        {   size_t const countSize = ZSTD_buildCTable(
+                op, (size_t)(oend - op),
+                CTable_MatchLength, MLFSELog, (symbolEncodingType_e)stats.MLtype,
+                countWorkspace, max, mlCodeTable, nbSeq,
+                ML_defaultNorm, ML_defaultNormLog, MaxML,
+                prevEntropy->matchlengthCTable,
+                sizeof(prevEntropy->matchlengthCTable),
+                entropyWorkspace, entropyWkspSize);
+            if (ZSTD_isError(countSize)) {
+                DEBUGLOG(3, "ZSTD_buildCTable for MatchLengths failed");
+                stats.size = countSize;
+                return stats;
+            }
+            if (stats.MLtype == set_compressed)
+                stats.lastCountSize = countSize;
+            op += countSize;
+            assert(op <= oend);
+    }   }
+    stats.size = (size_t)(op-ostart);
+    return stats;
+}
+
+/* ZSTD_entropyCompressSeqStore_internal():
+ * compresses both literals and sequences
+ * Returns compressed size of block, or a zstd error.
+ */
+#define SUSPECT_UNCOMPRESSIBLE_LITERAL_RATIO 20
+MEM_STATIC size_t
+ZSTD_entropyCompressSeqStore_internal(
+                        const seqStore_t* seqStorePtr,
+                        const ZSTD_entropyCTables_t* prevEntropy,
+                              ZSTD_entropyCTables_t* nextEntropy,
+                        const ZSTD_CCtx_params* cctxParams,
+                              void* dst, size_t dstCapacity,
+                              void* entropyWorkspace, size_t entropyWkspSize,
+                        const int bmi2)
+{
+    ZSTD_strategy const strategy = cctxParams->cParams.strategy;
+    unsigned* count = (unsigned*)entropyWorkspace;
+    FSE_CTable* CTable_LitLength = nextEntropy->fse.litlengthCTable;
+    FSE_CTable* CTable_OffsetBits = nextEntropy->fse.offcodeCTable;
+    FSE_CTable* CTable_MatchLength = nextEntropy->fse.matchlengthCTable;
+    const seqDef* const sequences = seqStorePtr->sequencesStart;
+    const size_t nbSeq = (size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart);
+    const BYTE* const ofCodeTable = seqStorePtr->ofCode;
+    const BYTE* const llCodeTable = seqStorePtr->llCode;
+    const BYTE* const mlCodeTable = seqStorePtr->mlCode;
+    BYTE* const ostart = (BYTE*)dst;
+    BYTE* const oend = ostart + dstCapacity;
+    BYTE* op = ostart;
+    size_t lastCountSize;
+    int longOffsets = 0;
+
+    entropyWorkspace = count + (MaxSeq + 1);
+    entropyWkspSize -= (MaxSeq + 1) * sizeof(*count);
+
+    DEBUGLOG(5, "ZSTD_entropyCompressSeqStore_internal (nbSeq=%zu, dstCapacity=%zu)", nbSeq, dstCapacity);
+    ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog)));
+    assert(entropyWkspSize >= HUF_WORKSPACE_SIZE);
+
+    /* Compress literals */
+    {   const BYTE* const literals = seqStorePtr->litStart;
+        size_t const numSequences = (size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart);
+        size_t const numLiterals = (size_t)(seqStorePtr->lit - seqStorePtr->litStart);
+        /* Base suspicion of uncompressibility on ratio of literals to sequences */
+        unsigned const suspectUncompressible = (numSequences == 0) || (numLiterals / numSequences >= SUSPECT_UNCOMPRESSIBLE_LITERAL_RATIO);
+        size_t const litSize = (size_t)(seqStorePtr->lit - literals);
+
+        size_t const cSize = ZSTD_compressLiterals(
+                                    op, dstCapacity,
+                                    literals, litSize,
+                                    entropyWorkspace, entropyWkspSize,
+                                    &prevEntropy->huf, &nextEntropy->huf,
+                                    cctxParams->cParams.strategy,
+                                    ZSTD_literalsCompressionIsDisabled(cctxParams),
+                                    suspectUncompressible, bmi2);
+        FORWARD_IF_ERROR(cSize, "ZSTD_compressLiterals failed");
+        assert(cSize <= dstCapacity);
+        op += cSize;
+    }
+
+    /* Sequences Header */
+    RETURN_ERROR_IF((oend-op) < 3 /*max nbSeq Size*/ + 1 /*seqHead*/,
+                    dstSize_tooSmall, "Can't fit seq hdr in output buf!");
+    if (nbSeq < 128) {
+        *op++ = (BYTE)nbSeq;
+    } else if (nbSeq < LONGNBSEQ) {
+        op[0] = (BYTE)((nbSeq>>8) + 0x80);
+        op[1] = (BYTE)nbSeq;
+        op+=2;
+    } else {
+        op[0]=0xFF;
+        MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ));
+        op+=3;
+    }
+    assert(op <= oend);
+    if (nbSeq==0) {
+        /* Copy the old tables over as if we repeated them */
+        ZSTD_memcpy(&nextEntropy->fse, &prevEntropy->fse, sizeof(prevEntropy->fse));
+        return (size_t)(op - ostart);
+    }
+    {   BYTE* const seqHead = op++;
+        /* build stats for sequences */
+        const ZSTD_symbolEncodingTypeStats_t stats =
+                ZSTD_buildSequencesStatistics(seqStorePtr, nbSeq,
+                                             &prevEntropy->fse, &nextEntropy->fse,
+                                              op, oend,
+                                              strategy, count,
+                                              entropyWorkspace, entropyWkspSize);
+        FORWARD_IF_ERROR(stats.size, "ZSTD_buildSequencesStatistics failed!");
+        *seqHead = (BYTE)((stats.LLtype<<6) + (stats.Offtype<<4) + (stats.MLtype<<2));
+        lastCountSize = stats.lastCountSize;
+        op += stats.size;
+        longOffsets = stats.longOffsets;
+    }
+
+    {   size_t const bitstreamSize = ZSTD_encodeSequences(
+                                        op, (size_t)(oend - op),
+                                        CTable_MatchLength, mlCodeTable,
+                                        CTable_OffsetBits, ofCodeTable,
+                                        CTable_LitLength, llCodeTable,
+                                        sequences, nbSeq,
+                                        longOffsets, bmi2);
+        FORWARD_IF_ERROR(bitstreamSize, "ZSTD_encodeSequences failed");
+        op += bitstreamSize;
+        assert(op <= oend);
+        /* zstd versions <= 1.3.4 mistakenly report corruption when
+         * FSE_readNCount() receives a buffer < 4 bytes.
+         * Fixed by https://github.com/facebook/zstd/pull/1146.
+         * This can happen when the last set_compressed table present is 2
+         * bytes and the bitstream is only one byte.
+         * In this exceedingly rare case, we will simply emit an uncompressed
+         * block, since it isn't worth optimizing.
+         */
+        if (lastCountSize && (lastCountSize + bitstreamSize) < 4) {
+            /* lastCountSize >= 2 && bitstreamSize > 0 ==> lastCountSize == 3 */
+            assert(lastCountSize + bitstreamSize == 3);
+            DEBUGLOG(5, "Avoiding bug in zstd decoder in versions <= 1.3.4 by "
+                        "emitting an uncompressed block.");
+            return 0;
+        }
+    }
+
+    DEBUGLOG(5, "compressed block size : %u", (unsigned)(op - ostart));
+    return (size_t)(op - ostart);
+}
+
+MEM_STATIC size_t
+ZSTD_entropyCompressSeqStore(
+                    const seqStore_t* seqStorePtr,
+                    const ZSTD_entropyCTables_t* prevEntropy,
+                          ZSTD_entropyCTables_t* nextEntropy,
+                    const ZSTD_CCtx_params* cctxParams,
+                          void* dst, size_t dstCapacity,
+                          size_t srcSize,
+                          void* entropyWorkspace, size_t entropyWkspSize,
+                          int bmi2)
+{
+    size_t const cSize = ZSTD_entropyCompressSeqStore_internal(
+                            seqStorePtr, prevEntropy, nextEntropy, cctxParams,
+                            dst, dstCapacity,
+                            entropyWorkspace, entropyWkspSize, bmi2);
+    if (cSize == 0) return 0;
+    /* When srcSize <= dstCapacity, there is enough space to write a raw uncompressed block.
+     * Since we ran out of space, block must be not compressible, so fall back to raw uncompressed block.
+     */
+    if ((cSize == ERROR(dstSize_tooSmall)) & (srcSize <= dstCapacity)) {
+        DEBUGLOG(4, "not enough dstCapacity (%zu) for ZSTD_entropyCompressSeqStore_internal()=> do not compress block", dstCapacity);
+        return 0;  /* block not compressed */
+    }
+    FORWARD_IF_ERROR(cSize, "ZSTD_entropyCompressSeqStore_internal failed");
+
+    /* Check compressibility */
+    {   size_t const maxCSize = srcSize - ZSTD_minGain(srcSize, cctxParams->cParams.strategy);
+        if (cSize >= maxCSize) return 0;  /* block not compressed */
+    }
+    DEBUGLOG(5, "ZSTD_entropyCompressSeqStore() cSize: %zu", cSize);
+    /* libzstd decoder before  > v1.5.4 is not compatible with compressed blocks of size ZSTD_BLOCKSIZE_MAX exactly.
+     * This restriction is indirectly already fulfilled by respecting ZSTD_minGain() condition above.
+     */
+    assert(cSize < ZSTD_BLOCKSIZE_MAX);
+    return cSize;
+}
+
+/* ZSTD_selectBlockCompressor() :
+ * Not static, but internal use only (used by long distance matcher)
+ * assumption : strat is a valid strategy */
+ZSTD_blockCompressor ZSTD_selectBlockCompressor(ZSTD_strategy strat, ZSTD_paramSwitch_e useRowMatchFinder, ZSTD_dictMode_e dictMode)
+{
+    static const ZSTD_blockCompressor blockCompressor[4][ZSTD_STRATEGY_MAX+1] = {
+        { ZSTD_compressBlock_fast  /* default for 0 */,
+          ZSTD_compressBlock_fast,
+          ZSTD_compressBlock_doubleFast,
+          ZSTD_compressBlock_greedy,
+          ZSTD_compressBlock_lazy,
+          ZSTD_compressBlock_lazy2,
+          ZSTD_compressBlock_btlazy2,
+          ZSTD_compressBlock_btopt,
+          ZSTD_compressBlock_btultra,
+          ZSTD_compressBlock_btultra2 },
+        { ZSTD_compressBlock_fast_extDict  /* default for 0 */,
+          ZSTD_compressBlock_fast_extDict,
+          ZSTD_compressBlock_doubleFast_extDict,
+          ZSTD_compressBlock_greedy_extDict,
+          ZSTD_compressBlock_lazy_extDict,
+          ZSTD_compressBlock_lazy2_extDict,
+          ZSTD_compressBlock_btlazy2_extDict,
+          ZSTD_compressBlock_btopt_extDict,
+          ZSTD_compressBlock_btultra_extDict,
+          ZSTD_compressBlock_btultra_extDict },
+        { ZSTD_compressBlock_fast_dictMatchState  /* default for 0 */,
+          ZSTD_compressBlock_fast_dictMatchState,
+          ZSTD_compressBlock_doubleFast_dictMatchState,
+          ZSTD_compressBlock_greedy_dictMatchState,
+          ZSTD_compressBlock_lazy_dictMatchState,
+          ZSTD_compressBlock_lazy2_dictMatchState,
+          ZSTD_compressBlock_btlazy2_dictMatchState,
+          ZSTD_compressBlock_btopt_dictMatchState,
+          ZSTD_compressBlock_btultra_dictMatchState,
+          ZSTD_compressBlock_btultra_dictMatchState },
+        { NULL  /* default for 0 */,
+          NULL,
+          NULL,
+          ZSTD_compressBlock_greedy_dedicatedDictSearch,
+          ZSTD_compressBlock_lazy_dedicatedDictSearch,
+          ZSTD_compressBlock_lazy2_dedicatedDictSearch,
+          NULL,
+          NULL,
+          NULL,
+          NULL }
+    };
+    ZSTD_blockCompressor selectedCompressor;
+    ZSTD_STATIC_ASSERT((unsigned)ZSTD_fast == 1);
+
+    assert(ZSTD_cParam_withinBounds(ZSTD_c_strategy, strat));
+    DEBUGLOG(4, "Selected block compressor: dictMode=%d strat=%d rowMatchfinder=%d", (int)dictMode, (int)strat, (int)useRowMatchFinder);
+    if (ZSTD_rowMatchFinderUsed(strat, useRowMatchFinder)) {
+        static const ZSTD_blockCompressor rowBasedBlockCompressors[4][3] = {
+            { ZSTD_compressBlock_greedy_row,
+            ZSTD_compressBlock_lazy_row,
+            ZSTD_compressBlock_lazy2_row },
+            { ZSTD_compressBlock_greedy_extDict_row,
+            ZSTD_compressBlock_lazy_extDict_row,
+            ZSTD_compressBlock_lazy2_extDict_row },
+            { ZSTD_compressBlock_greedy_dictMatchState_row,
+            ZSTD_compressBlock_lazy_dictMatchState_row,
+            ZSTD_compressBlock_lazy2_dictMatchState_row },
+            { ZSTD_compressBlock_greedy_dedicatedDictSearch_row,
+            ZSTD_compressBlock_lazy_dedicatedDictSearch_row,
+            ZSTD_compressBlock_lazy2_dedicatedDictSearch_row }
+        };
+        DEBUGLOG(4, "Selecting a row-based matchfinder");
+        assert(useRowMatchFinder != ZSTD_ps_auto);
+        selectedCompressor = rowBasedBlockCompressors[(int)dictMode][(int)strat - (int)ZSTD_greedy];
+    } else {
+        selectedCompressor = blockCompressor[(int)dictMode][(int)strat];
+    }
+    assert(selectedCompressor != NULL);
+    return selectedCompressor;
+}
+
+static void ZSTD_storeLastLiterals(seqStore_t* seqStorePtr,
+                                   const BYTE* anchor, size_t lastLLSize)
+{
+    ZSTD_memcpy(seqStorePtr->lit, anchor, lastLLSize);
+    seqStorePtr->lit += lastLLSize;
+}
+
+void ZSTD_resetSeqStore(seqStore_t* ssPtr)
+{
+    ssPtr->lit = ssPtr->litStart;
+    ssPtr->sequences = ssPtr->sequencesStart;
+    ssPtr->longLengthType = ZSTD_llt_none;
+}
+
+/* ZSTD_postProcessSequenceProducerResult() :
+ * Validates and post-processes sequences obtained through the external matchfinder API:
+ *   - Checks whether nbExternalSeqs represents an error condition.
+ *   - Appends a block delimiter to outSeqs if one is not already present.
+ *     See zstd.h for context regarding block delimiters.
+ * Returns the number of sequences after post-processing, or an error code. */
+static size_t ZSTD_postProcessSequenceProducerResult(
+    ZSTD_Sequence* outSeqs, size_t nbExternalSeqs, size_t outSeqsCapacity, size_t srcSize
+) {
+    RETURN_ERROR_IF(
+        nbExternalSeqs > outSeqsCapacity,
+        sequenceProducer_failed,
+        "External sequence producer returned error code %lu",
+        (unsigned long)nbExternalSeqs
+    );
+
+    RETURN_ERROR_IF(
+        nbExternalSeqs == 0 && srcSize > 0,
+        sequenceProducer_failed,
+        "Got zero sequences from external sequence producer for a non-empty src buffer!"
+    );
+
+    if (srcSize == 0) {
+        ZSTD_memset(&outSeqs[0], 0, sizeof(ZSTD_Sequence));
+        return 1;
+    }
+
+    {
+        ZSTD_Sequence const lastSeq = outSeqs[nbExternalSeqs - 1];
+
+        /* We can return early if lastSeq is already a block delimiter. */
+        if (lastSeq.offset == 0 && lastSeq.matchLength == 0) {
+            return nbExternalSeqs;
+        }
+
+        /* This error condition is only possible if the external matchfinder
+         * produced an invalid parse, by definition of ZSTD_sequenceBound(). */
+        RETURN_ERROR_IF(
+            nbExternalSeqs == outSeqsCapacity,
+            sequenceProducer_failed,
+            "nbExternalSeqs == outSeqsCapacity but lastSeq is not a block delimiter!"
+        );
+
+        /* lastSeq is not a block delimiter, so we need to append one. */
+        ZSTD_memset(&outSeqs[nbExternalSeqs], 0, sizeof(ZSTD_Sequence));
+        return nbExternalSeqs + 1;
+    }
+}
+
+/* ZSTD_fastSequenceLengthSum() :
+ * Returns sum(litLen) + sum(matchLen) + lastLits for *seqBuf*.
+ * Similar to another function in zstd_compress.c (determine_blockSize),
+ * except it doesn't check for a block delimiter to end summation.
+ * Removing the early exit allows the compiler to auto-vectorize (https://godbolt.org/z/cY1cajz9P).
+ * This function can be deleted and replaced by determine_blockSize after we resolve issue #3456. */
+static size_t ZSTD_fastSequenceLengthSum(ZSTD_Sequence const* seqBuf, size_t seqBufSize) {
+    size_t matchLenSum, litLenSum, i;
+    matchLenSum = 0;
+    litLenSum = 0;
+    for (i = 0; i < seqBufSize; i++) {
+        litLenSum += seqBuf[i].litLength;
+        matchLenSum += seqBuf[i].matchLength;
+    }
+    return litLenSum + matchLenSum;
+}
+
+typedef enum { ZSTDbss_compress, ZSTDbss_noCompress } ZSTD_buildSeqStore_e;
+
+static size_t ZSTD_buildSeqStore(ZSTD_CCtx* zc, const void* src, size_t srcSize)
+{
+    ZSTD_matchState_t* const ms = &zc->blockState.matchState;
+    DEBUGLOG(5, "ZSTD_buildSeqStore (srcSize=%zu)", srcSize);
+    assert(srcSize <= ZSTD_BLOCKSIZE_MAX);
+    /* Assert that we have correctly flushed the ctx params into the ms's copy */
+    ZSTD_assertEqualCParams(zc->appliedParams.cParams, ms->cParams);
+    /* TODO: See 3090. We reduced MIN_CBLOCK_SIZE from 3 to 2 so to compensate we are adding
+     * additional 1. We need to revisit and change this logic to be more consistent */
+    if (srcSize < MIN_CBLOCK_SIZE+ZSTD_blockHeaderSize+1+1) {
+        if (zc->appliedParams.cParams.strategy >= ZSTD_btopt) {
+            ZSTD_ldm_skipRawSeqStoreBytes(&zc->externSeqStore, srcSize);
+        } else {
+            ZSTD_ldm_skipSequences(&zc->externSeqStore, srcSize, zc->appliedParams.cParams.minMatch);
+        }
+        return ZSTDbss_noCompress; /* don't even attempt compression below a certain srcSize */
+    }
+    ZSTD_resetSeqStore(&(zc->seqStore));
+    /* required for optimal parser to read stats from dictionary */
+    ms->opt.symbolCosts = &zc->blockState.prevCBlock->entropy;
+    /* tell the optimal parser how we expect to compress literals */
+    ms->opt.literalCompressionMode = zc->appliedParams.literalCompressionMode;
+    /* a gap between an attached dict and the current window is not safe,
+     * they must remain adjacent,
+     * and when that stops being the case, the dict must be unset */
+    assert(ms->dictMatchState == NULL || ms->loadedDictEnd == ms->window.dictLimit);
+
+    /* limited update after a very long match */
+    {   const BYTE* const base = ms->window.base;
+        const BYTE* const istart = (const BYTE*)src;
+        const U32 curr = (U32)(istart-base);
+        if (sizeof(ptrdiff_t)==8) assert(istart - base < (ptrdiff_t)(U32)(-1));   /* ensure no overflow */
+        if (curr > ms->nextToUpdate + 384)
+            ms->nextToUpdate = curr - MIN(192, (U32)(curr - ms->nextToUpdate - 384));
+    }
+
+    /* select and store sequences */
+    {   ZSTD_dictMode_e const dictMode = ZSTD_matchState_dictMode(ms);
+        size_t lastLLSize;
+        {   int i;
+            for (i = 0; i < ZSTD_REP_NUM; ++i)
+                zc->blockState.nextCBlock->rep[i] = zc->blockState.prevCBlock->rep[i];
+        }
+        if (zc->externSeqStore.pos < zc->externSeqStore.size) {
+            assert(zc->appliedParams.ldmParams.enableLdm == ZSTD_ps_disable);
+
+            /* External matchfinder + LDM is technically possible, just not implemented yet.
+             * We need to revisit soon and implement it. */
+            RETURN_ERROR_IF(
+                zc->appliedParams.useSequenceProducer,
+                parameter_combination_unsupported,
+                "Long-distance matching with external sequence producer enabled is not currently supported."
+            );
+
+            /* Updates ldmSeqStore.pos */
+            lastLLSize =
+                ZSTD_ldm_blockCompress(&zc->externSeqStore,
+                                       ms, &zc->seqStore,
+                                       zc->blockState.nextCBlock->rep,
+                                       zc->appliedParams.useRowMatchFinder,
+                                       src, srcSize);
+            assert(zc->externSeqStore.pos <= zc->externSeqStore.size);
+        } else if (zc->appliedParams.ldmParams.enableLdm == ZSTD_ps_enable) {
+            rawSeqStore_t ldmSeqStore = kNullRawSeqStore;
+
+            /* External matchfinder + LDM is technically possible, just not implemented yet.
+             * We need to revisit soon and implement it. */
+            RETURN_ERROR_IF(
+                zc->appliedParams.useSequenceProducer,
+                parameter_combination_unsupported,
+                "Long-distance matching with external sequence producer enabled is not currently supported."
+            );
+
+            ldmSeqStore.seq = zc->ldmSequences;
+            ldmSeqStore.capacity = zc->maxNbLdmSequences;
+            /* Updates ldmSeqStore.size */
+            FORWARD_IF_ERROR(ZSTD_ldm_generateSequences(&zc->ldmState, &ldmSeqStore,
+                                               &zc->appliedParams.ldmParams,
+                                               src, srcSize), "");
+            /* Updates ldmSeqStore.pos */
+            lastLLSize =
+                ZSTD_ldm_blockCompress(&ldmSeqStore,
+                                       ms, &zc->seqStore,
+                                       zc->blockState.nextCBlock->rep,
+                                       zc->appliedParams.useRowMatchFinder,
+                                       src, srcSize);
+            assert(ldmSeqStore.pos == ldmSeqStore.size);
+        } else if (zc->appliedParams.useSequenceProducer) {
+            assert(
+                zc->externalMatchCtx.seqBufferCapacity >= ZSTD_sequenceBound(srcSize)
+            );
+            assert(zc->externalMatchCtx.mFinder != NULL);
+
+            {   U32 const windowSize = (U32)1 << zc->appliedParams.cParams.windowLog;
+
+                size_t const nbExternalSeqs = (zc->externalMatchCtx.mFinder)(
+                    zc->externalMatchCtx.mState,
+                    zc->externalMatchCtx.seqBuffer,
+                    zc->externalMatchCtx.seqBufferCapacity,
+                    src, srcSize,
+                    NULL, 0,  /* dict and dictSize, currently not supported */
+                    zc->appliedParams.compressionLevel,
+                    windowSize
+                );
+
+                size_t const nbPostProcessedSeqs = ZSTD_postProcessSequenceProducerResult(
+                    zc->externalMatchCtx.seqBuffer,
+                    nbExternalSeqs,
+                    zc->externalMatchCtx.seqBufferCapacity,
+                    srcSize
+                );
+
+                /* Return early if there is no error, since we don't need to worry about last literals */
+                if (!ZSTD_isError(nbPostProcessedSeqs)) {
+                    ZSTD_sequencePosition seqPos = {0,0,0};
+                    size_t const seqLenSum = ZSTD_fastSequenceLengthSum(zc->externalMatchCtx.seqBuffer, nbPostProcessedSeqs);
+                    RETURN_ERROR_IF(seqLenSum > srcSize, externalSequences_invalid, "External sequences imply too large a block!");
+                    FORWARD_IF_ERROR(
+                        ZSTD_copySequencesToSeqStoreExplicitBlockDelim(
+                            zc, &seqPos,
+                            zc->externalMatchCtx.seqBuffer, nbPostProcessedSeqs,
+                            src, srcSize,
+                            zc->appliedParams.searchForExternalRepcodes
+                        ),
+                        "Failed to copy external sequences to seqStore!"
+                    );
+                    ms->ldmSeqStore = NULL;
+                    DEBUGLOG(5, "Copied %lu sequences from external sequence producer to internal seqStore.", (unsigned long)nbExternalSeqs);
+                    return ZSTDbss_compress;
+                }
+
+                /* Propagate the error if fallback is disabled */
+                if (!zc->appliedParams.enableMatchFinderFallback) {
+                    return nbPostProcessedSeqs;
+                }
+
+                /* Fallback to software matchfinder */
+                {   ZSTD_blockCompressor const blockCompressor = ZSTD_selectBlockCompressor(zc->appliedParams.cParams.strategy,
+                                                                                            zc->appliedParams.useRowMatchFinder,
+                                                                                            dictMode);
+                    ms->ldmSeqStore = NULL;
+                    DEBUGLOG(
+                        5,
+                        "External sequence producer returned error code %lu. Falling back to internal parser.",
+                        (unsigned long)nbExternalSeqs
+                    );
+                    lastLLSize = blockCompressor(ms, &zc->seqStore, zc->blockState.nextCBlock->rep, src, srcSize);
+            }   }
+        } else {   /* not long range mode and no external matchfinder */
+            ZSTD_blockCompressor const blockCompressor = ZSTD_selectBlockCompressor(zc->appliedParams.cParams.strategy,
+                                                                                    zc->appliedParams.useRowMatchFinder,
+                                                                                    dictMode);
+            ms->ldmSeqStore = NULL;
+            lastLLSize = blockCompressor(ms, &zc->seqStore, zc->blockState.nextCBlock->rep, src, srcSize);
+        }
+        {   const BYTE* const lastLiterals = (const BYTE*)src + srcSize - lastLLSize;
+            ZSTD_storeLastLiterals(&zc->seqStore, lastLiterals, lastLLSize);
+    }   }
+    return ZSTDbss_compress;
+}
+
+static void ZSTD_copyBlockSequences(ZSTD_CCtx* zc)
+{
+    const seqStore_t* seqStore = ZSTD_getSeqStore(zc);
+    const seqDef* seqStoreSeqs = seqStore->sequencesStart;
+    size_t seqStoreSeqSize = seqStore->sequences - seqStoreSeqs;
+    size_t seqStoreLiteralsSize = (size_t)(seqStore->lit - seqStore->litStart);
+    size_t literalsRead = 0;
+    size_t lastLLSize;
+
+    ZSTD_Sequence* outSeqs = &zc->seqCollector.seqStart[zc->seqCollector.seqIndex];
+    size_t i;
+    repcodes_t updatedRepcodes;
+
+    assert(zc->seqCollector.seqIndex + 1 < zc->seqCollector.maxSequences);
+    /* Ensure we have enough space for last literals "sequence" */
+    assert(zc->seqCollector.maxSequences >= seqStoreSeqSize + 1);
+    ZSTD_memcpy(updatedRepcodes.rep, zc->blockState.prevCBlock->rep, sizeof(repcodes_t));
+    for (i = 0; i < seqStoreSeqSize; ++i) {
+        U32 rawOffset = seqStoreSeqs[i].offBase - ZSTD_REP_NUM;
+        outSeqs[i].litLength = seqStoreSeqs[i].litLength;
+        outSeqs[i].matchLength = seqStoreSeqs[i].mlBase + MINMATCH;
+        outSeqs[i].rep = 0;
+
+        if (i == seqStore->longLengthPos) {
+            if (seqStore->longLengthType == ZSTD_llt_literalLength) {
+                outSeqs[i].litLength += 0x10000;
+            } else if (seqStore->longLengthType == ZSTD_llt_matchLength) {
+                outSeqs[i].matchLength += 0x10000;
+            }
+        }
+
+        if (seqStoreSeqs[i].offBase <= ZSTD_REP_NUM) {
+            /* Derive the correct offset corresponding to a repcode */
+            outSeqs[i].rep = seqStoreSeqs[i].offBase;
+            if (outSeqs[i].litLength != 0) {
+                rawOffset = updatedRepcodes.rep[outSeqs[i].rep - 1];
+            } else {
+                if (outSeqs[i].rep == 3) {
+                    rawOffset = updatedRepcodes.rep[0] - 1;
+                } else {
+                    rawOffset = updatedRepcodes.rep[outSeqs[i].rep];
+                }
+            }
+        }
+        outSeqs[i].offset = rawOffset;
+        /* seqStoreSeqs[i].offset == offCode+1, and ZSTD_updateRep() expects offCode
+           so we provide seqStoreSeqs[i].offset - 1 */
+        ZSTD_updateRep(updatedRepcodes.rep,
+                       seqStoreSeqs[i].offBase,
+                       seqStoreSeqs[i].litLength == 0);
+        literalsRead += outSeqs[i].litLength;
+    }
+    /* Insert last literals (if any exist) in the block as a sequence with ml == off == 0.
+     * If there are no last literals, then we'll emit (of: 0, ml: 0, ll: 0), which is a marker
+     * for the block boundary, according to the API.
+     */
+    assert(seqStoreLiteralsSize >= literalsRead);
+    lastLLSize = seqStoreLiteralsSize - literalsRead;
+    outSeqs[i].litLength = (U32)lastLLSize;
+    outSeqs[i].matchLength = outSeqs[i].offset = outSeqs[i].rep = 0;
+    seqStoreSeqSize++;
+    zc->seqCollector.seqIndex += seqStoreSeqSize;
+}
+
+size_t ZSTD_sequenceBound(size_t srcSize) {
+    return (srcSize / ZSTD_MINMATCH_MIN) + 1;
+}
+
+size_t ZSTD_generateSequences(ZSTD_CCtx* zc, ZSTD_Sequence* outSeqs,
+                              size_t outSeqsSize, const void* src, size_t srcSize)
+{
+    const size_t dstCapacity = ZSTD_compressBound(srcSize);
+    void* dst = ZSTD_customMalloc(dstCapacity, ZSTD_defaultCMem);
+    SeqCollector seqCollector;
+
+    RETURN_ERROR_IF(dst == NULL, memory_allocation, "NULL pointer!");
+
+    seqCollector.collectSequences = 1;
+    seqCollector.seqStart = outSeqs;
+    seqCollector.seqIndex = 0;
+    seqCollector.maxSequences = outSeqsSize;
+    zc->seqCollector = seqCollector;
+
+    ZSTD_compress2(zc, dst, dstCapacity, src, srcSize);
+    ZSTD_customFree(dst, ZSTD_defaultCMem);
+    return zc->seqCollector.seqIndex;
+}
+
+size_t ZSTD_mergeBlockDelimiters(ZSTD_Sequence* sequences, size_t seqsSize) {
+    size_t in = 0;
+    size_t out = 0;
+    for (; in < seqsSize; ++in) {
+        if (sequences[in].offset == 0 && sequences[in].matchLength == 0) {
+            if (in != seqsSize - 1) {
+                sequences[in+1].litLength += sequences[in].litLength;
+            }
+        } else {
+            sequences[out] = sequences[in];
+            ++out;
+        }
+    }
+    return out;
+}
+
+/* Unrolled loop to read four size_ts of input at a time. Returns 1 if is RLE, 0 if not. */
+static int ZSTD_isRLE(const BYTE* src, size_t length) {
+    const BYTE* ip = src;
+    const BYTE value = ip[0];
+    const size_t valueST = (size_t)((U64)value * 0x0101010101010101ULL);
+    const size_t unrollSize = sizeof(size_t) * 4;
+    const size_t unrollMask = unrollSize - 1;
+    const size_t prefixLength = length & unrollMask;
+    size_t i;
+    if (length == 1) return 1;
+    /* Check if prefix is RLE first before using unrolled loop */
+    if (prefixLength && ZSTD_count(ip+1, ip, ip+prefixLength) != prefixLength-1) {
+        return 0;
+    }
+    for (i = prefixLength; i != length; i += unrollSize) {
+        size_t u;
+        for (u = 0; u < unrollSize; u += sizeof(size_t)) {
+            if (MEM_readST(ip + i + u) != valueST) {
+                return 0;
+    }   }   }
+    return 1;
+}
+
+/* Returns true if the given block may be RLE.
+ * This is just a heuristic based on the compressibility.
+ * It may return both false positives and false negatives.
+ */
+static int ZSTD_maybeRLE(seqStore_t const* seqStore)
+{
+    size_t const nbSeqs = (size_t)(seqStore->sequences - seqStore->sequencesStart);
+    size_t const nbLits = (size_t)(seqStore->lit - seqStore->litStart);
+
+    return nbSeqs < 4 && nbLits < 10;
+}
+
+static void
+ZSTD_blockState_confirmRepcodesAndEntropyTables(ZSTD_blockState_t* const bs)
+{
+    ZSTD_compressedBlockState_t* const tmp = bs->prevCBlock;
+    bs->prevCBlock = bs->nextCBlock;
+    bs->nextCBlock = tmp;
+}
+
+/* Writes the block header */
+static void
+writeBlockHeader(void* op, size_t cSize, size_t blockSize, U32 lastBlock)
+{
+    U32 const cBlockHeader = cSize == 1 ?
+                        lastBlock + (((U32)bt_rle)<<1) + (U32)(blockSize << 3) :
+                        lastBlock + (((U32)bt_compressed)<<1) + (U32)(cSize << 3);
+    MEM_writeLE24(op, cBlockHeader);
+    DEBUGLOG(3, "writeBlockHeader: cSize: %zu blockSize: %zu lastBlock: %u", cSize, blockSize, lastBlock);
+}
+
+/** ZSTD_buildBlockEntropyStats_literals() :
+ *  Builds entropy for the literals.
+ *  Stores literals block type (raw, rle, compressed, repeat) and
+ *  huffman description table to hufMetadata.
+ *  Requires ENTROPY_WORKSPACE_SIZE workspace
+ * @return : size of huffman description table, or an error code
+ */
+static size_t
+ZSTD_buildBlockEntropyStats_literals(void* const src, size_t srcSize,
+                               const ZSTD_hufCTables_t* prevHuf,
+                                     ZSTD_hufCTables_t* nextHuf,
+                                     ZSTD_hufCTablesMetadata_t* hufMetadata,
+                               const int literalsCompressionIsDisabled,
+                                     void* workspace, size_t wkspSize,
+                                     int hufFlags)
+{
+    BYTE* const wkspStart = (BYTE*)workspace;
+    BYTE* const wkspEnd = wkspStart + wkspSize;
+    BYTE* const countWkspStart = wkspStart;
+    unsigned* const countWksp = (unsigned*)workspace;
+    const size_t countWkspSize = (HUF_SYMBOLVALUE_MAX + 1) * sizeof(unsigned);
+    BYTE* const nodeWksp = countWkspStart + countWkspSize;
+    const size_t nodeWkspSize = (size_t)(wkspEnd - nodeWksp);
+    unsigned maxSymbolValue = HUF_SYMBOLVALUE_MAX;
+    unsigned huffLog = LitHufLog;
+    HUF_repeat repeat = prevHuf->repeatMode;
+    DEBUGLOG(5, "ZSTD_buildBlockEntropyStats_literals (srcSize=%zu)", srcSize);
+
+    /* Prepare nextEntropy assuming reusing the existing table */
+    ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));
+
+    if (literalsCompressionIsDisabled) {
+        DEBUGLOG(5, "set_basic - disabled");
+        hufMetadata->hType = set_basic;
+        return 0;
+    }
+
+    /* small ? don't even attempt compression (speed opt) */
+#ifndef COMPRESS_LITERALS_SIZE_MIN
+# define COMPRESS_LITERALS_SIZE_MIN 63  /* heuristic */
+#endif
+    {   size_t const minLitSize = (prevHuf->repeatMode == HUF_repeat_valid) ? 6 : COMPRESS_LITERALS_SIZE_MIN;
+        if (srcSize <= minLitSize) {
+            DEBUGLOG(5, "set_basic - too small");
+            hufMetadata->hType = set_basic;
+            return 0;
+    }   }
+
+    /* Scan input and build symbol stats */
+    {   size_t const largest =
+            HIST_count_wksp (countWksp, &maxSymbolValue,
+                            (const BYTE*)src, srcSize,
+                            workspace, wkspSize);
+        FORWARD_IF_ERROR(largest, "HIST_count_wksp failed");
+        if (largest == srcSize) {
+            /* only one literal symbol */
+            DEBUGLOG(5, "set_rle");
+            hufMetadata->hType = set_rle;
+            return 0;
+        }
+        if (largest <= (srcSize >> 7)+4) {
+            /* heuristic: likely not compressible */
+            DEBUGLOG(5, "set_basic - no gain");
+            hufMetadata->hType = set_basic;
+            return 0;
+    }   }
+
+    /* Validate the previous Huffman table */
+    if (repeat == HUF_repeat_check
+      && !HUF_validateCTable((HUF_CElt const*)prevHuf->CTable, countWksp, maxSymbolValue)) {
+        repeat = HUF_repeat_none;
+    }
+
+    /* Build Huffman Tree */
+    ZSTD_memset(nextHuf->CTable, 0, sizeof(nextHuf->CTable));
+    huffLog = HUF_optimalTableLog(huffLog, srcSize, maxSymbolValue, nodeWksp, nodeWkspSize, nextHuf->CTable, countWksp, hufFlags);
+    assert(huffLog <= LitHufLog);
+    {   size_t const maxBits = HUF_buildCTable_wksp((HUF_CElt*)nextHuf->CTable, countWksp,
+                                                    maxSymbolValue, huffLog,
+                                                    nodeWksp, nodeWkspSize);
+        FORWARD_IF_ERROR(maxBits, "HUF_buildCTable_wksp");
+        huffLog = (U32)maxBits;
+    }
+    {   /* Build and write the CTable */
+        size_t const newCSize = HUF_estimateCompressedSize(
+                (HUF_CElt*)nextHuf->CTable, countWksp, maxSymbolValue);
+        size_t const hSize = HUF_writeCTable_wksp(
+                hufMetadata->hufDesBuffer, sizeof(hufMetadata->hufDesBuffer),
+                (HUF_CElt*)nextHuf->CTable, maxSymbolValue, huffLog,
+                nodeWksp, nodeWkspSize);
+        /* Check against repeating the previous CTable */
+        if (repeat != HUF_repeat_none) {
+            size_t const oldCSize = HUF_estimateCompressedSize(
+                    (HUF_CElt const*)prevHuf->CTable, countWksp, maxSymbolValue);
+            if (oldCSize < srcSize && (oldCSize <= hSize + newCSize || hSize + 12 >= srcSize)) {
+                DEBUGLOG(5, "set_repeat - smaller");
+                ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));
+                hufMetadata->hType = set_repeat;
+                return 0;
+        }   }
+        if (newCSize + hSize >= srcSize) {
+            DEBUGLOG(5, "set_basic - no gains");
+            ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));
+            hufMetadata->hType = set_basic;
+            return 0;
+        }
+        DEBUGLOG(5, "set_compressed (hSize=%u)", (U32)hSize);
+        hufMetadata->hType = set_compressed;
+        nextHuf->repeatMode = HUF_repeat_check;
+        return hSize;
+    }
+}
+
+
+/* ZSTD_buildDummySequencesStatistics():
+ * Returns a ZSTD_symbolEncodingTypeStats_t with all encoding types as set_basic,
+ * and updates nextEntropy to the appropriate repeatMode.
+ */
+static ZSTD_symbolEncodingTypeStats_t
+ZSTD_buildDummySequencesStatistics(ZSTD_fseCTables_t* nextEntropy)
+{
+    ZSTD_symbolEncodingTypeStats_t stats = {set_basic, set_basic, set_basic, 0, 0, 0};
+    nextEntropy->litlength_repeatMode = FSE_repeat_none;
+    nextEntropy->offcode_repeatMode = FSE_repeat_none;
+    nextEntropy->matchlength_repeatMode = FSE_repeat_none;
+    return stats;
+}
+
+/** ZSTD_buildBlockEntropyStats_sequences() :
+ *  Builds entropy for the sequences.
+ *  Stores symbol compression modes and fse table to fseMetadata.
+ *  Requires ENTROPY_WORKSPACE_SIZE wksp.
+ * @return : size of fse tables or error code */
+static size_t
+ZSTD_buildBlockEntropyStats_sequences(
+                const seqStore_t* seqStorePtr,
+                const ZSTD_fseCTables_t* prevEntropy,
+                      ZSTD_fseCTables_t* nextEntropy,
+                const ZSTD_CCtx_params* cctxParams,
+                      ZSTD_fseCTablesMetadata_t* fseMetadata,
+                      void* workspace, size_t wkspSize)
+{
+    ZSTD_strategy const strategy = cctxParams->cParams.strategy;
+    size_t const nbSeq = (size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart);
+    BYTE* const ostart = fseMetadata->fseTablesBuffer;
+    BYTE* const oend = ostart + sizeof(fseMetadata->fseTablesBuffer);
+    BYTE* op = ostart;
+    unsigned* countWorkspace = (unsigned*)workspace;
+    unsigned* entropyWorkspace = countWorkspace + (MaxSeq + 1);
+    size_t entropyWorkspaceSize = wkspSize - (MaxSeq + 1) * sizeof(*countWorkspace);
+    ZSTD_symbolEncodingTypeStats_t stats;
+
+    DEBUGLOG(5, "ZSTD_buildBlockEntropyStats_sequences (nbSeq=%zu)", nbSeq);
+    stats = nbSeq != 0 ? ZSTD_buildSequencesStatistics(seqStorePtr, nbSeq,
+                                          prevEntropy, nextEntropy, op, oend,
+                                          strategy, countWorkspace,
+                                          entropyWorkspace, entropyWorkspaceSize)
+                       : ZSTD_buildDummySequencesStatistics(nextEntropy);
+    FORWARD_IF_ERROR(stats.size, "ZSTD_buildSequencesStatistics failed!");
+    fseMetadata->llType = (symbolEncodingType_e) stats.LLtype;
+    fseMetadata->ofType = (symbolEncodingType_e) stats.Offtype;
+    fseMetadata->mlType = (symbolEncodingType_e) stats.MLtype;
+    fseMetadata->lastCountSize = stats.lastCountSize;
+    return stats.size;
+}
+
+
+/** ZSTD_buildBlockEntropyStats() :
+ *  Builds entropy for the block.
+ *  Requires workspace size ENTROPY_WORKSPACE_SIZE
+ * @return : 0 on success, or an error code
+ *  Note : also employed in superblock
+ */
+size_t ZSTD_buildBlockEntropyStats(
+            const seqStore_t* seqStorePtr,
+            const ZSTD_entropyCTables_t* prevEntropy,
+                  ZSTD_entropyCTables_t* nextEntropy,
+            const ZSTD_CCtx_params* cctxParams,
+                  ZSTD_entropyCTablesMetadata_t* entropyMetadata,
+                  void* workspace, size_t wkspSize)
+{
+    size_t const litSize = (size_t)(seqStorePtr->lit - seqStorePtr->litStart);
+    int const huf_useOptDepth = (cctxParams->cParams.strategy >= HUF_OPTIMAL_DEPTH_THRESHOLD);
+    int const hufFlags = huf_useOptDepth ? HUF_flags_optimalDepth : 0;
+
+    entropyMetadata->hufMetadata.hufDesSize =
+        ZSTD_buildBlockEntropyStats_literals(seqStorePtr->litStart, litSize,
+                                            &prevEntropy->huf, &nextEntropy->huf,
+                                            &entropyMetadata->hufMetadata,
+                                            ZSTD_literalsCompressionIsDisabled(cctxParams),
+                                            workspace, wkspSize, hufFlags);
+
+    FORWARD_IF_ERROR(entropyMetadata->hufMetadata.hufDesSize, "ZSTD_buildBlockEntropyStats_literals failed");
+    entropyMetadata->fseMetadata.fseTablesSize =
+        ZSTD_buildBlockEntropyStats_sequences(seqStorePtr,
+                                              &prevEntropy->fse, &nextEntropy->fse,
+                                              cctxParams,
+                                              &entropyMetadata->fseMetadata,
+                                              workspace, wkspSize);
+    FORWARD_IF_ERROR(entropyMetadata->fseMetadata.fseTablesSize, "ZSTD_buildBlockEntropyStats_sequences failed");
+    return 0;
+}
+
+/* Returns the size estimate for the literals section (header + content) of a block */
+static size_t
+ZSTD_estimateBlockSize_literal(const BYTE* literals, size_t litSize,
+                               const ZSTD_hufCTables_t* huf,
+                               const ZSTD_hufCTablesMetadata_t* hufMetadata,
+                               void* workspace, size_t wkspSize,
+                               int writeEntropy)
+{
+    unsigned* const countWksp = (unsigned*)workspace;
+    unsigned maxSymbolValue = HUF_SYMBOLVALUE_MAX;
+    size_t literalSectionHeaderSize = 3 + (litSize >= 1 KB) + (litSize >= 16 KB);
+    U32 singleStream = litSize < 256;
+
+    if (hufMetadata->hType == set_basic) return litSize;
+    else if (hufMetadata->hType == set_rle) return 1;
+    else if (hufMetadata->hType == set_compressed || hufMetadata->hType == set_repeat) {
+        size_t const largest = HIST_count_wksp (countWksp, &maxSymbolValue, (const BYTE*)literals, litSize, workspace, wkspSize);
+        if (ZSTD_isError(largest)) return litSize;
+        {   size_t cLitSizeEstimate = HUF_estimateCompressedSize((const HUF_CElt*)huf->CTable, countWksp, maxSymbolValue);
+            if (writeEntropy) cLitSizeEstimate += hufMetadata->hufDesSize;
+            if (!singleStream) cLitSizeEstimate += 6; /* multi-stream huffman uses 6-byte jump table */
+            return cLitSizeEstimate + literalSectionHeaderSize;
+    }   }
+    assert(0); /* impossible */
+    return 0;
+}
+
+/* Returns the size estimate for the FSE-compressed symbols (of, ml, ll) of a block */
+static size_t
+ZSTD_estimateBlockSize_symbolType(symbolEncodingType_e type,
+                    const BYTE* codeTable, size_t nbSeq, unsigned maxCode,
+                    const FSE_CTable* fseCTable,
+                    const U8* additionalBits,
+                    short const* defaultNorm, U32 defaultNormLog, U32 defaultMax,
+                    void* workspace, size_t wkspSize)
+{
+    unsigned* const countWksp = (unsigned*)workspace;
+    const BYTE* ctp = codeTable;
+    const BYTE* const ctStart = ctp;
+    const BYTE* const ctEnd = ctStart + nbSeq;
+    size_t cSymbolTypeSizeEstimateInBits = 0;
+    unsigned max = maxCode;
+
+    HIST_countFast_wksp(countWksp, &max, codeTable, nbSeq, workspace, wkspSize);  /* can't fail */
+    if (type == set_basic) {
+        /* We selected this encoding type, so it must be valid. */
+        assert(max <= defaultMax);
+        (void)defaultMax;
+        cSymbolTypeSizeEstimateInBits = ZSTD_crossEntropyCost(defaultNorm, defaultNormLog, countWksp, max);
+    } else if (type == set_rle) {
+        cSymbolTypeSizeEstimateInBits = 0;
+    } else if (type == set_compressed || type == set_repeat) {
+        cSymbolTypeSizeEstimateInBits = ZSTD_fseBitCost(fseCTable, countWksp, max);
+    }
+    if (ZSTD_isError(cSymbolTypeSizeEstimateInBits)) {
+        return nbSeq * 10;
+    }
+    while (ctp < ctEnd) {
+        if (additionalBits) cSymbolTypeSizeEstimateInBits += additionalBits[*ctp];
+        else cSymbolTypeSizeEstimateInBits += *ctp; /* for offset, offset code is also the number of additional bits */
+        ctp++;
+    }
+    return cSymbolTypeSizeEstimateInBits >> 3;
+}
+
+/* Returns the size estimate for the sequences section (header + content) of a block */
+static size_t
+ZSTD_estimateBlockSize_sequences(const BYTE* ofCodeTable,
+                                 const BYTE* llCodeTable,
+                                 const BYTE* mlCodeTable,
+                                 size_t nbSeq,
+                                 const ZSTD_fseCTables_t* fseTables,
+                                 const ZSTD_fseCTablesMetadata_t* fseMetadata,
+                                 void* workspace, size_t wkspSize,
+                                 int writeEntropy)
+{
+    size_t sequencesSectionHeaderSize = 1 /* seqHead */ + 1 /* min seqSize size */ + (nbSeq >= 128) + (nbSeq >= LONGNBSEQ);
+    size_t cSeqSizeEstimate = 0;
+    cSeqSizeEstimate += ZSTD_estimateBlockSize_symbolType(fseMetadata->ofType, ofCodeTable, nbSeq, MaxOff,
+                                    fseTables->offcodeCTable, NULL,
+                                    OF_defaultNorm, OF_defaultNormLog, DefaultMaxOff,
+                                    workspace, wkspSize);
+    cSeqSizeEstimate += ZSTD_estimateBlockSize_symbolType(fseMetadata->llType, llCodeTable, nbSeq, MaxLL,
+                                    fseTables->litlengthCTable, LL_bits,
+                                    LL_defaultNorm, LL_defaultNormLog, MaxLL,
+                                    workspace, wkspSize);
+    cSeqSizeEstimate += ZSTD_estimateBlockSize_symbolType(fseMetadata->mlType, mlCodeTable, nbSeq, MaxML,
+                                    fseTables->matchlengthCTable, ML_bits,
+                                    ML_defaultNorm, ML_defaultNormLog, MaxML,
+                                    workspace, wkspSize);
+    if (writeEntropy) cSeqSizeEstimate += fseMetadata->fseTablesSize;
+    return cSeqSizeEstimate + sequencesSectionHeaderSize;
+}
+
+/* Returns the size estimate for a given stream of literals, of, ll, ml */
+static size_t
+ZSTD_estimateBlockSize(const BYTE* literals, size_t litSize,
+                       const BYTE* ofCodeTable,
+                       const BYTE* llCodeTable,
+                       const BYTE* mlCodeTable,
+                       size_t nbSeq,
+                       const ZSTD_entropyCTables_t* entropy,
+                       const ZSTD_entropyCTablesMetadata_t* entropyMetadata,
+                       void* workspace, size_t wkspSize,
+                       int writeLitEntropy, int writeSeqEntropy)
+{
+    size_t const literalsSize = ZSTD_estimateBlockSize_literal(literals, litSize,
+                                    &entropy->huf, &entropyMetadata->hufMetadata,
+                                    workspace, wkspSize, writeLitEntropy);
+    size_t const seqSize = ZSTD_estimateBlockSize_sequences(ofCodeTable, llCodeTable, mlCodeTable,
+                                    nbSeq, &entropy->fse, &entropyMetadata->fseMetadata,
+                                    workspace, wkspSize, writeSeqEntropy);
+    return seqSize + literalsSize + ZSTD_blockHeaderSize;
+}
+
+/* Builds entropy statistics and uses them for blocksize estimation.
+ *
+ * @return: estimated compressed size of the seqStore, or a zstd error.
+ */
+static size_t
+ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize(seqStore_t* seqStore, ZSTD_CCtx* zc)
+{
+    ZSTD_entropyCTablesMetadata_t* const entropyMetadata = &zc->blockSplitCtx.entropyMetadata;
+    DEBUGLOG(6, "ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize()");
+    FORWARD_IF_ERROR(ZSTD_buildBlockEntropyStats(seqStore,
+                    &zc->blockState.prevCBlock->entropy,
+                    &zc->blockState.nextCBlock->entropy,
+                    &zc->appliedParams,
+                    entropyMetadata,
+                    zc->entropyWorkspace, ENTROPY_WORKSPACE_SIZE), "");
+    return ZSTD_estimateBlockSize(
+                    seqStore->litStart, (size_t)(seqStore->lit - seqStore->litStart),
+                    seqStore->ofCode, seqStore->llCode, seqStore->mlCode,
+                    (size_t)(seqStore->sequences - seqStore->sequencesStart),
+                    &zc->blockState.nextCBlock->entropy,
+                    entropyMetadata,
+                    zc->entropyWorkspace, ENTROPY_WORKSPACE_SIZE,
+                    (int)(entropyMetadata->hufMetadata.hType == set_compressed), 1);
+}
+
+/* Returns literals bytes represented in a seqStore */
+static size_t ZSTD_countSeqStoreLiteralsBytes(const seqStore_t* const seqStore)
+{
+    size_t literalsBytes = 0;
+    size_t const nbSeqs = (size_t)(seqStore->sequences - seqStore->sequencesStart);
+    size_t i;
+    for (i = 0; i < nbSeqs; ++i) {
+        seqDef const seq = seqStore->sequencesStart[i];
+        literalsBytes += seq.litLength;
+        if (i == seqStore->longLengthPos && seqStore->longLengthType == ZSTD_llt_literalLength) {
+            literalsBytes += 0x10000;
+    }   }
+    return literalsBytes;
+}
+
+/* Returns match bytes represented in a seqStore */
+static size_t ZSTD_countSeqStoreMatchBytes(const seqStore_t* const seqStore)
+{
+    size_t matchBytes = 0;
+    size_t const nbSeqs = (size_t)(seqStore->sequences - seqStore->sequencesStart);
+    size_t i;
+    for (i = 0; i < nbSeqs; ++i) {
+        seqDef seq = seqStore->sequencesStart[i];
+        matchBytes += seq.mlBase + MINMATCH;
+        if (i == seqStore->longLengthPos && seqStore->longLengthType == ZSTD_llt_matchLength) {
+            matchBytes += 0x10000;
+    }   }
+    return matchBytes;
+}
+
+/* Derives the seqStore that is a chunk of the originalSeqStore from [startIdx, endIdx).
+ * Stores the result in resultSeqStore.
+ */
+static void ZSTD_deriveSeqStoreChunk(seqStore_t* resultSeqStore,
+                               const seqStore_t* originalSeqStore,
+                                     size_t startIdx, size_t endIdx)
+{
+    *resultSeqStore = *originalSeqStore;
+    if (startIdx > 0) {
+        resultSeqStore->sequences = originalSeqStore->sequencesStart + startIdx;
+        resultSeqStore->litStart += ZSTD_countSeqStoreLiteralsBytes(resultSeqStore);
+    }
+
+    /* Move longLengthPos into the correct position if necessary */
+    if (originalSeqStore->longLengthType != ZSTD_llt_none) {
+        if (originalSeqStore->longLengthPos < startIdx || originalSeqStore->longLengthPos > endIdx) {
+            resultSeqStore->longLengthType = ZSTD_llt_none;
+        } else {
+            resultSeqStore->longLengthPos -= (U32)startIdx;
+        }
+    }
+    resultSeqStore->sequencesStart = originalSeqStore->sequencesStart + startIdx;
+    resultSeqStore->sequences = originalSeqStore->sequencesStart + endIdx;
+    if (endIdx == (size_t)(originalSeqStore->sequences - originalSeqStore->sequencesStart)) {
+        /* This accounts for possible last literals if the derived chunk reaches the end of the block */
+        assert(resultSeqStore->lit == originalSeqStore->lit);
+    } else {
+        size_t const literalsBytes = ZSTD_countSeqStoreLiteralsBytes(resultSeqStore);
+        resultSeqStore->lit = resultSeqStore->litStart + literalsBytes;
+    }
+    resultSeqStore->llCode += startIdx;
+    resultSeqStore->mlCode += startIdx;
+    resultSeqStore->ofCode += startIdx;
+}
+
+/**
+ * Returns the raw offset represented by the combination of offBase, ll0, and repcode history.
+ * offBase must represent a repcode in the numeric representation of ZSTD_storeSeq().
+ */
+static U32
+ZSTD_resolveRepcodeToRawOffset(const U32 rep[ZSTD_REP_NUM], const U32 offBase, const U32 ll0)
+{
+    U32 const adjustedRepCode = OFFBASE_TO_REPCODE(offBase) - 1 + ll0;  /* [ 0 - 3 ] */
+    assert(OFFBASE_IS_REPCODE(offBase));
+    if (adjustedRepCode == ZSTD_REP_NUM) {
+        assert(ll0);
+        /* litlength == 0 and offCode == 2 implies selection of first repcode - 1
+         * This is only valid if it results in a valid offset value, aka > 0.
+         * Note : it may happen that `rep[0]==1` in exceptional circumstances.
+         * In which case this function will return 0, which is an invalid offset.
+         * It's not an issue though, since this value will be
+         * compared and discarded within ZSTD_seqStore_resolveOffCodes().
+         */
+        return rep[0] - 1;
+    }
+    return rep[adjustedRepCode];
+}
+
+/**
+ * ZSTD_seqStore_resolveOffCodes() reconciles any possible divergences in offset history that may arise
+ * due to emission of RLE/raw blocks that disturb the offset history,
+ * and replaces any repcodes within the seqStore that may be invalid.
+ *
+ * dRepcodes are updated as would be on the decompression side.
+ * cRepcodes are updated exactly in accordance with the seqStore.
+ *
+ * Note : this function assumes seq->offBase respects the following numbering scheme :
+ *        0 : invalid
+ *        1-3 : repcode 1-3
+ *        4+ : real_offset+3
+ */
+static void
+ZSTD_seqStore_resolveOffCodes(repcodes_t* const dRepcodes, repcodes_t* const cRepcodes,
+                        const seqStore_t* const seqStore, U32 const nbSeq)
+{
+    U32 idx = 0;
+    U32 const longLitLenIdx = seqStore->longLengthType == ZSTD_llt_literalLength ? seqStore->longLengthPos : nbSeq;
+    for (; idx < nbSeq; ++idx) {
+        seqDef* const seq = seqStore->sequencesStart + idx;
+        U32 const ll0 = (seq->litLength == 0) && (idx != longLitLenIdx);
+        U32 const offBase = seq->offBase;
+        assert(offBase > 0);
+        if (OFFBASE_IS_REPCODE(offBase)) {
+            U32 const dRawOffset = ZSTD_resolveRepcodeToRawOffset(dRepcodes->rep, offBase, ll0);
+            U32 const cRawOffset = ZSTD_resolveRepcodeToRawOffset(cRepcodes->rep, offBase, ll0);
+            /* Adjust simulated decompression repcode history if we come across a mismatch. Replace
+             * the repcode with the offset it actually references, determined by the compression
+             * repcode history.
+             */
+            if (dRawOffset != cRawOffset) {
+                seq->offBase = OFFSET_TO_OFFBASE(cRawOffset);
+            }
+        }
+        /* Compression repcode history is always updated with values directly from the unmodified seqStore.
+         * Decompression repcode history may use modified seq->offset value taken from compression repcode history.
+         */
+        ZSTD_updateRep(dRepcodes->rep, seq->offBase, ll0);
+        ZSTD_updateRep(cRepcodes->rep, offBase, ll0);
+    }
+}
+
+/* ZSTD_compressSeqStore_singleBlock():
+ * Compresses a seqStore into a block with a block header, into the buffer dst.
+ *
+ * Returns the total size of that block (including header) or a ZSTD error code.
+ */
+static size_t
+ZSTD_compressSeqStore_singleBlock(ZSTD_CCtx* zc,
+                            const seqStore_t* const seqStore,
+                                  repcodes_t* const dRep, repcodes_t* const cRep,
+                                  void* dst, size_t dstCapacity,
+                            const void* src, size_t srcSize,
+                                  U32 lastBlock, U32 isPartition)
+{
+    const U32 rleMaxLength = 25;
+    BYTE* op = (BYTE*)dst;
+    const BYTE* ip = (const BYTE*)src;
+    size_t cSize;
+    size_t cSeqsSize;
+
+    /* In case of an RLE or raw block, the simulated decompression repcode history must be reset */
+    repcodes_t const dRepOriginal = *dRep;
+    DEBUGLOG(5, "ZSTD_compressSeqStore_singleBlock");
+    if (isPartition)
+        ZSTD_seqStore_resolveOffCodes(dRep, cRep, seqStore, (U32)(seqStore->sequences - seqStore->sequencesStart));
+
+    RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize, dstSize_tooSmall, "Block header doesn't fit");
+    cSeqsSize = ZSTD_entropyCompressSeqStore(seqStore,
+                &zc->blockState.prevCBlock->entropy, &zc->blockState.nextCBlock->entropy,
+                &zc->appliedParams,
+                op + ZSTD_blockHeaderSize, dstCapacity - ZSTD_blockHeaderSize,
+                srcSize,
+                zc->entropyWorkspace, ENTROPY_WORKSPACE_SIZE /* statically allocated in resetCCtx */,
+                zc->bmi2);
+    FORWARD_IF_ERROR(cSeqsSize, "ZSTD_entropyCompressSeqStore failed!");
+
+    if (!zc->isFirstBlock &&
+        cSeqsSize < rleMaxLength &&
+        ZSTD_isRLE((BYTE const*)src, srcSize)) {
+        /* We don't want to emit our first block as a RLE even if it qualifies because
+        * doing so will cause the decoder (cli only) to throw a "should consume all input error."
+        * This is only an issue for zstd <= v1.4.3
+        */
+        cSeqsSize = 1;
+    }
+
+    if (zc->seqCollector.collectSequences) {
+        ZSTD_copyBlockSequences(zc);
+        ZSTD_blockState_confirmRepcodesAndEntropyTables(&zc->blockState);
+        return 0;
+    }
+
+    if (cSeqsSize == 0) {
+        cSize = ZSTD_noCompressBlock(op, dstCapacity, ip, srcSize, lastBlock);
+        FORWARD_IF_ERROR(cSize, "Nocompress block failed");
+        DEBUGLOG(4, "Writing out nocompress block, size: %zu", cSize);
+        *dRep = dRepOriginal; /* reset simulated decompression repcode history */
+    } else if (cSeqsSize == 1) {
+        cSize = ZSTD_rleCompressBlock(op, dstCapacity, *ip, srcSize, lastBlock);
+        FORWARD_IF_ERROR(cSize, "RLE compress block failed");
+        DEBUGLOG(4, "Writing out RLE block, size: %zu", cSize);
+        *dRep = dRepOriginal; /* reset simulated decompression repcode history */
+    } else {
+        ZSTD_blockState_confirmRepcodesAndEntropyTables(&zc->blockState);
+        writeBlockHeader(op, cSeqsSize, srcSize, lastBlock);
+        cSize = ZSTD_blockHeaderSize + cSeqsSize;
+        DEBUGLOG(4, "Writing out compressed block, size: %zu", cSize);
+    }
+
+    if (zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode == FSE_repeat_valid)
+        zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode = FSE_repeat_check;
+
+    return cSize;
+}
+
+/* Struct to keep track of where we are in our recursive calls. */
+typedef struct {
+    U32* splitLocations;    /* Array of split indices */
+    size_t idx;             /* The current index within splitLocations being worked on */
+} seqStoreSplits;
+
+#define MIN_SEQUENCES_BLOCK_SPLITTING 300
+
+/* Helper function to perform the recursive search for block splits.
+ * Estimates the cost of seqStore prior to split, and estimates the cost of splitting the sequences in half.
+ * If advantageous to split, then we recurse down the two sub-blocks.
+ * If not, or if an error occurred in estimation, then we do not recurse.
+ *
+ * Note: The recursion depth is capped by a heuristic minimum number of sequences,
+ * defined by MIN_SEQUENCES_BLOCK_SPLITTING.
+ * In theory, this means the absolute largest recursion depth is 10 == log2(maxNbSeqInBlock/MIN_SEQUENCES_BLOCK_SPLITTING).
+ * In practice, recursion depth usually doesn't go beyond 4.
+ *
+ * Furthermore, the number of splits is capped by ZSTD_MAX_NB_BLOCK_SPLITS.
+ * At ZSTD_MAX_NB_BLOCK_SPLITS == 196 with the current existing blockSize
+ * maximum of 128 KB, this value is actually impossible to reach.
+ */
+static void
+ZSTD_deriveBlockSplitsHelper(seqStoreSplits* splits, size_t startIdx, size_t endIdx,
+                             ZSTD_CCtx* zc, const seqStore_t* origSeqStore)
+{
+    seqStore_t* const fullSeqStoreChunk = &zc->blockSplitCtx.fullSeqStoreChunk;
+    seqStore_t* const firstHalfSeqStore = &zc->blockSplitCtx.firstHalfSeqStore;
+    seqStore_t* const secondHalfSeqStore = &zc->blockSplitCtx.secondHalfSeqStore;
+    size_t estimatedOriginalSize;
+    size_t estimatedFirstHalfSize;
+    size_t estimatedSecondHalfSize;
+    size_t midIdx = (startIdx + endIdx)/2;
+
+    DEBUGLOG(5, "ZSTD_deriveBlockSplitsHelper: startIdx=%zu endIdx=%zu", startIdx, endIdx);
+    assert(endIdx >= startIdx);
+    if (endIdx - startIdx < MIN_SEQUENCES_BLOCK_SPLITTING || splits->idx >= ZSTD_MAX_NB_BLOCK_SPLITS) {
+        DEBUGLOG(6, "ZSTD_deriveBlockSplitsHelper: Too few sequences (%zu)", endIdx - startIdx);
+        return;
+    }
+    ZSTD_deriveSeqStoreChunk(fullSeqStoreChunk, origSeqStore, startIdx, endIdx);
+    ZSTD_deriveSeqStoreChunk(firstHalfSeqStore, origSeqStore, startIdx, midIdx);
+    ZSTD_deriveSeqStoreChunk(secondHalfSeqStore, origSeqStore, midIdx, endIdx);
+    estimatedOriginalSize = ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize(fullSeqStoreChunk, zc);
+    estimatedFirstHalfSize = ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize(firstHalfSeqStore, zc);
+    estimatedSecondHalfSize = ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize(secondHalfSeqStore, zc);
+    DEBUGLOG(5, "Estimated original block size: %zu -- First half split: %zu -- Second half split: %zu",
+             estimatedOriginalSize, estimatedFirstHalfSize, estimatedSecondHalfSize);
+    if (ZSTD_isError(estimatedOriginalSize) || ZSTD_isError(estimatedFirstHalfSize) || ZSTD_isError(estimatedSecondHalfSize)) {
+        return;
+    }
+    if (estimatedFirstHalfSize + estimatedSecondHalfSize < estimatedOriginalSize) {
+        DEBUGLOG(5, "split decided at seqNb:%zu", midIdx);
+        ZSTD_deriveBlockSplitsHelper(splits, startIdx, midIdx, zc, origSeqStore);
+        splits->splitLocations[splits->idx] = (U32)midIdx;
+        splits->idx++;
+        ZSTD_deriveBlockSplitsHelper(splits, midIdx, endIdx, zc, origSeqStore);
+    }
+}
+
+/* Base recursive function.
+ * Populates a table with intra-block partition indices that can improve compression ratio.
+ *
+ * @return: number of splits made (which equals the size of the partition table - 1).
+ */
+static size_t ZSTD_deriveBlockSplits(ZSTD_CCtx* zc, U32 partitions[], U32 nbSeq)
+{
+    seqStoreSplits splits;
+    splits.splitLocations = partitions;
+    splits.idx = 0;
+    if (nbSeq <= 4) {
+        DEBUGLOG(5, "ZSTD_deriveBlockSplits: Too few sequences to split (%u <= 4)", nbSeq);
+        /* Refuse to try and split anything with less than 4 sequences */
+        return 0;
+    }
+    ZSTD_deriveBlockSplitsHelper(&splits, 0, nbSeq, zc, &zc->seqStore);
+    splits.splitLocations[splits.idx] = nbSeq;
+    DEBUGLOG(5, "ZSTD_deriveBlockSplits: final nb partitions: %zu", splits.idx+1);
+    return splits.idx;
+}
+
+/* ZSTD_compressBlock_splitBlock():
+ * Attempts to split a given block into multiple blocks to improve compression ratio.
+ *
+ * Returns combined size of all blocks (which includes headers), or a ZSTD error code.
+ */
+static size_t
+ZSTD_compressBlock_splitBlock_internal(ZSTD_CCtx* zc,
+                                    void* dst, size_t dstCapacity,
+                              const void* src, size_t blockSize,
+                                    U32 lastBlock, U32 nbSeq)
+{
+    size_t cSize = 0;
+    const BYTE* ip = (const BYTE*)src;
+    BYTE* op = (BYTE*)dst;
+    size_t i = 0;
+    size_t srcBytesTotal = 0;
+    U32* const partitions = zc->blockSplitCtx.partitions; /* size == ZSTD_MAX_NB_BLOCK_SPLITS */
+    seqStore_t* const nextSeqStore = &zc->blockSplitCtx.nextSeqStore;
+    seqStore_t* const currSeqStore = &zc->blockSplitCtx.currSeqStore;
+    size_t const numSplits = ZSTD_deriveBlockSplits(zc, partitions, nbSeq);
+
+    /* If a block is split and some partitions are emitted as RLE/uncompressed, then repcode history
+     * may become invalid. In order to reconcile potentially invalid repcodes, we keep track of two
+     * separate repcode histories that simulate repcode history on compression and decompression side,
+     * and use the histories to determine whether we must replace a particular repcode with its raw offset.
+     *
+     * 1) cRep gets updated for each partition, regardless of whether the block was emitted as uncompressed
+     *    or RLE. This allows us to retrieve the offset value that an invalid repcode references within
+     *    a nocompress/RLE block.
+     * 2) dRep gets updated only for compressed partitions, and when a repcode gets replaced, will use
+     *    the replacement offset value rather than the original repcode to update the repcode history.
+     *    dRep also will be the final repcode history sent to the next block.
+     *
+     * See ZSTD_seqStore_resolveOffCodes() for more details.
+     */
+    repcodes_t dRep;
+    repcodes_t cRep;
+    ZSTD_memcpy(dRep.rep, zc->blockState.prevCBlock->rep, sizeof(repcodes_t));
+    ZSTD_memcpy(cRep.rep, zc->blockState.prevCBlock->rep, sizeof(repcodes_t));
+    ZSTD_memset(nextSeqStore, 0, sizeof(seqStore_t));
+
+    DEBUGLOG(5, "ZSTD_compressBlock_splitBlock_internal (dstCapacity=%u, dictLimit=%u, nextToUpdate=%u)",
+                (unsigned)dstCapacity, (unsigned)zc->blockState.matchState.window.dictLimit,
+                (unsigned)zc->blockState.matchState.nextToUpdate);
+
+    if (numSplits == 0) {
+        size_t cSizeSingleBlock =
+            ZSTD_compressSeqStore_singleBlock(zc, &zc->seqStore,
+                                            &dRep, &cRep,
+                                            op, dstCapacity,
+                                            ip, blockSize,
+                                            lastBlock, 0 /* isPartition */);
+        FORWARD_IF_ERROR(cSizeSingleBlock, "Compressing single block from splitBlock_internal() failed!");
+        DEBUGLOG(5, "ZSTD_compressBlock_splitBlock_internal: No splits");
+        assert(zc->blockSize <= ZSTD_BLOCKSIZE_MAX);
+        assert(cSizeSingleBlock <= zc->blockSize + ZSTD_blockHeaderSize);
+        return cSizeSingleBlock;
+    }
+
+    ZSTD_deriveSeqStoreChunk(currSeqStore, &zc->seqStore, 0, partitions[0]);
+    for (i = 0; i <= numSplits; ++i) {
+        size_t cSizeChunk;
+        U32 const lastPartition = (i == numSplits);
+        U32 lastBlockEntireSrc = 0;
+
+        size_t srcBytes = ZSTD_countSeqStoreLiteralsBytes(currSeqStore) + ZSTD_countSeqStoreMatchBytes(currSeqStore);
+        srcBytesTotal += srcBytes;
+        if (lastPartition) {
+            /* This is the final partition, need to account for possible last literals */
+            srcBytes += blockSize - srcBytesTotal;
+            lastBlockEntireSrc = lastBlock;
+        } else {
+            ZSTD_deriveSeqStoreChunk(nextSeqStore, &zc->seqStore, partitions[i], partitions[i+1]);
+        }
+
+        cSizeChunk = ZSTD_compressSeqStore_singleBlock(zc, currSeqStore,
+                                                      &dRep, &cRep,
+                                                       op, dstCapacity,
+                                                       ip, srcBytes,
+                                                       lastBlockEntireSrc, 1 /* isPartition */);
+        DEBUGLOG(5, "Estimated size: %zu vs %zu : actual size",
+                    ZSTD_buildEntropyStatisticsAndEstimateSubBlockSize(currSeqStore, zc), cSizeChunk);
+        FORWARD_IF_ERROR(cSizeChunk, "Compressing chunk failed!");
+
+        ip += srcBytes;
+        op += cSizeChunk;
+        dstCapacity -= cSizeChunk;
+        cSize += cSizeChunk;
+        *currSeqStore = *nextSeqStore;
+        assert(cSizeChunk <= zc->blockSize + ZSTD_blockHeaderSize);
+    }
+    /* cRep and dRep may have diverged during the compression.
+     * If so, we use the dRep repcodes for the next block.
+     */
+    ZSTD_memcpy(zc->blockState.prevCBlock->rep, dRep.rep, sizeof(repcodes_t));
+    return cSize;
+}
+
+static size_t
+ZSTD_compressBlock_splitBlock(ZSTD_CCtx* zc,
+                              void* dst, size_t dstCapacity,
+                              const void* src, size_t srcSize, U32 lastBlock)
+{
+    U32 nbSeq;
+    size_t cSize;
+    DEBUGLOG(4, "ZSTD_compressBlock_splitBlock");
+    assert(zc->appliedParams.useBlockSplitter == ZSTD_ps_enable);
+
+    {   const size_t bss = ZSTD_buildSeqStore(zc, src, srcSize);
+        FORWARD_IF_ERROR(bss, "ZSTD_buildSeqStore failed");
+        if (bss == ZSTDbss_noCompress) {
+            if (zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode == FSE_repeat_valid)
+                zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode = FSE_repeat_check;
+            cSize = ZSTD_noCompressBlock(dst, dstCapacity, src, srcSize, lastBlock);
+            FORWARD_IF_ERROR(cSize, "ZSTD_noCompressBlock failed");
+            DEBUGLOG(4, "ZSTD_compressBlock_splitBlock: Nocompress block");
+            return cSize;
+        }
+        nbSeq = (U32)(zc->seqStore.sequences - zc->seqStore.sequencesStart);
+    }
+
+    cSize = ZSTD_compressBlock_splitBlock_internal(zc, dst, dstCapacity, src, srcSize, lastBlock, nbSeq);
+    FORWARD_IF_ERROR(cSize, "Splitting blocks failed!");
+    return cSize;
+}
+
+static size_t
+ZSTD_compressBlock_internal(ZSTD_CCtx* zc,
+                            void* dst, size_t dstCapacity,
+                            const void* src, size_t srcSize, U32 frame)
+{
+    /* This is an estimated upper bound for the length of an rle block.
+     * This isn't the actual upper bound.
+     * Finding the real threshold needs further investigation.
+     */
+    const U32 rleMaxLength = 25;
+    size_t cSize;
+    const BYTE* ip = (const BYTE*)src;
+    BYTE* op = (BYTE*)dst;
+    DEBUGLOG(5, "ZSTD_compressBlock_internal (dstCapacity=%u, dictLimit=%u, nextToUpdate=%u)",
+                (unsigned)dstCapacity, (unsigned)zc->blockState.matchState.window.dictLimit,
+                (unsigned)zc->blockState.matchState.nextToUpdate);
+
+    {   const size_t bss = ZSTD_buildSeqStore(zc, src, srcSize);
+        FORWARD_IF_ERROR(bss, "ZSTD_buildSeqStore failed");
+        if (bss == ZSTDbss_noCompress) { cSize = 0; goto out; }
+    }
+
+    if (zc->seqCollector.collectSequences) {
+        ZSTD_copyBlockSequences(zc);
+        ZSTD_blockState_confirmRepcodesAndEntropyTables(&zc->blockState);
+        return 0;
+    }
+
+    /* encode sequences and literals */
+    cSize = ZSTD_entropyCompressSeqStore(&zc->seqStore,
+            &zc->blockState.prevCBlock->entropy, &zc->blockState.nextCBlock->entropy,
+            &zc->appliedParams,
+            dst, dstCapacity,
+            srcSize,
+            zc->entropyWorkspace, ENTROPY_WORKSPACE_SIZE /* statically allocated in resetCCtx */,
+            zc->bmi2);
+
+    if (frame &&
+        /* We don't want to emit our first block as a RLE even if it qualifies because
+         * doing so will cause the decoder (cli only) to throw a "should consume all input error."
+         * This is only an issue for zstd <= v1.4.3
+         */
+        !zc->isFirstBlock &&
+        cSize < rleMaxLength &&
+        ZSTD_isRLE(ip, srcSize))
+    {
+        cSize = 1;
+        op[0] = ip[0];
+    }
+
+out:
+    if (!ZSTD_isError(cSize) && cSize > 1) {
+        ZSTD_blockState_confirmRepcodesAndEntropyTables(&zc->blockState);
+    }
+    /* We check that dictionaries have offset codes available for the first
+     * block. After the first block, the offcode table might not have large
+     * enough codes to represent the offsets in the data.
+     */
+    if (zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode == FSE_repeat_valid)
+        zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode = FSE_repeat_check;
+
+    return cSize;
+}
+
+static size_t ZSTD_compressBlock_targetCBlockSize_body(ZSTD_CCtx* zc,
+                               void* dst, size_t dstCapacity,
+                               const void* src, size_t srcSize,
+                               const size_t bss, U32 lastBlock)
+{
+    DEBUGLOG(6, "Attempting ZSTD_compressSuperBlock()");
+    if (bss == ZSTDbss_compress) {
+        if (/* We don't want to emit our first block as a RLE even if it qualifies because
+            * doing so will cause the decoder (cli only) to throw a "should consume all input error."
+            * This is only an issue for zstd <= v1.4.3
+            */
+            !zc->isFirstBlock &&
+            ZSTD_maybeRLE(&zc->seqStore) &&
+            ZSTD_isRLE((BYTE const*)src, srcSize))
+        {
+            return ZSTD_rleCompressBlock(dst, dstCapacity, *(BYTE const*)src, srcSize, lastBlock);
+        }
+        /* Attempt superblock compression.
+         *
+         * Note that compressed size of ZSTD_compressSuperBlock() is not bound by the
+         * standard ZSTD_compressBound(). This is a problem, because even if we have
+         * space now, taking an extra byte now could cause us to run out of space later
+         * and violate ZSTD_compressBound().
+         *
+         * Define blockBound(blockSize) = blockSize + ZSTD_blockHeaderSize.
+         *
+         * In order to respect ZSTD_compressBound() we must attempt to emit a raw
+         * uncompressed block in these cases:
+         *   * cSize == 0: Return code for an uncompressed block.
+         *   * cSize == dstSize_tooSmall: We may have expanded beyond blockBound(srcSize).
+         *     ZSTD_noCompressBlock() will return dstSize_tooSmall if we are really out of
+         *     output space.
+         *   * cSize >= blockBound(srcSize): We have expanded the block too much so
+         *     emit an uncompressed block.
+         */
+        {   size_t const cSize =
+                ZSTD_compressSuperBlock(zc, dst, dstCapacity, src, srcSize, lastBlock);
+            if (cSize != ERROR(dstSize_tooSmall)) {
+                size_t const maxCSize =
+                    srcSize - ZSTD_minGain(srcSize, zc->appliedParams.cParams.strategy);
+                FORWARD_IF_ERROR(cSize, "ZSTD_compressSuperBlock failed");
+                if (cSize != 0 && cSize < maxCSize + ZSTD_blockHeaderSize) {
+                    ZSTD_blockState_confirmRepcodesAndEntropyTables(&zc->blockState);
+                    return cSize;
+                }
+            }
+        }
+    } /* if (bss == ZSTDbss_compress)*/
+
+    DEBUGLOG(6, "Resorting to ZSTD_noCompressBlock()");
+    /* Superblock compression failed, attempt to emit a single no compress block.
+     * The decoder will be able to stream this block since it is uncompressed.
+     */
+    return ZSTD_noCompressBlock(dst, dstCapacity, src, srcSize, lastBlock);
+}
+
+static size_t ZSTD_compressBlock_targetCBlockSize(ZSTD_CCtx* zc,
+                               void* dst, size_t dstCapacity,
+                               const void* src, size_t srcSize,
+                               U32 lastBlock)
+{
+    size_t cSize = 0;
+    const size_t bss = ZSTD_buildSeqStore(zc, src, srcSize);
+    DEBUGLOG(5, "ZSTD_compressBlock_targetCBlockSize (dstCapacity=%u, dictLimit=%u, nextToUpdate=%u, srcSize=%zu)",
+                (unsigned)dstCapacity, (unsigned)zc->blockState.matchState.window.dictLimit, (unsigned)zc->blockState.matchState.nextToUpdate, srcSize);
+    FORWARD_IF_ERROR(bss, "ZSTD_buildSeqStore failed");
+
+    cSize = ZSTD_compressBlock_targetCBlockSize_body(zc, dst, dstCapacity, src, srcSize, bss, lastBlock);
+    FORWARD_IF_ERROR(cSize, "ZSTD_compressBlock_targetCBlockSize_body failed");
+
+    if (zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode == FSE_repeat_valid)
+        zc->blockState.prevCBlock->entropy.fse.offcode_repeatMode = FSE_repeat_check;
+
+    return cSize;
+}
+
+static void ZSTD_overflowCorrectIfNeeded(ZSTD_matchState_t* ms,
+                                         ZSTD_cwksp* ws,
+                                         ZSTD_CCtx_params const* params,
+                                         void const* ip,
+                                         void const* iend)
+{
+    U32 const cycleLog = ZSTD_cycleLog(params->cParams.chainLog, params->cParams.strategy);
+    U32 const maxDist = (U32)1 << params->cParams.windowLog;
+    if (ZSTD_window_needOverflowCorrection(ms->window, cycleLog, maxDist, ms->loadedDictEnd, ip, iend)) {
+        U32 const correction = ZSTD_window_correctOverflow(&ms->window, cycleLog, maxDist, ip);
+        ZSTD_STATIC_ASSERT(ZSTD_CHAINLOG_MAX <= 30);
+        ZSTD_STATIC_ASSERT(ZSTD_WINDOWLOG_MAX_32 <= 30);
+        ZSTD_STATIC_ASSERT(ZSTD_WINDOWLOG_MAX <= 31);
+        ZSTD_cwksp_mark_tables_dirty(ws);
+        ZSTD_reduceIndex(ms, params, correction);
+        ZSTD_cwksp_mark_tables_clean(ws);
+        if (ms->nextToUpdate < correction) ms->nextToUpdate = 0;
+        else ms->nextToUpdate -= correction;
+        /* invalidate dictionaries on overflow correction */
+        ms->loadedDictEnd = 0;
+        ms->dictMatchState = NULL;
+    }
+}
+
+/*! ZSTD_compress_frameChunk() :
+*   Compress a chunk of data into one or multiple blocks.
+*   All blocks will be terminated, all input will be consumed.
+*   Function will issue an error if there is not enough `dstCapacity` to hold the compressed content.
+*   Frame is supposed already started (header already produced)
+*  @return : compressed size, or an error code
+*/
+static size_t ZSTD_compress_frameChunk(ZSTD_CCtx* cctx,
+                                     void* dst, size_t dstCapacity,
+                               const void* src, size_t srcSize,
+                                     U32 lastFrameChunk)
+{
+    size_t blockSize = cctx->blockSize;
+    size_t remaining = srcSize;
+    const BYTE* ip = (const BYTE*)src;
+    BYTE* const ostart = (BYTE*)dst;
+    BYTE* op = ostart;
+    U32 const maxDist = (U32)1 << cctx->appliedParams.cParams.windowLog;
+
+    assert(cctx->appliedParams.cParams.windowLog <= ZSTD_WINDOWLOG_MAX);
+
+    DEBUGLOG(4, "ZSTD_compress_frameChunk (blockSize=%u)", (unsigned)blockSize);
+    if (cctx->appliedParams.fParams.checksumFlag && srcSize)
+        XXH64_update(&cctx->xxhState, src, srcSize);
+
+    while (remaining) {
+        ZSTD_matchState_t* const ms = &cctx->blockState.matchState;
+        U32 const lastBlock = lastFrameChunk & (blockSize >= remaining);
+
+        /* TODO: See 3090. We reduced MIN_CBLOCK_SIZE from 3 to 2 so to compensate we are adding
+         * additional 1. We need to revisit and change this logic to be more consistent */
+        RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize + MIN_CBLOCK_SIZE + 1,
+                        dstSize_tooSmall,
+                        "not enough space to store compressed block");
+        if (remaining < blockSize) blockSize = remaining;
+
+        ZSTD_overflowCorrectIfNeeded(
+            ms, &cctx->workspace, &cctx->appliedParams, ip, ip + blockSize);
+        ZSTD_checkDictValidity(&ms->window, ip + blockSize, maxDist, &ms->loadedDictEnd, &ms->dictMatchState);
+        ZSTD_window_enforceMaxDist(&ms->window, ip, maxDist, &ms->loadedDictEnd, &ms->dictMatchState);
+
+        /* Ensure hash/chain table insertion resumes no sooner than lowlimit */
+        if (ms->nextToUpdate < ms->window.lowLimit) ms->nextToUpdate = ms->window.lowLimit;
+
+        {   size_t cSize;
+            if (ZSTD_useTargetCBlockSize(&cctx->appliedParams)) {
+                cSize = ZSTD_compressBlock_targetCBlockSize(cctx, op, dstCapacity, ip, blockSize, lastBlock);
+                FORWARD_IF_ERROR(cSize, "ZSTD_compressBlock_targetCBlockSize failed");
+                assert(cSize > 0);
+                assert(cSize <= blockSize + ZSTD_blockHeaderSize);
+            } else if (ZSTD_blockSplitterEnabled(&cctx->appliedParams)) {
+                cSize = ZSTD_compressBlock_splitBlock(cctx, op, dstCapacity, ip, blockSize, lastBlock);
+                FORWARD_IF_ERROR(cSize, "ZSTD_compressBlock_splitBlock failed");
+                assert(cSize > 0 || cctx->seqCollector.collectSequences == 1);
+            } else {
+                cSize = ZSTD_compressBlock_internal(cctx,
+                                        op+ZSTD_blockHeaderSize, dstCapacity-ZSTD_blockHeaderSize,
+                                        ip, blockSize, 1 /* frame */);
+                FORWARD_IF_ERROR(cSize, "ZSTD_compressBlock_internal failed");
+
+                if (cSize == 0) {  /* block is not compressible */
+                    cSize = ZSTD_noCompressBlock(op, dstCapacity, ip, blockSize, lastBlock);
+                    FORWARD_IF_ERROR(cSize, "ZSTD_noCompressBlock failed");
+                } else {
+                    U32 const cBlockHeader = cSize == 1 ?
+                        lastBlock + (((U32)bt_rle)<<1) + (U32)(blockSize << 3) :
+                        lastBlock + (((U32)bt_compressed)<<1) + (U32)(cSize << 3);
+                    MEM_writeLE24(op, cBlockHeader);
+                    cSize += ZSTD_blockHeaderSize;
+                }
+            }  /* if (ZSTD_useTargetCBlockSize(&cctx->appliedParams))*/
+
+
+            ip += blockSize;
+            assert(remaining >= blockSize);
+            remaining -= blockSize;
+            op += cSize;
+            assert(dstCapacity >= cSize);
+            dstCapacity -= cSize;
+            cctx->isFirstBlock = 0;
+            DEBUGLOG(5, "ZSTD_compress_frameChunk: adding a block of size %u",
+                        (unsigned)cSize);
+    }   }
+
+    if (lastFrameChunk && (op>ostart)) cctx->stage = ZSTDcs_ending;
+    return (size_t)(op-ostart);
+}
+
+
+static size_t ZSTD_writeFrameHeader(void* dst, size_t dstCapacity,
+                                    const ZSTD_CCtx_params* params, U64 pledgedSrcSize, U32 dictID)
+{   BYTE* const op = (BYTE*)dst;
+    U32   const dictIDSizeCodeLength = (dictID>0) + (dictID>=256) + (dictID>=65536);   /* 0-3 */
+    U32   const dictIDSizeCode = params->fParams.noDictIDFlag ? 0 : dictIDSizeCodeLength;   /* 0-3 */
+    U32   const checksumFlag = params->fParams.checksumFlag>0;
+    U32   const windowSize = (U32)1 << params->cParams.windowLog;
+    U32   const singleSegment = params->fParams.contentSizeFlag && (windowSize >= pledgedSrcSize);
+    BYTE  const windowLogByte = (BYTE)((params->cParams.windowLog - ZSTD_WINDOWLOG_ABSOLUTEMIN) << 3);
+    U32   const fcsCode = params->fParams.contentSizeFlag ?
+                     (pledgedSrcSize>=256) + (pledgedSrcSize>=65536+256) + (pledgedSrcSize>=0xFFFFFFFFU) : 0;  /* 0-3 */
+    BYTE  const frameHeaderDescriptionByte = (BYTE)(dictIDSizeCode + (checksumFlag<<2) + (singleSegment<<5) + (fcsCode<<6) );
+    size_t pos=0;
+
+    assert(!(params->fParams.contentSizeFlag && pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN));
+    RETURN_ERROR_IF(dstCapacity < ZSTD_FRAMEHEADERSIZE_MAX, dstSize_tooSmall,
+                    "dst buf is too small to fit worst-case frame header size.");
+    DEBUGLOG(4, "ZSTD_writeFrameHeader : dictIDFlag : %u ; dictID : %u ; dictIDSizeCode : %u",
+                !params->fParams.noDictIDFlag, (unsigned)dictID, (unsigned)dictIDSizeCode);
+    if (params->format == ZSTD_f_zstd1) {
+        MEM_writeLE32(dst, ZSTD_MAGICNUMBER);
+        pos = 4;
+    }
+    op[pos++] = frameHeaderDescriptionByte;
+    if (!singleSegment) op[pos++] = windowLogByte;
+    switch(dictIDSizeCode)
+    {
+        default:
+            assert(0); /* impossible */
+            ZSTD_FALLTHROUGH;
+        case 0 : break;
+        case 1 : op[pos] = (BYTE)(dictID); pos++; break;
+        case 2 : MEM_writeLE16(op+pos, (U16)dictID); pos+=2; break;
+        case 3 : MEM_writeLE32(op+pos, dictID); pos+=4; break;
+    }
+    switch(fcsCode)
+    {
+        default:
+            assert(0); /* impossible */
+            ZSTD_FALLTHROUGH;
+        case 0 : if (singleSegment) op[pos++] = (BYTE)(pledgedSrcSize); break;
+        case 1 : MEM_writeLE16(op+pos, (U16)(pledgedSrcSize-256)); pos+=2; break;
+        case 2 : MEM_writeLE32(op+pos, (U32)(pledgedSrcSize)); pos+=4; break;
+        case 3 : MEM_writeLE64(op+pos, (U64)(pledgedSrcSize)); pos+=8; break;
+    }
+    return pos;
+}
+
+/* ZSTD_writeSkippableFrame_advanced() :
+ * Writes out a skippable frame with the specified magic number variant (16 are supported),
+ * from ZSTD_MAGIC_SKIPPABLE_START to ZSTD_MAGIC_SKIPPABLE_START+15, and the desired source data.
+ *
+ * Returns the total number of bytes written, or a ZSTD error code.
+ */
+size_t ZSTD_writeSkippableFrame(void* dst, size_t dstCapacity,
+                                const void* src, size_t srcSize, unsigned magicVariant) {
+    BYTE* op = (BYTE*)dst;
+    RETURN_ERROR_IF(dstCapacity < srcSize + ZSTD_SKIPPABLEHEADERSIZE /* Skippable frame overhead */,
+                    dstSize_tooSmall, "Not enough room for skippable frame");
+    RETURN_ERROR_IF(srcSize > (unsigned)0xFFFFFFFF, srcSize_wrong, "Src size too large for skippable frame");
+    RETURN_ERROR_IF(magicVariant > 15, parameter_outOfBound, "Skippable frame magic number variant not supported");
+
+    MEM_writeLE32(op, (U32)(ZSTD_MAGIC_SKIPPABLE_START + magicVariant));
+    MEM_writeLE32(op+4, (U32)srcSize);
+    ZSTD_memcpy(op+8, src, srcSize);
+    return srcSize + ZSTD_SKIPPABLEHEADERSIZE;
+}
+
+/* ZSTD_writeLastEmptyBlock() :
+ * output an empty Block with end-of-frame mark to complete a frame
+ * @return : size of data written into `dst` (== ZSTD_blockHeaderSize (defined in zstd_internal.h))
+ *           or an error code if `dstCapacity` is too small (<ZSTD_blockHeaderSize)
+ */
+size_t ZSTD_writeLastEmptyBlock(void* dst, size_t dstCapacity)
+{
+    RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize, dstSize_tooSmall,
+                    "dst buf is too small to write frame trailer empty block.");
+    {   U32 const cBlockHeader24 = 1 /*lastBlock*/ + (((U32)bt_raw)<<1);  /* 0 size */
+        MEM_writeLE24(dst, cBlockHeader24);
+        return ZSTD_blockHeaderSize;
+    }
+}
+
+size_t ZSTD_referenceExternalSequences(ZSTD_CCtx* cctx, rawSeq* seq, size_t nbSeq)
+{
+    RETURN_ERROR_IF(cctx->stage != ZSTDcs_init, stage_wrong,
+                    "wrong cctx stage");
+    RETURN_ERROR_IF(cctx->appliedParams.ldmParams.enableLdm == ZSTD_ps_enable,
+                    parameter_unsupported,
+                    "incompatible with ldm");
+    cctx->externSeqStore.seq = seq;
+    cctx->externSeqStore.size = nbSeq;
+    cctx->externSeqStore.capacity = nbSeq;
+    cctx->externSeqStore.pos = 0;
+    cctx->externSeqStore.posInSequence = 0;
+    return 0;
+}
+
+
+static size_t ZSTD_compressContinue_internal (ZSTD_CCtx* cctx,
+                              void* dst, size_t dstCapacity,
+                        const void* src, size_t srcSize,
+                               U32 frame, U32 lastFrameChunk)
+{
+    ZSTD_matchState_t* const ms = &cctx->blockState.matchState;
+    size_t fhSize = 0;
+
+    DEBUGLOG(5, "ZSTD_compressContinue_internal, stage: %u, srcSize: %u",
+                cctx->stage, (unsigned)srcSize);
+    RETURN_ERROR_IF(cctx->stage==ZSTDcs_created, stage_wrong,
+                    "missing init (ZSTD_compressBegin)");
+
+    if (frame && (cctx->stage==ZSTDcs_init)) {
+        fhSize = ZSTD_writeFrameHeader(dst, dstCapacity, &cctx->appliedParams,
+                                       cctx->pledgedSrcSizePlusOne-1, cctx->dictID);
+        FORWARD_IF_ERROR(fhSize, "ZSTD_writeFrameHeader failed");
+        assert(fhSize <= dstCapacity);
+        dstCapacity -= fhSize;
+        dst = (char*)dst + fhSize;
+        cctx->stage = ZSTDcs_ongoing;
+    }
+
+    if (!srcSize) return fhSize;  /* do not generate an empty block if no input */
+
+    if (!ZSTD_window_update(&ms->window, src, srcSize, ms->forceNonContiguous)) {
+        ms->forceNonContiguous = 0;
+        ms->nextToUpdate = ms->window.dictLimit;
+    }
+    if (cctx->appliedParams.ldmParams.enableLdm == ZSTD_ps_enable) {
+        ZSTD_window_update(&cctx->ldmState.window, src, srcSize, /* forceNonContiguous */ 0);
+    }
+
+    if (!frame) {
+        /* overflow check and correction for block mode */
+        ZSTD_overflowCorrectIfNeeded(
+            ms, &cctx->workspace, &cctx->appliedParams,
+            src, (BYTE const*)src + srcSize);
+    }
+
+    DEBUGLOG(5, "ZSTD_compressContinue_internal (blockSize=%u)", (unsigned)cctx->blockSize);
+    {   size_t const cSize = frame ?
+                             ZSTD_compress_frameChunk (cctx, dst, dstCapacity, src, srcSize, lastFrameChunk) :
+                             ZSTD_compressBlock_internal (cctx, dst, dstCapacity, src, srcSize, 0 /* frame */);
+        FORWARD_IF_ERROR(cSize, "%s", frame ? "ZSTD_compress_frameChunk failed" : "ZSTD_compressBlock_internal failed");
+        cctx->consumedSrcSize += srcSize;
+        cctx->producedCSize += (cSize + fhSize);
+        assert(!(cctx->appliedParams.fParams.contentSizeFlag && cctx->pledgedSrcSizePlusOne == 0));
+        if (cctx->pledgedSrcSizePlusOne != 0) {  /* control src size */
+            ZSTD_STATIC_ASSERT(ZSTD_CONTENTSIZE_UNKNOWN == (unsigned long long)-1);
+            RETURN_ERROR_IF(
+                cctx->consumedSrcSize+1 > cctx->pledgedSrcSizePlusOne,
+                srcSize_wrong,
+                "error : pledgedSrcSize = %u, while realSrcSize >= %u",
+                (unsigned)cctx->pledgedSrcSizePlusOne-1,
+                (unsigned)cctx->consumedSrcSize);
+        }
+        return cSize + fhSize;
+    }
+}
+
+size_t ZSTD_compressContinue_public(ZSTD_CCtx* cctx,
+                                        void* dst, size_t dstCapacity,
+                                  const void* src, size_t srcSize)
+{
+    DEBUGLOG(5, "ZSTD_compressContinue (srcSize=%u)", (unsigned)srcSize);
+    return ZSTD_compressContinue_internal(cctx, dst, dstCapacity, src, srcSize, 1 /* frame mode */, 0 /* last chunk */);
+}
+
+/* NOTE: Must just wrap ZSTD_compressContinue_public() */
+size_t ZSTD_compressContinue(ZSTD_CCtx* cctx,
+                             void* dst, size_t dstCapacity,
+                       const void* src, size_t srcSize)
+{
+    return ZSTD_compressContinue_public(cctx, dst, dstCapacity, src, srcSize);
+}
+
+static size_t ZSTD_getBlockSize_deprecated(const ZSTD_CCtx* cctx)
+{
+    ZSTD_compressionParameters const cParams = cctx->appliedParams.cParams;
+    assert(!ZSTD_checkCParams(cParams));
+    return MIN(cctx->appliedParams.maxBlockSize, (size_t)1 << cParams.windowLog);
+}
+
+/* NOTE: Must just wrap ZSTD_getBlockSize_deprecated() */
+size_t ZSTD_getBlockSize(const ZSTD_CCtx* cctx)
+{
+    return ZSTD_getBlockSize_deprecated(cctx);
+}
+
+/* NOTE: Must just wrap ZSTD_compressBlock_deprecated() */
+size_t ZSTD_compressBlock_deprecated(ZSTD_CCtx* cctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize)
+{
+    DEBUGLOG(5, "ZSTD_compressBlock: srcSize = %u", (unsigned)srcSize);
+    { size_t const blockSizeMax = ZSTD_getBlockSize_deprecated(cctx);
+      RETURN_ERROR_IF(srcSize > blockSizeMax, srcSize_wrong, "input is larger than a block"); }
+
+    return ZSTD_compressContinue_internal(cctx, dst, dstCapacity, src, srcSize, 0 /* frame mode */, 0 /* last chunk */);
+}
+
+/* NOTE: Must just wrap ZSTD_compressBlock_deprecated() */
+size_t ZSTD_compressBlock(ZSTD_CCtx* cctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_deprecated(cctx, dst, dstCapacity, src, srcSize);
+}
+
+/*! ZSTD_loadDictionaryContent() :
+ *  @return : 0, or an error code
+ */
+static size_t ZSTD_loadDictionaryContent(ZSTD_matchState_t* ms,
+                                         ldmState_t* ls,
+                                         ZSTD_cwksp* ws,
+                                         ZSTD_CCtx_params const* params,
+                                         const void* src, size_t srcSize,
+                                         ZSTD_dictTableLoadMethod_e dtlm,
+                                         ZSTD_tableFillPurpose_e tfp)
+{
+    const BYTE* ip = (const BYTE*) src;
+    const BYTE* const iend = ip + srcSize;
+    int const loadLdmDict = params->ldmParams.enableLdm == ZSTD_ps_enable && ls != NULL;
+
+    /* Assert that the ms params match the params we're being given */
+    ZSTD_assertEqualCParams(params->cParams, ms->cParams);
+
+    {   /* Ensure large dictionaries can't cause index overflow */
+
+        /* Allow the dictionary to set indices up to exactly ZSTD_CURRENT_MAX.
+         * Dictionaries right at the edge will immediately trigger overflow
+         * correction, but I don't want to insert extra constraints here.
+         */
+        U32 maxDictSize = ZSTD_CURRENT_MAX - ZSTD_WINDOW_START_INDEX;
+
+        int const CDictTaggedIndices = ZSTD_CDictIndicesAreTagged(&params->cParams);
+        if (CDictTaggedIndices && tfp == ZSTD_tfp_forCDict) {
+            /* Some dictionary matchfinders in zstd use "short cache",
+             * which treats the lower ZSTD_SHORT_CACHE_TAG_BITS of each
+             * CDict hashtable entry as a tag rather than as part of an index.
+             * When short cache is used, we need to truncate the dictionary
+             * so that its indices don't overlap with the tag. */
+            U32 const shortCacheMaxDictSize = (1u << (32 - ZSTD_SHORT_CACHE_TAG_BITS)) - ZSTD_WINDOW_START_INDEX;
+            maxDictSize = MIN(maxDictSize, shortCacheMaxDictSize);
+            assert(!loadLdmDict);
+        }
+
+        /* If the dictionary is too large, only load the suffix of the dictionary. */
+        if (srcSize > maxDictSize) {
+            ip = iend - maxDictSize;
+            src = ip;
+            srcSize = maxDictSize;
+        }
+    }
+
+    if (srcSize > ZSTD_CHUNKSIZE_MAX) {
+        /* We must have cleared our windows when our source is this large. */
+        assert(ZSTD_window_isEmpty(ms->window));
+        if (loadLdmDict) assert(ZSTD_window_isEmpty(ls->window));
+    }
+    ZSTD_window_update(&ms->window, src, srcSize, /* forceNonContiguous */ 0);
+
+    DEBUGLOG(4, "ZSTD_loadDictionaryContent(): useRowMatchFinder=%d", (int)params->useRowMatchFinder);
+
+    if (loadLdmDict) { /* Load the entire dict into LDM matchfinders. */
+        ZSTD_window_update(&ls->window, src, srcSize, /* forceNonContiguous */ 0);
+        ls->loadedDictEnd = params->forceWindow ? 0 : (U32)(iend - ls->window.base);
+        ZSTD_ldm_fillHashTable(ls, ip, iend, &params->ldmParams);
+    }
+
+    /* If the dict is larger than we can reasonably index in our tables, only load the suffix. */
+    if (params->cParams.strategy < ZSTD_btultra) {
+        U32 maxDictSize = 8U << MIN(MAX(params->cParams.hashLog, params->cParams.chainLog), 28);
+        if (srcSize > maxDictSize) {
+            ip = iend - maxDictSize;
+            src = ip;
+            srcSize = maxDictSize;
+        }
+    }
+
+    ms->nextToUpdate = (U32)(ip - ms->window.base);
+    ms->loadedDictEnd = params->forceWindow ? 0 : (U32)(iend - ms->window.base);
+    ms->forceNonContiguous = params->deterministicRefPrefix;
+
+    if (srcSize <= HASH_READ_SIZE) return 0;
+
+    ZSTD_overflowCorrectIfNeeded(ms, ws, params, ip, iend);
+
+    switch(params->cParams.strategy)
+    {
+    case ZSTD_fast:
+        ZSTD_fillHashTable(ms, iend, dtlm, tfp);
+        break;
+    case ZSTD_dfast:
+        ZSTD_fillDoubleHashTable(ms, iend, dtlm, tfp);
+        break;
+
+    case ZSTD_greedy:
+    case ZSTD_lazy:
+    case ZSTD_lazy2:
+        assert(srcSize >= HASH_READ_SIZE);
+        if (ms->dedicatedDictSearch) {
+            assert(ms->chainTable != NULL);
+            ZSTD_dedicatedDictSearch_lazy_loadDictionary(ms, iend-HASH_READ_SIZE);
+        } else {
+            assert(params->useRowMatchFinder != ZSTD_ps_auto);
+            if (params->useRowMatchFinder == ZSTD_ps_enable) {
+                size_t const tagTableSize = ((size_t)1 << params->cParams.hashLog);
+                ZSTD_memset(ms->tagTable, 0, tagTableSize);
+                ZSTD_row_update(ms, iend-HASH_READ_SIZE);
+                DEBUGLOG(4, "Using row-based hash table for lazy dict");
+            } else {
+                ZSTD_insertAndFindFirstIndex(ms, iend-HASH_READ_SIZE);
+                DEBUGLOG(4, "Using chain-based hash table for lazy dict");
+            }
+        }
+        break;
+
+    case ZSTD_btlazy2:   /* we want the dictionary table fully sorted */
+    case ZSTD_btopt:
+    case ZSTD_btultra:
+    case ZSTD_btultra2:
+        assert(srcSize >= HASH_READ_SIZE);
+        ZSTD_updateTree(ms, iend-HASH_READ_SIZE, iend);
+        break;
+
+    default:
+        assert(0);  /* not possible : not a valid strategy id */
+    }
+
+    ms->nextToUpdate = (U32)(iend - ms->window.base);
+    return 0;
+}
+
+
+/* Dictionaries that assign zero probability to symbols that show up causes problems
+ * when FSE encoding. Mark dictionaries with zero probability symbols as FSE_repeat_check
+ * and only dictionaries with 100% valid symbols can be assumed valid.
+ */
+static FSE_repeat ZSTD_dictNCountRepeat(short* normalizedCounter, unsigned dictMaxSymbolValue, unsigned maxSymbolValue)
+{
+    U32 s;
+    if (dictMaxSymbolValue < maxSymbolValue) {
+        return FSE_repeat_check;
+    }
+    for (s = 0; s <= maxSymbolValue; ++s) {
+        if (normalizedCounter[s] == 0) {
+            return FSE_repeat_check;
+        }
+    }
+    return FSE_repeat_valid;
+}
+
+size_t ZSTD_loadCEntropy(ZSTD_compressedBlockState_t* bs, void* workspace,
+                         const void* const dict, size_t dictSize)
+{
+    short offcodeNCount[MaxOff+1];
+    unsigned offcodeMaxValue = MaxOff;
+    const BYTE* dictPtr = (const BYTE*)dict;    /* skip magic num and dict ID */
+    const BYTE* const dictEnd = dictPtr + dictSize;
+    dictPtr += 8;
+    bs->entropy.huf.repeatMode = HUF_repeat_check;
+
+    {   unsigned maxSymbolValue = 255;
+        unsigned hasZeroWeights = 1;
+        size_t const hufHeaderSize = HUF_readCTable((HUF_CElt*)bs->entropy.huf.CTable, &maxSymbolValue, dictPtr,
+            dictEnd-dictPtr, &hasZeroWeights);
+
+        /* We only set the loaded table as valid if it contains all non-zero
+         * weights. Otherwise, we set it to check */
+        if (!hasZeroWeights)
+            bs->entropy.huf.repeatMode = HUF_repeat_valid;
+
+        RETURN_ERROR_IF(HUF_isError(hufHeaderSize), dictionary_corrupted, "");
+        RETURN_ERROR_IF(maxSymbolValue < 255, dictionary_corrupted, "");
+        dictPtr += hufHeaderSize;
+    }
+
+    {   unsigned offcodeLog;
+        size_t const offcodeHeaderSize = FSE_readNCount(offcodeNCount, &offcodeMaxValue, &offcodeLog, dictPtr, dictEnd-dictPtr);
+        RETURN_ERROR_IF(FSE_isError(offcodeHeaderSize), dictionary_corrupted, "");
+        RETURN_ERROR_IF(offcodeLog > OffFSELog, dictionary_corrupted, "");
+        /* fill all offset symbols to avoid garbage at end of table */
+        RETURN_ERROR_IF(FSE_isError(FSE_buildCTable_wksp(
+                bs->entropy.fse.offcodeCTable,
+                offcodeNCount, MaxOff, offcodeLog,
+                workspace, HUF_WORKSPACE_SIZE)),
+            dictionary_corrupted, "");
+        /* Defer checking offcodeMaxValue because we need to know the size of the dictionary content */
+        dictPtr += offcodeHeaderSize;
+    }
+
+    {   short matchlengthNCount[MaxML+1];
+        unsigned matchlengthMaxValue = MaxML, matchlengthLog;
+        size_t const matchlengthHeaderSize = FSE_readNCount(matchlengthNCount, &matchlengthMaxValue, &matchlengthLog, dictPtr, dictEnd-dictPtr);
+        RETURN_ERROR_IF(FSE_isError(matchlengthHeaderSize), dictionary_corrupted, "");
+        RETURN_ERROR_IF(matchlengthLog > MLFSELog, dictionary_corrupted, "");
+        RETURN_ERROR_IF(FSE_isError(FSE_buildCTable_wksp(
+                bs->entropy.fse.matchlengthCTable,
+                matchlengthNCount, matchlengthMaxValue, matchlengthLog,
+                workspace, HUF_WORKSPACE_SIZE)),
+            dictionary_corrupted, "");
+        bs->entropy.fse.matchlength_repeatMode = ZSTD_dictNCountRepeat(matchlengthNCount, matchlengthMaxValue, MaxML);
+        dictPtr += matchlengthHeaderSize;
+    }
+
+    {   short litlengthNCount[MaxLL+1];
+        unsigned litlengthMaxValue = MaxLL, litlengthLog;
+        size_t const litlengthHeaderSize = FSE_readNCount(litlengthNCount, &litlengthMaxValue, &litlengthLog, dictPtr, dictEnd-dictPtr);
+        RETURN_ERROR_IF(FSE_isError(litlengthHeaderSize), dictionary_corrupted, "");
+        RETURN_ERROR_IF(litlengthLog > LLFSELog, dictionary_corrupted, "");
+        RETURN_ERROR_IF(FSE_isError(FSE_buildCTable_wksp(
+                bs->entropy.fse.litlengthCTable,
+                litlengthNCount, litlengthMaxValue, litlengthLog,
+                workspace, HUF_WORKSPACE_SIZE)),
+            dictionary_corrupted, "");
+        bs->entropy.fse.litlength_repeatMode = ZSTD_dictNCountRepeat(litlengthNCount, litlengthMaxValue, MaxLL);
+        dictPtr += litlengthHeaderSize;
+    }
+
+    RETURN_ERROR_IF(dictPtr+12 > dictEnd, dictionary_corrupted, "");
+    bs->rep[0] = MEM_readLE32(dictPtr+0);
+    bs->rep[1] = MEM_readLE32(dictPtr+4);
+    bs->rep[2] = MEM_readLE32(dictPtr+8);
+    dictPtr += 12;
+
+    {   size_t const dictContentSize = (size_t)(dictEnd - dictPtr);
+        U32 offcodeMax = MaxOff;
+        if (dictContentSize <= ((U32)-1) - 128 KB) {
+            U32 const maxOffset = (U32)dictContentSize + 128 KB; /* The maximum offset that must be supported */
+            offcodeMax = ZSTD_highbit32(maxOffset); /* Calculate minimum offset code required to represent maxOffset */
+        }
+        /* All offset values <= dictContentSize + 128 KB must be representable for a valid table */
+        bs->entropy.fse.offcode_repeatMode = ZSTD_dictNCountRepeat(offcodeNCount, offcodeMaxValue, MIN(offcodeMax, MaxOff));
+
+        /* All repCodes must be <= dictContentSize and != 0 */
+        {   U32 u;
+            for (u=0; u<3; u++) {
+                RETURN_ERROR_IF(bs->rep[u] == 0, dictionary_corrupted, "");
+                RETURN_ERROR_IF(bs->rep[u] > dictContentSize, dictionary_corrupted, "");
+    }   }   }
+
+    return dictPtr - (const BYTE*)dict;
+}
+
+/* Dictionary format :
+ * See :
+ * https://github.com/facebook/zstd/blob/release/doc/zstd_compression_format.md#dictionary-format
+ */
+/*! ZSTD_loadZstdDictionary() :
+ * @return : dictID, or an error code
+ *  assumptions : magic number supposed already checked
+ *                dictSize supposed >= 8
+ */
+static size_t ZSTD_loadZstdDictionary(ZSTD_compressedBlockState_t* bs,
+                                      ZSTD_matchState_t* ms,
+                                      ZSTD_cwksp* ws,
+                                      ZSTD_CCtx_params const* params,
+                                      const void* dict, size_t dictSize,
+                                      ZSTD_dictTableLoadMethod_e dtlm,
+                                      ZSTD_tableFillPurpose_e tfp,
+                                      void* workspace)
+{
+    const BYTE* dictPtr = (const BYTE*)dict;
+    const BYTE* const dictEnd = dictPtr + dictSize;
+    size_t dictID;
+    size_t eSize;
+    ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog)));
+    assert(dictSize >= 8);
+    assert(MEM_readLE32(dictPtr) == ZSTD_MAGIC_DICTIONARY);
+
+    dictID = params->fParams.noDictIDFlag ? 0 :  MEM_readLE32(dictPtr + 4 /* skip magic number */ );
+    eSize = ZSTD_loadCEntropy(bs, workspace, dict, dictSize);
+    FORWARD_IF_ERROR(eSize, "ZSTD_loadCEntropy failed");
+    dictPtr += eSize;
+
+    {
+        size_t const dictContentSize = (size_t)(dictEnd - dictPtr);
+        FORWARD_IF_ERROR(ZSTD_loadDictionaryContent(
+            ms, NULL, ws, params, dictPtr, dictContentSize, dtlm, tfp), "");
+    }
+    return dictID;
+}
+
+/** ZSTD_compress_insertDictionary() :
+*   @return : dictID, or an error code */
+static size_t
+ZSTD_compress_insertDictionary(ZSTD_compressedBlockState_t* bs,
+                               ZSTD_matchState_t* ms,
+                               ldmState_t* ls,
+                               ZSTD_cwksp* ws,
+                         const ZSTD_CCtx_params* params,
+                         const void* dict, size_t dictSize,
+                               ZSTD_dictContentType_e dictContentType,
+                               ZSTD_dictTableLoadMethod_e dtlm,
+                               ZSTD_tableFillPurpose_e tfp,
+                               void* workspace)
+{
+    DEBUGLOG(4, "ZSTD_compress_insertDictionary (dictSize=%u)", (U32)dictSize);
+    if ((dict==NULL) || (dictSize<8)) {
+        RETURN_ERROR_IF(dictContentType == ZSTD_dct_fullDict, dictionary_wrong, "");
+        return 0;
+    }
+
+    ZSTD_reset_compressedBlockState(bs);
+
+    /* dict restricted modes */
+    if (dictContentType == ZSTD_dct_rawContent)
+        return ZSTD_loadDictionaryContent(ms, ls, ws, params, dict, dictSize, dtlm, tfp);
+
+    if (MEM_readLE32(dict) != ZSTD_MAGIC_DICTIONARY) {
+        if (dictContentType == ZSTD_dct_auto) {
+            DEBUGLOG(4, "raw content dictionary detected");
+            return ZSTD_loadDictionaryContent(
+                ms, ls, ws, params, dict, dictSize, dtlm, tfp);
+        }
+        RETURN_ERROR_IF(dictContentType == ZSTD_dct_fullDict, dictionary_wrong, "");
+        assert(0);   /* impossible */
+    }
+
+    /* dict as full zstd dictionary */
+    return ZSTD_loadZstdDictionary(
+        bs, ms, ws, params, dict, dictSize, dtlm, tfp, workspace);
+}
+
+#define ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF (128 KB)
+#define ZSTD_USE_CDICT_PARAMS_DICTSIZE_MULTIPLIER (6ULL)
+
+/*! ZSTD_compressBegin_internal() :
+ * Assumption : either @dict OR @cdict (or none) is non-NULL, never both
+ * @return : 0, or an error code */
+static size_t ZSTD_compressBegin_internal(ZSTD_CCtx* cctx,
+                                    const void* dict, size_t dictSize,
+                                    ZSTD_dictContentType_e dictContentType,
+                                    ZSTD_dictTableLoadMethod_e dtlm,
+                                    const ZSTD_CDict* cdict,
+                                    const ZSTD_CCtx_params* params, U64 pledgedSrcSize,
+                                    ZSTD_buffered_policy_e zbuff)
+{
+    size_t const dictContentSize = cdict ? cdict->dictContentSize : dictSize;
+#if ZSTD_TRACE
+    cctx->traceCtx = (ZSTD_trace_compress_begin != NULL) ? ZSTD_trace_compress_begin(cctx) : 0;
+#endif
+    DEBUGLOG(4, "ZSTD_compressBegin_internal: wlog=%u", params->cParams.windowLog);
+    /* params are supposed to be fully validated at this point */
+    assert(!ZSTD_isError(ZSTD_checkCParams(params->cParams)));
+    assert(!((dict) && (cdict)));  /* either dict or cdict, not both */
+    if ( (cdict)
+      && (cdict->dictContentSize > 0)
+      && ( pledgedSrcSize < ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF
+        || pledgedSrcSize < cdict->dictContentSize * ZSTD_USE_CDICT_PARAMS_DICTSIZE_MULTIPLIER
+        || pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN
+        || cdict->compressionLevel == 0)
+      && (params->attachDictPref != ZSTD_dictForceLoad) ) {
+        return ZSTD_resetCCtx_usingCDict(cctx, cdict, params, pledgedSrcSize, zbuff);
+    }
+
+    FORWARD_IF_ERROR( ZSTD_resetCCtx_internal(cctx, params, pledgedSrcSize,
+                                     dictContentSize,
+                                     ZSTDcrp_makeClean, zbuff) , "");
+    {   size_t const dictID = cdict ?
+                ZSTD_compress_insertDictionary(
+                        cctx->blockState.prevCBlock, &cctx->blockState.matchState,
+                        &cctx->ldmState, &cctx->workspace, &cctx->appliedParams, cdict->dictContent,
+                        cdict->dictContentSize, cdict->dictContentType, dtlm,
+                        ZSTD_tfp_forCCtx, cctx->entropyWorkspace)
+              : ZSTD_compress_insertDictionary(
+                        cctx->blockState.prevCBlock, &cctx->blockState.matchState,
+                        &cctx->ldmState, &cctx->workspace, &cctx->appliedParams, dict, dictSize,
+                        dictContentType, dtlm, ZSTD_tfp_forCCtx, cctx->entropyWorkspace);
+        FORWARD_IF_ERROR(dictID, "ZSTD_compress_insertDictionary failed");
+        assert(dictID <= UINT_MAX);
+        cctx->dictID = (U32)dictID;
+        cctx->dictContentSize = dictContentSize;
+    }
+    return 0;
+}
+
+size_t ZSTD_compressBegin_advanced_internal(ZSTD_CCtx* cctx,
+                                    const void* dict, size_t dictSize,
+                                    ZSTD_dictContentType_e dictContentType,
+                                    ZSTD_dictTableLoadMethod_e dtlm,
+                                    const ZSTD_CDict* cdict,
+                                    const ZSTD_CCtx_params* params,
+                                    unsigned long long pledgedSrcSize)
+{
+    DEBUGLOG(4, "ZSTD_compressBegin_advanced_internal: wlog=%u", params->cParams.windowLog);
+    /* compression parameters verification and optimization */
+    FORWARD_IF_ERROR( ZSTD_checkCParams(params->cParams) , "");
+    return ZSTD_compressBegin_internal(cctx,
+                                       dict, dictSize, dictContentType, dtlm,
+                                       cdict,
+                                       params, pledgedSrcSize,
+                                       ZSTDb_not_buffered);
+}
+
+/*! ZSTD_compressBegin_advanced() :
+*   @return : 0, or an error code */
+size_t ZSTD_compressBegin_advanced(ZSTD_CCtx* cctx,
+                             const void* dict, size_t dictSize,
+                                   ZSTD_parameters params, unsigned long long pledgedSrcSize)
+{
+    ZSTD_CCtx_params cctxParams;
+    ZSTD_CCtxParams_init_internal(&cctxParams, &params, ZSTD_NO_CLEVEL);
+    return ZSTD_compressBegin_advanced_internal(cctx,
+                                            dict, dictSize, ZSTD_dct_auto, ZSTD_dtlm_fast,
+                                            NULL /*cdict*/,
+                                            &cctxParams, pledgedSrcSize);
+}
+
+static size_t
+ZSTD_compressBegin_usingDict_deprecated(ZSTD_CCtx* cctx, const void* dict, size_t dictSize, int compressionLevel)
+{
+    ZSTD_CCtx_params cctxParams;
+    {   ZSTD_parameters const params = ZSTD_getParams_internal(compressionLevel, ZSTD_CONTENTSIZE_UNKNOWN, dictSize, ZSTD_cpm_noAttachDict);
+        ZSTD_CCtxParams_init_internal(&cctxParams, &params, (compressionLevel == 0) ? ZSTD_CLEVEL_DEFAULT : compressionLevel);
+    }
+    DEBUGLOG(4, "ZSTD_compressBegin_usingDict (dictSize=%u)", (unsigned)dictSize);
+    return ZSTD_compressBegin_internal(cctx, dict, dictSize, ZSTD_dct_auto, ZSTD_dtlm_fast, NULL,
+                                       &cctxParams, ZSTD_CONTENTSIZE_UNKNOWN, ZSTDb_not_buffered);
+}
+
+size_t
+ZSTD_compressBegin_usingDict(ZSTD_CCtx* cctx, const void* dict, size_t dictSize, int compressionLevel)
+{
+    return ZSTD_compressBegin_usingDict_deprecated(cctx, dict, dictSize, compressionLevel);
+}
+
+size_t ZSTD_compressBegin(ZSTD_CCtx* cctx, int compressionLevel)
+{
+    return ZSTD_compressBegin_usingDict_deprecated(cctx, NULL, 0, compressionLevel);
+}
+
+
+/*! ZSTD_writeEpilogue() :
+*   Ends a frame.
+*   @return : nb of bytes written into dst (or an error code) */
+static size_t ZSTD_writeEpilogue(ZSTD_CCtx* cctx, void* dst, size_t dstCapacity)
+{
+    BYTE* const ostart = (BYTE*)dst;
+    BYTE* op = ostart;
+    size_t fhSize = 0;
+
+    DEBUGLOG(4, "ZSTD_writeEpilogue");
+    RETURN_ERROR_IF(cctx->stage == ZSTDcs_created, stage_wrong, "init missing");
+
+    /* special case : empty frame */
+    if (cctx->stage == ZSTDcs_init) {
+        fhSize = ZSTD_writeFrameHeader(dst, dstCapacity, &cctx->appliedParams, 0, 0);
+        FORWARD_IF_ERROR(fhSize, "ZSTD_writeFrameHeader failed");
+        dstCapacity -= fhSize;
+        op += fhSize;
+        cctx->stage = ZSTDcs_ongoing;
+    }
+
+    if (cctx->stage != ZSTDcs_ending) {
+        /* write one last empty block, make it the "last" block */
+        U32 const cBlockHeader24 = 1 /* last block */ + (((U32)bt_raw)<<1) + 0;
+        RETURN_ERROR_IF(dstCapacity<4, dstSize_tooSmall, "no room for epilogue");
+        MEM_writeLE32(op, cBlockHeader24);
+        op += ZSTD_blockHeaderSize;
+        dstCapacity -= ZSTD_blockHeaderSize;
+    }
+
+    if (cctx->appliedParams.fParams.checksumFlag) {
+        U32 const checksum = (U32) XXH64_digest(&cctx->xxhState);
+        RETURN_ERROR_IF(dstCapacity<4, dstSize_tooSmall, "no room for checksum");
+        DEBUGLOG(4, "ZSTD_writeEpilogue: write checksum : %08X", (unsigned)checksum);
+        MEM_writeLE32(op, checksum);
+        op += 4;
+    }
+
+    cctx->stage = ZSTDcs_created;  /* return to "created but no init" status */
+    return op-ostart;
+}
+
+void ZSTD_CCtx_trace(ZSTD_CCtx* cctx, size_t extraCSize)
+{
+#if ZSTD_TRACE
+    if (cctx->traceCtx && ZSTD_trace_compress_end != NULL) {
+        int const streaming = cctx->inBuffSize > 0 || cctx->outBuffSize > 0 || cctx->appliedParams.nbWorkers > 0;
+        ZSTD_Trace trace;
+        ZSTD_memset(&trace, 0, sizeof(trace));
+        trace.version = ZSTD_VERSION_NUMBER;
+        trace.streaming = streaming;
+        trace.dictionaryID = cctx->dictID;
+        trace.dictionarySize = cctx->dictContentSize;
+        trace.uncompressedSize = cctx->consumedSrcSize;
+        trace.compressedSize = cctx->producedCSize + extraCSize;
+        trace.params = &cctx->appliedParams;
+        trace.cctx = cctx;
+        ZSTD_trace_compress_end(cctx->traceCtx, &trace);
+    }
+    cctx->traceCtx = 0;
+#else
+    (void)cctx;
+    (void)extraCSize;
+#endif
+}
+
+size_t ZSTD_compressEnd_public(ZSTD_CCtx* cctx,
+                               void* dst, size_t dstCapacity,
+                         const void* src, size_t srcSize)
+{
+    size_t endResult;
+    size_t const cSize = ZSTD_compressContinue_internal(cctx,
+                                dst, dstCapacity, src, srcSize,
+                                1 /* frame mode */, 1 /* last chunk */);
+    FORWARD_IF_ERROR(cSize, "ZSTD_compressContinue_internal failed");
+    endResult = ZSTD_writeEpilogue(cctx, (char*)dst + cSize, dstCapacity-cSize);
+    FORWARD_IF_ERROR(endResult, "ZSTD_writeEpilogue failed");
+    assert(!(cctx->appliedParams.fParams.contentSizeFlag && cctx->pledgedSrcSizePlusOne == 0));
+    if (cctx->pledgedSrcSizePlusOne != 0) {  /* control src size */
+        ZSTD_STATIC_ASSERT(ZSTD_CONTENTSIZE_UNKNOWN == (unsigned long long)-1);
+        DEBUGLOG(4, "end of frame : controlling src size");
+        RETURN_ERROR_IF(
+            cctx->pledgedSrcSizePlusOne != cctx->consumedSrcSize+1,
+            srcSize_wrong,
+             "error : pledgedSrcSize = %u, while realSrcSize = %u",
+            (unsigned)cctx->pledgedSrcSizePlusOne-1,
+            (unsigned)cctx->consumedSrcSize);
+    }
+    ZSTD_CCtx_trace(cctx, endResult);
+    return cSize + endResult;
+}
+
+/* NOTE: Must just wrap ZSTD_compressEnd_public() */
+size_t ZSTD_compressEnd(ZSTD_CCtx* cctx,
+                        void* dst, size_t dstCapacity,
+                  const void* src, size_t srcSize)
+{
+    return ZSTD_compressEnd_public(cctx, dst, dstCapacity, src, srcSize);
+}
+
+size_t ZSTD_compress_advanced (ZSTD_CCtx* cctx,
+                               void* dst, size_t dstCapacity,
+                         const void* src, size_t srcSize,
+                         const void* dict,size_t dictSize,
+                               ZSTD_parameters params)
+{
+    DEBUGLOG(4, "ZSTD_compress_advanced");
+    FORWARD_IF_ERROR(ZSTD_checkCParams(params.cParams), "");
+    ZSTD_CCtxParams_init_internal(&cctx->simpleApiParams, &params, ZSTD_NO_CLEVEL);
+    return ZSTD_compress_advanced_internal(cctx,
+                                           dst, dstCapacity,
+                                           src, srcSize,
+                                           dict, dictSize,
+                                           &cctx->simpleApiParams);
+}
+
+/* Internal */
+size_t ZSTD_compress_advanced_internal(
+        ZSTD_CCtx* cctx,
+        void* dst, size_t dstCapacity,
+        const void* src, size_t srcSize,
+        const void* dict,size_t dictSize,
+        const ZSTD_CCtx_params* params)
+{
+    DEBUGLOG(4, "ZSTD_compress_advanced_internal (srcSize:%u)", (unsigned)srcSize);
+    FORWARD_IF_ERROR( ZSTD_compressBegin_internal(cctx,
+                         dict, dictSize, ZSTD_dct_auto, ZSTD_dtlm_fast, NULL,
+                         params, srcSize, ZSTDb_not_buffered) , "");
+    return ZSTD_compressEnd_public(cctx, dst, dstCapacity, src, srcSize);
+}
+
+size_t ZSTD_compress_usingDict(ZSTD_CCtx* cctx,
+                               void* dst, size_t dstCapacity,
+                         const void* src, size_t srcSize,
+                         const void* dict, size_t dictSize,
+                               int compressionLevel)
+{
+    {
+        ZSTD_parameters const params = ZSTD_getParams_internal(compressionLevel, srcSize, dict ? dictSize : 0, ZSTD_cpm_noAttachDict);
+        assert(params.fParams.contentSizeFlag == 1);
+        ZSTD_CCtxParams_init_internal(&cctx->simpleApiParams, &params, (compressionLevel == 0) ? ZSTD_CLEVEL_DEFAULT: compressionLevel);
+    }
+    DEBUGLOG(4, "ZSTD_compress_usingDict (srcSize=%u)", (unsigned)srcSize);
+    return ZSTD_compress_advanced_internal(cctx, dst, dstCapacity, src, srcSize, dict, dictSize, &cctx->simpleApiParams);
+}
+
+size_t ZSTD_compressCCtx(ZSTD_CCtx* cctx,
+                         void* dst, size_t dstCapacity,
+                   const void* src, size_t srcSize,
+                         int compressionLevel)
+{
+    DEBUGLOG(4, "ZSTD_compressCCtx (srcSize=%u)", (unsigned)srcSize);
+    assert(cctx != NULL);
+    return ZSTD_compress_usingDict(cctx, dst, dstCapacity, src, srcSize, NULL, 0, compressionLevel);
+}
+
+size_t ZSTD_compress(void* dst, size_t dstCapacity,
+               const void* src, size_t srcSize,
+                     int compressionLevel)
+{
+    size_t result;
+#if ZSTD_COMPRESS_HEAPMODE
+    ZSTD_CCtx* cctx = ZSTD_createCCtx();
+    RETURN_ERROR_IF(!cctx, memory_allocation, "ZSTD_createCCtx failed");
+    result = ZSTD_compressCCtx(cctx, dst, dstCapacity, src, srcSize, compressionLevel);
+    ZSTD_freeCCtx(cctx);
+#else
+    ZSTD_CCtx ctxBody;
+    ZSTD_initCCtx(&ctxBody, ZSTD_defaultCMem);
+    result = ZSTD_compressCCtx(&ctxBody, dst, dstCapacity, src, srcSize, compressionLevel);
+    ZSTD_freeCCtxContent(&ctxBody);   /* can't free ctxBody itself, as it's on stack; free only heap content */
+#endif
+    return result;
+}
+
+
+/* =====  Dictionary API  ===== */
+
+/*! ZSTD_estimateCDictSize_advanced() :
+ *  Estimate amount of memory that will be needed to create a dictionary with following arguments */
+size_t ZSTD_estimateCDictSize_advanced(
+        size_t dictSize, ZSTD_compressionParameters cParams,
+        ZSTD_dictLoadMethod_e dictLoadMethod)
+{
+    DEBUGLOG(5, "sizeof(ZSTD_CDict) : %u", (unsigned)sizeof(ZSTD_CDict));
+    return ZSTD_cwksp_alloc_size(sizeof(ZSTD_CDict))
+         + ZSTD_cwksp_alloc_size(HUF_WORKSPACE_SIZE)
+         /* enableDedicatedDictSearch == 1 ensures that CDict estimation will not be too small
+          * in case we are using DDS with row-hash. */
+         + ZSTD_sizeof_matchState(&cParams, ZSTD_resolveRowMatchFinderMode(ZSTD_ps_auto, &cParams),
+                                  /* enableDedicatedDictSearch */ 1, /* forCCtx */ 0)
+         + (dictLoadMethod == ZSTD_dlm_byRef ? 0
+            : ZSTD_cwksp_alloc_size(ZSTD_cwksp_align(dictSize, sizeof(void *))));
+}
+
+size_t ZSTD_estimateCDictSize(size_t dictSize, int compressionLevel)
+{
+    ZSTD_compressionParameters const cParams = ZSTD_getCParams_internal(compressionLevel, ZSTD_CONTENTSIZE_UNKNOWN, dictSize, ZSTD_cpm_createCDict);
+    return ZSTD_estimateCDictSize_advanced(dictSize, cParams, ZSTD_dlm_byCopy);
+}
+
+size_t ZSTD_sizeof_CDict(const ZSTD_CDict* cdict)
+{
+    if (cdict==NULL) return 0;   /* support sizeof on NULL */
+    DEBUGLOG(5, "sizeof(*cdict) : %u", (unsigned)sizeof(*cdict));
+    /* cdict may be in the workspace */
+    return (cdict->workspace.workspace == cdict ? 0 : sizeof(*cdict))
+        + ZSTD_cwksp_sizeof(&cdict->workspace);
+}
+
+static size_t ZSTD_initCDict_internal(
+                    ZSTD_CDict* cdict,
+              const void* dictBuffer, size_t dictSize,
+                    ZSTD_dictLoadMethod_e dictLoadMethod,
+                    ZSTD_dictContentType_e dictContentType,
+                    ZSTD_CCtx_params params)
+{
+    DEBUGLOG(3, "ZSTD_initCDict_internal (dictContentType:%u)", (unsigned)dictContentType);
+    assert(!ZSTD_checkCParams(params.cParams));
+    cdict->matchState.cParams = params.cParams;
+    cdict->matchState.dedicatedDictSearch = params.enableDedicatedDictSearch;
+    if ((dictLoadMethod == ZSTD_dlm_byRef) || (!dictBuffer) || (!dictSize)) {
+        cdict->dictContent = dictBuffer;
+    } else {
+         void *internalBuffer = ZSTD_cwksp_reserve_object(&cdict->workspace, ZSTD_cwksp_align(dictSize, sizeof(void*)));
+        RETURN_ERROR_IF(!internalBuffer, memory_allocation, "NULL pointer!");
+        cdict->dictContent = internalBuffer;
+        ZSTD_memcpy(internalBuffer, dictBuffer, dictSize);
+    }
+    cdict->dictContentSize = dictSize;
+    cdict->dictContentType = dictContentType;
+
+    cdict->entropyWorkspace = (U32*)ZSTD_cwksp_reserve_object(&cdict->workspace, HUF_WORKSPACE_SIZE);
+
+
+    /* Reset the state to no dictionary */
+    ZSTD_reset_compressedBlockState(&cdict->cBlockState);
+    FORWARD_IF_ERROR(ZSTD_reset_matchState(
+        &cdict->matchState,
+        &cdict->workspace,
+        &params.cParams,
+        params.useRowMatchFinder,
+        ZSTDcrp_makeClean,
+        ZSTDirp_reset,
+        ZSTD_resetTarget_CDict), "");
+    /* (Maybe) load the dictionary
+     * Skips loading the dictionary if it is < 8 bytes.
+     */
+    {   params.compressionLevel = ZSTD_CLEVEL_DEFAULT;
+        params.fParams.contentSizeFlag = 1;
+        {   size_t const dictID = ZSTD_compress_insertDictionary(
+                    &cdict->cBlockState, &cdict->matchState, NULL, &cdict->workspace,
+                    &params, cdict->dictContent, cdict->dictContentSize,
+                    dictContentType, ZSTD_dtlm_full, ZSTD_tfp_forCDict, cdict->entropyWorkspace);
+            FORWARD_IF_ERROR(dictID, "ZSTD_compress_insertDictionary failed");
+            assert(dictID <= (size_t)(U32)-1);
+            cdict->dictID = (U32)dictID;
+        }
+    }
+
+    return 0;
+}
+
+static ZSTD_CDict* ZSTD_createCDict_advanced_internal(size_t dictSize,
+                                      ZSTD_dictLoadMethod_e dictLoadMethod,
+                                      ZSTD_compressionParameters cParams,
+                                      ZSTD_paramSwitch_e useRowMatchFinder,
+                                      U32 enableDedicatedDictSearch,
+                                      ZSTD_customMem customMem)
+{
+    if ((!customMem.customAlloc) ^ (!customMem.customFree)) return NULL;
+
+    {   size_t const workspaceSize =
+            ZSTD_cwksp_alloc_size(sizeof(ZSTD_CDict)) +
+            ZSTD_cwksp_alloc_size(HUF_WORKSPACE_SIZE) +
+            ZSTD_sizeof_matchState(&cParams, useRowMatchFinder, enableDedicatedDictSearch, /* forCCtx */ 0) +
+            (dictLoadMethod == ZSTD_dlm_byRef ? 0
+             : ZSTD_cwksp_alloc_size(ZSTD_cwksp_align(dictSize, sizeof(void*))));
+        void* const workspace = ZSTD_customMalloc(workspaceSize, customMem);
+        ZSTD_cwksp ws;
+        ZSTD_CDict* cdict;
+
+        if (!workspace) {
+            ZSTD_customFree(workspace, customMem);
+            return NULL;
+        }
+
+        ZSTD_cwksp_init(&ws, workspace, workspaceSize, ZSTD_cwksp_dynamic_alloc);
+
+        cdict = (ZSTD_CDict*)ZSTD_cwksp_reserve_object(&ws, sizeof(ZSTD_CDict));
+        assert(cdict != NULL);
+        ZSTD_cwksp_move(&cdict->workspace, &ws);
+        cdict->customMem = customMem;
+        cdict->compressionLevel = ZSTD_NO_CLEVEL; /* signals advanced API usage */
+        cdict->useRowMatchFinder = useRowMatchFinder;
+        return cdict;
+    }
+}
+
+ZSTD_CDict* ZSTD_createCDict_advanced(const void* dictBuffer, size_t dictSize,
+                                      ZSTD_dictLoadMethod_e dictLoadMethod,
+                                      ZSTD_dictContentType_e dictContentType,
+                                      ZSTD_compressionParameters cParams,
+                                      ZSTD_customMem customMem)
+{
+    ZSTD_CCtx_params cctxParams;
+    ZSTD_memset(&cctxParams, 0, sizeof(cctxParams));
+    ZSTD_CCtxParams_init(&cctxParams, 0);
+    cctxParams.cParams = cParams;
+    cctxParams.customMem = customMem;
+    return ZSTD_createCDict_advanced2(
+        dictBuffer, dictSize,
+        dictLoadMethod, dictContentType,
+        &cctxParams, customMem);
+}
+
+ZSTD_CDict* ZSTD_createCDict_advanced2(
+        const void* dict, size_t dictSize,
+        ZSTD_dictLoadMethod_e dictLoadMethod,
+        ZSTD_dictContentType_e dictContentType,
+        const ZSTD_CCtx_params* originalCctxParams,
+        ZSTD_customMem customMem)
+{
+    ZSTD_CCtx_params cctxParams = *originalCctxParams;
+    ZSTD_compressionParameters cParams;
+    ZSTD_CDict* cdict;
+
+    DEBUGLOG(3, "ZSTD_createCDict_advanced2, mode %u", (unsigned)dictContentType);
+    if (!customMem.customAlloc ^ !customMem.customFree) return NULL;
+
+    if (cctxParams.enableDedicatedDictSearch) {
+        cParams = ZSTD_dedicatedDictSearch_getCParams(
+            cctxParams.compressionLevel, dictSize);
+        ZSTD_overrideCParams(&cParams, &cctxParams.cParams);
+    } else {
+        cParams = ZSTD_getCParamsFromCCtxParams(
+            &cctxParams, ZSTD_CONTENTSIZE_UNKNOWN, dictSize, ZSTD_cpm_createCDict);
+    }
+
+    if (!ZSTD_dedicatedDictSearch_isSupported(&cParams)) {
+        /* Fall back to non-DDSS params */
+        cctxParams.enableDedicatedDictSearch = 0;
+        cParams = ZSTD_getCParamsFromCCtxParams(
+            &cctxParams, ZSTD_CONTENTSIZE_UNKNOWN, dictSize, ZSTD_cpm_createCDict);
+    }
+
+    DEBUGLOG(3, "ZSTD_createCDict_advanced2: DDS: %u", cctxParams.enableDedicatedDictSearch);
+    cctxParams.cParams = cParams;
+    cctxParams.useRowMatchFinder = ZSTD_resolveRowMatchFinderMode(cctxParams.useRowMatchFinder, &cParams);
+
+    cdict = ZSTD_createCDict_advanced_internal(dictSize,
+                        dictLoadMethod, cctxParams.cParams,
+                        cctxParams.useRowMatchFinder, cctxParams.enableDedicatedDictSearch,
+                        customMem);
+
+    if (ZSTD_isError( ZSTD_initCDict_internal(cdict,
+                                    dict, dictSize,
+                                    dictLoadMethod, dictContentType,
+                                    cctxParams) )) {
+        ZSTD_freeCDict(cdict);
+        return NULL;
+    }
+
+    return cdict;
+}
+
+ZSTD_CDict* ZSTD_createCDict(const void* dict, size_t dictSize, int compressionLevel)
+{
+    ZSTD_compressionParameters cParams = ZSTD_getCParams_internal(compressionLevel, ZSTD_CONTENTSIZE_UNKNOWN, dictSize, ZSTD_cpm_createCDict);
+    ZSTD_CDict* const cdict = ZSTD_createCDict_advanced(dict, dictSize,
+                                                  ZSTD_dlm_byCopy, ZSTD_dct_auto,
+                                                  cParams, ZSTD_defaultCMem);
+    if (cdict)
+        cdict->compressionLevel = (compressionLevel == 0) ? ZSTD_CLEVEL_DEFAULT : compressionLevel;
+    return cdict;
+}
+
+ZSTD_CDict* ZSTD_createCDict_byReference(const void* dict, size_t dictSize, int compressionLevel)
+{
+    ZSTD_compressionParameters cParams = ZSTD_getCParams_internal(compressionLevel, ZSTD_CONTENTSIZE_UNKNOWN, dictSize, ZSTD_cpm_createCDict);
+    ZSTD_CDict* const cdict = ZSTD_createCDict_advanced(dict, dictSize,
+                                     ZSTD_dlm_byRef, ZSTD_dct_auto,
+                                     cParams, ZSTD_defaultCMem);
+    if (cdict)
+        cdict->compressionLevel = (compressionLevel == 0) ? ZSTD_CLEVEL_DEFAULT : compressionLevel;
+    return cdict;
+}
+
+size_t ZSTD_freeCDict(ZSTD_CDict* cdict)
+{
+    if (cdict==NULL) return 0;   /* support free on NULL */
+    {   ZSTD_customMem const cMem = cdict->customMem;
+        int cdictInWorkspace = ZSTD_cwksp_owns_buffer(&cdict->workspace, cdict);
+        ZSTD_cwksp_free(&cdict->workspace, cMem);
+        if (!cdictInWorkspace) {
+            ZSTD_customFree(cdict, cMem);
+        }
+        return 0;
+    }
+}
+
+/*! ZSTD_initStaticCDict_advanced() :
+ *  Generate a digested dictionary in provided memory area.
+ *  workspace: The memory area to emplace the dictionary into.
+ *             Provided pointer must 8-bytes aligned.
+ *             It must outlive dictionary usage.
+ *  workspaceSize: Use ZSTD_estimateCDictSize()
+ *                 to determine how large workspace must be.
+ *  cParams : use ZSTD_getCParams() to transform a compression level
+ *            into its relevants cParams.
+ * @return : pointer to ZSTD_CDict*, or NULL if error (size too small)
+ *  Note : there is no corresponding "free" function.
+ *         Since workspace was allocated externally, it must be freed externally.
+ */
+const ZSTD_CDict* ZSTD_initStaticCDict(
+                                 void* workspace, size_t workspaceSize,
+                           const void* dict, size_t dictSize,
+                                 ZSTD_dictLoadMethod_e dictLoadMethod,
+                                 ZSTD_dictContentType_e dictContentType,
+                                 ZSTD_compressionParameters cParams)
+{
+    ZSTD_paramSwitch_e const useRowMatchFinder = ZSTD_resolveRowMatchFinderMode(ZSTD_ps_auto, &cParams);
+    /* enableDedicatedDictSearch == 1 ensures matchstate is not too small in case this CDict will be used for DDS + row hash */
+    size_t const matchStateSize = ZSTD_sizeof_matchState(&cParams, useRowMatchFinder, /* enableDedicatedDictSearch */ 1, /* forCCtx */ 0);
+    size_t const neededSize = ZSTD_cwksp_alloc_size(sizeof(ZSTD_CDict))
+                            + (dictLoadMethod == ZSTD_dlm_byRef ? 0
+                               : ZSTD_cwksp_alloc_size(ZSTD_cwksp_align(dictSize, sizeof(void*))))
+                            + ZSTD_cwksp_alloc_size(HUF_WORKSPACE_SIZE)
+                            + matchStateSize;
+    ZSTD_CDict* cdict;
+    ZSTD_CCtx_params params;
+
+    if ((size_t)workspace & 7) return NULL;  /* 8-aligned */
+
+    {
+        ZSTD_cwksp ws;
+        ZSTD_cwksp_init(&ws, workspace, workspaceSize, ZSTD_cwksp_static_alloc);
+        cdict = (ZSTD_CDict*)ZSTD_cwksp_reserve_object(&ws, sizeof(ZSTD_CDict));
+        if (cdict == NULL) return NULL;
+        ZSTD_cwksp_move(&cdict->workspace, &ws);
+    }
+
+    DEBUGLOG(4, "(workspaceSize < neededSize) : (%u < %u) => %u",
+        (unsigned)workspaceSize, (unsigned)neededSize, (unsigned)(workspaceSize < neededSize));
+    if (workspaceSize < neededSize) return NULL;
+
+    ZSTD_CCtxParams_init(&params, 0);
+    params.cParams = cParams;
+    params.useRowMatchFinder = useRowMatchFinder;
+    cdict->useRowMatchFinder = useRowMatchFinder;
+    cdict->compressionLevel = ZSTD_NO_CLEVEL;
+
+    if (ZSTD_isError( ZSTD_initCDict_internal(cdict,
+                                              dict, dictSize,
+                                              dictLoadMethod, dictContentType,
+                                              params) ))
+        return NULL;
+
+    return cdict;
+}
+
+ZSTD_compressionParameters ZSTD_getCParamsFromCDict(const ZSTD_CDict* cdict)
+{
+    assert(cdict != NULL);
+    return cdict->matchState.cParams;
+}
+
+/*! ZSTD_getDictID_fromCDict() :
+ *  Provides the dictID of the dictionary loaded into `cdict`.
+ *  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
+ *  Non-conformant dictionaries can still be loaded, but as content-only dictionaries. */
+unsigned ZSTD_getDictID_fromCDict(const ZSTD_CDict* cdict)
+{
+    if (cdict==NULL) return 0;
+    return cdict->dictID;
+}
+
+/* ZSTD_compressBegin_usingCDict_internal() :
+ * Implementation of various ZSTD_compressBegin_usingCDict* functions.
+ */
+static size_t ZSTD_compressBegin_usingCDict_internal(
+    ZSTD_CCtx* const cctx, const ZSTD_CDict* const cdict,
+    ZSTD_frameParameters const fParams, unsigned long long const pledgedSrcSize)
+{
+    ZSTD_CCtx_params cctxParams;
+    DEBUGLOG(4, "ZSTD_compressBegin_usingCDict_internal");
+    RETURN_ERROR_IF(cdict==NULL, dictionary_wrong, "NULL pointer!");
+    /* Initialize the cctxParams from the cdict */
+    {
+        ZSTD_parameters params;
+        params.fParams = fParams;
+        params.cParams = ( pledgedSrcSize < ZSTD_USE_CDICT_PARAMS_SRCSIZE_CUTOFF
+                        || pledgedSrcSize < cdict->dictContentSize * ZSTD_USE_CDICT_PARAMS_DICTSIZE_MULTIPLIER
+                        || pledgedSrcSize == ZSTD_CONTENTSIZE_UNKNOWN
+                        || cdict->compressionLevel == 0 ) ?
+                ZSTD_getCParamsFromCDict(cdict)
+              : ZSTD_getCParams(cdict->compressionLevel,
+                                pledgedSrcSize,
+                                cdict->dictContentSize);
+        ZSTD_CCtxParams_init_internal(&cctxParams, &params, cdict->compressionLevel);
+    }
+    /* Increase window log to fit the entire dictionary and source if the
+     * source size is known. Limit the increase to 19, which is the
+     * window log for compression level 1 with the largest source size.
+     */
+    if (pledgedSrcSize != ZSTD_CONTENTSIZE_UNKNOWN) {
+        U32 const limitedSrcSize = (U32)MIN(pledgedSrcSize, 1U << 19);
+        U32 const limitedSrcLog = limitedSrcSize > 1 ? ZSTD_highbit32(limitedSrcSize - 1) + 1 : 1;
+        cctxParams.cParams.windowLog = MAX(cctxParams.cParams.windowLog, limitedSrcLog);
+    }
+    return ZSTD_compressBegin_internal(cctx,
+                                        NULL, 0, ZSTD_dct_auto, ZSTD_dtlm_fast,
+                                        cdict,
+                                        &cctxParams, pledgedSrcSize,
+                                        ZSTDb_not_buffered);
+}
+
+
+/* ZSTD_compressBegin_usingCDict_advanced() :
+ * This function is DEPRECATED.
+ * cdict must be != NULL */
+size_t ZSTD_compressBegin_usingCDict_advanced(
+    ZSTD_CCtx* const cctx, const ZSTD_CDict* const cdict,
+    ZSTD_frameParameters const fParams, unsigned long long const pledgedSrcSize)
+{
+    return ZSTD_compressBegin_usingCDict_internal(cctx, cdict, fParams, pledgedSrcSize);
+}
+
+/* ZSTD_compressBegin_usingCDict() :
+ * cdict must be != NULL */
+size_t ZSTD_compressBegin_usingCDict_deprecated(ZSTD_CCtx* cctx, const ZSTD_CDict* cdict)
+{
+    ZSTD_frameParameters const fParams = { 0 /*content*/, 0 /*checksum*/, 0 /*noDictID*/ };
+    return ZSTD_compressBegin_usingCDict_internal(cctx, cdict, fParams, ZSTD_CONTENTSIZE_UNKNOWN);
+}
+
+size_t ZSTD_compressBegin_usingCDict(ZSTD_CCtx* cctx, const ZSTD_CDict* cdict)
+{
+    return ZSTD_compressBegin_usingCDict_deprecated(cctx, cdict);
+}
+
+/*! ZSTD_compress_usingCDict_internal():
+ * Implementation of various ZSTD_compress_usingCDict* functions.
+ */
+static size_t ZSTD_compress_usingCDict_internal(ZSTD_CCtx* cctx,
+                                void* dst, size_t dstCapacity,
+                                const void* src, size_t srcSize,
+                                const ZSTD_CDict* cdict, ZSTD_frameParameters fParams)
+{
+    FORWARD_IF_ERROR(ZSTD_compressBegin_usingCDict_internal(cctx, cdict, fParams, srcSize), ""); /* will check if cdict != NULL */
+    return ZSTD_compressEnd_public(cctx, dst, dstCapacity, src, srcSize);
+}
+
+/*! ZSTD_compress_usingCDict_advanced():
+ * This function is DEPRECATED.
+ */
+size_t ZSTD_compress_usingCDict_advanced(ZSTD_CCtx* cctx,
+                                void* dst, size_t dstCapacity,
+                                const void* src, size_t srcSize,
+                                const ZSTD_CDict* cdict, ZSTD_frameParameters fParams)
+{
+    return ZSTD_compress_usingCDict_internal(cctx, dst, dstCapacity, src, srcSize, cdict, fParams);
+}
+
+/*! ZSTD_compress_usingCDict() :
+ *  Compression using a digested Dictionary.
+ *  Faster startup than ZSTD_compress_usingDict(), recommended when same dictionary is used multiple times.
+ *  Note that compression parameters are decided at CDict creation time
+ *  while frame parameters are hardcoded */
+size_t ZSTD_compress_usingCDict(ZSTD_CCtx* cctx,
+                                void* dst, size_t dstCapacity,
+                                const void* src, size_t srcSize,
+                                const ZSTD_CDict* cdict)
+{
+    ZSTD_frameParameters const fParams = { 1 /*content*/, 0 /*checksum*/, 0 /*noDictID*/ };
+    return ZSTD_compress_usingCDict_internal(cctx, dst, dstCapacity, src, srcSize, cdict, fParams);
+}
+
+
+
+/* ******************************************************************
+*  Streaming
+********************************************************************/
+
+ZSTD_CStream* ZSTD_createCStream(void)
+{
+    DEBUGLOG(3, "ZSTD_createCStream");
+    return ZSTD_createCStream_advanced(ZSTD_defaultCMem);
+}
+
+ZSTD_CStream* ZSTD_initStaticCStream(void *workspace, size_t workspaceSize)
+{
+    return ZSTD_initStaticCCtx(workspace, workspaceSize);
+}
+
+ZSTD_CStream* ZSTD_createCStream_advanced(ZSTD_customMem customMem)
+{   /* CStream and CCtx are now same object */
+    return ZSTD_createCCtx_advanced(customMem);
+}
+
+size_t ZSTD_freeCStream(ZSTD_CStream* zcs)
+{
+    return ZSTD_freeCCtx(zcs);   /* same object */
+}
+
+
+
+/*======   Initialization   ======*/
+
+size_t ZSTD_CStreamInSize(void)  { return ZSTD_BLOCKSIZE_MAX; }
+
+size_t ZSTD_CStreamOutSize(void)
+{
+    return ZSTD_compressBound(ZSTD_BLOCKSIZE_MAX) + ZSTD_blockHeaderSize + 4 /* 32-bits hash */ ;
+}
+
+static ZSTD_cParamMode_e ZSTD_getCParamMode(ZSTD_CDict const* cdict, ZSTD_CCtx_params const* params, U64 pledgedSrcSize)
+{
+    if (cdict != NULL && ZSTD_shouldAttachDict(cdict, params, pledgedSrcSize))
+        return ZSTD_cpm_attachDict;
+    else
+        return ZSTD_cpm_noAttachDict;
+}
+
+/* ZSTD_resetCStream():
+ * pledgedSrcSize == 0 means "unknown" */
+size_t ZSTD_resetCStream(ZSTD_CStream* zcs, unsigned long long pss)
+{
+    /* temporary : 0 interpreted as "unknown" during transition period.
+     * Users willing to specify "unknown" **must** use ZSTD_CONTENTSIZE_UNKNOWN.
+     * 0 will be interpreted as "empty" in the future.
+     */
+    U64 const pledgedSrcSize = (pss==0) ? ZSTD_CONTENTSIZE_UNKNOWN : pss;
+    DEBUGLOG(4, "ZSTD_resetCStream: pledgedSrcSize = %u", (unsigned)pledgedSrcSize);
+    FORWARD_IF_ERROR( ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only) , "");
+    FORWARD_IF_ERROR( ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize) , "");
+    return 0;
+}
+
+/*! ZSTD_initCStream_internal() :
+ *  Note : for lib/compress only. Used by zstdmt_compress.c.
+ *  Assumption 1 : params are valid
+ *  Assumption 2 : either dict, or cdict, is defined, not both */
+size_t ZSTD_initCStream_internal(ZSTD_CStream* zcs,
+                    const void* dict, size_t dictSize, const ZSTD_CDict* cdict,
+                    const ZSTD_CCtx_params* params,
+                    unsigned long long pledgedSrcSize)
+{
+    DEBUGLOG(4, "ZSTD_initCStream_internal");
+    FORWARD_IF_ERROR( ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only) , "");
+    FORWARD_IF_ERROR( ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize) , "");
+    assert(!ZSTD_isError(ZSTD_checkCParams(params->cParams)));
+    zcs->requestedParams = *params;
+    assert(!((dict) && (cdict)));  /* either dict or cdict, not both */
+    if (dict) {
+        FORWARD_IF_ERROR( ZSTD_CCtx_loadDictionary(zcs, dict, dictSize) , "");
+    } else {
+        /* Dictionary is cleared if !cdict */
+        FORWARD_IF_ERROR( ZSTD_CCtx_refCDict(zcs, cdict) , "");
+    }
+    return 0;
+}
+
+/* ZSTD_initCStream_usingCDict_advanced() :
+ * same as ZSTD_initCStream_usingCDict(), with control over frame parameters */
+size_t ZSTD_initCStream_usingCDict_advanced(ZSTD_CStream* zcs,
+                                            const ZSTD_CDict* cdict,
+                                            ZSTD_frameParameters fParams,
+                                            unsigned long long pledgedSrcSize)
+{
+    DEBUGLOG(4, "ZSTD_initCStream_usingCDict_advanced");
+    FORWARD_IF_ERROR( ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only) , "");
+    FORWARD_IF_ERROR( ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize) , "");
+    zcs->requestedParams.fParams = fParams;
+    FORWARD_IF_ERROR( ZSTD_CCtx_refCDict(zcs, cdict) , "");
+    return 0;
+}
+
+/* note : cdict must outlive compression session */
+size_t ZSTD_initCStream_usingCDict(ZSTD_CStream* zcs, const ZSTD_CDict* cdict)
+{
+    DEBUGLOG(4, "ZSTD_initCStream_usingCDict");
+    FORWARD_IF_ERROR( ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only) , "");
+    FORWARD_IF_ERROR( ZSTD_CCtx_refCDict(zcs, cdict) , "");
+    return 0;
+}
+
+
+/* ZSTD_initCStream_advanced() :
+ * pledgedSrcSize must be exact.
+ * if srcSize is not known at init time, use value ZSTD_CONTENTSIZE_UNKNOWN.
+ * dict is loaded with default parameters ZSTD_dct_auto and ZSTD_dlm_byCopy. */
+size_t ZSTD_initCStream_advanced(ZSTD_CStream* zcs,
+                                 const void* dict, size_t dictSize,
+                                 ZSTD_parameters params, unsigned long long pss)
+{
+    /* for compatibility with older programs relying on this behavior.
+     * Users should now specify ZSTD_CONTENTSIZE_UNKNOWN.
+     * This line will be removed in the future.
+     */
+    U64 const pledgedSrcSize = (pss==0 && params.fParams.contentSizeFlag==0) ? ZSTD_CONTENTSIZE_UNKNOWN : pss;
+    DEBUGLOG(4, "ZSTD_initCStream_advanced");
+    FORWARD_IF_ERROR( ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only) , "");
+    FORWARD_IF_ERROR( ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize) , "");
+    FORWARD_IF_ERROR( ZSTD_checkCParams(params.cParams) , "");
+    ZSTD_CCtxParams_setZstdParams(&zcs->requestedParams, &params);
+    FORWARD_IF_ERROR( ZSTD_CCtx_loadDictionary(zcs, dict, dictSize) , "");
+    return 0;
+}
+
+size_t ZSTD_initCStream_usingDict(ZSTD_CStream* zcs, const void* dict, size_t dictSize, int compressionLevel)
+{
+    DEBUGLOG(4, "ZSTD_initCStream_usingDict");
+    FORWARD_IF_ERROR( ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only) , "");
+    FORWARD_IF_ERROR( ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel) , "");
+    FORWARD_IF_ERROR( ZSTD_CCtx_loadDictionary(zcs, dict, dictSize) , "");
+    return 0;
+}
+
+size_t ZSTD_initCStream_srcSize(ZSTD_CStream* zcs, int compressionLevel, unsigned long long pss)
+{
+    /* temporary : 0 interpreted as "unknown" during transition period.
+     * Users willing to specify "unknown" **must** use ZSTD_CONTENTSIZE_UNKNOWN.
+     * 0 will be interpreted as "empty" in the future.
+     */
+    U64 const pledgedSrcSize = (pss==0) ? ZSTD_CONTENTSIZE_UNKNOWN : pss;
+    DEBUGLOG(4, "ZSTD_initCStream_srcSize");
+    FORWARD_IF_ERROR( ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only) , "");
+    FORWARD_IF_ERROR( ZSTD_CCtx_refCDict(zcs, NULL) , "");
+    FORWARD_IF_ERROR( ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel) , "");
+    FORWARD_IF_ERROR( ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize) , "");
+    return 0;
+}
+
+size_t ZSTD_initCStream(ZSTD_CStream* zcs, int compressionLevel)
+{
+    DEBUGLOG(4, "ZSTD_initCStream");
+    FORWARD_IF_ERROR( ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only) , "");
+    FORWARD_IF_ERROR( ZSTD_CCtx_refCDict(zcs, NULL) , "");
+    FORWARD_IF_ERROR( ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel) , "");
+    return 0;
+}
+
+/*======   Compression   ======*/
+
+static size_t ZSTD_nextInputSizeHint(const ZSTD_CCtx* cctx)
+{
+    if (cctx->appliedParams.inBufferMode == ZSTD_bm_stable) {
+        return cctx->blockSize - cctx->stableIn_notConsumed;
+    }
+    assert(cctx->appliedParams.inBufferMode == ZSTD_bm_buffered);
+    {   size_t hintInSize = cctx->inBuffTarget - cctx->inBuffPos;
+        if (hintInSize==0) hintInSize = cctx->blockSize;
+        return hintInSize;
+    }
+}
+
+/** ZSTD_compressStream_generic():
+ *  internal function for all *compressStream*() variants
+ * @return : hint size for next input to complete ongoing block */
+static size_t ZSTD_compressStream_generic(ZSTD_CStream* zcs,
+                                          ZSTD_outBuffer* output,
+                                          ZSTD_inBuffer* input,
+                                          ZSTD_EndDirective const flushMode)
+{
+    const char* const istart = (assert(input != NULL), (const char*)input->src);
+    const char* const iend = (istart != NULL) ? istart + input->size : istart;
+    const char* ip = (istart != NULL) ? istart + input->pos : istart;
+    char* const ostart = (assert(output != NULL), (char*)output->dst);
+    char* const oend = (ostart != NULL) ? ostart + output->size : ostart;
+    char* op = (ostart != NULL) ? ostart + output->pos : ostart;
+    U32 someMoreWork = 1;
+
+    /* check expectations */
+    DEBUGLOG(5, "ZSTD_compressStream_generic, flush=%i, srcSize = %zu", (int)flushMode, input->size - input->pos);
+    assert(zcs != NULL);
+    if (zcs->appliedParams.inBufferMode == ZSTD_bm_stable) {
+        assert(input->pos >= zcs->stableIn_notConsumed);
+        input->pos -= zcs->stableIn_notConsumed;
+        ip -= zcs->stableIn_notConsumed;
+        zcs->stableIn_notConsumed = 0;
+    }
+    if (zcs->appliedParams.inBufferMode == ZSTD_bm_buffered) {
+        assert(zcs->inBuff != NULL);
+        assert(zcs->inBuffSize > 0);
+    }
+    if (zcs->appliedParams.outBufferMode == ZSTD_bm_buffered) {
+        assert(zcs->outBuff !=  NULL);
+        assert(zcs->outBuffSize > 0);
+    }
+    if (input->src == NULL) assert(input->size == 0);
+    assert(input->pos <= input->size);
+    if (output->dst == NULL) assert(output->size == 0);
+    assert(output->pos <= output->size);
+    assert((U32)flushMode <= (U32)ZSTD_e_end);
+
+    while (someMoreWork) {
+        switch(zcs->streamStage)
+        {
+        case zcss_init:
+            RETURN_ERROR(init_missing, "call ZSTD_initCStream() first!");
+
+        case zcss_load:
+            if ( (flushMode == ZSTD_e_end)
+              && ( (size_t)(oend-op) >= ZSTD_compressBound(iend-ip)     /* Enough output space */
+                || zcs->appliedParams.outBufferMode == ZSTD_bm_stable)  /* OR we are allowed to return dstSizeTooSmall */
+              && (zcs->inBuffPos == 0) ) {
+                /* shortcut to compression pass directly into output buffer */
+                size_t const cSize = ZSTD_compressEnd_public(zcs,
+                                                op, oend-op, ip, iend-ip);
+                DEBUGLOG(4, "ZSTD_compressEnd : cSize=%u", (unsigned)cSize);
+                FORWARD_IF_ERROR(cSize, "ZSTD_compressEnd failed");
+                ip = iend;
+                op += cSize;
+                zcs->frameEnded = 1;
+                ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
+                someMoreWork = 0; break;
+            }
+            /* complete loading into inBuffer in buffered mode */
+            if (zcs->appliedParams.inBufferMode == ZSTD_bm_buffered) {
+                size_t const toLoad = zcs->inBuffTarget - zcs->inBuffPos;
+                size_t const loaded = ZSTD_limitCopy(
+                                        zcs->inBuff + zcs->inBuffPos, toLoad,
+                                        ip, iend-ip);
+                zcs->inBuffPos += loaded;
+                if (ip) ip += loaded;
+                if ( (flushMode == ZSTD_e_continue)
+                  && (zcs->inBuffPos < zcs->inBuffTarget) ) {
+                    /* not enough input to fill full block : stop here */
+                    someMoreWork = 0; break;
+                }
+                if ( (flushMode == ZSTD_e_flush)
+                  && (zcs->inBuffPos == zcs->inToCompress) ) {
+                    /* empty */
+                    someMoreWork = 0; break;
+                }
+            } else {
+                assert(zcs->appliedParams.inBufferMode == ZSTD_bm_stable);
+                if ( (flushMode == ZSTD_e_continue)
+                  && ( (size_t)(iend - ip) < zcs->blockSize) ) {
+                    /* can't compress a full block : stop here */
+                    zcs->stableIn_notConsumed = (size_t)(iend - ip);
+                    ip = iend;  /* pretend to have consumed input */
+                    someMoreWork = 0; break;
+                }
+                if ( (flushMode == ZSTD_e_flush)
+                  && (ip == iend) ) {
+                    /* empty */
+                    someMoreWork = 0; break;
+                }
+            }
+            /* compress current block (note : this stage cannot be stopped in the middle) */
+            DEBUGLOG(5, "stream compression stage (flushMode==%u)", flushMode);
+            {   int const inputBuffered = (zcs->appliedParams.inBufferMode == ZSTD_bm_buffered);
+                void* cDst;
+                size_t cSize;
+                size_t oSize = oend-op;
+                size_t const iSize = inputBuffered ? zcs->inBuffPos - zcs->inToCompress
+                                                   : MIN((size_t)(iend - ip), zcs->blockSize);
+                if (oSize >= ZSTD_compressBound(iSize) || zcs->appliedParams.outBufferMode == ZSTD_bm_stable)
+                    cDst = op;   /* compress into output buffer, to skip flush stage */
+                else
+                    cDst = zcs->outBuff, oSize = zcs->outBuffSize;
+                if (inputBuffered) {
+                    unsigned const lastBlock = (flushMode == ZSTD_e_end) && (ip==iend);
+                    cSize = lastBlock ?
+                            ZSTD_compressEnd_public(zcs, cDst, oSize,
+                                        zcs->inBuff + zcs->inToCompress, iSize) :
+                            ZSTD_compressContinue_public(zcs, cDst, oSize,
+                                        zcs->inBuff + zcs->inToCompress, iSize);
+                    FORWARD_IF_ERROR(cSize, "%s", lastBlock ? "ZSTD_compressEnd failed" : "ZSTD_compressContinue failed");
+                    zcs->frameEnded = lastBlock;
+                    /* prepare next block */
+                    zcs->inBuffTarget = zcs->inBuffPos + zcs->blockSize;
+                    if (zcs->inBuffTarget > zcs->inBuffSize)
+                        zcs->inBuffPos = 0, zcs->inBuffTarget = zcs->blockSize;
+                    DEBUGLOG(5, "inBuffTarget:%u / inBuffSize:%u",
+                            (unsigned)zcs->inBuffTarget, (unsigned)zcs->inBuffSize);
+                    if (!lastBlock)
+                        assert(zcs->inBuffTarget <= zcs->inBuffSize);
+                    zcs->inToCompress = zcs->inBuffPos;
+                } else { /* !inputBuffered, hence ZSTD_bm_stable */
+                    unsigned const lastBlock = (flushMode == ZSTD_e_end) && (ip + iSize == iend);
+                    cSize = lastBlock ?
+                            ZSTD_compressEnd_public(zcs, cDst, oSize, ip, iSize) :
+                            ZSTD_compressContinue_public(zcs, cDst, oSize, ip, iSize);
+                    /* Consume the input prior to error checking to mirror buffered mode. */
+                    if (ip) ip += iSize;
+                    FORWARD_IF_ERROR(cSize, "%s", lastBlock ? "ZSTD_compressEnd failed" : "ZSTD_compressContinue failed");
+                    zcs->frameEnded = lastBlock;
+                    if (lastBlock) assert(ip == iend);
+                }
+                if (cDst == op) {  /* no need to flush */
+                    op += cSize;
+                    if (zcs->frameEnded) {
+                        DEBUGLOG(5, "Frame completed directly in outBuffer");
+                        someMoreWork = 0;
+                        ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
+                    }
+                    break;
+                }
+                zcs->outBuffContentSize = cSize;
+                zcs->outBuffFlushedSize = 0;
+                zcs->streamStage = zcss_flush; /* pass-through to flush stage */
+            }
+	    ZSTD_FALLTHROUGH;
+        case zcss_flush:
+            DEBUGLOG(5, "flush stage");
+            assert(zcs->appliedParams.outBufferMode == ZSTD_bm_buffered);
+            {   size_t const toFlush = zcs->outBuffContentSize - zcs->outBuffFlushedSize;
+                size_t const flushed = ZSTD_limitCopy(op, (size_t)(oend-op),
+                            zcs->outBuff + zcs->outBuffFlushedSize, toFlush);
+                DEBUGLOG(5, "toFlush: %u into %u ==> flushed: %u",
+                            (unsigned)toFlush, (unsigned)(oend-op), (unsigned)flushed);
+                if (flushed)
+                    op += flushed;
+                zcs->outBuffFlushedSize += flushed;
+                if (toFlush!=flushed) {
+                    /* flush not fully completed, presumably because dst is too small */
+                    assert(op==oend);
+                    someMoreWork = 0;
+                    break;
+                }
+                zcs->outBuffContentSize = zcs->outBuffFlushedSize = 0;
+                if (zcs->frameEnded) {
+                    DEBUGLOG(5, "Frame completed on flush");
+                    someMoreWork = 0;
+                    ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
+                    break;
+                }
+                zcs->streamStage = zcss_load;
+                break;
+            }
+
+        default: /* impossible */
+            assert(0);
+        }
+    }
+
+    input->pos = ip - istart;
+    output->pos = op - ostart;
+    if (zcs->frameEnded) return 0;
+    return ZSTD_nextInputSizeHint(zcs);
+}
+
+static size_t ZSTD_nextInputSizeHint_MTorST(const ZSTD_CCtx* cctx)
+{
+#ifdef ZSTD_MULTITHREAD
+    if (cctx->appliedParams.nbWorkers >= 1) {
+        assert(cctx->mtctx != NULL);
+        return ZSTDMT_nextInputSizeHint(cctx->mtctx);
+    }
+#endif
+    return ZSTD_nextInputSizeHint(cctx);
+
+}
+
+size_t ZSTD_compressStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output, ZSTD_inBuffer* input)
+{
+    FORWARD_IF_ERROR( ZSTD_compressStream2(zcs, output, input, ZSTD_e_continue) , "");
+    return ZSTD_nextInputSizeHint_MTorST(zcs);
+}
+
+/* After a compression call set the expected input/output buffer.
+ * This is validated at the start of the next compression call.
+ */
+static void
+ZSTD_setBufferExpectations(ZSTD_CCtx* cctx, const ZSTD_outBuffer* output, const ZSTD_inBuffer* input)
+{
+    DEBUGLOG(5, "ZSTD_setBufferExpectations (for advanced stable in/out modes)");
+    if (cctx->appliedParams.inBufferMode == ZSTD_bm_stable) {
+        cctx->expectedInBuffer = *input;
+    }
+    if (cctx->appliedParams.outBufferMode == ZSTD_bm_stable) {
+        cctx->expectedOutBufferSize = output->size - output->pos;
+    }
+}
+
+/* Validate that the input/output buffers match the expectations set by
+ * ZSTD_setBufferExpectations.
+ */
+static size_t ZSTD_checkBufferStability(ZSTD_CCtx const* cctx,
+                                        ZSTD_outBuffer const* output,
+                                        ZSTD_inBuffer const* input,
+                                        ZSTD_EndDirective endOp)
+{
+    if (cctx->appliedParams.inBufferMode == ZSTD_bm_stable) {
+        ZSTD_inBuffer const expect = cctx->expectedInBuffer;
+        if (expect.src != input->src || expect.pos != input->pos)
+            RETURN_ERROR(stabilityCondition_notRespected, "ZSTD_c_stableInBuffer enabled but input differs!");
+    }
+    (void)endOp;
+    if (cctx->appliedParams.outBufferMode == ZSTD_bm_stable) {
+        size_t const outBufferSize = output->size - output->pos;
+        if (cctx->expectedOutBufferSize != outBufferSize)
+            RETURN_ERROR(stabilityCondition_notRespected, "ZSTD_c_stableOutBuffer enabled but output size differs!");
+    }
+    return 0;
+}
+
+static size_t ZSTD_CCtx_init_compressStream2(ZSTD_CCtx* cctx,
+                                             ZSTD_EndDirective endOp,
+                                             size_t inSize)
+{
+    ZSTD_CCtx_params params = cctx->requestedParams;
+    ZSTD_prefixDict const prefixDict = cctx->prefixDict;
+    FORWARD_IF_ERROR( ZSTD_initLocalDict(cctx) , ""); /* Init the local dict if present. */
+    ZSTD_memset(&cctx->prefixDict, 0, sizeof(cctx->prefixDict));   /* single usage */
+    assert(prefixDict.dict==NULL || cctx->cdict==NULL);    /* only one can be set */
+    if (cctx->cdict && !cctx->localDict.cdict) {
+        /* Let the cdict's compression level take priority over the requested params.
+         * But do not take the cdict's compression level if the "cdict" is actually a localDict
+         * generated from ZSTD_initLocalDict().
+         */
+        params.compressionLevel = cctx->cdict->compressionLevel;
+    }
+    DEBUGLOG(4, "ZSTD_compressStream2 : transparent init stage");
+    if (endOp == ZSTD_e_end) cctx->pledgedSrcSizePlusOne = inSize + 1;  /* auto-determine pledgedSrcSize */
+
+    {   size_t const dictSize = prefixDict.dict
+                ? prefixDict.dictSize
+                : (cctx->cdict ? cctx->cdict->dictContentSize : 0);
+        ZSTD_cParamMode_e const mode = ZSTD_getCParamMode(cctx->cdict, &params, cctx->pledgedSrcSizePlusOne - 1);
+        params.cParams = ZSTD_getCParamsFromCCtxParams(
+                &params, cctx->pledgedSrcSizePlusOne-1,
+                dictSize, mode);
+    }
+
+    params.useBlockSplitter = ZSTD_resolveBlockSplitterMode(params.useBlockSplitter, &params.cParams);
+    params.ldmParams.enableLdm = ZSTD_resolveEnableLdm(params.ldmParams.enableLdm, &params.cParams);
+    params.useRowMatchFinder = ZSTD_resolveRowMatchFinderMode(params.useRowMatchFinder, &params.cParams);
+    params.validateSequences = ZSTD_resolveExternalSequenceValidation(params.validateSequences);
+    params.maxBlockSize = ZSTD_resolveMaxBlockSize(params.maxBlockSize);
+    params.searchForExternalRepcodes = ZSTD_resolveExternalRepcodeSearch(params.searchForExternalRepcodes, params.compressionLevel);
+
+#ifdef ZSTD_MULTITHREAD
+    /* If external matchfinder is enabled, make sure to fail before checking job size (for consistency) */
+    RETURN_ERROR_IF(
+        params.useSequenceProducer == 1 && params.nbWorkers >= 1,
+        parameter_combination_unsupported,
+        "External sequence producer isn't supported with nbWorkers >= 1"
+    );
+
+    if ((cctx->pledgedSrcSizePlusOne-1) <= ZSTDMT_JOBSIZE_MIN) {
+        params.nbWorkers = 0; /* do not invoke multi-threading when src size is too small */
+    }
+    if (params.nbWorkers > 0) {
+#if ZSTD_TRACE
+        cctx->traceCtx = (ZSTD_trace_compress_begin != NULL) ? ZSTD_trace_compress_begin(cctx) : 0;
+#endif
+        /* mt context creation */
+        if (cctx->mtctx == NULL) {
+            DEBUGLOG(4, "ZSTD_compressStream2: creating new mtctx for nbWorkers=%u",
+                        params.nbWorkers);
+            cctx->mtctx = ZSTDMT_createCCtx_advanced((U32)params.nbWorkers, cctx->customMem, cctx->pool);
+            RETURN_ERROR_IF(cctx->mtctx == NULL, memory_allocation, "NULL pointer!");
+        }
+        /* mt compression */
+        DEBUGLOG(4, "call ZSTDMT_initCStream_internal as nbWorkers=%u", params.nbWorkers);
+        FORWARD_IF_ERROR( ZSTDMT_initCStream_internal(
+                    cctx->mtctx,
+                    prefixDict.dict, prefixDict.dictSize, prefixDict.dictContentType,
+                    cctx->cdict, params, cctx->pledgedSrcSizePlusOne-1) , "");
+        cctx->dictID = cctx->cdict ? cctx->cdict->dictID : 0;
+        cctx->dictContentSize = cctx->cdict ? cctx->cdict->dictContentSize : prefixDict.dictSize;
+        cctx->consumedSrcSize = 0;
+        cctx->producedCSize = 0;
+        cctx->streamStage = zcss_load;
+        cctx->appliedParams = params;
+    } else
+#endif  /* ZSTD_MULTITHREAD */
+    {   U64 const pledgedSrcSize = cctx->pledgedSrcSizePlusOne - 1;
+        assert(!ZSTD_isError(ZSTD_checkCParams(params.cParams)));
+        FORWARD_IF_ERROR( ZSTD_compressBegin_internal(cctx,
+                prefixDict.dict, prefixDict.dictSize, prefixDict.dictContentType, ZSTD_dtlm_fast,
+                cctx->cdict,
+                &params, pledgedSrcSize,
+                ZSTDb_buffered) , "");
+        assert(cctx->appliedParams.nbWorkers == 0);
+        cctx->inToCompress = 0;
+        cctx->inBuffPos = 0;
+        if (cctx->appliedParams.inBufferMode == ZSTD_bm_buffered) {
+            /* for small input: avoid automatic flush on reaching end of block, since
+            * it would require to add a 3-bytes null block to end frame
+            */
+            cctx->inBuffTarget = cctx->blockSize + (cctx->blockSize == pledgedSrcSize);
+        } else {
+            cctx->inBuffTarget = 0;
+        }
+        cctx->outBuffContentSize = cctx->outBuffFlushedSize = 0;
+        cctx->streamStage = zcss_load;
+        cctx->frameEnded = 0;
+    }
+    return 0;
+}
+
+/* @return provides a minimum amount of data remaining to be flushed from internal buffers
+ */
+size_t ZSTD_compressStream2( ZSTD_CCtx* cctx,
+                             ZSTD_outBuffer* output,
+                             ZSTD_inBuffer* input,
+                             ZSTD_EndDirective endOp)
+{
+    DEBUGLOG(5, "ZSTD_compressStream2, endOp=%u ", (unsigned)endOp);
+    /* check conditions */
+    RETURN_ERROR_IF(output->pos > output->size, dstSize_tooSmall, "invalid output buffer");
+    RETURN_ERROR_IF(input->pos  > input->size, srcSize_wrong, "invalid input buffer");
+    RETURN_ERROR_IF((U32)endOp > (U32)ZSTD_e_end, parameter_outOfBound, "invalid endDirective");
+    assert(cctx != NULL);
+
+    /* transparent initialization stage */
+    if (cctx->streamStage == zcss_init) {
+        size_t const inputSize = input->size - input->pos;  /* no obligation to start from pos==0 */
+        size_t const totalInputSize = inputSize + cctx->stableIn_notConsumed;
+        if ( (cctx->requestedParams.inBufferMode == ZSTD_bm_stable) /* input is presumed stable, across invocations */
+          && (endOp == ZSTD_e_continue)                             /* no flush requested, more input to come */
+          && (totalInputSize < ZSTD_BLOCKSIZE_MAX) ) {              /* not even reached one block yet */
+            if (cctx->stableIn_notConsumed) {  /* not the first time */
+                /* check stable source guarantees */
+                RETURN_ERROR_IF(input->src != cctx->expectedInBuffer.src, stabilityCondition_notRespected, "stableInBuffer condition not respected: wrong src pointer");
+                RETURN_ERROR_IF(input->pos != cctx->expectedInBuffer.size, stabilityCondition_notRespected, "stableInBuffer condition not respected: externally modified pos");
+            }
+            /* pretend input was consumed, to give a sense forward progress */
+            input->pos = input->size;
+            /* save stable inBuffer, for later control, and flush/end */
+            cctx->expectedInBuffer = *input;
+            /* but actually input wasn't consumed, so keep track of position from where compression shall resume */
+            cctx->stableIn_notConsumed += inputSize;
+            /* don't initialize yet, wait for the first block of flush() order, for better parameters adaptation */
+            return ZSTD_FRAMEHEADERSIZE_MIN(cctx->requestedParams.format);  /* at least some header to produce */
+        }
+        FORWARD_IF_ERROR(ZSTD_CCtx_init_compressStream2(cctx, endOp, totalInputSize), "compressStream2 initialization failed");
+        ZSTD_setBufferExpectations(cctx, output, input);   /* Set initial buffer expectations now that we've initialized */
+    }
+    /* end of transparent initialization stage */
+
+    FORWARD_IF_ERROR(ZSTD_checkBufferStability(cctx, output, input, endOp), "invalid buffers");
+    /* compression stage */
+#ifdef ZSTD_MULTITHREAD
+    if (cctx->appliedParams.nbWorkers > 0) {
+        size_t flushMin;
+        if (cctx->cParamsChanged) {
+            ZSTDMT_updateCParams_whileCompressing(cctx->mtctx, &cctx->requestedParams);
+            cctx->cParamsChanged = 0;
+        }
+        if (cctx->stableIn_notConsumed) {
+            assert(cctx->appliedParams.inBufferMode == ZSTD_bm_stable);
+            /* some early data was skipped - make it available for consumption */
+            assert(input->pos >= cctx->stableIn_notConsumed);
+            input->pos -= cctx->stableIn_notConsumed;
+            cctx->stableIn_notConsumed = 0;
+        }
+        for (;;) {
+            size_t const ipos = input->pos;
+            size_t const opos = output->pos;
+            flushMin = ZSTDMT_compressStream_generic(cctx->mtctx, output, input, endOp);
+            cctx->consumedSrcSize += (U64)(input->pos - ipos);
+            cctx->producedCSize += (U64)(output->pos - opos);
+            if ( ZSTD_isError(flushMin)
+              || (endOp == ZSTD_e_end && flushMin == 0) ) { /* compression completed */
+                if (flushMin == 0)
+                    ZSTD_CCtx_trace(cctx, 0);
+                ZSTD_CCtx_reset(cctx, ZSTD_reset_session_only);
+            }
+            FORWARD_IF_ERROR(flushMin, "ZSTDMT_compressStream_generic failed");
+
+            if (endOp == ZSTD_e_continue) {
+                /* We only require some progress with ZSTD_e_continue, not maximal progress.
+                 * We're done if we've consumed or produced any bytes, or either buffer is
+                 * full.
+                 */
+                if (input->pos != ipos || output->pos != opos || input->pos == input->size || output->pos == output->size)
+                    break;
+            } else {
+                assert(endOp == ZSTD_e_flush || endOp == ZSTD_e_end);
+                /* We require maximal progress. We're done when the flush is complete or the
+                 * output buffer is full.
+                 */
+                if (flushMin == 0 || output->pos == output->size)
+                    break;
+            }
+        }
+        DEBUGLOG(5, "completed ZSTD_compressStream2 delegating to ZSTDMT_compressStream_generic");
+        /* Either we don't require maximum forward progress, we've finished the
+         * flush, or we are out of output space.
+         */
+        assert(endOp == ZSTD_e_continue || flushMin == 0 || output->pos == output->size);
+        ZSTD_setBufferExpectations(cctx, output, input);
+        return flushMin;
+    }
+#endif /* ZSTD_MULTITHREAD */
+    FORWARD_IF_ERROR( ZSTD_compressStream_generic(cctx, output, input, endOp) , "");
+    DEBUGLOG(5, "completed ZSTD_compressStream2");
+    ZSTD_setBufferExpectations(cctx, output, input);
+    return cctx->outBuffContentSize - cctx->outBuffFlushedSize; /* remaining to flush */
+}
+
+size_t ZSTD_compressStream2_simpleArgs (
+                            ZSTD_CCtx* cctx,
+                            void* dst, size_t dstCapacity, size_t* dstPos,
+                      const void* src, size_t srcSize, size_t* srcPos,
+                            ZSTD_EndDirective endOp)
+{
+    ZSTD_outBuffer output;
+    ZSTD_inBuffer  input;
+    output.dst = dst;
+    output.size = dstCapacity;
+    output.pos = *dstPos;
+    input.src = src;
+    input.size = srcSize;
+    input.pos = *srcPos;
+    /* ZSTD_compressStream2() will check validity of dstPos and srcPos */
+    {   size_t const cErr = ZSTD_compressStream2(cctx, &output, &input, endOp);
+        *dstPos = output.pos;
+        *srcPos = input.pos;
+        return cErr;
+    }
+}
+
+size_t ZSTD_compress2(ZSTD_CCtx* cctx,
+                      void* dst, size_t dstCapacity,
+                      const void* src, size_t srcSize)
+{
+    ZSTD_bufferMode_e const originalInBufferMode = cctx->requestedParams.inBufferMode;
+    ZSTD_bufferMode_e const originalOutBufferMode = cctx->requestedParams.outBufferMode;
+    DEBUGLOG(4, "ZSTD_compress2 (srcSize=%u)", (unsigned)srcSize);
+    ZSTD_CCtx_reset(cctx, ZSTD_reset_session_only);
+    /* Enable stable input/output buffers. */
+    cctx->requestedParams.inBufferMode = ZSTD_bm_stable;
+    cctx->requestedParams.outBufferMode = ZSTD_bm_stable;
+    {   size_t oPos = 0;
+        size_t iPos = 0;
+        size_t const result = ZSTD_compressStream2_simpleArgs(cctx,
+                                        dst, dstCapacity, &oPos,
+                                        src, srcSize, &iPos,
+                                        ZSTD_e_end);
+        /* Reset to the original values. */
+        cctx->requestedParams.inBufferMode = originalInBufferMode;
+        cctx->requestedParams.outBufferMode = originalOutBufferMode;
+
+        FORWARD_IF_ERROR(result, "ZSTD_compressStream2_simpleArgs failed");
+        if (result != 0) {  /* compression not completed, due to lack of output space */
+            assert(oPos == dstCapacity);
+            RETURN_ERROR(dstSize_tooSmall, "");
+        }
+        assert(iPos == srcSize);   /* all input is expected consumed */
+        return oPos;
+    }
+}
+
+/* ZSTD_validateSequence() :
+ * @offCode : is presumed to follow format required by ZSTD_storeSeq()
+ * @returns a ZSTD error code if sequence is not valid
+ */
+static size_t
+ZSTD_validateSequence(U32 offCode, U32 matchLength, U32 minMatch,
+                      size_t posInSrc, U32 windowLog, size_t dictSize, int useSequenceProducer)
+{
+    U32 const windowSize = 1u << windowLog;
+    /* posInSrc represents the amount of data the decoder would decode up to this point.
+     * As long as the amount of data decoded is less than or equal to window size, offsets may be
+     * larger than the total length of output decoded in order to reference the dict, even larger than
+     * window size. After output surpasses windowSize, we're limited to windowSize offsets again.
+     */
+    size_t const offsetBound = posInSrc > windowSize ? (size_t)windowSize : posInSrc + (size_t)dictSize;
+    size_t const matchLenLowerBound = (minMatch == 3 || useSequenceProducer) ? 3 : 4;
+    RETURN_ERROR_IF(offCode > OFFSET_TO_OFFBASE(offsetBound), externalSequences_invalid, "Offset too large!");
+    /* Validate maxNbSeq is large enough for the given matchLength and minMatch */
+    RETURN_ERROR_IF(matchLength < matchLenLowerBound, externalSequences_invalid, "Matchlength too small for the minMatch");
+    return 0;
+}
+
+/* Returns an offset code, given a sequence's raw offset, the ongoing repcode array, and whether litLength == 0 */
+static U32 ZSTD_finalizeOffBase(U32 rawOffset, const U32 rep[ZSTD_REP_NUM], U32 ll0)
+{
+    U32 offBase = OFFSET_TO_OFFBASE(rawOffset);
+
+    if (!ll0 && rawOffset == rep[0]) {
+        offBase = REPCODE1_TO_OFFBASE;
+    } else if (rawOffset == rep[1]) {
+        offBase = REPCODE_TO_OFFBASE(2 - ll0);
+    } else if (rawOffset == rep[2]) {
+        offBase = REPCODE_TO_OFFBASE(3 - ll0);
+    } else if (ll0 && rawOffset == rep[0] - 1) {
+        offBase = REPCODE3_TO_OFFBASE;
+    }
+    return offBase;
+}
+
+size_t
+ZSTD_copySequencesToSeqStoreExplicitBlockDelim(ZSTD_CCtx* cctx,
+                                              ZSTD_sequencePosition* seqPos,
+                                        const ZSTD_Sequence* const inSeqs, size_t inSeqsSize,
+                                        const void* src, size_t blockSize,
+                                        ZSTD_paramSwitch_e externalRepSearch)
+{
+    U32 idx = seqPos->idx;
+    U32 const startIdx = idx;
+    BYTE const* ip = (BYTE const*)(src);
+    const BYTE* const iend = ip + blockSize;
+    repcodes_t updatedRepcodes;
+    U32 dictSize;
+
+    DEBUGLOG(5, "ZSTD_copySequencesToSeqStoreExplicitBlockDelim (blockSize = %zu)", blockSize);
+
+    if (cctx->cdict) {
+        dictSize = (U32)cctx->cdict->dictContentSize;
+    } else if (cctx->prefixDict.dict) {
+        dictSize = (U32)cctx->prefixDict.dictSize;
+    } else {
+        dictSize = 0;
+    }
+    ZSTD_memcpy(updatedRepcodes.rep, cctx->blockState.prevCBlock->rep, sizeof(repcodes_t));
+    for (; idx < inSeqsSize && (inSeqs[idx].matchLength != 0 || inSeqs[idx].offset != 0); ++idx) {
+        U32 const litLength = inSeqs[idx].litLength;
+        U32 const matchLength = inSeqs[idx].matchLength;
+        U32 offBase;
+
+        if (externalRepSearch == ZSTD_ps_disable) {
+            offBase = OFFSET_TO_OFFBASE(inSeqs[idx].offset);
+        } else {
+            U32 const ll0 = (litLength == 0);
+            offBase = ZSTD_finalizeOffBase(inSeqs[idx].offset, updatedRepcodes.rep, ll0);
+            ZSTD_updateRep(updatedRepcodes.rep, offBase, ll0);
+        }
+
+        DEBUGLOG(6, "Storing sequence: (of: %u, ml: %u, ll: %u)", offBase, matchLength, litLength);
+        if (cctx->appliedParams.validateSequences) {
+            seqPos->posInSrc += litLength + matchLength;
+            FORWARD_IF_ERROR(ZSTD_validateSequence(offBase, matchLength, cctx->appliedParams.cParams.minMatch, seqPos->posInSrc,
+                                                cctx->appliedParams.cParams.windowLog, dictSize, cctx->appliedParams.useSequenceProducer),
+                                                "Sequence validation failed");
+        }
+        RETURN_ERROR_IF(idx - seqPos->idx >= cctx->seqStore.maxNbSeq, externalSequences_invalid,
+                        "Not enough memory allocated. Try adjusting ZSTD_c_minMatch.");
+        ZSTD_storeSeq(&cctx->seqStore, litLength, ip, iend, offBase, matchLength);
+        ip += matchLength + litLength;
+    }
+
+    /* If we skipped repcode search while parsing, we need to update repcodes now */
+    assert(externalRepSearch != ZSTD_ps_auto);
+    assert(idx >= startIdx);
+    if (externalRepSearch == ZSTD_ps_disable && idx != startIdx) {
+        U32* const rep = updatedRepcodes.rep;
+        U32 lastSeqIdx = idx - 1; /* index of last non-block-delimiter sequence */
+
+        if (lastSeqIdx >= startIdx + 2) {
+            rep[2] = inSeqs[lastSeqIdx - 2].offset;
+            rep[1] = inSeqs[lastSeqIdx - 1].offset;
+            rep[0] = inSeqs[lastSeqIdx].offset;
+        } else if (lastSeqIdx == startIdx + 1) {
+            rep[2] = rep[0];
+            rep[1] = inSeqs[lastSeqIdx - 1].offset;
+            rep[0] = inSeqs[lastSeqIdx].offset;
+        } else {
+            assert(lastSeqIdx == startIdx);
+            rep[2] = rep[1];
+            rep[1] = rep[0];
+            rep[0] = inSeqs[lastSeqIdx].offset;
+        }
+    }
+
+    ZSTD_memcpy(cctx->blockState.nextCBlock->rep, updatedRepcodes.rep, sizeof(repcodes_t));
+
+    if (inSeqs[idx].litLength) {
+        DEBUGLOG(6, "Storing last literals of size: %u", inSeqs[idx].litLength);
+        ZSTD_storeLastLiterals(&cctx->seqStore, ip, inSeqs[idx].litLength);
+        ip += inSeqs[idx].litLength;
+        seqPos->posInSrc += inSeqs[idx].litLength;
+    }
+    RETURN_ERROR_IF(ip != iend, externalSequences_invalid, "Blocksize doesn't agree with block delimiter!");
+    seqPos->idx = idx+1;
+    return 0;
+}
+
+size_t
+ZSTD_copySequencesToSeqStoreNoBlockDelim(ZSTD_CCtx* cctx, ZSTD_sequencePosition* seqPos,
+                                   const ZSTD_Sequence* const inSeqs, size_t inSeqsSize,
+                                   const void* src, size_t blockSize, ZSTD_paramSwitch_e externalRepSearch)
+{
+    U32 idx = seqPos->idx;
+    U32 startPosInSequence = seqPos->posInSequence;
+    U32 endPosInSequence = seqPos->posInSequence + (U32)blockSize;
+    size_t dictSize;
+    BYTE const* ip = (BYTE const*)(src);
+    BYTE const* iend = ip + blockSize;  /* May be adjusted if we decide to process fewer than blockSize bytes */
+    repcodes_t updatedRepcodes;
+    U32 bytesAdjustment = 0;
+    U32 finalMatchSplit = 0;
+
+    /* TODO(embg) support fast parsing mode in noBlockDelim mode */
+    (void)externalRepSearch;
+
+    if (cctx->cdict) {
+        dictSize = cctx->cdict->dictContentSize;
+    } else if (cctx->prefixDict.dict) {
+        dictSize = cctx->prefixDict.dictSize;
+    } else {
+        dictSize = 0;
+    }
+    DEBUGLOG(5, "ZSTD_copySequencesToSeqStoreNoBlockDelim: idx: %u PIS: %u blockSize: %zu", idx, startPosInSequence, blockSize);
+    DEBUGLOG(5, "Start seq: idx: %u (of: %u ml: %u ll: %u)", idx, inSeqs[idx].offset, inSeqs[idx].matchLength, inSeqs[idx].litLength);
+    ZSTD_memcpy(updatedRepcodes.rep, cctx->blockState.prevCBlock->rep, sizeof(repcodes_t));
+    while (endPosInSequence && idx < inSeqsSize && !finalMatchSplit) {
+        const ZSTD_Sequence currSeq = inSeqs[idx];
+        U32 litLength = currSeq.litLength;
+        U32 matchLength = currSeq.matchLength;
+        U32 const rawOffset = currSeq.offset;
+        U32 offBase;
+
+        /* Modify the sequence depending on where endPosInSequence lies */
+        if (endPosInSequence >= currSeq.litLength + currSeq.matchLength) {
+            if (startPosInSequence >= litLength) {
+                startPosInSequence -= litLength;
+                litLength = 0;
+                matchLength -= startPosInSequence;
+            } else {
+                litLength -= startPosInSequence;
+            }
+            /* Move to the next sequence */
+            endPosInSequence -= currSeq.litLength + currSeq.matchLength;
+            startPosInSequence = 0;
+        } else {
+            /* This is the final (partial) sequence we're adding from inSeqs, and endPosInSequence
+               does not reach the end of the match. So, we have to split the sequence */
+            DEBUGLOG(6, "Require a split: diff: %u, idx: %u PIS: %u",
+                     currSeq.litLength + currSeq.matchLength - endPosInSequence, idx, endPosInSequence);
+            if (endPosInSequence > litLength) {
+                U32 firstHalfMatchLength;
+                litLength = startPosInSequence >= litLength ? 0 : litLength - startPosInSequence;
+                firstHalfMatchLength = endPosInSequence - startPosInSequence - litLength;
+                if (matchLength > blockSize && firstHalfMatchLength >= cctx->appliedParams.cParams.minMatch) {
+                    /* Only ever split the match if it is larger than the block size */
+                    U32 secondHalfMatchLength = currSeq.matchLength + currSeq.litLength - endPosInSequence;
+                    if (secondHalfMatchLength < cctx->appliedParams.cParams.minMatch) {
+                        /* Move the endPosInSequence backward so that it creates match of minMatch length */
+                        endPosInSequence -= cctx->appliedParams.cParams.minMatch - secondHalfMatchLength;
+                        bytesAdjustment = cctx->appliedParams.cParams.minMatch - secondHalfMatchLength;
+                        firstHalfMatchLength -= bytesAdjustment;
+                    }
+                    matchLength = firstHalfMatchLength;
+                    /* Flag that we split the last match - after storing the sequence, exit the loop,
+                       but keep the value of endPosInSequence */
+                    finalMatchSplit = 1;
+                } else {
+                    /* Move the position in sequence backwards so that we don't split match, and break to store
+                     * the last literals. We use the original currSeq.litLength as a marker for where endPosInSequence
+                     * should go. We prefer to do this whenever it is not necessary to split the match, or if doing so
+                     * would cause the first half of the match to be too small
+                     */
+                    bytesAdjustment = endPosInSequence - currSeq.litLength;
+                    endPosInSequence = currSeq.litLength;
+                    break;
+                }
+            } else {
+                /* This sequence ends inside the literals, break to store the last literals */
+                break;
+            }
+        }
+        /* Check if this offset can be represented with a repcode */
+        {   U32 const ll0 = (litLength == 0);
+            offBase = ZSTD_finalizeOffBase(rawOffset, updatedRepcodes.rep, ll0);
+            ZSTD_updateRep(updatedRepcodes.rep, offBase, ll0);
+        }
+
+        if (cctx->appliedParams.validateSequences) {
+            seqPos->posInSrc += litLength + matchLength;
+            FORWARD_IF_ERROR(ZSTD_validateSequence(offBase, matchLength, cctx->appliedParams.cParams.minMatch, seqPos->posInSrc,
+                                                   cctx->appliedParams.cParams.windowLog, dictSize, cctx->appliedParams.useSequenceProducer),
+                                                   "Sequence validation failed");
+        }
+        DEBUGLOG(6, "Storing sequence: (of: %u, ml: %u, ll: %u)", offBase, matchLength, litLength);
+        RETURN_ERROR_IF(idx - seqPos->idx >= cctx->seqStore.maxNbSeq, externalSequences_invalid,
+                        "Not enough memory allocated. Try adjusting ZSTD_c_minMatch.");
+        ZSTD_storeSeq(&cctx->seqStore, litLength, ip, iend, offBase, matchLength);
+        ip += matchLength + litLength;
+        if (!finalMatchSplit)
+            idx++; /* Next Sequence */
+    }
+    DEBUGLOG(5, "Ending seq: idx: %u (of: %u ml: %u ll: %u)", idx, inSeqs[idx].offset, inSeqs[idx].matchLength, inSeqs[idx].litLength);
+    assert(idx == inSeqsSize || endPosInSequence <= inSeqs[idx].litLength + inSeqs[idx].matchLength);
+    seqPos->idx = idx;
+    seqPos->posInSequence = endPosInSequence;
+    ZSTD_memcpy(cctx->blockState.nextCBlock->rep, updatedRepcodes.rep, sizeof(repcodes_t));
+
+    iend -= bytesAdjustment;
+    if (ip != iend) {
+        /* Store any last literals */
+        U32 lastLLSize = (U32)(iend - ip);
+        assert(ip <= iend);
+        DEBUGLOG(6, "Storing last literals of size: %u", lastLLSize);
+        ZSTD_storeLastLiterals(&cctx->seqStore, ip, lastLLSize);
+        seqPos->posInSrc += lastLLSize;
+    }
+
+    return bytesAdjustment;
+}
+
+typedef size_t (*ZSTD_sequenceCopier) (ZSTD_CCtx* cctx, ZSTD_sequencePosition* seqPos,
+                                       const ZSTD_Sequence* const inSeqs, size_t inSeqsSize,
+                                       const void* src, size_t blockSize, ZSTD_paramSwitch_e externalRepSearch);
+static ZSTD_sequenceCopier ZSTD_selectSequenceCopier(ZSTD_sequenceFormat_e mode)
+{
+    ZSTD_sequenceCopier sequenceCopier = NULL;
+    assert(ZSTD_cParam_withinBounds(ZSTD_c_blockDelimiters, mode));
+    if (mode == ZSTD_sf_explicitBlockDelimiters) {
+        return ZSTD_copySequencesToSeqStoreExplicitBlockDelim;
+    } else if (mode == ZSTD_sf_noBlockDelimiters) {
+        return ZSTD_copySequencesToSeqStoreNoBlockDelim;
+    }
+    assert(sequenceCopier != NULL);
+    return sequenceCopier;
+}
+
+/* Discover the size of next block by searching for the delimiter.
+ * Note that a block delimiter **must** exist in this mode,
+ * otherwise it's an input error.
+ * The block size retrieved will be later compared to ensure it remains within bounds */
+static size_t
+blockSize_explicitDelimiter(const ZSTD_Sequence* inSeqs, size_t inSeqsSize, ZSTD_sequencePosition seqPos)
+{
+    int end = 0;
+    size_t blockSize = 0;
+    size_t spos = seqPos.idx;
+    DEBUGLOG(6, "blockSize_explicitDelimiter : seq %zu / %zu", spos, inSeqsSize);
+    assert(spos <= inSeqsSize);
+    while (spos < inSeqsSize) {
+        end = (inSeqs[spos].offset == 0);
+        blockSize += inSeqs[spos].litLength + inSeqs[spos].matchLength;
+        if (end) {
+            if (inSeqs[spos].matchLength != 0)
+                RETURN_ERROR(externalSequences_invalid, "delimiter format error : both matchlength and offset must be == 0");
+            break;
+        }
+        spos++;
+    }
+    if (!end)
+        RETURN_ERROR(externalSequences_invalid, "Reached end of sequences without finding a block delimiter");
+    return blockSize;
+}
+
+/* More a "target" block size */
+static size_t blockSize_noDelimiter(size_t blockSize, size_t remaining)
+{
+    int const lastBlock = (remaining <= blockSize);
+    return lastBlock ? remaining : blockSize;
+}
+
+static size_t determine_blockSize(ZSTD_sequenceFormat_e mode,
+                           size_t blockSize, size_t remaining,
+                     const ZSTD_Sequence* inSeqs, size_t inSeqsSize, ZSTD_sequencePosition seqPos)
+{
+    DEBUGLOG(6, "determine_blockSize : remainingSize = %zu", remaining);
+    if (mode == ZSTD_sf_noBlockDelimiters)
+        return blockSize_noDelimiter(blockSize, remaining);
+    {   size_t const explicitBlockSize = blockSize_explicitDelimiter(inSeqs, inSeqsSize, seqPos);
+        FORWARD_IF_ERROR(explicitBlockSize, "Error while determining block size with explicit delimiters");
+        if (explicitBlockSize > blockSize)
+            RETURN_ERROR(externalSequences_invalid, "sequences incorrectly define a too large block");
+        if (explicitBlockSize > remaining)
+            RETURN_ERROR(externalSequences_invalid, "sequences define a frame longer than source");
+        return explicitBlockSize;
+    }
+}
+
+/* Compress, block-by-block, all of the sequences given.
+ *
+ * Returns the cumulative size of all compressed blocks (including their headers),
+ * otherwise a ZSTD error.
+ */
+static size_t
+ZSTD_compressSequences_internal(ZSTD_CCtx* cctx,
+                                void* dst, size_t dstCapacity,
+                          const ZSTD_Sequence* inSeqs, size_t inSeqsSize,
+                          const void* src, size_t srcSize)
+{
+    size_t cSize = 0;
+    size_t remaining = srcSize;
+    ZSTD_sequencePosition seqPos = {0, 0, 0};
+
+    BYTE const* ip = (BYTE const*)src;
+    BYTE* op = (BYTE*)dst;
+    ZSTD_sequenceCopier const sequenceCopier = ZSTD_selectSequenceCopier(cctx->appliedParams.blockDelimiters);
+
+    DEBUGLOG(4, "ZSTD_compressSequences_internal srcSize: %zu, inSeqsSize: %zu", srcSize, inSeqsSize);
+    /* Special case: empty frame */
+    if (remaining == 0) {
+        U32 const cBlockHeader24 = 1 /* last block */ + (((U32)bt_raw)<<1);
+        RETURN_ERROR_IF(dstCapacity<4, dstSize_tooSmall, "No room for empty frame block header");
+        MEM_writeLE32(op, cBlockHeader24);
+        op += ZSTD_blockHeaderSize;
+        dstCapacity -= ZSTD_blockHeaderSize;
+        cSize += ZSTD_blockHeaderSize;
+    }
+
+    while (remaining) {
+        size_t compressedSeqsSize;
+        size_t cBlockSize;
+        size_t additionalByteAdjustment;
+        size_t blockSize = determine_blockSize(cctx->appliedParams.blockDelimiters,
+                                        cctx->blockSize, remaining,
+                                        inSeqs, inSeqsSize, seqPos);
+        U32 const lastBlock = (blockSize == remaining);
+        FORWARD_IF_ERROR(blockSize, "Error while trying to determine block size");
+        assert(blockSize <= remaining);
+        ZSTD_resetSeqStore(&cctx->seqStore);
+        DEBUGLOG(5, "Working on new block. Blocksize: %zu (total:%zu)", blockSize, (ip - (const BYTE*)src) + blockSize);
+
+        additionalByteAdjustment = sequenceCopier(cctx, &seqPos, inSeqs, inSeqsSize, ip, blockSize, cctx->appliedParams.searchForExternalRepcodes);
+        FORWARD_IF_ERROR(additionalByteAdjustment, "Bad sequence copy");
+        blockSize -= additionalByteAdjustment;
+
+        /* If blocks are too small, emit as a nocompress block */
+        /* TODO: See 3090. We reduced MIN_CBLOCK_SIZE from 3 to 2 so to compensate we are adding
+         * additional 1. We need to revisit and change this logic to be more consistent */
+        if (blockSize < MIN_CBLOCK_SIZE+ZSTD_blockHeaderSize+1+1) {
+            cBlockSize = ZSTD_noCompressBlock(op, dstCapacity, ip, blockSize, lastBlock);
+            FORWARD_IF_ERROR(cBlockSize, "Nocompress block failed");
+            DEBUGLOG(5, "Block too small, writing out nocompress block: cSize: %zu", cBlockSize);
+            cSize += cBlockSize;
+            ip += blockSize;
+            op += cBlockSize;
+            remaining -= blockSize;
+            dstCapacity -= cBlockSize;
+            continue;
+        }
+
+        RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize, dstSize_tooSmall, "not enough dstCapacity to write a new compressed block");
+        compressedSeqsSize = ZSTD_entropyCompressSeqStore(&cctx->seqStore,
+                                &cctx->blockState.prevCBlock->entropy, &cctx->blockState.nextCBlock->entropy,
+                                &cctx->appliedParams,
+                                op + ZSTD_blockHeaderSize /* Leave space for block header */, dstCapacity - ZSTD_blockHeaderSize,
+                                blockSize,
+                                cctx->entropyWorkspace, ENTROPY_WORKSPACE_SIZE /* statically allocated in resetCCtx */,
+                                cctx->bmi2);
+        FORWARD_IF_ERROR(compressedSeqsSize, "Compressing sequences of block failed");
+        DEBUGLOG(5, "Compressed sequences size: %zu", compressedSeqsSize);
+
+        if (!cctx->isFirstBlock &&
+            ZSTD_maybeRLE(&cctx->seqStore) &&
+            ZSTD_isRLE(ip, blockSize)) {
+            /* We don't want to emit our first block as a RLE even if it qualifies because
+            * doing so will cause the decoder (cli only) to throw a "should consume all input error."
+            * This is only an issue for zstd <= v1.4.3
+            */
+            compressedSeqsSize = 1;
+        }
+
+        if (compressedSeqsSize == 0) {
+            /* ZSTD_noCompressBlock writes the block header as well */
+            cBlockSize = ZSTD_noCompressBlock(op, dstCapacity, ip, blockSize, lastBlock);
+            FORWARD_IF_ERROR(cBlockSize, "ZSTD_noCompressBlock failed");
+            DEBUGLOG(5, "Writing out nocompress block, size: %zu", cBlockSize);
+        } else if (compressedSeqsSize == 1) {
+            cBlockSize = ZSTD_rleCompressBlock(op, dstCapacity, *ip, blockSize, lastBlock);
+            FORWARD_IF_ERROR(cBlockSize, "ZSTD_rleCompressBlock failed");
+            DEBUGLOG(5, "Writing out RLE block, size: %zu", cBlockSize);
+        } else {
+            U32 cBlockHeader;
+            /* Error checking and repcodes update */
+            ZSTD_blockState_confirmRepcodesAndEntropyTables(&cctx->blockState);
+            if (cctx->blockState.prevCBlock->entropy.fse.offcode_repeatMode == FSE_repeat_valid)
+                cctx->blockState.prevCBlock->entropy.fse.offcode_repeatMode = FSE_repeat_check;
+
+            /* Write block header into beginning of block*/
+            cBlockHeader = lastBlock + (((U32)bt_compressed)<<1) + (U32)(compressedSeqsSize << 3);
+            MEM_writeLE24(op, cBlockHeader);
+            cBlockSize = ZSTD_blockHeaderSize + compressedSeqsSize;
+            DEBUGLOG(5, "Writing out compressed block, size: %zu", cBlockSize);
+        }
+
+        cSize += cBlockSize;
+
+        if (lastBlock) {
+            break;
+        } else {
+            ip += blockSize;
+            op += cBlockSize;
+            remaining -= blockSize;
+            dstCapacity -= cBlockSize;
+            cctx->isFirstBlock = 0;
+        }
+        DEBUGLOG(5, "cSize running total: %zu (remaining dstCapacity=%zu)", cSize, dstCapacity);
+    }
+
+    DEBUGLOG(4, "cSize final total: %zu", cSize);
+    return cSize;
+}
+
+size_t ZSTD_compressSequences(ZSTD_CCtx* cctx,
+                              void* dst, size_t dstCapacity,
+                              const ZSTD_Sequence* inSeqs, size_t inSeqsSize,
+                              const void* src, size_t srcSize)
+{
+    BYTE* op = (BYTE*)dst;
+    size_t cSize = 0;
+    size_t compressedBlocksSize = 0;
+    size_t frameHeaderSize = 0;
+
+    /* Transparent initialization stage, same as compressStream2() */
+    DEBUGLOG(4, "ZSTD_compressSequences (dstCapacity=%zu)", dstCapacity);
+    assert(cctx != NULL);
+    FORWARD_IF_ERROR(ZSTD_CCtx_init_compressStream2(cctx, ZSTD_e_end, srcSize), "CCtx initialization failed");
+    /* Begin writing output, starting with frame header */
+    frameHeaderSize = ZSTD_writeFrameHeader(op, dstCapacity, &cctx->appliedParams, srcSize, cctx->dictID);
+    op += frameHeaderSize;
+    dstCapacity -= frameHeaderSize;
+    cSize += frameHeaderSize;
+    if (cctx->appliedParams.fParams.checksumFlag && srcSize) {
+        XXH64_update(&cctx->xxhState, src, srcSize);
+    }
+    /* cSize includes block header size and compressed sequences size */
+    compressedBlocksSize = ZSTD_compressSequences_internal(cctx,
+                                                           op, dstCapacity,
+                                                           inSeqs, inSeqsSize,
+                                                           src, srcSize);
+    FORWARD_IF_ERROR(compressedBlocksSize, "Compressing blocks failed!");
+    cSize += compressedBlocksSize;
+    dstCapacity -= compressedBlocksSize;
+
+    if (cctx->appliedParams.fParams.checksumFlag) {
+        U32 const checksum = (U32) XXH64_digest(&cctx->xxhState);
+        RETURN_ERROR_IF(dstCapacity<4, dstSize_tooSmall, "no room for checksum");
+        DEBUGLOG(4, "Write checksum : %08X", (unsigned)checksum);
+        MEM_writeLE32((char*)dst + cSize, checksum);
+        cSize += 4;
+    }
+
+    DEBUGLOG(4, "Final compressed size: %zu", cSize);
+    return cSize;
+}
+
+/*======   Finalize   ======*/
+
+static ZSTD_inBuffer inBuffer_forEndFlush(const ZSTD_CStream* zcs)
+{
+    const ZSTD_inBuffer nullInput = { NULL, 0, 0 };
+    const int stableInput = (zcs->appliedParams.inBufferMode == ZSTD_bm_stable);
+    return stableInput ? zcs->expectedInBuffer : nullInput;
+}
+
+/*! ZSTD_flushStream() :
+ * @return : amount of data remaining to flush */
+size_t ZSTD_flushStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output)
+{
+    ZSTD_inBuffer input = inBuffer_forEndFlush(zcs);
+    input.size = input.pos; /* do not ingest more input during flush */
+    return ZSTD_compressStream2(zcs, output, &input, ZSTD_e_flush);
+}
+
+
+size_t ZSTD_endStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output)
+{
+    ZSTD_inBuffer input = inBuffer_forEndFlush(zcs);
+    size_t const remainingToFlush = ZSTD_compressStream2(zcs, output, &input, ZSTD_e_end);
+    FORWARD_IF_ERROR(remainingToFlush , "ZSTD_compressStream2(,,ZSTD_e_end) failed");
+    if (zcs->appliedParams.nbWorkers > 0) return remainingToFlush;   /* minimal estimation */
+    /* single thread mode : attempt to calculate remaining to flush more precisely */
+    {   size_t const lastBlockSize = zcs->frameEnded ? 0 : ZSTD_BLOCKHEADERSIZE;
+        size_t const checksumSize = (size_t)(zcs->frameEnded ? 0 : zcs->appliedParams.fParams.checksumFlag * 4);
+        size_t const toFlush = remainingToFlush + lastBlockSize + checksumSize;
+        DEBUGLOG(4, "ZSTD_endStream : remaining to flush : %u", (unsigned)toFlush);
+        return toFlush;
+    }
+}
+
+
+/*-=====  Pre-defined compression levels  =====-*/
+#include "clevels.h"
+
+int ZSTD_maxCLevel(void) { return ZSTD_MAX_CLEVEL; }
+int ZSTD_minCLevel(void) { return (int)-ZSTD_TARGETLENGTH_MAX; }
+int ZSTD_defaultCLevel(void) { return ZSTD_CLEVEL_DEFAULT; }
+
+static ZSTD_compressionParameters ZSTD_dedicatedDictSearch_getCParams(int const compressionLevel, size_t const dictSize)
+{
+    ZSTD_compressionParameters cParams = ZSTD_getCParams_internal(compressionLevel, 0, dictSize, ZSTD_cpm_createCDict);
+    switch (cParams.strategy) {
+        case ZSTD_fast:
+        case ZSTD_dfast:
+            break;
+        case ZSTD_greedy:
+        case ZSTD_lazy:
+        case ZSTD_lazy2:
+            cParams.hashLog += ZSTD_LAZY_DDSS_BUCKET_LOG;
+            break;
+        case ZSTD_btlazy2:
+        case ZSTD_btopt:
+        case ZSTD_btultra:
+        case ZSTD_btultra2:
+            break;
+    }
+    return cParams;
+}
+
+static int ZSTD_dedicatedDictSearch_isSupported(
+        ZSTD_compressionParameters const* cParams)
+{
+    return (cParams->strategy >= ZSTD_greedy)
+        && (cParams->strategy <= ZSTD_lazy2)
+        && (cParams->hashLog > cParams->chainLog)
+        && (cParams->chainLog <= 24);
+}
+
+/**
+ * Reverses the adjustment applied to cparams when enabling dedicated dict
+ * search. This is used to recover the params set to be used in the working
+ * context. (Otherwise, those tables would also grow.)
+ */
+static void ZSTD_dedicatedDictSearch_revertCParams(
+        ZSTD_compressionParameters* cParams) {
+    switch (cParams->strategy) {
+        case ZSTD_fast:
+        case ZSTD_dfast:
+            break;
+        case ZSTD_greedy:
+        case ZSTD_lazy:
+        case ZSTD_lazy2:
+            cParams->hashLog -= ZSTD_LAZY_DDSS_BUCKET_LOG;
+            if (cParams->hashLog < ZSTD_HASHLOG_MIN) {
+                cParams->hashLog = ZSTD_HASHLOG_MIN;
+            }
+            break;
+        case ZSTD_btlazy2:
+        case ZSTD_btopt:
+        case ZSTD_btultra:
+        case ZSTD_btultra2:
+            break;
+    }
+}
+
+static U64 ZSTD_getCParamRowSize(U64 srcSizeHint, size_t dictSize, ZSTD_cParamMode_e mode)
+{
+    switch (mode) {
+    case ZSTD_cpm_unknown:
+    case ZSTD_cpm_noAttachDict:
+    case ZSTD_cpm_createCDict:
+        break;
+    case ZSTD_cpm_attachDict:
+        dictSize = 0;
+        break;
+    default:
+        assert(0);
+        break;
+    }
+    {   int const unknown = srcSizeHint == ZSTD_CONTENTSIZE_UNKNOWN;
+        size_t const addedSize = unknown && dictSize > 0 ? 500 : 0;
+        return unknown && dictSize == 0 ? ZSTD_CONTENTSIZE_UNKNOWN : srcSizeHint+dictSize+addedSize;
+    }
+}
+
+/*! ZSTD_getCParams_internal() :
+ * @return ZSTD_compressionParameters structure for a selected compression level, srcSize and dictSize.
+ *  Note: srcSizeHint 0 means 0, use ZSTD_CONTENTSIZE_UNKNOWN for unknown.
+ *        Use dictSize == 0 for unknown or unused.
+ *  Note: `mode` controls how we treat the `dictSize`. See docs for `ZSTD_cParamMode_e`. */
+static ZSTD_compressionParameters ZSTD_getCParams_internal(int compressionLevel, unsigned long long srcSizeHint, size_t dictSize, ZSTD_cParamMode_e mode)
+{
+    U64 const rSize = ZSTD_getCParamRowSize(srcSizeHint, dictSize, mode);
+    U32 const tableID = (rSize <= 256 KB) + (rSize <= 128 KB) + (rSize <= 16 KB);
+    int row;
+    DEBUGLOG(5, "ZSTD_getCParams_internal (cLevel=%i)", compressionLevel);
+
+    /* row */
+    if (compressionLevel == 0) row = ZSTD_CLEVEL_DEFAULT;   /* 0 == default */
+    else if (compressionLevel < 0) row = 0;   /* entry 0 is baseline for fast mode */
+    else if (compressionLevel > ZSTD_MAX_CLEVEL) row = ZSTD_MAX_CLEVEL;
+    else row = compressionLevel;
+
+    {   ZSTD_compressionParameters cp = ZSTD_defaultCParameters[tableID][row];
+        DEBUGLOG(5, "ZSTD_getCParams_internal selected tableID: %u row: %u strat: %u", tableID, row, (U32)cp.strategy);
+        /* acceleration factor */
+        if (compressionLevel < 0) {
+            int const clampedCompressionLevel = MAX(ZSTD_minCLevel(), compressionLevel);
+            cp.targetLength = (unsigned)(-clampedCompressionLevel);
+        }
+        /* refine parameters based on srcSize & dictSize */
+        return ZSTD_adjustCParams_internal(cp, srcSizeHint, dictSize, mode, ZSTD_ps_auto);
+    }
+}
+
+/*! ZSTD_getCParams() :
+ * @return ZSTD_compressionParameters structure for a selected compression level, srcSize and dictSize.
+ *  Size values are optional, provide 0 if not known or unused */
+ZSTD_compressionParameters ZSTD_getCParams(int compressionLevel, unsigned long long srcSizeHint, size_t dictSize)
+{
+    if (srcSizeHint == 0) srcSizeHint = ZSTD_CONTENTSIZE_UNKNOWN;
+    return ZSTD_getCParams_internal(compressionLevel, srcSizeHint, dictSize, ZSTD_cpm_unknown);
+}
+
+/*! ZSTD_getParams() :
+ *  same idea as ZSTD_getCParams()
+ * @return a `ZSTD_parameters` structure (instead of `ZSTD_compressionParameters`).
+ *  Fields of `ZSTD_frameParameters` are set to default values */
+static ZSTD_parameters ZSTD_getParams_internal(int compressionLevel, unsigned long long srcSizeHint, size_t dictSize, ZSTD_cParamMode_e mode) {
+    ZSTD_parameters params;
+    ZSTD_compressionParameters const cParams = ZSTD_getCParams_internal(compressionLevel, srcSizeHint, dictSize, mode);
+    DEBUGLOG(5, "ZSTD_getParams (cLevel=%i)", compressionLevel);
+    ZSTD_memset(&params, 0, sizeof(params));
+    params.cParams = cParams;
+    params.fParams.contentSizeFlag = 1;
+    return params;
+}
+
+/*! ZSTD_getParams() :
+ *  same idea as ZSTD_getCParams()
+ * @return a `ZSTD_parameters` structure (instead of `ZSTD_compressionParameters`).
+ *  Fields of `ZSTD_frameParameters` are set to default values */
+ZSTD_parameters ZSTD_getParams(int compressionLevel, unsigned long long srcSizeHint, size_t dictSize) {
+    if (srcSizeHint == 0) srcSizeHint = ZSTD_CONTENTSIZE_UNKNOWN;
+    return ZSTD_getParams_internal(compressionLevel, srcSizeHint, dictSize, ZSTD_cpm_unknown);
+}
+
+void ZSTD_registerSequenceProducer(
+    ZSTD_CCtx* zc, void* mState,
+    ZSTD_sequenceProducer_F* mFinder
+) {
+    if (mFinder != NULL) {
+        ZSTD_externalMatchCtx emctx;
+        emctx.mState = mState;
+        emctx.mFinder = mFinder;
+        emctx.seqBuffer = NULL;
+        emctx.seqBufferCapacity = 0;
+        zc->externalMatchCtx = emctx;
+        zc->requestedParams.useSequenceProducer = 1;
+    } else {
+        ZSTD_memset(&zc->externalMatchCtx, 0, sizeof(zc->externalMatchCtx));
+        zc->requestedParams.useSequenceProducer = 0;
+    }
+}
diff --git a/src/3rdparty/zstd/src/compress/zstd_compress_internal.h b/src/3rdparty/zstd/src/compress/zstd_compress_internal.h
new file mode 100644
index 0000000000..10f68d010e
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_compress_internal.h
@@ -0,0 +1,1532 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+/* This header contains definitions
+ * that shall **only** be used by modules within lib/compress.
+ */
+
+#ifndef ZSTD_COMPRESS_H
+#define ZSTD_COMPRESS_H
+
+/*-*************************************
+*  Dependencies
+***************************************/
+#include "../common/zstd_internal.h"
+#include "zstd_cwksp.h"
+#ifdef ZSTD_MULTITHREAD
+#  include "zstdmt_compress.h"
+#endif
+#include "../common/bits.h" /* ZSTD_highbit32, ZSTD_NbCommonBytes */
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+/*-*************************************
+*  Constants
+***************************************/
+#define kSearchStrength      8
+#define HASH_READ_SIZE       8
+#define ZSTD_DUBT_UNSORTED_MARK 1   /* For btlazy2 strategy, index ZSTD_DUBT_UNSORTED_MARK==1 means "unsorted".
+                                       It could be confused for a real successor at index "1", if sorted as larger than its predecessor.
+                                       It's not a big deal though : candidate will just be sorted again.
+                                       Additionally, candidate position 1 will be lost.
+                                       But candidate 1 cannot hide a large tree of candidates, so it's a minimal loss.
+                                       The benefit is that ZSTD_DUBT_UNSORTED_MARK cannot be mishandled after table re-use with a different strategy.
+                                       This constant is required by ZSTD_compressBlock_btlazy2() and ZSTD_reduceTable_internal() */
+
+
+/*-*************************************
+*  Context memory management
+***************************************/
+typedef enum { ZSTDcs_created=0, ZSTDcs_init, ZSTDcs_ongoing, ZSTDcs_ending } ZSTD_compressionStage_e;
+typedef enum { zcss_init=0, zcss_load, zcss_flush } ZSTD_cStreamStage;
+
+typedef struct ZSTD_prefixDict_s {
+    const void* dict;
+    size_t dictSize;
+    ZSTD_dictContentType_e dictContentType;
+} ZSTD_prefixDict;
+
+typedef struct {
+    void* dictBuffer;
+    void const* dict;
+    size_t dictSize;
+    ZSTD_dictContentType_e dictContentType;
+    ZSTD_CDict* cdict;
+} ZSTD_localDict;
+
+typedef struct {
+    HUF_CElt CTable[HUF_CTABLE_SIZE_ST(255)];
+    HUF_repeat repeatMode;
+} ZSTD_hufCTables_t;
+
+typedef struct {
+    FSE_CTable offcodeCTable[FSE_CTABLE_SIZE_U32(OffFSELog, MaxOff)];
+    FSE_CTable matchlengthCTable[FSE_CTABLE_SIZE_U32(MLFSELog, MaxML)];
+    FSE_CTable litlengthCTable[FSE_CTABLE_SIZE_U32(LLFSELog, MaxLL)];
+    FSE_repeat offcode_repeatMode;
+    FSE_repeat matchlength_repeatMode;
+    FSE_repeat litlength_repeatMode;
+} ZSTD_fseCTables_t;
+
+typedef struct {
+    ZSTD_hufCTables_t huf;
+    ZSTD_fseCTables_t fse;
+} ZSTD_entropyCTables_t;
+
+/***********************************************
+*  Entropy buffer statistics structs and funcs *
+***********************************************/
+/** ZSTD_hufCTablesMetadata_t :
+ *  Stores Literals Block Type for a super-block in hType, and
+ *  huffman tree description in hufDesBuffer.
+ *  hufDesSize refers to the size of huffman tree description in bytes.
+ *  This metadata is populated in ZSTD_buildBlockEntropyStats_literals() */
+typedef struct {
+    symbolEncodingType_e hType;
+    BYTE hufDesBuffer[ZSTD_MAX_HUF_HEADER_SIZE];
+    size_t hufDesSize;
+} ZSTD_hufCTablesMetadata_t;
+
+/** ZSTD_fseCTablesMetadata_t :
+ *  Stores symbol compression modes for a super-block in {ll, ol, ml}Type, and
+ *  fse tables in fseTablesBuffer.
+ *  fseTablesSize refers to the size of fse tables in bytes.
+ *  This metadata is populated in ZSTD_buildBlockEntropyStats_sequences() */
+typedef struct {
+    symbolEncodingType_e llType;
+    symbolEncodingType_e ofType;
+    symbolEncodingType_e mlType;
+    BYTE fseTablesBuffer[ZSTD_MAX_FSE_HEADERS_SIZE];
+    size_t fseTablesSize;
+    size_t lastCountSize; /* This is to account for bug in 1.3.4. More detail in ZSTD_entropyCompressSeqStore_internal() */
+} ZSTD_fseCTablesMetadata_t;
+
+typedef struct {
+    ZSTD_hufCTablesMetadata_t hufMetadata;
+    ZSTD_fseCTablesMetadata_t fseMetadata;
+} ZSTD_entropyCTablesMetadata_t;
+
+/** ZSTD_buildBlockEntropyStats() :
+ *  Builds entropy for the block.
+ *  @return : 0 on success or error code */
+size_t ZSTD_buildBlockEntropyStats(
+                    const seqStore_t* seqStorePtr,
+                    const ZSTD_entropyCTables_t* prevEntropy,
+                          ZSTD_entropyCTables_t* nextEntropy,
+                    const ZSTD_CCtx_params* cctxParams,
+                          ZSTD_entropyCTablesMetadata_t* entropyMetadata,
+                          void* workspace, size_t wkspSize);
+
+/*********************************
+*  Compression internals structs *
+*********************************/
+
+typedef struct {
+    U32 off;            /* Offset sumtype code for the match, using ZSTD_storeSeq() format */
+    U32 len;            /* Raw length of match */
+} ZSTD_match_t;
+
+typedef struct {
+    U32 offset;         /* Offset of sequence */
+    U32 litLength;      /* Length of literals prior to match */
+    U32 matchLength;    /* Raw length of match */
+} rawSeq;
+
+typedef struct {
+  rawSeq* seq;          /* The start of the sequences */
+  size_t pos;           /* The index in seq where reading stopped. pos <= size. */
+  size_t posInSequence; /* The position within the sequence at seq[pos] where reading
+                           stopped. posInSequence <= seq[pos].litLength + seq[pos].matchLength */
+  size_t size;          /* The number of sequences. <= capacity. */
+  size_t capacity;      /* The capacity starting from `seq` pointer */
+} rawSeqStore_t;
+
+typedef struct {
+    U32 idx;            /* Index in array of ZSTD_Sequence */
+    U32 posInSequence;  /* Position within sequence at idx */
+    size_t posInSrc;    /* Number of bytes given by sequences provided so far */
+} ZSTD_sequencePosition;
+
+UNUSED_ATTR static const rawSeqStore_t kNullRawSeqStore = {NULL, 0, 0, 0, 0};
+
+typedef struct {
+    int price;
+    U32 off;
+    U32 mlen;
+    U32 litlen;
+    U32 rep[ZSTD_REP_NUM];
+} ZSTD_optimal_t;
+
+typedef enum { zop_dynamic=0, zop_predef } ZSTD_OptPrice_e;
+
+typedef struct {
+    /* All tables are allocated inside cctx->workspace by ZSTD_resetCCtx_internal() */
+    unsigned* litFreq;           /* table of literals statistics, of size 256 */
+    unsigned* litLengthFreq;     /* table of litLength statistics, of size (MaxLL+1) */
+    unsigned* matchLengthFreq;   /* table of matchLength statistics, of size (MaxML+1) */
+    unsigned* offCodeFreq;       /* table of offCode statistics, of size (MaxOff+1) */
+    ZSTD_match_t* matchTable;    /* list of found matches, of size ZSTD_OPT_NUM+1 */
+    ZSTD_optimal_t* priceTable;  /* All positions tracked by optimal parser, of size ZSTD_OPT_NUM+1 */
+
+    U32  litSum;                 /* nb of literals */
+    U32  litLengthSum;           /* nb of litLength codes */
+    U32  matchLengthSum;         /* nb of matchLength codes */
+    U32  offCodeSum;             /* nb of offset codes */
+    U32  litSumBasePrice;        /* to compare to log2(litfreq) */
+    U32  litLengthSumBasePrice;  /* to compare to log2(llfreq)  */
+    U32  matchLengthSumBasePrice;/* to compare to log2(mlfreq)  */
+    U32  offCodeSumBasePrice;    /* to compare to log2(offreq)  */
+    ZSTD_OptPrice_e priceType;   /* prices can be determined dynamically, or follow a pre-defined cost structure */
+    const ZSTD_entropyCTables_t* symbolCosts;  /* pre-calculated dictionary statistics */
+    ZSTD_paramSwitch_e literalCompressionMode;
+} optState_t;
+
+typedef struct {
+  ZSTD_entropyCTables_t entropy;
+  U32 rep[ZSTD_REP_NUM];
+} ZSTD_compressedBlockState_t;
+
+typedef struct {
+    BYTE const* nextSrc;       /* next block here to continue on current prefix */
+    BYTE const* base;          /* All regular indexes relative to this position */
+    BYTE const* dictBase;      /* extDict indexes relative to this position */
+    U32 dictLimit;             /* below that point, need extDict */
+    U32 lowLimit;              /* below that point, no more valid data */
+    U32 nbOverflowCorrections; /* Number of times overflow correction has run since
+                                * ZSTD_window_init(). Useful for debugging coredumps
+                                * and for ZSTD_WINDOW_OVERFLOW_CORRECT_FREQUENTLY.
+                                */
+} ZSTD_window_t;
+
+#define ZSTD_WINDOW_START_INDEX 2
+
+typedef struct ZSTD_matchState_t ZSTD_matchState_t;
+
+#define ZSTD_ROW_HASH_CACHE_SIZE 8       /* Size of prefetching hash cache for row-based matchfinder */
+
+struct ZSTD_matchState_t {
+    ZSTD_window_t window;   /* State for window round buffer management */
+    U32 loadedDictEnd;      /* index of end of dictionary, within context's referential.
+                             * When loadedDictEnd != 0, a dictionary is in use, and still valid.
+                             * This relies on a mechanism to set loadedDictEnd=0 when dictionary is no longer within distance.
+                             * Such mechanism is provided within ZSTD_window_enforceMaxDist() and ZSTD_checkDictValidity().
+                             * When dict referential is copied into active context (i.e. not attached),
+                             * loadedDictEnd == dictSize, since referential starts from zero.
+                             */
+    U32 nextToUpdate;       /* index from which to continue table update */
+    U32 hashLog3;           /* dispatch table for matches of len==3 : larger == faster, more memory */
+
+    U32 rowHashLog;                          /* For row-based matchfinder: Hashlog based on nb of rows in the hashTable.*/
+    BYTE* tagTable;                          /* For row-based matchFinder: A row-based table containing the hashes and head index. */
+    U32 hashCache[ZSTD_ROW_HASH_CACHE_SIZE]; /* For row-based matchFinder: a cache of hashes to improve speed */
+    U64 hashSalt;                            /* For row-based matchFinder: salts the hash for re-use of tag table */
+    U32 hashSaltEntropy;                     /* For row-based matchFinder: collects entropy for salt generation */
+
+    U32* hashTable;
+    U32* hashTable3;
+    U32* chainTable;
+
+    U32 forceNonContiguous; /* Non-zero if we should force non-contiguous load for the next window update. */
+
+    int dedicatedDictSearch;  /* Indicates whether this matchState is using the
+                               * dedicated dictionary search structure.
+                               */
+    optState_t opt;         /* optimal parser state */
+    const ZSTD_matchState_t* dictMatchState;
+    ZSTD_compressionParameters cParams;
+    const rawSeqStore_t* ldmSeqStore;
+
+    /* Controls prefetching in some dictMatchState matchfinders.
+     * This behavior is controlled from the cctx ms.
+     * This parameter has no effect in the cdict ms. */
+    int prefetchCDictTables;
+
+    /* When == 0, lazy match finders insert every position.
+     * When != 0, lazy match finders only insert positions they search.
+     * This allows them to skip much faster over incompressible data,
+     * at a small cost to compression ratio.
+     */
+    int lazySkipping;
+};
+
+typedef struct {
+    ZSTD_compressedBlockState_t* prevCBlock;
+    ZSTD_compressedBlockState_t* nextCBlock;
+    ZSTD_matchState_t matchState;
+} ZSTD_blockState_t;
+
+typedef struct {
+    U32 offset;
+    U32 checksum;
+} ldmEntry_t;
+
+typedef struct {
+    BYTE const* split;
+    U32 hash;
+    U32 checksum;
+    ldmEntry_t* bucket;
+} ldmMatchCandidate_t;
+
+#define LDM_BATCH_SIZE 64
+
+typedef struct {
+    ZSTD_window_t window;   /* State for the window round buffer management */
+    ldmEntry_t* hashTable;
+    U32 loadedDictEnd;
+    BYTE* bucketOffsets;    /* Next position in bucket to insert entry */
+    size_t splitIndices[LDM_BATCH_SIZE];
+    ldmMatchCandidate_t matchCandidates[LDM_BATCH_SIZE];
+} ldmState_t;
+
+typedef struct {
+    ZSTD_paramSwitch_e enableLdm; /* ZSTD_ps_enable to enable LDM. ZSTD_ps_auto by default */
+    U32 hashLog;            /* Log size of hashTable */
+    U32 bucketSizeLog;      /* Log bucket size for collision resolution, at most 8 */
+    U32 minMatchLength;     /* Minimum match length */
+    U32 hashRateLog;       /* Log number of entries to skip */
+    U32 windowLog;          /* Window log for the LDM */
+} ldmParams_t;
+
+typedef struct {
+    int collectSequences;
+    ZSTD_Sequence* seqStart;
+    size_t seqIndex;
+    size_t maxSequences;
+} SeqCollector;
+
+struct ZSTD_CCtx_params_s {
+    ZSTD_format_e format;
+    ZSTD_compressionParameters cParams;
+    ZSTD_frameParameters fParams;
+
+    int compressionLevel;
+    int forceWindow;           /* force back-references to respect limit of
+                                * 1<<wLog, even for dictionary */
+    size_t targetCBlockSize;   /* Tries to fit compressed block size to be around targetCBlockSize.
+                                * No target when targetCBlockSize == 0.
+                                * There is no guarantee on compressed block size */
+    int srcSizeHint;           /* User's best guess of source size.
+                                * Hint is not valid when srcSizeHint == 0.
+                                * There is no guarantee that hint is close to actual source size */
+
+    ZSTD_dictAttachPref_e attachDictPref;
+    ZSTD_paramSwitch_e literalCompressionMode;
+
+    /* Multithreading: used to pass parameters to mtctx */
+    int nbWorkers;
+    size_t jobSize;
+    int overlapLog;
+    int rsyncable;
+
+    /* Long distance matching parameters */
+    ldmParams_t ldmParams;
+
+    /* Dedicated dict search algorithm trigger */
+    int enableDedicatedDictSearch;
+
+    /* Input/output buffer modes */
+    ZSTD_bufferMode_e inBufferMode;
+    ZSTD_bufferMode_e outBufferMode;
+
+    /* Sequence compression API */
+    ZSTD_sequenceFormat_e blockDelimiters;
+    int validateSequences;
+
+    /* Block splitting */
+    ZSTD_paramSwitch_e useBlockSplitter;
+
+    /* Param for deciding whether to use row-based matchfinder */
+    ZSTD_paramSwitch_e useRowMatchFinder;
+
+    /* Always load a dictionary in ext-dict mode (not prefix mode)? */
+    int deterministicRefPrefix;
+
+    /* Internal use, for createCCtxParams() and freeCCtxParams() only */
+    ZSTD_customMem customMem;
+
+    /* Controls prefetching in some dictMatchState matchfinders */
+    ZSTD_paramSwitch_e prefetchCDictTables;
+
+    /* Controls whether zstd will fall back to an internal matchfinder
+     * if the external matchfinder returns an error code. */
+    int enableMatchFinderFallback;
+
+    /* Indicates whether an external matchfinder has been referenced.
+     * Users can't set this externally.
+     * It is set internally in ZSTD_registerSequenceProducer(). */
+    int useSequenceProducer;
+
+    /* Adjust the max block size*/
+    size_t maxBlockSize;
+
+    /* Controls repcode search in external sequence parsing */
+    ZSTD_paramSwitch_e searchForExternalRepcodes;
+};  /* typedef'd to ZSTD_CCtx_params within "zstd.h" */
+
+#define COMPRESS_SEQUENCES_WORKSPACE_SIZE (sizeof(unsigned) * (MaxSeq + 2))
+#define ENTROPY_WORKSPACE_SIZE (HUF_WORKSPACE_SIZE + COMPRESS_SEQUENCES_WORKSPACE_SIZE)
+
+/**
+ * Indicates whether this compression proceeds directly from user-provided
+ * source buffer to user-provided destination buffer (ZSTDb_not_buffered), or
+ * whether the context needs to buffer the input/output (ZSTDb_buffered).
+ */
+typedef enum {
+    ZSTDb_not_buffered,
+    ZSTDb_buffered
+} ZSTD_buffered_policy_e;
+
+/**
+ * Struct that contains all elements of block splitter that should be allocated
+ * in a wksp.
+ */
+#define ZSTD_MAX_NB_BLOCK_SPLITS 196
+typedef struct {
+    seqStore_t fullSeqStoreChunk;
+    seqStore_t firstHalfSeqStore;
+    seqStore_t secondHalfSeqStore;
+    seqStore_t currSeqStore;
+    seqStore_t nextSeqStore;
+
+    U32 partitions[ZSTD_MAX_NB_BLOCK_SPLITS];
+    ZSTD_entropyCTablesMetadata_t entropyMetadata;
+} ZSTD_blockSplitCtx;
+
+/* Context for block-level external matchfinder API */
+typedef struct {
+  void* mState;
+  ZSTD_sequenceProducer_F* mFinder;
+  ZSTD_Sequence* seqBuffer;
+  size_t seqBufferCapacity;
+} ZSTD_externalMatchCtx;
+
+struct ZSTD_CCtx_s {
+    ZSTD_compressionStage_e stage;
+    int cParamsChanged;                  /* == 1 if cParams(except wlog) or compression level are changed in requestedParams. Triggers transmission of new params to ZSTDMT (if available) then reset to 0. */
+    int bmi2;                            /* == 1 if the CPU supports BMI2 and 0 otherwise. CPU support is determined dynamically once per context lifetime. */
+    ZSTD_CCtx_params requestedParams;
+    ZSTD_CCtx_params appliedParams;
+    ZSTD_CCtx_params simpleApiParams;    /* Param storage used by the simple API - not sticky. Must only be used in top-level simple API functions for storage. */
+    U32   dictID;
+    size_t dictContentSize;
+
+    ZSTD_cwksp workspace; /* manages buffer for dynamic allocations */
+    size_t blockSize;
+    unsigned long long pledgedSrcSizePlusOne;  /* this way, 0 (default) == unknown */
+    unsigned long long consumedSrcSize;
+    unsigned long long producedCSize;
+    XXH64_state_t xxhState;
+    ZSTD_customMem customMem;
+    ZSTD_threadPool* pool;
+    size_t staticSize;
+    SeqCollector seqCollector;
+    int isFirstBlock;
+    int initialized;
+
+    seqStore_t seqStore;      /* sequences storage ptrs */
+    ldmState_t ldmState;      /* long distance matching state */
+    rawSeq* ldmSequences;     /* Storage for the ldm output sequences */
+    size_t maxNbLdmSequences;
+    rawSeqStore_t externSeqStore; /* Mutable reference to external sequences */
+    ZSTD_blockState_t blockState;
+    U32* entropyWorkspace;  /* entropy workspace of ENTROPY_WORKSPACE_SIZE bytes */
+
+    /* Whether we are streaming or not */
+    ZSTD_buffered_policy_e bufferedPolicy;
+
+    /* streaming */
+    char*  inBuff;
+    size_t inBuffSize;
+    size_t inToCompress;
+    size_t inBuffPos;
+    size_t inBuffTarget;
+    char*  outBuff;
+    size_t outBuffSize;
+    size_t outBuffContentSize;
+    size_t outBuffFlushedSize;
+    ZSTD_cStreamStage streamStage;
+    U32    frameEnded;
+
+    /* Stable in/out buffer verification */
+    ZSTD_inBuffer expectedInBuffer;
+    size_t stableIn_notConsumed; /* nb bytes within stable input buffer that are said to be consumed but are not */
+    size_t expectedOutBufferSize;
+
+    /* Dictionary */
+    ZSTD_localDict localDict;
+    const ZSTD_CDict* cdict;
+    ZSTD_prefixDict prefixDict;   /* single-usage dictionary */
+
+    /* Multi-threading */
+#ifdef ZSTD_MULTITHREAD
+    ZSTDMT_CCtx* mtctx;
+#endif
+
+    /* Tracing */
+#if ZSTD_TRACE
+    ZSTD_TraceCtx traceCtx;
+#endif
+
+    /* Workspace for block splitter */
+    ZSTD_blockSplitCtx blockSplitCtx;
+
+    /* Workspace for external matchfinder */
+    ZSTD_externalMatchCtx externalMatchCtx;
+};
+
+typedef enum { ZSTD_dtlm_fast, ZSTD_dtlm_full } ZSTD_dictTableLoadMethod_e;
+typedef enum { ZSTD_tfp_forCCtx, ZSTD_tfp_forCDict } ZSTD_tableFillPurpose_e;
+
+typedef enum {
+    ZSTD_noDict = 0,
+    ZSTD_extDict = 1,
+    ZSTD_dictMatchState = 2,
+    ZSTD_dedicatedDictSearch = 3
+} ZSTD_dictMode_e;
+
+typedef enum {
+    ZSTD_cpm_noAttachDict = 0,  /* Compression with ZSTD_noDict or ZSTD_extDict.
+                                 * In this mode we use both the srcSize and the dictSize
+                                 * when selecting and adjusting parameters.
+                                 */
+    ZSTD_cpm_attachDict = 1,    /* Compression with ZSTD_dictMatchState or ZSTD_dedicatedDictSearch.
+                                 * In this mode we only take the srcSize into account when selecting
+                                 * and adjusting parameters.
+                                 */
+    ZSTD_cpm_createCDict = 2,   /* Creating a CDict.
+                                 * In this mode we take both the source size and the dictionary size
+                                 * into account when selecting and adjusting the parameters.
+                                 */
+    ZSTD_cpm_unknown = 3        /* ZSTD_getCParams, ZSTD_getParams, ZSTD_adjustParams.
+                                 * We don't know what these parameters are for. We default to the legacy
+                                 * behavior of taking both the source size and the dict size into account
+                                 * when selecting and adjusting parameters.
+                                 */
+} ZSTD_cParamMode_e;
+
+typedef size_t (*ZSTD_blockCompressor) (
+        ZSTD_matchState_t* bs, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+ZSTD_blockCompressor ZSTD_selectBlockCompressor(ZSTD_strategy strat, ZSTD_paramSwitch_e rowMatchfinderMode, ZSTD_dictMode_e dictMode);
+
+
+MEM_STATIC U32 ZSTD_LLcode(U32 litLength)
+{
+    static const BYTE LL_Code[64] = {  0,  1,  2,  3,  4,  5,  6,  7,
+                                       8,  9, 10, 11, 12, 13, 14, 15,
+                                      16, 16, 17, 17, 18, 18, 19, 19,
+                                      20, 20, 20, 20, 21, 21, 21, 21,
+                                      22, 22, 22, 22, 22, 22, 22, 22,
+                                      23, 23, 23, 23, 23, 23, 23, 23,
+                                      24, 24, 24, 24, 24, 24, 24, 24,
+                                      24, 24, 24, 24, 24, 24, 24, 24 };
+    static const U32 LL_deltaCode = 19;
+    return (litLength > 63) ? ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];
+}
+
+/* ZSTD_MLcode() :
+ * note : mlBase = matchLength - MINMATCH;
+ *        because it's the format it's stored in seqStore->sequences */
+MEM_STATIC U32 ZSTD_MLcode(U32 mlBase)
+{
+    static const BYTE ML_Code[128] = { 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
+                                      16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+                                      32, 32, 33, 33, 34, 34, 35, 35, 36, 36, 36, 36, 37, 37, 37, 37,
+                                      38, 38, 38, 38, 38, 38, 38, 38, 39, 39, 39, 39, 39, 39, 39, 39,
+                                      40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+                                      41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
+                                      42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
+                                      42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42 };
+    static const U32 ML_deltaCode = 36;
+    return (mlBase > 127) ? ZSTD_highbit32(mlBase) + ML_deltaCode : ML_Code[mlBase];
+}
+
+/* ZSTD_cParam_withinBounds:
+ * @return 1 if value is within cParam bounds,
+ * 0 otherwise */
+MEM_STATIC int ZSTD_cParam_withinBounds(ZSTD_cParameter cParam, int value)
+{
+    ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);
+    if (ZSTD_isError(bounds.error)) return 0;
+    if (value < bounds.lowerBound) return 0;
+    if (value > bounds.upperBound) return 0;
+    return 1;
+}
+
+/* ZSTD_noCompressBlock() :
+ * Writes uncompressed block to dst buffer from given src.
+ * Returns the size of the block */
+MEM_STATIC size_t
+ZSTD_noCompressBlock(void* dst, size_t dstCapacity, const void* src, size_t srcSize, U32 lastBlock)
+{
+    U32 const cBlockHeader24 = lastBlock + (((U32)bt_raw)<<1) + (U32)(srcSize << 3);
+    DEBUGLOG(5, "ZSTD_noCompressBlock (srcSize=%zu, dstCapacity=%zu)", srcSize, dstCapacity);
+    RETURN_ERROR_IF(srcSize + ZSTD_blockHeaderSize > dstCapacity,
+                    dstSize_tooSmall, "dst buf too small for uncompressed block");
+    MEM_writeLE24(dst, cBlockHeader24);
+    ZSTD_memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);
+    return ZSTD_blockHeaderSize + srcSize;
+}
+
+MEM_STATIC size_t
+ZSTD_rleCompressBlock(void* dst, size_t dstCapacity, BYTE src, size_t srcSize, U32 lastBlock)
+{
+    BYTE* const op = (BYTE*)dst;
+    U32 const cBlockHeader = lastBlock + (((U32)bt_rle)<<1) + (U32)(srcSize << 3);
+    RETURN_ERROR_IF(dstCapacity < 4, dstSize_tooSmall, "");
+    MEM_writeLE24(op, cBlockHeader);
+    op[3] = src;
+    return 4;
+}
+
+
+/* ZSTD_minGain() :
+ * minimum compression required
+ * to generate a compress block or a compressed literals section.
+ * note : use same formula for both situations */
+MEM_STATIC size_t ZSTD_minGain(size_t srcSize, ZSTD_strategy strat)
+{
+    U32 const minlog = (strat>=ZSTD_btultra) ? (U32)(strat) - 1 : 6;
+    ZSTD_STATIC_ASSERT(ZSTD_btultra == 8);
+    assert(ZSTD_cParam_withinBounds(ZSTD_c_strategy, (int)strat));
+    return (srcSize >> minlog) + 2;
+}
+
+MEM_STATIC int ZSTD_literalsCompressionIsDisabled(const ZSTD_CCtx_params* cctxParams)
+{
+    switch (cctxParams->literalCompressionMode) {
+    case ZSTD_ps_enable:
+        return 0;
+    case ZSTD_ps_disable:
+        return 1;
+    default:
+        assert(0 /* impossible: pre-validated */);
+        ZSTD_FALLTHROUGH;
+    case ZSTD_ps_auto:
+        return (cctxParams->cParams.strategy == ZSTD_fast) && (cctxParams->cParams.targetLength > 0);
+    }
+}
+
+/*! ZSTD_safecopyLiterals() :
+ *  memcpy() function that won't read beyond more than WILDCOPY_OVERLENGTH bytes past ilimit_w.
+ *  Only called when the sequence ends past ilimit_w, so it only needs to be optimized for single
+ *  large copies.
+ */
+static void
+ZSTD_safecopyLiterals(BYTE* op, BYTE const* ip, BYTE const* const iend, BYTE const* ilimit_w)
+{
+    assert(iend > ilimit_w);
+    if (ip <= ilimit_w) {
+        ZSTD_wildcopy(op, ip, ilimit_w - ip, ZSTD_no_overlap);
+        op += ilimit_w - ip;
+        ip = ilimit_w;
+    }
+    while (ip < iend) *op++ = *ip++;
+}
+
+
+#define REPCODE1_TO_OFFBASE REPCODE_TO_OFFBASE(1)
+#define REPCODE2_TO_OFFBASE REPCODE_TO_OFFBASE(2)
+#define REPCODE3_TO_OFFBASE REPCODE_TO_OFFBASE(3)
+#define REPCODE_TO_OFFBASE(r) (assert((r)>=1), assert((r)<=ZSTD_REP_NUM), (r)) /* accepts IDs 1,2,3 */
+#define OFFSET_TO_OFFBASE(o)  (assert((o)>0), o + ZSTD_REP_NUM)
+#define OFFBASE_IS_OFFSET(o)  ((o) > ZSTD_REP_NUM)
+#define OFFBASE_IS_REPCODE(o) ( 1 <= (o) && (o) <= ZSTD_REP_NUM)
+#define OFFBASE_TO_OFFSET(o)  (assert(OFFBASE_IS_OFFSET(o)), (o) - ZSTD_REP_NUM)
+#define OFFBASE_TO_REPCODE(o) (assert(OFFBASE_IS_REPCODE(o)), (o))  /* returns ID 1,2,3 */
+
+/*! ZSTD_storeSeq() :
+ *  Store a sequence (litlen, litPtr, offBase and matchLength) into seqStore_t.
+ *  @offBase : Users should employ macros REPCODE_TO_OFFBASE() and OFFSET_TO_OFFBASE().
+ *  @matchLength : must be >= MINMATCH
+ *  Allowed to over-read literals up to litLimit.
+*/
+HINT_INLINE UNUSED_ATTR void
+ZSTD_storeSeq(seqStore_t* seqStorePtr,
+              size_t litLength, const BYTE* literals, const BYTE* litLimit,
+              U32 offBase,
+              size_t matchLength)
+{
+    BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;
+    BYTE const* const litEnd = literals + litLength;
+#if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)
+    static const BYTE* g_start = NULL;
+    if (g_start==NULL) g_start = (const BYTE*)literals;  /* note : index only works for compression within a single segment */
+    {   U32 const pos = (U32)((const BYTE*)literals - g_start);
+        DEBUGLOG(6, "Cpos%7u :%3u literals, match%4u bytes at offBase%7u",
+               pos, (U32)litLength, (U32)matchLength, (U32)offBase);
+    }
+#endif
+    assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);
+    /* copy Literals */
+    assert(seqStorePtr->maxNbLit <= 128 KB);
+    assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);
+    assert(literals + litLength <= litLimit);
+    if (litEnd <= litLimit_w) {
+        /* Common case we can use wildcopy.
+         * First copy 16 bytes, because literals are likely short.
+         */
+        ZSTD_STATIC_ASSERT(WILDCOPY_OVERLENGTH >= 16);
+        ZSTD_copy16(seqStorePtr->lit, literals);
+        if (litLength > 16) {
+            ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);
+        }
+    } else {
+        ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);
+    }
+    seqStorePtr->lit += litLength;
+
+    /* literal Length */
+    if (litLength>0xFFFF) {
+        assert(seqStorePtr->longLengthType == ZSTD_llt_none); /* there can only be a single long length */
+        seqStorePtr->longLengthType = ZSTD_llt_literalLength;
+        seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);
+    }
+    seqStorePtr->sequences[0].litLength = (U16)litLength;
+
+    /* match offset */
+    seqStorePtr->sequences[0].offBase = offBase;
+
+    /* match Length */
+    assert(matchLength >= MINMATCH);
+    {   size_t const mlBase = matchLength - MINMATCH;
+        if (mlBase>0xFFFF) {
+            assert(seqStorePtr->longLengthType == ZSTD_llt_none); /* there can only be a single long length */
+            seqStorePtr->longLengthType = ZSTD_llt_matchLength;
+            seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);
+        }
+        seqStorePtr->sequences[0].mlBase = (U16)mlBase;
+    }
+
+    seqStorePtr->sequences++;
+}
+
+/* ZSTD_updateRep() :
+ * updates in-place @rep (array of repeat offsets)
+ * @offBase : sum-type, using numeric representation of ZSTD_storeSeq()
+ */
+MEM_STATIC void
+ZSTD_updateRep(U32 rep[ZSTD_REP_NUM], U32 const offBase, U32 const ll0)
+{
+    if (OFFBASE_IS_OFFSET(offBase)) {  /* full offset */
+        rep[2] = rep[1];
+        rep[1] = rep[0];
+        rep[0] = OFFBASE_TO_OFFSET(offBase);
+    } else {   /* repcode */
+        U32 const repCode = OFFBASE_TO_REPCODE(offBase) - 1 + ll0;
+        if (repCode > 0) {  /* note : if repCode==0, no change */
+            U32 const currentOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];
+            rep[2] = (repCode >= 2) ? rep[1] : rep[2];
+            rep[1] = rep[0];
+            rep[0] = currentOffset;
+        } else {   /* repCode == 0 */
+            /* nothing to do */
+        }
+    }
+}
+
+typedef struct repcodes_s {
+    U32 rep[3];
+} repcodes_t;
+
+MEM_STATIC repcodes_t
+ZSTD_newRep(U32 const rep[ZSTD_REP_NUM], U32 const offBase, U32 const ll0)
+{
+    repcodes_t newReps;
+    ZSTD_memcpy(&newReps, rep, sizeof(newReps));
+    ZSTD_updateRep(newReps.rep, offBase, ll0);
+    return newReps;
+}
+
+
+/*-*************************************
+*  Match length counter
+***************************************/
+MEM_STATIC size_t ZSTD_count(const BYTE* pIn, const BYTE* pMatch, const BYTE* const pInLimit)
+{
+    const BYTE* const pStart = pIn;
+    const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);
+
+    if (pIn < pInLoopLimit) {
+        { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);
+          if (diff) return ZSTD_NbCommonBytes(diff); }
+        pIn+=sizeof(size_t); pMatch+=sizeof(size_t);
+        while (pIn < pInLoopLimit) {
+            size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);
+            if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }
+            pIn += ZSTD_NbCommonBytes(diff);
+            return (size_t)(pIn - pStart);
+    }   }
+    if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }
+    if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }
+    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
+    return (size_t)(pIn - pStart);
+}
+
+/** ZSTD_count_2segments() :
+ *  can count match length with `ip` & `match` in 2 different segments.
+ *  convention : on reaching mEnd, match count continue starting from iStart
+ */
+MEM_STATIC size_t
+ZSTD_count_2segments(const BYTE* ip, const BYTE* match,
+                     const BYTE* iEnd, const BYTE* mEnd, const BYTE* iStart)
+{
+    const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);
+    size_t const matchLength = ZSTD_count(ip, match, vEnd);
+    if (match + matchLength != mEnd) return matchLength;
+    DEBUGLOG(7, "ZSTD_count_2segments: found a 2-parts match (current length==%zu)", matchLength);
+    DEBUGLOG(7, "distance from match beginning to end dictionary = %zi", mEnd - match);
+    DEBUGLOG(7, "distance from current pos to end buffer = %zi", iEnd - ip);
+    DEBUGLOG(7, "next byte : ip==%02X, istart==%02X", ip[matchLength], *iStart);
+    DEBUGLOG(7, "final match length = %zu", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));
+    return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);
+}
+
+
+/*-*************************************
+ *  Hashes
+ ***************************************/
+static const U32 prime3bytes = 506832829U;
+static U32    ZSTD_hash3(U32 u, U32 h, U32 s) { assert(h <= 32); return (((u << (32-24)) * prime3bytes) ^ s)  >> (32-h) ; }
+MEM_STATIC size_t ZSTD_hash3Ptr(const void* ptr, U32 h) { return ZSTD_hash3(MEM_readLE32(ptr), h, 0); } /* only in zstd_opt.h */
+MEM_STATIC size_t ZSTD_hash3PtrS(const void* ptr, U32 h, U32 s) { return ZSTD_hash3(MEM_readLE32(ptr), h, s); }
+
+static const U32 prime4bytes = 2654435761U;
+static U32    ZSTD_hash4(U32 u, U32 h, U32 s) { assert(h <= 32); return ((u * prime4bytes) ^ s) >> (32-h) ; }
+static size_t ZSTD_hash4Ptr(const void* ptr, U32 h) { return ZSTD_hash4(MEM_readLE32(ptr), h, 0); }
+static size_t ZSTD_hash4PtrS(const void* ptr, U32 h, U32 s) { return ZSTD_hash4(MEM_readLE32(ptr), h, s); }
+
+static const U64 prime5bytes = 889523592379ULL;
+static size_t ZSTD_hash5(U64 u, U32 h, U64 s) { assert(h <= 64); return (size_t)((((u  << (64-40)) * prime5bytes) ^ s) >> (64-h)) ; }
+static size_t ZSTD_hash5Ptr(const void* p, U32 h) { return ZSTD_hash5(MEM_readLE64(p), h, 0); }
+static size_t ZSTD_hash5PtrS(const void* p, U32 h, U64 s) { return ZSTD_hash5(MEM_readLE64(p), h, s); }
+
+static const U64 prime6bytes = 227718039650203ULL;
+static size_t ZSTD_hash6(U64 u, U32 h, U64 s) { assert(h <= 64); return (size_t)((((u  << (64-48)) * prime6bytes) ^ s) >> (64-h)) ; }
+static size_t ZSTD_hash6Ptr(const void* p, U32 h) { return ZSTD_hash6(MEM_readLE64(p), h, 0); }
+static size_t ZSTD_hash6PtrS(const void* p, U32 h, U64 s) { return ZSTD_hash6(MEM_readLE64(p), h, s); }
+
+static const U64 prime7bytes = 58295818150454627ULL;
+static size_t ZSTD_hash7(U64 u, U32 h, U64 s) { assert(h <= 64); return (size_t)((((u  << (64-56)) * prime7bytes) ^ s) >> (64-h)) ; }
+static size_t ZSTD_hash7Ptr(const void* p, U32 h) { return ZSTD_hash7(MEM_readLE64(p), h, 0); }
+static size_t ZSTD_hash7PtrS(const void* p, U32 h, U64 s) { return ZSTD_hash7(MEM_readLE64(p), h, s); }
+
+static const U64 prime8bytes = 0xCF1BBCDCB7A56463ULL;
+static size_t ZSTD_hash8(U64 u, U32 h, U64 s) { assert(h <= 64); return (size_t)((((u) * prime8bytes)  ^ s) >> (64-h)) ; }
+static size_t ZSTD_hash8Ptr(const void* p, U32 h) { return ZSTD_hash8(MEM_readLE64(p), h, 0); }
+static size_t ZSTD_hash8PtrS(const void* p, U32 h, U64 s) { return ZSTD_hash8(MEM_readLE64(p), h, s); }
+
+
+MEM_STATIC FORCE_INLINE_ATTR
+size_t ZSTD_hashPtr(const void* p, U32 hBits, U32 mls)
+{
+    /* Although some of these hashes do support hBits up to 64, some do not.
+     * To be on the safe side, always avoid hBits > 32. */
+    assert(hBits <= 32);
+
+    switch(mls)
+    {
+    default:
+    case 4: return ZSTD_hash4Ptr(p, hBits);
+    case 5: return ZSTD_hash5Ptr(p, hBits);
+    case 6: return ZSTD_hash6Ptr(p, hBits);
+    case 7: return ZSTD_hash7Ptr(p, hBits);
+    case 8: return ZSTD_hash8Ptr(p, hBits);
+    }
+}
+
+MEM_STATIC FORCE_INLINE_ATTR
+size_t ZSTD_hashPtrSalted(const void* p, U32 hBits, U32 mls, const U64 hashSalt) {
+    /* Although some of these hashes do support hBits up to 64, some do not.
+     * To be on the safe side, always avoid hBits > 32. */
+    assert(hBits <= 32);
+
+    switch(mls)
+    {
+        default:
+        case 4: return ZSTD_hash4PtrS(p, hBits, (U32)hashSalt);
+        case 5: return ZSTD_hash5PtrS(p, hBits, hashSalt);
+        case 6: return ZSTD_hash6PtrS(p, hBits, hashSalt);
+        case 7: return ZSTD_hash7PtrS(p, hBits, hashSalt);
+        case 8: return ZSTD_hash8PtrS(p, hBits, hashSalt);
+    }
+}
+
+
+/** ZSTD_ipow() :
+ * Return base^exponent.
+ */
+static U64 ZSTD_ipow(U64 base, U64 exponent)
+{
+    U64 power = 1;
+    while (exponent) {
+      if (exponent & 1) power *= base;
+      exponent >>= 1;
+      base *= base;
+    }
+    return power;
+}
+
+#define ZSTD_ROLL_HASH_CHAR_OFFSET 10
+
+/** ZSTD_rollingHash_append() :
+ * Add the buffer to the hash value.
+ */
+static U64 ZSTD_rollingHash_append(U64 hash, void const* buf, size_t size)
+{
+    BYTE const* istart = (BYTE const*)buf;
+    size_t pos;
+    for (pos = 0; pos < size; ++pos) {
+        hash *= prime8bytes;
+        hash += istart[pos] + ZSTD_ROLL_HASH_CHAR_OFFSET;
+    }
+    return hash;
+}
+
+/** ZSTD_rollingHash_compute() :
+ * Compute the rolling hash value of the buffer.
+ */
+MEM_STATIC U64 ZSTD_rollingHash_compute(void const* buf, size_t size)
+{
+    return ZSTD_rollingHash_append(0, buf, size);
+}
+
+/** ZSTD_rollingHash_primePower() :
+ * Compute the primePower to be passed to ZSTD_rollingHash_rotate() for a hash
+ * over a window of length bytes.
+ */
+MEM_STATIC U64 ZSTD_rollingHash_primePower(U32 length)
+{
+    return ZSTD_ipow(prime8bytes, length - 1);
+}
+
+/** ZSTD_rollingHash_rotate() :
+ * Rotate the rolling hash by one byte.
+ */
+MEM_STATIC U64 ZSTD_rollingHash_rotate(U64 hash, BYTE toRemove, BYTE toAdd, U64 primePower)
+{
+    hash -= (toRemove + ZSTD_ROLL_HASH_CHAR_OFFSET) * primePower;
+    hash *= prime8bytes;
+    hash += toAdd + ZSTD_ROLL_HASH_CHAR_OFFSET;
+    return hash;
+}
+
+/*-*************************************
+*  Round buffer management
+***************************************/
+#if (ZSTD_WINDOWLOG_MAX_64 > 31)
+# error "ZSTD_WINDOWLOG_MAX is too large : would overflow ZSTD_CURRENT_MAX"
+#endif
+/* Max current allowed */
+#define ZSTD_CURRENT_MAX ((3U << 29) + (1U << ZSTD_WINDOWLOG_MAX))
+/* Maximum chunk size before overflow correction needs to be called again */
+#define ZSTD_CHUNKSIZE_MAX                                                     \
+    ( ((U32)-1)                  /* Maximum ending current index */            \
+    - ZSTD_CURRENT_MAX)          /* Maximum beginning lowLimit */
+
+/**
+ * ZSTD_window_clear():
+ * Clears the window containing the history by simply setting it to empty.
+ */
+MEM_STATIC void ZSTD_window_clear(ZSTD_window_t* window)
+{
+    size_t const endT = (size_t)(window->nextSrc - window->base);
+    U32 const end = (U32)endT;
+
+    window->lowLimit = end;
+    window->dictLimit = end;
+}
+
+MEM_STATIC U32 ZSTD_window_isEmpty(ZSTD_window_t const window)
+{
+    return window.dictLimit == ZSTD_WINDOW_START_INDEX &&
+           window.lowLimit == ZSTD_WINDOW_START_INDEX &&
+           (window.nextSrc - window.base) == ZSTD_WINDOW_START_INDEX;
+}
+
+/**
+ * ZSTD_window_hasExtDict():
+ * Returns non-zero if the window has a non-empty extDict.
+ */
+MEM_STATIC U32 ZSTD_window_hasExtDict(ZSTD_window_t const window)
+{
+    return window.lowLimit < window.dictLimit;
+}
+
+/**
+ * ZSTD_matchState_dictMode():
+ * Inspects the provided matchState and figures out what dictMode should be
+ * passed to the compressor.
+ */
+MEM_STATIC ZSTD_dictMode_e ZSTD_matchState_dictMode(const ZSTD_matchState_t *ms)
+{
+    return ZSTD_window_hasExtDict(ms->window) ?
+        ZSTD_extDict :
+        ms->dictMatchState != NULL ?
+            (ms->dictMatchState->dedicatedDictSearch ? ZSTD_dedicatedDictSearch : ZSTD_dictMatchState) :
+            ZSTD_noDict;
+}
+
+/* Defining this macro to non-zero tells zstd to run the overflow correction
+ * code much more frequently. This is very inefficient, and should only be
+ * used for tests and fuzzers.
+ */
+#ifndef ZSTD_WINDOW_OVERFLOW_CORRECT_FREQUENTLY
+#  ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+#    define ZSTD_WINDOW_OVERFLOW_CORRECT_FREQUENTLY 1
+#  else
+#    define ZSTD_WINDOW_OVERFLOW_CORRECT_FREQUENTLY 0
+#  endif
+#endif
+
+/**
+ * ZSTD_window_canOverflowCorrect():
+ * Returns non-zero if the indices are large enough for overflow correction
+ * to work correctly without impacting compression ratio.
+ */
+MEM_STATIC U32 ZSTD_window_canOverflowCorrect(ZSTD_window_t const window,
+                                              U32 cycleLog,
+                                              U32 maxDist,
+                                              U32 loadedDictEnd,
+                                              void const* src)
+{
+    U32 const cycleSize = 1u << cycleLog;
+    U32 const curr = (U32)((BYTE const*)src - window.base);
+    U32 const minIndexToOverflowCorrect = cycleSize
+                                        + MAX(maxDist, cycleSize)
+                                        + ZSTD_WINDOW_START_INDEX;
+
+    /* Adjust the min index to backoff the overflow correction frequency,
+     * so we don't waste too much CPU in overflow correction. If this
+     * computation overflows we don't really care, we just need to make
+     * sure it is at least minIndexToOverflowCorrect.
+     */
+    U32 const adjustment = window.nbOverflowCorrections + 1;
+    U32 const adjustedIndex = MAX(minIndexToOverflowCorrect * adjustment,
+                                  minIndexToOverflowCorrect);
+    U32 const indexLargeEnough = curr > adjustedIndex;
+
+    /* Only overflow correct early if the dictionary is invalidated already,
+     * so we don't hurt compression ratio.
+     */
+    U32 const dictionaryInvalidated = curr > maxDist + loadedDictEnd;
+
+    return indexLargeEnough && dictionaryInvalidated;
+}
+
+/**
+ * ZSTD_window_needOverflowCorrection():
+ * Returns non-zero if the indices are getting too large and need overflow
+ * protection.
+ */
+MEM_STATIC U32 ZSTD_window_needOverflowCorrection(ZSTD_window_t const window,
+                                                  U32 cycleLog,
+                                                  U32 maxDist,
+                                                  U32 loadedDictEnd,
+                                                  void const* src,
+                                                  void const* srcEnd)
+{
+    U32 const curr = (U32)((BYTE const*)srcEnd - window.base);
+    if (ZSTD_WINDOW_OVERFLOW_CORRECT_FREQUENTLY) {
+        if (ZSTD_window_canOverflowCorrect(window, cycleLog, maxDist, loadedDictEnd, src)) {
+            return 1;
+        }
+    }
+    return curr > ZSTD_CURRENT_MAX;
+}
+
+/**
+ * ZSTD_window_correctOverflow():
+ * Reduces the indices to protect from index overflow.
+ * Returns the correction made to the indices, which must be applied to every
+ * stored index.
+ *
+ * The least significant cycleLog bits of the indices must remain the same,
+ * which may be 0. Every index up to maxDist in the past must be valid.
+ */
+MEM_STATIC U32 ZSTD_window_correctOverflow(ZSTD_window_t* window, U32 cycleLog,
+                                           U32 maxDist, void const* src)
+{
+    /* preemptive overflow correction:
+     * 1. correction is large enough:
+     *    lowLimit > (3<<29) ==> current > 3<<29 + 1<<windowLog
+     *    1<<windowLog <= newCurrent < 1<<chainLog + 1<<windowLog
+     *
+     *    current - newCurrent
+     *    > (3<<29 + 1<<windowLog) - (1<<windowLog + 1<<chainLog)
+     *    > (3<<29) - (1<<chainLog)
+     *    > (3<<29) - (1<<30)             (NOTE: chainLog <= 30)
+     *    > 1<<29
+     *
+     * 2. (ip+ZSTD_CHUNKSIZE_MAX - cctx->base) doesn't overflow:
+     *    After correction, current is less than (1<<chainLog + 1<<windowLog).
+     *    In 64-bit mode we are safe, because we have 64-bit ptrdiff_t.
+     *    In 32-bit mode we are safe, because (chainLog <= 29), so
+     *    ip+ZSTD_CHUNKSIZE_MAX - cctx->base < 1<<32.
+     * 3. (cctx->lowLimit + 1<<windowLog) < 1<<32:
+     *    windowLog <= 31 ==> 3<<29 + 1<<windowLog < 7<<29 < 1<<32.
+     */
+    U32 const cycleSize = 1u << cycleLog;
+    U32 const cycleMask = cycleSize - 1;
+    U32 const curr = (U32)((BYTE const*)src - window->base);
+    U32 const currentCycle = curr & cycleMask;
+    /* Ensure newCurrent - maxDist >= ZSTD_WINDOW_START_INDEX. */
+    U32 const currentCycleCorrection = currentCycle < ZSTD_WINDOW_START_INDEX
+                                     ? MAX(cycleSize, ZSTD_WINDOW_START_INDEX)
+                                     : 0;
+    U32 const newCurrent = currentCycle
+                         + currentCycleCorrection
+                         + MAX(maxDist, cycleSize);
+    U32 const correction = curr - newCurrent;
+    /* maxDist must be a power of two so that:
+     *   (newCurrent & cycleMask) == (curr & cycleMask)
+     * This is required to not corrupt the chains / binary tree.
+     */
+    assert((maxDist & (maxDist - 1)) == 0);
+    assert((curr & cycleMask) == (newCurrent & cycleMask));
+    assert(curr > newCurrent);
+    if (!ZSTD_WINDOW_OVERFLOW_CORRECT_FREQUENTLY) {
+        /* Loose bound, should be around 1<<29 (see above) */
+        assert(correction > 1<<28);
+    }
+
+    window->base += correction;
+    window->dictBase += correction;
+    if (window->lowLimit < correction + ZSTD_WINDOW_START_INDEX) {
+        window->lowLimit = ZSTD_WINDOW_START_INDEX;
+    } else {
+        window->lowLimit -= correction;
+    }
+    if (window->dictLimit < correction + ZSTD_WINDOW_START_INDEX) {
+        window->dictLimit = ZSTD_WINDOW_START_INDEX;
+    } else {
+        window->dictLimit -= correction;
+    }
+
+    /* Ensure we can still reference the full window. */
+    assert(newCurrent >= maxDist);
+    assert(newCurrent - maxDist >= ZSTD_WINDOW_START_INDEX);
+    /* Ensure that lowLimit and dictLimit didn't underflow. */
+    assert(window->lowLimit <= newCurrent);
+    assert(window->dictLimit <= newCurrent);
+
+    ++window->nbOverflowCorrections;
+
+    DEBUGLOG(4, "Correction of 0x%x bytes to lowLimit=0x%x", correction,
+             window->lowLimit);
+    return correction;
+}
+
+/**
+ * ZSTD_window_enforceMaxDist():
+ * Updates lowLimit so that:
+ *    (srcEnd - base) - lowLimit == maxDist + loadedDictEnd
+ *
+ * It ensures index is valid as long as index >= lowLimit.
+ * This must be called before a block compression call.
+ *
+ * loadedDictEnd is only defined if a dictionary is in use for current compression.
+ * As the name implies, loadedDictEnd represents the index at end of dictionary.
+ * The value lies within context's referential, it can be directly compared to blockEndIdx.
+ *
+ * If loadedDictEndPtr is NULL, no dictionary is in use, and we use loadedDictEnd == 0.
+ * If loadedDictEndPtr is not NULL, we set it to zero after updating lowLimit.
+ * This is because dictionaries are allowed to be referenced fully
+ * as long as the last byte of the dictionary is in the window.
+ * Once input has progressed beyond window size, dictionary cannot be referenced anymore.
+ *
+ * In normal dict mode, the dictionary lies between lowLimit and dictLimit.
+ * In dictMatchState mode, lowLimit and dictLimit are the same,
+ * and the dictionary is below them.
+ * forceWindow and dictMatchState are therefore incompatible.
+ */
+MEM_STATIC void
+ZSTD_window_enforceMaxDist(ZSTD_window_t* window,
+                     const void* blockEnd,
+                           U32   maxDist,
+                           U32*  loadedDictEndPtr,
+                     const ZSTD_matchState_t** dictMatchStatePtr)
+{
+    U32 const blockEndIdx = (U32)((BYTE const*)blockEnd - window->base);
+    U32 const loadedDictEnd = (loadedDictEndPtr != NULL) ? *loadedDictEndPtr : 0;
+    DEBUGLOG(5, "ZSTD_window_enforceMaxDist: blockEndIdx=%u, maxDist=%u, loadedDictEnd=%u",
+                (unsigned)blockEndIdx, (unsigned)maxDist, (unsigned)loadedDictEnd);
+
+    /* - When there is no dictionary : loadedDictEnd == 0.
+         In which case, the test (blockEndIdx > maxDist) is merely to avoid
+         overflowing next operation `newLowLimit = blockEndIdx - maxDist`.
+       - When there is a standard dictionary :
+         Index referential is copied from the dictionary,
+         which means it starts from 0.
+         In which case, loadedDictEnd == dictSize,
+         and it makes sense to compare `blockEndIdx > maxDist + dictSize`
+         since `blockEndIdx` also starts from zero.
+       - When there is an attached dictionary :
+         loadedDictEnd is expressed within the referential of the context,
+         so it can be directly compared against blockEndIdx.
+    */
+    if (blockEndIdx > maxDist + loadedDictEnd) {
+        U32 const newLowLimit = blockEndIdx - maxDist;
+        if (window->lowLimit < newLowLimit) window->lowLimit = newLowLimit;
+        if (window->dictLimit < window->lowLimit) {
+            DEBUGLOG(5, "Update dictLimit to match lowLimit, from %u to %u",
+                        (unsigned)window->dictLimit, (unsigned)window->lowLimit);
+            window->dictLimit = window->lowLimit;
+        }
+        /* On reaching window size, dictionaries are invalidated */
+        if (loadedDictEndPtr) *loadedDictEndPtr = 0;
+        if (dictMatchStatePtr) *dictMatchStatePtr = NULL;
+    }
+}
+
+/* Similar to ZSTD_window_enforceMaxDist(),
+ * but only invalidates dictionary
+ * when input progresses beyond window size.
+ * assumption : loadedDictEndPtr and dictMatchStatePtr are valid (non NULL)
+ *              loadedDictEnd uses same referential as window->base
+ *              maxDist is the window size */
+MEM_STATIC void
+ZSTD_checkDictValidity(const ZSTD_window_t* window,
+                       const void* blockEnd,
+                             U32   maxDist,
+                             U32*  loadedDictEndPtr,
+                       const ZSTD_matchState_t** dictMatchStatePtr)
+{
+    assert(loadedDictEndPtr != NULL);
+    assert(dictMatchStatePtr != NULL);
+    {   U32 const blockEndIdx = (U32)((BYTE const*)blockEnd - window->base);
+        U32 const loadedDictEnd = *loadedDictEndPtr;
+        DEBUGLOG(5, "ZSTD_checkDictValidity: blockEndIdx=%u, maxDist=%u, loadedDictEnd=%u",
+                    (unsigned)blockEndIdx, (unsigned)maxDist, (unsigned)loadedDictEnd);
+        assert(blockEndIdx >= loadedDictEnd);
+
+        if (blockEndIdx > loadedDictEnd + maxDist || loadedDictEnd != window->dictLimit) {
+            /* On reaching window size, dictionaries are invalidated.
+             * For simplification, if window size is reached anywhere within next block,
+             * the dictionary is invalidated for the full block.
+             *
+             * We also have to invalidate the dictionary if ZSTD_window_update() has detected
+             * non-contiguous segments, which means that loadedDictEnd != window->dictLimit.
+             * loadedDictEnd may be 0, if forceWindow is true, but in that case we never use
+             * dictMatchState, so setting it to NULL is not a problem.
+             */
+            DEBUGLOG(6, "invalidating dictionary for current block (distance > windowSize)");
+            *loadedDictEndPtr = 0;
+            *dictMatchStatePtr = NULL;
+        } else {
+            if (*loadedDictEndPtr != 0) {
+                DEBUGLOG(6, "dictionary considered valid for current block");
+    }   }   }
+}
+
+MEM_STATIC void ZSTD_window_init(ZSTD_window_t* window) {
+    ZSTD_memset(window, 0, sizeof(*window));
+    window->base = (BYTE const*)" ";
+    window->dictBase = (BYTE const*)" ";
+    ZSTD_STATIC_ASSERT(ZSTD_DUBT_UNSORTED_MARK < ZSTD_WINDOW_START_INDEX); /* Start above ZSTD_DUBT_UNSORTED_MARK */
+    window->dictLimit = ZSTD_WINDOW_START_INDEX;    /* start from >0, so that 1st position is valid */
+    window->lowLimit = ZSTD_WINDOW_START_INDEX;     /* it ensures first and later CCtx usages compress the same */
+    window->nextSrc = window->base + ZSTD_WINDOW_START_INDEX;   /* see issue #1241 */
+    window->nbOverflowCorrections = 0;
+}
+
+/**
+ * ZSTD_window_update():
+ * Updates the window by appending [src, src + srcSize) to the window.
+ * If it is not contiguous, the current prefix becomes the extDict, and we
+ * forget about the extDict. Handles overlap of the prefix and extDict.
+ * Returns non-zero if the segment is contiguous.
+ */
+MEM_STATIC U32 ZSTD_window_update(ZSTD_window_t* window,
+                                  void const* src, size_t srcSize,
+                                  int forceNonContiguous)
+{
+    BYTE const* const ip = (BYTE const*)src;
+    U32 contiguous = 1;
+    DEBUGLOG(5, "ZSTD_window_update");
+    if (srcSize == 0)
+        return contiguous;
+    assert(window->base != NULL);
+    assert(window->dictBase != NULL);
+    /* Check if blocks follow each other */
+    if (src != window->nextSrc || forceNonContiguous) {
+        /* not contiguous */
+        size_t const distanceFromBase = (size_t)(window->nextSrc - window->base);
+        DEBUGLOG(5, "Non contiguous blocks, new segment starts at %u", window->dictLimit);
+        window->lowLimit = window->dictLimit;
+        assert(distanceFromBase == (size_t)(U32)distanceFromBase);  /* should never overflow */
+        window->dictLimit = (U32)distanceFromBase;
+        window->dictBase = window->base;
+        window->base = ip - distanceFromBase;
+        /* ms->nextToUpdate = window->dictLimit; */
+        if (window->dictLimit - window->lowLimit < HASH_READ_SIZE) window->lowLimit = window->dictLimit;   /* too small extDict */
+        contiguous = 0;
+    }
+    window->nextSrc = ip + srcSize;
+    /* if input and dictionary overlap : reduce dictionary (area presumed modified by input) */
+    if ( (ip+srcSize > window->dictBase + window->lowLimit)
+       & (ip < window->dictBase + window->dictLimit)) {
+        ptrdiff_t const highInputIdx = (ip + srcSize) - window->dictBase;
+        U32 const lowLimitMax = (highInputIdx > (ptrdiff_t)window->dictLimit) ? window->dictLimit : (U32)highInputIdx;
+        window->lowLimit = lowLimitMax;
+        DEBUGLOG(5, "Overlapping extDict and input : new lowLimit = %u", window->lowLimit);
+    }
+    return contiguous;
+}
+
+/**
+ * Returns the lowest allowed match index. It may either be in the ext-dict or the prefix.
+ */
+MEM_STATIC U32 ZSTD_getLowestMatchIndex(const ZSTD_matchState_t* ms, U32 curr, unsigned windowLog)
+{
+    U32 const maxDistance = 1U << windowLog;
+    U32 const lowestValid = ms->window.lowLimit;
+    U32 const withinWindow = (curr - lowestValid > maxDistance) ? curr - maxDistance : lowestValid;
+    U32 const isDictionary = (ms->loadedDictEnd != 0);
+    /* When using a dictionary the entire dictionary is valid if a single byte of the dictionary
+     * is within the window. We invalidate the dictionary (and set loadedDictEnd to 0) when it isn't
+     * valid for the entire block. So this check is sufficient to find the lowest valid match index.
+     */
+    U32 const matchLowest = isDictionary ? lowestValid : withinWindow;
+    return matchLowest;
+}
+
+/**
+ * Returns the lowest allowed match index in the prefix.
+ */
+MEM_STATIC U32 ZSTD_getLowestPrefixIndex(const ZSTD_matchState_t* ms, U32 curr, unsigned windowLog)
+{
+    U32    const maxDistance = 1U << windowLog;
+    U32    const lowestValid = ms->window.dictLimit;
+    U32    const withinWindow = (curr - lowestValid > maxDistance) ? curr - maxDistance : lowestValid;
+    U32    const isDictionary = (ms->loadedDictEnd != 0);
+    /* When computing the lowest prefix index we need to take the dictionary into account to handle
+     * the edge case where the dictionary and the source are contiguous in memory.
+     */
+    U32    const matchLowest = isDictionary ? lowestValid : withinWindow;
+    return matchLowest;
+}
+
+
+
+/* debug functions */
+#if (DEBUGLEVEL>=2)
+
+MEM_STATIC double ZSTD_fWeight(U32 rawStat)
+{
+    U32 const fp_accuracy = 8;
+    U32 const fp_multiplier = (1 << fp_accuracy);
+    U32 const newStat = rawStat + 1;
+    U32 const hb = ZSTD_highbit32(newStat);
+    U32 const BWeight = hb * fp_multiplier;
+    U32 const FWeight = (newStat << fp_accuracy) >> hb;
+    U32 const weight = BWeight + FWeight;
+    assert(hb + fp_accuracy < 31);
+    return (double)weight / fp_multiplier;
+}
+
+/* display a table content,
+ * listing each element, its frequency, and its predicted bit cost */
+MEM_STATIC void ZSTD_debugTable(const U32* table, U32 max)
+{
+    unsigned u, sum;
+    for (u=0, sum=0; u<=max; u++) sum += table[u];
+    DEBUGLOG(2, "total nb elts: %u", sum);
+    for (u=0; u<=max; u++) {
+        DEBUGLOG(2, "%2u: %5u  (%.2f)",
+                u, table[u], ZSTD_fWeight(sum) - ZSTD_fWeight(table[u]) );
+    }
+}
+
+#endif
+
+/* Short Cache */
+
+/* Normally, zstd matchfinders follow this flow:
+ *     1. Compute hash at ip
+ *     2. Load index from hashTable[hash]
+ *     3. Check if *ip == *(base + index)
+ * In dictionary compression, loading *(base + index) is often an L2 or even L3 miss.
+ *
+ * Short cache is an optimization which allows us to avoid step 3 most of the time
+ * when the data doesn't actually match. With short cache, the flow becomes:
+ *     1. Compute (hash, currentTag) at ip. currentTag is an 8-bit independent hash at ip.
+ *     2. Load (index, matchTag) from hashTable[hash]. See ZSTD_writeTaggedIndex to understand how this works.
+ *     3. Only if currentTag == matchTag, check *ip == *(base + index). Otherwise, continue.
+ *
+ * Currently, short cache is only implemented in CDict hashtables. Thus, its use is limited to
+ * dictMatchState matchfinders.
+ */
+#define ZSTD_SHORT_CACHE_TAG_BITS 8
+#define ZSTD_SHORT_CACHE_TAG_MASK ((1u << ZSTD_SHORT_CACHE_TAG_BITS) - 1)
+
+/* Helper function for ZSTD_fillHashTable and ZSTD_fillDoubleHashTable.
+ * Unpacks hashAndTag into (hash, tag), then packs (index, tag) into hashTable[hash]. */
+MEM_STATIC void ZSTD_writeTaggedIndex(U32* const hashTable, size_t hashAndTag, U32 index) {
+    size_t const hash = hashAndTag >> ZSTD_SHORT_CACHE_TAG_BITS;
+    U32 const tag = (U32)(hashAndTag & ZSTD_SHORT_CACHE_TAG_MASK);
+    assert(index >> (32 - ZSTD_SHORT_CACHE_TAG_BITS) == 0);
+    hashTable[hash] = (index << ZSTD_SHORT_CACHE_TAG_BITS) | tag;
+}
+
+/* Helper function for short cache matchfinders.
+ * Unpacks tag1 and tag2 from lower bits of packedTag1 and packedTag2, then checks if the tags match. */
+MEM_STATIC int ZSTD_comparePackedTags(size_t packedTag1, size_t packedTag2) {
+    U32 const tag1 = packedTag1 & ZSTD_SHORT_CACHE_TAG_MASK;
+    U32 const tag2 = packedTag2 & ZSTD_SHORT_CACHE_TAG_MASK;
+    return tag1 == tag2;
+}
+
+#if defined (__cplusplus)
+}
+#endif
+
+/* ===============================================================
+ * Shared internal declarations
+ * These prototypes may be called from sources not in lib/compress
+ * =============================================================== */
+
+/* ZSTD_loadCEntropy() :
+ * dict : must point at beginning of a valid zstd dictionary.
+ * return : size of dictionary header (size of magic number + dict ID + entropy tables)
+ * assumptions : magic number supposed already checked
+ *               and dictSize >= 8 */
+size_t ZSTD_loadCEntropy(ZSTD_compressedBlockState_t* bs, void* workspace,
+                         const void* const dict, size_t dictSize);
+
+void ZSTD_reset_compressedBlockState(ZSTD_compressedBlockState_t* bs);
+
+/* ==============================================================
+ * Private declarations
+ * These prototypes shall only be called from within lib/compress
+ * ============================================================== */
+
+/* ZSTD_getCParamsFromCCtxParams() :
+ * cParams are built depending on compressionLevel, src size hints,
+ * LDM and manually set compression parameters.
+ * Note: srcSizeHint == 0 means 0!
+ */
+ZSTD_compressionParameters ZSTD_getCParamsFromCCtxParams(
+        const ZSTD_CCtx_params* CCtxParams, U64 srcSizeHint, size_t dictSize, ZSTD_cParamMode_e mode);
+
+/*! ZSTD_initCStream_internal() :
+ *  Private use only. Init streaming operation.
+ *  expects params to be valid.
+ *  must receive dict, or cdict, or none, but not both.
+ *  @return : 0, or an error code */
+size_t ZSTD_initCStream_internal(ZSTD_CStream* zcs,
+                     const void* dict, size_t dictSize,
+                     const ZSTD_CDict* cdict,
+                     const ZSTD_CCtx_params* params, unsigned long long pledgedSrcSize);
+
+void ZSTD_resetSeqStore(seqStore_t* ssPtr);
+
+/*! ZSTD_getCParamsFromCDict() :
+ *  as the name implies */
+ZSTD_compressionParameters ZSTD_getCParamsFromCDict(const ZSTD_CDict* cdict);
+
+/* ZSTD_compressBegin_advanced_internal() :
+ * Private use only. To be called from zstdmt_compress.c. */
+size_t ZSTD_compressBegin_advanced_internal(ZSTD_CCtx* cctx,
+                                    const void* dict, size_t dictSize,
+                                    ZSTD_dictContentType_e dictContentType,
+                                    ZSTD_dictTableLoadMethod_e dtlm,
+                                    const ZSTD_CDict* cdict,
+                                    const ZSTD_CCtx_params* params,
+                                    unsigned long long pledgedSrcSize);
+
+/* ZSTD_compress_advanced_internal() :
+ * Private use only. To be called from zstdmt_compress.c. */
+size_t ZSTD_compress_advanced_internal(ZSTD_CCtx* cctx,
+                                       void* dst, size_t dstCapacity,
+                                 const void* src, size_t srcSize,
+                                 const void* dict,size_t dictSize,
+                                 const ZSTD_CCtx_params* params);
+
+
+/* ZSTD_writeLastEmptyBlock() :
+ * output an empty Block with end-of-frame mark to complete a frame
+ * @return : size of data written into `dst` (== ZSTD_blockHeaderSize (defined in zstd_internal.h))
+ *           or an error code if `dstCapacity` is too small (<ZSTD_blockHeaderSize)
+ */
+size_t ZSTD_writeLastEmptyBlock(void* dst, size_t dstCapacity);
+
+
+/* ZSTD_referenceExternalSequences() :
+ * Must be called before starting a compression operation.
+ * seqs must parse a prefix of the source.
+ * This cannot be used when long range matching is enabled.
+ * Zstd will use these sequences, and pass the literals to a secondary block
+ * compressor.
+ * @return : An error code on failure.
+ * NOTE: seqs are not verified! Invalid sequences can cause out-of-bounds memory
+ * access and data corruption.
+ */
+size_t ZSTD_referenceExternalSequences(ZSTD_CCtx* cctx, rawSeq* seq, size_t nbSeq);
+
+/** ZSTD_cycleLog() :
+ *  condition for correct operation : hashLog > 1 */
+U32 ZSTD_cycleLog(U32 hashLog, ZSTD_strategy strat);
+
+/** ZSTD_CCtx_trace() :
+ *  Trace the end of a compression call.
+ */
+void ZSTD_CCtx_trace(ZSTD_CCtx* cctx, size_t extraCSize);
+
+/* Returns 0 on success, and a ZSTD_error otherwise. This function scans through an array of
+ * ZSTD_Sequence, storing the sequences it finds, until it reaches a block delimiter.
+ * Note that the block delimiter must include the last literals of the block.
+ */
+size_t
+ZSTD_copySequencesToSeqStoreExplicitBlockDelim(ZSTD_CCtx* cctx,
+                                              ZSTD_sequencePosition* seqPos,
+                                        const ZSTD_Sequence* const inSeqs, size_t inSeqsSize,
+                                        const void* src, size_t blockSize, ZSTD_paramSwitch_e externalRepSearch);
+
+/* Returns the number of bytes to move the current read position back by.
+ * Only non-zero if we ended up splitting a sequence.
+ * Otherwise, it may return a ZSTD error if something went wrong.
+ *
+ * This function will attempt to scan through blockSize bytes
+ * represented by the sequences in @inSeqs,
+ * storing any (partial) sequences.
+ *
+ * Occasionally, we may want to change the actual number of bytes we consumed from inSeqs to
+ * avoid splitting a match, or to avoid splitting a match such that it would produce a match
+ * smaller than MINMATCH. In this case, we return the number of bytes that we didn't read from this block.
+ */
+size_t
+ZSTD_copySequencesToSeqStoreNoBlockDelim(ZSTD_CCtx* cctx, ZSTD_sequencePosition* seqPos,
+                                   const ZSTD_Sequence* const inSeqs, size_t inSeqsSize,
+                                   const void* src, size_t blockSize, ZSTD_paramSwitch_e externalRepSearch);
+
+
+/* ===============================================================
+ * Deprecated definitions that are still used internally to avoid
+ * deprecation warnings. These functions are exactly equivalent to
+ * their public variants, but avoid the deprecation warnings.
+ * =============================================================== */
+
+size_t ZSTD_compressBegin_usingCDict_deprecated(ZSTD_CCtx* cctx, const ZSTD_CDict* cdict);
+
+size_t ZSTD_compressContinue_public(ZSTD_CCtx* cctx,
+                                    void* dst, size_t dstCapacity,
+                              const void* src, size_t srcSize);
+
+size_t ZSTD_compressEnd_public(ZSTD_CCtx* cctx,
+                               void* dst, size_t dstCapacity,
+                         const void* src, size_t srcSize);
+
+size_t ZSTD_compressBlock_deprecated(ZSTD_CCtx* cctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize);
+
+
+#endif /* ZSTD_COMPRESS_H */
diff --git a/src/3rdparty/zstd/src/compress/zstd_compress_literals.c b/src/3rdparty/zstd/src/compress/zstd_compress_literals.c
new file mode 100644
index 0000000000..bfd4f11abe
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_compress_literals.c
@@ -0,0 +1,235 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+ /*-*************************************
+ *  Dependencies
+ ***************************************/
+#include "zstd_compress_literals.h"
+
+
+/* **************************************************************
+*  Debug Traces
+****************************************************************/
+#if DEBUGLEVEL >= 2
+
+static size_t showHexa(const void* src, size_t srcSize)
+{
+    const BYTE* const ip = (const BYTE*)src;
+    size_t u;
+    for (u=0; u<srcSize; u++) {
+        RAWLOG(5, " %02X", ip[u]); (void)ip;
+    }
+    RAWLOG(5, " \n");
+    return srcSize;
+}
+
+#endif
+
+
+/* **************************************************************
+*  Literals compression - special cases
+****************************************************************/
+size_t ZSTD_noCompressLiterals (void* dst, size_t dstCapacity, const void* src, size_t srcSize)
+{
+    BYTE* const ostart = (BYTE*)dst;
+    U32   const flSize = 1 + (srcSize>31) + (srcSize>4095);
+
+    DEBUGLOG(5, "ZSTD_noCompressLiterals: srcSize=%zu, dstCapacity=%zu", srcSize, dstCapacity);
+
+    RETURN_ERROR_IF(srcSize + flSize > dstCapacity, dstSize_tooSmall, "");
+
+    switch(flSize)
+    {
+        case 1: /* 2 - 1 - 5 */
+            ostart[0] = (BYTE)((U32)set_basic + (srcSize<<3));
+            break;
+        case 2: /* 2 - 2 - 12 */
+            MEM_writeLE16(ostart, (U16)((U32)set_basic + (1<<2) + (srcSize<<4)));
+            break;
+        case 3: /* 2 - 2 - 20 */
+            MEM_writeLE32(ostart, (U32)((U32)set_basic + (3<<2) + (srcSize<<4)));
+            break;
+        default:   /* not necessary : flSize is {1,2,3} */
+            assert(0);
+    }
+
+    ZSTD_memcpy(ostart + flSize, src, srcSize);
+    DEBUGLOG(5, "Raw (uncompressed) literals: %u -> %u", (U32)srcSize, (U32)(srcSize + flSize));
+    return srcSize + flSize;
+}
+
+static int allBytesIdentical(const void* src, size_t srcSize)
+{
+    assert(srcSize >= 1);
+    assert(src != NULL);
+    {   const BYTE b = ((const BYTE*)src)[0];
+        size_t p;
+        for (p=1; p<srcSize; p++) {
+            if (((const BYTE*)src)[p] != b) return 0;
+        }
+        return 1;
+    }
+}
+
+size_t ZSTD_compressRleLiteralsBlock (void* dst, size_t dstCapacity, const void* src, size_t srcSize)
+{
+    BYTE* const ostart = (BYTE*)dst;
+    U32   const flSize = 1 + (srcSize>31) + (srcSize>4095);
+
+    assert(dstCapacity >= 4); (void)dstCapacity;
+    assert(allBytesIdentical(src, srcSize));
+
+    switch(flSize)
+    {
+        case 1: /* 2 - 1 - 5 */
+            ostart[0] = (BYTE)((U32)set_rle + (srcSize<<3));
+            break;
+        case 2: /* 2 - 2 - 12 */
+            MEM_writeLE16(ostart, (U16)((U32)set_rle + (1<<2) + (srcSize<<4)));
+            break;
+        case 3: /* 2 - 2 - 20 */
+            MEM_writeLE32(ostart, (U32)((U32)set_rle + (3<<2) + (srcSize<<4)));
+            break;
+        default:   /* not necessary : flSize is {1,2,3} */
+            assert(0);
+    }
+
+    ostart[flSize] = *(const BYTE*)src;
+    DEBUGLOG(5, "RLE : Repeated Literal (%02X: %u times) -> %u bytes encoded", ((const BYTE*)src)[0], (U32)srcSize, (U32)flSize + 1);
+    return flSize+1;
+}
+
+/* ZSTD_minLiteralsToCompress() :
+ * returns minimal amount of literals
+ * for literal compression to even be attempted.
+ * Minimum is made tighter as compression strategy increases.
+ */
+static size_t
+ZSTD_minLiteralsToCompress(ZSTD_strategy strategy, HUF_repeat huf_repeat)
+{
+    assert((int)strategy >= 0);
+    assert((int)strategy <= 9);
+    /* btultra2 : min 8 bytes;
+     * then 2x larger for each successive compression strategy
+     * max threshold 64 bytes */
+    {   int const shift = MIN(9-(int)strategy, 3);
+        size_t const mintc = (huf_repeat == HUF_repeat_valid) ? 6 : (size_t)8 << shift;
+        DEBUGLOG(7, "minLiteralsToCompress = %zu", mintc);
+        return mintc;
+    }
+}
+
+size_t ZSTD_compressLiterals (
+                  void* dst, size_t dstCapacity,
+            const void* src, size_t srcSize,
+                  void* entropyWorkspace, size_t entropyWorkspaceSize,
+            const ZSTD_hufCTables_t* prevHuf,
+                  ZSTD_hufCTables_t* nextHuf,
+                  ZSTD_strategy strategy,
+                  int disableLiteralCompression,
+                  int suspectUncompressible,
+                  int bmi2)
+{
+    size_t const lhSize = 3 + (srcSize >= 1 KB) + (srcSize >= 16 KB);
+    BYTE*  const ostart = (BYTE*)dst;
+    U32 singleStream = srcSize < 256;
+    symbolEncodingType_e hType = set_compressed;
+    size_t cLitSize;
+
+    DEBUGLOG(5,"ZSTD_compressLiterals (disableLiteralCompression=%i, srcSize=%u, dstCapacity=%zu)",
+                disableLiteralCompression, (U32)srcSize, dstCapacity);
+
+    DEBUGLOG(6, "Completed literals listing (%zu bytes)", showHexa(src, srcSize));
+
+    /* Prepare nextEntropy assuming reusing the existing table */
+    ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));
+
+    if (disableLiteralCompression)
+        return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);
+
+    /* if too small, don't even attempt compression (speed opt) */
+    if (srcSize < ZSTD_minLiteralsToCompress(strategy, prevHuf->repeatMode))
+        return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);
+
+    RETURN_ERROR_IF(dstCapacity < lhSize+1, dstSize_tooSmall, "not enough space for compression");
+    {   HUF_repeat repeat = prevHuf->repeatMode;
+        int const flags = 0
+            | (bmi2 ? HUF_flags_bmi2 : 0)
+            | (strategy < ZSTD_lazy && srcSize <= 1024 ? HUF_flags_preferRepeat : 0)
+            | (strategy >= HUF_OPTIMAL_DEPTH_THRESHOLD ? HUF_flags_optimalDepth : 0)
+            | (suspectUncompressible ? HUF_flags_suspectUncompressible : 0);
+
+        typedef size_t (*huf_compress_f)(void*, size_t, const void*, size_t, unsigned, unsigned, void*, size_t, HUF_CElt*, HUF_repeat*, int);
+        huf_compress_f huf_compress;
+        if (repeat == HUF_repeat_valid && lhSize == 3) singleStream = 1;
+        huf_compress = singleStream ? HUF_compress1X_repeat : HUF_compress4X_repeat;
+        cLitSize = huf_compress(ostart+lhSize, dstCapacity-lhSize,
+                                src, srcSize,
+                                HUF_SYMBOLVALUE_MAX, LitHufLog,
+                                entropyWorkspace, entropyWorkspaceSize,
+                                (HUF_CElt*)nextHuf->CTable,
+                                &repeat, flags);
+        DEBUGLOG(5, "%zu literals compressed into %zu bytes (before header)", srcSize, cLitSize);
+        if (repeat != HUF_repeat_none) {
+            /* reused the existing table */
+            DEBUGLOG(5, "reusing statistics from previous huffman block");
+            hType = set_repeat;
+        }
+    }
+
+    {   size_t const minGain = ZSTD_minGain(srcSize, strategy);
+        if ((cLitSize==0) || (cLitSize >= srcSize - minGain) || ERR_isError(cLitSize)) {
+            ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));
+            return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);
+    }   }
+    if (cLitSize==1) {
+        /* A return value of 1 signals that the alphabet consists of a single symbol.
+         * However, in some rare circumstances, it could be the compressed size (a single byte).
+         * For that outcome to have a chance to happen, it's necessary that `srcSize < 8`.
+         * (it's also necessary to not generate statistics).
+         * Therefore, in such a case, actively check that all bytes are identical. */
+        if ((srcSize >= 8) || allBytesIdentical(src, srcSize)) {
+            ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));
+            return ZSTD_compressRleLiteralsBlock(dst, dstCapacity, src, srcSize);
+    }   }
+
+    if (hType == set_compressed) {
+        /* using a newly constructed table */
+        nextHuf->repeatMode = HUF_repeat_check;
+    }
+
+    /* Build header */
+    switch(lhSize)
+    {
+    case 3: /* 2 - 2 - 10 - 10 */
+        if (!singleStream) assert(srcSize >= MIN_LITERALS_FOR_4_STREAMS);
+        {   U32 const lhc = hType + ((U32)(!singleStream) << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<14);
+            MEM_writeLE24(ostart, lhc);
+            break;
+        }
+    case 4: /* 2 - 2 - 14 - 14 */
+        assert(srcSize >= MIN_LITERALS_FOR_4_STREAMS);
+        {   U32 const lhc = hType + (2 << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<18);
+            MEM_writeLE32(ostart, lhc);
+            break;
+        }
+    case 5: /* 2 - 2 - 18 - 18 */
+        assert(srcSize >= MIN_LITERALS_FOR_4_STREAMS);
+        {   U32 const lhc = hType + (3 << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<22);
+            MEM_writeLE32(ostart, lhc);
+            ostart[4] = (BYTE)(cLitSize >> 10);
+            break;
+        }
+    default:  /* not possible : lhSize is {3,4,5} */
+        assert(0);
+    }
+    DEBUGLOG(5, "Compressed literals: %u -> %u", (U32)srcSize, (U32)(lhSize+cLitSize));
+    return lhSize+cLitSize;
+}
diff --git a/src/3rdparty/zstd/src/compress/zstd_compress_literals.h b/src/3rdparty/zstd/src/compress/zstd_compress_literals.h
new file mode 100644
index 0000000000..b060c8ad21
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_compress_literals.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_COMPRESS_LITERALS_H
+#define ZSTD_COMPRESS_LITERALS_H
+
+#include "zstd_compress_internal.h" /* ZSTD_hufCTables_t, ZSTD_minGain() */
+
+
+size_t ZSTD_noCompressLiterals (void* dst, size_t dstCapacity, const void* src, size_t srcSize);
+
+/* ZSTD_compressRleLiteralsBlock() :
+ * Conditions :
+ * - All bytes in @src are identical
+ * - dstCapacity >= 4 */
+size_t ZSTD_compressRleLiteralsBlock (void* dst, size_t dstCapacity, const void* src, size_t srcSize);
+
+/* ZSTD_compressLiterals():
+ * @entropyWorkspace: must be aligned on 4-bytes boundaries
+ * @entropyWorkspaceSize : must be >= HUF_WORKSPACE_SIZE
+ * @suspectUncompressible: sampling checks, to potentially skip huffman coding
+ */
+size_t ZSTD_compressLiterals (void* dst, size_t dstCapacity,
+                        const void* src, size_t srcSize,
+                              void* entropyWorkspace, size_t entropyWorkspaceSize,
+                        const ZSTD_hufCTables_t* prevHuf,
+                              ZSTD_hufCTables_t* nextHuf,
+                              ZSTD_strategy strategy, int disableLiteralCompression,
+                              int suspectUncompressible,
+                              int bmi2);
+
+#endif /* ZSTD_COMPRESS_LITERALS_H */
diff --git a/src/3rdparty/zstd/src/compress/zstd_compress_sequences.c b/src/3rdparty/zstd/src/compress/zstd_compress_sequences.c
new file mode 100644
index 0000000000..8872d4d354
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_compress_sequences.c
@@ -0,0 +1,442 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+ /*-*************************************
+ *  Dependencies
+ ***************************************/
+#include "zstd_compress_sequences.h"
+
+/**
+ * -log2(x / 256) lookup table for x in [0, 256).
+ * If x == 0: Return 0
+ * Else: Return floor(-log2(x / 256) * 256)
+ */
+static unsigned const kInverseProbabilityLog256[256] = {
+    0,    2048, 1792, 1642, 1536, 1453, 1386, 1329, 1280, 1236, 1197, 1162,
+    1130, 1100, 1073, 1047, 1024, 1001, 980,  960,  941,  923,  906,  889,
+    874,  859,  844,  830,  817,  804,  791,  779,  768,  756,  745,  734,
+    724,  714,  704,  694,  685,  676,  667,  658,  650,  642,  633,  626,
+    618,  610,  603,  595,  588,  581,  574,  567,  561,  554,  548,  542,
+    535,  529,  523,  517,  512,  506,  500,  495,  489,  484,  478,  473,
+    468,  463,  458,  453,  448,  443,  438,  434,  429,  424,  420,  415,
+    411,  407,  402,  398,  394,  390,  386,  382,  377,  373,  370,  366,
+    362,  358,  354,  350,  347,  343,  339,  336,  332,  329,  325,  322,
+    318,  315,  311,  308,  305,  302,  298,  295,  292,  289,  286,  282,
+    279,  276,  273,  270,  267,  264,  261,  258,  256,  253,  250,  247,
+    244,  241,  239,  236,  233,  230,  228,  225,  222,  220,  217,  215,
+    212,  209,  207,  204,  202,  199,  197,  194,  192,  190,  187,  185,
+    182,  180,  178,  175,  173,  171,  168,  166,  164,  162,  159,  157,
+    155,  153,  151,  149,  146,  144,  142,  140,  138,  136,  134,  132,
+    130,  128,  126,  123,  121,  119,  117,  115,  114,  112,  110,  108,
+    106,  104,  102,  100,  98,   96,   94,   93,   91,   89,   87,   85,
+    83,   82,   80,   78,   76,   74,   73,   71,   69,   67,   66,   64,
+    62,   61,   59,   57,   55,   54,   52,   50,   49,   47,   46,   44,
+    42,   41,   39,   37,   36,   34,   33,   31,   30,   28,   26,   25,
+    23,   22,   20,   19,   17,   16,   14,   13,   11,   10,   8,    7,
+    5,    4,    2,    1,
+};
+
+static unsigned ZSTD_getFSEMaxSymbolValue(FSE_CTable const* ctable) {
+  void const* ptr = ctable;
+  U16 const* u16ptr = (U16 const*)ptr;
+  U32 const maxSymbolValue = MEM_read16(u16ptr + 1);
+  return maxSymbolValue;
+}
+
+/**
+ * Returns true if we should use ncount=-1 else we should
+ * use ncount=1 for low probability symbols instead.
+ */
+static unsigned ZSTD_useLowProbCount(size_t const nbSeq)
+{
+    /* Heuristic: This should cover most blocks <= 16K and
+     * start to fade out after 16K to about 32K depending on
+     * compressibility.
+     */
+    return nbSeq >= 2048;
+}
+
+/**
+ * Returns the cost in bytes of encoding the normalized count header.
+ * Returns an error if any of the helper functions return an error.
+ */
+static size_t ZSTD_NCountCost(unsigned const* count, unsigned const max,
+                              size_t const nbSeq, unsigned const FSELog)
+{
+    BYTE wksp[FSE_NCOUNTBOUND];
+    S16 norm[MaxSeq + 1];
+    const U32 tableLog = FSE_optimalTableLog(FSELog, nbSeq, max);
+    FORWARD_IF_ERROR(FSE_normalizeCount(norm, tableLog, count, nbSeq, max, ZSTD_useLowProbCount(nbSeq)), "");
+    return FSE_writeNCount(wksp, sizeof(wksp), norm, max, tableLog);
+}
+
+/**
+ * Returns the cost in bits of encoding the distribution described by count
+ * using the entropy bound.
+ */
+static size_t ZSTD_entropyCost(unsigned const* count, unsigned const max, size_t const total)
+{
+    unsigned cost = 0;
+    unsigned s;
+
+    assert(total > 0);
+    for (s = 0; s <= max; ++s) {
+        unsigned norm = (unsigned)((256 * count[s]) / total);
+        if (count[s] != 0 && norm == 0)
+            norm = 1;
+        assert(count[s] < total);
+        cost += count[s] * kInverseProbabilityLog256[norm];
+    }
+    return cost >> 8;
+}
+
+/**
+ * Returns the cost in bits of encoding the distribution in count using ctable.
+ * Returns an error if ctable cannot represent all the symbols in count.
+ */
+size_t ZSTD_fseBitCost(
+    FSE_CTable const* ctable,
+    unsigned const* count,
+    unsigned const max)
+{
+    unsigned const kAccuracyLog = 8;
+    size_t cost = 0;
+    unsigned s;
+    FSE_CState_t cstate;
+    FSE_initCState(&cstate, ctable);
+    if (ZSTD_getFSEMaxSymbolValue(ctable) < max) {
+        DEBUGLOG(5, "Repeat FSE_CTable has maxSymbolValue %u < %u",
+                    ZSTD_getFSEMaxSymbolValue(ctable), max);
+        return ERROR(GENERIC);
+    }
+    for (s = 0; s <= max; ++s) {
+        unsigned const tableLog = cstate.stateLog;
+        unsigned const badCost = (tableLog + 1) << kAccuracyLog;
+        unsigned const bitCost = FSE_bitCost(cstate.symbolTT, tableLog, s, kAccuracyLog);
+        if (count[s] == 0)
+            continue;
+        if (bitCost >= badCost) {
+            DEBUGLOG(5, "Repeat FSE_CTable has Prob[%u] == 0", s);
+            return ERROR(GENERIC);
+        }
+        cost += (size_t)count[s] * bitCost;
+    }
+    return cost >> kAccuracyLog;
+}
+
+/**
+ * Returns the cost in bits of encoding the distribution in count using the
+ * table described by norm. The max symbol support by norm is assumed >= max.
+ * norm must be valid for every symbol with non-zero probability in count.
+ */
+size_t ZSTD_crossEntropyCost(short const* norm, unsigned accuracyLog,
+                             unsigned const* count, unsigned const max)
+{
+    unsigned const shift = 8 - accuracyLog;
+    size_t cost = 0;
+    unsigned s;
+    assert(accuracyLog <= 8);
+    for (s = 0; s <= max; ++s) {
+        unsigned const normAcc = (norm[s] != -1) ? (unsigned)norm[s] : 1;
+        unsigned const norm256 = normAcc << shift;
+        assert(norm256 > 0);
+        assert(norm256 < 256);
+        cost += count[s] * kInverseProbabilityLog256[norm256];
+    }
+    return cost >> 8;
+}
+
+symbolEncodingType_e
+ZSTD_selectEncodingType(
+        FSE_repeat* repeatMode, unsigned const* count, unsigned const max,
+        size_t const mostFrequent, size_t nbSeq, unsigned const FSELog,
+        FSE_CTable const* prevCTable,
+        short const* defaultNorm, U32 defaultNormLog,
+        ZSTD_defaultPolicy_e const isDefaultAllowed,
+        ZSTD_strategy const strategy)
+{
+    ZSTD_STATIC_ASSERT(ZSTD_defaultDisallowed == 0 && ZSTD_defaultAllowed != 0);
+    if (mostFrequent == nbSeq) {
+        *repeatMode = FSE_repeat_none;
+        if (isDefaultAllowed && nbSeq <= 2) {
+            /* Prefer set_basic over set_rle when there are 2 or fewer symbols,
+             * since RLE uses 1 byte, but set_basic uses 5-6 bits per symbol.
+             * If basic encoding isn't possible, always choose RLE.
+             */
+            DEBUGLOG(5, "Selected set_basic");
+            return set_basic;
+        }
+        DEBUGLOG(5, "Selected set_rle");
+        return set_rle;
+    }
+    if (strategy < ZSTD_lazy) {
+        if (isDefaultAllowed) {
+            size_t const staticFse_nbSeq_max = 1000;
+            size_t const mult = 10 - strategy;
+            size_t const baseLog = 3;
+            size_t const dynamicFse_nbSeq_min = (((size_t)1 << defaultNormLog) * mult) >> baseLog;  /* 28-36 for offset, 56-72 for lengths */
+            assert(defaultNormLog >= 5 && defaultNormLog <= 6);  /* xx_DEFAULTNORMLOG */
+            assert(mult <= 9 && mult >= 7);
+            if ( (*repeatMode == FSE_repeat_valid)
+              && (nbSeq < staticFse_nbSeq_max) ) {
+                DEBUGLOG(5, "Selected set_repeat");
+                return set_repeat;
+            }
+            if ( (nbSeq < dynamicFse_nbSeq_min)
+              || (mostFrequent < (nbSeq >> (defaultNormLog-1))) ) {
+                DEBUGLOG(5, "Selected set_basic");
+                /* The format allows default tables to be repeated, but it isn't useful.
+                 * When using simple heuristics to select encoding type, we don't want
+                 * to confuse these tables with dictionaries. When running more careful
+                 * analysis, we don't need to waste time checking both repeating tables
+                 * and default tables.
+                 */
+                *repeatMode = FSE_repeat_none;
+                return set_basic;
+            }
+        }
+    } else {
+        size_t const basicCost = isDefaultAllowed ? ZSTD_crossEntropyCost(defaultNorm, defaultNormLog, count, max) : ERROR(GENERIC);
+        size_t const repeatCost = *repeatMode != FSE_repeat_none ? ZSTD_fseBitCost(prevCTable, count, max) : ERROR(GENERIC);
+        size_t const NCountCost = ZSTD_NCountCost(count, max, nbSeq, FSELog);
+        size_t const compressedCost = (NCountCost << 3) + ZSTD_entropyCost(count, max, nbSeq);
+
+        if (isDefaultAllowed) {
+            assert(!ZSTD_isError(basicCost));
+            assert(!(*repeatMode == FSE_repeat_valid && ZSTD_isError(repeatCost)));
+        }
+        assert(!ZSTD_isError(NCountCost));
+        assert(compressedCost < ERROR(maxCode));
+        DEBUGLOG(5, "Estimated bit costs: basic=%u\trepeat=%u\tcompressed=%u",
+                    (unsigned)basicCost, (unsigned)repeatCost, (unsigned)compressedCost);
+        if (basicCost <= repeatCost && basicCost <= compressedCost) {
+            DEBUGLOG(5, "Selected set_basic");
+            assert(isDefaultAllowed);
+            *repeatMode = FSE_repeat_none;
+            return set_basic;
+        }
+        if (repeatCost <= compressedCost) {
+            DEBUGLOG(5, "Selected set_repeat");
+            assert(!ZSTD_isError(repeatCost));
+            return set_repeat;
+        }
+        assert(compressedCost < basicCost && compressedCost < repeatCost);
+    }
+    DEBUGLOG(5, "Selected set_compressed");
+    *repeatMode = FSE_repeat_check;
+    return set_compressed;
+}
+
+typedef struct {
+    S16 norm[MaxSeq + 1];
+    U32 wksp[FSE_BUILD_CTABLE_WORKSPACE_SIZE_U32(MaxSeq, MaxFSELog)];
+} ZSTD_BuildCTableWksp;
+
+size_t
+ZSTD_buildCTable(void* dst, size_t dstCapacity,
+                FSE_CTable* nextCTable, U32 FSELog, symbolEncodingType_e type,
+                unsigned* count, U32 max,
+                const BYTE* codeTable, size_t nbSeq,
+                const S16* defaultNorm, U32 defaultNormLog, U32 defaultMax,
+                const FSE_CTable* prevCTable, size_t prevCTableSize,
+                void* entropyWorkspace, size_t entropyWorkspaceSize)
+{
+    BYTE* op = (BYTE*)dst;
+    const BYTE* const oend = op + dstCapacity;
+    DEBUGLOG(6, "ZSTD_buildCTable (dstCapacity=%u)", (unsigned)dstCapacity);
+
+    switch (type) {
+    case set_rle:
+        FORWARD_IF_ERROR(FSE_buildCTable_rle(nextCTable, (BYTE)max), "");
+        RETURN_ERROR_IF(dstCapacity==0, dstSize_tooSmall, "not enough space");
+        *op = codeTable[0];
+        return 1;
+    case set_repeat:
+        ZSTD_memcpy(nextCTable, prevCTable, prevCTableSize);
+        return 0;
+    case set_basic:
+        FORWARD_IF_ERROR(FSE_buildCTable_wksp(nextCTable, defaultNorm, defaultMax, defaultNormLog, entropyWorkspace, entropyWorkspaceSize), "");  /* note : could be pre-calculated */
+        return 0;
+    case set_compressed: {
+        ZSTD_BuildCTableWksp* wksp = (ZSTD_BuildCTableWksp*)entropyWorkspace;
+        size_t nbSeq_1 = nbSeq;
+        const U32 tableLog = FSE_optimalTableLog(FSELog, nbSeq, max);
+        if (count[codeTable[nbSeq-1]] > 1) {
+            count[codeTable[nbSeq-1]]--;
+            nbSeq_1--;
+        }
+        assert(nbSeq_1 > 1);
+        assert(entropyWorkspaceSize >= sizeof(ZSTD_BuildCTableWksp));
+        (void)entropyWorkspaceSize;
+        FORWARD_IF_ERROR(FSE_normalizeCount(wksp->norm, tableLog, count, nbSeq_1, max, ZSTD_useLowProbCount(nbSeq_1)), "FSE_normalizeCount failed");
+        assert(oend >= op);
+        {   size_t const NCountSize = FSE_writeNCount(op, (size_t)(oend - op), wksp->norm, max, tableLog);   /* overflow protected */
+            FORWARD_IF_ERROR(NCountSize, "FSE_writeNCount failed");
+            FORWARD_IF_ERROR(FSE_buildCTable_wksp(nextCTable, wksp->norm, max, tableLog, wksp->wksp, sizeof(wksp->wksp)), "FSE_buildCTable_wksp failed");
+            return NCountSize;
+        }
+    }
+    default: assert(0); RETURN_ERROR(GENERIC, "impossible to reach");
+    }
+}
+
+FORCE_INLINE_TEMPLATE size_t
+ZSTD_encodeSequences_body(
+            void* dst, size_t dstCapacity,
+            FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,
+            FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,
+            FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,
+            seqDef const* sequences, size_t nbSeq, int longOffsets)
+{
+    BIT_CStream_t blockStream;
+    FSE_CState_t  stateMatchLength;
+    FSE_CState_t  stateOffsetBits;
+    FSE_CState_t  stateLitLength;
+
+    RETURN_ERROR_IF(
+        ERR_isError(BIT_initCStream(&blockStream, dst, dstCapacity)),
+        dstSize_tooSmall, "not enough space remaining");
+    DEBUGLOG(6, "available space for bitstream : %i  (dstCapacity=%u)",
+                (int)(blockStream.endPtr - blockStream.startPtr),
+                (unsigned)dstCapacity);
+
+    /* first symbols */
+    FSE_initCState2(&stateMatchLength, CTable_MatchLength, mlCodeTable[nbSeq-1]);
+    FSE_initCState2(&stateOffsetBits,  CTable_OffsetBits,  ofCodeTable[nbSeq-1]);
+    FSE_initCState2(&stateLitLength,   CTable_LitLength,   llCodeTable[nbSeq-1]);
+    BIT_addBits(&blockStream, sequences[nbSeq-1].litLength, LL_bits[llCodeTable[nbSeq-1]]);
+    if (MEM_32bits()) BIT_flushBits(&blockStream);
+    BIT_addBits(&blockStream, sequences[nbSeq-1].mlBase, ML_bits[mlCodeTable[nbSeq-1]]);
+    if (MEM_32bits()) BIT_flushBits(&blockStream);
+    if (longOffsets) {
+        U32 const ofBits = ofCodeTable[nbSeq-1];
+        unsigned const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);
+        if (extraBits) {
+            BIT_addBits(&blockStream, sequences[nbSeq-1].offBase, extraBits);
+            BIT_flushBits(&blockStream);
+        }
+        BIT_addBits(&blockStream, sequences[nbSeq-1].offBase >> extraBits,
+                    ofBits - extraBits);
+    } else {
+        BIT_addBits(&blockStream, sequences[nbSeq-1].offBase, ofCodeTable[nbSeq-1]);
+    }
+    BIT_flushBits(&blockStream);
+
+    {   size_t n;
+        for (n=nbSeq-2 ; n<nbSeq ; n--) {      /* intentional underflow */
+            BYTE const llCode = llCodeTable[n];
+            BYTE const ofCode = ofCodeTable[n];
+            BYTE const mlCode = mlCodeTable[n];
+            U32  const llBits = LL_bits[llCode];
+            U32  const ofBits = ofCode;
+            U32  const mlBits = ML_bits[mlCode];
+            DEBUGLOG(6, "encoding: litlen:%2u - matchlen:%2u - offCode:%7u",
+                        (unsigned)sequences[n].litLength,
+                        (unsigned)sequences[n].mlBase + MINMATCH,
+                        (unsigned)sequences[n].offBase);
+                                                                            /* 32b*/  /* 64b*/
+                                                                            /* (7)*/  /* (7)*/
+            FSE_encodeSymbol(&blockStream, &stateOffsetBits, ofCode);       /* 15 */  /* 15 */
+            FSE_encodeSymbol(&blockStream, &stateMatchLength, mlCode);      /* 24 */  /* 24 */
+            if (MEM_32bits()) BIT_flushBits(&blockStream);                  /* (7)*/
+            FSE_encodeSymbol(&blockStream, &stateLitLength, llCode);        /* 16 */  /* 33 */
+            if (MEM_32bits() || (ofBits+mlBits+llBits >= 64-7-(LLFSELog+MLFSELog+OffFSELog)))
+                BIT_flushBits(&blockStream);                                /* (7)*/
+            BIT_addBits(&blockStream, sequences[n].litLength, llBits);
+            if (MEM_32bits() && ((llBits+mlBits)>24)) BIT_flushBits(&blockStream);
+            BIT_addBits(&blockStream, sequences[n].mlBase, mlBits);
+            if (MEM_32bits() || (ofBits+mlBits+llBits > 56)) BIT_flushBits(&blockStream);
+            if (longOffsets) {
+                unsigned const extraBits = ofBits - MIN(ofBits, STREAM_ACCUMULATOR_MIN-1);
+                if (extraBits) {
+                    BIT_addBits(&blockStream, sequences[n].offBase, extraBits);
+                    BIT_flushBits(&blockStream);                            /* (7)*/
+                }
+                BIT_addBits(&blockStream, sequences[n].offBase >> extraBits,
+                            ofBits - extraBits);                            /* 31 */
+            } else {
+                BIT_addBits(&blockStream, sequences[n].offBase, ofBits);     /* 31 */
+            }
+            BIT_flushBits(&blockStream);                                    /* (7)*/
+            DEBUGLOG(7, "remaining space : %i", (int)(blockStream.endPtr - blockStream.ptr));
+    }   }
+
+    DEBUGLOG(6, "ZSTD_encodeSequences: flushing ML state with %u bits", stateMatchLength.stateLog);
+    FSE_flushCState(&blockStream, &stateMatchLength);
+    DEBUGLOG(6, "ZSTD_encodeSequences: flushing Off state with %u bits", stateOffsetBits.stateLog);
+    FSE_flushCState(&blockStream, &stateOffsetBits);
+    DEBUGLOG(6, "ZSTD_encodeSequences: flushing LL state with %u bits", stateLitLength.stateLog);
+    FSE_flushCState(&blockStream, &stateLitLength);
+
+    {   size_t const streamSize = BIT_closeCStream(&blockStream);
+        RETURN_ERROR_IF(streamSize==0, dstSize_tooSmall, "not enough space");
+        return streamSize;
+    }
+}
+
+static size_t
+ZSTD_encodeSequences_default(
+            void* dst, size_t dstCapacity,
+            FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,
+            FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,
+            FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,
+            seqDef const* sequences, size_t nbSeq, int longOffsets)
+{
+    return ZSTD_encodeSequences_body(dst, dstCapacity,
+                                    CTable_MatchLength, mlCodeTable,
+                                    CTable_OffsetBits, ofCodeTable,
+                                    CTable_LitLength, llCodeTable,
+                                    sequences, nbSeq, longOffsets);
+}
+
+
+#if DYNAMIC_BMI2
+
+static BMI2_TARGET_ATTRIBUTE size_t
+ZSTD_encodeSequences_bmi2(
+            void* dst, size_t dstCapacity,
+            FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,
+            FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,
+            FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,
+            seqDef const* sequences, size_t nbSeq, int longOffsets)
+{
+    return ZSTD_encodeSequences_body(dst, dstCapacity,
+                                    CTable_MatchLength, mlCodeTable,
+                                    CTable_OffsetBits, ofCodeTable,
+                                    CTable_LitLength, llCodeTable,
+                                    sequences, nbSeq, longOffsets);
+}
+
+#endif
+
+size_t ZSTD_encodeSequences(
+            void* dst, size_t dstCapacity,
+            FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,
+            FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,
+            FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,
+            seqDef const* sequences, size_t nbSeq, int longOffsets, int bmi2)
+{
+    DEBUGLOG(5, "ZSTD_encodeSequences: dstCapacity = %u", (unsigned)dstCapacity);
+#if DYNAMIC_BMI2
+    if (bmi2) {
+        return ZSTD_encodeSequences_bmi2(dst, dstCapacity,
+                                         CTable_MatchLength, mlCodeTable,
+                                         CTable_OffsetBits, ofCodeTable,
+                                         CTable_LitLength, llCodeTable,
+                                         sequences, nbSeq, longOffsets);
+    }
+#endif
+    (void)bmi2;
+    return ZSTD_encodeSequences_default(dst, dstCapacity,
+                                        CTable_MatchLength, mlCodeTable,
+                                        CTable_OffsetBits, ofCodeTable,
+                                        CTable_LitLength, llCodeTable,
+                                        sequences, nbSeq, longOffsets);
+}
diff --git a/src/3rdparty/zstd/src/compress/zstd_compress_sequences.h b/src/3rdparty/zstd/src/compress/zstd_compress_sequences.h
new file mode 100644
index 0000000000..4a3a05da94
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_compress_sequences.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_COMPRESS_SEQUENCES_H
+#define ZSTD_COMPRESS_SEQUENCES_H
+
+#include "../common/fse.h" /* FSE_repeat, FSE_CTable */
+#include "../common/zstd_internal.h" /* symbolEncodingType_e, ZSTD_strategy */
+
+typedef enum {
+    ZSTD_defaultDisallowed = 0,
+    ZSTD_defaultAllowed = 1
+} ZSTD_defaultPolicy_e;
+
+symbolEncodingType_e
+ZSTD_selectEncodingType(
+        FSE_repeat* repeatMode, unsigned const* count, unsigned const max,
+        size_t const mostFrequent, size_t nbSeq, unsigned const FSELog,
+        FSE_CTable const* prevCTable,
+        short const* defaultNorm, U32 defaultNormLog,
+        ZSTD_defaultPolicy_e const isDefaultAllowed,
+        ZSTD_strategy const strategy);
+
+size_t
+ZSTD_buildCTable(void* dst, size_t dstCapacity,
+                FSE_CTable* nextCTable, U32 FSELog, symbolEncodingType_e type,
+                unsigned* count, U32 max,
+                const BYTE* codeTable, size_t nbSeq,
+                const S16* defaultNorm, U32 defaultNormLog, U32 defaultMax,
+                const FSE_CTable* prevCTable, size_t prevCTableSize,
+                void* entropyWorkspace, size_t entropyWorkspaceSize);
+
+size_t ZSTD_encodeSequences(
+            void* dst, size_t dstCapacity,
+            FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,
+            FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,
+            FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,
+            seqDef const* sequences, size_t nbSeq, int longOffsets, int bmi2);
+
+size_t ZSTD_fseBitCost(
+    FSE_CTable const* ctable,
+    unsigned const* count,
+    unsigned const max);
+
+size_t ZSTD_crossEntropyCost(short const* norm, unsigned accuracyLog,
+                             unsigned const* count, unsigned const max);
+#endif /* ZSTD_COMPRESS_SEQUENCES_H */
diff --git a/src/3rdparty/zstd/src/compress/zstd_compress_superblock.c b/src/3rdparty/zstd/src/compress/zstd_compress_superblock.c
new file mode 100644
index 0000000000..638c4acbe7
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_compress_superblock.c
@@ -0,0 +1,577 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+ /*-*************************************
+ *  Dependencies
+ ***************************************/
+#include "zstd_compress_superblock.h"
+
+#include "../common/zstd_internal.h"  /* ZSTD_getSequenceLength */
+#include "hist.h"                     /* HIST_countFast_wksp */
+#include "zstd_compress_internal.h"   /* ZSTD_[huf|fse|entropy]CTablesMetadata_t */
+#include "zstd_compress_sequences.h"
+#include "zstd_compress_literals.h"
+
+/** ZSTD_compressSubBlock_literal() :
+ *  Compresses literals section for a sub-block.
+ *  When we have to write the Huffman table we will sometimes choose a header
+ *  size larger than necessary. This is because we have to pick the header size
+ *  before we know the table size + compressed size, so we have a bound on the
+ *  table size. If we guessed incorrectly, we fall back to uncompressed literals.
+ *
+ *  We write the header when writeEntropy=1 and set entropyWritten=1 when we succeeded
+ *  in writing the header, otherwise it is set to 0.
+ *
+ *  hufMetadata->hType has literals block type info.
+ *      If it is set_basic, all sub-blocks literals section will be Raw_Literals_Block.
+ *      If it is set_rle, all sub-blocks literals section will be RLE_Literals_Block.
+ *      If it is set_compressed, first sub-block's literals section will be Compressed_Literals_Block
+ *      If it is set_compressed, first sub-block's literals section will be Treeless_Literals_Block
+ *      and the following sub-blocks' literals sections will be Treeless_Literals_Block.
+ *  @return : compressed size of literals section of a sub-block
+ *            Or 0 if unable to compress.
+ *            Or error code */
+static size_t
+ZSTD_compressSubBlock_literal(const HUF_CElt* hufTable,
+                              const ZSTD_hufCTablesMetadata_t* hufMetadata,
+                              const BYTE* literals, size_t litSize,
+                              void* dst, size_t dstSize,
+                              const int bmi2, int writeEntropy, int* entropyWritten)
+{
+    size_t const header = writeEntropy ? 200 : 0;
+    size_t const lhSize = 3 + (litSize >= (1 KB - header)) + (litSize >= (16 KB - header));
+    BYTE* const ostart = (BYTE*)dst;
+    BYTE* const oend = ostart + dstSize;
+    BYTE* op = ostart + lhSize;
+    U32 const singleStream = lhSize == 3;
+    symbolEncodingType_e hType = writeEntropy ? hufMetadata->hType : set_repeat;
+    size_t cLitSize = 0;
+
+    DEBUGLOG(5, "ZSTD_compressSubBlock_literal (litSize=%zu, lhSize=%zu, writeEntropy=%d)", litSize, lhSize, writeEntropy);
+
+    *entropyWritten = 0;
+    if (litSize == 0 || hufMetadata->hType == set_basic) {
+      DEBUGLOG(5, "ZSTD_compressSubBlock_literal using raw literal");
+      return ZSTD_noCompressLiterals(dst, dstSize, literals, litSize);
+    } else if (hufMetadata->hType == set_rle) {
+      DEBUGLOG(5, "ZSTD_compressSubBlock_literal using rle literal");
+      return ZSTD_compressRleLiteralsBlock(dst, dstSize, literals, litSize);
+    }
+
+    assert(litSize > 0);
+    assert(hufMetadata->hType == set_compressed || hufMetadata->hType == set_repeat);
+
+    if (writeEntropy && hufMetadata->hType == set_compressed) {
+        ZSTD_memcpy(op, hufMetadata->hufDesBuffer, hufMetadata->hufDesSize);
+        op += hufMetadata->hufDesSize;
+        cLitSize += hufMetadata->hufDesSize;
+        DEBUGLOG(5, "ZSTD_compressSubBlock_literal (hSize=%zu)", hufMetadata->hufDesSize);
+    }
+
+    {   int const flags = bmi2 ? HUF_flags_bmi2 : 0;
+        const size_t cSize = singleStream ? HUF_compress1X_usingCTable(op, oend-op, literals, litSize, hufTable, flags)
+                                          : HUF_compress4X_usingCTable(op, oend-op, literals, litSize, hufTable, flags);
+        op += cSize;
+        cLitSize += cSize;
+        if (cSize == 0 || ERR_isError(cSize)) {
+            DEBUGLOG(5, "Failed to write entropy tables %s", ZSTD_getErrorName(cSize));
+            return 0;
+        }
+        /* If we expand and we aren't writing a header then emit uncompressed */
+        if (!writeEntropy && cLitSize >= litSize) {
+            DEBUGLOG(5, "ZSTD_compressSubBlock_literal using raw literal because uncompressible");
+            return ZSTD_noCompressLiterals(dst, dstSize, literals, litSize);
+        }
+        /* If we are writing headers then allow expansion that doesn't change our header size. */
+        if (lhSize < (size_t)(3 + (cLitSize >= 1 KB) + (cLitSize >= 16 KB))) {
+            assert(cLitSize > litSize);
+            DEBUGLOG(5, "Literals expanded beyond allowed header size");
+            return ZSTD_noCompressLiterals(dst, dstSize, literals, litSize);
+        }
+        DEBUGLOG(5, "ZSTD_compressSubBlock_literal (cSize=%zu)", cSize);
+    }
+
+    /* Build header */
+    switch(lhSize)
+    {
+    case 3: /* 2 - 2 - 10 - 10 */
+        {   U32 const lhc = hType + ((!singleStream) << 2) + ((U32)litSize<<4) + ((U32)cLitSize<<14);
+            MEM_writeLE24(ostart, lhc);
+            break;
+        }
+    case 4: /* 2 - 2 - 14 - 14 */
+        {   U32 const lhc = hType + (2 << 2) + ((U32)litSize<<4) + ((U32)cLitSize<<18);
+            MEM_writeLE32(ostart, lhc);
+            break;
+        }
+    case 5: /* 2 - 2 - 18 - 18 */
+        {   U32 const lhc = hType + (3 << 2) + ((U32)litSize<<4) + ((U32)cLitSize<<22);
+            MEM_writeLE32(ostart, lhc);
+            ostart[4] = (BYTE)(cLitSize >> 10);
+            break;
+        }
+    default:  /* not possible : lhSize is {3,4,5} */
+        assert(0);
+    }
+    *entropyWritten = 1;
+    DEBUGLOG(5, "Compressed literals: %u -> %u", (U32)litSize, (U32)(op-ostart));
+    return op-ostart;
+}
+
+static size_t
+ZSTD_seqDecompressedSize(seqStore_t const* seqStore,
+                   const seqDef* sequences, size_t nbSeq,
+                         size_t litSize, int lastSequence)
+{
+    const seqDef* const sstart = sequences;
+    const seqDef* const send = sequences + nbSeq;
+    const seqDef* sp = sstart;
+    size_t matchLengthSum = 0;
+    size_t litLengthSum = 0;
+    (void)(litLengthSum); /* suppress unused variable warning on some environments */
+    while (send-sp > 0) {
+        ZSTD_sequenceLength const seqLen = ZSTD_getSequenceLength(seqStore, sp);
+        litLengthSum += seqLen.litLength;
+        matchLengthSum += seqLen.matchLength;
+        sp++;
+    }
+    assert(litLengthSum <= litSize);
+    if (!lastSequence) {
+        assert(litLengthSum == litSize);
+    }
+    return matchLengthSum + litSize;
+}
+
+/** ZSTD_compressSubBlock_sequences() :
+ *  Compresses sequences section for a sub-block.
+ *  fseMetadata->llType, fseMetadata->ofType, and fseMetadata->mlType have
+ *  symbol compression modes for the super-block.
+ *  The first successfully compressed block will have these in its header.
+ *  We set entropyWritten=1 when we succeed in compressing the sequences.
+ *  The following sub-blocks will always have repeat mode.
+ *  @return : compressed size of sequences section of a sub-block
+ *            Or 0 if it is unable to compress
+ *            Or error code. */
+static size_t
+ZSTD_compressSubBlock_sequences(const ZSTD_fseCTables_t* fseTables,
+                                const ZSTD_fseCTablesMetadata_t* fseMetadata,
+                                const seqDef* sequences, size_t nbSeq,
+                                const BYTE* llCode, const BYTE* mlCode, const BYTE* ofCode,
+                                const ZSTD_CCtx_params* cctxParams,
+                                void* dst, size_t dstCapacity,
+                                const int bmi2, int writeEntropy, int* entropyWritten)
+{
+    const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;
+    BYTE* const ostart = (BYTE*)dst;
+    BYTE* const oend = ostart + dstCapacity;
+    BYTE* op = ostart;
+    BYTE* seqHead;
+
+    DEBUGLOG(5, "ZSTD_compressSubBlock_sequences (nbSeq=%zu, writeEntropy=%d, longOffsets=%d)", nbSeq, writeEntropy, longOffsets);
+
+    *entropyWritten = 0;
+    /* Sequences Header */
+    RETURN_ERROR_IF((oend-op) < 3 /*max nbSeq Size*/ + 1 /*seqHead*/,
+                    dstSize_tooSmall, "");
+    if (nbSeq < 0x7F)
+        *op++ = (BYTE)nbSeq;
+    else if (nbSeq < LONGNBSEQ)
+        op[0] = (BYTE)((nbSeq>>8) + 0x80), op[1] = (BYTE)nbSeq, op+=2;
+    else
+        op[0]=0xFF, MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ)), op+=3;
+    if (nbSeq==0) {
+        return op - ostart;
+    }
+
+    /* seqHead : flags for FSE encoding type */
+    seqHead = op++;
+
+    DEBUGLOG(5, "ZSTD_compressSubBlock_sequences (seqHeadSize=%u)", (unsigned)(op-ostart));
+
+    if (writeEntropy) {
+        const U32 LLtype = fseMetadata->llType;
+        const U32 Offtype = fseMetadata->ofType;
+        const U32 MLtype = fseMetadata->mlType;
+        DEBUGLOG(5, "ZSTD_compressSubBlock_sequences (fseTablesSize=%zu)", fseMetadata->fseTablesSize);
+        *seqHead = (BYTE)((LLtype<<6) + (Offtype<<4) + (MLtype<<2));
+        ZSTD_memcpy(op, fseMetadata->fseTablesBuffer, fseMetadata->fseTablesSize);
+        op += fseMetadata->fseTablesSize;
+    } else {
+        const U32 repeat = set_repeat;
+        *seqHead = (BYTE)((repeat<<6) + (repeat<<4) + (repeat<<2));
+    }
+
+    {   size_t const bitstreamSize = ZSTD_encodeSequences(
+                                        op, oend - op,
+                                        fseTables->matchlengthCTable, mlCode,
+                                        fseTables->offcodeCTable, ofCode,
+                                        fseTables->litlengthCTable, llCode,
+                                        sequences, nbSeq,
+                                        longOffsets, bmi2);
+        FORWARD_IF_ERROR(bitstreamSize, "ZSTD_encodeSequences failed");
+        op += bitstreamSize;
+        /* zstd versions <= 1.3.4 mistakenly report corruption when
+         * FSE_readNCount() receives a buffer < 4 bytes.
+         * Fixed by https://github.com/facebook/zstd/pull/1146.
+         * This can happen when the last set_compressed table present is 2
+         * bytes and the bitstream is only one byte.
+         * In this exceedingly rare case, we will simply emit an uncompressed
+         * block, since it isn't worth optimizing.
+         */
+#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+        if (writeEntropy && fseMetadata->lastCountSize && fseMetadata->lastCountSize + bitstreamSize < 4) {
+            /* NCountSize >= 2 && bitstreamSize > 0 ==> lastCountSize == 3 */
+            assert(fseMetadata->lastCountSize + bitstreamSize == 3);
+            DEBUGLOG(5, "Avoiding bug in zstd decoder in versions <= 1.3.4 by "
+                        "emitting an uncompressed block.");
+            return 0;
+        }
+#endif
+        DEBUGLOG(5, "ZSTD_compressSubBlock_sequences (bitstreamSize=%zu)", bitstreamSize);
+    }
+
+    /* zstd versions <= 1.4.0 mistakenly report error when
+     * sequences section body size is less than 3 bytes.
+     * Fixed by https://github.com/facebook/zstd/pull/1664.
+     * This can happen when the previous sequences section block is compressed
+     * with rle mode and the current block's sequences section is compressed
+     * with repeat mode where sequences section body size can be 1 byte.
+     */
+#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+    if (op-seqHead < 4) {
+        DEBUGLOG(5, "Avoiding bug in zstd decoder in versions <= 1.4.0 by emitting "
+                    "an uncompressed block when sequences are < 4 bytes");
+        return 0;
+    }
+#endif
+
+    *entropyWritten = 1;
+    return op - ostart;
+}
+
+/** ZSTD_compressSubBlock() :
+ *  Compresses a single sub-block.
+ *  @return : compressed size of the sub-block
+ *            Or 0 if it failed to compress. */
+static size_t ZSTD_compressSubBlock(const ZSTD_entropyCTables_t* entropy,
+                                    const ZSTD_entropyCTablesMetadata_t* entropyMetadata,
+                                    const seqDef* sequences, size_t nbSeq,
+                                    const BYTE* literals, size_t litSize,
+                                    const BYTE* llCode, const BYTE* mlCode, const BYTE* ofCode,
+                                    const ZSTD_CCtx_params* cctxParams,
+                                    void* dst, size_t dstCapacity,
+                                    const int bmi2,
+                                    int writeLitEntropy, int writeSeqEntropy,
+                                    int* litEntropyWritten, int* seqEntropyWritten,
+                                    U32 lastBlock)
+{
+    BYTE* const ostart = (BYTE*)dst;
+    BYTE* const oend = ostart + dstCapacity;
+    BYTE* op = ostart + ZSTD_blockHeaderSize;
+    DEBUGLOG(5, "ZSTD_compressSubBlock (litSize=%zu, nbSeq=%zu, writeLitEntropy=%d, writeSeqEntropy=%d, lastBlock=%d)",
+                litSize, nbSeq, writeLitEntropy, writeSeqEntropy, lastBlock);
+    {   size_t cLitSize = ZSTD_compressSubBlock_literal((const HUF_CElt*)entropy->huf.CTable,
+                                                        &entropyMetadata->hufMetadata, literals, litSize,
+                                                        op, oend-op, bmi2, writeLitEntropy, litEntropyWritten);
+        FORWARD_IF_ERROR(cLitSize, "ZSTD_compressSubBlock_literal failed");
+        if (cLitSize == 0) return 0;
+        op += cLitSize;
+    }
+    {   size_t cSeqSize = ZSTD_compressSubBlock_sequences(&entropy->fse,
+                                                  &entropyMetadata->fseMetadata,
+                                                  sequences, nbSeq,
+                                                  llCode, mlCode, ofCode,
+                                                  cctxParams,
+                                                  op, oend-op,
+                                                  bmi2, writeSeqEntropy, seqEntropyWritten);
+        FORWARD_IF_ERROR(cSeqSize, "ZSTD_compressSubBlock_sequences failed");
+        if (cSeqSize == 0) return 0;
+        op += cSeqSize;
+    }
+    /* Write block header */
+    {   size_t cSize = (op-ostart)-ZSTD_blockHeaderSize;
+        U32 const cBlockHeader24 = lastBlock + (((U32)bt_compressed)<<1) + (U32)(cSize << 3);
+        MEM_writeLE24(ostart, cBlockHeader24);
+    }
+    return op-ostart;
+}
+
+static size_t ZSTD_estimateSubBlockSize_literal(const BYTE* literals, size_t litSize,
+                                                const ZSTD_hufCTables_t* huf,
+                                                const ZSTD_hufCTablesMetadata_t* hufMetadata,
+                                                void* workspace, size_t wkspSize,
+                                                int writeEntropy)
+{
+    unsigned* const countWksp = (unsigned*)workspace;
+    unsigned maxSymbolValue = 255;
+    size_t literalSectionHeaderSize = 3; /* Use hard coded size of 3 bytes */
+
+    if (hufMetadata->hType == set_basic) return litSize;
+    else if (hufMetadata->hType == set_rle) return 1;
+    else if (hufMetadata->hType == set_compressed || hufMetadata->hType == set_repeat) {
+        size_t const largest = HIST_count_wksp (countWksp, &maxSymbolValue, (const BYTE*)literals, litSize, workspace, wkspSize);
+        if (ZSTD_isError(largest)) return litSize;
+        {   size_t cLitSizeEstimate = HUF_estimateCompressedSize((const HUF_CElt*)huf->CTable, countWksp, maxSymbolValue);
+            if (writeEntropy) cLitSizeEstimate += hufMetadata->hufDesSize;
+            return cLitSizeEstimate + literalSectionHeaderSize;
+    }   }
+    assert(0); /* impossible */
+    return 0;
+}
+
+static size_t ZSTD_estimateSubBlockSize_symbolType(symbolEncodingType_e type,
+                        const BYTE* codeTable, unsigned maxCode,
+                        size_t nbSeq, const FSE_CTable* fseCTable,
+                        const U8* additionalBits,
+                        short const* defaultNorm, U32 defaultNormLog, U32 defaultMax,
+                        void* workspace, size_t wkspSize)
+{
+    unsigned* const countWksp = (unsigned*)workspace;
+    const BYTE* ctp = codeTable;
+    const BYTE* const ctStart = ctp;
+    const BYTE* const ctEnd = ctStart + nbSeq;
+    size_t cSymbolTypeSizeEstimateInBits = 0;
+    unsigned max = maxCode;
+
+    HIST_countFast_wksp(countWksp, &max, codeTable, nbSeq, workspace, wkspSize);  /* can't fail */
+    if (type == set_basic) {
+        /* We selected this encoding type, so it must be valid. */
+        assert(max <= defaultMax);
+        cSymbolTypeSizeEstimateInBits = max <= defaultMax
+                ? ZSTD_crossEntropyCost(defaultNorm, defaultNormLog, countWksp, max)
+                : ERROR(GENERIC);
+    } else if (type == set_rle) {
+        cSymbolTypeSizeEstimateInBits = 0;
+    } else if (type == set_compressed || type == set_repeat) {
+        cSymbolTypeSizeEstimateInBits = ZSTD_fseBitCost(fseCTable, countWksp, max);
+    }
+    if (ZSTD_isError(cSymbolTypeSizeEstimateInBits)) return nbSeq * 10;
+    while (ctp < ctEnd) {
+        if (additionalBits) cSymbolTypeSizeEstimateInBits += additionalBits[*ctp];
+        else cSymbolTypeSizeEstimateInBits += *ctp; /* for offset, offset code is also the number of additional bits */
+        ctp++;
+    }
+    return cSymbolTypeSizeEstimateInBits / 8;
+}
+
+static size_t ZSTD_estimateSubBlockSize_sequences(const BYTE* ofCodeTable,
+                                                  const BYTE* llCodeTable,
+                                                  const BYTE* mlCodeTable,
+                                                  size_t nbSeq,
+                                                  const ZSTD_fseCTables_t* fseTables,
+                                                  const ZSTD_fseCTablesMetadata_t* fseMetadata,
+                                                  void* workspace, size_t wkspSize,
+                                                  int writeEntropy)
+{
+    size_t const sequencesSectionHeaderSize = 3; /* Use hard coded size of 3 bytes */
+    size_t cSeqSizeEstimate = 0;
+    if (nbSeq == 0) return sequencesSectionHeaderSize;
+    cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->ofType, ofCodeTable, MaxOff,
+                                         nbSeq, fseTables->offcodeCTable, NULL,
+                                         OF_defaultNorm, OF_defaultNormLog, DefaultMaxOff,
+                                         workspace, wkspSize);
+    cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->llType, llCodeTable, MaxLL,
+                                         nbSeq, fseTables->litlengthCTable, LL_bits,
+                                         LL_defaultNorm, LL_defaultNormLog, MaxLL,
+                                         workspace, wkspSize);
+    cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->mlType, mlCodeTable, MaxML,
+                                         nbSeq, fseTables->matchlengthCTable, ML_bits,
+                                         ML_defaultNorm, ML_defaultNormLog, MaxML,
+                                         workspace, wkspSize);
+    if (writeEntropy) cSeqSizeEstimate += fseMetadata->fseTablesSize;
+    return cSeqSizeEstimate + sequencesSectionHeaderSize;
+}
+
+static size_t ZSTD_estimateSubBlockSize(const BYTE* literals, size_t litSize,
+                                        const BYTE* ofCodeTable,
+                                        const BYTE* llCodeTable,
+                                        const BYTE* mlCodeTable,
+                                        size_t nbSeq,
+                                        const ZSTD_entropyCTables_t* entropy,
+                                        const ZSTD_entropyCTablesMetadata_t* entropyMetadata,
+                                        void* workspace, size_t wkspSize,
+                                        int writeLitEntropy, int writeSeqEntropy) {
+    size_t cSizeEstimate = 0;
+    cSizeEstimate += ZSTD_estimateSubBlockSize_literal(literals, litSize,
+                                                         &entropy->huf, &entropyMetadata->hufMetadata,
+                                                         workspace, wkspSize, writeLitEntropy);
+    cSizeEstimate += ZSTD_estimateSubBlockSize_sequences(ofCodeTable, llCodeTable, mlCodeTable,
+                                                         nbSeq, &entropy->fse, &entropyMetadata->fseMetadata,
+                                                         workspace, wkspSize, writeSeqEntropy);
+    return cSizeEstimate + ZSTD_blockHeaderSize;
+}
+
+static int ZSTD_needSequenceEntropyTables(ZSTD_fseCTablesMetadata_t const* fseMetadata)
+{
+    if (fseMetadata->llType == set_compressed || fseMetadata->llType == set_rle)
+        return 1;
+    if (fseMetadata->mlType == set_compressed || fseMetadata->mlType == set_rle)
+        return 1;
+    if (fseMetadata->ofType == set_compressed || fseMetadata->ofType == set_rle)
+        return 1;
+    return 0;
+}
+
+/** ZSTD_compressSubBlock_multi() :
+ *  Breaks super-block into multiple sub-blocks and compresses them.
+ *  Entropy will be written to the first block.
+ *  The following blocks will use repeat mode to compress.
+ *  All sub-blocks are compressed blocks (no raw or rle blocks).
+ *  @return : compressed size of the super block (which is multiple ZSTD blocks)
+ *            Or 0 if it failed to compress. */
+static size_t ZSTD_compressSubBlock_multi(const seqStore_t* seqStorePtr,
+                            const ZSTD_compressedBlockState_t* prevCBlock,
+                            ZSTD_compressedBlockState_t* nextCBlock,
+                            const ZSTD_entropyCTablesMetadata_t* entropyMetadata,
+                            const ZSTD_CCtx_params* cctxParams,
+                                  void* dst, size_t dstCapacity,
+                            const void* src, size_t srcSize,
+                            const int bmi2, U32 lastBlock,
+                            void* workspace, size_t wkspSize)
+{
+    const seqDef* const sstart = seqStorePtr->sequencesStart;
+    const seqDef* const send = seqStorePtr->sequences;
+    const seqDef* sp = sstart;
+    const BYTE* const lstart = seqStorePtr->litStart;
+    const BYTE* const lend = seqStorePtr->lit;
+    const BYTE* lp = lstart;
+    BYTE const* ip = (BYTE const*)src;
+    BYTE const* const iend = ip + srcSize;
+    BYTE* const ostart = (BYTE*)dst;
+    BYTE* const oend = ostart + dstCapacity;
+    BYTE* op = ostart;
+    const BYTE* llCodePtr = seqStorePtr->llCode;
+    const BYTE* mlCodePtr = seqStorePtr->mlCode;
+    const BYTE* ofCodePtr = seqStorePtr->ofCode;
+    size_t targetCBlockSize = cctxParams->targetCBlockSize;
+    size_t litSize, seqCount;
+    int writeLitEntropy = entropyMetadata->hufMetadata.hType == set_compressed;
+    int writeSeqEntropy = 1;
+    int lastSequence = 0;
+
+    DEBUGLOG(5, "ZSTD_compressSubBlock_multi (litSize=%u, nbSeq=%u)",
+                (unsigned)(lend-lp), (unsigned)(send-sstart));
+
+    litSize = 0;
+    seqCount = 0;
+    do {
+        size_t cBlockSizeEstimate = 0;
+        if (sstart == send) {
+            lastSequence = 1;
+        } else {
+            const seqDef* const sequence = sp + seqCount;
+            lastSequence = sequence == send - 1;
+            litSize += ZSTD_getSequenceLength(seqStorePtr, sequence).litLength;
+            seqCount++;
+        }
+        if (lastSequence) {
+            assert(lp <= lend);
+            assert(litSize <= (size_t)(lend - lp));
+            litSize = (size_t)(lend - lp);
+        }
+        /* I think there is an optimization opportunity here.
+         * Calling ZSTD_estimateSubBlockSize for every sequence can be wasteful
+         * since it recalculates estimate from scratch.
+         * For example, it would recount literal distribution and symbol codes every time.
+         */
+        cBlockSizeEstimate = ZSTD_estimateSubBlockSize(lp, litSize, ofCodePtr, llCodePtr, mlCodePtr, seqCount,
+                                                       &nextCBlock->entropy, entropyMetadata,
+                                                       workspace, wkspSize, writeLitEntropy, writeSeqEntropy);
+        if (cBlockSizeEstimate > targetCBlockSize || lastSequence) {
+            int litEntropyWritten = 0;
+            int seqEntropyWritten = 0;
+            const size_t decompressedSize = ZSTD_seqDecompressedSize(seqStorePtr, sp, seqCount, litSize, lastSequence);
+            const size_t cSize = ZSTD_compressSubBlock(&nextCBlock->entropy, entropyMetadata,
+                                                       sp, seqCount,
+                                                       lp, litSize,
+                                                       llCodePtr, mlCodePtr, ofCodePtr,
+                                                       cctxParams,
+                                                       op, oend-op,
+                                                       bmi2, writeLitEntropy, writeSeqEntropy,
+                                                       &litEntropyWritten, &seqEntropyWritten,
+                                                       lastBlock && lastSequence);
+            FORWARD_IF_ERROR(cSize, "ZSTD_compressSubBlock failed");
+            if (cSize > 0 && cSize < decompressedSize) {
+                DEBUGLOG(5, "Committed the sub-block");
+                assert(ip + decompressedSize <= iend);
+                ip += decompressedSize;
+                sp += seqCount;
+                lp += litSize;
+                op += cSize;
+                llCodePtr += seqCount;
+                mlCodePtr += seqCount;
+                ofCodePtr += seqCount;
+                litSize = 0;
+                seqCount = 0;
+                /* Entropy only needs to be written once */
+                if (litEntropyWritten) {
+                    writeLitEntropy = 0;
+                }
+                if (seqEntropyWritten) {
+                    writeSeqEntropy = 0;
+                }
+            }
+        }
+    } while (!lastSequence);
+    if (writeLitEntropy) {
+        DEBUGLOG(5, "ZSTD_compressSubBlock_multi has literal entropy tables unwritten");
+        ZSTD_memcpy(&nextCBlock->entropy.huf, &prevCBlock->entropy.huf, sizeof(prevCBlock->entropy.huf));
+    }
+    if (writeSeqEntropy && ZSTD_needSequenceEntropyTables(&entropyMetadata->fseMetadata)) {
+        /* If we haven't written our entropy tables, then we've violated our contract and
+         * must emit an uncompressed block.
+         */
+        DEBUGLOG(5, "ZSTD_compressSubBlock_multi has sequence entropy tables unwritten");
+        return 0;
+    }
+    if (ip < iend) {
+        size_t const cSize = ZSTD_noCompressBlock(op, oend - op, ip, iend - ip, lastBlock);
+        DEBUGLOG(5, "ZSTD_compressSubBlock_multi last sub-block uncompressed, %zu bytes", (size_t)(iend - ip));
+        FORWARD_IF_ERROR(cSize, "ZSTD_noCompressBlock failed");
+        assert(cSize != 0);
+        op += cSize;
+        /* We have to regenerate the repcodes because we've skipped some sequences */
+        if (sp < send) {
+            seqDef const* seq;
+            repcodes_t rep;
+            ZSTD_memcpy(&rep, prevCBlock->rep, sizeof(rep));
+            for (seq = sstart; seq < sp; ++seq) {
+                ZSTD_updateRep(rep.rep, seq->offBase, ZSTD_getSequenceLength(seqStorePtr, seq).litLength == 0);
+            }
+            ZSTD_memcpy(nextCBlock->rep, &rep, sizeof(rep));
+        }
+    }
+    DEBUGLOG(5, "ZSTD_compressSubBlock_multi compressed");
+    return op-ostart;
+}
+
+size_t ZSTD_compressSuperBlock(ZSTD_CCtx* zc,
+                               void* dst, size_t dstCapacity,
+                               void const* src, size_t srcSize,
+                               unsigned lastBlock) {
+    ZSTD_entropyCTablesMetadata_t entropyMetadata;
+
+    FORWARD_IF_ERROR(ZSTD_buildBlockEntropyStats(&zc->seqStore,
+          &zc->blockState.prevCBlock->entropy,
+          &zc->blockState.nextCBlock->entropy,
+          &zc->appliedParams,
+          &entropyMetadata,
+          zc->entropyWorkspace, ENTROPY_WORKSPACE_SIZE /* statically allocated in resetCCtx */), "");
+
+    return ZSTD_compressSubBlock_multi(&zc->seqStore,
+            zc->blockState.prevCBlock,
+            zc->blockState.nextCBlock,
+            &entropyMetadata,
+            &zc->appliedParams,
+            dst, dstCapacity,
+            src, srcSize,
+            zc->bmi2, lastBlock,
+            zc->entropyWorkspace, ENTROPY_WORKSPACE_SIZE /* statically allocated in resetCCtx */);
+}
diff --git a/src/3rdparty/zstd/src/compress/zstd_compress_superblock.h b/src/3rdparty/zstd/src/compress/zstd_compress_superblock.h
new file mode 100644
index 0000000000..8e494f0d5e
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_compress_superblock.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_COMPRESS_ADVANCED_H
+#define ZSTD_COMPRESS_ADVANCED_H
+
+/*-*************************************
+*  Dependencies
+***************************************/
+
+#include "../zstd.h" /* ZSTD_CCtx */
+
+/*-*************************************
+*  Target Compressed Block Size
+***************************************/
+
+/* ZSTD_compressSuperBlock() :
+ * Used to compress a super block when targetCBlockSize is being used.
+ * The given block will be compressed into multiple sub blocks that are around targetCBlockSize. */
+size_t ZSTD_compressSuperBlock(ZSTD_CCtx* zc,
+                               void* dst, size_t dstCapacity,
+                               void const* src, size_t srcSize,
+                               unsigned lastBlock);
+
+#endif /* ZSTD_COMPRESS_ADVANCED_H */
diff --git a/src/3rdparty/zstd/src/compress/zstd_cwksp.h b/src/3rdparty/zstd/src/compress/zstd_cwksp.h
new file mode 100644
index 0000000000..cc7fb1c715
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_cwksp.h
@@ -0,0 +1,742 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_CWKSP_H
+#define ZSTD_CWKSP_H
+
+/*-*************************************
+*  Dependencies
+***************************************/
+#include "../common/allocations.h"  /* ZSTD_customMalloc, ZSTD_customFree */
+#include "../common/zstd_internal.h"
+#include "../common/portability_macros.h"
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+/*-*************************************
+*  Constants
+***************************************/
+
+/* Since the workspace is effectively its own little malloc implementation /
+ * arena, when we run under ASAN, we should similarly insert redzones between
+ * each internal element of the workspace, so ASAN will catch overruns that
+ * reach outside an object but that stay inside the workspace.
+ *
+ * This defines the size of that redzone.
+ */
+#ifndef ZSTD_CWKSP_ASAN_REDZONE_SIZE
+#define ZSTD_CWKSP_ASAN_REDZONE_SIZE 128
+#endif
+
+
+/* Set our tables and aligneds to align by 64 bytes */
+#define ZSTD_CWKSP_ALIGNMENT_BYTES 64
+
+/*-*************************************
+*  Structures
+***************************************/
+typedef enum {
+    ZSTD_cwksp_alloc_objects,
+    ZSTD_cwksp_alloc_aligned_init_once,
+    ZSTD_cwksp_alloc_aligned,
+    ZSTD_cwksp_alloc_buffers
+} ZSTD_cwksp_alloc_phase_e;
+
+/**
+ * Used to describe whether the workspace is statically allocated (and will not
+ * necessarily ever be freed), or if it's dynamically allocated and we can
+ * expect a well-formed caller to free this.
+ */
+typedef enum {
+    ZSTD_cwksp_dynamic_alloc,
+    ZSTD_cwksp_static_alloc
+} ZSTD_cwksp_static_alloc_e;
+
+/**
+ * Zstd fits all its internal datastructures into a single continuous buffer,
+ * so that it only needs to perform a single OS allocation (or so that a buffer
+ * can be provided to it and it can perform no allocations at all). This buffer
+ * is called the workspace.
+ *
+ * Several optimizations complicate that process of allocating memory ranges
+ * from this workspace for each internal datastructure:
+ *
+ * - These different internal datastructures have different setup requirements:
+ *
+ *   - The static objects need to be cleared once and can then be trivially
+ *     reused for each compression.
+ *
+ *   - Various buffers don't need to be initialized at all--they are always
+ *     written into before they're read.
+ *
+ *   - The matchstate tables have a unique requirement that they don't need
+ *     their memory to be totally cleared, but they do need the memory to have
+ *     some bound, i.e., a guarantee that all values in the memory they've been
+ *     allocated is less than some maximum value (which is the starting value
+ *     for the indices that they will then use for compression). When this
+ *     guarantee is provided to them, they can use the memory without any setup
+ *     work. When it can't, they have to clear the area.
+ *
+ * - These buffers also have different alignment requirements.
+ *
+ * - We would like to reuse the objects in the workspace for multiple
+ *   compressions without having to perform any expensive reallocation or
+ *   reinitialization work.
+ *
+ * - We would like to be able to efficiently reuse the workspace across
+ *   multiple compressions **even when the compression parameters change** and
+ *   we need to resize some of the objects (where possible).
+ *
+ * To attempt to manage this buffer, given these constraints, the ZSTD_cwksp
+ * abstraction was created. It works as follows:
+ *
+ * Workspace Layout:
+ *
+ * [                        ... workspace ...                           ]
+ * [objects][tables ->] free space [<- buffers][<- aligned][<- init once]
+ *
+ * The various objects that live in the workspace are divided into the
+ * following categories, and are allocated separately:
+ *
+ * - Static objects: this is optionally the enclosing ZSTD_CCtx or ZSTD_CDict,
+ *   so that literally everything fits in a single buffer. Note: if present,
+ *   this must be the first object in the workspace, since ZSTD_customFree{CCtx,
+ *   CDict}() rely on a pointer comparison to see whether one or two frees are
+ *   required.
+ *
+ * - Fixed size objects: these are fixed-size, fixed-count objects that are
+ *   nonetheless "dynamically" allocated in the workspace so that we can
+ *   control how they're initialized separately from the broader ZSTD_CCtx.
+ *   Examples:
+ *   - Entropy Workspace
+ *   - 2 x ZSTD_compressedBlockState_t
+ *   - CDict dictionary contents
+ *
+ * - Tables: these are any of several different datastructures (hash tables,
+ *   chain tables, binary trees) that all respect a common format: they are
+ *   uint32_t arrays, all of whose values are between 0 and (nextSrc - base).
+ *   Their sizes depend on the cparams. These tables are 64-byte aligned.
+ *
+ * - Init once: these buffers require to be initialized at least once before
+ *   use. They should be used when we want to skip memory initialization
+ *   while not triggering memory checkers (like Valgrind) when reading from
+ *   from this memory without writing to it first.
+ *   These buffers should be used carefully as they might contain data
+ *   from previous compressions.
+ *   Buffers are aligned to 64 bytes.
+ *
+ * - Aligned: these buffers don't require any initialization before they're
+ *   used. The user of the buffer should make sure they write into a buffer
+ *   location before reading from it.
+ *   Buffers are aligned to 64 bytes.
+ *
+ * - Buffers: these buffers are used for various purposes that don't require
+ *   any alignment or initialization before they're used. This means they can
+ *   be moved around at no cost for a new compression.
+ *
+ * Allocating Memory:
+ *
+ * The various types of objects must be allocated in order, so they can be
+ * correctly packed into the workspace buffer. That order is:
+ *
+ * 1. Objects
+ * 2. Init once / Tables
+ * 3. Aligned / Tables
+ * 4. Buffers / Tables
+ *
+ * Attempts to reserve objects of different types out of order will fail.
+ */
+typedef struct {
+    void* workspace;
+    void* workspaceEnd;
+
+    void* objectEnd;
+    void* tableEnd;
+    void* tableValidEnd;
+    void* allocStart;
+    void* initOnceStart;
+
+    BYTE allocFailed;
+    int workspaceOversizedDuration;
+    ZSTD_cwksp_alloc_phase_e phase;
+    ZSTD_cwksp_static_alloc_e isStatic;
+} ZSTD_cwksp;
+
+/*-*************************************
+*  Functions
+***************************************/
+
+MEM_STATIC size_t ZSTD_cwksp_available_space(ZSTD_cwksp* ws);
+MEM_STATIC void*  ZSTD_cwksp_initialAllocStart(ZSTD_cwksp* ws);
+
+MEM_STATIC void ZSTD_cwksp_assert_internal_consistency(ZSTD_cwksp* ws) {
+    (void)ws;
+    assert(ws->workspace <= ws->objectEnd);
+    assert(ws->objectEnd <= ws->tableEnd);
+    assert(ws->objectEnd <= ws->tableValidEnd);
+    assert(ws->tableEnd <= ws->allocStart);
+    assert(ws->tableValidEnd <= ws->allocStart);
+    assert(ws->allocStart <= ws->workspaceEnd);
+    assert(ws->initOnceStart <= ZSTD_cwksp_initialAllocStart(ws));
+    assert(ws->workspace <= ws->initOnceStart);
+#if ZSTD_MEMORY_SANITIZER
+    {
+        intptr_t const offset = __msan_test_shadow(ws->initOnceStart,
+            (U8*)ZSTD_cwksp_initialAllocStart(ws) - (U8*)ws->initOnceStart);
+#if defined(ZSTD_MSAN_PRINT)
+        if(offset!=-1) {
+            __msan_print_shadow((U8*)ws->initOnceStart + offset - 8, 32);
+        }
+#endif
+        assert(offset==-1);
+    };
+#endif
+}
+
+/**
+ * Align must be a power of 2.
+ */
+MEM_STATIC size_t ZSTD_cwksp_align(size_t size, size_t const align) {
+    size_t const mask = align - 1;
+    assert((align & mask) == 0);
+    return (size + mask) & ~mask;
+}
+
+/**
+ * Use this to determine how much space in the workspace we will consume to
+ * allocate this object. (Normally it should be exactly the size of the object,
+ * but under special conditions, like ASAN, where we pad each object, it might
+ * be larger.)
+ *
+ * Since tables aren't currently redzoned, you don't need to call through this
+ * to figure out how much space you need for the matchState tables. Everything
+ * else is though.
+ *
+ * Do not use for sizing aligned buffers. Instead, use ZSTD_cwksp_aligned_alloc_size().
+ */
+MEM_STATIC size_t ZSTD_cwksp_alloc_size(size_t size) {
+    if (size == 0)
+        return 0;
+#if ZSTD_ADDRESS_SANITIZER && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
+    return size + 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
+#else
+    return size;
+#endif
+}
+
+/**
+ * Returns an adjusted alloc size that is the nearest larger multiple of 64 bytes.
+ * Used to determine the number of bytes required for a given "aligned".
+ */
+MEM_STATIC size_t ZSTD_cwksp_aligned_alloc_size(size_t size) {
+    return ZSTD_cwksp_alloc_size(ZSTD_cwksp_align(size, ZSTD_CWKSP_ALIGNMENT_BYTES));
+}
+
+/**
+ * Returns the amount of additional space the cwksp must allocate
+ * for internal purposes (currently only alignment).
+ */
+MEM_STATIC size_t ZSTD_cwksp_slack_space_required(void) {
+    /* For alignment, the wksp will always allocate an additional 2*ZSTD_CWKSP_ALIGNMENT_BYTES
+     * bytes to align the beginning of tables section and end of buffers;
+     */
+    size_t const slackSpace = ZSTD_CWKSP_ALIGNMENT_BYTES * 2;
+    return slackSpace;
+}
+
+
+/**
+ * Return the number of additional bytes required to align a pointer to the given number of bytes.
+ * alignBytes must be a power of two.
+ */
+MEM_STATIC size_t ZSTD_cwksp_bytes_to_align_ptr(void* ptr, const size_t alignBytes) {
+    size_t const alignBytesMask = alignBytes - 1;
+    size_t const bytes = (alignBytes - ((size_t)ptr & (alignBytesMask))) & alignBytesMask;
+    assert((alignBytes & alignBytesMask) == 0);
+    assert(bytes < alignBytes);
+    return bytes;
+}
+
+/**
+ * Returns the initial value for allocStart which is used to determine the position from
+ * which we can allocate from the end of the workspace.
+ */
+MEM_STATIC void*  ZSTD_cwksp_initialAllocStart(ZSTD_cwksp* ws) {
+    return (void*)((size_t)ws->workspaceEnd & ~(ZSTD_CWKSP_ALIGNMENT_BYTES-1));
+}
+
+/**
+ * Internal function. Do not use directly.
+ * Reserves the given number of bytes within the aligned/buffer segment of the wksp,
+ * which counts from the end of the wksp (as opposed to the object/table segment).
+ *
+ * Returns a pointer to the beginning of that space.
+ */
+MEM_STATIC void*
+ZSTD_cwksp_reserve_internal_buffer_space(ZSTD_cwksp* ws, size_t const bytes)
+{
+    void* const alloc = (BYTE*)ws->allocStart - bytes;
+    void* const bottom = ws->tableEnd;
+    DEBUGLOG(5, "cwksp: reserving %p %zd bytes, %zd bytes remaining",
+        alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
+    ZSTD_cwksp_assert_internal_consistency(ws);
+    assert(alloc >= bottom);
+    if (alloc < bottom) {
+        DEBUGLOG(4, "cwksp: alloc failed!");
+        ws->allocFailed = 1;
+        return NULL;
+    }
+    /* the area is reserved from the end of wksp.
+     * If it overlaps with tableValidEnd, it voids guarantees on values' range */
+    if (alloc < ws->tableValidEnd) {
+        ws->tableValidEnd = alloc;
+    }
+    ws->allocStart = alloc;
+    return alloc;
+}
+
+/**
+ * Moves the cwksp to the next phase, and does any necessary allocations.
+ * cwksp initialization must necessarily go through each phase in order.
+ * Returns a 0 on success, or zstd error
+ */
+MEM_STATIC size_t
+ZSTD_cwksp_internal_advance_phase(ZSTD_cwksp* ws, ZSTD_cwksp_alloc_phase_e phase)
+{
+    assert(phase >= ws->phase);
+    if (phase > ws->phase) {
+        /* Going from allocating objects to allocating initOnce / tables */
+        if (ws->phase < ZSTD_cwksp_alloc_aligned_init_once &&
+            phase >= ZSTD_cwksp_alloc_aligned_init_once) {
+            ws->tableValidEnd = ws->objectEnd;
+            ws->initOnceStart = ZSTD_cwksp_initialAllocStart(ws);
+
+            {   /* Align the start of the tables to 64 bytes. Use [0, 63] bytes */
+                void *const alloc = ws->objectEnd;
+                size_t const bytesToAlign = ZSTD_cwksp_bytes_to_align_ptr(alloc, ZSTD_CWKSP_ALIGNMENT_BYTES);
+                void *const objectEnd = (BYTE *) alloc + bytesToAlign;
+                DEBUGLOG(5, "reserving table alignment addtl space: %zu", bytesToAlign);
+                RETURN_ERROR_IF(objectEnd > ws->workspaceEnd, memory_allocation,
+                                "table phase - alignment initial allocation failed!");
+                ws->objectEnd = objectEnd;
+                ws->tableEnd = objectEnd;  /* table area starts being empty */
+                if (ws->tableValidEnd < ws->tableEnd) {
+                    ws->tableValidEnd = ws->tableEnd;
+                }
+            }
+        }
+        ws->phase = phase;
+        ZSTD_cwksp_assert_internal_consistency(ws);
+    }
+    return 0;
+}
+
+/**
+ * Returns whether this object/buffer/etc was allocated in this workspace.
+ */
+MEM_STATIC int ZSTD_cwksp_owns_buffer(const ZSTD_cwksp* ws, const void* ptr)
+{
+    return (ptr != NULL) && (ws->workspace <= ptr) && (ptr < ws->workspaceEnd);
+}
+
+/**
+ * Internal function. Do not use directly.
+ */
+MEM_STATIC void*
+ZSTD_cwksp_reserve_internal(ZSTD_cwksp* ws, size_t bytes, ZSTD_cwksp_alloc_phase_e phase)
+{
+    void* alloc;
+    if (ZSTD_isError(ZSTD_cwksp_internal_advance_phase(ws, phase)) || bytes == 0) {
+        return NULL;
+    }
+
+#if ZSTD_ADDRESS_SANITIZER && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
+    /* over-reserve space */
+    bytes += 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
+#endif
+
+    alloc = ZSTD_cwksp_reserve_internal_buffer_space(ws, bytes);
+
+#if ZSTD_ADDRESS_SANITIZER && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
+    /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
+     * either size. */
+    if (alloc) {
+        alloc = (BYTE *)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
+        if (ws->isStatic == ZSTD_cwksp_dynamic_alloc) {
+            /* We need to keep the redzone poisoned while unpoisoning the bytes that
+             * are actually allocated. */
+            __asan_unpoison_memory_region(alloc, bytes - 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE);
+        }
+    }
+#endif
+
+    return alloc;
+}
+
+/**
+ * Reserves and returns unaligned memory.
+ */
+MEM_STATIC BYTE* ZSTD_cwksp_reserve_buffer(ZSTD_cwksp* ws, size_t bytes)
+{
+    return (BYTE*)ZSTD_cwksp_reserve_internal(ws, bytes, ZSTD_cwksp_alloc_buffers);
+}
+
+/**
+ * Reserves and returns memory sized on and aligned on ZSTD_CWKSP_ALIGNMENT_BYTES (64 bytes).
+ * This memory has been initialized at least once in the past.
+ * This doesn't mean it has been initialized this time, and it might contain data from previous
+ * operations.
+ * The main usage is for algorithms that might need read access into uninitialized memory.
+ * The algorithm must maintain safety under these conditions and must make sure it doesn't
+ * leak any of the past data (directly or in side channels).
+ */
+MEM_STATIC void* ZSTD_cwksp_reserve_aligned_init_once(ZSTD_cwksp* ws, size_t bytes)
+{
+    size_t const alignedBytes = ZSTD_cwksp_align(bytes, ZSTD_CWKSP_ALIGNMENT_BYTES);
+    void* ptr = ZSTD_cwksp_reserve_internal(ws, alignedBytes, ZSTD_cwksp_alloc_aligned_init_once);
+    assert(((size_t)ptr & (ZSTD_CWKSP_ALIGNMENT_BYTES-1))== 0);
+    if(ptr && ptr < ws->initOnceStart) {
+        /* We assume the memory following the current allocation is either:
+         * 1. Not usable as initOnce memory (end of workspace)
+         * 2. Another initOnce buffer that has been allocated before (and so was previously memset)
+         * 3. An ASAN redzone, in which case we don't want to write on it
+         * For these reasons it should be fine to not explicitly zero every byte up to ws->initOnceStart.
+         * Note that we assume here that MSAN and ASAN cannot run in the same time. */
+        ZSTD_memset(ptr, 0, MIN((size_t)((U8*)ws->initOnceStart - (U8*)ptr), alignedBytes));
+        ws->initOnceStart = ptr;
+    }
+#if ZSTD_MEMORY_SANITIZER
+    assert(__msan_test_shadow(ptr, bytes) == -1);
+#endif
+    return ptr;
+}
+
+/**
+ * Reserves and returns memory sized on and aligned on ZSTD_CWKSP_ALIGNMENT_BYTES (64 bytes).
+ */
+MEM_STATIC void* ZSTD_cwksp_reserve_aligned(ZSTD_cwksp* ws, size_t bytes)
+{
+    void* ptr = ZSTD_cwksp_reserve_internal(ws, ZSTD_cwksp_align(bytes, ZSTD_CWKSP_ALIGNMENT_BYTES),
+                                            ZSTD_cwksp_alloc_aligned);
+    assert(((size_t)ptr & (ZSTD_CWKSP_ALIGNMENT_BYTES-1))== 0);
+    return ptr;
+}
+
+/**
+ * Aligned on 64 bytes. These buffers have the special property that
+ * their values remain constrained, allowing us to re-use them without
+ * memset()-ing them.
+ */
+MEM_STATIC void* ZSTD_cwksp_reserve_table(ZSTD_cwksp* ws, size_t bytes)
+{
+    const ZSTD_cwksp_alloc_phase_e phase = ZSTD_cwksp_alloc_aligned_init_once;
+    void* alloc;
+    void* end;
+    void* top;
+
+    /* We can only start allocating tables after we are done reserving space for objects at the
+     * start of the workspace */
+    if(ws->phase < phase) {
+        if (ZSTD_isError(ZSTD_cwksp_internal_advance_phase(ws, phase))) {
+            return NULL;
+        }
+    }
+    alloc = ws->tableEnd;
+    end = (BYTE *)alloc + bytes;
+    top = ws->allocStart;
+
+    DEBUGLOG(5, "cwksp: reserving %p table %zd bytes, %zd bytes remaining",
+        alloc, bytes, ZSTD_cwksp_available_space(ws) - bytes);
+    assert((bytes & (sizeof(U32)-1)) == 0);
+    ZSTD_cwksp_assert_internal_consistency(ws);
+    assert(end <= top);
+    if (end > top) {
+        DEBUGLOG(4, "cwksp: table alloc failed!");
+        ws->allocFailed = 1;
+        return NULL;
+    }
+    ws->tableEnd = end;
+
+#if ZSTD_ADDRESS_SANITIZER && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
+    if (ws->isStatic == ZSTD_cwksp_dynamic_alloc) {
+        __asan_unpoison_memory_region(alloc, bytes);
+    }
+#endif
+
+    assert((bytes & (ZSTD_CWKSP_ALIGNMENT_BYTES-1)) == 0);
+    assert(((size_t)alloc & (ZSTD_CWKSP_ALIGNMENT_BYTES-1))== 0);
+    return alloc;
+}
+
+/**
+ * Aligned on sizeof(void*).
+ * Note : should happen only once, at workspace first initialization
+ */
+MEM_STATIC void* ZSTD_cwksp_reserve_object(ZSTD_cwksp* ws, size_t bytes)
+{
+    size_t const roundedBytes = ZSTD_cwksp_align(bytes, sizeof(void*));
+    void* alloc = ws->objectEnd;
+    void* end = (BYTE*)alloc + roundedBytes;
+
+#if ZSTD_ADDRESS_SANITIZER && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
+    /* over-reserve space */
+    end = (BYTE *)end + 2 * ZSTD_CWKSP_ASAN_REDZONE_SIZE;
+#endif
+
+    DEBUGLOG(4,
+        "cwksp: reserving %p object %zd bytes (rounded to %zd), %zd bytes remaining",
+        alloc, bytes, roundedBytes, ZSTD_cwksp_available_space(ws) - roundedBytes);
+    assert((size_t)alloc % ZSTD_ALIGNOF(void*) == 0);
+    assert(bytes % ZSTD_ALIGNOF(void*) == 0);
+    ZSTD_cwksp_assert_internal_consistency(ws);
+    /* we must be in the first phase, no advance is possible */
+    if (ws->phase != ZSTD_cwksp_alloc_objects || end > ws->workspaceEnd) {
+        DEBUGLOG(3, "cwksp: object alloc failed!");
+        ws->allocFailed = 1;
+        return NULL;
+    }
+    ws->objectEnd = end;
+    ws->tableEnd = end;
+    ws->tableValidEnd = end;
+
+#if ZSTD_ADDRESS_SANITIZER && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
+    /* Move alloc so there's ZSTD_CWKSP_ASAN_REDZONE_SIZE unused space on
+     * either size. */
+    alloc = (BYTE*)alloc + ZSTD_CWKSP_ASAN_REDZONE_SIZE;
+    if (ws->isStatic == ZSTD_cwksp_dynamic_alloc) {
+        __asan_unpoison_memory_region(alloc, bytes);
+    }
+#endif
+
+    return alloc;
+}
+
+MEM_STATIC void ZSTD_cwksp_mark_tables_dirty(ZSTD_cwksp* ws)
+{
+    DEBUGLOG(4, "cwksp: ZSTD_cwksp_mark_tables_dirty");
+
+#if ZSTD_MEMORY_SANITIZER && !defined (ZSTD_MSAN_DONT_POISON_WORKSPACE)
+    /* To validate that the table re-use logic is sound, and that we don't
+     * access table space that we haven't cleaned, we re-"poison" the table
+     * space every time we mark it dirty.
+     * Since tableValidEnd space and initOnce space may overlap we don't poison
+     * the initOnce portion as it break its promise. This means that this poisoning
+     * check isn't always applied fully. */
+    {
+        size_t size = (BYTE*)ws->tableValidEnd - (BYTE*)ws->objectEnd;
+        assert(__msan_test_shadow(ws->objectEnd, size) == -1);
+        if((BYTE*)ws->tableValidEnd < (BYTE*)ws->initOnceStart) {
+            __msan_poison(ws->objectEnd, size);
+        } else {
+            assert(ws->initOnceStart >= ws->objectEnd);
+            __msan_poison(ws->objectEnd, (BYTE*)ws->initOnceStart - (BYTE*)ws->objectEnd);
+        }
+    }
+#endif
+
+    assert(ws->tableValidEnd >= ws->objectEnd);
+    assert(ws->tableValidEnd <= ws->allocStart);
+    ws->tableValidEnd = ws->objectEnd;
+    ZSTD_cwksp_assert_internal_consistency(ws);
+}
+
+MEM_STATIC void ZSTD_cwksp_mark_tables_clean(ZSTD_cwksp* ws) {
+    DEBUGLOG(4, "cwksp: ZSTD_cwksp_mark_tables_clean");
+    assert(ws->tableValidEnd >= ws->objectEnd);
+    assert(ws->tableValidEnd <= ws->allocStart);
+    if (ws->tableValidEnd < ws->tableEnd) {
+        ws->tableValidEnd = ws->tableEnd;
+    }
+    ZSTD_cwksp_assert_internal_consistency(ws);
+}
+
+/**
+ * Zero the part of the allocated tables not already marked clean.
+ */
+MEM_STATIC void ZSTD_cwksp_clean_tables(ZSTD_cwksp* ws) {
+    DEBUGLOG(4, "cwksp: ZSTD_cwksp_clean_tables");
+    assert(ws->tableValidEnd >= ws->objectEnd);
+    assert(ws->tableValidEnd <= ws->allocStart);
+    if (ws->tableValidEnd < ws->tableEnd) {
+        ZSTD_memset(ws->tableValidEnd, 0, (size_t)((BYTE*)ws->tableEnd - (BYTE*)ws->tableValidEnd));
+    }
+    ZSTD_cwksp_mark_tables_clean(ws);
+}
+
+/**
+ * Invalidates table allocations.
+ * All other allocations remain valid.
+ */
+MEM_STATIC void ZSTD_cwksp_clear_tables(ZSTD_cwksp* ws) {
+    DEBUGLOG(4, "cwksp: clearing tables!");
+
+#if ZSTD_ADDRESS_SANITIZER && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
+    /* We don't do this when the workspace is statically allocated, because
+     * when that is the case, we have no capability to hook into the end of the
+     * workspace's lifecycle to unpoison the memory.
+     */
+    if (ws->isStatic == ZSTD_cwksp_dynamic_alloc) {
+        size_t size = (BYTE*)ws->tableValidEnd - (BYTE*)ws->objectEnd;
+        __asan_poison_memory_region(ws->objectEnd, size);
+    }
+#endif
+
+    ws->tableEnd = ws->objectEnd;
+    ZSTD_cwksp_assert_internal_consistency(ws);
+}
+
+/**
+ * Invalidates all buffer, aligned, and table allocations.
+ * Object allocations remain valid.
+ */
+MEM_STATIC void ZSTD_cwksp_clear(ZSTD_cwksp* ws) {
+    DEBUGLOG(4, "cwksp: clearing!");
+
+#if ZSTD_MEMORY_SANITIZER && !defined (ZSTD_MSAN_DONT_POISON_WORKSPACE)
+    /* To validate that the context re-use logic is sound, and that we don't
+     * access stuff that this compression hasn't initialized, we re-"poison"
+     * the workspace except for the areas in which we expect memory re-use
+     * without initialization (objects, valid tables area and init once
+     * memory). */
+    {
+        if((BYTE*)ws->tableValidEnd < (BYTE*)ws->initOnceStart) {
+            size_t size = (BYTE*)ws->initOnceStart - (BYTE*)ws->tableValidEnd;
+            __msan_poison(ws->tableValidEnd, size);
+        }
+    }
+#endif
+
+#if ZSTD_ADDRESS_SANITIZER && !defined (ZSTD_ASAN_DONT_POISON_WORKSPACE)
+    /* We don't do this when the workspace is statically allocated, because
+     * when that is the case, we have no capability to hook into the end of the
+     * workspace's lifecycle to unpoison the memory.
+     */
+    if (ws->isStatic == ZSTD_cwksp_dynamic_alloc) {
+        size_t size = (BYTE*)ws->workspaceEnd - (BYTE*)ws->objectEnd;
+        __asan_poison_memory_region(ws->objectEnd, size);
+    }
+#endif
+
+    ws->tableEnd = ws->objectEnd;
+    ws->allocStart = ZSTD_cwksp_initialAllocStart(ws);
+    ws->allocFailed = 0;
+    if (ws->phase > ZSTD_cwksp_alloc_aligned_init_once) {
+        ws->phase = ZSTD_cwksp_alloc_aligned_init_once;
+    }
+    ZSTD_cwksp_assert_internal_consistency(ws);
+}
+
+/**
+ * The provided workspace takes ownership of the buffer [start, start+size).
+ * Any existing values in the workspace are ignored (the previously managed
+ * buffer, if present, must be separately freed).
+ */
+MEM_STATIC void ZSTD_cwksp_init(ZSTD_cwksp* ws, void* start, size_t size, ZSTD_cwksp_static_alloc_e isStatic) {
+    DEBUGLOG(4, "cwksp: init'ing workspace with %zd bytes", size);
+    assert(((size_t)start & (sizeof(void*)-1)) == 0); /* ensure correct alignment */
+    ws->workspace = start;
+    ws->workspaceEnd = (BYTE*)start + size;
+    ws->objectEnd = ws->workspace;
+    ws->tableValidEnd = ws->objectEnd;
+    ws->initOnceStart = ZSTD_cwksp_initialAllocStart(ws);
+    ws->phase = ZSTD_cwksp_alloc_objects;
+    ws->isStatic = isStatic;
+    ZSTD_cwksp_clear(ws);
+    ws->workspaceOversizedDuration = 0;
+    ZSTD_cwksp_assert_internal_consistency(ws);
+}
+
+MEM_STATIC size_t ZSTD_cwksp_create(ZSTD_cwksp* ws, size_t size, ZSTD_customMem customMem) {
+    void* workspace = ZSTD_customMalloc(size, customMem);
+    DEBUGLOG(4, "cwksp: creating new workspace with %zd bytes", size);
+    RETURN_ERROR_IF(workspace == NULL, memory_allocation, "NULL pointer!");
+    ZSTD_cwksp_init(ws, workspace, size, ZSTD_cwksp_dynamic_alloc);
+    return 0;
+}
+
+MEM_STATIC void ZSTD_cwksp_free(ZSTD_cwksp* ws, ZSTD_customMem customMem) {
+    void *ptr = ws->workspace;
+    DEBUGLOG(4, "cwksp: freeing workspace");
+    ZSTD_memset(ws, 0, sizeof(ZSTD_cwksp));
+    ZSTD_customFree(ptr, customMem);
+}
+
+/**
+ * Moves the management of a workspace from one cwksp to another. The src cwksp
+ * is left in an invalid state (src must be re-init()'ed before it's used again).
+ */
+MEM_STATIC void ZSTD_cwksp_move(ZSTD_cwksp* dst, ZSTD_cwksp* src) {
+    *dst = *src;
+    ZSTD_memset(src, 0, sizeof(ZSTD_cwksp));
+}
+
+MEM_STATIC size_t ZSTD_cwksp_sizeof(const ZSTD_cwksp* ws) {
+    return (size_t)((BYTE*)ws->workspaceEnd - (BYTE*)ws->workspace);
+}
+
+MEM_STATIC size_t ZSTD_cwksp_used(const ZSTD_cwksp* ws) {
+    return (size_t)((BYTE*)ws->tableEnd - (BYTE*)ws->workspace)
+         + (size_t)((BYTE*)ws->workspaceEnd - (BYTE*)ws->allocStart);
+}
+
+MEM_STATIC int ZSTD_cwksp_reserve_failed(const ZSTD_cwksp* ws) {
+    return ws->allocFailed;
+}
+
+/*-*************************************
+*  Functions Checking Free Space
+***************************************/
+
+/* ZSTD_alignmentSpaceWithinBounds() :
+ * Returns if the estimated space needed for a wksp is within an acceptable limit of the
+ * actual amount of space used.
+ */
+MEM_STATIC int ZSTD_cwksp_estimated_space_within_bounds(const ZSTD_cwksp *const ws, size_t const estimatedSpace) {
+    /* We have an alignment space between objects and tables between tables and buffers, so we can have up to twice
+     * the alignment bytes difference between estimation and actual usage */
+    return (estimatedSpace - ZSTD_cwksp_slack_space_required()) <= ZSTD_cwksp_used(ws) &&
+           ZSTD_cwksp_used(ws) <= estimatedSpace;
+}
+
+
+MEM_STATIC size_t ZSTD_cwksp_available_space(ZSTD_cwksp* ws) {
+    return (size_t)((BYTE*)ws->allocStart - (BYTE*)ws->tableEnd);
+}
+
+MEM_STATIC int ZSTD_cwksp_check_available(ZSTD_cwksp* ws, size_t additionalNeededSpace) {
+    return ZSTD_cwksp_available_space(ws) >= additionalNeededSpace;
+}
+
+MEM_STATIC int ZSTD_cwksp_check_too_large(ZSTD_cwksp* ws, size_t additionalNeededSpace) {
+    return ZSTD_cwksp_check_available(
+        ws, additionalNeededSpace * ZSTD_WORKSPACETOOLARGE_FACTOR);
+}
+
+MEM_STATIC int ZSTD_cwksp_check_wasteful(ZSTD_cwksp* ws, size_t additionalNeededSpace) {
+    return ZSTD_cwksp_check_too_large(ws, additionalNeededSpace)
+        && ws->workspaceOversizedDuration > ZSTD_WORKSPACETOOLARGE_MAXDURATION;
+}
+
+MEM_STATIC void ZSTD_cwksp_bump_oversized_duration(
+        ZSTD_cwksp* ws, size_t additionalNeededSpace) {
+    if (ZSTD_cwksp_check_too_large(ws, additionalNeededSpace)) {
+        ws->workspaceOversizedDuration++;
+    } else {
+        ws->workspaceOversizedDuration = 0;
+    }
+}
+
+#if defined (__cplusplus)
+}
+#endif
+
+#endif /* ZSTD_CWKSP_H */
diff --git a/src/3rdparty/zstd/src/compress/zstd_double_fast.c b/src/3rdparty/zstd/src/compress/zstd_double_fast.c
new file mode 100644
index 0000000000..0ad88ffc7b
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_double_fast.c
@@ -0,0 +1,758 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#include "zstd_compress_internal.h"
+#include "zstd_double_fast.h"
+
+static void ZSTD_fillDoubleHashTableForCDict(ZSTD_matchState_t* ms,
+                              void const* end, ZSTD_dictTableLoadMethod_e dtlm)
+{
+    const ZSTD_compressionParameters* const cParams = &ms->cParams;
+    U32* const hashLarge = ms->hashTable;
+    U32  const hBitsL = cParams->hashLog + ZSTD_SHORT_CACHE_TAG_BITS;
+    U32  const mls = cParams->minMatch;
+    U32* const hashSmall = ms->chainTable;
+    U32  const hBitsS = cParams->chainLog + ZSTD_SHORT_CACHE_TAG_BITS;
+    const BYTE* const base = ms->window.base;
+    const BYTE* ip = base + ms->nextToUpdate;
+    const BYTE* const iend = ((const BYTE*)end) - HASH_READ_SIZE;
+    const U32 fastHashFillStep = 3;
+
+    /* Always insert every fastHashFillStep position into the hash tables.
+     * Insert the other positions into the large hash table if their entry
+     * is empty.
+     */
+    for (; ip + fastHashFillStep - 1 <= iend; ip += fastHashFillStep) {
+        U32 const curr = (U32)(ip - base);
+        U32 i;
+        for (i = 0; i < fastHashFillStep; ++i) {
+            size_t const smHashAndTag = ZSTD_hashPtr(ip + i, hBitsS, mls);
+            size_t const lgHashAndTag = ZSTD_hashPtr(ip + i, hBitsL, 8);
+            if (i == 0) {
+                ZSTD_writeTaggedIndex(hashSmall, smHashAndTag, curr + i);
+            }
+            if (i == 0 || hashLarge[lgHashAndTag >> ZSTD_SHORT_CACHE_TAG_BITS] == 0) {
+                ZSTD_writeTaggedIndex(hashLarge, lgHashAndTag, curr + i);
+            }
+            /* Only load extra positions for ZSTD_dtlm_full */
+            if (dtlm == ZSTD_dtlm_fast)
+                break;
+    }   }
+}
+
+static void ZSTD_fillDoubleHashTableForCCtx(ZSTD_matchState_t* ms,
+                              void const* end, ZSTD_dictTableLoadMethod_e dtlm)
+{
+    const ZSTD_compressionParameters* const cParams = &ms->cParams;
+    U32* const hashLarge = ms->hashTable;
+    U32  const hBitsL = cParams->hashLog;
+    U32  const mls = cParams->minMatch;
+    U32* const hashSmall = ms->chainTable;
+    U32  const hBitsS = cParams->chainLog;
+    const BYTE* const base = ms->window.base;
+    const BYTE* ip = base + ms->nextToUpdate;
+    const BYTE* const iend = ((const BYTE*)end) - HASH_READ_SIZE;
+    const U32 fastHashFillStep = 3;
+
+    /* Always insert every fastHashFillStep position into the hash tables.
+     * Insert the other positions into the large hash table if their entry
+     * is empty.
+     */
+    for (; ip + fastHashFillStep - 1 <= iend; ip += fastHashFillStep) {
+        U32 const curr = (U32)(ip - base);
+        U32 i;
+        for (i = 0; i < fastHashFillStep; ++i) {
+            size_t const smHash = ZSTD_hashPtr(ip + i, hBitsS, mls);
+            size_t const lgHash = ZSTD_hashPtr(ip + i, hBitsL, 8);
+            if (i == 0)
+                hashSmall[smHash] = curr + i;
+            if (i == 0 || hashLarge[lgHash] == 0)
+                hashLarge[lgHash] = curr + i;
+            /* Only load extra positions for ZSTD_dtlm_full */
+            if (dtlm == ZSTD_dtlm_fast)
+                break;
+        }   }
+}
+
+void ZSTD_fillDoubleHashTable(ZSTD_matchState_t* ms,
+                        const void* const end,
+                        ZSTD_dictTableLoadMethod_e dtlm,
+                        ZSTD_tableFillPurpose_e tfp)
+{
+    if (tfp == ZSTD_tfp_forCDict) {
+        ZSTD_fillDoubleHashTableForCDict(ms, end, dtlm);
+    } else {
+        ZSTD_fillDoubleHashTableForCCtx(ms, end, dtlm);
+    }
+}
+
+
+FORCE_INLINE_TEMPLATE
+size_t ZSTD_compressBlock_doubleFast_noDict_generic(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize, U32 const mls /* template */)
+{
+    ZSTD_compressionParameters const* cParams = &ms->cParams;
+    U32* const hashLong = ms->hashTable;
+    const U32 hBitsL = cParams->hashLog;
+    U32* const hashSmall = ms->chainTable;
+    const U32 hBitsS = cParams->chainLog;
+    const BYTE* const base = ms->window.base;
+    const BYTE* const istart = (const BYTE*)src;
+    const BYTE* anchor = istart;
+    const U32 endIndex = (U32)((size_t)(istart - base) + srcSize);
+    /* presumes that, if there is a dictionary, it must be using Attach mode */
+    const U32 prefixLowestIndex = ZSTD_getLowestPrefixIndex(ms, endIndex, cParams->windowLog);
+    const BYTE* const prefixLowest = base + prefixLowestIndex;
+    const BYTE* const iend = istart + srcSize;
+    const BYTE* const ilimit = iend - HASH_READ_SIZE;
+    U32 offset_1=rep[0], offset_2=rep[1];
+    U32 offsetSaved1 = 0, offsetSaved2 = 0;
+
+    size_t mLength;
+    U32 offset;
+    U32 curr;
+
+    /* how many positions to search before increasing step size */
+    const size_t kStepIncr = 1 << kSearchStrength;
+    /* the position at which to increment the step size if no match is found */
+    const BYTE* nextStep;
+    size_t step; /* the current step size */
+
+    size_t hl0; /* the long hash at ip */
+    size_t hl1; /* the long hash at ip1 */
+
+    U32 idxl0; /* the long match index for ip */
+    U32 idxl1; /* the long match index for ip1 */
+
+    const BYTE* matchl0; /* the long match for ip */
+    const BYTE* matchs0; /* the short match for ip */
+    const BYTE* matchl1; /* the long match for ip1 */
+
+    const BYTE* ip = istart; /* the current position */
+    const BYTE* ip1; /* the next position */
+
+    DEBUGLOG(5, "ZSTD_compressBlock_doubleFast_noDict_generic");
+
+    /* init */
+    ip += ((ip - prefixLowest) == 0);
+    {
+        U32 const current = (U32)(ip - base);
+        U32 const windowLow = ZSTD_getLowestPrefixIndex(ms, current, cParams->windowLog);
+        U32 const maxRep = current - windowLow;
+        if (offset_2 > maxRep) offsetSaved2 = offset_2, offset_2 = 0;
+        if (offset_1 > maxRep) offsetSaved1 = offset_1, offset_1 = 0;
+    }
+
+    /* Outer Loop: one iteration per match found and stored */
+    while (1) {
+        step = 1;
+        nextStep = ip + kStepIncr;
+        ip1 = ip + step;
+
+        if (ip1 > ilimit) {
+            goto _cleanup;
+        }
+
+        hl0 = ZSTD_hashPtr(ip, hBitsL, 8);
+        idxl0 = hashLong[hl0];
+        matchl0 = base + idxl0;
+
+        /* Inner Loop: one iteration per search / position */
+        do {
+            const size_t hs0 = ZSTD_hashPtr(ip, hBitsS, mls);
+            const U32 idxs0 = hashSmall[hs0];
+            curr = (U32)(ip-base);
+            matchs0 = base + idxs0;
+
+            hashLong[hl0] = hashSmall[hs0] = curr;   /* update hash tables */
+
+            /* check noDict repcode */
+            if ((offset_1 > 0) & (MEM_read32(ip+1-offset_1) == MEM_read32(ip+1))) {
+                mLength = ZSTD_count(ip+1+4, ip+1+4-offset_1, iend) + 4;
+                ip++;
+                ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, REPCODE1_TO_OFFBASE, mLength);
+                goto _match_stored;
+            }
+
+            hl1 = ZSTD_hashPtr(ip1, hBitsL, 8);
+
+            if (idxl0 > prefixLowestIndex) {
+                /* check prefix long match */
+                if (MEM_read64(matchl0) == MEM_read64(ip)) {
+                    mLength = ZSTD_count(ip+8, matchl0+8, iend) + 8;
+                    offset = (U32)(ip-matchl0);
+                    while (((ip>anchor) & (matchl0>prefixLowest)) && (ip[-1] == matchl0[-1])) { ip--; matchl0--; mLength++; } /* catch up */
+                    goto _match_found;
+                }
+            }
+
+            idxl1 = hashLong[hl1];
+            matchl1 = base + idxl1;
+
+            if (idxs0 > prefixLowestIndex) {
+                /* check prefix short match */
+                if (MEM_read32(matchs0) == MEM_read32(ip)) {
+                    goto _search_next_long;
+                }
+            }
+
+            if (ip1 >= nextStep) {
+                PREFETCH_L1(ip1 + 64);
+                PREFETCH_L1(ip1 + 128);
+                step++;
+                nextStep += kStepIncr;
+            }
+            ip = ip1;
+            ip1 += step;
+
+            hl0 = hl1;
+            idxl0 = idxl1;
+            matchl0 = matchl1;
+    #if defined(__aarch64__)
+            PREFETCH_L1(ip+256);
+    #endif
+        } while (ip1 <= ilimit);
+
+_cleanup:
+        /* If offset_1 started invalid (offsetSaved1 != 0) and became valid (offset_1 != 0),
+         * rotate saved offsets. See comment in ZSTD_compressBlock_fast_noDict for more context. */
+        offsetSaved2 = ((offsetSaved1 != 0) && (offset_1 != 0)) ? offsetSaved1 : offsetSaved2;
+
+        /* save reps for next block */
+        rep[0] = offset_1 ? offset_1 : offsetSaved1;
+        rep[1] = offset_2 ? offset_2 : offsetSaved2;
+
+        /* Return the last literals size */
+        return (size_t)(iend - anchor);
+
+_search_next_long:
+
+        /* check prefix long +1 match */
+        if (idxl1 > prefixLowestIndex) {
+            if (MEM_read64(matchl1) == MEM_read64(ip1)) {
+                ip = ip1;
+                mLength = ZSTD_count(ip+8, matchl1+8, iend) + 8;
+                offset = (U32)(ip-matchl1);
+                while (((ip>anchor) & (matchl1>prefixLowest)) && (ip[-1] == matchl1[-1])) { ip--; matchl1--; mLength++; } /* catch up */
+                goto _match_found;
+            }
+        }
+
+        /* if no long +1 match, explore the short match we found */
+        mLength = ZSTD_count(ip+4, matchs0+4, iend) + 4;
+        offset = (U32)(ip - matchs0);
+        while (((ip>anchor) & (matchs0>prefixLowest)) && (ip[-1] == matchs0[-1])) { ip--; matchs0--; mLength++; } /* catch up */
+
+        /* fall-through */
+
+_match_found: /* requires ip, offset, mLength */
+        offset_2 = offset_1;
+        offset_1 = offset;
+
+        if (step < 4) {
+            /* It is unsafe to write this value back to the hashtable when ip1 is
+             * greater than or equal to the new ip we will have after we're done
+             * processing this match. Rather than perform that test directly
+             * (ip1 >= ip + mLength), which costs speed in practice, we do a simpler
+             * more predictable test. The minmatch even if we take a short match is
+             * 4 bytes, so as long as step, the distance between ip and ip1
+             * (initially) is less than 4, we know ip1 < new ip. */
+            hashLong[hl1] = (U32)(ip1 - base);
+        }
+
+        ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, OFFSET_TO_OFFBASE(offset), mLength);
+
+_match_stored:
+        /* match found */
+        ip += mLength;
+        anchor = ip;
+
+        if (ip <= ilimit) {
+            /* Complementary insertion */
+            /* done after iLimit test, as candidates could be > iend-8 */
+            {   U32 const indexToInsert = curr+2;
+                hashLong[ZSTD_hashPtr(base+indexToInsert, hBitsL, 8)] = indexToInsert;
+                hashLong[ZSTD_hashPtr(ip-2, hBitsL, 8)] = (U32)(ip-2-base);
+                hashSmall[ZSTD_hashPtr(base+indexToInsert, hBitsS, mls)] = indexToInsert;
+                hashSmall[ZSTD_hashPtr(ip-1, hBitsS, mls)] = (U32)(ip-1-base);
+            }
+
+            /* check immediate repcode */
+            while ( (ip <= ilimit)
+                 && ( (offset_2>0)
+                    & (MEM_read32(ip) == MEM_read32(ip - offset_2)) )) {
+                /* store sequence */
+                size_t const rLength = ZSTD_count(ip+4, ip+4-offset_2, iend) + 4;
+                U32 const tmpOff = offset_2; offset_2 = offset_1; offset_1 = tmpOff;  /* swap offset_2 <=> offset_1 */
+                hashSmall[ZSTD_hashPtr(ip, hBitsS, mls)] = (U32)(ip-base);
+                hashLong[ZSTD_hashPtr(ip, hBitsL, 8)] = (U32)(ip-base);
+                ZSTD_storeSeq(seqStore, 0, anchor, iend, REPCODE1_TO_OFFBASE, rLength);
+                ip += rLength;
+                anchor = ip;
+                continue;   /* faster when present ... (?) */
+            }
+        }
+    }
+}
+
+
+FORCE_INLINE_TEMPLATE
+size_t ZSTD_compressBlock_doubleFast_dictMatchState_generic(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize,
+        U32 const mls /* template */)
+{
+    ZSTD_compressionParameters const* cParams = &ms->cParams;
+    U32* const hashLong = ms->hashTable;
+    const U32 hBitsL = cParams->hashLog;
+    U32* const hashSmall = ms->chainTable;
+    const U32 hBitsS = cParams->chainLog;
+    const BYTE* const base = ms->window.base;
+    const BYTE* const istart = (const BYTE*)src;
+    const BYTE* ip = istart;
+    const BYTE* anchor = istart;
+    const U32 endIndex = (U32)((size_t)(istart - base) + srcSize);
+    /* presumes that, if there is a dictionary, it must be using Attach mode */
+    const U32 prefixLowestIndex = ZSTD_getLowestPrefixIndex(ms, endIndex, cParams->windowLog);
+    const BYTE* const prefixLowest = base + prefixLowestIndex;
+    const BYTE* const iend = istart + srcSize;
+    const BYTE* const ilimit = iend - HASH_READ_SIZE;
+    U32 offset_1=rep[0], offset_2=rep[1];
+
+    const ZSTD_matchState_t* const dms = ms->dictMatchState;
+    const ZSTD_compressionParameters* const dictCParams = &dms->cParams;
+    const U32* const dictHashLong  = dms->hashTable;
+    const U32* const dictHashSmall = dms->chainTable;
+    const U32 dictStartIndex       = dms->window.dictLimit;
+    const BYTE* const dictBase     = dms->window.base;
+    const BYTE* const dictStart    = dictBase + dictStartIndex;
+    const BYTE* const dictEnd      = dms->window.nextSrc;
+    const U32 dictIndexDelta       = prefixLowestIndex - (U32)(dictEnd - dictBase);
+    const U32 dictHBitsL           = dictCParams->hashLog + ZSTD_SHORT_CACHE_TAG_BITS;
+    const U32 dictHBitsS           = dictCParams->chainLog + ZSTD_SHORT_CACHE_TAG_BITS;
+    const U32 dictAndPrefixLength  = (U32)((ip - prefixLowest) + (dictEnd - dictStart));
+
+    DEBUGLOG(5, "ZSTD_compressBlock_doubleFast_dictMatchState_generic");
+
+    /* if a dictionary is attached, it must be within window range */
+    assert(ms->window.dictLimit + (1U << cParams->windowLog) >= endIndex);
+
+    if (ms->prefetchCDictTables) {
+        size_t const hashTableBytes = (((size_t)1) << dictCParams->hashLog) * sizeof(U32);
+        size_t const chainTableBytes = (((size_t)1) << dictCParams->chainLog) * sizeof(U32);
+        PREFETCH_AREA(dictHashLong, hashTableBytes)
+        PREFETCH_AREA(dictHashSmall, chainTableBytes)
+    }
+
+    /* init */
+    ip += (dictAndPrefixLength == 0);
+
+    /* dictMatchState repCode checks don't currently handle repCode == 0
+     * disabling. */
+    assert(offset_1 <= dictAndPrefixLength);
+    assert(offset_2 <= dictAndPrefixLength);
+
+    /* Main Search Loop */
+    while (ip < ilimit) {   /* < instead of <=, because repcode check at (ip+1) */
+        size_t mLength;
+        U32 offset;
+        size_t const h2 = ZSTD_hashPtr(ip, hBitsL, 8);
+        size_t const h = ZSTD_hashPtr(ip, hBitsS, mls);
+        size_t const dictHashAndTagL = ZSTD_hashPtr(ip, dictHBitsL, 8);
+        size_t const dictHashAndTagS = ZSTD_hashPtr(ip, dictHBitsS, mls);
+        U32 const dictMatchIndexAndTagL = dictHashLong[dictHashAndTagL >> ZSTD_SHORT_CACHE_TAG_BITS];
+        U32 const dictMatchIndexAndTagS = dictHashSmall[dictHashAndTagS >> ZSTD_SHORT_CACHE_TAG_BITS];
+        int const dictTagsMatchL = ZSTD_comparePackedTags(dictMatchIndexAndTagL, dictHashAndTagL);
+        int const dictTagsMatchS = ZSTD_comparePackedTags(dictMatchIndexAndTagS, dictHashAndTagS);
+        U32 const curr = (U32)(ip-base);
+        U32 const matchIndexL = hashLong[h2];
+        U32 matchIndexS = hashSmall[h];
+        const BYTE* matchLong = base + matchIndexL;
+        const BYTE* match = base + matchIndexS;
+        const U32 repIndex = curr + 1 - offset_1;
+        const BYTE* repMatch = (repIndex < prefixLowestIndex) ?
+                               dictBase + (repIndex - dictIndexDelta) :
+                               base + repIndex;
+        hashLong[h2] = hashSmall[h] = curr;   /* update hash tables */
+
+        /* check repcode */
+        if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
+            && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {
+            const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;
+            mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;
+            ip++;
+            ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, REPCODE1_TO_OFFBASE, mLength);
+            goto _match_stored;
+        }
+
+        if (matchIndexL > prefixLowestIndex) {
+            /* check prefix long match */
+            if (MEM_read64(matchLong) == MEM_read64(ip)) {
+                mLength = ZSTD_count(ip+8, matchLong+8, iend) + 8;
+                offset = (U32)(ip-matchLong);
+                while (((ip>anchor) & (matchLong>prefixLowest)) && (ip[-1] == matchLong[-1])) { ip--; matchLong--; mLength++; } /* catch up */
+                goto _match_found;
+            }
+        } else if (dictTagsMatchL) {
+            /* check dictMatchState long match */
+            U32 const dictMatchIndexL = dictMatchIndexAndTagL >> ZSTD_SHORT_CACHE_TAG_BITS;
+            const BYTE* dictMatchL = dictBase + dictMatchIndexL;
+            assert(dictMatchL < dictEnd);
+
+            if (dictMatchL > dictStart && MEM_read64(dictMatchL) == MEM_read64(ip)) {
+                mLength = ZSTD_count_2segments(ip+8, dictMatchL+8, iend, dictEnd, prefixLowest) + 8;
+                offset = (U32)(curr - dictMatchIndexL - dictIndexDelta);
+                while (((ip>anchor) & (dictMatchL>dictStart)) && (ip[-1] == dictMatchL[-1])) { ip--; dictMatchL--; mLength++; } /* catch up */
+                goto _match_found;
+        }   }
+
+        if (matchIndexS > prefixLowestIndex) {
+            /* check prefix short match */
+            if (MEM_read32(match) == MEM_read32(ip)) {
+                goto _search_next_long;
+            }
+        } else if (dictTagsMatchS) {
+            /* check dictMatchState short match */
+            U32 const dictMatchIndexS = dictMatchIndexAndTagS >> ZSTD_SHORT_CACHE_TAG_BITS;
+            match = dictBase + dictMatchIndexS;
+            matchIndexS = dictMatchIndexS + dictIndexDelta;
+
+            if (match > dictStart && MEM_read32(match) == MEM_read32(ip)) {
+                goto _search_next_long;
+        }   }
+
+        ip += ((ip-anchor) >> kSearchStrength) + 1;
+#if defined(__aarch64__)
+        PREFETCH_L1(ip+256);
+#endif
+        continue;
+
+_search_next_long:
+        {   size_t const hl3 = ZSTD_hashPtr(ip+1, hBitsL, 8);
+            size_t const dictHashAndTagL3 = ZSTD_hashPtr(ip+1, dictHBitsL, 8);
+            U32 const matchIndexL3 = hashLong[hl3];
+            U32 const dictMatchIndexAndTagL3 = dictHashLong[dictHashAndTagL3 >> ZSTD_SHORT_CACHE_TAG_BITS];
+            int const dictTagsMatchL3 = ZSTD_comparePackedTags(dictMatchIndexAndTagL3, dictHashAndTagL3);
+            const BYTE* matchL3 = base + matchIndexL3;
+            hashLong[hl3] = curr + 1;
+
+            /* check prefix long +1 match */
+            if (matchIndexL3 > prefixLowestIndex) {
+                if (MEM_read64(matchL3) == MEM_read64(ip+1)) {
+                    mLength = ZSTD_count(ip+9, matchL3+8, iend) + 8;
+                    ip++;
+                    offset = (U32)(ip-matchL3);
+                    while (((ip>anchor) & (matchL3>prefixLowest)) && (ip[-1] == matchL3[-1])) { ip--; matchL3--; mLength++; } /* catch up */
+                    goto _match_found;
+                }
+            } else if (dictTagsMatchL3) {
+                /* check dict long +1 match */
+                U32 const dictMatchIndexL3 = dictMatchIndexAndTagL3 >> ZSTD_SHORT_CACHE_TAG_BITS;
+                const BYTE* dictMatchL3 = dictBase + dictMatchIndexL3;
+                assert(dictMatchL3 < dictEnd);
+                if (dictMatchL3 > dictStart && MEM_read64(dictMatchL3) == MEM_read64(ip+1)) {
+                    mLength = ZSTD_count_2segments(ip+1+8, dictMatchL3+8, iend, dictEnd, prefixLowest) + 8;
+                    ip++;
+                    offset = (U32)(curr + 1 - dictMatchIndexL3 - dictIndexDelta);
+                    while (((ip>anchor) & (dictMatchL3>dictStart)) && (ip[-1] == dictMatchL3[-1])) { ip--; dictMatchL3--; mLength++; } /* catch up */
+                    goto _match_found;
+        }   }   }
+
+        /* if no long +1 match, explore the short match we found */
+        if (matchIndexS < prefixLowestIndex) {
+            mLength = ZSTD_count_2segments(ip+4, match+4, iend, dictEnd, prefixLowest) + 4;
+            offset = (U32)(curr - matchIndexS);
+            while (((ip>anchor) & (match>dictStart)) && (ip[-1] == match[-1])) { ip--; match--; mLength++; } /* catch up */
+        } else {
+            mLength = ZSTD_count(ip+4, match+4, iend) + 4;
+            offset = (U32)(ip - match);
+            while (((ip>anchor) & (match>prefixLowest)) && (ip[-1] == match[-1])) { ip--; match--; mLength++; } /* catch up */
+        }
+
+_match_found:
+        offset_2 = offset_1;
+        offset_1 = offset;
+
+        ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, OFFSET_TO_OFFBASE(offset), mLength);
+
+_match_stored:
+        /* match found */
+        ip += mLength;
+        anchor = ip;
+
+        if (ip <= ilimit) {
+            /* Complementary insertion */
+            /* done after iLimit test, as candidates could be > iend-8 */
+            {   U32 const indexToInsert = curr+2;
+                hashLong[ZSTD_hashPtr(base+indexToInsert, hBitsL, 8)] = indexToInsert;
+                hashLong[ZSTD_hashPtr(ip-2, hBitsL, 8)] = (U32)(ip-2-base);
+                hashSmall[ZSTD_hashPtr(base+indexToInsert, hBitsS, mls)] = indexToInsert;
+                hashSmall[ZSTD_hashPtr(ip-1, hBitsS, mls)] = (U32)(ip-1-base);
+            }
+
+            /* check immediate repcode */
+            while (ip <= ilimit) {
+                U32 const current2 = (U32)(ip-base);
+                U32 const repIndex2 = current2 - offset_2;
+                const BYTE* repMatch2 = repIndex2 < prefixLowestIndex ?
+                        dictBase + repIndex2 - dictIndexDelta :
+                        base + repIndex2;
+                if ( ((U32)((prefixLowestIndex-1) - (U32)repIndex2) >= 3 /* intentional overflow */)
+                   && (MEM_read32(repMatch2) == MEM_read32(ip)) ) {
+                    const BYTE* const repEnd2 = repIndex2 < prefixLowestIndex ? dictEnd : iend;
+                    size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixLowest) + 4;
+                    U32 tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;   /* swap offset_2 <=> offset_1 */
+                    ZSTD_storeSeq(seqStore, 0, anchor, iend, REPCODE1_TO_OFFBASE, repLength2);
+                    hashSmall[ZSTD_hashPtr(ip, hBitsS, mls)] = current2;
+                    hashLong[ZSTD_hashPtr(ip, hBitsL, 8)] = current2;
+                    ip += repLength2;
+                    anchor = ip;
+                    continue;
+                }
+                break;
+            }
+        }
+    }   /* while (ip < ilimit) */
+
+    /* save reps for next block */
+    rep[0] = offset_1;
+    rep[1] = offset_2;
+
+    /* Return the last literals size */
+    return (size_t)(iend - anchor);
+}
+
+#define ZSTD_GEN_DFAST_FN(dictMode, mls)                                                                 \
+    static size_t ZSTD_compressBlock_doubleFast_##dictMode##_##mls(                                      \
+            ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],                          \
+            void const* src, size_t srcSize)                                                             \
+    {                                                                                                    \
+        return ZSTD_compressBlock_doubleFast_##dictMode##_generic(ms, seqStore, rep, src, srcSize, mls); \
+    }
+
+ZSTD_GEN_DFAST_FN(noDict, 4)
+ZSTD_GEN_DFAST_FN(noDict, 5)
+ZSTD_GEN_DFAST_FN(noDict, 6)
+ZSTD_GEN_DFAST_FN(noDict, 7)
+
+ZSTD_GEN_DFAST_FN(dictMatchState, 4)
+ZSTD_GEN_DFAST_FN(dictMatchState, 5)
+ZSTD_GEN_DFAST_FN(dictMatchState, 6)
+ZSTD_GEN_DFAST_FN(dictMatchState, 7)
+
+
+size_t ZSTD_compressBlock_doubleFast(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    const U32 mls = ms->cParams.minMatch;
+    switch(mls)
+    {
+    default: /* includes case 3 */
+    case 4 :
+        return ZSTD_compressBlock_doubleFast_noDict_4(ms, seqStore, rep, src, srcSize);
+    case 5 :
+        return ZSTD_compressBlock_doubleFast_noDict_5(ms, seqStore, rep, src, srcSize);
+    case 6 :
+        return ZSTD_compressBlock_doubleFast_noDict_6(ms, seqStore, rep, src, srcSize);
+    case 7 :
+        return ZSTD_compressBlock_doubleFast_noDict_7(ms, seqStore, rep, src, srcSize);
+    }
+}
+
+
+size_t ZSTD_compressBlock_doubleFast_dictMatchState(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    const U32 mls = ms->cParams.minMatch;
+    switch(mls)
+    {
+    default: /* includes case 3 */
+    case 4 :
+        return ZSTD_compressBlock_doubleFast_dictMatchState_4(ms, seqStore, rep, src, srcSize);
+    case 5 :
+        return ZSTD_compressBlock_doubleFast_dictMatchState_5(ms, seqStore, rep, src, srcSize);
+    case 6 :
+        return ZSTD_compressBlock_doubleFast_dictMatchState_6(ms, seqStore, rep, src, srcSize);
+    case 7 :
+        return ZSTD_compressBlock_doubleFast_dictMatchState_7(ms, seqStore, rep, src, srcSize);
+    }
+}
+
+
+static size_t ZSTD_compressBlock_doubleFast_extDict_generic(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize,
+        U32 const mls /* template */)
+{
+    ZSTD_compressionParameters const* cParams = &ms->cParams;
+    U32* const hashLong = ms->hashTable;
+    U32  const hBitsL = cParams->hashLog;
+    U32* const hashSmall = ms->chainTable;
+    U32  const hBitsS = cParams->chainLog;
+    const BYTE* const istart = (const BYTE*)src;
+    const BYTE* ip = istart;
+    const BYTE* anchor = istart;
+    const BYTE* const iend = istart + srcSize;
+    const BYTE* const ilimit = iend - 8;
+    const BYTE* const base = ms->window.base;
+    const U32   endIndex = (U32)((size_t)(istart - base) + srcSize);
+    const U32   lowLimit = ZSTD_getLowestMatchIndex(ms, endIndex, cParams->windowLog);
+    const U32   dictStartIndex = lowLimit;
+    const U32   dictLimit = ms->window.dictLimit;
+    const U32   prefixStartIndex = (dictLimit > lowLimit) ? dictLimit : lowLimit;
+    const BYTE* const prefixStart = base + prefixStartIndex;
+    const BYTE* const dictBase = ms->window.dictBase;
+    const BYTE* const dictStart = dictBase + dictStartIndex;
+    const BYTE* const dictEnd = dictBase + prefixStartIndex;
+    U32 offset_1=rep[0], offset_2=rep[1];
+
+    DEBUGLOG(5, "ZSTD_compressBlock_doubleFast_extDict_generic (srcSize=%zu)", srcSize);
+
+    /* if extDict is invalidated due to maxDistance, switch to "regular" variant */
+    if (prefixStartIndex == dictStartIndex)
+        return ZSTD_compressBlock_doubleFast(ms, seqStore, rep, src, srcSize);
+
+    /* Search Loop */
+    while (ip < ilimit) {  /* < instead of <=, because (ip+1) */
+        const size_t hSmall = ZSTD_hashPtr(ip, hBitsS, mls);
+        const U32 matchIndex = hashSmall[hSmall];
+        const BYTE* const matchBase = matchIndex < prefixStartIndex ? dictBase : base;
+        const BYTE* match = matchBase + matchIndex;
+
+        const size_t hLong = ZSTD_hashPtr(ip, hBitsL, 8);
+        const U32 matchLongIndex = hashLong[hLong];
+        const BYTE* const matchLongBase = matchLongIndex < prefixStartIndex ? dictBase : base;
+        const BYTE* matchLong = matchLongBase + matchLongIndex;
+
+        const U32 curr = (U32)(ip-base);
+        const U32 repIndex = curr + 1 - offset_1;   /* offset_1 expected <= curr +1 */
+        const BYTE* const repBase = repIndex < prefixStartIndex ? dictBase : base;
+        const BYTE* const repMatch = repBase + repIndex;
+        size_t mLength;
+        hashSmall[hSmall] = hashLong[hLong] = curr;   /* update hash table */
+
+        if ((((U32)((prefixStartIndex-1) - repIndex) >= 3) /* intentional underflow : ensure repIndex doesn't overlap dict + prefix */
+            & (offset_1 <= curr+1 - dictStartIndex)) /* note: we are searching at curr+1 */
+          && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {
+            const BYTE* repMatchEnd = repIndex < prefixStartIndex ? dictEnd : iend;
+            mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;
+            ip++;
+            ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, REPCODE1_TO_OFFBASE, mLength);
+        } else {
+            if ((matchLongIndex > dictStartIndex) && (MEM_read64(matchLong) == MEM_read64(ip))) {
+                const BYTE* const matchEnd = matchLongIndex < prefixStartIndex ? dictEnd : iend;
+                const BYTE* const lowMatchPtr = matchLongIndex < prefixStartIndex ? dictStart : prefixStart;
+                U32 offset;
+                mLength = ZSTD_count_2segments(ip+8, matchLong+8, iend, matchEnd, prefixStart) + 8;
+                offset = curr - matchLongIndex;
+                while (((ip>anchor) & (matchLong>lowMatchPtr)) && (ip[-1] == matchLong[-1])) { ip--; matchLong--; mLength++; }   /* catch up */
+                offset_2 = offset_1;
+                offset_1 = offset;
+                ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, OFFSET_TO_OFFBASE(offset), mLength);
+
+            } else if ((matchIndex > dictStartIndex) && (MEM_read32(match) == MEM_read32(ip))) {
+                size_t const h3 = ZSTD_hashPtr(ip+1, hBitsL, 8);
+                U32 const matchIndex3 = hashLong[h3];
+                const BYTE* const match3Base = matchIndex3 < prefixStartIndex ? dictBase : base;
+                const BYTE* match3 = match3Base + matchIndex3;
+                U32 offset;
+                hashLong[h3] = curr + 1;
+                if ( (matchIndex3 > dictStartIndex) && (MEM_read64(match3) == MEM_read64(ip+1)) ) {
+                    const BYTE* const matchEnd = matchIndex3 < prefixStartIndex ? dictEnd : iend;
+                    const BYTE* const lowMatchPtr = matchIndex3 < prefixStartIndex ? dictStart : prefixStart;
+                    mLength = ZSTD_count_2segments(ip+9, match3+8, iend, matchEnd, prefixStart) + 8;
+                    ip++;
+                    offset = curr+1 - matchIndex3;
+                    while (((ip>anchor) & (match3>lowMatchPtr)) && (ip[-1] == match3[-1])) { ip--; match3--; mLength++; } /* catch up */
+                } else {
+                    const BYTE* const matchEnd = matchIndex < prefixStartIndex ? dictEnd : iend;
+                    const BYTE* const lowMatchPtr = matchIndex < prefixStartIndex ? dictStart : prefixStart;
+                    mLength = ZSTD_count_2segments(ip+4, match+4, iend, matchEnd, prefixStart) + 4;
+                    offset = curr - matchIndex;
+                    while (((ip>anchor) & (match>lowMatchPtr)) && (ip[-1] == match[-1])) { ip--; match--; mLength++; }   /* catch up */
+                }
+                offset_2 = offset_1;
+                offset_1 = offset;
+                ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, OFFSET_TO_OFFBASE(offset), mLength);
+
+            } else {
+                ip += ((ip-anchor) >> kSearchStrength) + 1;
+                continue;
+        }   }
+
+        /* move to next sequence start */
+        ip += mLength;
+        anchor = ip;
+
+        if (ip <= ilimit) {
+            /* Complementary insertion */
+            /* done after iLimit test, as candidates could be > iend-8 */
+            {   U32 const indexToInsert = curr+2;
+                hashLong[ZSTD_hashPtr(base+indexToInsert, hBitsL, 8)] = indexToInsert;
+                hashLong[ZSTD_hashPtr(ip-2, hBitsL, 8)] = (U32)(ip-2-base);
+                hashSmall[ZSTD_hashPtr(base+indexToInsert, hBitsS, mls)] = indexToInsert;
+                hashSmall[ZSTD_hashPtr(ip-1, hBitsS, mls)] = (U32)(ip-1-base);
+            }
+
+            /* check immediate repcode */
+            while (ip <= ilimit) {
+                U32 const current2 = (U32)(ip-base);
+                U32 const repIndex2 = current2 - offset_2;
+                const BYTE* repMatch2 = repIndex2 < prefixStartIndex ? dictBase + repIndex2 : base + repIndex2;
+                if ( (((U32)((prefixStartIndex-1) - repIndex2) >= 3)   /* intentional overflow : ensure repIndex2 doesn't overlap dict + prefix */
+                    & (offset_2 <= current2 - dictStartIndex))
+                  && (MEM_read32(repMatch2) == MEM_read32(ip)) ) {
+                    const BYTE* const repEnd2 = repIndex2 < prefixStartIndex ? dictEnd : iend;
+                    size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;
+                    U32 const tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;   /* swap offset_2 <=> offset_1 */
+                    ZSTD_storeSeq(seqStore, 0, anchor, iend, REPCODE1_TO_OFFBASE, repLength2);
+                    hashSmall[ZSTD_hashPtr(ip, hBitsS, mls)] = current2;
+                    hashLong[ZSTD_hashPtr(ip, hBitsL, 8)] = current2;
+                    ip += repLength2;
+                    anchor = ip;
+                    continue;
+                }
+                break;
+    }   }   }
+
+    /* save reps for next block */
+    rep[0] = offset_1;
+    rep[1] = offset_2;
+
+    /* Return the last literals size */
+    return (size_t)(iend - anchor);
+}
+
+ZSTD_GEN_DFAST_FN(extDict, 4)
+ZSTD_GEN_DFAST_FN(extDict, 5)
+ZSTD_GEN_DFAST_FN(extDict, 6)
+ZSTD_GEN_DFAST_FN(extDict, 7)
+
+size_t ZSTD_compressBlock_doubleFast_extDict(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    U32 const mls = ms->cParams.minMatch;
+    switch(mls)
+    {
+    default: /* includes case 3 */
+    case 4 :
+        return ZSTD_compressBlock_doubleFast_extDict_4(ms, seqStore, rep, src, srcSize);
+    case 5 :
+        return ZSTD_compressBlock_doubleFast_extDict_5(ms, seqStore, rep, src, srcSize);
+    case 6 :
+        return ZSTD_compressBlock_doubleFast_extDict_6(ms, seqStore, rep, src, srcSize);
+    case 7 :
+        return ZSTD_compressBlock_doubleFast_extDict_7(ms, seqStore, rep, src, srcSize);
+    }
+}
diff --git a/src/3rdparty/zstd/src/compress/zstd_double_fast.h b/src/3rdparty/zstd/src/compress/zstd_double_fast.h
new file mode 100644
index 0000000000..6f0047c4ba
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_double_fast.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_DOUBLE_FAST_H
+#define ZSTD_DOUBLE_FAST_H
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#include "../common/mem.h"      /* U32 */
+#include "zstd_compress_internal.h"     /* ZSTD_CCtx, size_t */
+
+void ZSTD_fillDoubleHashTable(ZSTD_matchState_t* ms,
+                              void const* end, ZSTD_dictTableLoadMethod_e dtlm,
+                              ZSTD_tableFillPurpose_e tfp);
+size_t ZSTD_compressBlock_doubleFast(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_doubleFast_dictMatchState(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_doubleFast_extDict(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+
+
+#if defined (__cplusplus)
+}
+#endif
+
+#endif /* ZSTD_DOUBLE_FAST_H */
diff --git a/src/3rdparty/zstd/src/compress/zstd_fast.c b/src/3rdparty/zstd/src/compress/zstd_fast.c
new file mode 100644
index 0000000000..5f2c6a2eda
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_fast.c
@@ -0,0 +1,960 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#include "zstd_compress_internal.h"  /* ZSTD_hashPtr, ZSTD_count, ZSTD_storeSeq */
+#include "zstd_fast.h"
+
+static void ZSTD_fillHashTableForCDict(ZSTD_matchState_t* ms,
+                        const void* const end,
+                        ZSTD_dictTableLoadMethod_e dtlm)
+{
+    const ZSTD_compressionParameters* const cParams = &ms->cParams;
+    U32* const hashTable = ms->hashTable;
+    U32  const hBits = cParams->hashLog + ZSTD_SHORT_CACHE_TAG_BITS;
+    U32  const mls = cParams->minMatch;
+    const BYTE* const base = ms->window.base;
+    const BYTE* ip = base + ms->nextToUpdate;
+    const BYTE* const iend = ((const BYTE*)end) - HASH_READ_SIZE;
+    const U32 fastHashFillStep = 3;
+
+    /* Currently, we always use ZSTD_dtlm_full for filling CDict tables.
+     * Feel free to remove this assert if there's a good reason! */
+    assert(dtlm == ZSTD_dtlm_full);
+
+    /* Always insert every fastHashFillStep position into the hash table.
+     * Insert the other positions if their hash entry is empty.
+     */
+    for ( ; ip + fastHashFillStep < iend + 2; ip += fastHashFillStep) {
+        U32 const curr = (U32)(ip - base);
+        {   size_t const hashAndTag = ZSTD_hashPtr(ip, hBits, mls);
+            ZSTD_writeTaggedIndex(hashTable, hashAndTag, curr);   }
+
+        if (dtlm == ZSTD_dtlm_fast) continue;
+        /* Only load extra positions for ZSTD_dtlm_full */
+        {   U32 p;
+            for (p = 1; p < fastHashFillStep; ++p) {
+                size_t const hashAndTag = ZSTD_hashPtr(ip + p, hBits, mls);
+                if (hashTable[hashAndTag >> ZSTD_SHORT_CACHE_TAG_BITS] == 0) {  /* not yet filled */
+                    ZSTD_writeTaggedIndex(hashTable, hashAndTag, curr + p);
+                }   }   }   }
+}
+
+static void ZSTD_fillHashTableForCCtx(ZSTD_matchState_t* ms,
+                        const void* const end,
+                        ZSTD_dictTableLoadMethod_e dtlm)
+{
+    const ZSTD_compressionParameters* const cParams = &ms->cParams;
+    U32* const hashTable = ms->hashTable;
+    U32  const hBits = cParams->hashLog;
+    U32  const mls = cParams->minMatch;
+    const BYTE* const base = ms->window.base;
+    const BYTE* ip = base + ms->nextToUpdate;
+    const BYTE* const iend = ((const BYTE*)end) - HASH_READ_SIZE;
+    const U32 fastHashFillStep = 3;
+
+    /* Currently, we always use ZSTD_dtlm_fast for filling CCtx tables.
+     * Feel free to remove this assert if there's a good reason! */
+    assert(dtlm == ZSTD_dtlm_fast);
+
+    /* Always insert every fastHashFillStep position into the hash table.
+     * Insert the other positions if their hash entry is empty.
+     */
+    for ( ; ip + fastHashFillStep < iend + 2; ip += fastHashFillStep) {
+        U32 const curr = (U32)(ip - base);
+        size_t const hash0 = ZSTD_hashPtr(ip, hBits, mls);
+        hashTable[hash0] = curr;
+        if (dtlm == ZSTD_dtlm_fast) continue;
+        /* Only load extra positions for ZSTD_dtlm_full */
+        {   U32 p;
+            for (p = 1; p < fastHashFillStep; ++p) {
+                size_t const hash = ZSTD_hashPtr(ip + p, hBits, mls);
+                if (hashTable[hash] == 0) {  /* not yet filled */
+                    hashTable[hash] = curr + p;
+    }   }   }   }
+}
+
+void ZSTD_fillHashTable(ZSTD_matchState_t* ms,
+                        const void* const end,
+                        ZSTD_dictTableLoadMethod_e dtlm,
+                        ZSTD_tableFillPurpose_e tfp)
+{
+    if (tfp == ZSTD_tfp_forCDict) {
+        ZSTD_fillHashTableForCDict(ms, end, dtlm);
+    } else {
+        ZSTD_fillHashTableForCCtx(ms, end, dtlm);
+    }
+}
+
+
+/**
+ * If you squint hard enough (and ignore repcodes), the search operation at any
+ * given position is broken into 4 stages:
+ *
+ * 1. Hash   (map position to hash value via input read)
+ * 2. Lookup (map hash val to index via hashtable read)
+ * 3. Load   (map index to value at that position via input read)
+ * 4. Compare
+ *
+ * Each of these steps involves a memory read at an address which is computed
+ * from the previous step. This means these steps must be sequenced and their
+ * latencies are cumulative.
+ *
+ * Rather than do 1->2->3->4 sequentially for a single position before moving
+ * onto the next, this implementation interleaves these operations across the
+ * next few positions:
+ *
+ * R = Repcode Read & Compare
+ * H = Hash
+ * T = Table Lookup
+ * M = Match Read & Compare
+ *
+ * Pos | Time -->
+ * ----+-------------------
+ * N   | ... M
+ * N+1 | ...   TM
+ * N+2 |    R H   T M
+ * N+3 |         H    TM
+ * N+4 |           R H   T M
+ * N+5 |                H   ...
+ * N+6 |                  R ...
+ *
+ * This is very much analogous to the pipelining of execution in a CPU. And just
+ * like a CPU, we have to dump the pipeline when we find a match (i.e., take a
+ * branch).
+ *
+ * When this happens, we throw away our current state, and do the following prep
+ * to re-enter the loop:
+ *
+ * Pos | Time -->
+ * ----+-------------------
+ * N   | H T
+ * N+1 |  H
+ *
+ * This is also the work we do at the beginning to enter the loop initially.
+ */
+FORCE_INLINE_TEMPLATE size_t
+ZSTD_compressBlock_fast_noDict_generic(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize,
+        U32 const mls, U32 const hasStep)
+{
+    const ZSTD_compressionParameters* const cParams = &ms->cParams;
+    U32* const hashTable = ms->hashTable;
+    U32 const hlog = cParams->hashLog;
+    /* support stepSize of 0 */
+    size_t const stepSize = hasStep ? (cParams->targetLength + !(cParams->targetLength) + 1) : 2;
+    const BYTE* const base = ms->window.base;
+    const BYTE* const istart = (const BYTE*)src;
+    const U32   endIndex = (U32)((size_t)(istart - base) + srcSize);
+    const U32   prefixStartIndex = ZSTD_getLowestPrefixIndex(ms, endIndex, cParams->windowLog);
+    const BYTE* const prefixStart = base + prefixStartIndex;
+    const BYTE* const iend = istart + srcSize;
+    const BYTE* const ilimit = iend - HASH_READ_SIZE;
+
+    const BYTE* anchor = istart;
+    const BYTE* ip0 = istart;
+    const BYTE* ip1;
+    const BYTE* ip2;
+    const BYTE* ip3;
+    U32 current0;
+
+    U32 rep_offset1 = rep[0];
+    U32 rep_offset2 = rep[1];
+    U32 offsetSaved1 = 0, offsetSaved2 = 0;
+
+    size_t hash0; /* hash for ip0 */
+    size_t hash1; /* hash for ip1 */
+    U32 idx; /* match idx for ip0 */
+    U32 mval; /* src value at match idx */
+
+    U32 offcode;
+    const BYTE* match0;
+    size_t mLength;
+
+    /* ip0 and ip1 are always adjacent. The targetLength skipping and
+     * uncompressibility acceleration is applied to every other position,
+     * matching the behavior of #1562. step therefore represents the gap
+     * between pairs of positions, from ip0 to ip2 or ip1 to ip3. */
+    size_t step;
+    const BYTE* nextStep;
+    const size_t kStepIncr = (1 << (kSearchStrength - 1));
+
+    DEBUGLOG(5, "ZSTD_compressBlock_fast_generic");
+    ip0 += (ip0 == prefixStart);
+    {   U32 const curr = (U32)(ip0 - base);
+        U32 const windowLow = ZSTD_getLowestPrefixIndex(ms, curr, cParams->windowLog);
+        U32 const maxRep = curr - windowLow;
+        if (rep_offset2 > maxRep) offsetSaved2 = rep_offset2, rep_offset2 = 0;
+        if (rep_offset1 > maxRep) offsetSaved1 = rep_offset1, rep_offset1 = 0;
+    }
+
+    /* start each op */
+_start: /* Requires: ip0 */
+
+    step = stepSize;
+    nextStep = ip0 + kStepIncr;
+
+    /* calculate positions, ip0 - anchor == 0, so we skip step calc */
+    ip1 = ip0 + 1;
+    ip2 = ip0 + step;
+    ip3 = ip2 + 1;
+
+    if (ip3 >= ilimit) {
+        goto _cleanup;
+    }
+
+    hash0 = ZSTD_hashPtr(ip0, hlog, mls);
+    hash1 = ZSTD_hashPtr(ip1, hlog, mls);
+
+    idx = hashTable[hash0];
+
+    do {
+        /* load repcode match for ip[2]*/
+        const U32 rval = MEM_read32(ip2 - rep_offset1);
+
+        /* write back hash table entry */
+        current0 = (U32)(ip0 - base);
+        hashTable[hash0] = current0;
+
+        /* check repcode at ip[2] */
+        if ((MEM_read32(ip2) == rval) & (rep_offset1 > 0)) {
+            ip0 = ip2;
+            match0 = ip0 - rep_offset1;
+            mLength = ip0[-1] == match0[-1];
+            ip0 -= mLength;
+            match0 -= mLength;
+            offcode = REPCODE1_TO_OFFBASE;
+            mLength += 4;
+
+            /* First write next hash table entry; we've already calculated it.
+             * This write is known to be safe because the ip1 is before the
+             * repcode (ip2). */
+            hashTable[hash1] = (U32)(ip1 - base);
+
+            goto _match;
+        }
+
+        /* load match for ip[0] */
+        if (idx >= prefixStartIndex) {
+            mval = MEM_read32(base + idx);
+        } else {
+            mval = MEM_read32(ip0) ^ 1; /* guaranteed to not match. */
+        }
+
+        /* check match at ip[0] */
+        if (MEM_read32(ip0) == mval) {
+            /* found a match! */
+
+            /* First write next hash table entry; we've already calculated it.
+             * This write is known to be safe because the ip1 == ip0 + 1, so
+             * we know we will resume searching after ip1 */
+            hashTable[hash1] = (U32)(ip1 - base);
+
+            goto _offset;
+        }
+
+        /* lookup ip[1] */
+        idx = hashTable[hash1];
+
+        /* hash ip[2] */
+        hash0 = hash1;
+        hash1 = ZSTD_hashPtr(ip2, hlog, mls);
+
+        /* advance to next positions */
+        ip0 = ip1;
+        ip1 = ip2;
+        ip2 = ip3;
+
+        /* write back hash table entry */
+        current0 = (U32)(ip0 - base);
+        hashTable[hash0] = current0;
+
+        /* load match for ip[0] */
+        if (idx >= prefixStartIndex) {
+            mval = MEM_read32(base + idx);
+        } else {
+            mval = MEM_read32(ip0) ^ 1; /* guaranteed to not match. */
+        }
+
+        /* check match at ip[0] */
+        if (MEM_read32(ip0) == mval) {
+            /* found a match! */
+
+            /* first write next hash table entry; we've already calculated it */
+            if (step <= 4) {
+                /* We need to avoid writing an index into the hash table >= the
+                 * position at which we will pick up our searching after we've
+                 * taken this match.
+                 *
+                 * The minimum possible match has length 4, so the earliest ip0
+                 * can be after we take this match will be the current ip0 + 4.
+                 * ip1 is ip0 + step - 1. If ip1 is >= ip0 + 4, we can't safely
+                 * write this position.
+                 */
+                hashTable[hash1] = (U32)(ip1 - base);
+            }
+
+            goto _offset;
+        }
+
+        /* lookup ip[1] */
+        idx = hashTable[hash1];
+
+        /* hash ip[2] */
+        hash0 = hash1;
+        hash1 = ZSTD_hashPtr(ip2, hlog, mls);
+
+        /* advance to next positions */
+        ip0 = ip1;
+        ip1 = ip2;
+        ip2 = ip0 + step;
+        ip3 = ip1 + step;
+
+        /* calculate step */
+        if (ip2 >= nextStep) {
+            step++;
+            PREFETCH_L1(ip1 + 64);
+            PREFETCH_L1(ip1 + 128);
+            nextStep += kStepIncr;
+        }
+    } while (ip3 < ilimit);
+
+_cleanup:
+    /* Note that there are probably still a couple positions we could search.
+     * However, it seems to be a meaningful performance hit to try to search
+     * them. So let's not. */
+
+    /* When the repcodes are outside of the prefix, we set them to zero before the loop.
+     * When the offsets are still zero, we need to restore them after the block to have a correct
+     * repcode history. If only one offset was invalid, it is easy. The tricky case is when both
+     * offsets were invalid. We need to figure out which offset to refill with.
+     *     - If both offsets are zero they are in the same order.
+     *     - If both offsets are non-zero, we won't restore the offsets from `offsetSaved[12]`.
+     *     - If only one is zero, we need to decide which offset to restore.
+     *         - If rep_offset1 is non-zero, then rep_offset2 must be offsetSaved1.
+     *         - It is impossible for rep_offset2 to be non-zero.
+     *
+     * So if rep_offset1 started invalid (offsetSaved1 != 0) and became valid (rep_offset1 != 0), then
+     * set rep[0] = rep_offset1 and rep[1] = offsetSaved1.
+     */
+    offsetSaved2 = ((offsetSaved1 != 0) && (rep_offset1 != 0)) ? offsetSaved1 : offsetSaved2;
+
+    /* save reps for next block */
+    rep[0] = rep_offset1 ? rep_offset1 : offsetSaved1;
+    rep[1] = rep_offset2 ? rep_offset2 : offsetSaved2;
+
+    /* Return the last literals size */
+    return (size_t)(iend - anchor);
+
+_offset: /* Requires: ip0, idx */
+
+    /* Compute the offset code. */
+    match0 = base + idx;
+    rep_offset2 = rep_offset1;
+    rep_offset1 = (U32)(ip0-match0);
+    offcode = OFFSET_TO_OFFBASE(rep_offset1);
+    mLength = 4;
+
+    /* Count the backwards match length. */
+    while (((ip0>anchor) & (match0>prefixStart)) && (ip0[-1] == match0[-1])) {
+        ip0--;
+        match0--;
+        mLength++;
+    }
+
+_match: /* Requires: ip0, match0, offcode */
+
+    /* Count the forward length. */
+    mLength += ZSTD_count(ip0 + mLength, match0 + mLength, iend);
+
+    ZSTD_storeSeq(seqStore, (size_t)(ip0 - anchor), anchor, iend, offcode, mLength);
+
+    ip0 += mLength;
+    anchor = ip0;
+
+    /* Fill table and check for immediate repcode. */
+    if (ip0 <= ilimit) {
+        /* Fill Table */
+        assert(base+current0+2 > istart);  /* check base overflow */
+        hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */
+        hashTable[ZSTD_hashPtr(ip0-2, hlog, mls)] = (U32)(ip0-2-base);
+
+        if (rep_offset2 > 0) { /* rep_offset2==0 means rep_offset2 is invalidated */
+            while ( (ip0 <= ilimit) && (MEM_read32(ip0) == MEM_read32(ip0 - rep_offset2)) ) {
+                /* store sequence */
+                size_t const rLength = ZSTD_count(ip0+4, ip0+4-rep_offset2, iend) + 4;
+                { U32 const tmpOff = rep_offset2; rep_offset2 = rep_offset1; rep_offset1 = tmpOff; } /* swap rep_offset2 <=> rep_offset1 */
+                hashTable[ZSTD_hashPtr(ip0, hlog, mls)] = (U32)(ip0-base);
+                ip0 += rLength;
+                ZSTD_storeSeq(seqStore, 0 /*litLen*/, anchor, iend, REPCODE1_TO_OFFBASE, rLength);
+                anchor = ip0;
+                continue;   /* faster when present (confirmed on gcc-8) ... (?) */
+    }   }   }
+
+    goto _start;
+}
+
+#define ZSTD_GEN_FAST_FN(dictMode, mls, step)                                                            \
+    static size_t ZSTD_compressBlock_fast_##dictMode##_##mls##_##step(                                      \
+            ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],                    \
+            void const* src, size_t srcSize)                                                       \
+    {                                                                                              \
+        return ZSTD_compressBlock_fast_##dictMode##_generic(ms, seqStore, rep, src, srcSize, mls, step); \
+    }
+
+ZSTD_GEN_FAST_FN(noDict, 4, 1)
+ZSTD_GEN_FAST_FN(noDict, 5, 1)
+ZSTD_GEN_FAST_FN(noDict, 6, 1)
+ZSTD_GEN_FAST_FN(noDict, 7, 1)
+
+ZSTD_GEN_FAST_FN(noDict, 4, 0)
+ZSTD_GEN_FAST_FN(noDict, 5, 0)
+ZSTD_GEN_FAST_FN(noDict, 6, 0)
+ZSTD_GEN_FAST_FN(noDict, 7, 0)
+
+size_t ZSTD_compressBlock_fast(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    U32 const mls = ms->cParams.minMatch;
+    assert(ms->dictMatchState == NULL);
+    if (ms->cParams.targetLength > 1) {
+        switch(mls)
+        {
+        default: /* includes case 3 */
+        case 4 :
+            return ZSTD_compressBlock_fast_noDict_4_1(ms, seqStore, rep, src, srcSize);
+        case 5 :
+            return ZSTD_compressBlock_fast_noDict_5_1(ms, seqStore, rep, src, srcSize);
+        case 6 :
+            return ZSTD_compressBlock_fast_noDict_6_1(ms, seqStore, rep, src, srcSize);
+        case 7 :
+            return ZSTD_compressBlock_fast_noDict_7_1(ms, seqStore, rep, src, srcSize);
+        }
+    } else {
+        switch(mls)
+        {
+        default: /* includes case 3 */
+        case 4 :
+            return ZSTD_compressBlock_fast_noDict_4_0(ms, seqStore, rep, src, srcSize);
+        case 5 :
+            return ZSTD_compressBlock_fast_noDict_5_0(ms, seqStore, rep, src, srcSize);
+        case 6 :
+            return ZSTD_compressBlock_fast_noDict_6_0(ms, seqStore, rep, src, srcSize);
+        case 7 :
+            return ZSTD_compressBlock_fast_noDict_7_0(ms, seqStore, rep, src, srcSize);
+        }
+
+    }
+}
+
+FORCE_INLINE_TEMPLATE
+size_t ZSTD_compressBlock_fast_dictMatchState_generic(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize, U32 const mls, U32 const hasStep)
+{
+    const ZSTD_compressionParameters* const cParams = &ms->cParams;
+    U32* const hashTable = ms->hashTable;
+    U32 const hlog = cParams->hashLog;
+    /* support stepSize of 0 */
+    U32 const stepSize = cParams->targetLength + !(cParams->targetLength);
+    const BYTE* const base = ms->window.base;
+    const BYTE* const istart = (const BYTE*)src;
+    const BYTE* ip0 = istart;
+    const BYTE* ip1 = ip0 + stepSize; /* we assert below that stepSize >= 1 */
+    const BYTE* anchor = istart;
+    const U32   prefixStartIndex = ms->window.dictLimit;
+    const BYTE* const prefixStart = base + prefixStartIndex;
+    const BYTE* const iend = istart + srcSize;
+    const BYTE* const ilimit = iend - HASH_READ_SIZE;
+    U32 offset_1=rep[0], offset_2=rep[1];
+
+    const ZSTD_matchState_t* const dms = ms->dictMatchState;
+    const ZSTD_compressionParameters* const dictCParams = &dms->cParams ;
+    const U32* const dictHashTable = dms->hashTable;
+    const U32 dictStartIndex       = dms->window.dictLimit;
+    const BYTE* const dictBase     = dms->window.base;
+    const BYTE* const dictStart    = dictBase + dictStartIndex;
+    const BYTE* const dictEnd      = dms->window.nextSrc;
+    const U32 dictIndexDelta       = prefixStartIndex - (U32)(dictEnd - dictBase);
+    const U32 dictAndPrefixLength  = (U32)(istart - prefixStart + dictEnd - dictStart);
+    const U32 dictHBits            = dictCParams->hashLog + ZSTD_SHORT_CACHE_TAG_BITS;
+
+    /* if a dictionary is still attached, it necessarily means that
+     * it is within window size. So we just check it. */
+    const U32 maxDistance = 1U << cParams->windowLog;
+    const U32 endIndex = (U32)((size_t)(istart - base) + srcSize);
+    assert(endIndex - prefixStartIndex <= maxDistance);
+    (void)maxDistance; (void)endIndex;   /* these variables are not used when assert() is disabled */
+
+    (void)hasStep; /* not currently specialized on whether it's accelerated */
+
+    /* ensure there will be no underflow
+     * when translating a dict index into a local index */
+    assert(prefixStartIndex >= (U32)(dictEnd - dictBase));
+
+    if (ms->prefetchCDictTables) {
+        size_t const hashTableBytes = (((size_t)1) << dictCParams->hashLog) * sizeof(U32);
+        PREFETCH_AREA(dictHashTable, hashTableBytes)
+    }
+
+    /* init */
+    DEBUGLOG(5, "ZSTD_compressBlock_fast_dictMatchState_generic");
+    ip0 += (dictAndPrefixLength == 0);
+    /* dictMatchState repCode checks don't currently handle repCode == 0
+     * disabling. */
+    assert(offset_1 <= dictAndPrefixLength);
+    assert(offset_2 <= dictAndPrefixLength);
+
+    /* Outer search loop */
+    assert(stepSize >= 1);
+    while (ip1 <= ilimit) {   /* repcode check at (ip0 + 1) is safe because ip0 < ip1 */
+        size_t mLength;
+        size_t hash0 = ZSTD_hashPtr(ip0, hlog, mls);
+
+        size_t const dictHashAndTag0 = ZSTD_hashPtr(ip0, dictHBits, mls);
+        U32 dictMatchIndexAndTag = dictHashTable[dictHashAndTag0 >> ZSTD_SHORT_CACHE_TAG_BITS];
+        int dictTagsMatch = ZSTD_comparePackedTags(dictMatchIndexAndTag, dictHashAndTag0);
+
+        U32 matchIndex = hashTable[hash0];
+        U32 curr = (U32)(ip0 - base);
+        size_t step = stepSize;
+        const size_t kStepIncr = 1 << kSearchStrength;
+        const BYTE* nextStep = ip0 + kStepIncr;
+
+        /* Inner search loop */
+        while (1) {
+            const BYTE* match = base + matchIndex;
+            const U32 repIndex = curr + 1 - offset_1;
+            const BYTE* repMatch = (repIndex < prefixStartIndex) ?
+                                   dictBase + (repIndex - dictIndexDelta) :
+                                   base + repIndex;
+            const size_t hash1 = ZSTD_hashPtr(ip1, hlog, mls);
+            size_t const dictHashAndTag1 = ZSTD_hashPtr(ip1, dictHBits, mls);
+            hashTable[hash0] = curr;   /* update hash table */
+
+            if (((U32) ((prefixStartIndex - 1) - repIndex) >=
+                 3) /* intentional underflow : ensure repIndex isn't overlapping dict + prefix */
+                && (MEM_read32(repMatch) == MEM_read32(ip0 + 1))) {
+                const BYTE* const repMatchEnd = repIndex < prefixStartIndex ? dictEnd : iend;
+                mLength = ZSTD_count_2segments(ip0 + 1 + 4, repMatch + 4, iend, repMatchEnd, prefixStart) + 4;
+                ip0++;
+                ZSTD_storeSeq(seqStore, (size_t) (ip0 - anchor), anchor, iend, REPCODE1_TO_OFFBASE, mLength);
+                break;
+            }
+
+            if (dictTagsMatch) {
+                /* Found a possible dict match */
+                const U32 dictMatchIndex = dictMatchIndexAndTag >> ZSTD_SHORT_CACHE_TAG_BITS;
+                const BYTE* dictMatch = dictBase + dictMatchIndex;
+                if (dictMatchIndex > dictStartIndex &&
+                    MEM_read32(dictMatch) == MEM_read32(ip0)) {
+                    /* To replicate extDict parse behavior, we only use dict matches when the normal matchIndex is invalid */
+                    if (matchIndex <= prefixStartIndex) {
+                        U32 const offset = (U32) (curr - dictMatchIndex - dictIndexDelta);
+                        mLength = ZSTD_count_2segments(ip0 + 4, dictMatch + 4, iend, dictEnd, prefixStart) + 4;
+                        while (((ip0 > anchor) & (dictMatch > dictStart))
+                            && (ip0[-1] == dictMatch[-1])) {
+                            ip0--;
+                            dictMatch--;
+                            mLength++;
+                        } /* catch up */
+                        offset_2 = offset_1;
+                        offset_1 = offset;
+                        ZSTD_storeSeq(seqStore, (size_t) (ip0 - anchor), anchor, iend, OFFSET_TO_OFFBASE(offset), mLength);
+                        break;
+                    }
+                }
+            }
+
+            if (matchIndex > prefixStartIndex && MEM_read32(match) == MEM_read32(ip0)) {
+                /* found a regular match */
+                U32 const offset = (U32) (ip0 - match);
+                mLength = ZSTD_count(ip0 + 4, match + 4, iend) + 4;
+                while (((ip0 > anchor) & (match > prefixStart))
+                       && (ip0[-1] == match[-1])) {
+                    ip0--;
+                    match--;
+                    mLength++;
+                } /* catch up */
+                offset_2 = offset_1;
+                offset_1 = offset;
+                ZSTD_storeSeq(seqStore, (size_t) (ip0 - anchor), anchor, iend, OFFSET_TO_OFFBASE(offset), mLength);
+                break;
+            }
+
+            /* Prepare for next iteration */
+            dictMatchIndexAndTag = dictHashTable[dictHashAndTag1 >> ZSTD_SHORT_CACHE_TAG_BITS];
+            dictTagsMatch = ZSTD_comparePackedTags(dictMatchIndexAndTag, dictHashAndTag1);
+            matchIndex = hashTable[hash1];
+
+            if (ip1 >= nextStep) {
+                step++;
+                nextStep += kStepIncr;
+            }
+            ip0 = ip1;
+            ip1 = ip1 + step;
+            if (ip1 > ilimit) goto _cleanup;
+
+            curr = (U32)(ip0 - base);
+            hash0 = hash1;
+        }   /* end inner search loop */
+
+        /* match found */
+        assert(mLength);
+        ip0 += mLength;
+        anchor = ip0;
+
+        if (ip0 <= ilimit) {
+            /* Fill Table */
+            assert(base+curr+2 > istart);  /* check base overflow */
+            hashTable[ZSTD_hashPtr(base+curr+2, hlog, mls)] = curr+2;  /* here because curr+2 could be > iend-8 */
+            hashTable[ZSTD_hashPtr(ip0-2, hlog, mls)] = (U32)(ip0-2-base);
+
+            /* check immediate repcode */
+            while (ip0 <= ilimit) {
+                U32 const current2 = (U32)(ip0-base);
+                U32 const repIndex2 = current2 - offset_2;
+                const BYTE* repMatch2 = repIndex2 < prefixStartIndex ?
+                        dictBase - dictIndexDelta + repIndex2 :
+                        base + repIndex2;
+                if ( ((U32)((prefixStartIndex-1) - (U32)repIndex2) >= 3 /* intentional overflow */)
+                   && (MEM_read32(repMatch2) == MEM_read32(ip0))) {
+                    const BYTE* const repEnd2 = repIndex2 < prefixStartIndex ? dictEnd : iend;
+                    size_t const repLength2 = ZSTD_count_2segments(ip0+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;
+                    U32 tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;   /* swap offset_2 <=> offset_1 */
+                    ZSTD_storeSeq(seqStore, 0, anchor, iend, REPCODE1_TO_OFFBASE, repLength2);
+                    hashTable[ZSTD_hashPtr(ip0, hlog, mls)] = current2;
+                    ip0 += repLength2;
+                    anchor = ip0;
+                    continue;
+                }
+                break;
+            }
+        }
+
+        /* Prepare for next iteration */
+        assert(ip0 == anchor);
+        ip1 = ip0 + stepSize;
+    }
+
+_cleanup:
+    /* save reps for next block */
+    rep[0] = offset_1;
+    rep[1] = offset_2;
+
+    /* Return the last literals size */
+    return (size_t)(iend - anchor);
+}
+
+
+ZSTD_GEN_FAST_FN(dictMatchState, 4, 0)
+ZSTD_GEN_FAST_FN(dictMatchState, 5, 0)
+ZSTD_GEN_FAST_FN(dictMatchState, 6, 0)
+ZSTD_GEN_FAST_FN(dictMatchState, 7, 0)
+
+size_t ZSTD_compressBlock_fast_dictMatchState(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    U32 const mls = ms->cParams.minMatch;
+    assert(ms->dictMatchState != NULL);
+    switch(mls)
+    {
+    default: /* includes case 3 */
+    case 4 :
+        return ZSTD_compressBlock_fast_dictMatchState_4_0(ms, seqStore, rep, src, srcSize);
+    case 5 :
+        return ZSTD_compressBlock_fast_dictMatchState_5_0(ms, seqStore, rep, src, srcSize);
+    case 6 :
+        return ZSTD_compressBlock_fast_dictMatchState_6_0(ms, seqStore, rep, src, srcSize);
+    case 7 :
+        return ZSTD_compressBlock_fast_dictMatchState_7_0(ms, seqStore, rep, src, srcSize);
+    }
+}
+
+
+static size_t ZSTD_compressBlock_fast_extDict_generic(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize, U32 const mls, U32 const hasStep)
+{
+    const ZSTD_compressionParameters* const cParams = &ms->cParams;
+    U32* const hashTable = ms->hashTable;
+    U32 const hlog = cParams->hashLog;
+    /* support stepSize of 0 */
+    size_t const stepSize = cParams->targetLength + !(cParams->targetLength) + 1;
+    const BYTE* const base = ms->window.base;
+    const BYTE* const dictBase = ms->window.dictBase;
+    const BYTE* const istart = (const BYTE*)src;
+    const BYTE* anchor = istart;
+    const U32   endIndex = (U32)((size_t)(istart - base) + srcSize);
+    const U32   lowLimit = ZSTD_getLowestMatchIndex(ms, endIndex, cParams->windowLog);
+    const U32   dictStartIndex = lowLimit;
+    const BYTE* const dictStart = dictBase + dictStartIndex;
+    const U32   dictLimit = ms->window.dictLimit;
+    const U32   prefixStartIndex = dictLimit < lowLimit ? lowLimit : dictLimit;
+    const BYTE* const prefixStart = base + prefixStartIndex;
+    const BYTE* const dictEnd = dictBase + prefixStartIndex;
+    const BYTE* const iend = istart + srcSize;
+    const BYTE* const ilimit = iend - 8;
+    U32 offset_1=rep[0], offset_2=rep[1];
+    U32 offsetSaved1 = 0, offsetSaved2 = 0;
+
+    const BYTE* ip0 = istart;
+    const BYTE* ip1;
+    const BYTE* ip2;
+    const BYTE* ip3;
+    U32 current0;
+
+
+    size_t hash0; /* hash for ip0 */
+    size_t hash1; /* hash for ip1 */
+    U32 idx; /* match idx for ip0 */
+    const BYTE* idxBase; /* base pointer for idx */
+
+    U32 offcode;
+    const BYTE* match0;
+    size_t mLength;
+    const BYTE* matchEnd = 0; /* initialize to avoid warning, assert != 0 later */
+
+    size_t step;
+    const BYTE* nextStep;
+    const size_t kStepIncr = (1 << (kSearchStrength - 1));
+
+    (void)hasStep; /* not currently specialized on whether it's accelerated */
+
+    DEBUGLOG(5, "ZSTD_compressBlock_fast_extDict_generic (offset_1=%u)", offset_1);
+
+    /* switch to "regular" variant if extDict is invalidated due to maxDistance */
+    if (prefixStartIndex == dictStartIndex)
+        return ZSTD_compressBlock_fast(ms, seqStore, rep, src, srcSize);
+
+    {   U32 const curr = (U32)(ip0 - base);
+        U32 const maxRep = curr - dictStartIndex;
+        if (offset_2 >= maxRep) offsetSaved2 = offset_2, offset_2 = 0;
+        if (offset_1 >= maxRep) offsetSaved1 = offset_1, offset_1 = 0;
+    }
+
+    /* start each op */
+_start: /* Requires: ip0 */
+
+    step = stepSize;
+    nextStep = ip0 + kStepIncr;
+
+    /* calculate positions, ip0 - anchor == 0, so we skip step calc */
+    ip1 = ip0 + 1;
+    ip2 = ip0 + step;
+    ip3 = ip2 + 1;
+
+    if (ip3 >= ilimit) {
+        goto _cleanup;
+    }
+
+    hash0 = ZSTD_hashPtr(ip0, hlog, mls);
+    hash1 = ZSTD_hashPtr(ip1, hlog, mls);
+
+    idx = hashTable[hash0];
+    idxBase = idx < prefixStartIndex ? dictBase : base;
+
+    do {
+        {   /* load repcode match for ip[2] */
+            U32 const current2 = (U32)(ip2 - base);
+            U32 const repIndex = current2 - offset_1;
+            const BYTE* const repBase = repIndex < prefixStartIndex ? dictBase : base;
+            U32 rval;
+            if ( ((U32)(prefixStartIndex - repIndex) >= 4) /* intentional underflow */
+                 & (offset_1 > 0) ) {
+                rval = MEM_read32(repBase + repIndex);
+            } else {
+                rval = MEM_read32(ip2) ^ 1; /* guaranteed to not match. */
+            }
+
+            /* write back hash table entry */
+            current0 = (U32)(ip0 - base);
+            hashTable[hash0] = current0;
+
+            /* check repcode at ip[2] */
+            if (MEM_read32(ip2) == rval) {
+                ip0 = ip2;
+                match0 = repBase + repIndex;
+                matchEnd = repIndex < prefixStartIndex ? dictEnd : iend;
+                assert((match0 != prefixStart) & (match0 != dictStart));
+                mLength = ip0[-1] == match0[-1];
+                ip0 -= mLength;
+                match0 -= mLength;
+                offcode = REPCODE1_TO_OFFBASE;
+                mLength += 4;
+                goto _match;
+        }   }
+
+        {   /* load match for ip[0] */
+            U32 const mval = idx >= dictStartIndex ?
+                    MEM_read32(idxBase + idx) :
+                    MEM_read32(ip0) ^ 1; /* guaranteed not to match */
+
+            /* check match at ip[0] */
+            if (MEM_read32(ip0) == mval) {
+                /* found a match! */
+                goto _offset;
+        }   }
+
+        /* lookup ip[1] */
+        idx = hashTable[hash1];
+        idxBase = idx < prefixStartIndex ? dictBase : base;
+
+        /* hash ip[2] */
+        hash0 = hash1;
+        hash1 = ZSTD_hashPtr(ip2, hlog, mls);
+
+        /* advance to next positions */
+        ip0 = ip1;
+        ip1 = ip2;
+        ip2 = ip3;
+
+        /* write back hash table entry */
+        current0 = (U32)(ip0 - base);
+        hashTable[hash0] = current0;
+
+        {   /* load match for ip[0] */
+            U32 const mval = idx >= dictStartIndex ?
+                    MEM_read32(idxBase + idx) :
+                    MEM_read32(ip0) ^ 1; /* guaranteed not to match */
+
+            /* check match at ip[0] */
+            if (MEM_read32(ip0) == mval) {
+                /* found a match! */
+                goto _offset;
+        }   }
+
+        /* lookup ip[1] */
+        idx = hashTable[hash1];
+        idxBase = idx < prefixStartIndex ? dictBase : base;
+
+        /* hash ip[2] */
+        hash0 = hash1;
+        hash1 = ZSTD_hashPtr(ip2, hlog, mls);
+
+        /* advance to next positions */
+        ip0 = ip1;
+        ip1 = ip2;
+        ip2 = ip0 + step;
+        ip3 = ip1 + step;
+
+        /* calculate step */
+        if (ip2 >= nextStep) {
+            step++;
+            PREFETCH_L1(ip1 + 64);
+            PREFETCH_L1(ip1 + 128);
+            nextStep += kStepIncr;
+        }
+    } while (ip3 < ilimit);
+
+_cleanup:
+    /* Note that there are probably still a couple positions we could search.
+     * However, it seems to be a meaningful performance hit to try to search
+     * them. So let's not. */
+
+    /* If offset_1 started invalid (offsetSaved1 != 0) and became valid (offset_1 != 0),
+     * rotate saved offsets. See comment in ZSTD_compressBlock_fast_noDict for more context. */
+    offsetSaved2 = ((offsetSaved1 != 0) && (offset_1 != 0)) ? offsetSaved1 : offsetSaved2;
+
+    /* save reps for next block */
+    rep[0] = offset_1 ? offset_1 : offsetSaved1;
+    rep[1] = offset_2 ? offset_2 : offsetSaved2;
+
+    /* Return the last literals size */
+    return (size_t)(iend - anchor);
+
+_offset: /* Requires: ip0, idx, idxBase */
+
+    /* Compute the offset code. */
+    {   U32 const offset = current0 - idx;
+        const BYTE* const lowMatchPtr = idx < prefixStartIndex ? dictStart : prefixStart;
+        matchEnd = idx < prefixStartIndex ? dictEnd : iend;
+        match0 = idxBase + idx;
+        offset_2 = offset_1;
+        offset_1 = offset;
+        offcode = OFFSET_TO_OFFBASE(offset);
+        mLength = 4;
+
+        /* Count the backwards match length. */
+        while (((ip0>anchor) & (match0>lowMatchPtr)) && (ip0[-1] == match0[-1])) {
+            ip0--;
+            match0--;
+            mLength++;
+    }   }
+
+_match: /* Requires: ip0, match0, offcode, matchEnd */
+
+    /* Count the forward length. */
+    assert(matchEnd != 0);
+    mLength += ZSTD_count_2segments(ip0 + mLength, match0 + mLength, iend, matchEnd, prefixStart);
+
+    ZSTD_storeSeq(seqStore, (size_t)(ip0 - anchor), anchor, iend, offcode, mLength);
+
+    ip0 += mLength;
+    anchor = ip0;
+
+    /* write next hash table entry */
+    if (ip1 < ip0) {
+        hashTable[hash1] = (U32)(ip1 - base);
+    }
+
+    /* Fill table and check for immediate repcode. */
+    if (ip0 <= ilimit) {
+        /* Fill Table */
+        assert(base+current0+2 > istart);  /* check base overflow */
+        hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;  /* here because current+2 could be > iend-8 */
+        hashTable[ZSTD_hashPtr(ip0-2, hlog, mls)] = (U32)(ip0-2-base);
+
+        while (ip0 <= ilimit) {
+            U32 const repIndex2 = (U32)(ip0-base) - offset_2;
+            const BYTE* const repMatch2 = repIndex2 < prefixStartIndex ? dictBase + repIndex2 : base + repIndex2;
+            if ( (((U32)((prefixStartIndex-1) - repIndex2) >= 3) & (offset_2 > 0))  /* intentional underflow */
+                 && (MEM_read32(repMatch2) == MEM_read32(ip0)) ) {
+                const BYTE* const repEnd2 = repIndex2 < prefixStartIndex ? dictEnd : iend;
+                size_t const repLength2 = ZSTD_count_2segments(ip0+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;
+                { U32 const tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset; }  /* swap offset_2 <=> offset_1 */
+                ZSTD_storeSeq(seqStore, 0 /*litlen*/, anchor, iend, REPCODE1_TO_OFFBASE, repLength2);
+                hashTable[ZSTD_hashPtr(ip0, hlog, mls)] = (U32)(ip0-base);
+                ip0 += repLength2;
+                anchor = ip0;
+                continue;
+            }
+            break;
+    }   }
+
+    goto _start;
+}
+
+ZSTD_GEN_FAST_FN(extDict, 4, 0)
+ZSTD_GEN_FAST_FN(extDict, 5, 0)
+ZSTD_GEN_FAST_FN(extDict, 6, 0)
+ZSTD_GEN_FAST_FN(extDict, 7, 0)
+
+size_t ZSTD_compressBlock_fast_extDict(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    U32 const mls = ms->cParams.minMatch;
+    assert(ms->dictMatchState == NULL);
+    switch(mls)
+    {
+    default: /* includes case 3 */
+    case 4 :
+        return ZSTD_compressBlock_fast_extDict_4_0(ms, seqStore, rep, src, srcSize);
+    case 5 :
+        return ZSTD_compressBlock_fast_extDict_5_0(ms, seqStore, rep, src, srcSize);
+    case 6 :
+        return ZSTD_compressBlock_fast_extDict_6_0(ms, seqStore, rep, src, srcSize);
+    case 7 :
+        return ZSTD_compressBlock_fast_extDict_7_0(ms, seqStore, rep, src, srcSize);
+    }
+}
diff --git a/src/3rdparty/zstd/src/compress/zstd_fast.h b/src/3rdparty/zstd/src/compress/zstd_fast.h
new file mode 100644
index 0000000000..9e4236b472
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_fast.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_FAST_H
+#define ZSTD_FAST_H
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#include "../common/mem.h"      /* U32 */
+#include "zstd_compress_internal.h"
+
+void ZSTD_fillHashTable(ZSTD_matchState_t* ms,
+                        void const* end, ZSTD_dictTableLoadMethod_e dtlm,
+                        ZSTD_tableFillPurpose_e tfp);
+size_t ZSTD_compressBlock_fast(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_fast_dictMatchState(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_fast_extDict(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+
+#if defined (__cplusplus)
+}
+#endif
+
+#endif /* ZSTD_FAST_H */
diff --git a/src/3rdparty/zstd/src/compress/zstd_lazy.c b/src/3rdparty/zstd/src/compress/zstd_lazy.c
new file mode 100644
index 0000000000..5ba88e8678
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_lazy.c
@@ -0,0 +1,2157 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#include "zstd_compress_internal.h"
+#include "zstd_lazy.h"
+#include "../common/bits.h" /* ZSTD_countTrailingZeros64 */
+
+#define kLazySkippingStep 8
+
+
+/*-*************************************
+*  Binary Tree search
+***************************************/
+
+static void
+ZSTD_updateDUBT(ZSTD_matchState_t* ms,
+                const BYTE* ip, const BYTE* iend,
+                U32 mls)
+{
+    const ZSTD_compressionParameters* const cParams = &ms->cParams;
+    U32* const hashTable = ms->hashTable;
+    U32  const hashLog = cParams->hashLog;
+
+    U32* const bt = ms->chainTable;
+    U32  const btLog  = cParams->chainLog - 1;
+    U32  const btMask = (1 << btLog) - 1;
+
+    const BYTE* const base = ms->window.base;
+    U32 const target = (U32)(ip - base);
+    U32 idx = ms->nextToUpdate;
+
+    if (idx != target)
+        DEBUGLOG(7, "ZSTD_updateDUBT, from %u to %u (dictLimit:%u)",
+                    idx, target, ms->window.dictLimit);
+    assert(ip + 8 <= iend);   /* condition for ZSTD_hashPtr */
+    (void)iend;
+
+    assert(idx >= ms->window.dictLimit);   /* condition for valid base+idx */
+    for ( ; idx < target ; idx++) {
+        size_t const h  = ZSTD_hashPtr(base + idx, hashLog, mls);   /* assumption : ip + 8 <= iend */
+        U32    const matchIndex = hashTable[h];
+
+        U32*   const nextCandidatePtr = bt + 2*(idx&btMask);
+        U32*   const sortMarkPtr  = nextCandidatePtr + 1;
+
+        DEBUGLOG(8, "ZSTD_updateDUBT: insert %u", idx);
+        hashTable[h] = idx;   /* Update Hash Table */
+        *nextCandidatePtr = matchIndex;   /* update BT like a chain */
+        *sortMarkPtr = ZSTD_DUBT_UNSORTED_MARK;
+    }
+    ms->nextToUpdate = target;
+}
+
+
+/** ZSTD_insertDUBT1() :
+ *  sort one already inserted but unsorted position
+ *  assumption : curr >= btlow == (curr - btmask)
+ *  doesn't fail */
+static void
+ZSTD_insertDUBT1(const ZSTD_matchState_t* ms,
+                 U32 curr, const BYTE* inputEnd,
+                 U32 nbCompares, U32 btLow,
+                 const ZSTD_dictMode_e dictMode)
+{
+    const ZSTD_compressionParameters* const cParams = &ms->cParams;
+    U32* const bt = ms->chainTable;
+    U32  const btLog  = cParams->chainLog - 1;
+    U32  const btMask = (1 << btLog) - 1;
+    size_t commonLengthSmaller=0, commonLengthLarger=0;
+    const BYTE* const base = ms->window.base;
+    const BYTE* const dictBase = ms->window.dictBase;
+    const U32 dictLimit = ms->window.dictLimit;
+    const BYTE* const ip = (curr>=dictLimit) ? base + curr : dictBase + curr;
+    const BYTE* const iend = (curr>=dictLimit) ? inputEnd : dictBase + dictLimit;
+    const BYTE* const dictEnd = dictBase + dictLimit;
+    const BYTE* const prefixStart = base + dictLimit;
+    const BYTE* match;
+    U32* smallerPtr = bt + 2*(curr&btMask);
+    U32* largerPtr  = smallerPtr + 1;
+    U32 matchIndex = *smallerPtr;   /* this candidate is unsorted : next sorted candidate is reached through *smallerPtr, while *largerPtr contains previous unsorted candidate (which is already saved and can be overwritten) */
+    U32 dummy32;   /* to be nullified at the end */
+    U32 const windowValid = ms->window.lowLimit;
+    U32 const maxDistance = 1U << cParams->windowLog;
+    U32 const windowLow = (curr - windowValid > maxDistance) ? curr - maxDistance : windowValid;
+
+
+    DEBUGLOG(8, "ZSTD_insertDUBT1(%u) (dictLimit=%u, lowLimit=%u)",
+                curr, dictLimit, windowLow);
+    assert(curr >= btLow);
+    assert(ip < iend);   /* condition for ZSTD_count */
+
+    for (; nbCompares && (matchIndex > windowLow); --nbCompares) {
+        U32* const nextPtr = bt + 2*(matchIndex & btMask);
+        size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
+        assert(matchIndex < curr);
+        /* note : all candidates are now supposed sorted,
+         * but it's still possible to have nextPtr[1] == ZSTD_DUBT_UNSORTED_MARK
+         * when a real index has the same value as ZSTD_DUBT_UNSORTED_MARK */
+
+        if ( (dictMode != ZSTD_extDict)
+          || (matchIndex+matchLength >= dictLimit)  /* both in current segment*/
+          || (curr < dictLimit) /* both in extDict */) {
+            const BYTE* const mBase = ( (dictMode != ZSTD_extDict)
+                                     || (matchIndex+matchLength >= dictLimit)) ?
+                                        base : dictBase;
+            assert( (matchIndex+matchLength >= dictLimit)   /* might be wrong if extDict is incorrectly set to 0 */
+                 || (curr < dictLimit) );
+            match = mBase + matchIndex;
+            matchLength += ZSTD_count(ip+matchLength, match+matchLength, iend);
+        } else {
+            match = dictBase + matchIndex;
+            matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);
+            if (matchIndex+matchLength >= dictLimit)
+                match = base + matchIndex;   /* preparation for next read of match[matchLength] */
+        }
+
+        DEBUGLOG(8, "ZSTD_insertDUBT1: comparing %u with %u : found %u common bytes ",
+                    curr, matchIndex, (U32)matchLength);
+
+        if (ip+matchLength == iend) {   /* equal : no way to know if inf or sup */
+            break;   /* drop , to guarantee consistency ; miss a bit of compression, but other solutions can corrupt tree */
+        }
+
+        if (match[matchLength] < ip[matchLength]) {  /* necessarily within buffer */
+            /* match is smaller than current */
+            *smallerPtr = matchIndex;             /* update smaller idx */
+            commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
+            if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop searching */
+            DEBUGLOG(8, "ZSTD_insertDUBT1: %u (>btLow=%u) is smaller : next => %u",
+                        matchIndex, btLow, nextPtr[1]);
+            smallerPtr = nextPtr+1;               /* new "candidate" => larger than match, which was smaller than target */
+            matchIndex = nextPtr[1];              /* new matchIndex, larger than previous and closer to current */
+        } else {
+            /* match is larger than current */
+            *largerPtr = matchIndex;
+            commonLengthLarger = matchLength;
+            if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop searching */
+            DEBUGLOG(8, "ZSTD_insertDUBT1: %u (>btLow=%u) is larger => %u",
+                        matchIndex, btLow, nextPtr[0]);
+            largerPtr = nextPtr;
+            matchIndex = nextPtr[0];
+    }   }
+
+    *smallerPtr = *largerPtr = 0;
+}
+
+
+static size_t
+ZSTD_DUBT_findBetterDictMatch (
+        const ZSTD_matchState_t* ms,
+        const BYTE* const ip, const BYTE* const iend,
+        size_t* offsetPtr,
+        size_t bestLength,
+        U32 nbCompares,
+        U32 const mls,
+        const ZSTD_dictMode_e dictMode)
+{
+    const ZSTD_matchState_t * const dms = ms->dictMatchState;
+    const ZSTD_compressionParameters* const dmsCParams = &dms->cParams;
+    const U32 * const dictHashTable = dms->hashTable;
+    U32         const hashLog = dmsCParams->hashLog;
+    size_t      const h  = ZSTD_hashPtr(ip, hashLog, mls);
+    U32               dictMatchIndex = dictHashTable[h];
+
+    const BYTE* const base = ms->window.base;
+    const BYTE* const prefixStart = base + ms->window.dictLimit;
+    U32         const curr = (U32)(ip-base);
+    const BYTE* const dictBase = dms->window.base;
+    const BYTE* const dictEnd = dms->window.nextSrc;
+    U32         const dictHighLimit = (U32)(dms->window.nextSrc - dms->window.base);
+    U32         const dictLowLimit = dms->window.lowLimit;
+    U32         const dictIndexDelta = ms->window.lowLimit - dictHighLimit;
+
+    U32*        const dictBt = dms->chainTable;
+    U32         const btLog  = dmsCParams->chainLog - 1;
+    U32         const btMask = (1 << btLog) - 1;
+    U32         const btLow = (btMask >= dictHighLimit - dictLowLimit) ? dictLowLimit : dictHighLimit - btMask;
+
+    size_t commonLengthSmaller=0, commonLengthLarger=0;
+
+    (void)dictMode;
+    assert(dictMode == ZSTD_dictMatchState);
+
+    for (; nbCompares && (dictMatchIndex > dictLowLimit); --nbCompares) {
+        U32* const nextPtr = dictBt + 2*(dictMatchIndex & btMask);
+        size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
+        const BYTE* match = dictBase + dictMatchIndex;
+        matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);
+        if (dictMatchIndex+matchLength >= dictHighLimit)
+            match = base + dictMatchIndex + dictIndexDelta;   /* to prepare for next usage of match[matchLength] */
+
+        if (matchLength > bestLength) {
+            U32 matchIndex = dictMatchIndex + dictIndexDelta;
+            if ( (4*(int)(matchLength-bestLength)) > (int)(ZSTD_highbit32(curr-matchIndex+1) - ZSTD_highbit32((U32)offsetPtr[0]+1)) ) {
+                DEBUGLOG(9, "ZSTD_DUBT_findBetterDictMatch(%u) : found better match length %u -> %u and offsetCode %u -> %u (dictMatchIndex %u, matchIndex %u)",
+                    curr, (U32)bestLength, (U32)matchLength, (U32)*offsetPtr, OFFSET_TO_OFFBASE(curr - matchIndex), dictMatchIndex, matchIndex);
+                bestLength = matchLength, *offsetPtr = OFFSET_TO_OFFBASE(curr - matchIndex);
+            }
+            if (ip+matchLength == iend) {   /* reached end of input : ip[matchLength] is not valid, no way to know if it's larger or smaller than match */
+                break;   /* drop, to guarantee consistency (miss a little bit of compression) */
+            }
+        }
+
+        if (match[matchLength] < ip[matchLength]) {
+            if (dictMatchIndex <= btLow) { break; }   /* beyond tree size, stop the search */
+            commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
+            dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
+        } else {
+            /* match is larger than current */
+            if (dictMatchIndex <= btLow) { break; }   /* beyond tree size, stop the search */
+            commonLengthLarger = matchLength;
+            dictMatchIndex = nextPtr[0];
+        }
+    }
+
+    if (bestLength >= MINMATCH) {
+        U32 const mIndex = curr - (U32)OFFBASE_TO_OFFSET(*offsetPtr); (void)mIndex;
+        DEBUGLOG(8, "ZSTD_DUBT_findBetterDictMatch(%u) : found match of length %u and offsetCode %u (pos %u)",
+                    curr, (U32)bestLength, (U32)*offsetPtr, mIndex);
+    }
+    return bestLength;
+
+}
+
+
+static size_t
+ZSTD_DUBT_findBestMatch(ZSTD_matchState_t* ms,
+                        const BYTE* const ip, const BYTE* const iend,
+                        size_t* offBasePtr,
+                        U32 const mls,
+                        const ZSTD_dictMode_e dictMode)
+{
+    const ZSTD_compressionParameters* const cParams = &ms->cParams;
+    U32*   const hashTable = ms->hashTable;
+    U32    const hashLog = cParams->hashLog;
+    size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);
+    U32          matchIndex  = hashTable[h];
+
+    const BYTE* const base = ms->window.base;
+    U32    const curr = (U32)(ip-base);
+    U32    const windowLow = ZSTD_getLowestMatchIndex(ms, curr, cParams->windowLog);
+
+    U32*   const bt = ms->chainTable;
+    U32    const btLog  = cParams->chainLog - 1;
+    U32    const btMask = (1 << btLog) - 1;
+    U32    const btLow = (btMask >= curr) ? 0 : curr - btMask;
+    U32    const unsortLimit = MAX(btLow, windowLow);
+
+    U32*         nextCandidate = bt + 2*(matchIndex&btMask);
+    U32*         unsortedMark = bt + 2*(matchIndex&btMask) + 1;
+    U32          nbCompares = 1U << cParams->searchLog;
+    U32          nbCandidates = nbCompares;
+    U32          previousCandidate = 0;
+
+    DEBUGLOG(7, "ZSTD_DUBT_findBestMatch (%u) ", curr);
+    assert(ip <= iend-8);   /* required for h calculation */
+    assert(dictMode != ZSTD_dedicatedDictSearch);
+
+    /* reach end of unsorted candidates list */
+    while ( (matchIndex > unsortLimit)
+         && (*unsortedMark == ZSTD_DUBT_UNSORTED_MARK)
+         && (nbCandidates > 1) ) {
+        DEBUGLOG(8, "ZSTD_DUBT_findBestMatch: candidate %u is unsorted",
+                    matchIndex);
+        *unsortedMark = previousCandidate;  /* the unsortedMark becomes a reversed chain, to move up back to original position */
+        previousCandidate = matchIndex;
+        matchIndex = *nextCandidate;
+        nextCandidate = bt + 2*(matchIndex&btMask);
+        unsortedMark = bt + 2*(matchIndex&btMask) + 1;
+        nbCandidates --;
+    }
+
+    /* nullify last candidate if it's still unsorted
+     * simplification, detrimental to compression ratio, beneficial for speed */
+    if ( (matchIndex > unsortLimit)
+      && (*unsortedMark==ZSTD_DUBT_UNSORTED_MARK) ) {
+        DEBUGLOG(7, "ZSTD_DUBT_findBestMatch: nullify last unsorted candidate %u",
+                    matchIndex);
+        *nextCandidate = *unsortedMark = 0;
+    }
+
+    /* batch sort stacked candidates */
+    matchIndex = previousCandidate;
+    while (matchIndex) {  /* will end on matchIndex == 0 */
+        U32* const nextCandidateIdxPtr = bt + 2*(matchIndex&btMask) + 1;
+        U32 const nextCandidateIdx = *nextCandidateIdxPtr;
+        ZSTD_insertDUBT1(ms, matchIndex, iend,
+                         nbCandidates, unsortLimit, dictMode);
+        matchIndex = nextCandidateIdx;
+        nbCandidates++;
+    }
+
+    /* find longest match */
+    {   size_t commonLengthSmaller = 0, commonLengthLarger = 0;
+        const BYTE* const dictBase = ms->window.dictBase;
+        const U32 dictLimit = ms->window.dictLimit;
+        const BYTE* const dictEnd = dictBase + dictLimit;
+        const BYTE* const prefixStart = base + dictLimit;
+        U32* smallerPtr = bt + 2*(curr&btMask);
+        U32* largerPtr  = bt + 2*(curr&btMask) + 1;
+        U32 matchEndIdx = curr + 8 + 1;
+        U32 dummy32;   /* to be nullified at the end */
+        size_t bestLength = 0;
+
+        matchIndex  = hashTable[h];
+        hashTable[h] = curr;   /* Update Hash Table */
+
+        for (; nbCompares && (matchIndex > windowLow); --nbCompares) {
+            U32* const nextPtr = bt + 2*(matchIndex & btMask);
+            size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
+            const BYTE* match;
+
+            if ((dictMode != ZSTD_extDict) || (matchIndex+matchLength >= dictLimit)) {
+                match = base + matchIndex;
+                matchLength += ZSTD_count(ip+matchLength, match+matchLength, iend);
+            } else {
+                match = dictBase + matchIndex;
+                matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);
+                if (matchIndex+matchLength >= dictLimit)
+                    match = base + matchIndex;   /* to prepare for next usage of match[matchLength] */
+            }
+
+            if (matchLength > bestLength) {
+                if (matchLength > matchEndIdx - matchIndex)
+                    matchEndIdx = matchIndex + (U32)matchLength;
+                if ( (4*(int)(matchLength-bestLength)) > (int)(ZSTD_highbit32(curr - matchIndex + 1) - ZSTD_highbit32((U32)*offBasePtr)) )
+                    bestLength = matchLength, *offBasePtr = OFFSET_TO_OFFBASE(curr - matchIndex);
+                if (ip+matchLength == iend) {   /* equal : no way to know if inf or sup */
+                    if (dictMode == ZSTD_dictMatchState) {
+                        nbCompares = 0; /* in addition to avoiding checking any
+                                         * further in this loop, make sure we
+                                         * skip checking in the dictionary. */
+                    }
+                    break;   /* drop, to guarantee consistency (miss a little bit of compression) */
+                }
+            }
+
+            if (match[matchLength] < ip[matchLength]) {
+                /* match is smaller than current */
+                *smallerPtr = matchIndex;             /* update smaller idx */
+                commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
+                if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */
+                smallerPtr = nextPtr+1;               /* new "smaller" => larger of match */
+                matchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
+            } else {
+                /* match is larger than current */
+                *largerPtr = matchIndex;
+                commonLengthLarger = matchLength;
+                if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */
+                largerPtr = nextPtr;
+                matchIndex = nextPtr[0];
+        }   }
+
+        *smallerPtr = *largerPtr = 0;
+
+        assert(nbCompares <= (1U << ZSTD_SEARCHLOG_MAX)); /* Check we haven't underflowed. */
+        if (dictMode == ZSTD_dictMatchState && nbCompares) {
+            bestLength = ZSTD_DUBT_findBetterDictMatch(
+                    ms, ip, iend,
+                    offBasePtr, bestLength, nbCompares,
+                    mls, dictMode);
+        }
+
+        assert(matchEndIdx > curr+8); /* ensure nextToUpdate is increased */
+        ms->nextToUpdate = matchEndIdx - 8;   /* skip repetitive patterns */
+        if (bestLength >= MINMATCH) {
+            U32 const mIndex = curr - (U32)OFFBASE_TO_OFFSET(*offBasePtr); (void)mIndex;
+            DEBUGLOG(8, "ZSTD_DUBT_findBestMatch(%u) : found match of length %u and offsetCode %u (pos %u)",
+                        curr, (U32)bestLength, (U32)*offBasePtr, mIndex);
+        }
+        return bestLength;
+    }
+}
+
+
+/** ZSTD_BtFindBestMatch() : Tree updater, providing best match */
+FORCE_INLINE_TEMPLATE size_t
+ZSTD_BtFindBestMatch( ZSTD_matchState_t* ms,
+                const BYTE* const ip, const BYTE* const iLimit,
+                      size_t* offBasePtr,
+                const U32 mls /* template */,
+                const ZSTD_dictMode_e dictMode)
+{
+    DEBUGLOG(7, "ZSTD_BtFindBestMatch");
+    if (ip < ms->window.base + ms->nextToUpdate) return 0;   /* skipped area */
+    ZSTD_updateDUBT(ms, ip, iLimit, mls);
+    return ZSTD_DUBT_findBestMatch(ms, ip, iLimit, offBasePtr, mls, dictMode);
+}
+
+/***********************************
+* Dedicated dict search
+***********************************/
+
+void ZSTD_dedicatedDictSearch_lazy_loadDictionary(ZSTD_matchState_t* ms, const BYTE* const ip)
+{
+    const BYTE* const base = ms->window.base;
+    U32 const target = (U32)(ip - base);
+    U32* const hashTable = ms->hashTable;
+    U32* const chainTable = ms->chainTable;
+    U32 const chainSize = 1 << ms->cParams.chainLog;
+    U32 idx = ms->nextToUpdate;
+    U32 const minChain = chainSize < target - idx ? target - chainSize : idx;
+    U32 const bucketSize = 1 << ZSTD_LAZY_DDSS_BUCKET_LOG;
+    U32 const cacheSize = bucketSize - 1;
+    U32 const chainAttempts = (1 << ms->cParams.searchLog) - cacheSize;
+    U32 const chainLimit = chainAttempts > 255 ? 255 : chainAttempts;
+
+    /* We know the hashtable is oversized by a factor of `bucketSize`.
+     * We are going to temporarily pretend `bucketSize == 1`, keeping only a
+     * single entry. We will use the rest of the space to construct a temporary
+     * chaintable.
+     */
+    U32 const hashLog = ms->cParams.hashLog - ZSTD_LAZY_DDSS_BUCKET_LOG;
+    U32* const tmpHashTable = hashTable;
+    U32* const tmpChainTable = hashTable + ((size_t)1 << hashLog);
+    U32 const tmpChainSize = (U32)((1 << ZSTD_LAZY_DDSS_BUCKET_LOG) - 1) << hashLog;
+    U32 const tmpMinChain = tmpChainSize < target ? target - tmpChainSize : idx;
+    U32 hashIdx;
+
+    assert(ms->cParams.chainLog <= 24);
+    assert(ms->cParams.hashLog > ms->cParams.chainLog);
+    assert(idx != 0);
+    assert(tmpMinChain <= minChain);
+
+    /* fill conventional hash table and conventional chain table */
+    for ( ; idx < target; idx++) {
+        U32 const h = (U32)ZSTD_hashPtr(base + idx, hashLog, ms->cParams.minMatch);
+        if (idx >= tmpMinChain) {
+            tmpChainTable[idx - tmpMinChain] = hashTable[h];
+        }
+        tmpHashTable[h] = idx;
+    }
+
+    /* sort chains into ddss chain table */
+    {
+        U32 chainPos = 0;
+        for (hashIdx = 0; hashIdx < (1U << hashLog); hashIdx++) {
+            U32 count;
+            U32 countBeyondMinChain = 0;
+            U32 i = tmpHashTable[hashIdx];
+            for (count = 0; i >= tmpMinChain && count < cacheSize; count++) {
+                /* skip through the chain to the first position that won't be
+                 * in the hash cache bucket */
+                if (i < minChain) {
+                    countBeyondMinChain++;
+                }
+                i = tmpChainTable[i - tmpMinChain];
+            }
+            if (count == cacheSize) {
+                for (count = 0; count < chainLimit;) {
+                    if (i < minChain) {
+                        if (!i || ++countBeyondMinChain > cacheSize) {
+                            /* only allow pulling `cacheSize` number of entries
+                             * into the cache or chainTable beyond `minChain`,
+                             * to replace the entries pulled out of the
+                             * chainTable into the cache. This lets us reach
+                             * back further without increasing the total number
+                             * of entries in the chainTable, guaranteeing the
+                             * DDSS chain table will fit into the space
+                             * allocated for the regular one. */
+                            break;
+                        }
+                    }
+                    chainTable[chainPos++] = i;
+                    count++;
+                    if (i < tmpMinChain) {
+                        break;
+                    }
+                    i = tmpChainTable[i - tmpMinChain];
+                }
+            } else {
+                count = 0;
+            }
+            if (count) {
+                tmpHashTable[hashIdx] = ((chainPos - count) << 8) + count;
+            } else {
+                tmpHashTable[hashIdx] = 0;
+            }
+        }
+        assert(chainPos <= chainSize); /* I believe this is guaranteed... */
+    }
+
+    /* move chain pointers into the last entry of each hash bucket */
+    for (hashIdx = (1 << hashLog); hashIdx; ) {
+        U32 const bucketIdx = --hashIdx << ZSTD_LAZY_DDSS_BUCKET_LOG;
+        U32 const chainPackedPointer = tmpHashTable[hashIdx];
+        U32 i;
+        for (i = 0; i < cacheSize; i++) {
+            hashTable[bucketIdx + i] = 0;
+        }
+        hashTable[bucketIdx + bucketSize - 1] = chainPackedPointer;
+    }
+
+    /* fill the buckets of the hash table */
+    for (idx = ms->nextToUpdate; idx < target; idx++) {
+        U32 const h = (U32)ZSTD_hashPtr(base + idx, hashLog, ms->cParams.minMatch)
+                   << ZSTD_LAZY_DDSS_BUCKET_LOG;
+        U32 i;
+        /* Shift hash cache down 1. */
+        for (i = cacheSize - 1; i; i--)
+            hashTable[h + i] = hashTable[h + i - 1];
+        hashTable[h] = idx;
+    }
+
+    ms->nextToUpdate = target;
+}
+
+/* Returns the longest match length found in the dedicated dict search structure.
+ * If none are longer than the argument ml, then ml will be returned.
+ */
+FORCE_INLINE_TEMPLATE
+size_t ZSTD_dedicatedDictSearch_lazy_search(size_t* offsetPtr, size_t ml, U32 nbAttempts,
+                                            const ZSTD_matchState_t* const dms,
+                                            const BYTE* const ip, const BYTE* const iLimit,
+                                            const BYTE* const prefixStart, const U32 curr,
+                                            const U32 dictLimit, const size_t ddsIdx) {
+    const U32 ddsLowestIndex  = dms->window.dictLimit;
+    const BYTE* const ddsBase = dms->window.base;
+    const BYTE* const ddsEnd  = dms->window.nextSrc;
+    const U32 ddsSize         = (U32)(ddsEnd - ddsBase);
+    const U32 ddsIndexDelta   = dictLimit - ddsSize;
+    const U32 bucketSize      = (1 << ZSTD_LAZY_DDSS_BUCKET_LOG);
+    const U32 bucketLimit     = nbAttempts < bucketSize - 1 ? nbAttempts : bucketSize - 1;
+    U32 ddsAttempt;
+    U32 matchIndex;
+
+    for (ddsAttempt = 0; ddsAttempt < bucketSize - 1; ddsAttempt++) {
+        PREFETCH_L1(ddsBase + dms->hashTable[ddsIdx + ddsAttempt]);
+    }
+
+    {
+        U32 const chainPackedPointer = dms->hashTable[ddsIdx + bucketSize - 1];
+        U32 const chainIndex = chainPackedPointer >> 8;
+
+        PREFETCH_L1(&dms->chainTable[chainIndex]);
+    }
+
+    for (ddsAttempt = 0; ddsAttempt < bucketLimit; ddsAttempt++) {
+        size_t currentMl=0;
+        const BYTE* match;
+        matchIndex = dms->hashTable[ddsIdx + ddsAttempt];
+        match = ddsBase + matchIndex;
+
+        if (!matchIndex) {
+            return ml;
+        }
+
+        /* guaranteed by table construction */
+        (void)ddsLowestIndex;
+        assert(matchIndex >= ddsLowestIndex);
+        assert(match+4 <= ddsEnd);
+        if (MEM_read32(match) == MEM_read32(ip)) {
+            /* assumption : matchIndex <= dictLimit-4 (by table construction) */
+            currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, ddsEnd, prefixStart) + 4;
+        }
+
+        /* save best solution */
+        if (currentMl > ml) {
+            ml = currentMl;
+            *offsetPtr = OFFSET_TO_OFFBASE(curr - (matchIndex + ddsIndexDelta));
+            if (ip+currentMl == iLimit) {
+                /* best possible, avoids read overflow on next attempt */
+                return ml;
+            }
+        }
+    }
+
+    {
+        U32 const chainPackedPointer = dms->hashTable[ddsIdx + bucketSize - 1];
+        U32 chainIndex = chainPackedPointer >> 8;
+        U32 const chainLength = chainPackedPointer & 0xFF;
+        U32 const chainAttempts = nbAttempts - ddsAttempt;
+        U32 const chainLimit = chainAttempts > chainLength ? chainLength : chainAttempts;
+        U32 chainAttempt;
+
+        for (chainAttempt = 0 ; chainAttempt < chainLimit; chainAttempt++) {
+            PREFETCH_L1(ddsBase + dms->chainTable[chainIndex + chainAttempt]);
+        }
+
+        for (chainAttempt = 0 ; chainAttempt < chainLimit; chainAttempt++, chainIndex++) {
+            size_t currentMl=0;
+            const BYTE* match;
+            matchIndex = dms->chainTable[chainIndex];
+            match = ddsBase + matchIndex;
+
+            /* guaranteed by table construction */
+            assert(matchIndex >= ddsLowestIndex);
+            assert(match+4 <= ddsEnd);
+            if (MEM_read32(match) == MEM_read32(ip)) {
+                /* assumption : matchIndex <= dictLimit-4 (by table construction) */
+                currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, ddsEnd, prefixStart) + 4;
+            }
+
+            /* save best solution */
+            if (currentMl > ml) {
+                ml = currentMl;
+                *offsetPtr = OFFSET_TO_OFFBASE(curr - (matchIndex + ddsIndexDelta));
+                if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */
+            }
+        }
+    }
+    return ml;
+}
+
+
+/* *********************************
+*  Hash Chain
+***********************************/
+#define NEXT_IN_CHAIN(d, mask)   chainTable[(d) & (mask)]
+
+/* Update chains up to ip (excluded)
+   Assumption : always within prefix (i.e. not within extDict) */
+FORCE_INLINE_TEMPLATE U32 ZSTD_insertAndFindFirstIndex_internal(
+                        ZSTD_matchState_t* ms,
+                        const ZSTD_compressionParameters* const cParams,
+                        const BYTE* ip, U32 const mls, U32 const lazySkipping)
+{
+    U32* const hashTable  = ms->hashTable;
+    const U32 hashLog = cParams->hashLog;
+    U32* const chainTable = ms->chainTable;
+    const U32 chainMask = (1 << cParams->chainLog) - 1;
+    const BYTE* const base = ms->window.base;
+    const U32 target = (U32)(ip - base);
+    U32 idx = ms->nextToUpdate;
+
+    while(idx < target) { /* catch up */
+        size_t const h = ZSTD_hashPtr(base+idx, hashLog, mls);
+        NEXT_IN_CHAIN(idx, chainMask) = hashTable[h];
+        hashTable[h] = idx;
+        idx++;
+        /* Stop inserting every position when in the lazy skipping mode. */
+        if (lazySkipping)
+            break;
+    }
+
+    ms->nextToUpdate = target;
+    return hashTable[ZSTD_hashPtr(ip, hashLog, mls)];
+}
+
+U32 ZSTD_insertAndFindFirstIndex(ZSTD_matchState_t* ms, const BYTE* ip) {
+    const ZSTD_compressionParameters* const cParams = &ms->cParams;
+    return ZSTD_insertAndFindFirstIndex_internal(ms, cParams, ip, ms->cParams.minMatch, /* lazySkipping*/ 0);
+}
+
+/* inlining is important to hardwire a hot branch (template emulation) */
+FORCE_INLINE_TEMPLATE
+size_t ZSTD_HcFindBestMatch(
+                        ZSTD_matchState_t* ms,
+                        const BYTE* const ip, const BYTE* const iLimit,
+                        size_t* offsetPtr,
+                        const U32 mls, const ZSTD_dictMode_e dictMode)
+{
+    const ZSTD_compressionParameters* const cParams = &ms->cParams;
+    U32* const chainTable = ms->chainTable;
+    const U32 chainSize = (1 << cParams->chainLog);
+    const U32 chainMask = chainSize-1;
+    const BYTE* const base = ms->window.base;
+    const BYTE* const dictBase = ms->window.dictBase;
+    const U32 dictLimit = ms->window.dictLimit;
+    const BYTE* const prefixStart = base + dictLimit;
+    const BYTE* const dictEnd = dictBase + dictLimit;
+    const U32 curr = (U32)(ip-base);
+    const U32 maxDistance = 1U << cParams->windowLog;
+    const U32 lowestValid = ms->window.lowLimit;
+    const U32 withinMaxDistance = (curr - lowestValid > maxDistance) ? curr - maxDistance : lowestValid;
+    const U32 isDictionary = (ms->loadedDictEnd != 0);
+    const U32 lowLimit = isDictionary ? lowestValid : withinMaxDistance;
+    const U32 minChain = curr > chainSize ? curr - chainSize : 0;
+    U32 nbAttempts = 1U << cParams->searchLog;
+    size_t ml=4-1;
+
+    const ZSTD_matchState_t* const dms = ms->dictMatchState;
+    const U32 ddsHashLog = dictMode == ZSTD_dedicatedDictSearch
+                         ? dms->cParams.hashLog - ZSTD_LAZY_DDSS_BUCKET_LOG : 0;
+    const size_t ddsIdx = dictMode == ZSTD_dedicatedDictSearch
+                        ? ZSTD_hashPtr(ip, ddsHashLog, mls) << ZSTD_LAZY_DDSS_BUCKET_LOG : 0;
+
+    U32 matchIndex;
+
+    if (dictMode == ZSTD_dedicatedDictSearch) {
+        const U32* entry = &dms->hashTable[ddsIdx];
+        PREFETCH_L1(entry);
+    }
+
+    /* HC4 match finder */
+    matchIndex = ZSTD_insertAndFindFirstIndex_internal(ms, cParams, ip, mls, ms->lazySkipping);
+
+    for ( ; (matchIndex>=lowLimit) & (nbAttempts>0) ; nbAttempts--) {
+        size_t currentMl=0;
+        if ((dictMode != ZSTD_extDict) || matchIndex >= dictLimit) {
+            const BYTE* const match = base + matchIndex;
+            assert(matchIndex >= dictLimit);   /* ensures this is true if dictMode != ZSTD_extDict */
+            /* read 4B starting from (match + ml + 1 - sizeof(U32)) */
+            if (MEM_read32(match + ml - 3) == MEM_read32(ip + ml - 3))   /* potentially better */
+                currentMl = ZSTD_count(ip, match, iLimit);
+        } else {
+            const BYTE* const match = dictBase + matchIndex;
+            assert(match+4 <= dictEnd);
+            if (MEM_read32(match) == MEM_read32(ip))   /* assumption : matchIndex <= dictLimit-4 (by table construction) */
+                currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dictEnd, prefixStart) + 4;
+        }
+
+        /* save best solution */
+        if (currentMl > ml) {
+            ml = currentMl;
+            *offsetPtr = OFFSET_TO_OFFBASE(curr - matchIndex);
+            if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */
+        }
+
+        if (matchIndex <= minChain) break;
+        matchIndex = NEXT_IN_CHAIN(matchIndex, chainMask);
+    }
+
+    assert(nbAttempts <= (1U << ZSTD_SEARCHLOG_MAX)); /* Check we haven't underflowed. */
+    if (dictMode == ZSTD_dedicatedDictSearch) {
+        ml = ZSTD_dedicatedDictSearch_lazy_search(offsetPtr, ml, nbAttempts, dms,
+                                                  ip, iLimit, prefixStart, curr, dictLimit, ddsIdx);
+    } else if (dictMode == ZSTD_dictMatchState) {
+        const U32* const dmsChainTable = dms->chainTable;
+        const U32 dmsChainSize         = (1 << dms->cParams.chainLog);
+        const U32 dmsChainMask         = dmsChainSize - 1;
+        const U32 dmsLowestIndex       = dms->window.dictLimit;
+        const BYTE* const dmsBase      = dms->window.base;
+        const BYTE* const dmsEnd       = dms->window.nextSrc;
+        const U32 dmsSize              = (U32)(dmsEnd - dmsBase);
+        const U32 dmsIndexDelta        = dictLimit - dmsSize;
+        const U32 dmsMinChain = dmsSize > dmsChainSize ? dmsSize - dmsChainSize : 0;
+
+        matchIndex = dms->hashTable[ZSTD_hashPtr(ip, dms->cParams.hashLog, mls)];
+
+        for ( ; (matchIndex>=dmsLowestIndex) & (nbAttempts>0) ; nbAttempts--) {
+            size_t currentMl=0;
+            const BYTE* const match = dmsBase + matchIndex;
+            assert(match+4 <= dmsEnd);
+            if (MEM_read32(match) == MEM_read32(ip))   /* assumption : matchIndex <= dictLimit-4 (by table construction) */
+                currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dmsEnd, prefixStart) + 4;
+
+            /* save best solution */
+            if (currentMl > ml) {
+                ml = currentMl;
+                assert(curr > matchIndex + dmsIndexDelta);
+                *offsetPtr = OFFSET_TO_OFFBASE(curr - (matchIndex + dmsIndexDelta));
+                if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */
+            }
+
+            if (matchIndex <= dmsMinChain) break;
+
+            matchIndex = dmsChainTable[matchIndex & dmsChainMask];
+        }
+    }
+
+    return ml;
+}
+
+/* *********************************
+* (SIMD) Row-based matchfinder
+***********************************/
+/* Constants for row-based hash */
+#define ZSTD_ROW_HASH_TAG_MASK ((1u << ZSTD_ROW_HASH_TAG_BITS) - 1)
+#define ZSTD_ROW_HASH_MAX_ENTRIES 64    /* absolute maximum number of entries per row, for all configurations */
+
+#define ZSTD_ROW_HASH_CACHE_MASK (ZSTD_ROW_HASH_CACHE_SIZE - 1)
+
+typedef U64 ZSTD_VecMask;   /* Clarifies when we are interacting with a U64 representing a mask of matches */
+
+/* ZSTD_VecMask_next():
+ * Starting from the LSB, returns the idx of the next non-zero bit.
+ * Basically counting the nb of trailing zeroes.
+ */
+MEM_STATIC U32 ZSTD_VecMask_next(ZSTD_VecMask val) {
+    return ZSTD_countTrailingZeros64(val);
+}
+
+/* ZSTD_row_nextIndex():
+ * Returns the next index to insert at within a tagTable row, and updates the "head"
+ * value to reflect the update. Essentially cycles backwards from [1, {entries per row})
+ */
+FORCE_INLINE_TEMPLATE U32 ZSTD_row_nextIndex(BYTE* const tagRow, U32 const rowMask) {
+    U32 next = (*tagRow-1) & rowMask;
+    next += (next == 0) ? rowMask : 0; /* skip first position */
+    *tagRow = (BYTE)next;
+    return next;
+}
+
+/* ZSTD_isAligned():
+ * Checks that a pointer is aligned to "align" bytes which must be a power of 2.
+ */
+MEM_STATIC int ZSTD_isAligned(void const* ptr, size_t align) {
+    assert((align & (align - 1)) == 0);
+    return (((size_t)ptr) & (align - 1)) == 0;
+}
+
+/* ZSTD_row_prefetch():
+ * Performs prefetching for the hashTable and tagTable at a given row.
+ */
+FORCE_INLINE_TEMPLATE void ZSTD_row_prefetch(U32 const* hashTable, BYTE const* tagTable, U32 const relRow, U32 const rowLog) {
+    PREFETCH_L1(hashTable + relRow);
+    if (rowLog >= 5) {
+        PREFETCH_L1(hashTable + relRow + 16);
+        /* Note: prefetching more of the hash table does not appear to be beneficial for 128-entry rows */
+    }
+    PREFETCH_L1(tagTable + relRow);
+    if (rowLog == 6) {
+        PREFETCH_L1(tagTable + relRow + 32);
+    }
+    assert(rowLog == 4 || rowLog == 5 || rowLog == 6);
+    assert(ZSTD_isAligned(hashTable + relRow, 64));                 /* prefetched hash row always 64-byte aligned */
+    assert(ZSTD_isAligned(tagTable + relRow, (size_t)1 << rowLog)); /* prefetched tagRow sits on correct multiple of bytes (32,64,128) */
+}
+
+/* ZSTD_row_fillHashCache():
+ * Fill up the hash cache starting at idx, prefetching up to ZSTD_ROW_HASH_CACHE_SIZE entries,
+ * but not beyond iLimit.
+ */
+FORCE_INLINE_TEMPLATE void ZSTD_row_fillHashCache(ZSTD_matchState_t* ms, const BYTE* base,
+                                   U32 const rowLog, U32 const mls,
+                                   U32 idx, const BYTE* const iLimit)
+{
+    U32 const* const hashTable = ms->hashTable;
+    BYTE const* const tagTable = ms->tagTable;
+    U32 const hashLog = ms->rowHashLog;
+    U32 const maxElemsToPrefetch = (base + idx) > iLimit ? 0 : (U32)(iLimit - (base + idx) + 1);
+    U32 const lim = idx + MIN(ZSTD_ROW_HASH_CACHE_SIZE, maxElemsToPrefetch);
+
+    for (; idx < lim; ++idx) {
+        U32 const hash = (U32)ZSTD_hashPtrSalted(base + idx, hashLog + ZSTD_ROW_HASH_TAG_BITS, mls, ms->hashSalt);
+        U32 const row = (hash >> ZSTD_ROW_HASH_TAG_BITS) << rowLog;
+        ZSTD_row_prefetch(hashTable, tagTable, row, rowLog);
+        ms->hashCache[idx & ZSTD_ROW_HASH_CACHE_MASK] = hash;
+    }
+
+    DEBUGLOG(6, "ZSTD_row_fillHashCache(): [%u %u %u %u %u %u %u %u]", ms->hashCache[0], ms->hashCache[1],
+                                                     ms->hashCache[2], ms->hashCache[3], ms->hashCache[4],
+                                                     ms->hashCache[5], ms->hashCache[6], ms->hashCache[7]);
+}
+
+/* ZSTD_row_nextCachedHash():
+ * Returns the hash of base + idx, and replaces the hash in the hash cache with the byte at
+ * base + idx + ZSTD_ROW_HASH_CACHE_SIZE. Also prefetches the appropriate rows from hashTable and tagTable.
+ */
+FORCE_INLINE_TEMPLATE U32 ZSTD_row_nextCachedHash(U32* cache, U32 const* hashTable,
+                                                  BYTE const* tagTable, BYTE const* base,
+                                                  U32 idx, U32 const hashLog,
+                                                  U32 const rowLog, U32 const mls,
+                                                  U64 const hashSalt)
+{
+    U32 const newHash = (U32)ZSTD_hashPtrSalted(base+idx+ZSTD_ROW_HASH_CACHE_SIZE, hashLog + ZSTD_ROW_HASH_TAG_BITS, mls, hashSalt);
+    U32 const row = (newHash >> ZSTD_ROW_HASH_TAG_BITS) << rowLog;
+    ZSTD_row_prefetch(hashTable, tagTable, row, rowLog);
+    {   U32 const hash = cache[idx & ZSTD_ROW_HASH_CACHE_MASK];
+        cache[idx & ZSTD_ROW_HASH_CACHE_MASK] = newHash;
+        return hash;
+    }
+}
+
+/* ZSTD_row_update_internalImpl():
+ * Updates the hash table with positions starting from updateStartIdx until updateEndIdx.
+ */
+FORCE_INLINE_TEMPLATE void ZSTD_row_update_internalImpl(ZSTD_matchState_t* ms,
+                                                        U32 updateStartIdx, U32 const updateEndIdx,
+                                                        U32 const mls, U32 const rowLog,
+                                                        U32 const rowMask, U32 const useCache)
+{
+    U32* const hashTable = ms->hashTable;
+    BYTE* const tagTable = ms->tagTable;
+    U32 const hashLog = ms->rowHashLog;
+    const BYTE* const base = ms->window.base;
+
+    DEBUGLOG(6, "ZSTD_row_update_internalImpl(): updateStartIdx=%u, updateEndIdx=%u", updateStartIdx, updateEndIdx);
+    for (; updateStartIdx < updateEndIdx; ++updateStartIdx) {
+        U32 const hash = useCache ? ZSTD_row_nextCachedHash(ms->hashCache, hashTable, tagTable, base, updateStartIdx, hashLog, rowLog, mls, ms->hashSalt)
+                                  : (U32)ZSTD_hashPtrSalted(base + updateStartIdx, hashLog + ZSTD_ROW_HASH_TAG_BITS, mls, ms->hashSalt);
+        U32 const relRow = (hash >> ZSTD_ROW_HASH_TAG_BITS) << rowLog;
+        U32* const row = hashTable + relRow;
+        BYTE* tagRow = tagTable + relRow;
+        U32 const pos = ZSTD_row_nextIndex(tagRow, rowMask);
+
+        assert(hash == ZSTD_hashPtrSalted(base + updateStartIdx, hashLog + ZSTD_ROW_HASH_TAG_BITS, mls, ms->hashSalt));
+        tagRow[pos] = hash & ZSTD_ROW_HASH_TAG_MASK;
+        row[pos] = updateStartIdx;
+    }
+}
+
+/* ZSTD_row_update_internal():
+ * Inserts the byte at ip into the appropriate position in the hash table, and updates ms->nextToUpdate.
+ * Skips sections of long matches as is necessary.
+ */
+FORCE_INLINE_TEMPLATE void ZSTD_row_update_internal(ZSTD_matchState_t* ms, const BYTE* ip,
+                                                    U32 const mls, U32 const rowLog,
+                                                    U32 const rowMask, U32 const useCache)
+{
+    U32 idx = ms->nextToUpdate;
+    const BYTE* const base = ms->window.base;
+    const U32 target = (U32)(ip - base);
+    const U32 kSkipThreshold = 384;
+    const U32 kMaxMatchStartPositionsToUpdate = 96;
+    const U32 kMaxMatchEndPositionsToUpdate = 32;
+
+    if (useCache) {
+        /* Only skip positions when using hash cache, i.e.
+         * if we are loading a dict, don't skip anything.
+         * If we decide to skip, then we only update a set number
+         * of positions at the beginning and end of the match.
+         */
+        if (UNLIKELY(target - idx > kSkipThreshold)) {
+            U32 const bound = idx + kMaxMatchStartPositionsToUpdate;
+            ZSTD_row_update_internalImpl(ms, idx, bound, mls, rowLog, rowMask, useCache);
+            idx = target - kMaxMatchEndPositionsToUpdate;
+            ZSTD_row_fillHashCache(ms, base, rowLog, mls, idx, ip+1);
+        }
+    }
+    assert(target >= idx);
+    ZSTD_row_update_internalImpl(ms, idx, target, mls, rowLog, rowMask, useCache);
+    ms->nextToUpdate = target;
+}
+
+/* ZSTD_row_update():
+ * External wrapper for ZSTD_row_update_internal(). Used for filling the hashtable during dictionary
+ * processing.
+ */
+void ZSTD_row_update(ZSTD_matchState_t* const ms, const BYTE* ip) {
+    const U32 rowLog = BOUNDED(4, ms->cParams.searchLog, 6);
+    const U32 rowMask = (1u << rowLog) - 1;
+    const U32 mls = MIN(ms->cParams.minMatch, 6 /* mls caps out at 6 */);
+
+    DEBUGLOG(5, "ZSTD_row_update(), rowLog=%u", rowLog);
+    ZSTD_row_update_internal(ms, ip, mls, rowLog, rowMask, 0 /* don't use cache */);
+}
+
+/* Returns the mask width of bits group of which will be set to 1. Given not all
+ * architectures have easy movemask instruction, this helps to iterate over
+ * groups of bits easier and faster.
+ */
+FORCE_INLINE_TEMPLATE U32
+ZSTD_row_matchMaskGroupWidth(const U32 rowEntries)
+{
+    assert((rowEntries == 16) || (rowEntries == 32) || rowEntries == 64);
+    assert(rowEntries <= ZSTD_ROW_HASH_MAX_ENTRIES);
+    (void)rowEntries;
+#if defined(ZSTD_ARCH_ARM_NEON)
+    /* NEON path only works for little endian */
+    if (!MEM_isLittleEndian()) {
+        return 1;
+    }
+    if (rowEntries == 16) {
+        return 4;
+    }
+    if (rowEntries == 32) {
+        return 2;
+    }
+    if (rowEntries == 64) {
+        return 1;
+    }
+#endif
+    return 1;
+}
+
+#if defined(ZSTD_ARCH_X86_SSE2)
+FORCE_INLINE_TEMPLATE ZSTD_VecMask
+ZSTD_row_getSSEMask(int nbChunks, const BYTE* const src, const BYTE tag, const U32 head)
+{
+    const __m128i comparisonMask = _mm_set1_epi8((char)tag);
+    int matches[4] = {0};
+    int i;
+    assert(nbChunks == 1 || nbChunks == 2 || nbChunks == 4);
+    for (i=0; i<nbChunks; i++) {
+        const __m128i chunk = _mm_loadu_si128((const __m128i*)(const void*)(src + 16*i));
+        const __m128i equalMask = _mm_cmpeq_epi8(chunk, comparisonMask);
+        matches[i] = _mm_movemask_epi8(equalMask);
+    }
+    if (nbChunks == 1) return ZSTD_rotateRight_U16((U16)matches[0], head);
+    if (nbChunks == 2) return ZSTD_rotateRight_U32((U32)matches[1] << 16 | (U32)matches[0], head);
+    assert(nbChunks == 4);
+    return ZSTD_rotateRight_U64((U64)matches[3] << 48 | (U64)matches[2] << 32 | (U64)matches[1] << 16 | (U64)matches[0], head);
+}
+#endif
+
+#if defined(ZSTD_ARCH_ARM_NEON)
+FORCE_INLINE_TEMPLATE ZSTD_VecMask
+ZSTD_row_getNEONMask(const U32 rowEntries, const BYTE* const src, const BYTE tag, const U32 headGrouped)
+{
+    assert((rowEntries == 16) || (rowEntries == 32) || rowEntries == 64);
+    if (rowEntries == 16) {
+        /* vshrn_n_u16 shifts by 4 every u16 and narrows to 8 lower bits.
+         * After that groups of 4 bits represent the equalMask. We lower
+         * all bits except the highest in these groups by doing AND with
+         * 0x88 = 0b10001000.
+         */
+        const uint8x16_t chunk = vld1q_u8(src);
+        const uint16x8_t equalMask = vreinterpretq_u16_u8(vceqq_u8(chunk, vdupq_n_u8(tag)));
+        const uint8x8_t res = vshrn_n_u16(equalMask, 4);
+        const U64 matches = vget_lane_u64(vreinterpret_u64_u8(res), 0);
+        return ZSTD_rotateRight_U64(matches, headGrouped) & 0x8888888888888888ull;
+    } else if (rowEntries == 32) {
+        /* Same idea as with rowEntries == 16 but doing AND with
+         * 0x55 = 0b01010101.
+         */
+        const uint16x8x2_t chunk = vld2q_u16((const uint16_t*)(const void*)src);
+        const uint8x16_t chunk0 = vreinterpretq_u8_u16(chunk.val[0]);
+        const uint8x16_t chunk1 = vreinterpretq_u8_u16(chunk.val[1]);
+        const uint8x16_t dup = vdupq_n_u8(tag);
+        const uint8x8_t t0 = vshrn_n_u16(vreinterpretq_u16_u8(vceqq_u8(chunk0, dup)), 6);
+        const uint8x8_t t1 = vshrn_n_u16(vreinterpretq_u16_u8(vceqq_u8(chunk1, dup)), 6);
+        const uint8x8_t res = vsli_n_u8(t0, t1, 4);
+        const U64 matches = vget_lane_u64(vreinterpret_u64_u8(res), 0) ;
+        return ZSTD_rotateRight_U64(matches, headGrouped) & 0x5555555555555555ull;
+    } else { /* rowEntries == 64 */
+        const uint8x16x4_t chunk = vld4q_u8(src);
+        const uint8x16_t dup = vdupq_n_u8(tag);
+        const uint8x16_t cmp0 = vceqq_u8(chunk.val[0], dup);
+        const uint8x16_t cmp1 = vceqq_u8(chunk.val[1], dup);
+        const uint8x16_t cmp2 = vceqq_u8(chunk.val[2], dup);
+        const uint8x16_t cmp3 = vceqq_u8(chunk.val[3], dup);
+
+        const uint8x16_t t0 = vsriq_n_u8(cmp1, cmp0, 1);
+        const uint8x16_t t1 = vsriq_n_u8(cmp3, cmp2, 1);
+        const uint8x16_t t2 = vsriq_n_u8(t1, t0, 2);
+        const uint8x16_t t3 = vsriq_n_u8(t2, t2, 4);
+        const uint8x8_t t4 = vshrn_n_u16(vreinterpretq_u16_u8(t3), 4);
+        const U64 matches = vget_lane_u64(vreinterpret_u64_u8(t4), 0);
+        return ZSTD_rotateRight_U64(matches, headGrouped);
+    }
+}
+#endif
+
+/* Returns a ZSTD_VecMask (U64) that has the nth group (determined by
+ * ZSTD_row_matchMaskGroupWidth) of bits set to 1 if the newly-computed "tag"
+ * matches the hash at the nth position in a row of the tagTable.
+ * Each row is a circular buffer beginning at the value of "headGrouped". So we
+ * must rotate the "matches" bitfield to match up with the actual layout of the
+ * entries within the hashTable */
+FORCE_INLINE_TEMPLATE ZSTD_VecMask
+ZSTD_row_getMatchMask(const BYTE* const tagRow, const BYTE tag, const U32 headGrouped, const U32 rowEntries)
+{
+    const BYTE* const src = tagRow;
+    assert((rowEntries == 16) || (rowEntries == 32) || rowEntries == 64);
+    assert(rowEntries <= ZSTD_ROW_HASH_MAX_ENTRIES);
+    assert(ZSTD_row_matchMaskGroupWidth(rowEntries) * rowEntries <= sizeof(ZSTD_VecMask) * 8);
+
+#if defined(ZSTD_ARCH_X86_SSE2)
+
+    return ZSTD_row_getSSEMask(rowEntries / 16, src, tag, headGrouped);
+
+#else /* SW or NEON-LE */
+
+# if defined(ZSTD_ARCH_ARM_NEON)
+  /* This NEON path only works for little endian - otherwise use SWAR below */
+    if (MEM_isLittleEndian()) {
+        return ZSTD_row_getNEONMask(rowEntries, src, tag, headGrouped);
+    }
+# endif /* ZSTD_ARCH_ARM_NEON */
+    /* SWAR */
+    {   const int chunkSize = sizeof(size_t);
+        const size_t shiftAmount = ((chunkSize * 8) - chunkSize);
+        const size_t xFF = ~((size_t)0);
+        const size_t x01 = xFF / 0xFF;
+        const size_t x80 = x01 << 7;
+        const size_t splatChar = tag * x01;
+        ZSTD_VecMask matches = 0;
+        int i = rowEntries - chunkSize;
+        assert((sizeof(size_t) == 4) || (sizeof(size_t) == 8));
+        if (MEM_isLittleEndian()) { /* runtime check so have two loops */
+            const size_t extractMagic = (xFF / 0x7F) >> chunkSize;
+            do {
+                size_t chunk = MEM_readST(&src[i]);
+                chunk ^= splatChar;
+                chunk = (((chunk | x80) - x01) | chunk) & x80;
+                matches <<= chunkSize;
+                matches |= (chunk * extractMagic) >> shiftAmount;
+                i -= chunkSize;
+            } while (i >= 0);
+        } else { /* big endian: reverse bits during extraction */
+            const size_t msb = xFF ^ (xFF >> 1);
+            const size_t extractMagic = (msb / 0x1FF) | msb;
+            do {
+                size_t chunk = MEM_readST(&src[i]);
+                chunk ^= splatChar;
+                chunk = (((chunk | x80) - x01) | chunk) & x80;
+                matches <<= chunkSize;
+                matches |= ((chunk >> 7) * extractMagic) >> shiftAmount;
+                i -= chunkSize;
+            } while (i >= 0);
+        }
+        matches = ~matches;
+        if (rowEntries == 16) {
+            return ZSTD_rotateRight_U16((U16)matches, headGrouped);
+        } else if (rowEntries == 32) {
+            return ZSTD_rotateRight_U32((U32)matches, headGrouped);
+        } else {
+            return ZSTD_rotateRight_U64((U64)matches, headGrouped);
+        }
+    }
+#endif
+}
+
+/* The high-level approach of the SIMD row based match finder is as follows:
+ * - Figure out where to insert the new entry:
+ *      - Generate a hash from a byte along with an additional 1-byte "short hash". The additional byte is our "tag"
+ *      - The hashTable is effectively split into groups or "rows" of 16 or 32 entries of U32, and the hash determines
+ *        which row to insert into.
+ *      - Determine the correct position within the row to insert the entry into. Each row of 16 or 32 can
+ *        be considered as a circular buffer with a "head" index that resides in the tagTable.
+ *      - Also insert the "tag" into the equivalent row and position in the tagTable.
+ *          - Note: The tagTable has 17 or 33 1-byte entries per row, due to 16 or 32 tags, and 1 "head" entry.
+ *                  The 17 or 33 entry rows are spaced out to occur every 32 or 64 bytes, respectively,
+ *                  for alignment/performance reasons, leaving some bytes unused.
+ * - Use SIMD to efficiently compare the tags in the tagTable to the 1-byte "short hash" and
+ *   generate a bitfield that we can cycle through to check the collisions in the hash table.
+ * - Pick the longest match.
+ */
+FORCE_INLINE_TEMPLATE
+size_t ZSTD_RowFindBestMatch(
+                        ZSTD_matchState_t* ms,
+                        const BYTE* const ip, const BYTE* const iLimit,
+                        size_t* offsetPtr,
+                        const U32 mls, const ZSTD_dictMode_e dictMode,
+                        const U32 rowLog)
+{
+    U32* const hashTable = ms->hashTable;
+    BYTE* const tagTable = ms->tagTable;
+    U32* const hashCache = ms->hashCache;
+    const U32 hashLog = ms->rowHashLog;
+    const ZSTD_compressionParameters* const cParams = &ms->cParams;
+    const BYTE* const base = ms->window.base;
+    const BYTE* const dictBase = ms->window.dictBase;
+    const U32 dictLimit = ms->window.dictLimit;
+    const BYTE* const prefixStart = base + dictLimit;
+    const BYTE* const dictEnd = dictBase + dictLimit;
+    const U32 curr = (U32)(ip-base);
+    const U32 maxDistance = 1U << cParams->windowLog;
+    const U32 lowestValid = ms->window.lowLimit;
+    const U32 withinMaxDistance = (curr - lowestValid > maxDistance) ? curr - maxDistance : lowestValid;
+    const U32 isDictionary = (ms->loadedDictEnd != 0);
+    const U32 lowLimit = isDictionary ? lowestValid : withinMaxDistance;
+    const U32 rowEntries = (1U << rowLog);
+    const U32 rowMask = rowEntries - 1;
+    const U32 cappedSearchLog = MIN(cParams->searchLog, rowLog); /* nb of searches is capped at nb entries per row */
+    const U32 groupWidth = ZSTD_row_matchMaskGroupWidth(rowEntries);
+    const U64 hashSalt = ms->hashSalt;
+    U32 nbAttempts = 1U << cappedSearchLog;
+    size_t ml=4-1;
+    U32 hash;
+
+    /* DMS/DDS variables that may be referenced laster */
+    const ZSTD_matchState_t* const dms = ms->dictMatchState;
+
+    /* Initialize the following variables to satisfy static analyzer */
+    size_t ddsIdx = 0;
+    U32 ddsExtraAttempts = 0; /* cctx hash tables are limited in searches, but allow extra searches into DDS */
+    U32 dmsTag = 0;
+    U32* dmsRow = NULL;
+    BYTE* dmsTagRow = NULL;
+
+    if (dictMode == ZSTD_dedicatedDictSearch) {
+        const U32 ddsHashLog = dms->cParams.hashLog - ZSTD_LAZY_DDSS_BUCKET_LOG;
+        {   /* Prefetch DDS hashtable entry */
+            ddsIdx = ZSTD_hashPtr(ip, ddsHashLog, mls) << ZSTD_LAZY_DDSS_BUCKET_LOG;
+            PREFETCH_L1(&dms->hashTable[ddsIdx]);
+        }
+        ddsExtraAttempts = cParams->searchLog > rowLog ? 1U << (cParams->searchLog - rowLog) : 0;
+    }
+
+    if (dictMode == ZSTD_dictMatchState) {
+        /* Prefetch DMS rows */
+        U32* const dmsHashTable = dms->hashTable;
+        BYTE* const dmsTagTable = dms->tagTable;
+        U32 const dmsHash = (U32)ZSTD_hashPtr(ip, dms->rowHashLog + ZSTD_ROW_HASH_TAG_BITS, mls);
+        U32 const dmsRelRow = (dmsHash >> ZSTD_ROW_HASH_TAG_BITS) << rowLog;
+        dmsTag = dmsHash & ZSTD_ROW_HASH_TAG_MASK;
+        dmsTagRow = (BYTE*)(dmsTagTable + dmsRelRow);
+        dmsRow = dmsHashTable + dmsRelRow;
+        ZSTD_row_prefetch(dmsHashTable, dmsTagTable, dmsRelRow, rowLog);
+    }
+
+    /* Update the hashTable and tagTable up to (but not including) ip */
+    if (!ms->lazySkipping) {
+        ZSTD_row_update_internal(ms, ip, mls, rowLog, rowMask, 1 /* useCache */);
+        hash = ZSTD_row_nextCachedHash(hashCache, hashTable, tagTable, base, curr, hashLog, rowLog, mls, hashSalt);
+    } else {
+        /* Stop inserting every position when in the lazy skipping mode.
+         * The hash cache is also not kept up to date in this mode.
+         */
+        hash = (U32)ZSTD_hashPtrSalted(ip, hashLog + ZSTD_ROW_HASH_TAG_BITS, mls, hashSalt);
+        ms->nextToUpdate = curr;
+    }
+    ms->hashSaltEntropy += hash; /* collect salt entropy */
+
+    {   /* Get the hash for ip, compute the appropriate row */
+        U32 const relRow = (hash >> ZSTD_ROW_HASH_TAG_BITS) << rowLog;
+        U32 const tag = hash & ZSTD_ROW_HASH_TAG_MASK;
+        U32* const row = hashTable + relRow;
+        BYTE* tagRow = (BYTE*)(tagTable + relRow);
+        U32 const headGrouped = (*tagRow & rowMask) * groupWidth;
+        U32 matchBuffer[ZSTD_ROW_HASH_MAX_ENTRIES];
+        size_t numMatches = 0;
+        size_t currMatch = 0;
+        ZSTD_VecMask matches = ZSTD_row_getMatchMask(tagRow, (BYTE)tag, headGrouped, rowEntries);
+
+        /* Cycle through the matches and prefetch */
+        for (; (matches > 0) && (nbAttempts > 0); matches &= (matches - 1)) {
+            U32 const matchPos = ((headGrouped + ZSTD_VecMask_next(matches)) / groupWidth) & rowMask;
+            U32 const matchIndex = row[matchPos];
+            if(matchPos == 0) continue;
+            assert(numMatches < rowEntries);
+            if (matchIndex < lowLimit)
+                break;
+            if ((dictMode != ZSTD_extDict) || matchIndex >= dictLimit) {
+                PREFETCH_L1(base + matchIndex);
+            } else {
+                PREFETCH_L1(dictBase + matchIndex);
+            }
+            matchBuffer[numMatches++] = matchIndex;
+            --nbAttempts;
+        }
+
+        /* Speed opt: insert current byte into hashtable too. This allows us to avoid one iteration of the loop
+           in ZSTD_row_update_internal() at the next search. */
+        {
+            U32 const pos = ZSTD_row_nextIndex(tagRow, rowMask);
+            tagRow[pos] = (BYTE)tag;
+            row[pos] = ms->nextToUpdate++;
+        }
+
+        /* Return the longest match */
+        for (; currMatch < numMatches; ++currMatch) {
+            U32 const matchIndex = matchBuffer[currMatch];
+            size_t currentMl=0;
+            assert(matchIndex < curr);
+            assert(matchIndex >= lowLimit);
+
+            if ((dictMode != ZSTD_extDict) || matchIndex >= dictLimit) {
+                const BYTE* const match = base + matchIndex;
+                assert(matchIndex >= dictLimit);   /* ensures this is true if dictMode != ZSTD_extDict */
+                /* read 4B starting from (match + ml + 1 - sizeof(U32)) */
+                if (MEM_read32(match + ml - 3) == MEM_read32(ip + ml - 3))   /* potentially better */
+                    currentMl = ZSTD_count(ip, match, iLimit);
+            } else {
+                const BYTE* const match = dictBase + matchIndex;
+                assert(match+4 <= dictEnd);
+                if (MEM_read32(match) == MEM_read32(ip))   /* assumption : matchIndex <= dictLimit-4 (by table construction) */
+                    currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dictEnd, prefixStart) + 4;
+            }
+
+            /* Save best solution */
+            if (currentMl > ml) {
+                ml = currentMl;
+                *offsetPtr = OFFSET_TO_OFFBASE(curr - matchIndex);
+                if (ip+currentMl == iLimit) break; /* best possible, avoids read overflow on next attempt */
+            }
+        }
+    }
+
+    assert(nbAttempts <= (1U << ZSTD_SEARCHLOG_MAX)); /* Check we haven't underflowed. */
+    if (dictMode == ZSTD_dedicatedDictSearch) {
+        ml = ZSTD_dedicatedDictSearch_lazy_search(offsetPtr, ml, nbAttempts + ddsExtraAttempts, dms,
+                                                  ip, iLimit, prefixStart, curr, dictLimit, ddsIdx);
+    } else if (dictMode == ZSTD_dictMatchState) {
+        /* TODO: Measure and potentially add prefetching to DMS */
+        const U32 dmsLowestIndex       = dms->window.dictLimit;
+        const BYTE* const dmsBase      = dms->window.base;
+        const BYTE* const dmsEnd       = dms->window.nextSrc;
+        const U32 dmsSize              = (U32)(dmsEnd - dmsBase);
+        const U32 dmsIndexDelta        = dictLimit - dmsSize;
+
+        {   U32 const headGrouped = (*dmsTagRow & rowMask) * groupWidth;
+            U32 matchBuffer[ZSTD_ROW_HASH_MAX_ENTRIES];
+            size_t numMatches = 0;
+            size_t currMatch = 0;
+            ZSTD_VecMask matches = ZSTD_row_getMatchMask(dmsTagRow, (BYTE)dmsTag, headGrouped, rowEntries);
+
+            for (; (matches > 0) && (nbAttempts > 0); matches &= (matches - 1)) {
+                U32 const matchPos = ((headGrouped + ZSTD_VecMask_next(matches)) / groupWidth) & rowMask;
+                U32 const matchIndex = dmsRow[matchPos];
+                if(matchPos == 0) continue;
+                if (matchIndex < dmsLowestIndex)
+                    break;
+                PREFETCH_L1(dmsBase + matchIndex);
+                matchBuffer[numMatches++] = matchIndex;
+                --nbAttempts;
+            }
+
+            /* Return the longest match */
+            for (; currMatch < numMatches; ++currMatch) {
+                U32 const matchIndex = matchBuffer[currMatch];
+                size_t currentMl=0;
+                assert(matchIndex >= dmsLowestIndex);
+                assert(matchIndex < curr);
+
+                {   const BYTE* const match = dmsBase + matchIndex;
+                    assert(match+4 <= dmsEnd);
+                    if (MEM_read32(match) == MEM_read32(ip))
+                        currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dmsEnd, prefixStart) + 4;
+                }
+
+                if (currentMl > ml) {
+                    ml = currentMl;
+                    assert(curr > matchIndex + dmsIndexDelta);
+                    *offsetPtr = OFFSET_TO_OFFBASE(curr - (matchIndex + dmsIndexDelta));
+                    if (ip+currentMl == iLimit) break;
+                }
+            }
+        }
+    }
+    return ml;
+}
+
+
+/**
+ * Generate search functions templated on (dictMode, mls, rowLog).
+ * These functions are outlined for code size & compilation time.
+ * ZSTD_searchMax() dispatches to the correct implementation function.
+ *
+ * TODO: The start of the search function involves loading and calculating a
+ * bunch of constants from the ZSTD_matchState_t. These computations could be
+ * done in an initialization function, and saved somewhere in the match state.
+ * Then we could pass a pointer to the saved state instead of the match state,
+ * and avoid duplicate computations.
+ *
+ * TODO: Move the match re-winding into searchMax. This improves compression
+ * ratio, and unlocks further simplifications with the next TODO.
+ *
+ * TODO: Try moving the repcode search into searchMax. After the re-winding
+ * and repcode search are in searchMax, there is no more logic in the match
+ * finder loop that requires knowledge about the dictMode. So we should be
+ * able to avoid force inlining it, and we can join the extDict loop with
+ * the single segment loop. It should go in searchMax instead of its own
+ * function to avoid having multiple virtual function calls per search.
+ */
+
+#define ZSTD_BT_SEARCH_FN(dictMode, mls) ZSTD_BtFindBestMatch_##dictMode##_##mls
+#define ZSTD_HC_SEARCH_FN(dictMode, mls) ZSTD_HcFindBestMatch_##dictMode##_##mls
+#define ZSTD_ROW_SEARCH_FN(dictMode, mls, rowLog) ZSTD_RowFindBestMatch_##dictMode##_##mls##_##rowLog
+
+#define ZSTD_SEARCH_FN_ATTRS FORCE_NOINLINE
+
+#define GEN_ZSTD_BT_SEARCH_FN(dictMode, mls)                                           \
+    ZSTD_SEARCH_FN_ATTRS size_t ZSTD_BT_SEARCH_FN(dictMode, mls)(                      \
+            ZSTD_matchState_t* ms,                                                     \
+            const BYTE* ip, const BYTE* const iLimit,                                  \
+            size_t* offBasePtr)                                                        \
+    {                                                                                  \
+        assert(MAX(4, MIN(6, ms->cParams.minMatch)) == mls);                           \
+        return ZSTD_BtFindBestMatch(ms, ip, iLimit, offBasePtr, mls, ZSTD_##dictMode); \
+    }                                                                                  \
+
+#define GEN_ZSTD_HC_SEARCH_FN(dictMode, mls)                                          \
+    ZSTD_SEARCH_FN_ATTRS size_t ZSTD_HC_SEARCH_FN(dictMode, mls)(                     \
+            ZSTD_matchState_t* ms,                                                    \
+            const BYTE* ip, const BYTE* const iLimit,                                 \
+            size_t* offsetPtr)                                                        \
+    {                                                                                 \
+        assert(MAX(4, MIN(6, ms->cParams.minMatch)) == mls);                          \
+        return ZSTD_HcFindBestMatch(ms, ip, iLimit, offsetPtr, mls, ZSTD_##dictMode); \
+    }                                                                                 \
+
+#define GEN_ZSTD_ROW_SEARCH_FN(dictMode, mls, rowLog)                                          \
+    ZSTD_SEARCH_FN_ATTRS size_t ZSTD_ROW_SEARCH_FN(dictMode, mls, rowLog)(                     \
+            ZSTD_matchState_t* ms,                                                             \
+            const BYTE* ip, const BYTE* const iLimit,                                          \
+            size_t* offsetPtr)                                                                 \
+    {                                                                                          \
+        assert(MAX(4, MIN(6, ms->cParams.minMatch)) == mls);                                   \
+        assert(MAX(4, MIN(6, ms->cParams.searchLog)) == rowLog);                               \
+        return ZSTD_RowFindBestMatch(ms, ip, iLimit, offsetPtr, mls, ZSTD_##dictMode, rowLog); \
+    }                                                                                          \
+
+#define ZSTD_FOR_EACH_ROWLOG(X, dictMode, mls) \
+    X(dictMode, mls, 4)                        \
+    X(dictMode, mls, 5)                        \
+    X(dictMode, mls, 6)
+
+#define ZSTD_FOR_EACH_MLS_ROWLOG(X, dictMode) \
+    ZSTD_FOR_EACH_ROWLOG(X, dictMode, 4)      \
+    ZSTD_FOR_EACH_ROWLOG(X, dictMode, 5)      \
+    ZSTD_FOR_EACH_ROWLOG(X, dictMode, 6)
+
+#define ZSTD_FOR_EACH_MLS(X, dictMode) \
+    X(dictMode, 4)                     \
+    X(dictMode, 5)                     \
+    X(dictMode, 6)
+
+#define ZSTD_FOR_EACH_DICT_MODE(X, ...) \
+    X(__VA_ARGS__, noDict)              \
+    X(__VA_ARGS__, extDict)             \
+    X(__VA_ARGS__, dictMatchState)      \
+    X(__VA_ARGS__, dedicatedDictSearch)
+
+/* Generate row search fns for each combination of (dictMode, mls, rowLog) */
+ZSTD_FOR_EACH_DICT_MODE(ZSTD_FOR_EACH_MLS_ROWLOG, GEN_ZSTD_ROW_SEARCH_FN)
+/* Generate binary Tree search fns for each combination of (dictMode, mls) */
+ZSTD_FOR_EACH_DICT_MODE(ZSTD_FOR_EACH_MLS, GEN_ZSTD_BT_SEARCH_FN)
+/* Generate hash chain search fns for each combination of (dictMode, mls) */
+ZSTD_FOR_EACH_DICT_MODE(ZSTD_FOR_EACH_MLS, GEN_ZSTD_HC_SEARCH_FN)
+
+typedef enum { search_hashChain=0, search_binaryTree=1, search_rowHash=2 } searchMethod_e;
+
+#define GEN_ZSTD_CALL_BT_SEARCH_FN(dictMode, mls)                         \
+    case mls:                                                             \
+        return ZSTD_BT_SEARCH_FN(dictMode, mls)(ms, ip, iend, offsetPtr);
+#define GEN_ZSTD_CALL_HC_SEARCH_FN(dictMode, mls)                         \
+    case mls:                                                             \
+        return ZSTD_HC_SEARCH_FN(dictMode, mls)(ms, ip, iend, offsetPtr);
+#define GEN_ZSTD_CALL_ROW_SEARCH_FN(dictMode, mls, rowLog)                         \
+    case rowLog:                                                                   \
+        return ZSTD_ROW_SEARCH_FN(dictMode, mls, rowLog)(ms, ip, iend, offsetPtr);
+
+#define ZSTD_SWITCH_MLS(X, dictMode)   \
+    switch (mls) {                     \
+        ZSTD_FOR_EACH_MLS(X, dictMode) \
+    }
+
+#define ZSTD_SWITCH_ROWLOG(dictMode, mls)                                    \
+    case mls:                                                                \
+        switch (rowLog) {                                                    \
+            ZSTD_FOR_EACH_ROWLOG(GEN_ZSTD_CALL_ROW_SEARCH_FN, dictMode, mls) \
+        }                                                                    \
+        ZSTD_UNREACHABLE;                                                    \
+        break;
+
+#define ZSTD_SWITCH_SEARCH_METHOD(dictMode)                       \
+    switch (searchMethod) {                                       \
+        case search_hashChain:                                    \
+            ZSTD_SWITCH_MLS(GEN_ZSTD_CALL_HC_SEARCH_FN, dictMode) \
+            break;                                                \
+        case search_binaryTree:                                   \
+            ZSTD_SWITCH_MLS(GEN_ZSTD_CALL_BT_SEARCH_FN, dictMode) \
+            break;                                                \
+        case search_rowHash:                                      \
+            ZSTD_SWITCH_MLS(ZSTD_SWITCH_ROWLOG, dictMode)         \
+            break;                                                \
+    }                                                             \
+    ZSTD_UNREACHABLE;
+
+/**
+ * Searches for the longest match at @p ip.
+ * Dispatches to the correct implementation function based on the
+ * (searchMethod, dictMode, mls, rowLog). We use switch statements
+ * here instead of using an indirect function call through a function
+ * pointer because after Spectre and Meltdown mitigations, indirect
+ * function calls can be very costly, especially in the kernel.
+ *
+ * NOTE: dictMode and searchMethod should be templated, so those switch
+ * statements should be optimized out. Only the mls & rowLog switches
+ * should be left.
+ *
+ * @param ms The match state.
+ * @param ip The position to search at.
+ * @param iend The end of the input data.
+ * @param[out] offsetPtr Stores the match offset into this pointer.
+ * @param mls The minimum search length, in the range [4, 6].
+ * @param rowLog The row log (if applicable), in the range [4, 6].
+ * @param searchMethod The search method to use (templated).
+ * @param dictMode The dictMode (templated).
+ *
+ * @returns The length of the longest match found, or < mls if no match is found.
+ * If a match is found its offset is stored in @p offsetPtr.
+ */
+FORCE_INLINE_TEMPLATE size_t ZSTD_searchMax(
+    ZSTD_matchState_t* ms,
+    const BYTE* ip,
+    const BYTE* iend,
+    size_t* offsetPtr,
+    U32 const mls,
+    U32 const rowLog,
+    searchMethod_e const searchMethod,
+    ZSTD_dictMode_e const dictMode)
+{
+    if (dictMode == ZSTD_noDict) {
+        ZSTD_SWITCH_SEARCH_METHOD(noDict)
+    } else if (dictMode == ZSTD_extDict) {
+        ZSTD_SWITCH_SEARCH_METHOD(extDict)
+    } else if (dictMode == ZSTD_dictMatchState) {
+        ZSTD_SWITCH_SEARCH_METHOD(dictMatchState)
+    } else if (dictMode == ZSTD_dedicatedDictSearch) {
+        ZSTD_SWITCH_SEARCH_METHOD(dedicatedDictSearch)
+    }
+    ZSTD_UNREACHABLE;
+    return 0;
+}
+
+/* *******************************
+*  Common parser - lazy strategy
+*********************************/
+
+FORCE_INLINE_TEMPLATE size_t
+ZSTD_compressBlock_lazy_generic(
+                        ZSTD_matchState_t* ms, seqStore_t* seqStore,
+                        U32 rep[ZSTD_REP_NUM],
+                        const void* src, size_t srcSize,
+                        const searchMethod_e searchMethod, const U32 depth,
+                        ZSTD_dictMode_e const dictMode)
+{
+    const BYTE* const istart = (const BYTE*)src;
+    const BYTE* ip = istart;
+    const BYTE* anchor = istart;
+    const BYTE* const iend = istart + srcSize;
+    const BYTE* const ilimit = (searchMethod == search_rowHash) ? iend - 8 - ZSTD_ROW_HASH_CACHE_SIZE : iend - 8;
+    const BYTE* const base = ms->window.base;
+    const U32 prefixLowestIndex = ms->window.dictLimit;
+    const BYTE* const prefixLowest = base + prefixLowestIndex;
+    const U32 mls = BOUNDED(4, ms->cParams.minMatch, 6);
+    const U32 rowLog = BOUNDED(4, ms->cParams.searchLog, 6);
+
+    U32 offset_1 = rep[0], offset_2 = rep[1];
+    U32 offsetSaved1 = 0, offsetSaved2 = 0;
+
+    const int isDMS = dictMode == ZSTD_dictMatchState;
+    const int isDDS = dictMode == ZSTD_dedicatedDictSearch;
+    const int isDxS = isDMS || isDDS;
+    const ZSTD_matchState_t* const dms = ms->dictMatchState;
+    const U32 dictLowestIndex      = isDxS ? dms->window.dictLimit : 0;
+    const BYTE* const dictBase     = isDxS ? dms->window.base : NULL;
+    const BYTE* const dictLowest   = isDxS ? dictBase + dictLowestIndex : NULL;
+    const BYTE* const dictEnd      = isDxS ? dms->window.nextSrc : NULL;
+    const U32 dictIndexDelta       = isDxS ?
+                                     prefixLowestIndex - (U32)(dictEnd - dictBase) :
+                                     0;
+    const U32 dictAndPrefixLength = (U32)((ip - prefixLowest) + (dictEnd - dictLowest));
+
+    DEBUGLOG(5, "ZSTD_compressBlock_lazy_generic (dictMode=%u) (searchFunc=%u)", (U32)dictMode, (U32)searchMethod);
+    ip += (dictAndPrefixLength == 0);
+    if (dictMode == ZSTD_noDict) {
+        U32 const curr = (U32)(ip - base);
+        U32 const windowLow = ZSTD_getLowestPrefixIndex(ms, curr, ms->cParams.windowLog);
+        U32 const maxRep = curr - windowLow;
+        if (offset_2 > maxRep) offsetSaved2 = offset_2, offset_2 = 0;
+        if (offset_1 > maxRep) offsetSaved1 = offset_1, offset_1 = 0;
+    }
+    if (isDxS) {
+        /* dictMatchState repCode checks don't currently handle repCode == 0
+         * disabling. */
+        assert(offset_1 <= dictAndPrefixLength);
+        assert(offset_2 <= dictAndPrefixLength);
+    }
+
+    /* Reset the lazy skipping state */
+    ms->lazySkipping = 0;
+
+    if (searchMethod == search_rowHash) {
+        ZSTD_row_fillHashCache(ms, base, rowLog, mls, ms->nextToUpdate, ilimit);
+    }
+
+    /* Match Loop */
+#if defined(__GNUC__) && defined(__x86_64__)
+    /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
+     * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
+     */
+    __asm__(".p2align 5");
+#endif
+    while (ip < ilimit) {
+        size_t matchLength=0;
+        size_t offBase = REPCODE1_TO_OFFBASE;
+        const BYTE* start=ip+1;
+        DEBUGLOG(7, "search baseline (depth 0)");
+
+        /* check repCode */
+        if (isDxS) {
+            const U32 repIndex = (U32)(ip - base) + 1 - offset_1;
+            const BYTE* repMatch = ((dictMode == ZSTD_dictMatchState || dictMode == ZSTD_dedicatedDictSearch)
+                                && repIndex < prefixLowestIndex) ?
+                                   dictBase + (repIndex - dictIndexDelta) :
+                                   base + repIndex;
+            if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
+                && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {
+                const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;
+                matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;
+                if (depth==0) goto _storeSequence;
+            }
+        }
+        if ( dictMode == ZSTD_noDict
+          && ((offset_1 > 0) & (MEM_read32(ip+1-offset_1) == MEM_read32(ip+1)))) {
+            matchLength = ZSTD_count(ip+1+4, ip+1+4-offset_1, iend) + 4;
+            if (depth==0) goto _storeSequence;
+        }
+
+        /* first search (depth 0) */
+        {   size_t offbaseFound = 999999999;
+            size_t const ml2 = ZSTD_searchMax(ms, ip, iend, &offbaseFound, mls, rowLog, searchMethod, dictMode);
+            if (ml2 > matchLength)
+                matchLength = ml2, start = ip, offBase = offbaseFound;
+        }
+
+        if (matchLength < 4) {
+            size_t const step = ((size_t)(ip-anchor) >> kSearchStrength) + 1;   /* jump faster over incompressible sections */;
+            ip += step;
+            /* Enter the lazy skipping mode once we are skipping more than 8 bytes at a time.
+             * In this mode we stop inserting every position into our tables, and only insert
+             * positions that we search, which is one in step positions.
+             * The exact cutoff is flexible, I've just chosen a number that is reasonably high,
+             * so we minimize the compression ratio loss in "normal" scenarios. This mode gets
+             * triggered once we've gone 2KB without finding any matches.
+             */
+            ms->lazySkipping = step > kLazySkippingStep;
+            continue;
+        }
+
+        /* let's try to find a better solution */
+        if (depth>=1)
+        while (ip<ilimit) {
+            DEBUGLOG(7, "search depth 1");
+            ip ++;
+            if ( (dictMode == ZSTD_noDict)
+              && (offBase) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {
+                size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;
+                int const gain2 = (int)(mlRep * 3);
+                int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offBase) + 1);
+                if ((mlRep >= 4) && (gain2 > gain1))
+                    matchLength = mlRep, offBase = REPCODE1_TO_OFFBASE, start = ip;
+            }
+            if (isDxS) {
+                const U32 repIndex = (U32)(ip - base) - offset_1;
+                const BYTE* repMatch = repIndex < prefixLowestIndex ?
+                               dictBase + (repIndex - dictIndexDelta) :
+                               base + repIndex;
+                if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
+                    && (MEM_read32(repMatch) == MEM_read32(ip)) ) {
+                    const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;
+                    size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;
+                    int const gain2 = (int)(mlRep * 3);
+                    int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offBase) + 1);
+                    if ((mlRep >= 4) && (gain2 > gain1))
+                        matchLength = mlRep, offBase = REPCODE1_TO_OFFBASE, start = ip;
+                }
+            }
+            {   size_t ofbCandidate=999999999;
+                size_t const ml2 = ZSTD_searchMax(ms, ip, iend, &ofbCandidate, mls, rowLog, searchMethod, dictMode);
+                int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)ofbCandidate));   /* raw approx */
+                int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offBase) + 4);
+                if ((ml2 >= 4) && (gain2 > gain1)) {
+                    matchLength = ml2, offBase = ofbCandidate, start = ip;
+                    continue;   /* search a better one */
+            }   }
+
+            /* let's find an even better one */
+            if ((depth==2) && (ip<ilimit)) {
+                DEBUGLOG(7, "search depth 2");
+                ip ++;
+                if ( (dictMode == ZSTD_noDict)
+                  && (offBase) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {
+                    size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;
+                    int const gain2 = (int)(mlRep * 4);
+                    int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offBase) + 1);
+                    if ((mlRep >= 4) && (gain2 > gain1))
+                        matchLength = mlRep, offBase = REPCODE1_TO_OFFBASE, start = ip;
+                }
+                if (isDxS) {
+                    const U32 repIndex = (U32)(ip - base) - offset_1;
+                    const BYTE* repMatch = repIndex < prefixLowestIndex ?
+                                   dictBase + (repIndex - dictIndexDelta) :
+                                   base + repIndex;
+                    if (((U32)((prefixLowestIndex-1) - repIndex) >= 3 /* intentional underflow */)
+                        && (MEM_read32(repMatch) == MEM_read32(ip)) ) {
+                        const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;
+                        size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;
+                        int const gain2 = (int)(mlRep * 4);
+                        int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offBase) + 1);
+                        if ((mlRep >= 4) && (gain2 > gain1))
+                            matchLength = mlRep, offBase = REPCODE1_TO_OFFBASE, start = ip;
+                    }
+                }
+                {   size_t ofbCandidate=999999999;
+                    size_t const ml2 = ZSTD_searchMax(ms, ip, iend, &ofbCandidate, mls, rowLog, searchMethod, dictMode);
+                    int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)ofbCandidate));   /* raw approx */
+                    int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offBase) + 7);
+                    if ((ml2 >= 4) && (gain2 > gain1)) {
+                        matchLength = ml2, offBase = ofbCandidate, start = ip;
+                        continue;
+            }   }   }
+            break;  /* nothing found : store previous solution */
+        }
+
+        /* NOTE:
+         * Pay attention that `start[-value]` can lead to strange undefined behavior
+         * notably if `value` is unsigned, resulting in a large positive `-value`.
+         */
+        /* catch up */
+        if (OFFBASE_IS_OFFSET(offBase)) {
+            if (dictMode == ZSTD_noDict) {
+                while ( ((start > anchor) & (start - OFFBASE_TO_OFFSET(offBase) > prefixLowest))
+                     && (start[-1] == (start-OFFBASE_TO_OFFSET(offBase))[-1]) )  /* only search for offset within prefix */
+                    { start--; matchLength++; }
+            }
+            if (isDxS) {
+                U32 const matchIndex = (U32)((size_t)(start-base) - OFFBASE_TO_OFFSET(offBase));
+                const BYTE* match = (matchIndex < prefixLowestIndex) ? dictBase + matchIndex - dictIndexDelta : base + matchIndex;
+                const BYTE* const mStart = (matchIndex < prefixLowestIndex) ? dictLowest : prefixLowest;
+                while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */
+            }
+            offset_2 = offset_1; offset_1 = (U32)OFFBASE_TO_OFFSET(offBase);
+        }
+        /* store sequence */
+_storeSequence:
+        {   size_t const litLength = (size_t)(start - anchor);
+            ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offBase, matchLength);
+            anchor = ip = start + matchLength;
+        }
+        if (ms->lazySkipping) {
+            /* We've found a match, disable lazy skipping mode, and refill the hash cache. */
+            if (searchMethod == search_rowHash) {
+                ZSTD_row_fillHashCache(ms, base, rowLog, mls, ms->nextToUpdate, ilimit);
+            }
+            ms->lazySkipping = 0;
+        }
+
+        /* check immediate repcode */
+        if (isDxS) {
+            while (ip <= ilimit) {
+                U32 const current2 = (U32)(ip-base);
+                U32 const repIndex = current2 - offset_2;
+                const BYTE* repMatch = repIndex < prefixLowestIndex ?
+                        dictBase - dictIndexDelta + repIndex :
+                        base + repIndex;
+                if ( ((U32)((prefixLowestIndex-1) - (U32)repIndex) >= 3 /* intentional overflow */)
+                   && (MEM_read32(repMatch) == MEM_read32(ip)) ) {
+                    const BYTE* const repEnd2 = repIndex < prefixLowestIndex ? dictEnd : iend;
+                    matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd2, prefixLowest) + 4;
+                    offBase = offset_2; offset_2 = offset_1; offset_1 = (U32)offBase;   /* swap offset_2 <=> offset_1 */
+                    ZSTD_storeSeq(seqStore, 0, anchor, iend, REPCODE1_TO_OFFBASE, matchLength);
+                    ip += matchLength;
+                    anchor = ip;
+                    continue;
+                }
+                break;
+            }
+        }
+
+        if (dictMode == ZSTD_noDict) {
+            while ( ((ip <= ilimit) & (offset_2>0))
+                 && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {
+                /* store sequence */
+                matchLength = ZSTD_count(ip+4, ip+4-offset_2, iend) + 4;
+                offBase = offset_2; offset_2 = offset_1; offset_1 = (U32)offBase; /* swap repcodes */
+                ZSTD_storeSeq(seqStore, 0, anchor, iend, REPCODE1_TO_OFFBASE, matchLength);
+                ip += matchLength;
+                anchor = ip;
+                continue;   /* faster when present ... (?) */
+    }   }   }
+
+    /* If offset_1 started invalid (offsetSaved1 != 0) and became valid (offset_1 != 0),
+     * rotate saved offsets. See comment in ZSTD_compressBlock_fast_noDict for more context. */
+    offsetSaved2 = ((offsetSaved1 != 0) && (offset_1 != 0)) ? offsetSaved1 : offsetSaved2;
+
+    /* save reps for next block */
+    rep[0] = offset_1 ? offset_1 : offsetSaved1;
+    rep[1] = offset_2 ? offset_2 : offsetSaved2;
+
+    /* Return the last literals size */
+    return (size_t)(iend - anchor);
+}
+
+
+size_t ZSTD_compressBlock_btlazy2(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_binaryTree, 2, ZSTD_noDict);
+}
+
+size_t ZSTD_compressBlock_lazy2(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 2, ZSTD_noDict);
+}
+
+size_t ZSTD_compressBlock_lazy(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 1, ZSTD_noDict);
+}
+
+size_t ZSTD_compressBlock_greedy(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 0, ZSTD_noDict);
+}
+
+size_t ZSTD_compressBlock_btlazy2_dictMatchState(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_binaryTree, 2, ZSTD_dictMatchState);
+}
+
+size_t ZSTD_compressBlock_lazy2_dictMatchState(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 2, ZSTD_dictMatchState);
+}
+
+size_t ZSTD_compressBlock_lazy_dictMatchState(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 1, ZSTD_dictMatchState);
+}
+
+size_t ZSTD_compressBlock_greedy_dictMatchState(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 0, ZSTD_dictMatchState);
+}
+
+
+size_t ZSTD_compressBlock_lazy2_dedicatedDictSearch(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 2, ZSTD_dedicatedDictSearch);
+}
+
+size_t ZSTD_compressBlock_lazy_dedicatedDictSearch(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 1, ZSTD_dedicatedDictSearch);
+}
+
+size_t ZSTD_compressBlock_greedy_dedicatedDictSearch(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 0, ZSTD_dedicatedDictSearch);
+}
+
+/* Row-based matchfinder */
+size_t ZSTD_compressBlock_lazy2_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 2, ZSTD_noDict);
+}
+
+size_t ZSTD_compressBlock_lazy_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 1, ZSTD_noDict);
+}
+
+size_t ZSTD_compressBlock_greedy_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 0, ZSTD_noDict);
+}
+
+size_t ZSTD_compressBlock_lazy2_dictMatchState_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 2, ZSTD_dictMatchState);
+}
+
+size_t ZSTD_compressBlock_lazy_dictMatchState_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 1, ZSTD_dictMatchState);
+}
+
+size_t ZSTD_compressBlock_greedy_dictMatchState_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 0, ZSTD_dictMatchState);
+}
+
+
+size_t ZSTD_compressBlock_lazy2_dedicatedDictSearch_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 2, ZSTD_dedicatedDictSearch);
+}
+
+size_t ZSTD_compressBlock_lazy_dedicatedDictSearch_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 1, ZSTD_dedicatedDictSearch);
+}
+
+size_t ZSTD_compressBlock_greedy_dedicatedDictSearch_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 0, ZSTD_dedicatedDictSearch);
+}
+
+FORCE_INLINE_TEMPLATE
+size_t ZSTD_compressBlock_lazy_extDict_generic(
+                        ZSTD_matchState_t* ms, seqStore_t* seqStore,
+                        U32 rep[ZSTD_REP_NUM],
+                        const void* src, size_t srcSize,
+                        const searchMethod_e searchMethod, const U32 depth)
+{
+    const BYTE* const istart = (const BYTE*)src;
+    const BYTE* ip = istart;
+    const BYTE* anchor = istart;
+    const BYTE* const iend = istart + srcSize;
+    const BYTE* const ilimit = searchMethod == search_rowHash ? iend - 8 - ZSTD_ROW_HASH_CACHE_SIZE : iend - 8;
+    const BYTE* const base = ms->window.base;
+    const U32 dictLimit = ms->window.dictLimit;
+    const BYTE* const prefixStart = base + dictLimit;
+    const BYTE* const dictBase = ms->window.dictBase;
+    const BYTE* const dictEnd  = dictBase + dictLimit;
+    const BYTE* const dictStart  = dictBase + ms->window.lowLimit;
+    const U32 windowLog = ms->cParams.windowLog;
+    const U32 mls = BOUNDED(4, ms->cParams.minMatch, 6);
+    const U32 rowLog = BOUNDED(4, ms->cParams.searchLog, 6);
+
+    U32 offset_1 = rep[0], offset_2 = rep[1];
+
+    DEBUGLOG(5, "ZSTD_compressBlock_lazy_extDict_generic (searchFunc=%u)", (U32)searchMethod);
+
+    /* Reset the lazy skipping state */
+    ms->lazySkipping = 0;
+
+    /* init */
+    ip += (ip == prefixStart);
+    if (searchMethod == search_rowHash) {
+        ZSTD_row_fillHashCache(ms, base, rowLog, mls, ms->nextToUpdate, ilimit);
+    }
+
+    /* Match Loop */
+#if defined(__GNUC__) && defined(__x86_64__)
+    /* I've measured random a 5% speed loss on levels 5 & 6 (greedy) when the
+     * code alignment is perturbed. To fix the instability align the loop on 32-bytes.
+     */
+    __asm__(".p2align 5");
+#endif
+    while (ip < ilimit) {
+        size_t matchLength=0;
+        size_t offBase = REPCODE1_TO_OFFBASE;
+        const BYTE* start=ip+1;
+        U32 curr = (U32)(ip-base);
+
+        /* check repCode */
+        {   const U32 windowLow = ZSTD_getLowestMatchIndex(ms, curr+1, windowLog);
+            const U32 repIndex = (U32)(curr+1 - offset_1);
+            const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;
+            const BYTE* const repMatch = repBase + repIndex;
+            if ( ((U32)((dictLimit-1) - repIndex) >= 3) /* intentional overflow */
+               & (offset_1 <= curr+1 - windowLow) ) /* note: we are searching at curr+1 */
+            if (MEM_read32(ip+1) == MEM_read32(repMatch)) {
+                /* repcode detected we should take it */
+                const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;
+                matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repEnd, prefixStart) + 4;
+                if (depth==0) goto _storeSequence;
+        }   }
+
+        /* first search (depth 0) */
+        {   size_t ofbCandidate = 999999999;
+            size_t const ml2 = ZSTD_searchMax(ms, ip, iend, &ofbCandidate, mls, rowLog, searchMethod, ZSTD_extDict);
+            if (ml2 > matchLength)
+                matchLength = ml2, start = ip, offBase = ofbCandidate;
+        }
+
+        if (matchLength < 4) {
+            size_t const step = ((size_t)(ip-anchor) >> kSearchStrength);
+            ip += step + 1;   /* jump faster over incompressible sections */
+            /* Enter the lazy skipping mode once we are skipping more than 8 bytes at a time.
+             * In this mode we stop inserting every position into our tables, and only insert
+             * positions that we search, which is one in step positions.
+             * The exact cutoff is flexible, I've just chosen a number that is reasonably high,
+             * so we minimize the compression ratio loss in "normal" scenarios. This mode gets
+             * triggered once we've gone 2KB without finding any matches.
+             */
+            ms->lazySkipping = step > kLazySkippingStep;
+            continue;
+        }
+
+        /* let's try to find a better solution */
+        if (depth>=1)
+        while (ip<ilimit) {
+            ip ++;
+            curr++;
+            /* check repCode */
+            if (offBase) {
+                const U32 windowLow = ZSTD_getLowestMatchIndex(ms, curr, windowLog);
+                const U32 repIndex = (U32)(curr - offset_1);
+                const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;
+                const BYTE* const repMatch = repBase + repIndex;
+                if ( ((U32)((dictLimit-1) - repIndex) >= 3) /* intentional overflow : do not test positions overlapping 2 memory segments  */
+                   & (offset_1 <= curr - windowLow) ) /* equivalent to `curr > repIndex >= windowLow` */
+                if (MEM_read32(ip) == MEM_read32(repMatch)) {
+                    /* repcode detected */
+                    const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;
+                    size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;
+                    int const gain2 = (int)(repLength * 3);
+                    int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offBase) + 1);
+                    if ((repLength >= 4) && (gain2 > gain1))
+                        matchLength = repLength, offBase = REPCODE1_TO_OFFBASE, start = ip;
+            }   }
+
+            /* search match, depth 1 */
+            {   size_t ofbCandidate = 999999999;
+                size_t const ml2 = ZSTD_searchMax(ms, ip, iend, &ofbCandidate, mls, rowLog, searchMethod, ZSTD_extDict);
+                int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)ofbCandidate));   /* raw approx */
+                int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offBase) + 4);
+                if ((ml2 >= 4) && (gain2 > gain1)) {
+                    matchLength = ml2, offBase = ofbCandidate, start = ip;
+                    continue;   /* search a better one */
+            }   }
+
+            /* let's find an even better one */
+            if ((depth==2) && (ip<ilimit)) {
+                ip ++;
+                curr++;
+                /* check repCode */
+                if (offBase) {
+                    const U32 windowLow = ZSTD_getLowestMatchIndex(ms, curr, windowLog);
+                    const U32 repIndex = (U32)(curr - offset_1);
+                    const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;
+                    const BYTE* const repMatch = repBase + repIndex;
+                    if ( ((U32)((dictLimit-1) - repIndex) >= 3) /* intentional overflow : do not test positions overlapping 2 memory segments  */
+                       & (offset_1 <= curr - windowLow) ) /* equivalent to `curr > repIndex >= windowLow` */
+                    if (MEM_read32(ip) == MEM_read32(repMatch)) {
+                        /* repcode detected */
+                        const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;
+                        size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;
+                        int const gain2 = (int)(repLength * 4);
+                        int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offBase) + 1);
+                        if ((repLength >= 4) && (gain2 > gain1))
+                            matchLength = repLength, offBase = REPCODE1_TO_OFFBASE, start = ip;
+                }   }
+
+                /* search match, depth 2 */
+                {   size_t ofbCandidate = 999999999;
+                    size_t const ml2 = ZSTD_searchMax(ms, ip, iend, &ofbCandidate, mls, rowLog, searchMethod, ZSTD_extDict);
+                    int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)ofbCandidate));   /* raw approx */
+                    int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offBase) + 7);
+                    if ((ml2 >= 4) && (gain2 > gain1)) {
+                        matchLength = ml2, offBase = ofbCandidate, start = ip;
+                        continue;
+            }   }   }
+            break;  /* nothing found : store previous solution */
+        }
+
+        /* catch up */
+        if (OFFBASE_IS_OFFSET(offBase)) {
+            U32 const matchIndex = (U32)((size_t)(start-base) - OFFBASE_TO_OFFSET(offBase));
+            const BYTE* match = (matchIndex < dictLimit) ? dictBase + matchIndex : base + matchIndex;
+            const BYTE* const mStart = (matchIndex < dictLimit) ? dictStart : prefixStart;
+            while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }  /* catch up */
+            offset_2 = offset_1; offset_1 = (U32)OFFBASE_TO_OFFSET(offBase);
+        }
+
+        /* store sequence */
+_storeSequence:
+        {   size_t const litLength = (size_t)(start - anchor);
+            ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offBase, matchLength);
+            anchor = ip = start + matchLength;
+        }
+        if (ms->lazySkipping) {
+            /* We've found a match, disable lazy skipping mode, and refill the hash cache. */
+            if (searchMethod == search_rowHash) {
+                ZSTD_row_fillHashCache(ms, base, rowLog, mls, ms->nextToUpdate, ilimit);
+            }
+            ms->lazySkipping = 0;
+        }
+
+        /* check immediate repcode */
+        while (ip <= ilimit) {
+            const U32 repCurrent = (U32)(ip-base);
+            const U32 windowLow = ZSTD_getLowestMatchIndex(ms, repCurrent, windowLog);
+            const U32 repIndex = repCurrent - offset_2;
+            const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;
+            const BYTE* const repMatch = repBase + repIndex;
+            if ( ((U32)((dictLimit-1) - repIndex) >= 3) /* intentional overflow : do not test positions overlapping 2 memory segments  */
+               & (offset_2 <= repCurrent - windowLow) ) /* equivalent to `curr > repIndex >= windowLow` */
+            if (MEM_read32(ip) == MEM_read32(repMatch)) {
+                /* repcode detected we should take it */
+                const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;
+                matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;
+                offBase = offset_2; offset_2 = offset_1; offset_1 = (U32)offBase;   /* swap offset history */
+                ZSTD_storeSeq(seqStore, 0, anchor, iend, REPCODE1_TO_OFFBASE, matchLength);
+                ip += matchLength;
+                anchor = ip;
+                continue;   /* faster when present ... (?) */
+            }
+            break;
+    }   }
+
+    /* Save reps for next block */
+    rep[0] = offset_1;
+    rep[1] = offset_2;
+
+    /* Return the last literals size */
+    return (size_t)(iend - anchor);
+}
+
+
+size_t ZSTD_compressBlock_greedy_extDict(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 0);
+}
+
+size_t ZSTD_compressBlock_lazy_extDict(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+
+{
+    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 1);
+}
+
+size_t ZSTD_compressBlock_lazy2_extDict(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+
+{
+    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 2);
+}
+
+size_t ZSTD_compressBlock_btlazy2_extDict(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+
+{
+    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_binaryTree, 2);
+}
+
+size_t ZSTD_compressBlock_greedy_extDict_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 0);
+}
+
+size_t ZSTD_compressBlock_lazy_extDict_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+
+{
+    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 1);
+}
+
+size_t ZSTD_compressBlock_lazy2_extDict_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 2);
+}
diff --git a/src/3rdparty/zstd/src/compress/zstd_lazy.h b/src/3rdparty/zstd/src/compress/zstd_lazy.h
new file mode 100644
index 0000000000..3bde67331e
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_lazy.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_LAZY_H
+#define ZSTD_LAZY_H
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#include "zstd_compress_internal.h"
+
+/**
+ * Dedicated Dictionary Search Structure bucket log. In the
+ * ZSTD_dedicatedDictSearch mode, the hashTable has
+ * 2 ** ZSTD_LAZY_DDSS_BUCKET_LOG entries in each bucket, rather than just
+ * one.
+ */
+#define ZSTD_LAZY_DDSS_BUCKET_LOG 2
+
+#define ZSTD_ROW_HASH_TAG_BITS 8        /* nb bits to use for the tag */
+
+U32 ZSTD_insertAndFindFirstIndex(ZSTD_matchState_t* ms, const BYTE* ip);
+void ZSTD_row_update(ZSTD_matchState_t* const ms, const BYTE* ip);
+
+void ZSTD_dedicatedDictSearch_lazy_loadDictionary(ZSTD_matchState_t* ms, const BYTE* const ip);
+
+void ZSTD_preserveUnsortedMark (U32* const table, U32 const size, U32 const reducerValue);  /*! used in ZSTD_reduceIndex(). preemptively increase value of ZSTD_DUBT_UNSORTED_MARK */
+
+size_t ZSTD_compressBlock_btlazy2(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_lazy2(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_lazy(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_greedy(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_lazy2_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_lazy_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_greedy_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+
+size_t ZSTD_compressBlock_btlazy2_dictMatchState(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_lazy2_dictMatchState(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_lazy_dictMatchState(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_greedy_dictMatchState(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_lazy2_dictMatchState_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_lazy_dictMatchState_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_greedy_dictMatchState_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+
+size_t ZSTD_compressBlock_lazy2_dedicatedDictSearch(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_lazy_dedicatedDictSearch(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_greedy_dedicatedDictSearch(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_lazy2_dedicatedDictSearch_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_lazy_dedicatedDictSearch_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_greedy_dedicatedDictSearch_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+
+size_t ZSTD_compressBlock_greedy_extDict(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_lazy_extDict(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_lazy2_extDict(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_greedy_extDict_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_lazy_extDict_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_lazy2_extDict_row(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_btlazy2_extDict(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+
+
+#if defined (__cplusplus)
+}
+#endif
+
+#endif /* ZSTD_LAZY_H */
diff --git a/src/3rdparty/zstd/src/compress/zstd_ldm.c b/src/3rdparty/zstd/src/compress/zstd_ldm.c
new file mode 100644
index 0000000000..3d74ff19e3
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_ldm.c
@@ -0,0 +1,724 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#include "zstd_ldm.h"
+
+#include "../common/debug.h"
+#include "../common/xxhash.h"
+#include "zstd_fast.h"          /* ZSTD_fillHashTable() */
+#include "zstd_double_fast.h"   /* ZSTD_fillDoubleHashTable() */
+#include "zstd_ldm_geartab.h"
+
+#define LDM_BUCKET_SIZE_LOG 3
+#define LDM_MIN_MATCH_LENGTH 64
+#define LDM_HASH_RLOG 7
+
+typedef struct {
+    U64 rolling;
+    U64 stopMask;
+} ldmRollingHashState_t;
+
+/** ZSTD_ldm_gear_init():
+ *
+ * Initializes the rolling hash state such that it will honor the
+ * settings in params. */
+static void ZSTD_ldm_gear_init(ldmRollingHashState_t* state, ldmParams_t const* params)
+{
+    unsigned maxBitsInMask = MIN(params->minMatchLength, 64);
+    unsigned hashRateLog = params->hashRateLog;
+
+    state->rolling = ~(U32)0;
+
+    /* The choice of the splitting criterion is subject to two conditions:
+     *   1. it has to trigger on average every 2^(hashRateLog) bytes;
+     *   2. ideally, it has to depend on a window of minMatchLength bytes.
+     *
+     * In the gear hash algorithm, bit n depends on the last n bytes;
+     * so in order to obtain a good quality splitting criterion it is
+     * preferable to use bits with high weight.
+     *
+     * To match condition 1 we use a mask with hashRateLog bits set
+     * and, because of the previous remark, we make sure these bits
+     * have the highest possible weight while still respecting
+     * condition 2.
+     */
+    if (hashRateLog > 0 && hashRateLog <= maxBitsInMask) {
+        state->stopMask = (((U64)1 << hashRateLog) - 1) << (maxBitsInMask - hashRateLog);
+    } else {
+        /* In this degenerate case we simply honor the hash rate. */
+        state->stopMask = ((U64)1 << hashRateLog) - 1;
+    }
+}
+
+/** ZSTD_ldm_gear_reset()
+ * Feeds [data, data + minMatchLength) into the hash without registering any
+ * splits. This effectively resets the hash state. This is used when skipping
+ * over data, either at the beginning of a block, or skipping sections.
+ */
+static void ZSTD_ldm_gear_reset(ldmRollingHashState_t* state,
+                                BYTE const* data, size_t minMatchLength)
+{
+    U64 hash = state->rolling;
+    size_t n = 0;
+
+#define GEAR_ITER_ONCE() do {                                  \
+        hash = (hash << 1) + ZSTD_ldm_gearTab[data[n] & 0xff]; \
+        n += 1;                                                \
+    } while (0)
+    while (n + 3 < minMatchLength) {
+        GEAR_ITER_ONCE();
+        GEAR_ITER_ONCE();
+        GEAR_ITER_ONCE();
+        GEAR_ITER_ONCE();
+    }
+    while (n < minMatchLength) {
+        GEAR_ITER_ONCE();
+    }
+#undef GEAR_ITER_ONCE
+}
+
+/** ZSTD_ldm_gear_feed():
+ *
+ * Registers in the splits array all the split points found in the first
+ * size bytes following the data pointer. This function terminates when
+ * either all the data has been processed or LDM_BATCH_SIZE splits are
+ * present in the splits array.
+ *
+ * Precondition: The splits array must not be full.
+ * Returns: The number of bytes processed. */
+static size_t ZSTD_ldm_gear_feed(ldmRollingHashState_t* state,
+                                 BYTE const* data, size_t size,
+                                 size_t* splits, unsigned* numSplits)
+{
+    size_t n;
+    U64 hash, mask;
+
+    hash = state->rolling;
+    mask = state->stopMask;
+    n = 0;
+
+#define GEAR_ITER_ONCE() do { \
+        hash = (hash << 1) + ZSTD_ldm_gearTab[data[n] & 0xff]; \
+        n += 1; \
+        if (UNLIKELY((hash & mask) == 0)) { \
+            splits[*numSplits] = n; \
+            *numSplits += 1; \
+            if (*numSplits == LDM_BATCH_SIZE) \
+                goto done; \
+        } \
+    } while (0)
+
+    while (n + 3 < size) {
+        GEAR_ITER_ONCE();
+        GEAR_ITER_ONCE();
+        GEAR_ITER_ONCE();
+        GEAR_ITER_ONCE();
+    }
+    while (n < size) {
+        GEAR_ITER_ONCE();
+    }
+
+#undef GEAR_ITER_ONCE
+
+done:
+    state->rolling = hash;
+    return n;
+}
+
+void ZSTD_ldm_adjustParameters(ldmParams_t* params,
+                               ZSTD_compressionParameters const* cParams)
+{
+    params->windowLog = cParams->windowLog;
+    ZSTD_STATIC_ASSERT(LDM_BUCKET_SIZE_LOG <= ZSTD_LDM_BUCKETSIZELOG_MAX);
+    DEBUGLOG(4, "ZSTD_ldm_adjustParameters");
+    if (!params->bucketSizeLog) params->bucketSizeLog = LDM_BUCKET_SIZE_LOG;
+    if (!params->minMatchLength) params->minMatchLength = LDM_MIN_MATCH_LENGTH;
+    if (params->hashLog == 0) {
+        params->hashLog = MAX(ZSTD_HASHLOG_MIN, params->windowLog - LDM_HASH_RLOG);
+        assert(params->hashLog <= ZSTD_HASHLOG_MAX);
+    }
+    if (params->hashRateLog == 0) {
+        params->hashRateLog = params->windowLog < params->hashLog
+                                   ? 0
+                                   : params->windowLog - params->hashLog;
+    }
+    params->bucketSizeLog = MIN(params->bucketSizeLog, params->hashLog);
+}
+
+size_t ZSTD_ldm_getTableSize(ldmParams_t params)
+{
+    size_t const ldmHSize = ((size_t)1) << params.hashLog;
+    size_t const ldmBucketSizeLog = MIN(params.bucketSizeLog, params.hashLog);
+    size_t const ldmBucketSize = ((size_t)1) << (params.hashLog - ldmBucketSizeLog);
+    size_t const totalSize = ZSTD_cwksp_alloc_size(ldmBucketSize)
+                           + ZSTD_cwksp_alloc_size(ldmHSize * sizeof(ldmEntry_t));
+    return params.enableLdm == ZSTD_ps_enable ? totalSize : 0;
+}
+
+size_t ZSTD_ldm_getMaxNbSeq(ldmParams_t params, size_t maxChunkSize)
+{
+    return params.enableLdm == ZSTD_ps_enable ? (maxChunkSize / params.minMatchLength) : 0;
+}
+
+/** ZSTD_ldm_getBucket() :
+ *  Returns a pointer to the start of the bucket associated with hash. */
+static ldmEntry_t* ZSTD_ldm_getBucket(
+        ldmState_t* ldmState, size_t hash, ldmParams_t const ldmParams)
+{
+    return ldmState->hashTable + (hash << ldmParams.bucketSizeLog);
+}
+
+/** ZSTD_ldm_insertEntry() :
+ *  Insert the entry with corresponding hash into the hash table */
+static void ZSTD_ldm_insertEntry(ldmState_t* ldmState,
+                                 size_t const hash, const ldmEntry_t entry,
+                                 ldmParams_t const ldmParams)
+{
+    BYTE* const pOffset = ldmState->bucketOffsets + hash;
+    unsigned const offset = *pOffset;
+
+    *(ZSTD_ldm_getBucket(ldmState, hash, ldmParams) + offset) = entry;
+    *pOffset = (BYTE)((offset + 1) & ((1u << ldmParams.bucketSizeLog) - 1));
+
+}
+
+/** ZSTD_ldm_countBackwardsMatch() :
+ *  Returns the number of bytes that match backwards before pIn and pMatch.
+ *
+ *  We count only bytes where pMatch >= pBase and pIn >= pAnchor. */
+static size_t ZSTD_ldm_countBackwardsMatch(
+            const BYTE* pIn, const BYTE* pAnchor,
+            const BYTE* pMatch, const BYTE* pMatchBase)
+{
+    size_t matchLength = 0;
+    while (pIn > pAnchor && pMatch > pMatchBase && pIn[-1] == pMatch[-1]) {
+        pIn--;
+        pMatch--;
+        matchLength++;
+    }
+    return matchLength;
+}
+
+/** ZSTD_ldm_countBackwardsMatch_2segments() :
+ *  Returns the number of bytes that match backwards from pMatch,
+ *  even with the backwards match spanning 2 different segments.
+ *
+ *  On reaching `pMatchBase`, start counting from mEnd */
+static size_t ZSTD_ldm_countBackwardsMatch_2segments(
+                    const BYTE* pIn, const BYTE* pAnchor,
+                    const BYTE* pMatch, const BYTE* pMatchBase,
+                    const BYTE* pExtDictStart, const BYTE* pExtDictEnd)
+{
+    size_t matchLength = ZSTD_ldm_countBackwardsMatch(pIn, pAnchor, pMatch, pMatchBase);
+    if (pMatch - matchLength != pMatchBase || pMatchBase == pExtDictStart) {
+        /* If backwards match is entirely in the extDict or prefix, immediately return */
+        return matchLength;
+    }
+    DEBUGLOG(7, "ZSTD_ldm_countBackwardsMatch_2segments: found 2-parts backwards match (length in prefix==%zu)", matchLength);
+    matchLength += ZSTD_ldm_countBackwardsMatch(pIn - matchLength, pAnchor, pExtDictEnd, pExtDictStart);
+    DEBUGLOG(7, "final backwards match length = %zu", matchLength);
+    return matchLength;
+}
+
+/** ZSTD_ldm_fillFastTables() :
+ *
+ *  Fills the relevant tables for the ZSTD_fast and ZSTD_dfast strategies.
+ *  This is similar to ZSTD_loadDictionaryContent.
+ *
+ *  The tables for the other strategies are filled within their
+ *  block compressors. */
+static size_t ZSTD_ldm_fillFastTables(ZSTD_matchState_t* ms,
+                                      void const* end)
+{
+    const BYTE* const iend = (const BYTE*)end;
+
+    switch(ms->cParams.strategy)
+    {
+    case ZSTD_fast:
+        ZSTD_fillHashTable(ms, iend, ZSTD_dtlm_fast, ZSTD_tfp_forCCtx);
+        break;
+
+    case ZSTD_dfast:
+        ZSTD_fillDoubleHashTable(ms, iend, ZSTD_dtlm_fast, ZSTD_tfp_forCCtx);
+        break;
+
+    case ZSTD_greedy:
+    case ZSTD_lazy:
+    case ZSTD_lazy2:
+    case ZSTD_btlazy2:
+    case ZSTD_btopt:
+    case ZSTD_btultra:
+    case ZSTD_btultra2:
+        break;
+    default:
+        assert(0);  /* not possible : not a valid strategy id */
+    }
+
+    return 0;
+}
+
+void ZSTD_ldm_fillHashTable(
+            ldmState_t* ldmState, const BYTE* ip,
+            const BYTE* iend, ldmParams_t const* params)
+{
+    U32 const minMatchLength = params->minMatchLength;
+    U32 const hBits = params->hashLog - params->bucketSizeLog;
+    BYTE const* const base = ldmState->window.base;
+    BYTE const* const istart = ip;
+    ldmRollingHashState_t hashState;
+    size_t* const splits = ldmState->splitIndices;
+    unsigned numSplits;
+
+    DEBUGLOG(5, "ZSTD_ldm_fillHashTable");
+
+    ZSTD_ldm_gear_init(&hashState, params);
+    while (ip < iend) {
+        size_t hashed;
+        unsigned n;
+
+        numSplits = 0;
+        hashed = ZSTD_ldm_gear_feed(&hashState, ip, iend - ip, splits, &numSplits);
+
+        for (n = 0; n < numSplits; n++) {
+            if (ip + splits[n] >= istart + minMatchLength) {
+                BYTE const* const split = ip + splits[n] - minMatchLength;
+                U64 const xxhash = XXH64(split, minMatchLength, 0);
+                U32 const hash = (U32)(xxhash & (((U32)1 << hBits) - 1));
+                ldmEntry_t entry;
+
+                entry.offset = (U32)(split - base);
+                entry.checksum = (U32)(xxhash >> 32);
+                ZSTD_ldm_insertEntry(ldmState, hash, entry, *params);
+            }
+        }
+
+        ip += hashed;
+    }
+}
+
+
+/** ZSTD_ldm_limitTableUpdate() :
+ *
+ *  Sets cctx->nextToUpdate to a position corresponding closer to anchor
+ *  if it is far way
+ *  (after a long match, only update tables a limited amount). */
+static void ZSTD_ldm_limitTableUpdate(ZSTD_matchState_t* ms, const BYTE* anchor)
+{
+    U32 const curr = (U32)(anchor - ms->window.base);
+    if (curr > ms->nextToUpdate + 1024) {
+        ms->nextToUpdate =
+            curr - MIN(512, curr - ms->nextToUpdate - 1024);
+    }
+}
+
+static size_t ZSTD_ldm_generateSequences_internal(
+        ldmState_t* ldmState, rawSeqStore_t* rawSeqStore,
+        ldmParams_t const* params, void const* src, size_t srcSize)
+{
+    /* LDM parameters */
+    int const extDict = ZSTD_window_hasExtDict(ldmState->window);
+    U32 const minMatchLength = params->minMatchLength;
+    U32 const entsPerBucket = 1U << params->bucketSizeLog;
+    U32 const hBits = params->hashLog - params->bucketSizeLog;
+    /* Prefix and extDict parameters */
+    U32 const dictLimit = ldmState->window.dictLimit;
+    U32 const lowestIndex = extDict ? ldmState->window.lowLimit : dictLimit;
+    BYTE const* const base = ldmState->window.base;
+    BYTE const* const dictBase = extDict ? ldmState->window.dictBase : NULL;
+    BYTE const* const dictStart = extDict ? dictBase + lowestIndex : NULL;
+    BYTE const* const dictEnd = extDict ? dictBase + dictLimit : NULL;
+    BYTE const* const lowPrefixPtr = base + dictLimit;
+    /* Input bounds */
+    BYTE const* const istart = (BYTE const*)src;
+    BYTE const* const iend = istart + srcSize;
+    BYTE const* const ilimit = iend - HASH_READ_SIZE;
+    /* Input positions */
+    BYTE const* anchor = istart;
+    BYTE const* ip = istart;
+    /* Rolling hash state */
+    ldmRollingHashState_t hashState;
+    /* Arrays for staged-processing */
+    size_t* const splits = ldmState->splitIndices;
+    ldmMatchCandidate_t* const candidates = ldmState->matchCandidates;
+    unsigned numSplits;
+
+    if (srcSize < minMatchLength)
+        return iend - anchor;
+
+    /* Initialize the rolling hash state with the first minMatchLength bytes */
+    ZSTD_ldm_gear_init(&hashState, params);
+    ZSTD_ldm_gear_reset(&hashState, ip, minMatchLength);
+    ip += minMatchLength;
+
+    while (ip < ilimit) {
+        size_t hashed;
+        unsigned n;
+
+        numSplits = 0;
+        hashed = ZSTD_ldm_gear_feed(&hashState, ip, ilimit - ip,
+                                    splits, &numSplits);
+
+        for (n = 0; n < numSplits; n++) {
+            BYTE const* const split = ip + splits[n] - minMatchLength;
+            U64 const xxhash = XXH64(split, minMatchLength, 0);
+            U32 const hash = (U32)(xxhash & (((U32)1 << hBits) - 1));
+
+            candidates[n].split = split;
+            candidates[n].hash = hash;
+            candidates[n].checksum = (U32)(xxhash >> 32);
+            candidates[n].bucket = ZSTD_ldm_getBucket(ldmState, hash, *params);
+            PREFETCH_L1(candidates[n].bucket);
+        }
+
+        for (n = 0; n < numSplits; n++) {
+            size_t forwardMatchLength = 0, backwardMatchLength = 0,
+                   bestMatchLength = 0, mLength;
+            U32 offset;
+            BYTE const* const split = candidates[n].split;
+            U32 const checksum = candidates[n].checksum;
+            U32 const hash = candidates[n].hash;
+            ldmEntry_t* const bucket = candidates[n].bucket;
+            ldmEntry_t const* cur;
+            ldmEntry_t const* bestEntry = NULL;
+            ldmEntry_t newEntry;
+
+            newEntry.offset = (U32)(split - base);
+            newEntry.checksum = checksum;
+
+            /* If a split point would generate a sequence overlapping with
+             * the previous one, we merely register it in the hash table and
+             * move on */
+            if (split < anchor) {
+                ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);
+                continue;
+            }
+
+            for (cur = bucket; cur < bucket + entsPerBucket; cur++) {
+                size_t curForwardMatchLength, curBackwardMatchLength,
+                       curTotalMatchLength;
+                if (cur->checksum != checksum || cur->offset <= lowestIndex) {
+                    continue;
+                }
+                if (extDict) {
+                    BYTE const* const curMatchBase =
+                        cur->offset < dictLimit ? dictBase : base;
+                    BYTE const* const pMatch = curMatchBase + cur->offset;
+                    BYTE const* const matchEnd =
+                        cur->offset < dictLimit ? dictEnd : iend;
+                    BYTE const* const lowMatchPtr =
+                        cur->offset < dictLimit ? dictStart : lowPrefixPtr;
+                    curForwardMatchLength =
+                        ZSTD_count_2segments(split, pMatch, iend, matchEnd, lowPrefixPtr);
+                    if (curForwardMatchLength < minMatchLength) {
+                        continue;
+                    }
+                    curBackwardMatchLength = ZSTD_ldm_countBackwardsMatch_2segments(
+                            split, anchor, pMatch, lowMatchPtr, dictStart, dictEnd);
+                } else { /* !extDict */
+                    BYTE const* const pMatch = base + cur->offset;
+                    curForwardMatchLength = ZSTD_count(split, pMatch, iend);
+                    if (curForwardMatchLength < minMatchLength) {
+                        continue;
+                    }
+                    curBackwardMatchLength =
+                        ZSTD_ldm_countBackwardsMatch(split, anchor, pMatch, lowPrefixPtr);
+                }
+                curTotalMatchLength = curForwardMatchLength + curBackwardMatchLength;
+
+                if (curTotalMatchLength > bestMatchLength) {
+                    bestMatchLength = curTotalMatchLength;
+                    forwardMatchLength = curForwardMatchLength;
+                    backwardMatchLength = curBackwardMatchLength;
+                    bestEntry = cur;
+                }
+            }
+
+            /* No match found -- insert an entry into the hash table
+             * and process the next candidate match */
+            if (bestEntry == NULL) {
+                ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);
+                continue;
+            }
+
+            /* Match found */
+            offset = (U32)(split - base) - bestEntry->offset;
+            mLength = forwardMatchLength + backwardMatchLength;
+            {
+                rawSeq* const seq = rawSeqStore->seq + rawSeqStore->size;
+
+                /* Out of sequence storage */
+                if (rawSeqStore->size == rawSeqStore->capacity)
+                    return ERROR(dstSize_tooSmall);
+                seq->litLength = (U32)(split - backwardMatchLength - anchor);
+                seq->matchLength = (U32)mLength;
+                seq->offset = offset;
+                rawSeqStore->size++;
+            }
+
+            /* Insert the current entry into the hash table --- it must be
+             * done after the previous block to avoid clobbering bestEntry */
+            ZSTD_ldm_insertEntry(ldmState, hash, newEntry, *params);
+
+            anchor = split + forwardMatchLength;
+
+            /* If we find a match that ends after the data that we've hashed
+             * then we have a repeating, overlapping, pattern. E.g. all zeros.
+             * If one repetition of the pattern matches our `stopMask` then all
+             * repetitions will. We don't need to insert them all into out table,
+             * only the first one. So skip over overlapping matches.
+             * This is a major speed boost (20x) for compressing a single byte
+             * repeated, when that byte ends up in the table.
+             */
+            if (anchor > ip + hashed) {
+                ZSTD_ldm_gear_reset(&hashState, anchor - minMatchLength, minMatchLength);
+                /* Continue the outer loop at anchor (ip + hashed == anchor). */
+                ip = anchor - hashed;
+                break;
+            }
+        }
+
+        ip += hashed;
+    }
+
+    return iend - anchor;
+}
+
+/*! ZSTD_ldm_reduceTable() :
+ *  reduce table indexes by `reducerValue` */
+static void ZSTD_ldm_reduceTable(ldmEntry_t* const table, U32 const size,
+                                 U32 const reducerValue)
+{
+    U32 u;
+    for (u = 0; u < size; u++) {
+        if (table[u].offset < reducerValue) table[u].offset = 0;
+        else table[u].offset -= reducerValue;
+    }
+}
+
+size_t ZSTD_ldm_generateSequences(
+        ldmState_t* ldmState, rawSeqStore_t* sequences,
+        ldmParams_t const* params, void const* src, size_t srcSize)
+{
+    U32 const maxDist = 1U << params->windowLog;
+    BYTE const* const istart = (BYTE const*)src;
+    BYTE const* const iend = istart + srcSize;
+    size_t const kMaxChunkSize = 1 << 20;
+    size_t const nbChunks = (srcSize / kMaxChunkSize) + ((srcSize % kMaxChunkSize) != 0);
+    size_t chunk;
+    size_t leftoverSize = 0;
+
+    assert(ZSTD_CHUNKSIZE_MAX >= kMaxChunkSize);
+    /* Check that ZSTD_window_update() has been called for this chunk prior
+     * to passing it to this function.
+     */
+    assert(ldmState->window.nextSrc >= (BYTE const*)src + srcSize);
+    /* The input could be very large (in zstdmt), so it must be broken up into
+     * chunks to enforce the maximum distance and handle overflow correction.
+     */
+    assert(sequences->pos <= sequences->size);
+    assert(sequences->size <= sequences->capacity);
+    for (chunk = 0; chunk < nbChunks && sequences->size < sequences->capacity; ++chunk) {
+        BYTE const* const chunkStart = istart + chunk * kMaxChunkSize;
+        size_t const remaining = (size_t)(iend - chunkStart);
+        BYTE const *const chunkEnd =
+            (remaining < kMaxChunkSize) ? iend : chunkStart + kMaxChunkSize;
+        size_t const chunkSize = chunkEnd - chunkStart;
+        size_t newLeftoverSize;
+        size_t const prevSize = sequences->size;
+
+        assert(chunkStart < iend);
+        /* 1. Perform overflow correction if necessary. */
+        if (ZSTD_window_needOverflowCorrection(ldmState->window, 0, maxDist, ldmState->loadedDictEnd, chunkStart, chunkEnd)) {
+            U32 const ldmHSize = 1U << params->hashLog;
+            U32 const correction = ZSTD_window_correctOverflow(
+                &ldmState->window, /* cycleLog */ 0, maxDist, chunkStart);
+            ZSTD_ldm_reduceTable(ldmState->hashTable, ldmHSize, correction);
+            /* invalidate dictionaries on overflow correction */
+            ldmState->loadedDictEnd = 0;
+        }
+        /* 2. We enforce the maximum offset allowed.
+         *
+         * kMaxChunkSize should be small enough that we don't lose too much of
+         * the window through early invalidation.
+         * TODO: * Test the chunk size.
+         *       * Try invalidation after the sequence generation and test the
+         *         offset against maxDist directly.
+         *
+         * NOTE: Because of dictionaries + sequence splitting we MUST make sure
+         * that any offset used is valid at the END of the sequence, since it may
+         * be split into two sequences. This condition holds when using
+         * ZSTD_window_enforceMaxDist(), but if we move to checking offsets
+         * against maxDist directly, we'll have to carefully handle that case.
+         */
+        ZSTD_window_enforceMaxDist(&ldmState->window, chunkEnd, maxDist, &ldmState->loadedDictEnd, NULL);
+        /* 3. Generate the sequences for the chunk, and get newLeftoverSize. */
+        newLeftoverSize = ZSTD_ldm_generateSequences_internal(
+            ldmState, sequences, params, chunkStart, chunkSize);
+        if (ZSTD_isError(newLeftoverSize))
+            return newLeftoverSize;
+        /* 4. We add the leftover literals from previous iterations to the first
+         *    newly generated sequence, or add the `newLeftoverSize` if none are
+         *    generated.
+         */
+        /* Prepend the leftover literals from the last call */
+        if (prevSize < sequences->size) {
+            sequences->seq[prevSize].litLength += (U32)leftoverSize;
+            leftoverSize = newLeftoverSize;
+        } else {
+            assert(newLeftoverSize == chunkSize);
+            leftoverSize += chunkSize;
+        }
+    }
+    return 0;
+}
+
+void
+ZSTD_ldm_skipSequences(rawSeqStore_t* rawSeqStore, size_t srcSize, U32 const minMatch)
+{
+    while (srcSize > 0 && rawSeqStore->pos < rawSeqStore->size) {
+        rawSeq* seq = rawSeqStore->seq + rawSeqStore->pos;
+        if (srcSize <= seq->litLength) {
+            /* Skip past srcSize literals */
+            seq->litLength -= (U32)srcSize;
+            return;
+        }
+        srcSize -= seq->litLength;
+        seq->litLength = 0;
+        if (srcSize < seq->matchLength) {
+            /* Skip past the first srcSize of the match */
+            seq->matchLength -= (U32)srcSize;
+            if (seq->matchLength < minMatch) {
+                /* The match is too short, omit it */
+                if (rawSeqStore->pos + 1 < rawSeqStore->size) {
+                    seq[1].litLength += seq[0].matchLength;
+                }
+                rawSeqStore->pos++;
+            }
+            return;
+        }
+        srcSize -= seq->matchLength;
+        seq->matchLength = 0;
+        rawSeqStore->pos++;
+    }
+}
+
+/**
+ * If the sequence length is longer than remaining then the sequence is split
+ * between this block and the next.
+ *
+ * Returns the current sequence to handle, or if the rest of the block should
+ * be literals, it returns a sequence with offset == 0.
+ */
+static rawSeq maybeSplitSequence(rawSeqStore_t* rawSeqStore,
+                                 U32 const remaining, U32 const minMatch)
+{
+    rawSeq sequence = rawSeqStore->seq[rawSeqStore->pos];
+    assert(sequence.offset > 0);
+    /* Likely: No partial sequence */
+    if (remaining >= sequence.litLength + sequence.matchLength) {
+        rawSeqStore->pos++;
+        return sequence;
+    }
+    /* Cut the sequence short (offset == 0 ==> rest is literals). */
+    if (remaining <= sequence.litLength) {
+        sequence.offset = 0;
+    } else if (remaining < sequence.litLength + sequence.matchLength) {
+        sequence.matchLength = remaining - sequence.litLength;
+        if (sequence.matchLength < minMatch) {
+            sequence.offset = 0;
+        }
+    }
+    /* Skip past `remaining` bytes for the future sequences. */
+    ZSTD_ldm_skipSequences(rawSeqStore, remaining, minMatch);
+    return sequence;
+}
+
+void ZSTD_ldm_skipRawSeqStoreBytes(rawSeqStore_t* rawSeqStore, size_t nbBytes) {
+    U32 currPos = (U32)(rawSeqStore->posInSequence + nbBytes);
+    while (currPos && rawSeqStore->pos < rawSeqStore->size) {
+        rawSeq currSeq = rawSeqStore->seq[rawSeqStore->pos];
+        if (currPos >= currSeq.litLength + currSeq.matchLength) {
+            currPos -= currSeq.litLength + currSeq.matchLength;
+            rawSeqStore->pos++;
+        } else {
+            rawSeqStore->posInSequence = currPos;
+            break;
+        }
+    }
+    if (currPos == 0 || rawSeqStore->pos == rawSeqStore->size) {
+        rawSeqStore->posInSequence = 0;
+    }
+}
+
+size_t ZSTD_ldm_blockCompress(rawSeqStore_t* rawSeqStore,
+    ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+    ZSTD_paramSwitch_e useRowMatchFinder,
+    void const* src, size_t srcSize)
+{
+    const ZSTD_compressionParameters* const cParams = &ms->cParams;
+    unsigned const minMatch = cParams->minMatch;
+    ZSTD_blockCompressor const blockCompressor =
+        ZSTD_selectBlockCompressor(cParams->strategy, useRowMatchFinder, ZSTD_matchState_dictMode(ms));
+    /* Input bounds */
+    BYTE const* const istart = (BYTE const*)src;
+    BYTE const* const iend = istart + srcSize;
+    /* Input positions */
+    BYTE const* ip = istart;
+
+    DEBUGLOG(5, "ZSTD_ldm_blockCompress: srcSize=%zu", srcSize);
+    /* If using opt parser, use LDMs only as candidates rather than always accepting them */
+    if (cParams->strategy >= ZSTD_btopt) {
+        size_t lastLLSize;
+        ms->ldmSeqStore = rawSeqStore;
+        lastLLSize = blockCompressor(ms, seqStore, rep, src, srcSize);
+        ZSTD_ldm_skipRawSeqStoreBytes(rawSeqStore, srcSize);
+        return lastLLSize;
+    }
+
+    assert(rawSeqStore->pos <= rawSeqStore->size);
+    assert(rawSeqStore->size <= rawSeqStore->capacity);
+    /* Loop through each sequence and apply the block compressor to the literals */
+    while (rawSeqStore->pos < rawSeqStore->size && ip < iend) {
+        /* maybeSplitSequence updates rawSeqStore->pos */
+        rawSeq const sequence = maybeSplitSequence(rawSeqStore,
+                                                   (U32)(iend - ip), minMatch);
+        int i;
+        /* End signal */
+        if (sequence.offset == 0)
+            break;
+
+        assert(ip + sequence.litLength + sequence.matchLength <= iend);
+
+        /* Fill tables for block compressor */
+        ZSTD_ldm_limitTableUpdate(ms, ip);
+        ZSTD_ldm_fillFastTables(ms, ip);
+        /* Run the block compressor */
+        DEBUGLOG(5, "pos %u : calling block compressor on segment of size %u", (unsigned)(ip-istart), sequence.litLength);
+        {
+            size_t const newLitLength =
+                blockCompressor(ms, seqStore, rep, ip, sequence.litLength);
+            ip += sequence.litLength;
+            /* Update the repcodes */
+            for (i = ZSTD_REP_NUM - 1; i > 0; i--)
+                rep[i] = rep[i-1];
+            rep[0] = sequence.offset;
+            /* Store the sequence */
+            ZSTD_storeSeq(seqStore, newLitLength, ip - newLitLength, iend,
+                          OFFSET_TO_OFFBASE(sequence.offset),
+                          sequence.matchLength);
+            ip += sequence.matchLength;
+        }
+    }
+    /* Fill the tables for the block compressor */
+    ZSTD_ldm_limitTableUpdate(ms, ip);
+    ZSTD_ldm_fillFastTables(ms, ip);
+    /* Compress the last literals */
+    return blockCompressor(ms, seqStore, rep, ip, iend - ip);
+}
diff --git a/src/3rdparty/zstd/src/compress/zstd_ldm.h b/src/3rdparty/zstd/src/compress/zstd_ldm.h
new file mode 100644
index 0000000000..f147021d29
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_ldm.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_LDM_H
+#define ZSTD_LDM_H
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#include "zstd_compress_internal.h"   /* ldmParams_t, U32 */
+#include "../zstd.h"   /* ZSTD_CCtx, size_t */
+
+/*-*************************************
+*  Long distance matching
+***************************************/
+
+#define ZSTD_LDM_DEFAULT_WINDOW_LOG ZSTD_WINDOWLOG_LIMIT_DEFAULT
+
+void ZSTD_ldm_fillHashTable(
+            ldmState_t* state, const BYTE* ip,
+            const BYTE* iend, ldmParams_t const* params);
+
+/**
+ * ZSTD_ldm_generateSequences():
+ *
+ * Generates the sequences using the long distance match finder.
+ * Generates long range matching sequences in `sequences`, which parse a prefix
+ * of the source. `sequences` must be large enough to store every sequence,
+ * which can be checked with `ZSTD_ldm_getMaxNbSeq()`.
+ * @returns 0 or an error code.
+ *
+ * NOTE: The user must have called ZSTD_window_update() for all of the input
+ * they have, even if they pass it to ZSTD_ldm_generateSequences() in chunks.
+ * NOTE: This function returns an error if it runs out of space to store
+ *       sequences.
+ */
+size_t ZSTD_ldm_generateSequences(
+            ldmState_t* ldms, rawSeqStore_t* sequences,
+            ldmParams_t const* params, void const* src, size_t srcSize);
+
+/**
+ * ZSTD_ldm_blockCompress():
+ *
+ * Compresses a block using the predefined sequences, along with a secondary
+ * block compressor. The literals section of every sequence is passed to the
+ * secondary block compressor, and those sequences are interspersed with the
+ * predefined sequences. Returns the length of the last literals.
+ * Updates `rawSeqStore.pos` to indicate how many sequences have been consumed.
+ * `rawSeqStore.seq` may also be updated to split the last sequence between two
+ * blocks.
+ * @return The length of the last literals.
+ *
+ * NOTE: The source must be at most the maximum block size, but the predefined
+ * sequences can be any size, and may be longer than the block. In the case that
+ * they are longer than the block, the last sequences may need to be split into
+ * two. We handle that case correctly, and update `rawSeqStore` appropriately.
+ * NOTE: This function does not return any errors.
+ */
+size_t ZSTD_ldm_blockCompress(rawSeqStore_t* rawSeqStore,
+            ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+            ZSTD_paramSwitch_e useRowMatchFinder,
+            void const* src, size_t srcSize);
+
+/**
+ * ZSTD_ldm_skipSequences():
+ *
+ * Skip past `srcSize` bytes worth of sequences in `rawSeqStore`.
+ * Avoids emitting matches less than `minMatch` bytes.
+ * Must be called for data that is not passed to ZSTD_ldm_blockCompress().
+ */
+void ZSTD_ldm_skipSequences(rawSeqStore_t* rawSeqStore, size_t srcSize,
+    U32 const minMatch);
+
+/* ZSTD_ldm_skipRawSeqStoreBytes():
+ * Moves forward in rawSeqStore by nbBytes, updating fields 'pos' and 'posInSequence'.
+ * Not to be used in conjunction with ZSTD_ldm_skipSequences().
+ * Must be called for data with is not passed to ZSTD_ldm_blockCompress().
+ */
+void ZSTD_ldm_skipRawSeqStoreBytes(rawSeqStore_t* rawSeqStore, size_t nbBytes);
+
+/** ZSTD_ldm_getTableSize() :
+ *  Estimate the space needed for long distance matching tables or 0 if LDM is
+ *  disabled.
+ */
+size_t ZSTD_ldm_getTableSize(ldmParams_t params);
+
+/** ZSTD_ldm_getSeqSpace() :
+ *  Return an upper bound on the number of sequences that can be produced by
+ *  the long distance matcher, or 0 if LDM is disabled.
+ */
+size_t ZSTD_ldm_getMaxNbSeq(ldmParams_t params, size_t maxChunkSize);
+
+/** ZSTD_ldm_adjustParameters() :
+ *  If the params->hashRateLog is not set, set it to its default value based on
+ *  windowLog and params->hashLog.
+ *
+ *  Ensures that params->bucketSizeLog is <= params->hashLog (setting it to
+ *  params->hashLog if it is not).
+ *
+ *  Ensures that the minMatchLength >= targetLength during optimal parsing.
+ */
+void ZSTD_ldm_adjustParameters(ldmParams_t* params,
+                               ZSTD_compressionParameters const* cParams);
+
+#if defined (__cplusplus)
+}
+#endif
+
+#endif /* ZSTD_FAST_H */
diff --git a/src/3rdparty/zstd/src/compress/zstd_ldm_geartab.h b/src/3rdparty/zstd/src/compress/zstd_ldm_geartab.h
new file mode 100644
index 0000000000..ef34bc5c92
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_ldm_geartab.h
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_LDM_GEARTAB_H
+#define ZSTD_LDM_GEARTAB_H
+
+#include "../common/compiler.h" /* UNUSED_ATTR */
+#include "../common/mem.h"      /* U64 */
+
+static UNUSED_ATTR const U64 ZSTD_ldm_gearTab[256] = {
+    0xf5b8f72c5f77775c, 0x84935f266b7ac412, 0xb647ada9ca730ccc,
+    0xb065bb4b114fb1de, 0x34584e7e8c3a9fd0, 0x4e97e17c6ae26b05,
+    0x3a03d743bc99a604, 0xcecd042422c4044f, 0x76de76c58524259e,
+    0x9c8528f65badeaca, 0x86563706e2097529, 0x2902475fa375d889,
+    0xafb32a9739a5ebe6, 0xce2714da3883e639, 0x21eaf821722e69e,
+    0x37b628620b628,    0x49a8d455d88caf5,  0x8556d711e6958140,
+    0x4f7ae74fc605c1f,  0x829f0c3468bd3a20, 0x4ffdc885c625179e,
+    0x8473de048a3daf1b, 0x51008822b05646b2, 0x69d75d12b2d1cc5f,
+    0x8c9d4a19159154bc, 0xc3cc10f4abbd4003, 0xd06ddc1cecb97391,
+    0xbe48e6e7ed80302e, 0x3481db31cee03547, 0xacc3f67cdaa1d210,
+    0x65cb771d8c7f96cc, 0x8eb27177055723dd, 0xc789950d44cd94be,
+    0x934feadc3700b12b, 0x5e485f11edbdf182, 0x1e2e2a46fd64767a,
+    0x2969ca71d82efa7c, 0x9d46e9935ebbba2e, 0xe056b67e05e6822b,
+    0x94d73f55739d03a0, 0xcd7010bdb69b5a03, 0x455ef9fcd79b82f4,
+    0x869cb54a8749c161, 0x38d1a4fa6185d225, 0xb475166f94bbe9bb,
+    0xa4143548720959f1, 0x7aed4780ba6b26ba, 0xd0ce264439e02312,
+    0x84366d746078d508, 0xa8ce973c72ed17be, 0x21c323a29a430b01,
+    0x9962d617e3af80ee, 0xab0ce91d9c8cf75b, 0x530e8ee6d19a4dbc,
+    0x2ef68c0cf53f5d72, 0xc03a681640a85506, 0x496e4e9f9c310967,
+    0x78580472b59b14a0, 0x273824c23b388577, 0x66bf923ad45cb553,
+    0x47ae1a5a2492ba86, 0x35e304569e229659, 0x4765182a46870b6f,
+    0x6cbab625e9099412, 0xddac9a2e598522c1, 0x7172086e666624f2,
+    0xdf5003ca503b7837, 0x88c0c1db78563d09, 0x58d51865acfc289d,
+    0x177671aec65224f1, 0xfb79d8a241e967d7, 0x2be1e101cad9a49a,
+    0x6625682f6e29186b, 0x399553457ac06e50, 0x35dffb4c23abb74,
+    0x429db2591f54aade, 0xc52802a8037d1009, 0x6acb27381f0b25f3,
+    0xf45e2551ee4f823b, 0x8b0ea2d99580c2f7, 0x3bed519cbcb4e1e1,
+    0xff452823dbb010a,  0x9d42ed614f3dd267, 0x5b9313c06257c57b,
+    0xa114b8008b5e1442, 0xc1fe311c11c13d4b, 0x66e8763ea34c5568,
+    0x8b982af1c262f05d, 0xee8876faaa75fbb7, 0x8a62a4d0d172bb2a,
+    0xc13d94a3b7449a97, 0x6dbbba9dc15d037c, 0xc786101f1d92e0f1,
+    0xd78681a907a0b79b, 0xf61aaf2962c9abb9, 0x2cfd16fcd3cb7ad9,
+    0x868c5b6744624d21, 0x25e650899c74ddd7, 0xba042af4a7c37463,
+    0x4eb1a539465a3eca, 0xbe09dbf03b05d5ca, 0x774e5a362b5472ba,
+    0x47a1221229d183cd, 0x504b0ca18ef5a2df, 0xdffbdfbde2456eb9,
+    0x46cd2b2fbee34634, 0xf2aef8fe819d98c3, 0x357f5276d4599d61,
+    0x24a5483879c453e3, 0x88026889192b4b9,  0x28da96671782dbec,
+    0x4ef37c40588e9aaa, 0x8837b90651bc9fb3, 0xc164f741d3f0e5d6,
+    0xbc135a0a704b70ba, 0x69cd868f7622ada,  0xbc37ba89e0b9c0ab,
+    0x47c14a01323552f6, 0x4f00794bacee98bb, 0x7107de7d637a69d5,
+    0x88af793bb6f2255e, 0xf3c6466b8799b598, 0xc288c616aa7f3b59,
+    0x81ca63cf42fca3fd, 0x88d85ace36a2674b, 0xd056bd3792389e7,
+    0xe55c396c4e9dd32d, 0xbefb504571e6c0a6, 0x96ab32115e91e8cc,
+    0xbf8acb18de8f38d1, 0x66dae58801672606, 0x833b6017872317fb,
+    0xb87c16f2d1c92864, 0xdb766a74e58b669c, 0x89659f85c61417be,
+    0xc8daad856011ea0c, 0x76a4b565b6fe7eae, 0xa469d085f6237312,
+    0xaaf0365683a3e96c, 0x4dbb746f8424f7b8, 0x638755af4e4acc1,
+    0x3d7807f5bde64486, 0x17be6d8f5bbb7639, 0x903f0cd44dc35dc,
+    0x67b672eafdf1196c, 0xa676ff93ed4c82f1, 0x521d1004c5053d9d,
+    0x37ba9ad09ccc9202, 0x84e54d297aacfb51, 0xa0b4b776a143445,
+    0x820d471e20b348e,  0x1874383cb83d46dc, 0x97edeec7a1efe11c,
+    0xb330e50b1bdc42aa, 0x1dd91955ce70e032, 0xa514cdb88f2939d5,
+    0x2791233fd90db9d3, 0x7b670a4cc50f7a9b, 0x77c07d2a05c6dfa5,
+    0xe3778b6646d0a6fa, 0xb39c8eda47b56749, 0x933ed448addbef28,
+    0xaf846af6ab7d0bf4, 0xe5af208eb666e49,  0x5e6622f73534cd6a,
+    0x297daeca42ef5b6e, 0x862daef3d35539a6, 0xe68722498f8e1ea9,
+    0x981c53093dc0d572, 0xfa09b0bfbf86fbf5, 0x30b1e96166219f15,
+    0x70e7d466bdc4fb83, 0x5a66736e35f2a8e9, 0xcddb59d2b7c1baef,
+    0xd6c7d247d26d8996, 0xea4e39eac8de1ba3, 0x539c8bb19fa3aff2,
+    0x9f90e4c5fd508d8,  0xa34e5956fbaf3385, 0x2e2f8e151d3ef375,
+    0x173691e9b83faec1, 0xb85a8d56bf016379, 0x8382381267408ae3,
+    0xb90f901bbdc0096d, 0x7c6ad32933bcec65, 0x76bb5e2f2c8ad595,
+    0x390f851a6cf46d28, 0xc3e6064da1c2da72, 0xc52a0c101cfa5389,
+    0xd78eaf84a3fbc530, 0x3781b9e2288b997e, 0x73c2f6dea83d05c4,
+    0x4228e364c5b5ed7,  0x9d7a3edf0da43911, 0x8edcfeda24686756,
+    0x5e7667a7b7a9b3a1, 0x4c4f389fa143791d, 0xb08bc1023da7cddc,
+    0x7ab4be3ae529b1cc, 0x754e6132dbe74ff9, 0x71635442a839df45,
+    0x2f6fb1643fbe52de, 0x961e0a42cf7a8177, 0xf3b45d83d89ef2ea,
+    0xee3de4cf4a6e3e9b, 0xcd6848542c3295e7, 0xe4cee1664c78662f,
+    0x9947548b474c68c4, 0x25d73777a5ed8b0b, 0xc915b1d636b7fc,
+    0x21c2ba75d9b0d2da, 0x5f6b5dcf608a64a1, 0xdcf333255ff9570c,
+    0x633b922418ced4ee, 0xc136dde0b004b34a, 0x58cc83b05d4b2f5a,
+    0x5eb424dda28e42d2, 0x62df47369739cd98, 0xb4e0b42485e4ce17,
+    0x16e1f0c1f9a8d1e7, 0x8ec3916707560ebf, 0x62ba6e2df2cc9db3,
+    0xcbf9f4ff77d83a16, 0x78d9d7d07d2bbcc4, 0xef554ce1e02c41f4,
+    0x8d7581127eccf94d, 0xa9b53336cb3c8a05, 0x38c42c0bf45c4f91,
+    0x640893cdf4488863, 0x80ec34bc575ea568, 0x39f324f5b48eaa40,
+    0xe9d9ed1f8eff527f, 0x9224fc058cc5a214, 0xbaba00b04cfe7741,
+    0x309a9f120fcf52af, 0xa558f3ec65626212, 0x424bec8b7adabe2f,
+    0x41622513a6aea433, 0xb88da2d5324ca798, 0xd287733b245528a4,
+    0x9a44697e6d68aec3, 0x7b1093be2f49bb28, 0x50bbec632e3d8aad,
+    0x6cd90723e1ea8283, 0x897b9e7431b02bf3, 0x219efdcb338a7047,
+    0x3b0311f0a27c0656, 0xdb17bf91c0db96e7, 0x8cd4fd6b4e85a5b2,
+    0xfab071054ba6409d, 0x40d6fe831fa9dfd9, 0xaf358debad7d791e,
+    0xeb8d0e25a65e3e58, 0xbbcbd3df14e08580, 0xcf751f27ecdab2b,
+    0x2b4da14f2613d8f4
+};
+
+#endif /* ZSTD_LDM_GEARTAB_H */
diff --git a/src/3rdparty/zstd/src/compress/zstd_opt.c b/src/3rdparty/zstd/src/compress/zstd_opt.c
new file mode 100644
index 0000000000..f02a760946
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_opt.c
@@ -0,0 +1,1472 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#include "zstd_compress_internal.h"
+#include "hist.h"
+#include "zstd_opt.h"
+
+
+#define ZSTD_LITFREQ_ADD    2   /* scaling factor for litFreq, so that frequencies adapt faster to new stats */
+#define ZSTD_MAX_PRICE     (1<<30)
+
+#define ZSTD_PREDEF_THRESHOLD 8   /* if srcSize < ZSTD_PREDEF_THRESHOLD, symbols' cost is assumed static, directly determined by pre-defined distributions */
+
+
+/*-*************************************
+*  Price functions for optimal parser
+***************************************/
+
+#if 0    /* approximation at bit level (for tests) */
+#  define BITCOST_ACCURACY 0
+#  define BITCOST_MULTIPLIER (1 << BITCOST_ACCURACY)
+#  define WEIGHT(stat, opt) ((void)(opt), ZSTD_bitWeight(stat))
+#elif 0  /* fractional bit accuracy (for tests) */
+#  define BITCOST_ACCURACY 8
+#  define BITCOST_MULTIPLIER (1 << BITCOST_ACCURACY)
+#  define WEIGHT(stat,opt) ((void)(opt), ZSTD_fracWeight(stat))
+#else    /* opt==approx, ultra==accurate */
+#  define BITCOST_ACCURACY 8
+#  define BITCOST_MULTIPLIER (1 << BITCOST_ACCURACY)
+#  define WEIGHT(stat,opt) ((opt) ? ZSTD_fracWeight(stat) : ZSTD_bitWeight(stat))
+#endif
+
+/* ZSTD_bitWeight() :
+ * provide estimated "cost" of a stat in full bits only */
+MEM_STATIC U32 ZSTD_bitWeight(U32 stat)
+{
+    return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);
+}
+
+/* ZSTD_fracWeight() :
+ * provide fractional-bit "cost" of a stat,
+ * using linear interpolation approximation */
+MEM_STATIC U32 ZSTD_fracWeight(U32 rawStat)
+{
+    U32 const stat = rawStat + 1;
+    U32 const hb = ZSTD_highbit32(stat);
+    U32 const BWeight = hb * BITCOST_MULTIPLIER;
+    /* Fweight was meant for "Fractional weight"
+     * but it's effectively a value between 1 and 2
+     * using fixed point arithmetic */
+    U32 const FWeight = (stat << BITCOST_ACCURACY) >> hb;
+    U32 const weight = BWeight + FWeight;
+    assert(hb + BITCOST_ACCURACY < 31);
+    return weight;
+}
+
+#if (DEBUGLEVEL>=2)
+/* debugging function,
+ * @return price in bytes as fractional value
+ * for debug messages only */
+MEM_STATIC double ZSTD_fCost(int price)
+{
+    return (double)price / (BITCOST_MULTIPLIER*8);
+}
+#endif
+
+static int ZSTD_compressedLiterals(optState_t const* const optPtr)
+{
+    return optPtr->literalCompressionMode != ZSTD_ps_disable;
+}
+
+static void ZSTD_setBasePrices(optState_t* optPtr, int optLevel)
+{
+    if (ZSTD_compressedLiterals(optPtr))
+        optPtr->litSumBasePrice = WEIGHT(optPtr->litSum, optLevel);
+    optPtr->litLengthSumBasePrice = WEIGHT(optPtr->litLengthSum, optLevel);
+    optPtr->matchLengthSumBasePrice = WEIGHT(optPtr->matchLengthSum, optLevel);
+    optPtr->offCodeSumBasePrice = WEIGHT(optPtr->offCodeSum, optLevel);
+}
+
+
+static U32 sum_u32(const unsigned table[], size_t nbElts)
+{
+    size_t n;
+    U32 total = 0;
+    for (n=0; n<nbElts; n++) {
+        total += table[n];
+    }
+    return total;
+}
+
+typedef enum { base_0possible=0, base_1guaranteed=1 } base_directive_e;
+
+static U32
+ZSTD_downscaleStats(unsigned* table, U32 lastEltIndex, U32 shift, base_directive_e base1)
+{
+    U32 s, sum=0;
+    DEBUGLOG(5, "ZSTD_downscaleStats (nbElts=%u, shift=%u)",
+            (unsigned)lastEltIndex+1, (unsigned)shift );
+    assert(shift < 30);
+    for (s=0; s<lastEltIndex+1; s++) {
+        unsigned const base = base1 ? 1 : (table[s]>0);
+        unsigned const newStat = base + (table[s] >> shift);
+        sum += newStat;
+        table[s] = newStat;
+    }
+    return sum;
+}
+
+/* ZSTD_scaleStats() :
+ * reduce all elt frequencies in table if sum too large
+ * return the resulting sum of elements */
+static U32 ZSTD_scaleStats(unsigned* table, U32 lastEltIndex, U32 logTarget)
+{
+    U32 const prevsum = sum_u32(table, lastEltIndex+1);
+    U32 const factor = prevsum >> logTarget;
+    DEBUGLOG(5, "ZSTD_scaleStats (nbElts=%u, target=%u)", (unsigned)lastEltIndex+1, (unsigned)logTarget);
+    assert(logTarget < 30);
+    if (factor <= 1) return prevsum;
+    return ZSTD_downscaleStats(table, lastEltIndex, ZSTD_highbit32(factor), base_1guaranteed);
+}
+
+/* ZSTD_rescaleFreqs() :
+ * if first block (detected by optPtr->litLengthSum == 0) : init statistics
+ *    take hints from dictionary if there is one
+ *    and init from zero if there is none,
+ *    using src for literals stats, and baseline stats for sequence symbols
+ * otherwise downscale existing stats, to be used as seed for next block.
+ */
+static void
+ZSTD_rescaleFreqs(optState_t* const optPtr,
+            const BYTE* const src, size_t const srcSize,
+                  int const optLevel)
+{
+    int const compressedLiterals = ZSTD_compressedLiterals(optPtr);
+    DEBUGLOG(5, "ZSTD_rescaleFreqs (srcSize=%u)", (unsigned)srcSize);
+    optPtr->priceType = zop_dynamic;
+
+    if (optPtr->litLengthSum == 0) {  /* no literals stats collected -> first block assumed -> init */
+
+        /* heuristic: use pre-defined stats for too small inputs */
+        if (srcSize <= ZSTD_PREDEF_THRESHOLD) {
+            DEBUGLOG(5, "srcSize <= %i : use predefined stats", ZSTD_PREDEF_THRESHOLD);
+            optPtr->priceType = zop_predef;
+        }
+
+        assert(optPtr->symbolCosts != NULL);
+        if (optPtr->symbolCosts->huf.repeatMode == HUF_repeat_valid) {
+
+            /* huffman stats covering the full value set : table presumed generated by dictionary */
+            optPtr->priceType = zop_dynamic;
+
+            if (compressedLiterals) {
+                /* generate literals statistics from huffman table */
+                unsigned lit;
+                assert(optPtr->litFreq != NULL);
+                optPtr->litSum = 0;
+                for (lit=0; lit<=MaxLit; lit++) {
+                    U32 const scaleLog = 11;   /* scale to 2K */
+                    U32 const bitCost = HUF_getNbBitsFromCTable(optPtr->symbolCosts->huf.CTable, lit);
+                    assert(bitCost <= scaleLog);
+                    optPtr->litFreq[lit] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;
+                    optPtr->litSum += optPtr->litFreq[lit];
+            }   }
+
+            {   unsigned ll;
+                FSE_CState_t llstate;
+                FSE_initCState(&llstate, optPtr->symbolCosts->fse.litlengthCTable);
+                optPtr->litLengthSum = 0;
+                for (ll=0; ll<=MaxLL; ll++) {
+                    U32 const scaleLog = 10;   /* scale to 1K */
+                    U32 const bitCost = FSE_getMaxNbBits(llstate.symbolTT, ll);
+                    assert(bitCost < scaleLog);
+                    optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;
+                    optPtr->litLengthSum += optPtr->litLengthFreq[ll];
+            }   }
+
+            {   unsigned ml;
+                FSE_CState_t mlstate;
+                FSE_initCState(&mlstate, optPtr->symbolCosts->fse.matchlengthCTable);
+                optPtr->matchLengthSum = 0;
+                for (ml=0; ml<=MaxML; ml++) {
+                    U32 const scaleLog = 10;
+                    U32 const bitCost = FSE_getMaxNbBits(mlstate.symbolTT, ml);
+                    assert(bitCost < scaleLog);
+                    optPtr->matchLengthFreq[ml] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;
+                    optPtr->matchLengthSum += optPtr->matchLengthFreq[ml];
+            }   }
+
+            {   unsigned of;
+                FSE_CState_t ofstate;
+                FSE_initCState(&ofstate, optPtr->symbolCosts->fse.offcodeCTable);
+                optPtr->offCodeSum = 0;
+                for (of=0; of<=MaxOff; of++) {
+                    U32 const scaleLog = 10;
+                    U32 const bitCost = FSE_getMaxNbBits(ofstate.symbolTT, of);
+                    assert(bitCost < scaleLog);
+                    optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1 /*minimum to calculate cost*/;
+                    optPtr->offCodeSum += optPtr->offCodeFreq[of];
+            }   }
+
+        } else {  /* first block, no dictionary */
+
+            assert(optPtr->litFreq != NULL);
+            if (compressedLiterals) {
+                /* base initial cost of literals on direct frequency within src */
+                unsigned lit = MaxLit;
+                HIST_count_simple(optPtr->litFreq, &lit, src, srcSize);   /* use raw first block to init statistics */
+                optPtr->litSum = ZSTD_downscaleStats(optPtr->litFreq, MaxLit, 8, base_0possible);
+            }
+
+            {   unsigned const baseLLfreqs[MaxLL+1] = {
+                    4, 2, 1, 1, 1, 1, 1, 1,
+                    1, 1, 1, 1, 1, 1, 1, 1,
+                    1, 1, 1, 1, 1, 1, 1, 1,
+                    1, 1, 1, 1, 1, 1, 1, 1,
+                    1, 1, 1, 1
+                };
+                ZSTD_memcpy(optPtr->litLengthFreq, baseLLfreqs, sizeof(baseLLfreqs));
+                optPtr->litLengthSum = sum_u32(baseLLfreqs, MaxLL+1);
+            }
+
+            {   unsigned ml;
+                for (ml=0; ml<=MaxML; ml++)
+                    optPtr->matchLengthFreq[ml] = 1;
+            }
+            optPtr->matchLengthSum = MaxML+1;
+
+            {   unsigned const baseOFCfreqs[MaxOff+1] = {
+                    6, 2, 1, 1, 2, 3, 4, 4,
+                    4, 3, 2, 1, 1, 1, 1, 1,
+                    1, 1, 1, 1, 1, 1, 1, 1,
+                    1, 1, 1, 1, 1, 1, 1, 1
+                };
+                ZSTD_memcpy(optPtr->offCodeFreq, baseOFCfreqs, sizeof(baseOFCfreqs));
+                optPtr->offCodeSum = sum_u32(baseOFCfreqs, MaxOff+1);
+            }
+
+        }
+
+    } else {   /* new block : scale down accumulated statistics */
+
+        if (compressedLiterals)
+            optPtr->litSum = ZSTD_scaleStats(optPtr->litFreq, MaxLit, 12);
+        optPtr->litLengthSum = ZSTD_scaleStats(optPtr->litLengthFreq, MaxLL, 11);
+        optPtr->matchLengthSum = ZSTD_scaleStats(optPtr->matchLengthFreq, MaxML, 11);
+        optPtr->offCodeSum = ZSTD_scaleStats(optPtr->offCodeFreq, MaxOff, 11);
+    }
+
+    ZSTD_setBasePrices(optPtr, optLevel);
+}
+
+/* ZSTD_rawLiteralsCost() :
+ * price of literals (only) in specified segment (which length can be 0).
+ * does not include price of literalLength symbol */
+static U32 ZSTD_rawLiteralsCost(const BYTE* const literals, U32 const litLength,
+                                const optState_t* const optPtr,
+                                int optLevel)
+{
+    if (litLength == 0) return 0;
+
+    if (!ZSTD_compressedLiterals(optPtr))
+        return (litLength << 3) * BITCOST_MULTIPLIER;  /* Uncompressed - 8 bytes per literal. */
+
+    if (optPtr->priceType == zop_predef)
+        return (litLength*6) * BITCOST_MULTIPLIER;  /* 6 bit per literal - no statistic used */
+
+    /* dynamic statistics */
+    {   U32 price = optPtr->litSumBasePrice * litLength;
+        U32 const litPriceMax = optPtr->litSumBasePrice - BITCOST_MULTIPLIER;
+        U32 u;
+        assert(optPtr->litSumBasePrice >= BITCOST_MULTIPLIER);
+        for (u=0; u < litLength; u++) {
+            U32 litPrice = WEIGHT(optPtr->litFreq[literals[u]], optLevel);
+            if (UNLIKELY(litPrice > litPriceMax)) litPrice = litPriceMax;
+            price -= litPrice;
+        }
+        return price;
+    }
+}
+
+/* ZSTD_litLengthPrice() :
+ * cost of literalLength symbol */
+static U32 ZSTD_litLengthPrice(U32 const litLength, const optState_t* const optPtr, int optLevel)
+{
+    assert(litLength <= ZSTD_BLOCKSIZE_MAX);
+    if (optPtr->priceType == zop_predef)
+        return WEIGHT(litLength, optLevel);
+
+    /* ZSTD_LLcode() can't compute litLength price for sizes >= ZSTD_BLOCKSIZE_MAX
+     * because it isn't representable in the zstd format.
+     * So instead just pretend it would cost 1 bit more than ZSTD_BLOCKSIZE_MAX - 1.
+     * In such a case, the block would be all literals.
+     */
+    if (litLength == ZSTD_BLOCKSIZE_MAX)
+        return BITCOST_MULTIPLIER + ZSTD_litLengthPrice(ZSTD_BLOCKSIZE_MAX - 1, optPtr, optLevel);
+
+    /* dynamic statistics */
+    {   U32 const llCode = ZSTD_LLcode(litLength);
+        return (LL_bits[llCode] * BITCOST_MULTIPLIER)
+             + optPtr->litLengthSumBasePrice
+             - WEIGHT(optPtr->litLengthFreq[llCode], optLevel);
+    }
+}
+
+/* ZSTD_getMatchPrice() :
+ * Provides the cost of the match part (offset + matchLength) of a sequence.
+ * Must be combined with ZSTD_fullLiteralsCost() to get the full cost of a sequence.
+ * @offBase : sumtype, representing an offset or a repcode, and using numeric representation of ZSTD_storeSeq()
+ * @optLevel: when <2, favors small offset for decompression speed (improved cache efficiency)
+ */
+FORCE_INLINE_TEMPLATE U32
+ZSTD_getMatchPrice(U32 const offBase,
+                   U32 const matchLength,
+             const optState_t* const optPtr,
+                   int const optLevel)
+{
+    U32 price;
+    U32 const offCode = ZSTD_highbit32(offBase);
+    U32 const mlBase = matchLength - MINMATCH;
+    assert(matchLength >= MINMATCH);
+
+    if (optPtr->priceType == zop_predef)  /* fixed scheme, does not use statistics */
+        return WEIGHT(mlBase, optLevel)
+             + ((16 + offCode) * BITCOST_MULTIPLIER); /* emulated offset cost */
+
+    /* dynamic statistics */
+    price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));
+    if ((optLevel<2) /*static*/ && offCode >= 20)
+        price += (offCode-19)*2 * BITCOST_MULTIPLIER; /* handicap for long distance offsets, favor decompression speed */
+
+    /* match Length */
+    {   U32 const mlCode = ZSTD_MLcode(mlBase);
+        price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));
+    }
+
+    price += BITCOST_MULTIPLIER / 5;   /* heuristic : make matches a bit more costly to favor less sequences -> faster decompression speed */
+
+    DEBUGLOG(8, "ZSTD_getMatchPrice(ml:%u) = %u", matchLength, price);
+    return price;
+}
+
+/* ZSTD_updateStats() :
+ * assumption : literals + litLength <= iend */
+static void ZSTD_updateStats(optState_t* const optPtr,
+                             U32 litLength, const BYTE* literals,
+                             U32 offBase, U32 matchLength)
+{
+    /* literals */
+    if (ZSTD_compressedLiterals(optPtr)) {
+        U32 u;
+        for (u=0; u < litLength; u++)
+            optPtr->litFreq[literals[u]] += ZSTD_LITFREQ_ADD;
+        optPtr->litSum += litLength*ZSTD_LITFREQ_ADD;
+    }
+
+    /* literal Length */
+    {   U32 const llCode = ZSTD_LLcode(litLength);
+        optPtr->litLengthFreq[llCode]++;
+        optPtr->litLengthSum++;
+    }
+
+    /* offset code : follows storeSeq() numeric representation */
+    {   U32 const offCode = ZSTD_highbit32(offBase);
+        assert(offCode <= MaxOff);
+        optPtr->offCodeFreq[offCode]++;
+        optPtr->offCodeSum++;
+    }
+
+    /* match Length */
+    {   U32 const mlBase = matchLength - MINMATCH;
+        U32 const mlCode = ZSTD_MLcode(mlBase);
+        optPtr->matchLengthFreq[mlCode]++;
+        optPtr->matchLengthSum++;
+    }
+}
+
+
+/* ZSTD_readMINMATCH() :
+ * function safe only for comparisons
+ * assumption : memPtr must be at least 4 bytes before end of buffer */
+MEM_STATIC U32 ZSTD_readMINMATCH(const void* memPtr, U32 length)
+{
+    switch (length)
+    {
+    default :
+    case 4 : return MEM_read32(memPtr);
+    case 3 : if (MEM_isLittleEndian())
+                return MEM_read32(memPtr)<<8;
+             else
+                return MEM_read32(memPtr)>>8;
+    }
+}
+
+
+/* Update hashTable3 up to ip (excluded)
+   Assumption : always within prefix (i.e. not within extDict) */
+static U32 ZSTD_insertAndFindFirstIndexHash3 (const ZSTD_matchState_t* ms,
+                                              U32* nextToUpdate3,
+                                              const BYTE* const ip)
+{
+    U32* const hashTable3 = ms->hashTable3;
+    U32 const hashLog3 = ms->hashLog3;
+    const BYTE* const base = ms->window.base;
+    U32 idx = *nextToUpdate3;
+    U32 const target = (U32)(ip - base);
+    size_t const hash3 = ZSTD_hash3Ptr(ip, hashLog3);
+    assert(hashLog3 > 0);
+
+    while(idx < target) {
+        hashTable3[ZSTD_hash3Ptr(base+idx, hashLog3)] = idx;
+        idx++;
+    }
+
+    *nextToUpdate3 = target;
+    return hashTable3[hash3];
+}
+
+
+/*-*************************************
+*  Binary Tree search
+***************************************/
+/** ZSTD_insertBt1() : add one or multiple positions to tree.
+ * @param ip assumed <= iend-8 .
+ * @param target The target of ZSTD_updateTree_internal() - we are filling to this position
+ * @return : nb of positions added */
+static U32 ZSTD_insertBt1(
+                const ZSTD_matchState_t* ms,
+                const BYTE* const ip, const BYTE* const iend,
+                U32 const target,
+                U32 const mls, const int extDict)
+{
+    const ZSTD_compressionParameters* const cParams = &ms->cParams;
+    U32*   const hashTable = ms->hashTable;
+    U32    const hashLog = cParams->hashLog;
+    size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);
+    U32*   const bt = ms->chainTable;
+    U32    const btLog  = cParams->chainLog - 1;
+    U32    const btMask = (1 << btLog) - 1;
+    U32 matchIndex = hashTable[h];
+    size_t commonLengthSmaller=0, commonLengthLarger=0;
+    const BYTE* const base = ms->window.base;
+    const BYTE* const dictBase = ms->window.dictBase;
+    const U32 dictLimit = ms->window.dictLimit;
+    const BYTE* const dictEnd = dictBase + dictLimit;
+    const BYTE* const prefixStart = base + dictLimit;
+    const BYTE* match;
+    const U32 curr = (U32)(ip-base);
+    const U32 btLow = btMask >= curr ? 0 : curr - btMask;
+    U32* smallerPtr = bt + 2*(curr&btMask);
+    U32* largerPtr  = smallerPtr + 1;
+    U32 dummy32;   /* to be nullified at the end */
+    /* windowLow is based on target because
+     * we only need positions that will be in the window at the end of the tree update.
+     */
+    U32 const windowLow = ZSTD_getLowestMatchIndex(ms, target, cParams->windowLog);
+    U32 matchEndIdx = curr+8+1;
+    size_t bestLength = 8;
+    U32 nbCompares = 1U << cParams->searchLog;
+#ifdef ZSTD_C_PREDICT
+    U32 predictedSmall = *(bt + 2*((curr-1)&btMask) + 0);
+    U32 predictedLarge = *(bt + 2*((curr-1)&btMask) + 1);
+    predictedSmall += (predictedSmall>0);
+    predictedLarge += (predictedLarge>0);
+#endif /* ZSTD_C_PREDICT */
+
+    DEBUGLOG(8, "ZSTD_insertBt1 (%u)", curr);
+
+    assert(curr <= target);
+    assert(ip <= iend-8);   /* required for h calculation */
+    hashTable[h] = curr;   /* Update Hash Table */
+
+    assert(windowLow > 0);
+    for (; nbCompares && (matchIndex >= windowLow); --nbCompares) {
+        U32* const nextPtr = bt + 2*(matchIndex & btMask);
+        size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
+        assert(matchIndex < curr);
+
+#ifdef ZSTD_C_PREDICT   /* note : can create issues when hlog small <= 11 */
+        const U32* predictPtr = bt + 2*((matchIndex-1) & btMask);   /* written this way, as bt is a roll buffer */
+        if (matchIndex == predictedSmall) {
+            /* no need to check length, result known */
+            *smallerPtr = matchIndex;
+            if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */
+            smallerPtr = nextPtr+1;               /* new "smaller" => larger of match */
+            matchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
+            predictedSmall = predictPtr[1] + (predictPtr[1]>0);
+            continue;
+        }
+        if (matchIndex == predictedLarge) {
+            *largerPtr = matchIndex;
+            if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */
+            largerPtr = nextPtr;
+            matchIndex = nextPtr[0];
+            predictedLarge = predictPtr[0] + (predictPtr[0]>0);
+            continue;
+        }
+#endif
+
+        if (!extDict || (matchIndex+matchLength >= dictLimit)) {
+            assert(matchIndex+matchLength >= dictLimit);   /* might be wrong if actually extDict */
+            match = base + matchIndex;
+            matchLength += ZSTD_count(ip+matchLength, match+matchLength, iend);
+        } else {
+            match = dictBase + matchIndex;
+            matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);
+            if (matchIndex+matchLength >= dictLimit)
+                match = base + matchIndex;   /* to prepare for next usage of match[matchLength] */
+        }
+
+        if (matchLength > bestLength) {
+            bestLength = matchLength;
+            if (matchLength > matchEndIdx - matchIndex)
+                matchEndIdx = matchIndex + (U32)matchLength;
+        }
+
+        if (ip+matchLength == iend) {   /* equal : no way to know if inf or sup */
+            break;   /* drop , to guarantee consistency ; miss a bit of compression, but other solutions can corrupt tree */
+        }
+
+        if (match[matchLength] < ip[matchLength]) {  /* necessarily within buffer */
+            /* match is smaller than current */
+            *smallerPtr = matchIndex;             /* update smaller idx */
+            commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
+            if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop searching */
+            smallerPtr = nextPtr+1;               /* new "candidate" => larger than match, which was smaller than target */
+            matchIndex = nextPtr[1];              /* new matchIndex, larger than previous and closer to current */
+        } else {
+            /* match is larger than current */
+            *largerPtr = matchIndex;
+            commonLengthLarger = matchLength;
+            if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop searching */
+            largerPtr = nextPtr;
+            matchIndex = nextPtr[0];
+    }   }
+
+    *smallerPtr = *largerPtr = 0;
+    {   U32 positions = 0;
+        if (bestLength > 384) positions = MIN(192, (U32)(bestLength - 384));   /* speed optimization */
+        assert(matchEndIdx > curr + 8);
+        return MAX(positions, matchEndIdx - (curr + 8));
+    }
+}
+
+FORCE_INLINE_TEMPLATE
+void ZSTD_updateTree_internal(
+                ZSTD_matchState_t* ms,
+                const BYTE* const ip, const BYTE* const iend,
+                const U32 mls, const ZSTD_dictMode_e dictMode)
+{
+    const BYTE* const base = ms->window.base;
+    U32 const target = (U32)(ip - base);
+    U32 idx = ms->nextToUpdate;
+    DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
+                idx, target, dictMode);
+
+    while(idx < target) {
+        U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, target, mls, dictMode == ZSTD_extDict);
+        assert(idx < (U32)(idx + forward));
+        idx += forward;
+    }
+    assert((size_t)(ip - base) <= (size_t)(U32)(-1));
+    assert((size_t)(iend - base) <= (size_t)(U32)(-1));
+    ms->nextToUpdate = target;
+}
+
+void ZSTD_updateTree(ZSTD_matchState_t* ms, const BYTE* ip, const BYTE* iend) {
+    ZSTD_updateTree_internal(ms, ip, iend, ms->cParams.minMatch, ZSTD_noDict);
+}
+
+FORCE_INLINE_TEMPLATE U32
+ZSTD_insertBtAndGetAllMatches (
+                ZSTD_match_t* matches,  /* store result (found matches) in this table (presumed large enough) */
+                ZSTD_matchState_t* ms,
+                U32* nextToUpdate3,
+                const BYTE* const ip, const BYTE* const iLimit,
+                const ZSTD_dictMode_e dictMode,
+                const U32 rep[ZSTD_REP_NUM],
+                const U32 ll0,  /* tells if associated literal length is 0 or not. This value must be 0 or 1 */
+                const U32 lengthToBeat,
+                const U32 mls /* template */)
+{
+    const ZSTD_compressionParameters* const cParams = &ms->cParams;
+    U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);
+    const BYTE* const base = ms->window.base;
+    U32 const curr = (U32)(ip-base);
+    U32 const hashLog = cParams->hashLog;
+    U32 const minMatch = (mls==3) ? 3 : 4;
+    U32* const hashTable = ms->hashTable;
+    size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);
+    U32 matchIndex  = hashTable[h];
+    U32* const bt   = ms->chainTable;
+    U32 const btLog = cParams->chainLog - 1;
+    U32 const btMask= (1U << btLog) - 1;
+    size_t commonLengthSmaller=0, commonLengthLarger=0;
+    const BYTE* const dictBase = ms->window.dictBase;
+    U32 const dictLimit = ms->window.dictLimit;
+    const BYTE* const dictEnd = dictBase + dictLimit;
+    const BYTE* const prefixStart = base + dictLimit;
+    U32 const btLow = (btMask >= curr) ? 0 : curr - btMask;
+    U32 const windowLow = ZSTD_getLowestMatchIndex(ms, curr, cParams->windowLog);
+    U32 const matchLow = windowLow ? windowLow : 1;
+    U32* smallerPtr = bt + 2*(curr&btMask);
+    U32* largerPtr  = bt + 2*(curr&btMask) + 1;
+    U32 matchEndIdx = curr+8+1;   /* farthest referenced position of any match => detects repetitive patterns */
+    U32 dummy32;   /* to be nullified at the end */
+    U32 mnum = 0;
+    U32 nbCompares = 1U << cParams->searchLog;
+
+    const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;
+    const ZSTD_compressionParameters* const dmsCParams =
+                                      dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;
+    const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;
+    const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;
+    U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;
+    U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;
+    U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;
+    U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;
+    U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;
+    U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;
+    U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;
+
+    size_t bestLength = lengthToBeat-1;
+    DEBUGLOG(8, "ZSTD_insertBtAndGetAllMatches: current=%u", curr);
+
+    /* check repCode */
+    assert(ll0 <= 1);   /* necessarily 1 or 0 */
+    {   U32 const lastR = ZSTD_REP_NUM + ll0;
+        U32 repCode;
+        for (repCode = ll0; repCode < lastR; repCode++) {
+            U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];
+            U32 const repIndex = curr - repOffset;
+            U32 repLen = 0;
+            assert(curr >= dictLimit);
+            if (repOffset-1 /* intentional overflow, discards 0 and -1 */ < curr-dictLimit) {  /* equivalent to `curr > repIndex >= dictLimit` */
+                /* We must validate the repcode offset because when we're using a dictionary the
+                 * valid offset range shrinks when the dictionary goes out of bounds.
+                 */
+                if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {
+                    repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;
+                }
+            } else {  /* repIndex < dictLimit || repIndex >= curr */
+                const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?
+                                             dmsBase + repIndex - dmsIndexDelta :
+                                             dictBase + repIndex;
+                assert(curr >= windowLow);
+                if ( dictMode == ZSTD_extDict
+                  && ( ((repOffset-1) /*intentional overflow*/ < curr - windowLow)  /* equivalent to `curr > repIndex >= windowLow` */
+                     & (((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */)
+                  && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
+                    repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;
+                }
+                if (dictMode == ZSTD_dictMatchState
+                  && ( ((repOffset-1) /*intentional overflow*/ < curr - (dmsLowLimit + dmsIndexDelta))  /* equivalent to `curr > repIndex >= dmsLowLimit` */
+                     & ((U32)((dictLimit-1) - repIndex) >= 3) ) /* intentional overflow : do not test positions overlapping 2 memory segments */
+                  && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {
+                    repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;
+            }   }
+            /* save longer solution */
+            if (repLen > bestLength) {
+                DEBUGLOG(8, "found repCode %u (ll0:%u, offset:%u) of length %u",
+                            repCode, ll0, repOffset, repLen);
+                bestLength = repLen;
+                matches[mnum].off = REPCODE_TO_OFFBASE(repCode - ll0 + 1);  /* expect value between 1 and 3 */
+                matches[mnum].len = (U32)repLen;
+                mnum++;
+                if ( (repLen > sufficient_len)
+                   | (ip+repLen == iLimit) ) {  /* best possible */
+                    return mnum;
+    }   }   }   }
+
+    /* HC3 match finder */
+    if ((mls == 3) /*static*/ && (bestLength < mls)) {
+        U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);
+        if ((matchIndex3 >= matchLow)
+          & (curr - matchIndex3 < (1<<18)) /*heuristic : longer distance likely too expensive*/ ) {
+            size_t mlen;
+            if ((dictMode == ZSTD_noDict) /*static*/ || (dictMode == ZSTD_dictMatchState) /*static*/ || (matchIndex3 >= dictLimit)) {
+                const BYTE* const match = base + matchIndex3;
+                mlen = ZSTD_count(ip, match, iLimit);
+            } else {
+                const BYTE* const match = dictBase + matchIndex3;
+                mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);
+            }
+
+            /* save best solution */
+            if (mlen >= mls /* == 3 > bestLength */) {
+                DEBUGLOG(8, "found small match with hlog3, of length %u",
+                            (U32)mlen);
+                bestLength = mlen;
+                assert(curr > matchIndex3);
+                assert(mnum==0);  /* no prior solution */
+                matches[0].off = OFFSET_TO_OFFBASE(curr - matchIndex3);
+                matches[0].len = (U32)mlen;
+                mnum = 1;
+                if ( (mlen > sufficient_len) |
+                     (ip+mlen == iLimit) ) {  /* best possible length */
+                    ms->nextToUpdate = curr+1;  /* skip insertion */
+                    return 1;
+        }   }   }
+        /* no dictMatchState lookup: dicts don't have a populated HC3 table */
+    }  /* if (mls == 3) */
+
+    hashTable[h] = curr;   /* Update Hash Table */
+
+    for (; nbCompares && (matchIndex >= matchLow); --nbCompares) {
+        U32* const nextPtr = bt + 2*(matchIndex & btMask);
+        const BYTE* match;
+        size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
+        assert(curr > matchIndex);
+
+        if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {
+            assert(matchIndex+matchLength >= dictLimit);  /* ensure the condition is correct when !extDict */
+            match = base + matchIndex;
+            if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
+            matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);
+        } else {
+            match = dictBase + matchIndex;
+            assert(memcmp(match, ip, matchLength) == 0);  /* ensure early section of match is equal as expected */
+            matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);
+            if (matchIndex+matchLength >= dictLimit)
+                match = base + matchIndex;   /* prepare for match[matchLength] read */
+        }
+
+        if (matchLength > bestLength) {
+            DEBUGLOG(8, "found match of length %u at distance %u (offBase=%u)",
+                    (U32)matchLength, curr - matchIndex, OFFSET_TO_OFFBASE(curr - matchIndex));
+            assert(matchEndIdx > matchIndex);
+            if (matchLength > matchEndIdx - matchIndex)
+                matchEndIdx = matchIndex + (U32)matchLength;
+            bestLength = matchLength;
+            matches[mnum].off = OFFSET_TO_OFFBASE(curr - matchIndex);
+            matches[mnum].len = (U32)matchLength;
+            mnum++;
+            if ( (matchLength > ZSTD_OPT_NUM)
+               | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
+                if (dictMode == ZSTD_dictMatchState) nbCompares = 0; /* break should also skip searching dms */
+                break; /* drop, to preserve bt consistency (miss a little bit of compression) */
+        }   }
+
+        if (match[matchLength] < ip[matchLength]) {
+            /* match smaller than current */
+            *smallerPtr = matchIndex;             /* update smaller idx */
+            commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
+            if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }   /* beyond tree size, stop the search */
+            smallerPtr = nextPtr+1;               /* new candidate => larger than match, which was smaller than current */
+            matchIndex = nextPtr[1];              /* new matchIndex, larger than previous, closer to current */
+        } else {
+            *largerPtr = matchIndex;
+            commonLengthLarger = matchLength;
+            if (matchIndex <= btLow) { largerPtr=&dummy32; break; }   /* beyond tree size, stop the search */
+            largerPtr = nextPtr;
+            matchIndex = nextPtr[0];
+    }   }
+
+    *smallerPtr = *largerPtr = 0;
+
+    assert(nbCompares <= (1U << ZSTD_SEARCHLOG_MAX)); /* Check we haven't underflowed. */
+    if (dictMode == ZSTD_dictMatchState && nbCompares) {
+        size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);
+        U32 dictMatchIndex = dms->hashTable[dmsH];
+        const U32* const dmsBt = dms->chainTable;
+        commonLengthSmaller = commonLengthLarger = 0;
+        for (; nbCompares && (dictMatchIndex > dmsLowLimit); --nbCompares) {
+            const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);
+            size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);   /* guaranteed minimum nb of common bytes */
+            const BYTE* match = dmsBase + dictMatchIndex;
+            matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);
+            if (dictMatchIndex+matchLength >= dmsHighLimit)
+                match = base + dictMatchIndex + dmsIndexDelta;   /* to prepare for next usage of match[matchLength] */
+
+            if (matchLength > bestLength) {
+                matchIndex = dictMatchIndex + dmsIndexDelta;
+                DEBUGLOG(8, "found dms match of length %u at distance %u (offBase=%u)",
+                        (U32)matchLength, curr - matchIndex, OFFSET_TO_OFFBASE(curr - matchIndex));
+                if (matchLength > matchEndIdx - matchIndex)
+                    matchEndIdx = matchIndex + (U32)matchLength;
+                bestLength = matchLength;
+                matches[mnum].off = OFFSET_TO_OFFBASE(curr - matchIndex);
+                matches[mnum].len = (U32)matchLength;
+                mnum++;
+                if ( (matchLength > ZSTD_OPT_NUM)
+                   | (ip+matchLength == iLimit) /* equal : no way to know if inf or sup */) {
+                    break;   /* drop, to guarantee consistency (miss a little bit of compression) */
+            }   }
+
+            if (dictMatchIndex <= dmsBtLow) { break; }   /* beyond tree size, stop the search */
+            if (match[matchLength] < ip[matchLength]) {
+                commonLengthSmaller = matchLength;    /* all smaller will now have at least this guaranteed common length */
+                dictMatchIndex = nextPtr[1];              /* new matchIndex larger than previous (closer to current) */
+            } else {
+                /* match is larger than current */
+                commonLengthLarger = matchLength;
+                dictMatchIndex = nextPtr[0];
+    }   }   }  /* if (dictMode == ZSTD_dictMatchState) */
+
+    assert(matchEndIdx > curr+8);
+    ms->nextToUpdate = matchEndIdx - 8;  /* skip repetitive patterns */
+    return mnum;
+}
+
+typedef U32 (*ZSTD_getAllMatchesFn)(
+    ZSTD_match_t*,
+    ZSTD_matchState_t*,
+    U32*,
+    const BYTE*,
+    const BYTE*,
+    const U32 rep[ZSTD_REP_NUM],
+    U32 const ll0,
+    U32 const lengthToBeat);
+
+FORCE_INLINE_TEMPLATE U32 ZSTD_btGetAllMatches_internal(
+        ZSTD_match_t* matches,
+        ZSTD_matchState_t* ms,
+        U32* nextToUpdate3,
+        const BYTE* ip,
+        const BYTE* const iHighLimit,
+        const U32 rep[ZSTD_REP_NUM],
+        U32 const ll0,
+        U32 const lengthToBeat,
+        const ZSTD_dictMode_e dictMode,
+        const U32 mls)
+{
+    assert(BOUNDED(3, ms->cParams.minMatch, 6) == mls);
+    DEBUGLOG(8, "ZSTD_BtGetAllMatches(dictMode=%d, mls=%u)", (int)dictMode, mls);
+    if (ip < ms->window.base + ms->nextToUpdate)
+        return 0;   /* skipped area */
+    ZSTD_updateTree_internal(ms, ip, iHighLimit, mls, dictMode);
+    return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, mls);
+}
+
+#define ZSTD_BT_GET_ALL_MATCHES_FN(dictMode, mls) ZSTD_btGetAllMatches_##dictMode##_##mls
+
+#define GEN_ZSTD_BT_GET_ALL_MATCHES_(dictMode, mls)            \
+    static U32 ZSTD_BT_GET_ALL_MATCHES_FN(dictMode, mls)(      \
+            ZSTD_match_t* matches,                             \
+            ZSTD_matchState_t* ms,                             \
+            U32* nextToUpdate3,                                \
+            const BYTE* ip,                                    \
+            const BYTE* const iHighLimit,                      \
+            const U32 rep[ZSTD_REP_NUM],                       \
+            U32 const ll0,                                     \
+            U32 const lengthToBeat)                            \
+    {                                                          \
+        return ZSTD_btGetAllMatches_internal(                  \
+                matches, ms, nextToUpdate3, ip, iHighLimit,    \
+                rep, ll0, lengthToBeat, ZSTD_##dictMode, mls); \
+    }
+
+#define GEN_ZSTD_BT_GET_ALL_MATCHES(dictMode)  \
+    GEN_ZSTD_BT_GET_ALL_MATCHES_(dictMode, 3)  \
+    GEN_ZSTD_BT_GET_ALL_MATCHES_(dictMode, 4)  \
+    GEN_ZSTD_BT_GET_ALL_MATCHES_(dictMode, 5)  \
+    GEN_ZSTD_BT_GET_ALL_MATCHES_(dictMode, 6)
+
+GEN_ZSTD_BT_GET_ALL_MATCHES(noDict)
+GEN_ZSTD_BT_GET_ALL_MATCHES(extDict)
+GEN_ZSTD_BT_GET_ALL_MATCHES(dictMatchState)
+
+#define ZSTD_BT_GET_ALL_MATCHES_ARRAY(dictMode)  \
+    {                                            \
+        ZSTD_BT_GET_ALL_MATCHES_FN(dictMode, 3), \
+        ZSTD_BT_GET_ALL_MATCHES_FN(dictMode, 4), \
+        ZSTD_BT_GET_ALL_MATCHES_FN(dictMode, 5), \
+        ZSTD_BT_GET_ALL_MATCHES_FN(dictMode, 6)  \
+    }
+
+static ZSTD_getAllMatchesFn
+ZSTD_selectBtGetAllMatches(ZSTD_matchState_t const* ms, ZSTD_dictMode_e const dictMode)
+{
+    ZSTD_getAllMatchesFn const getAllMatchesFns[3][4] = {
+        ZSTD_BT_GET_ALL_MATCHES_ARRAY(noDict),
+        ZSTD_BT_GET_ALL_MATCHES_ARRAY(extDict),
+        ZSTD_BT_GET_ALL_MATCHES_ARRAY(dictMatchState)
+    };
+    U32 const mls = BOUNDED(3, ms->cParams.minMatch, 6);
+    assert((U32)dictMode < 3);
+    assert(mls - 3 < 4);
+    return getAllMatchesFns[(int)dictMode][mls - 3];
+}
+
+/*************************
+*  LDM helper functions  *
+*************************/
+
+/* Struct containing info needed to make decision about ldm inclusion */
+typedef struct {
+    rawSeqStore_t seqStore;   /* External match candidates store for this block */
+    U32 startPosInBlock;      /* Start position of the current match candidate */
+    U32 endPosInBlock;        /* End position of the current match candidate */
+    U32 offset;               /* Offset of the match candidate */
+} ZSTD_optLdm_t;
+
+/* ZSTD_optLdm_skipRawSeqStoreBytes():
+ * Moves forward in @rawSeqStore by @nbBytes,
+ * which will update the fields 'pos' and 'posInSequence'.
+ */
+static void ZSTD_optLdm_skipRawSeqStoreBytes(rawSeqStore_t* rawSeqStore, size_t nbBytes)
+{
+    U32 currPos = (U32)(rawSeqStore->posInSequence + nbBytes);
+    while (currPos && rawSeqStore->pos < rawSeqStore->size) {
+        rawSeq currSeq = rawSeqStore->seq[rawSeqStore->pos];
+        if (currPos >= currSeq.litLength + currSeq.matchLength) {
+            currPos -= currSeq.litLength + currSeq.matchLength;
+            rawSeqStore->pos++;
+        } else {
+            rawSeqStore->posInSequence = currPos;
+            break;
+        }
+    }
+    if (currPos == 0 || rawSeqStore->pos == rawSeqStore->size) {
+        rawSeqStore->posInSequence = 0;
+    }
+}
+
+/* ZSTD_opt_getNextMatchAndUpdateSeqStore():
+ * Calculates the beginning and end of the next match in the current block.
+ * Updates 'pos' and 'posInSequence' of the ldmSeqStore.
+ */
+static void
+ZSTD_opt_getNextMatchAndUpdateSeqStore(ZSTD_optLdm_t* optLdm, U32 currPosInBlock,
+                                       U32 blockBytesRemaining)
+{
+    rawSeq currSeq;
+    U32 currBlockEndPos;
+    U32 literalsBytesRemaining;
+    U32 matchBytesRemaining;
+
+    /* Setting match end position to MAX to ensure we never use an LDM during this block */
+    if (optLdm->seqStore.size == 0 || optLdm->seqStore.pos >= optLdm->seqStore.size) {
+        optLdm->startPosInBlock = UINT_MAX;
+        optLdm->endPosInBlock = UINT_MAX;
+        return;
+    }
+    /* Calculate appropriate bytes left in matchLength and litLength
+     * after adjusting based on ldmSeqStore->posInSequence */
+    currSeq = optLdm->seqStore.seq[optLdm->seqStore.pos];
+    assert(optLdm->seqStore.posInSequence <= currSeq.litLength + currSeq.matchLength);
+    currBlockEndPos = currPosInBlock + blockBytesRemaining;
+    literalsBytesRemaining = (optLdm->seqStore.posInSequence < currSeq.litLength) ?
+            currSeq.litLength - (U32)optLdm->seqStore.posInSequence :
+            0;
+    matchBytesRemaining = (literalsBytesRemaining == 0) ?
+            currSeq.matchLength - ((U32)optLdm->seqStore.posInSequence - currSeq.litLength) :
+            currSeq.matchLength;
+
+    /* If there are more literal bytes than bytes remaining in block, no ldm is possible */
+    if (literalsBytesRemaining >= blockBytesRemaining) {
+        optLdm->startPosInBlock = UINT_MAX;
+        optLdm->endPosInBlock = UINT_MAX;
+        ZSTD_optLdm_skipRawSeqStoreBytes(&optLdm->seqStore, blockBytesRemaining);
+        return;
+    }
+
+    /* Matches may be < MINMATCH by this process. In that case, we will reject them
+       when we are deciding whether or not to add the ldm */
+    optLdm->startPosInBlock = currPosInBlock + literalsBytesRemaining;
+    optLdm->endPosInBlock = optLdm->startPosInBlock + matchBytesRemaining;
+    optLdm->offset = currSeq.offset;
+
+    if (optLdm->endPosInBlock > currBlockEndPos) {
+        /* Match ends after the block ends, we can't use the whole match */
+        optLdm->endPosInBlock = currBlockEndPos;
+        ZSTD_optLdm_skipRawSeqStoreBytes(&optLdm->seqStore, currBlockEndPos - currPosInBlock);
+    } else {
+        /* Consume nb of bytes equal to size of sequence left */
+        ZSTD_optLdm_skipRawSeqStoreBytes(&optLdm->seqStore, literalsBytesRemaining + matchBytesRemaining);
+    }
+}
+
+/* ZSTD_optLdm_maybeAddMatch():
+ * Adds a match if it's long enough,
+ * based on it's 'matchStartPosInBlock' and 'matchEndPosInBlock',
+ * into 'matches'. Maintains the correct ordering of 'matches'.
+ */
+static void ZSTD_optLdm_maybeAddMatch(ZSTD_match_t* matches, U32* nbMatches,
+                                      const ZSTD_optLdm_t* optLdm, U32 currPosInBlock)
+{
+    U32 const posDiff = currPosInBlock - optLdm->startPosInBlock;
+    /* Note: ZSTD_match_t actually contains offBase and matchLength (before subtracting MINMATCH) */
+    U32 const candidateMatchLength = optLdm->endPosInBlock - optLdm->startPosInBlock - posDiff;
+
+    /* Ensure that current block position is not outside of the match */
+    if (currPosInBlock < optLdm->startPosInBlock
+      || currPosInBlock >= optLdm->endPosInBlock
+      || candidateMatchLength < MINMATCH) {
+        return;
+    }
+
+    if (*nbMatches == 0 || ((candidateMatchLength > matches[*nbMatches-1].len) && *nbMatches < ZSTD_OPT_NUM)) {
+        U32 const candidateOffBase = OFFSET_TO_OFFBASE(optLdm->offset);
+        DEBUGLOG(6, "ZSTD_optLdm_maybeAddMatch(): Adding ldm candidate match (offBase: %u matchLength %u) at block position=%u",
+                 candidateOffBase, candidateMatchLength, currPosInBlock);
+        matches[*nbMatches].len = candidateMatchLength;
+        matches[*nbMatches].off = candidateOffBase;
+        (*nbMatches)++;
+    }
+}
+
+/* ZSTD_optLdm_processMatchCandidate():
+ * Wrapper function to update ldm seq store and call ldm functions as necessary.
+ */
+static void
+ZSTD_optLdm_processMatchCandidate(ZSTD_optLdm_t* optLdm,
+                                  ZSTD_match_t* matches, U32* nbMatches,
+                                  U32 currPosInBlock, U32 remainingBytes)
+{
+    if (optLdm->seqStore.size == 0 || optLdm->seqStore.pos >= optLdm->seqStore.size) {
+        return;
+    }
+
+    if (currPosInBlock >= optLdm->endPosInBlock) {
+        if (currPosInBlock > optLdm->endPosInBlock) {
+            /* The position at which ZSTD_optLdm_processMatchCandidate() is called is not necessarily
+             * at the end of a match from the ldm seq store, and will often be some bytes
+             * over beyond matchEndPosInBlock. As such, we need to correct for these "overshoots"
+             */
+            U32 const posOvershoot = currPosInBlock - optLdm->endPosInBlock;
+            ZSTD_optLdm_skipRawSeqStoreBytes(&optLdm->seqStore, posOvershoot);
+        }
+        ZSTD_opt_getNextMatchAndUpdateSeqStore(optLdm, currPosInBlock, remainingBytes);
+    }
+    ZSTD_optLdm_maybeAddMatch(matches, nbMatches, optLdm, currPosInBlock);
+}
+
+
+/*-*******************************
+*  Optimal parser
+*********************************/
+
+static U32 ZSTD_totalLen(ZSTD_optimal_t sol)
+{
+    return sol.litlen + sol.mlen;
+}
+
+#if 0 /* debug */
+
+static void
+listStats(const U32* table, int lastEltID)
+{
+    int const nbElts = lastEltID + 1;
+    int enb;
+    for (enb=0; enb < nbElts; enb++) {
+        (void)table;
+        /* RAWLOG(2, "%3i:%3i,  ", enb, table[enb]); */
+        RAWLOG(2, "%4i,", table[enb]);
+    }
+    RAWLOG(2, " \n");
+}
+
+#endif
+
+FORCE_INLINE_TEMPLATE size_t
+ZSTD_compressBlock_opt_generic(ZSTD_matchState_t* ms,
+                               seqStore_t* seqStore,
+                               U32 rep[ZSTD_REP_NUM],
+                         const void* src, size_t srcSize,
+                         const int optLevel,
+                         const ZSTD_dictMode_e dictMode)
+{
+    optState_t* const optStatePtr = &ms->opt;
+    const BYTE* const istart = (const BYTE*)src;
+    const BYTE* ip = istart;
+    const BYTE* anchor = istart;
+    const BYTE* const iend = istart + srcSize;
+    const BYTE* const ilimit = iend - 8;
+    const BYTE* const base = ms->window.base;
+    const BYTE* const prefixStart = base + ms->window.dictLimit;
+    const ZSTD_compressionParameters* const cParams = &ms->cParams;
+
+    ZSTD_getAllMatchesFn getAllMatches = ZSTD_selectBtGetAllMatches(ms, dictMode);
+
+    U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);
+    U32 const minMatch = (cParams->minMatch == 3) ? 3 : 4;
+    U32 nextToUpdate3 = ms->nextToUpdate;
+
+    ZSTD_optimal_t* const opt = optStatePtr->priceTable;
+    ZSTD_match_t* const matches = optStatePtr->matchTable;
+    ZSTD_optimal_t lastSequence;
+    ZSTD_optLdm_t optLdm;
+
+    ZSTD_memset(&lastSequence, 0, sizeof(ZSTD_optimal_t));
+
+    optLdm.seqStore = ms->ldmSeqStore ? *ms->ldmSeqStore : kNullRawSeqStore;
+    optLdm.endPosInBlock = optLdm.startPosInBlock = optLdm.offset = 0;
+    ZSTD_opt_getNextMatchAndUpdateSeqStore(&optLdm, (U32)(ip-istart), (U32)(iend-ip));
+
+    /* init */
+    DEBUGLOG(5, "ZSTD_compressBlock_opt_generic: current=%u, prefix=%u, nextToUpdate=%u",
+                (U32)(ip - base), ms->window.dictLimit, ms->nextToUpdate);
+    assert(optLevel <= 2);
+    ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize, optLevel);
+    ip += (ip==prefixStart);
+
+    /* Match Loop */
+    while (ip < ilimit) {
+        U32 cur, last_pos = 0;
+
+        /* find first match */
+        {   U32 const litlen = (U32)(ip - anchor);
+            U32 const ll0 = !litlen;
+            U32 nbMatches = getAllMatches(matches, ms, &nextToUpdate3, ip, iend, rep, ll0, minMatch);
+            ZSTD_optLdm_processMatchCandidate(&optLdm, matches, &nbMatches,
+                                              (U32)(ip-istart), (U32)(iend - ip));
+            if (!nbMatches) { ip++; continue; }
+
+            /* initialize opt[0] */
+            { U32 i ; for (i=0; i<ZSTD_REP_NUM; i++) opt[0].rep[i] = rep[i]; }
+            opt[0].mlen = 0;  /* means is_a_literal */
+            opt[0].litlen = litlen;
+            /* We don't need to include the actual price of the literals because
+             * it is static for the duration of the forward pass, and is included
+             * in every price. We include the literal length to avoid negative
+             * prices when we subtract the previous literal length.
+             */
+            opt[0].price = (int)ZSTD_litLengthPrice(litlen, optStatePtr, optLevel);
+
+            /* large match -> immediate encoding */
+            {   U32 const maxML = matches[nbMatches-1].len;
+                U32 const maxOffBase = matches[nbMatches-1].off;
+                DEBUGLOG(6, "found %u matches of maxLength=%u and maxOffBase=%u at cPos=%u => start new series",
+                            nbMatches, maxML, maxOffBase, (U32)(ip-prefixStart));
+
+                if (maxML > sufficient_len) {
+                    lastSequence.litlen = litlen;
+                    lastSequence.mlen = maxML;
+                    lastSequence.off = maxOffBase;
+                    DEBUGLOG(6, "large match (%u>%u), immediate encoding",
+                                maxML, sufficient_len);
+                    cur = 0;
+                    last_pos = ZSTD_totalLen(lastSequence);
+                    goto _shortestPath;
+            }   }
+
+            /* set prices for first matches starting position == 0 */
+            assert(opt[0].price >= 0);
+            {   U32 const literalsPrice = (U32)opt[0].price + ZSTD_litLengthPrice(0, optStatePtr, optLevel);
+                U32 pos;
+                U32 matchNb;
+                for (pos = 1; pos < minMatch; pos++) {
+                    opt[pos].price = ZSTD_MAX_PRICE;   /* mlen, litlen and price will be fixed during forward scanning */
+                }
+                for (matchNb = 0; matchNb < nbMatches; matchNb++) {
+                    U32 const offBase = matches[matchNb].off;
+                    U32 const end = matches[matchNb].len;
+                    for ( ; pos <= end ; pos++ ) {
+                        U32 const matchPrice = ZSTD_getMatchPrice(offBase, pos, optStatePtr, optLevel);
+                        U32 const sequencePrice = literalsPrice + matchPrice;
+                        DEBUGLOG(7, "rPos:%u => set initial price : %.2f",
+                                    pos, ZSTD_fCost((int)sequencePrice));
+                        opt[pos].mlen = pos;
+                        opt[pos].off = offBase;
+                        opt[pos].litlen = litlen;
+                        opt[pos].price = (int)sequencePrice;
+                }   }
+                last_pos = pos-1;
+            }
+        }
+
+        /* check further positions */
+        for (cur = 1; cur <= last_pos; cur++) {
+            const BYTE* const inr = ip + cur;
+            assert(cur < ZSTD_OPT_NUM);
+            DEBUGLOG(7, "cPos:%zi==rPos:%u", inr-istart, cur)
+
+            /* Fix current position with one literal if cheaper */
+            {   U32 const litlen = (opt[cur-1].mlen == 0) ? opt[cur-1].litlen + 1 : 1;
+                int const price = opt[cur-1].price
+                                + (int)ZSTD_rawLiteralsCost(ip+cur-1, 1, optStatePtr, optLevel)
+                                + (int)ZSTD_litLengthPrice(litlen, optStatePtr, optLevel)
+                                - (int)ZSTD_litLengthPrice(litlen-1, optStatePtr, optLevel);
+                assert(price < 1000000000); /* overflow check */
+                if (price <= opt[cur].price) {
+                    DEBUGLOG(7, "cPos:%zi==rPos:%u : better price (%.2f<=%.2f) using literal (ll==%u) (hist:%u,%u,%u)",
+                                inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price), litlen,
+                                opt[cur-1].rep[0], opt[cur-1].rep[1], opt[cur-1].rep[2]);
+                    opt[cur].mlen = 0;
+                    opt[cur].off = 0;
+                    opt[cur].litlen = litlen;
+                    opt[cur].price = price;
+                } else {
+                    DEBUGLOG(7, "cPos:%zi==rPos:%u : literal would cost more (%.2f>%.2f) (hist:%u,%u,%u)",
+                                inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price),
+                                opt[cur].rep[0], opt[cur].rep[1], opt[cur].rep[2]);
+                }
+            }
+
+            /* Set the repcodes of the current position. We must do it here
+             * because we rely on the repcodes of the 2nd to last sequence being
+             * correct to set the next chunks repcodes during the backward
+             * traversal.
+             */
+            ZSTD_STATIC_ASSERT(sizeof(opt[cur].rep) == sizeof(repcodes_t));
+            assert(cur >= opt[cur].mlen);
+            if (opt[cur].mlen != 0) {
+                U32 const prev = cur - opt[cur].mlen;
+                repcodes_t const newReps = ZSTD_newRep(opt[prev].rep, opt[cur].off, opt[cur].litlen==0);
+                ZSTD_memcpy(opt[cur].rep, &newReps, sizeof(repcodes_t));
+            } else {
+                ZSTD_memcpy(opt[cur].rep, opt[cur - 1].rep, sizeof(repcodes_t));
+            }
+
+            /* last match must start at a minimum distance of 8 from oend */
+            if (inr > ilimit) continue;
+
+            if (cur == last_pos) break;
+
+            if ( (optLevel==0) /*static_test*/
+              && (opt[cur+1].price <= opt[cur].price + (BITCOST_MULTIPLIER/2)) ) {
+                DEBUGLOG(7, "move to next rPos:%u : price is <=", cur+1);
+                continue;  /* skip unpromising positions; about ~+6% speed, -0.01 ratio */
+            }
+
+            assert(opt[cur].price >= 0);
+            {   U32 const ll0 = (opt[cur].mlen != 0);
+                U32 const litlen = (opt[cur].mlen == 0) ? opt[cur].litlen : 0;
+                U32 const previousPrice = (U32)opt[cur].price;
+                U32 const basePrice = previousPrice + ZSTD_litLengthPrice(0, optStatePtr, optLevel);
+                U32 nbMatches = getAllMatches(matches, ms, &nextToUpdate3, inr, iend, opt[cur].rep, ll0, minMatch);
+                U32 matchNb;
+
+                ZSTD_optLdm_processMatchCandidate(&optLdm, matches, &nbMatches,
+                                                  (U32)(inr-istart), (U32)(iend-inr));
+
+                if (!nbMatches) {
+                    DEBUGLOG(7, "rPos:%u : no match found", cur);
+                    continue;
+                }
+
+                {   U32 const maxML = matches[nbMatches-1].len;
+                    DEBUGLOG(7, "cPos:%zi==rPos:%u, found %u matches, of maxLength=%u",
+                                inr-istart, cur, nbMatches, maxML);
+
+                    if ( (maxML > sufficient_len)
+                      || (cur + maxML >= ZSTD_OPT_NUM) ) {
+                        lastSequence.mlen = maxML;
+                        lastSequence.off = matches[nbMatches-1].off;
+                        lastSequence.litlen = litlen;
+                        cur -= (opt[cur].mlen==0) ? opt[cur].litlen : 0;  /* last sequence is actually only literals, fix cur to last match - note : may underflow, in which case, it's first sequence, and it's okay */
+                        last_pos = cur + ZSTD_totalLen(lastSequence);
+                        if (cur > ZSTD_OPT_NUM) cur = 0;   /* underflow => first match */
+                        goto _shortestPath;
+                }   }
+
+                /* set prices using matches found at position == cur */
+                for (matchNb = 0; matchNb < nbMatches; matchNb++) {
+                    U32 const offset = matches[matchNb].off;
+                    U32 const lastML = matches[matchNb].len;
+                    U32 const startML = (matchNb>0) ? matches[matchNb-1].len+1 : minMatch;
+                    U32 mlen;
+
+                    DEBUGLOG(7, "testing match %u => offBase=%4u, mlen=%2u, llen=%2u",
+                                matchNb, matches[matchNb].off, lastML, litlen);
+
+                    for (mlen = lastML; mlen >= startML; mlen--) {  /* scan downward */
+                        U32 const pos = cur + mlen;
+                        int const price = (int)basePrice + (int)ZSTD_getMatchPrice(offset, mlen, optStatePtr, optLevel);
+
+                        if ((pos > last_pos) || (price < opt[pos].price)) {
+                            DEBUGLOG(7, "rPos:%u (ml=%2u) => new better price (%.2f<%.2f)",
+                                        pos, mlen, ZSTD_fCost(price), ZSTD_fCost(opt[pos].price));
+                            while (last_pos < pos) { opt[last_pos+1].price = ZSTD_MAX_PRICE; last_pos++; }   /* fill empty positions */
+                            opt[pos].mlen = mlen;
+                            opt[pos].off = offset;
+                            opt[pos].litlen = litlen;
+                            opt[pos].price = price;
+                        } else {
+                            DEBUGLOG(7, "rPos:%u (ml=%2u) => new price is worse (%.2f>=%.2f)",
+                                        pos, mlen, ZSTD_fCost(price), ZSTD_fCost(opt[pos].price));
+                            if (optLevel==0) break;  /* early update abort; gets ~+10% speed for about -0.01 ratio loss */
+                        }
+            }   }   }
+        }  /* for (cur = 1; cur <= last_pos; cur++) */
+
+        lastSequence = opt[last_pos];
+        cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;  /* single sequence, and it starts before `ip` */
+        assert(cur < ZSTD_OPT_NUM);  /* control overflow*/
+
+_shortestPath:   /* cur, last_pos, best_mlen, best_off have to be set */
+        assert(opt[0].mlen == 0);
+
+        /* Set the next chunk's repcodes based on the repcodes of the beginning
+         * of the last match, and the last sequence. This avoids us having to
+         * update them while traversing the sequences.
+         */
+        if (lastSequence.mlen != 0) {
+            repcodes_t const reps = ZSTD_newRep(opt[cur].rep, lastSequence.off, lastSequence.litlen==0);
+            ZSTD_memcpy(rep, &reps, sizeof(reps));
+        } else {
+            ZSTD_memcpy(rep, opt[cur].rep, sizeof(repcodes_t));
+        }
+
+        {   U32 const storeEnd = cur + 1;
+            U32 storeStart = storeEnd;
+            U32 seqPos = cur;
+
+            DEBUGLOG(6, "start reverse traversal (last_pos:%u, cur:%u)",
+                        last_pos, cur); (void)last_pos;
+            assert(storeEnd < ZSTD_OPT_NUM);
+            DEBUGLOG(6, "last sequence copied into pos=%u (llen=%u,mlen=%u,ofc=%u)",
+                        storeEnd, lastSequence.litlen, lastSequence.mlen, lastSequence.off);
+            opt[storeEnd] = lastSequence;
+            while (seqPos > 0) {
+                U32 const backDist = ZSTD_totalLen(opt[seqPos]);
+                storeStart--;
+                DEBUGLOG(6, "sequence from rPos=%u copied into pos=%u (llen=%u,mlen=%u,ofc=%u)",
+                            seqPos, storeStart, opt[seqPos].litlen, opt[seqPos].mlen, opt[seqPos].off);
+                opt[storeStart] = opt[seqPos];
+                seqPos = (seqPos > backDist) ? seqPos - backDist : 0;
+            }
+
+            /* save sequences */
+            DEBUGLOG(6, "sending selected sequences into seqStore")
+            {   U32 storePos;
+                for (storePos=storeStart; storePos <= storeEnd; storePos++) {
+                    U32 const llen = opt[storePos].litlen;
+                    U32 const mlen = opt[storePos].mlen;
+                    U32 const offBase = opt[storePos].off;
+                    U32 const advance = llen + mlen;
+                    DEBUGLOG(6, "considering seq starting at %zi, llen=%u, mlen=%u",
+                                anchor - istart, (unsigned)llen, (unsigned)mlen);
+
+                    if (mlen==0) {  /* only literals => must be last "sequence", actually starting a new stream of sequences */
+                        assert(storePos == storeEnd);   /* must be last sequence */
+                        ip = anchor + llen;     /* last "sequence" is a bunch of literals => don't progress anchor */
+                        continue;   /* will finish */
+                    }
+
+                    assert(anchor + llen <= iend);
+                    ZSTD_updateStats(optStatePtr, llen, anchor, offBase, mlen);
+                    ZSTD_storeSeq(seqStore, llen, anchor, iend, offBase, mlen);
+                    anchor += advance;
+                    ip = anchor;
+            }   }
+            ZSTD_setBasePrices(optStatePtr, optLevel);
+        }
+    }   /* while (ip < ilimit) */
+
+    /* Return the last literals size */
+    return (size_t)(iend - anchor);
+}
+
+static size_t ZSTD_compressBlock_opt0(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        const void* src, size_t srcSize, const ZSTD_dictMode_e dictMode)
+{
+    return ZSTD_compressBlock_opt_generic(ms, seqStore, rep, src, srcSize, 0 /* optLevel */, dictMode);
+}
+
+static size_t ZSTD_compressBlock_opt2(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        const void* src, size_t srcSize, const ZSTD_dictMode_e dictMode)
+{
+    return ZSTD_compressBlock_opt_generic(ms, seqStore, rep, src, srcSize, 2 /* optLevel */, dictMode);
+}
+
+size_t ZSTD_compressBlock_btopt(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        const void* src, size_t srcSize)
+{
+    DEBUGLOG(5, "ZSTD_compressBlock_btopt");
+    return ZSTD_compressBlock_opt0(ms, seqStore, rep, src, srcSize, ZSTD_noDict);
+}
+
+
+
+
+/* ZSTD_initStats_ultra():
+ * make a first compression pass, just to seed stats with more accurate starting values.
+ * only works on first block, with no dictionary and no ldm.
+ * this function cannot error out, its narrow contract must be respected.
+ */
+static void
+ZSTD_initStats_ultra(ZSTD_matchState_t* ms,
+                     seqStore_t* seqStore,
+                     U32 rep[ZSTD_REP_NUM],
+               const void* src, size_t srcSize)
+{
+    U32 tmpRep[ZSTD_REP_NUM];  /* updated rep codes will sink here */
+    ZSTD_memcpy(tmpRep, rep, sizeof(tmpRep));
+
+    DEBUGLOG(4, "ZSTD_initStats_ultra (srcSize=%zu)", srcSize);
+    assert(ms->opt.litLengthSum == 0);    /* first block */
+    assert(seqStore->sequences == seqStore->sequencesStart);   /* no ldm */
+    assert(ms->window.dictLimit == ms->window.lowLimit);   /* no dictionary */
+    assert(ms->window.dictLimit - ms->nextToUpdate <= 1);  /* no prefix (note: intentional overflow, defined as 2-complement) */
+
+    ZSTD_compressBlock_opt2(ms, seqStore, tmpRep, src, srcSize, ZSTD_noDict);   /* generate stats into ms->opt*/
+
+    /* invalidate first scan from history, only keep entropy stats */
+    ZSTD_resetSeqStore(seqStore);
+    ms->window.base -= srcSize;
+    ms->window.dictLimit += (U32)srcSize;
+    ms->window.lowLimit = ms->window.dictLimit;
+    ms->nextToUpdate = ms->window.dictLimit;
+
+}
+
+size_t ZSTD_compressBlock_btultra(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        const void* src, size_t srcSize)
+{
+    DEBUGLOG(5, "ZSTD_compressBlock_btultra (srcSize=%zu)", srcSize);
+    return ZSTD_compressBlock_opt2(ms, seqStore, rep, src, srcSize, ZSTD_noDict);
+}
+
+size_t ZSTD_compressBlock_btultra2(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        const void* src, size_t srcSize)
+{
+    U32 const curr = (U32)((const BYTE*)src - ms->window.base);
+    DEBUGLOG(5, "ZSTD_compressBlock_btultra2 (srcSize=%zu)", srcSize);
+
+    /* 2-passes strategy:
+     * this strategy makes a first pass over first block to collect statistics
+     * in order to seed next round's statistics with it.
+     * After 1st pass, function forgets history, and starts a new block.
+     * Consequently, this can only work if no data has been previously loaded in tables,
+     * aka, no dictionary, no prefix, no ldm preprocessing.
+     * The compression ratio gain is generally small (~0.5% on first block),
+    ** the cost is 2x cpu time on first block. */
+    assert(srcSize <= ZSTD_BLOCKSIZE_MAX);
+    if ( (ms->opt.litLengthSum==0)   /* first block */
+      && (seqStore->sequences == seqStore->sequencesStart)  /* no ldm */
+      && (ms->window.dictLimit == ms->window.lowLimit)   /* no dictionary */
+      && (curr == ms->window.dictLimit)    /* start of frame, nothing already loaded nor skipped */
+      && (srcSize > ZSTD_PREDEF_THRESHOLD) /* input large enough to not employ default stats */
+      ) {
+        ZSTD_initStats_ultra(ms, seqStore, rep, src, srcSize);
+    }
+
+    return ZSTD_compressBlock_opt2(ms, seqStore, rep, src, srcSize, ZSTD_noDict);
+}
+
+size_t ZSTD_compressBlock_btopt_dictMatchState(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        const void* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_opt0(ms, seqStore, rep, src, srcSize, ZSTD_dictMatchState);
+}
+
+size_t ZSTD_compressBlock_btultra_dictMatchState(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        const void* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_opt2(ms, seqStore, rep, src, srcSize, ZSTD_dictMatchState);
+}
+
+size_t ZSTD_compressBlock_btopt_extDict(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        const void* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_opt0(ms, seqStore, rep, src, srcSize, ZSTD_extDict);
+}
+
+size_t ZSTD_compressBlock_btultra_extDict(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        const void* src, size_t srcSize)
+{
+    return ZSTD_compressBlock_opt2(ms, seqStore, rep, src, srcSize, ZSTD_extDict);
+}
+
+/* note : no btultra2 variant for extDict nor dictMatchState,
+ * because btultra2 is not meant to work with dictionaries
+ * and is only specific for the first block (no prefix) */
diff --git a/src/3rdparty/zstd/src/compress/zstd_opt.h b/src/3rdparty/zstd/src/compress/zstd_opt.h
new file mode 100644
index 0000000000..342e5a3112
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstd_opt.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_OPT_H
+#define ZSTD_OPT_H
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#include "zstd_compress_internal.h"
+
+/* used in ZSTD_loadDictionaryContent() */
+void ZSTD_updateTree(ZSTD_matchState_t* ms, const BYTE* ip, const BYTE* iend);
+
+size_t ZSTD_compressBlock_btopt(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_btultra(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_btultra2(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+
+
+size_t ZSTD_compressBlock_btopt_dictMatchState(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_btultra_dictMatchState(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+
+size_t ZSTD_compressBlock_btopt_extDict(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+size_t ZSTD_compressBlock_btultra_extDict(
+        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],
+        void const* src, size_t srcSize);
+
+        /* note : no btultra2 variant for extDict nor dictMatchState,
+         * because btultra2 is not meant to work with dictionaries
+         * and is only specific for the first block (no prefix) */
+
+#if defined (__cplusplus)
+}
+#endif
+
+#endif /* ZSTD_OPT_H */
diff --git a/src/3rdparty/zstd/src/compress/zstdmt_compress.c b/src/3rdparty/zstd/src/compress/zstdmt_compress.c
new file mode 100644
index 0000000000..6786075569
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstdmt_compress.c
@@ -0,0 +1,1867 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+
+/* ======   Compiler specifics   ====== */
+#if defined(_MSC_VER)
+#  pragma warning(disable : 4204)   /* disable: C4204: non-constant aggregate initializer */
+#endif
+
+
+/* ======   Constants   ====== */
+#define ZSTDMT_OVERLAPLOG_DEFAULT 0
+
+
+/* ======   Dependencies   ====== */
+#include "../common/allocations.h"  /* ZSTD_customMalloc, ZSTD_customCalloc, ZSTD_customFree */
+#include "../common/zstd_deps.h"   /* ZSTD_memcpy, ZSTD_memset, INT_MAX, UINT_MAX */
+#include "../common/mem.h"         /* MEM_STATIC */
+#include "../common/pool.h"        /* threadpool */
+#include "../common/threading.h"   /* mutex */
+#include "zstd_compress_internal.h"  /* MIN, ERROR, ZSTD_*, ZSTD_highbit32 */
+#include "zstd_ldm.h"
+#include "zstdmt_compress.h"
+
+/* Guards code to support resizing the SeqPool.
+ * We will want to resize the SeqPool to save memory in the future.
+ * Until then, comment the code out since it is unused.
+ */
+#define ZSTD_RESIZE_SEQPOOL 0
+
+/* ======   Debug   ====== */
+#if defined(DEBUGLEVEL) && (DEBUGLEVEL>=2) \
+    && !defined(_MSC_VER) \
+    && !defined(__MINGW32__)
+
+#  include <stdio.h>
+#  include <unistd.h>
+#  include <sys/times.h>
+
+#  define DEBUG_PRINTHEX(l,p,n) {            \
+    unsigned debug_u;                        \
+    for (debug_u=0; debug_u<(n); debug_u++)  \
+        RAWLOG(l, "%02X ", ((const unsigned char*)(p))[debug_u]); \
+    RAWLOG(l, " \n");                        \
+}
+
+static unsigned long long GetCurrentClockTimeMicroseconds(void)
+{
+   static clock_t _ticksPerSecond = 0;
+   if (_ticksPerSecond <= 0) _ticksPerSecond = sysconf(_SC_CLK_TCK);
+
+   {   struct tms junk; clock_t newTicks = (clock_t) times(&junk);
+       return ((((unsigned long long)newTicks)*(1000000))/_ticksPerSecond);
+}  }
+
+#define MUTEX_WAIT_TIME_DLEVEL 6
+#define ZSTD_PTHREAD_MUTEX_LOCK(mutex) {          \
+    if (DEBUGLEVEL >= MUTEX_WAIT_TIME_DLEVEL) {   \
+        unsigned long long const beforeTime = GetCurrentClockTimeMicroseconds(); \
+        ZSTD_pthread_mutex_lock(mutex);           \
+        {   unsigned long long const afterTime = GetCurrentClockTimeMicroseconds(); \
+            unsigned long long const elapsedTime = (afterTime-beforeTime); \
+            if (elapsedTime > 1000) {  /* or whatever threshold you like; I'm using 1 millisecond here */ \
+                DEBUGLOG(MUTEX_WAIT_TIME_DLEVEL, "Thread took %llu microseconds to acquire mutex %s \n", \
+                   elapsedTime, #mutex);          \
+        }   }                                     \
+    } else {                                      \
+        ZSTD_pthread_mutex_lock(mutex);           \
+    }                                             \
+}
+
+#else
+
+#  define ZSTD_PTHREAD_MUTEX_LOCK(m) ZSTD_pthread_mutex_lock(m)
+#  define DEBUG_PRINTHEX(l,p,n) {}
+
+#endif
+
+
+/* =====   Buffer Pool   ===== */
+/* a single Buffer Pool can be invoked from multiple threads in parallel */
+
+typedef struct buffer_s {
+    void* start;
+    size_t capacity;
+} buffer_t;
+
+static const buffer_t g_nullBuffer = { NULL, 0 };
+
+typedef struct ZSTDMT_bufferPool_s {
+    ZSTD_pthread_mutex_t poolMutex;
+    size_t bufferSize;
+    unsigned totalBuffers;
+    unsigned nbBuffers;
+    ZSTD_customMem cMem;
+    buffer_t bTable[1];   /* variable size */
+} ZSTDMT_bufferPool;
+
+static ZSTDMT_bufferPool* ZSTDMT_createBufferPool(unsigned maxNbBuffers, ZSTD_customMem cMem)
+{
+    ZSTDMT_bufferPool* const bufPool = (ZSTDMT_bufferPool*)ZSTD_customCalloc(
+        sizeof(ZSTDMT_bufferPool) + (maxNbBuffers-1) * sizeof(buffer_t), cMem);
+    if (bufPool==NULL) return NULL;
+    if (ZSTD_pthread_mutex_init(&bufPool->poolMutex, NULL)) {
+        ZSTD_customFree(bufPool, cMem);
+        return NULL;
+    }
+    bufPool->bufferSize = 64 KB;
+    bufPool->totalBuffers = maxNbBuffers;
+    bufPool->nbBuffers = 0;
+    bufPool->cMem = cMem;
+    return bufPool;
+}
+
+static void ZSTDMT_freeBufferPool(ZSTDMT_bufferPool* bufPool)
+{
+    unsigned u;
+    DEBUGLOG(3, "ZSTDMT_freeBufferPool (address:%08X)", (U32)(size_t)bufPool);
+    if (!bufPool) return;   /* compatibility with free on NULL */
+    for (u=0; u<bufPool->totalBuffers; u++) {
+        DEBUGLOG(4, "free buffer %2u (address:%08X)", u, (U32)(size_t)bufPool->bTable[u].start);
+        ZSTD_customFree(bufPool->bTable[u].start, bufPool->cMem);
+    }
+    ZSTD_pthread_mutex_destroy(&bufPool->poolMutex);
+    ZSTD_customFree(bufPool, bufPool->cMem);
+}
+
+/* only works at initialization, not during compression */
+static size_t ZSTDMT_sizeof_bufferPool(ZSTDMT_bufferPool* bufPool)
+{
+    size_t const poolSize = sizeof(*bufPool)
+                          + (bufPool->totalBuffers - 1) * sizeof(buffer_t);
+    unsigned u;
+    size_t totalBufferSize = 0;
+    ZSTD_pthread_mutex_lock(&bufPool->poolMutex);
+    for (u=0; u<bufPool->totalBuffers; u++)
+        totalBufferSize += bufPool->bTable[u].capacity;
+    ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);
+
+    return poolSize + totalBufferSize;
+}
+
+/* ZSTDMT_setBufferSize() :
+ * all future buffers provided by this buffer pool will have _at least_ this size
+ * note : it's better for all buffers to have same size,
+ * as they become freely interchangeable, reducing malloc/free usages and memory fragmentation */
+static void ZSTDMT_setBufferSize(ZSTDMT_bufferPool* const bufPool, size_t const bSize)
+{
+    ZSTD_pthread_mutex_lock(&bufPool->poolMutex);
+    DEBUGLOG(4, "ZSTDMT_setBufferSize: bSize = %u", (U32)bSize);
+    bufPool->bufferSize = bSize;
+    ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);
+}
+
+
+static ZSTDMT_bufferPool* ZSTDMT_expandBufferPool(ZSTDMT_bufferPool* srcBufPool, unsigned maxNbBuffers)
+{
+    if (srcBufPool==NULL) return NULL;
+    if (srcBufPool->totalBuffers >= maxNbBuffers) /* good enough */
+        return srcBufPool;
+    /* need a larger buffer pool */
+    {   ZSTD_customMem const cMem = srcBufPool->cMem;
+        size_t const bSize = srcBufPool->bufferSize;   /* forward parameters */
+        ZSTDMT_bufferPool* newBufPool;
+        ZSTDMT_freeBufferPool(srcBufPool);
+        newBufPool = ZSTDMT_createBufferPool(maxNbBuffers, cMem);
+        if (newBufPool==NULL) return newBufPool;
+        ZSTDMT_setBufferSize(newBufPool, bSize);
+        return newBufPool;
+    }
+}
+
+/** ZSTDMT_getBuffer() :
+ *  assumption : bufPool must be valid
+ * @return : a buffer, with start pointer and size
+ *  note: allocation may fail, in this case, start==NULL and size==0 */
+static buffer_t ZSTDMT_getBuffer(ZSTDMT_bufferPool* bufPool)
+{
+    size_t const bSize = bufPool->bufferSize;
+    DEBUGLOG(5, "ZSTDMT_getBuffer: bSize = %u", (U32)bufPool->bufferSize);
+    ZSTD_pthread_mutex_lock(&bufPool->poolMutex);
+    if (bufPool->nbBuffers) {   /* try to use an existing buffer */
+        buffer_t const buf = bufPool->bTable[--(bufPool->nbBuffers)];
+        size_t const availBufferSize = buf.capacity;
+        bufPool->bTable[bufPool->nbBuffers] = g_nullBuffer;
+        if ((availBufferSize >= bSize) & ((availBufferSize>>3) <= bSize)) {
+            /* large enough, but not too much */
+            DEBUGLOG(5, "ZSTDMT_getBuffer: provide buffer %u of size %u",
+                        bufPool->nbBuffers, (U32)buf.capacity);
+            ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);
+            return buf;
+        }
+        /* size conditions not respected : scratch this buffer, create new one */
+        DEBUGLOG(5, "ZSTDMT_getBuffer: existing buffer does not meet size conditions => freeing");
+        ZSTD_customFree(buf.start, bufPool->cMem);
+    }
+    ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);
+    /* create new buffer */
+    DEBUGLOG(5, "ZSTDMT_getBuffer: create a new buffer");
+    {   buffer_t buffer;
+        void* const start = ZSTD_customMalloc(bSize, bufPool->cMem);
+        buffer.start = start;   /* note : start can be NULL if malloc fails ! */
+        buffer.capacity = (start==NULL) ? 0 : bSize;
+        if (start==NULL) {
+            DEBUGLOG(5, "ZSTDMT_getBuffer: buffer allocation failure !!");
+        } else {
+            DEBUGLOG(5, "ZSTDMT_getBuffer: created buffer of size %u", (U32)bSize);
+        }
+        return buffer;
+    }
+}
+
+#if ZSTD_RESIZE_SEQPOOL
+/** ZSTDMT_resizeBuffer() :
+ * assumption : bufPool must be valid
+ * @return : a buffer that is at least the buffer pool buffer size.
+ *           If a reallocation happens, the data in the input buffer is copied.
+ */
+static buffer_t ZSTDMT_resizeBuffer(ZSTDMT_bufferPool* bufPool, buffer_t buffer)
+{
+    size_t const bSize = bufPool->bufferSize;
+    if (buffer.capacity < bSize) {
+        void* const start = ZSTD_customMalloc(bSize, bufPool->cMem);
+        buffer_t newBuffer;
+        newBuffer.start = start;
+        newBuffer.capacity = start == NULL ? 0 : bSize;
+        if (start != NULL) {
+            assert(newBuffer.capacity >= buffer.capacity);
+            ZSTD_memcpy(newBuffer.start, buffer.start, buffer.capacity);
+            DEBUGLOG(5, "ZSTDMT_resizeBuffer: created buffer of size %u", (U32)bSize);
+            return newBuffer;
+        }
+        DEBUGLOG(5, "ZSTDMT_resizeBuffer: buffer allocation failure !!");
+    }
+    return buffer;
+}
+#endif
+
+/* store buffer for later re-use, up to pool capacity */
+static void ZSTDMT_releaseBuffer(ZSTDMT_bufferPool* bufPool, buffer_t buf)
+{
+    DEBUGLOG(5, "ZSTDMT_releaseBuffer");
+    if (buf.start == NULL) return;   /* compatible with release on NULL */
+    ZSTD_pthread_mutex_lock(&bufPool->poolMutex);
+    if (bufPool->nbBuffers < bufPool->totalBuffers) {
+        bufPool->bTable[bufPool->nbBuffers++] = buf;  /* stored for later use */
+        DEBUGLOG(5, "ZSTDMT_releaseBuffer: stored buffer of size %u in slot %u",
+                    (U32)buf.capacity, (U32)(bufPool->nbBuffers-1));
+        ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);
+        return;
+    }
+    ZSTD_pthread_mutex_unlock(&bufPool->poolMutex);
+    /* Reached bufferPool capacity (should not happen) */
+    DEBUGLOG(5, "ZSTDMT_releaseBuffer: pool capacity reached => freeing ");
+    ZSTD_customFree(buf.start, bufPool->cMem);
+}
+
+/* We need 2 output buffers per worker since each dstBuff must be flushed after it is released.
+ * The 3 additional buffers are as follows:
+ *   1 buffer for input loading
+ *   1 buffer for "next input" when submitting current one
+ *   1 buffer stuck in queue */
+#define BUF_POOL_MAX_NB_BUFFERS(nbWorkers) (2*(nbWorkers) + 3)
+
+/* After a worker releases its rawSeqStore, it is immediately ready for reuse.
+ * So we only need one seq buffer per worker. */
+#define SEQ_POOL_MAX_NB_BUFFERS(nbWorkers) (nbWorkers)
+
+/* =====   Seq Pool Wrapper   ====== */
+
+typedef ZSTDMT_bufferPool ZSTDMT_seqPool;
+
+static size_t ZSTDMT_sizeof_seqPool(ZSTDMT_seqPool* seqPool)
+{
+    return ZSTDMT_sizeof_bufferPool(seqPool);
+}
+
+static rawSeqStore_t bufferToSeq(buffer_t buffer)
+{
+    rawSeqStore_t seq = kNullRawSeqStore;
+    seq.seq = (rawSeq*)buffer.start;
+    seq.capacity = buffer.capacity / sizeof(rawSeq);
+    return seq;
+}
+
+static buffer_t seqToBuffer(rawSeqStore_t seq)
+{
+    buffer_t buffer;
+    buffer.start = seq.seq;
+    buffer.capacity = seq.capacity * sizeof(rawSeq);
+    return buffer;
+}
+
+static rawSeqStore_t ZSTDMT_getSeq(ZSTDMT_seqPool* seqPool)
+{
+    if (seqPool->bufferSize == 0) {
+        return kNullRawSeqStore;
+    }
+    return bufferToSeq(ZSTDMT_getBuffer(seqPool));
+}
+
+#if ZSTD_RESIZE_SEQPOOL
+static rawSeqStore_t ZSTDMT_resizeSeq(ZSTDMT_seqPool* seqPool, rawSeqStore_t seq)
+{
+  return bufferToSeq(ZSTDMT_resizeBuffer(seqPool, seqToBuffer(seq)));
+}
+#endif
+
+static void ZSTDMT_releaseSeq(ZSTDMT_seqPool* seqPool, rawSeqStore_t seq)
+{
+  ZSTDMT_releaseBuffer(seqPool, seqToBuffer(seq));
+}
+
+static void ZSTDMT_setNbSeq(ZSTDMT_seqPool* const seqPool, size_t const nbSeq)
+{
+  ZSTDMT_setBufferSize(seqPool, nbSeq * sizeof(rawSeq));
+}
+
+static ZSTDMT_seqPool* ZSTDMT_createSeqPool(unsigned nbWorkers, ZSTD_customMem cMem)
+{
+    ZSTDMT_seqPool* const seqPool = ZSTDMT_createBufferPool(SEQ_POOL_MAX_NB_BUFFERS(nbWorkers), cMem);
+    if (seqPool == NULL) return NULL;
+    ZSTDMT_setNbSeq(seqPool, 0);
+    return seqPool;
+}
+
+static void ZSTDMT_freeSeqPool(ZSTDMT_seqPool* seqPool)
+{
+    ZSTDMT_freeBufferPool(seqPool);
+}
+
+static ZSTDMT_seqPool* ZSTDMT_expandSeqPool(ZSTDMT_seqPool* pool, U32 nbWorkers)
+{
+    return ZSTDMT_expandBufferPool(pool, SEQ_POOL_MAX_NB_BUFFERS(nbWorkers));
+}
+
+
+/* =====   CCtx Pool   ===== */
+/* a single CCtx Pool can be invoked from multiple threads in parallel */
+
+typedef struct {
+    ZSTD_pthread_mutex_t poolMutex;
+    int totalCCtx;
+    int availCCtx;
+    ZSTD_customMem cMem;
+    ZSTD_CCtx* cctx[1];   /* variable size */
+} ZSTDMT_CCtxPool;
+
+/* note : all CCtx borrowed from the pool should be released back to the pool _before_ freeing the pool */
+static void ZSTDMT_freeCCtxPool(ZSTDMT_CCtxPool* pool)
+{
+    int cid;
+    for (cid=0; cid<pool->totalCCtx; cid++)
+        ZSTD_freeCCtx(pool->cctx[cid]);  /* note : compatible with free on NULL */
+    ZSTD_pthread_mutex_destroy(&pool->poolMutex);
+    ZSTD_customFree(pool, pool->cMem);
+}
+
+/* ZSTDMT_createCCtxPool() :
+ * implies nbWorkers >= 1 , checked by caller ZSTDMT_createCCtx() */
+static ZSTDMT_CCtxPool* ZSTDMT_createCCtxPool(int nbWorkers,
+                                              ZSTD_customMem cMem)
+{
+    ZSTDMT_CCtxPool* const cctxPool = (ZSTDMT_CCtxPool*) ZSTD_customCalloc(
+        sizeof(ZSTDMT_CCtxPool) + (nbWorkers-1)*sizeof(ZSTD_CCtx*), cMem);
+    assert(nbWorkers > 0);
+    if (!cctxPool) return NULL;
+    if (ZSTD_pthread_mutex_init(&cctxPool->poolMutex, NULL)) {
+        ZSTD_customFree(cctxPool, cMem);
+        return NULL;
+    }
+    cctxPool->cMem = cMem;
+    cctxPool->totalCCtx = nbWorkers;
+    cctxPool->availCCtx = 1;   /* at least one cctx for single-thread mode */
+    cctxPool->cctx[0] = ZSTD_createCCtx_advanced(cMem);
+    if (!cctxPool->cctx[0]) { ZSTDMT_freeCCtxPool(cctxPool); return NULL; }
+    DEBUGLOG(3, "cctxPool created, with %u workers", nbWorkers);
+    return cctxPool;
+}
+
+static ZSTDMT_CCtxPool* ZSTDMT_expandCCtxPool(ZSTDMT_CCtxPool* srcPool,
+                                              int nbWorkers)
+{
+    if (srcPool==NULL) return NULL;
+    if (nbWorkers <= srcPool->totalCCtx) return srcPool;   /* good enough */
+    /* need a larger cctx pool */
+    {   ZSTD_customMem const cMem = srcPool->cMem;
+        ZSTDMT_freeCCtxPool(srcPool);
+        return ZSTDMT_createCCtxPool(nbWorkers, cMem);
+    }
+}
+
+/* only works during initialization phase, not during compression */
+static size_t ZSTDMT_sizeof_CCtxPool(ZSTDMT_CCtxPool* cctxPool)
+{
+    ZSTD_pthread_mutex_lock(&cctxPool->poolMutex);
+    {   unsigned const nbWorkers = cctxPool->totalCCtx;
+        size_t const poolSize = sizeof(*cctxPool)
+                                + (nbWorkers-1) * sizeof(ZSTD_CCtx*);
+        unsigned u;
+        size_t totalCCtxSize = 0;
+        for (u=0; u<nbWorkers; u++) {
+            totalCCtxSize += ZSTD_sizeof_CCtx(cctxPool->cctx[u]);
+        }
+        ZSTD_pthread_mutex_unlock(&cctxPool->poolMutex);
+        assert(nbWorkers > 0);
+        return poolSize + totalCCtxSize;
+    }
+}
+
+static ZSTD_CCtx* ZSTDMT_getCCtx(ZSTDMT_CCtxPool* cctxPool)
+{
+    DEBUGLOG(5, "ZSTDMT_getCCtx");
+    ZSTD_pthread_mutex_lock(&cctxPool->poolMutex);
+    if (cctxPool->availCCtx) {
+        cctxPool->availCCtx--;
+        {   ZSTD_CCtx* const cctx = cctxPool->cctx[cctxPool->availCCtx];
+            ZSTD_pthread_mutex_unlock(&cctxPool->poolMutex);
+            return cctx;
+    }   }
+    ZSTD_pthread_mutex_unlock(&cctxPool->poolMutex);
+    DEBUGLOG(5, "create one more CCtx");
+    return ZSTD_createCCtx_advanced(cctxPool->cMem);   /* note : can be NULL, when creation fails ! */
+}
+
+static void ZSTDMT_releaseCCtx(ZSTDMT_CCtxPool* pool, ZSTD_CCtx* cctx)
+{
+    if (cctx==NULL) return;   /* compatibility with release on NULL */
+    ZSTD_pthread_mutex_lock(&pool->poolMutex);
+    if (pool->availCCtx < pool->totalCCtx)
+        pool->cctx[pool->availCCtx++] = cctx;
+    else {
+        /* pool overflow : should not happen, since totalCCtx==nbWorkers */
+        DEBUGLOG(4, "CCtx pool overflow : free cctx");
+        ZSTD_freeCCtx(cctx);
+    }
+    ZSTD_pthread_mutex_unlock(&pool->poolMutex);
+}
+
+/* ====   Serial State   ==== */
+
+typedef struct {
+    void const* start;
+    size_t size;
+} range_t;
+
+typedef struct {
+    /* All variables in the struct are protected by mutex. */
+    ZSTD_pthread_mutex_t mutex;
+    ZSTD_pthread_cond_t cond;
+    ZSTD_CCtx_params params;
+    ldmState_t ldmState;
+    XXH64_state_t xxhState;
+    unsigned nextJobID;
+    /* Protects ldmWindow.
+     * Must be acquired after the main mutex when acquiring both.
+     */
+    ZSTD_pthread_mutex_t ldmWindowMutex;
+    ZSTD_pthread_cond_t ldmWindowCond;  /* Signaled when ldmWindow is updated */
+    ZSTD_window_t ldmWindow;  /* A thread-safe copy of ldmState.window */
+} serialState_t;
+
+static int
+ZSTDMT_serialState_reset(serialState_t* serialState,
+                         ZSTDMT_seqPool* seqPool,
+                         ZSTD_CCtx_params params,
+                         size_t jobSize,
+                         const void* dict, size_t const dictSize,
+                         ZSTD_dictContentType_e dictContentType)
+{
+    /* Adjust parameters */
+    if (params.ldmParams.enableLdm == ZSTD_ps_enable) {
+        DEBUGLOG(4, "LDM window size = %u KB", (1U << params.cParams.windowLog) >> 10);
+        ZSTD_ldm_adjustParameters(&params.ldmParams, &params.cParams);
+        assert(params.ldmParams.hashLog >= params.ldmParams.bucketSizeLog);
+        assert(params.ldmParams.hashRateLog < 32);
+    } else {
+        ZSTD_memset(&params.ldmParams, 0, sizeof(params.ldmParams));
+    }
+    serialState->nextJobID = 0;
+    if (params.fParams.checksumFlag)
+        XXH64_reset(&serialState->xxhState, 0);
+    if (params.ldmParams.enableLdm == ZSTD_ps_enable) {
+        ZSTD_customMem cMem = params.customMem;
+        unsigned const hashLog = params.ldmParams.hashLog;
+        size_t const hashSize = ((size_t)1 << hashLog) * sizeof(ldmEntry_t);
+        unsigned const bucketLog =
+            params.ldmParams.hashLog - params.ldmParams.bucketSizeLog;
+        unsigned const prevBucketLog =
+            serialState->params.ldmParams.hashLog -
+            serialState->params.ldmParams.bucketSizeLog;
+        size_t const numBuckets = (size_t)1 << bucketLog;
+        /* Size the seq pool tables */
+        ZSTDMT_setNbSeq(seqPool, ZSTD_ldm_getMaxNbSeq(params.ldmParams, jobSize));
+        /* Reset the window */
+        ZSTD_window_init(&serialState->ldmState.window);
+        /* Resize tables and output space if necessary. */
+        if (serialState->ldmState.hashTable == NULL || serialState->params.ldmParams.hashLog < hashLog) {
+            ZSTD_customFree(serialState->ldmState.hashTable, cMem);
+            serialState->ldmState.hashTable = (ldmEntry_t*)ZSTD_customMalloc(hashSize, cMem);
+        }
+        if (serialState->ldmState.bucketOffsets == NULL || prevBucketLog < bucketLog) {
+            ZSTD_customFree(serialState->ldmState.bucketOffsets, cMem);
+            serialState->ldmState.bucketOffsets = (BYTE*)ZSTD_customMalloc(numBuckets, cMem);
+        }
+        if (!serialState->ldmState.hashTable || !serialState->ldmState.bucketOffsets)
+            return 1;
+        /* Zero the tables */
+        ZSTD_memset(serialState->ldmState.hashTable, 0, hashSize);
+        ZSTD_memset(serialState->ldmState.bucketOffsets, 0, numBuckets);
+
+        /* Update window state and fill hash table with dict */
+        serialState->ldmState.loadedDictEnd = 0;
+        if (dictSize > 0) {
+            if (dictContentType == ZSTD_dct_rawContent) {
+                BYTE const* const dictEnd = (const BYTE*)dict + dictSize;
+                ZSTD_window_update(&serialState->ldmState.window, dict, dictSize, /* forceNonContiguous */ 0);
+                ZSTD_ldm_fillHashTable(&serialState->ldmState, (const BYTE*)dict, dictEnd, &params.ldmParams);
+                serialState->ldmState.loadedDictEnd = params.forceWindow ? 0 : (U32)(dictEnd - serialState->ldmState.window.base);
+            } else {
+                /* don't even load anything */
+            }
+        }
+
+        /* Initialize serialState's copy of ldmWindow. */
+        serialState->ldmWindow = serialState->ldmState.window;
+    }
+
+    serialState->params = params;
+    serialState->params.jobSize = (U32)jobSize;
+    return 0;
+}
+
+static int ZSTDMT_serialState_init(serialState_t* serialState)
+{
+    int initError = 0;
+    ZSTD_memset(serialState, 0, sizeof(*serialState));
+    initError |= ZSTD_pthread_mutex_init(&serialState->mutex, NULL);
+    initError |= ZSTD_pthread_cond_init(&serialState->cond, NULL);
+    initError |= ZSTD_pthread_mutex_init(&serialState->ldmWindowMutex, NULL);
+    initError |= ZSTD_pthread_cond_init(&serialState->ldmWindowCond, NULL);
+    return initError;
+}
+
+static void ZSTDMT_serialState_free(serialState_t* serialState)
+{
+    ZSTD_customMem cMem = serialState->params.customMem;
+    ZSTD_pthread_mutex_destroy(&serialState->mutex);
+    ZSTD_pthread_cond_destroy(&serialState->cond);
+    ZSTD_pthread_mutex_destroy(&serialState->ldmWindowMutex);
+    ZSTD_pthread_cond_destroy(&serialState->ldmWindowCond);
+    ZSTD_customFree(serialState->ldmState.hashTable, cMem);
+    ZSTD_customFree(serialState->ldmState.bucketOffsets, cMem);
+}
+
+static void ZSTDMT_serialState_update(serialState_t* serialState,
+                                      ZSTD_CCtx* jobCCtx, rawSeqStore_t seqStore,
+                                      range_t src, unsigned jobID)
+{
+    /* Wait for our turn */
+    ZSTD_PTHREAD_MUTEX_LOCK(&serialState->mutex);
+    while (serialState->nextJobID < jobID) {
+        DEBUGLOG(5, "wait for serialState->cond");
+        ZSTD_pthread_cond_wait(&serialState->cond, &serialState->mutex);
+    }
+    /* A future job may error and skip our job */
+    if (serialState->nextJobID == jobID) {
+        /* It is now our turn, do any processing necessary */
+        if (serialState->params.ldmParams.enableLdm == ZSTD_ps_enable) {
+            size_t error;
+            assert(seqStore.seq != NULL && seqStore.pos == 0 &&
+                   seqStore.size == 0 && seqStore.capacity > 0);
+            assert(src.size <= serialState->params.jobSize);
+            ZSTD_window_update(&serialState->ldmState.window, src.start, src.size, /* forceNonContiguous */ 0);
+            error = ZSTD_ldm_generateSequences(
+                &serialState->ldmState, &seqStore,
+                &serialState->params.ldmParams, src.start, src.size);
+            /* We provide a large enough buffer to never fail. */
+            assert(!ZSTD_isError(error)); (void)error;
+            /* Update ldmWindow to match the ldmState.window and signal the main
+             * thread if it is waiting for a buffer.
+             */
+            ZSTD_PTHREAD_MUTEX_LOCK(&serialState->ldmWindowMutex);
+            serialState->ldmWindow = serialState->ldmState.window;
+            ZSTD_pthread_cond_signal(&serialState->ldmWindowCond);
+            ZSTD_pthread_mutex_unlock(&serialState->ldmWindowMutex);
+        }
+        if (serialState->params.fParams.checksumFlag && src.size > 0)
+            XXH64_update(&serialState->xxhState, src.start, src.size);
+    }
+    /* Now it is the next jobs turn */
+    serialState->nextJobID++;
+    ZSTD_pthread_cond_broadcast(&serialState->cond);
+    ZSTD_pthread_mutex_unlock(&serialState->mutex);
+
+    if (seqStore.size > 0) {
+        size_t const err = ZSTD_referenceExternalSequences(
+            jobCCtx, seqStore.seq, seqStore.size);
+        assert(serialState->params.ldmParams.enableLdm == ZSTD_ps_enable);
+        assert(!ZSTD_isError(err));
+        (void)err;
+    }
+}
+
+static void ZSTDMT_serialState_ensureFinished(serialState_t* serialState,
+                                              unsigned jobID, size_t cSize)
+{
+    ZSTD_PTHREAD_MUTEX_LOCK(&serialState->mutex);
+    if (serialState->nextJobID <= jobID) {
+        assert(ZSTD_isError(cSize)); (void)cSize;
+        DEBUGLOG(5, "Skipping past job %u because of error", jobID);
+        serialState->nextJobID = jobID + 1;
+        ZSTD_pthread_cond_broadcast(&serialState->cond);
+
+        ZSTD_PTHREAD_MUTEX_LOCK(&serialState->ldmWindowMutex);
+        ZSTD_window_clear(&serialState->ldmWindow);
+        ZSTD_pthread_cond_signal(&serialState->ldmWindowCond);
+        ZSTD_pthread_mutex_unlock(&serialState->ldmWindowMutex);
+    }
+    ZSTD_pthread_mutex_unlock(&serialState->mutex);
+
+}
+
+
+/* ------------------------------------------ */
+/* =====          Worker thread         ===== */
+/* ------------------------------------------ */
+
+static const range_t kNullRange = { NULL, 0 };
+
+typedef struct {
+    size_t   consumed;                   /* SHARED - set0 by mtctx, then modified by worker AND read by mtctx */
+    size_t   cSize;                      /* SHARED - set0 by mtctx, then modified by worker AND read by mtctx, then set0 by mtctx */
+    ZSTD_pthread_mutex_t job_mutex;      /* Thread-safe - used by mtctx and worker */
+    ZSTD_pthread_cond_t job_cond;        /* Thread-safe - used by mtctx and worker */
+    ZSTDMT_CCtxPool* cctxPool;           /* Thread-safe - used by mtctx and (all) workers */
+    ZSTDMT_bufferPool* bufPool;          /* Thread-safe - used by mtctx and (all) workers */
+    ZSTDMT_seqPool* seqPool;             /* Thread-safe - used by mtctx and (all) workers */
+    serialState_t* serial;               /* Thread-safe - used by mtctx and (all) workers */
+    buffer_t dstBuff;                    /* set by worker (or mtctx), then read by worker & mtctx, then modified by mtctx => no barrier */
+    range_t prefix;                      /* set by mtctx, then read by worker & mtctx => no barrier */
+    range_t src;                         /* set by mtctx, then read by worker & mtctx => no barrier */
+    unsigned jobID;                      /* set by mtctx, then read by worker => no barrier */
+    unsigned firstJob;                   /* set by mtctx, then read by worker => no barrier */
+    unsigned lastJob;                    /* set by mtctx, then read by worker => no barrier */
+    ZSTD_CCtx_params params;             /* set by mtctx, then read by worker => no barrier */
+    const ZSTD_CDict* cdict;             /* set by mtctx, then read by worker => no barrier */
+    unsigned long long fullFrameSize;    /* set by mtctx, then read by worker => no barrier */
+    size_t   dstFlushed;                 /* used only by mtctx */
+    unsigned frameChecksumNeeded;        /* used only by mtctx */
+} ZSTDMT_jobDescription;
+
+#define JOB_ERROR(e) {                          \
+    ZSTD_PTHREAD_MUTEX_LOCK(&job->job_mutex);   \
+    job->cSize = e;                             \
+    ZSTD_pthread_mutex_unlock(&job->job_mutex); \
+    goto _endJob;                               \
+}
+
+/* ZSTDMT_compressionJob() is a POOL_function type */
+static void ZSTDMT_compressionJob(void* jobDescription)
+{
+    ZSTDMT_jobDescription* const job = (ZSTDMT_jobDescription*)jobDescription;
+    ZSTD_CCtx_params jobParams = job->params;   /* do not modify job->params ! copy it, modify the copy */
+    ZSTD_CCtx* const cctx = ZSTDMT_getCCtx(job->cctxPool);
+    rawSeqStore_t rawSeqStore = ZSTDMT_getSeq(job->seqPool);
+    buffer_t dstBuff = job->dstBuff;
+    size_t lastCBlockSize = 0;
+
+    /* resources */
+    if (cctx==NULL) JOB_ERROR(ERROR(memory_allocation));
+    if (dstBuff.start == NULL) {   /* streaming job : doesn't provide a dstBuffer */
+        dstBuff = ZSTDMT_getBuffer(job->bufPool);
+        if (dstBuff.start==NULL) JOB_ERROR(ERROR(memory_allocation));
+        job->dstBuff = dstBuff;   /* this value can be read in ZSTDMT_flush, when it copies the whole job */
+    }
+    if (jobParams.ldmParams.enableLdm == ZSTD_ps_enable && rawSeqStore.seq == NULL)
+        JOB_ERROR(ERROR(memory_allocation));
+
+    /* Don't compute the checksum for chunks, since we compute it externally,
+     * but write it in the header.
+     */
+    if (job->jobID != 0) jobParams.fParams.checksumFlag = 0;
+    /* Don't run LDM for the chunks, since we handle it externally */
+    jobParams.ldmParams.enableLdm = ZSTD_ps_disable;
+    /* Correct nbWorkers to 0. */
+    jobParams.nbWorkers = 0;
+
+
+    /* init */
+    if (job->cdict) {
+        size_t const initError = ZSTD_compressBegin_advanced_internal(cctx, NULL, 0, ZSTD_dct_auto, ZSTD_dtlm_fast, job->cdict, &jobParams, job->fullFrameSize);
+        assert(job->firstJob);  /* only allowed for first job */
+        if (ZSTD_isError(initError)) JOB_ERROR(initError);
+    } else {  /* srcStart points at reloaded section */
+        U64 const pledgedSrcSize = job->firstJob ? job->fullFrameSize : job->src.size;
+        {   size_t const forceWindowError = ZSTD_CCtxParams_setParameter(&jobParams, ZSTD_c_forceMaxWindow, !job->firstJob);
+            if (ZSTD_isError(forceWindowError)) JOB_ERROR(forceWindowError);
+        }
+        if (!job->firstJob) {
+            size_t const err = ZSTD_CCtxParams_setParameter(&jobParams, ZSTD_c_deterministicRefPrefix, 0);
+            if (ZSTD_isError(err)) JOB_ERROR(err);
+        }
+        {   size_t const initError = ZSTD_compressBegin_advanced_internal(cctx,
+                                        job->prefix.start, job->prefix.size, ZSTD_dct_rawContent, /* load dictionary in "content-only" mode (no header analysis) */
+                                        ZSTD_dtlm_fast,
+                                        NULL, /*cdict*/
+                                        &jobParams, pledgedSrcSize);
+            if (ZSTD_isError(initError)) JOB_ERROR(initError);
+    }   }
+
+    /* Perform serial step as early as possible, but after CCtx initialization */
+    ZSTDMT_serialState_update(job->serial, cctx, rawSeqStore, job->src, job->jobID);
+
+    if (!job->firstJob) {  /* flush and overwrite frame header when it's not first job */
+        size_t const hSize = ZSTD_compressContinue_public(cctx, dstBuff.start, dstBuff.capacity, job->src.start, 0);
+        if (ZSTD_isError(hSize)) JOB_ERROR(hSize);
+        DEBUGLOG(5, "ZSTDMT_compressionJob: flush and overwrite %u bytes of frame header (not first job)", (U32)hSize);
+        ZSTD_invalidateRepCodes(cctx);
+    }
+
+    /* compress */
+    {   size_t const chunkSize = 4*ZSTD_BLOCKSIZE_MAX;
+        int const nbChunks = (int)((job->src.size + (chunkSize-1)) / chunkSize);
+        const BYTE* ip = (const BYTE*) job->src.start;
+        BYTE* const ostart = (BYTE*)dstBuff.start;
+        BYTE* op = ostart;
+        BYTE* oend = op + dstBuff.capacity;
+        int chunkNb;
+        if (sizeof(size_t) > sizeof(int)) assert(job->src.size < ((size_t)INT_MAX) * chunkSize);   /* check overflow */
+        DEBUGLOG(5, "ZSTDMT_compressionJob: compress %u bytes in %i blocks", (U32)job->src.size, nbChunks);
+        assert(job->cSize == 0);
+        for (chunkNb = 1; chunkNb < nbChunks; chunkNb++) {
+            size_t const cSize = ZSTD_compressContinue_public(cctx, op, oend-op, ip, chunkSize);
+            if (ZSTD_isError(cSize)) JOB_ERROR(cSize);
+            ip += chunkSize;
+            op += cSize; assert(op < oend);
+            /* stats */
+            ZSTD_PTHREAD_MUTEX_LOCK(&job->job_mutex);
+            job->cSize += cSize;
+            job->consumed = chunkSize * chunkNb;
+            DEBUGLOG(5, "ZSTDMT_compressionJob: compress new block : cSize==%u bytes (total: %u)",
+                        (U32)cSize, (U32)job->cSize);
+            ZSTD_pthread_cond_signal(&job->job_cond);   /* warns some more data is ready to be flushed */
+            ZSTD_pthread_mutex_unlock(&job->job_mutex);
+        }
+        /* last block */
+        assert(chunkSize > 0);
+        assert((chunkSize & (chunkSize - 1)) == 0);  /* chunkSize must be power of 2 for mask==(chunkSize-1) to work */
+        if ((nbChunks > 0) | job->lastJob /*must output a "last block" flag*/ ) {
+            size_t const lastBlockSize1 = job->src.size & (chunkSize-1);
+            size_t const lastBlockSize = ((lastBlockSize1==0) & (job->src.size>=chunkSize)) ? chunkSize : lastBlockSize1;
+            size_t const cSize = (job->lastJob) ?
+                 ZSTD_compressEnd_public(cctx, op, oend-op, ip, lastBlockSize) :
+                 ZSTD_compressContinue_public(cctx, op, oend-op, ip, lastBlockSize);
+            if (ZSTD_isError(cSize)) JOB_ERROR(cSize);
+            lastCBlockSize = cSize;
+    }   }
+    if (!job->firstJob) {
+        /* Double check that we don't have an ext-dict, because then our
+         * repcode invalidation doesn't work.
+         */
+        assert(!ZSTD_window_hasExtDict(cctx->blockState.matchState.window));
+    }
+    ZSTD_CCtx_trace(cctx, 0);
+
+_endJob:
+    ZSTDMT_serialState_ensureFinished(job->serial, job->jobID, job->cSize);
+    if (job->prefix.size > 0)
+        DEBUGLOG(5, "Finished with prefix: %zx", (size_t)job->prefix.start);
+    DEBUGLOG(5, "Finished with source: %zx", (size_t)job->src.start);
+    /* release resources */
+    ZSTDMT_releaseSeq(job->seqPool, rawSeqStore);
+    ZSTDMT_releaseCCtx(job->cctxPool, cctx);
+    /* report */
+    ZSTD_PTHREAD_MUTEX_LOCK(&job->job_mutex);
+    if (ZSTD_isError(job->cSize)) assert(lastCBlockSize == 0);
+    job->cSize += lastCBlockSize;
+    job->consumed = job->src.size;  /* when job->consumed == job->src.size , compression job is presumed completed */
+    ZSTD_pthread_cond_signal(&job->job_cond);
+    ZSTD_pthread_mutex_unlock(&job->job_mutex);
+}
+
+
+/* ------------------------------------------ */
+/* =====   Multi-threaded compression   ===== */
+/* ------------------------------------------ */
+
+typedef struct {
+    range_t prefix;         /* read-only non-owned prefix buffer */
+    buffer_t buffer;
+    size_t filled;
+} inBuff_t;
+
+typedef struct {
+  BYTE* buffer;     /* The round input buffer. All jobs get references
+                     * to pieces of the buffer. ZSTDMT_tryGetInputRange()
+                     * handles handing out job input buffers, and makes
+                     * sure it doesn't overlap with any pieces still in use.
+                     */
+  size_t capacity;  /* The capacity of buffer. */
+  size_t pos;       /* The position of the current inBuff in the round
+                     * buffer. Updated past the end if the inBuff once
+                     * the inBuff is sent to the worker thread.
+                     * pos <= capacity.
+                     */
+} roundBuff_t;
+
+static const roundBuff_t kNullRoundBuff = {NULL, 0, 0};
+
+#define RSYNC_LENGTH 32
+/* Don't create chunks smaller than the zstd block size.
+ * This stops us from regressing compression ratio too much,
+ * and ensures our output fits in ZSTD_compressBound().
+ *
+ * If this is shrunk < ZSTD_BLOCKSIZELOG_MIN then
+ * ZSTD_COMPRESSBOUND() will need to be updated.
+ */
+#define RSYNC_MIN_BLOCK_LOG ZSTD_BLOCKSIZELOG_MAX
+#define RSYNC_MIN_BLOCK_SIZE (1<<RSYNC_MIN_BLOCK_LOG)
+
+typedef struct {
+  U64 hash;
+  U64 hitMask;
+  U64 primePower;
+} rsyncState_t;
+
+struct ZSTDMT_CCtx_s {
+    POOL_ctx* factory;
+    ZSTDMT_jobDescription* jobs;
+    ZSTDMT_bufferPool* bufPool;
+    ZSTDMT_CCtxPool* cctxPool;
+    ZSTDMT_seqPool* seqPool;
+    ZSTD_CCtx_params params;
+    size_t targetSectionSize;
+    size_t targetPrefixSize;
+    int jobReady;        /* 1 => one job is already prepared, but pool has shortage of workers. Don't create a new job. */
+    inBuff_t inBuff;
+    roundBuff_t roundBuff;
+    serialState_t serial;
+    rsyncState_t rsync;
+    unsigned jobIDMask;
+    unsigned doneJobID;
+    unsigned nextJobID;
+    unsigned frameEnded;
+    unsigned allJobsCompleted;
+    unsigned long long frameContentSize;
+    unsigned long long consumed;
+    unsigned long long produced;
+    ZSTD_customMem cMem;
+    ZSTD_CDict* cdictLocal;
+    const ZSTD_CDict* cdict;
+    unsigned providedFactory: 1;
+};
+
+static void ZSTDMT_freeJobsTable(ZSTDMT_jobDescription* jobTable, U32 nbJobs, ZSTD_customMem cMem)
+{
+    U32 jobNb;
+    if (jobTable == NULL) return;
+    for (jobNb=0; jobNb<nbJobs; jobNb++) {
+        ZSTD_pthread_mutex_destroy(&jobTable[jobNb].job_mutex);
+        ZSTD_pthread_cond_destroy(&jobTable[jobNb].job_cond);
+    }
+    ZSTD_customFree(jobTable, cMem);
+}
+
+/* ZSTDMT_allocJobsTable()
+ * allocate and init a job table.
+ * update *nbJobsPtr to next power of 2 value, as size of table */
+static ZSTDMT_jobDescription* ZSTDMT_createJobsTable(U32* nbJobsPtr, ZSTD_customMem cMem)
+{
+    U32 const nbJobsLog2 = ZSTD_highbit32(*nbJobsPtr) + 1;
+    U32 const nbJobs = 1 << nbJobsLog2;
+    U32 jobNb;
+    ZSTDMT_jobDescription* const jobTable = (ZSTDMT_jobDescription*)
+                ZSTD_customCalloc(nbJobs * sizeof(ZSTDMT_jobDescription), cMem);
+    int initError = 0;
+    if (jobTable==NULL) return NULL;
+    *nbJobsPtr = nbJobs;
+    for (jobNb=0; jobNb<nbJobs; jobNb++) {
+        initError |= ZSTD_pthread_mutex_init(&jobTable[jobNb].job_mutex, NULL);
+        initError |= ZSTD_pthread_cond_init(&jobTable[jobNb].job_cond, NULL);
+    }
+    if (initError != 0) {
+        ZSTDMT_freeJobsTable(jobTable, nbJobs, cMem);
+        return NULL;
+    }
+    return jobTable;
+}
+
+static size_t ZSTDMT_expandJobsTable (ZSTDMT_CCtx* mtctx, U32 nbWorkers) {
+    U32 nbJobs = nbWorkers + 2;
+    if (nbJobs > mtctx->jobIDMask+1) {  /* need more job capacity */
+        ZSTDMT_freeJobsTable(mtctx->jobs, mtctx->jobIDMask+1, mtctx->cMem);
+        mtctx->jobIDMask = 0;
+        mtctx->jobs = ZSTDMT_createJobsTable(&nbJobs, mtctx->cMem);
+        if (mtctx->jobs==NULL) return ERROR(memory_allocation);
+        assert((nbJobs != 0) && ((nbJobs & (nbJobs - 1)) == 0));  /* ensure nbJobs is a power of 2 */
+        mtctx->jobIDMask = nbJobs - 1;
+    }
+    return 0;
+}
+
+
+/* ZSTDMT_CCtxParam_setNbWorkers():
+ * Internal use only */
+static size_t ZSTDMT_CCtxParam_setNbWorkers(ZSTD_CCtx_params* params, unsigned nbWorkers)
+{
+    return ZSTD_CCtxParams_setParameter(params, ZSTD_c_nbWorkers, (int)nbWorkers);
+}
+
+MEM_STATIC ZSTDMT_CCtx* ZSTDMT_createCCtx_advanced_internal(unsigned nbWorkers, ZSTD_customMem cMem, ZSTD_threadPool* pool)
+{
+    ZSTDMT_CCtx* mtctx;
+    U32 nbJobs = nbWorkers + 2;
+    int initError;
+    DEBUGLOG(3, "ZSTDMT_createCCtx_advanced (nbWorkers = %u)", nbWorkers);
+
+    if (nbWorkers < 1) return NULL;
+    nbWorkers = MIN(nbWorkers , ZSTDMT_NBWORKERS_MAX);
+    if ((cMem.customAlloc!=NULL) ^ (cMem.customFree!=NULL))
+        /* invalid custom allocator */
+        return NULL;
+
+    mtctx = (ZSTDMT_CCtx*) ZSTD_customCalloc(sizeof(ZSTDMT_CCtx), cMem);
+    if (!mtctx) return NULL;
+    ZSTDMT_CCtxParam_setNbWorkers(&mtctx->params, nbWorkers);
+    mtctx->cMem = cMem;
+    mtctx->allJobsCompleted = 1;
+    if (pool != NULL) {
+      mtctx->factory = pool;
+      mtctx->providedFactory = 1;
+    }
+    else {
+      mtctx->factory = POOL_create_advanced(nbWorkers, 0, cMem);
+      mtctx->providedFactory = 0;
+    }
+    mtctx->jobs = ZSTDMT_createJobsTable(&nbJobs, cMem);
+    assert(nbJobs > 0); assert((nbJobs & (nbJobs - 1)) == 0);  /* ensure nbJobs is a power of 2 */
+    mtctx->jobIDMask = nbJobs - 1;
+    mtctx->bufPool = ZSTDMT_createBufferPool(BUF_POOL_MAX_NB_BUFFERS(nbWorkers), cMem);
+    mtctx->cctxPool = ZSTDMT_createCCtxPool(nbWorkers, cMem);
+    mtctx->seqPool = ZSTDMT_createSeqPool(nbWorkers, cMem);
+    initError = ZSTDMT_serialState_init(&mtctx->serial);
+    mtctx->roundBuff = kNullRoundBuff;
+    if (!mtctx->factory | !mtctx->jobs | !mtctx->bufPool | !mtctx->cctxPool | !mtctx->seqPool | initError) {
+        ZSTDMT_freeCCtx(mtctx);
+        return NULL;
+    }
+    DEBUGLOG(3, "mt_cctx created, for %u threads", nbWorkers);
+    return mtctx;
+}
+
+ZSTDMT_CCtx* ZSTDMT_createCCtx_advanced(unsigned nbWorkers, ZSTD_customMem cMem, ZSTD_threadPool* pool)
+{
+#ifdef ZSTD_MULTITHREAD
+    return ZSTDMT_createCCtx_advanced_internal(nbWorkers, cMem, pool);
+#else
+    (void)nbWorkers;
+    (void)cMem;
+    (void)pool;
+    return NULL;
+#endif
+}
+
+
+/* ZSTDMT_releaseAllJobResources() :
+ * note : ensure all workers are killed first ! */
+static void ZSTDMT_releaseAllJobResources(ZSTDMT_CCtx* mtctx)
+{
+    unsigned jobID;
+    DEBUGLOG(3, "ZSTDMT_releaseAllJobResources");
+    for (jobID=0; jobID <= mtctx->jobIDMask; jobID++) {
+        /* Copy the mutex/cond out */
+        ZSTD_pthread_mutex_t const mutex = mtctx->jobs[jobID].job_mutex;
+        ZSTD_pthread_cond_t const cond = mtctx->jobs[jobID].job_cond;
+
+        DEBUGLOG(4, "job%02u: release dst address %08X", jobID, (U32)(size_t)mtctx->jobs[jobID].dstBuff.start);
+        ZSTDMT_releaseBuffer(mtctx->bufPool, mtctx->jobs[jobID].dstBuff);
+
+        /* Clear the job description, but keep the mutex/cond */
+        ZSTD_memset(&mtctx->jobs[jobID], 0, sizeof(mtctx->jobs[jobID]));
+        mtctx->jobs[jobID].job_mutex = mutex;
+        mtctx->jobs[jobID].job_cond = cond;
+    }
+    mtctx->inBuff.buffer = g_nullBuffer;
+    mtctx->inBuff.filled = 0;
+    mtctx->allJobsCompleted = 1;
+}
+
+static void ZSTDMT_waitForAllJobsCompleted(ZSTDMT_CCtx* mtctx)
+{
+    DEBUGLOG(4, "ZSTDMT_waitForAllJobsCompleted");
+    while (mtctx->doneJobID < mtctx->nextJobID) {
+        unsigned const jobID = mtctx->doneJobID & mtctx->jobIDMask;
+        ZSTD_PTHREAD_MUTEX_LOCK(&mtctx->jobs[jobID].job_mutex);
+        while (mtctx->jobs[jobID].consumed < mtctx->jobs[jobID].src.size) {
+            DEBUGLOG(4, "waiting for jobCompleted signal from job %u", mtctx->doneJobID);   /* we want to block when waiting for data to flush */
+            ZSTD_pthread_cond_wait(&mtctx->jobs[jobID].job_cond, &mtctx->jobs[jobID].job_mutex);
+        }
+        ZSTD_pthread_mutex_unlock(&mtctx->jobs[jobID].job_mutex);
+        mtctx->doneJobID++;
+    }
+}
+
+size_t ZSTDMT_freeCCtx(ZSTDMT_CCtx* mtctx)
+{
+    if (mtctx==NULL) return 0;   /* compatible with free on NULL */
+    if (!mtctx->providedFactory)
+        POOL_free(mtctx->factory);   /* stop and free worker threads */
+    ZSTDMT_releaseAllJobResources(mtctx);  /* release job resources into pools first */
+    ZSTDMT_freeJobsTable(mtctx->jobs, mtctx->jobIDMask+1, mtctx->cMem);
+    ZSTDMT_freeBufferPool(mtctx->bufPool);
+    ZSTDMT_freeCCtxPool(mtctx->cctxPool);
+    ZSTDMT_freeSeqPool(mtctx->seqPool);
+    ZSTDMT_serialState_free(&mtctx->serial);
+    ZSTD_freeCDict(mtctx->cdictLocal);
+    if (mtctx->roundBuff.buffer)
+        ZSTD_customFree(mtctx->roundBuff.buffer, mtctx->cMem);
+    ZSTD_customFree(mtctx, mtctx->cMem);
+    return 0;
+}
+
+size_t ZSTDMT_sizeof_CCtx(ZSTDMT_CCtx* mtctx)
+{
+    if (mtctx == NULL) return 0;   /* supports sizeof NULL */
+    return sizeof(*mtctx)
+            + POOL_sizeof(mtctx->factory)
+            + ZSTDMT_sizeof_bufferPool(mtctx->bufPool)
+            + (mtctx->jobIDMask+1) * sizeof(ZSTDMT_jobDescription)
+            + ZSTDMT_sizeof_CCtxPool(mtctx->cctxPool)
+            + ZSTDMT_sizeof_seqPool(mtctx->seqPool)
+            + ZSTD_sizeof_CDict(mtctx->cdictLocal)
+            + mtctx->roundBuff.capacity;
+}
+
+
+/* ZSTDMT_resize() :
+ * @return : error code if fails, 0 on success */
+static size_t ZSTDMT_resize(ZSTDMT_CCtx* mtctx, unsigned nbWorkers)
+{
+    if (POOL_resize(mtctx->factory, nbWorkers)) return ERROR(memory_allocation);
+    FORWARD_IF_ERROR( ZSTDMT_expandJobsTable(mtctx, nbWorkers) , "");
+    mtctx->bufPool = ZSTDMT_expandBufferPool(mtctx->bufPool, BUF_POOL_MAX_NB_BUFFERS(nbWorkers));
+    if (mtctx->bufPool == NULL) return ERROR(memory_allocation);
+    mtctx->cctxPool = ZSTDMT_expandCCtxPool(mtctx->cctxPool, nbWorkers);
+    if (mtctx->cctxPool == NULL) return ERROR(memory_allocation);
+    mtctx->seqPool = ZSTDMT_expandSeqPool(mtctx->seqPool, nbWorkers);
+    if (mtctx->seqPool == NULL) return ERROR(memory_allocation);
+    ZSTDMT_CCtxParam_setNbWorkers(&mtctx->params, nbWorkers);
+    return 0;
+}
+
+
+/*! ZSTDMT_updateCParams_whileCompressing() :
+ *  Updates a selected set of compression parameters, remaining compatible with currently active frame.
+ *  New parameters will be applied to next compression job. */
+void ZSTDMT_updateCParams_whileCompressing(ZSTDMT_CCtx* mtctx, const ZSTD_CCtx_params* cctxParams)
+{
+    U32 const saved_wlog = mtctx->params.cParams.windowLog;   /* Do not modify windowLog while compressing */
+    int const compressionLevel = cctxParams->compressionLevel;
+    DEBUGLOG(5, "ZSTDMT_updateCParams_whileCompressing (level:%i)",
+                compressionLevel);
+    mtctx->params.compressionLevel = compressionLevel;
+    {   ZSTD_compressionParameters cParams = ZSTD_getCParamsFromCCtxParams(cctxParams, ZSTD_CONTENTSIZE_UNKNOWN, 0, ZSTD_cpm_noAttachDict);
+        cParams.windowLog = saved_wlog;
+        mtctx->params.cParams = cParams;
+    }
+}
+
+/* ZSTDMT_getFrameProgression():
+ * tells how much data has been consumed (input) and produced (output) for current frame.
+ * able to count progression inside worker threads.
+ * Note : mutex will be acquired during statistics collection inside workers. */
+ZSTD_frameProgression ZSTDMT_getFrameProgression(ZSTDMT_CCtx* mtctx)
+{
+    ZSTD_frameProgression fps;
+    DEBUGLOG(5, "ZSTDMT_getFrameProgression");
+    fps.ingested = mtctx->consumed + mtctx->inBuff.filled;
+    fps.consumed = mtctx->consumed;
+    fps.produced = fps.flushed = mtctx->produced;
+    fps.currentJobID = mtctx->nextJobID;
+    fps.nbActiveWorkers = 0;
+    {   unsigned jobNb;
+        unsigned lastJobNb = mtctx->nextJobID + mtctx->jobReady; assert(mtctx->jobReady <= 1);
+        DEBUGLOG(6, "ZSTDMT_getFrameProgression: jobs: from %u to <%u (jobReady:%u)",
+                    mtctx->doneJobID, lastJobNb, mtctx->jobReady)
+        for (jobNb = mtctx->doneJobID ; jobNb < lastJobNb ; jobNb++) {
+            unsigned const wJobID = jobNb & mtctx->jobIDMask;
+            ZSTDMT_jobDescription* jobPtr = &mtctx->jobs[wJobID];
+            ZSTD_pthread_mutex_lock(&jobPtr->job_mutex);
+            {   size_t const cResult = jobPtr->cSize;
+                size_t const produced = ZSTD_isError(cResult) ? 0 : cResult;
+                size_t const flushed = ZSTD_isError(cResult) ? 0 : jobPtr->dstFlushed;
+                assert(flushed <= produced);
+                fps.ingested += jobPtr->src.size;
+                fps.consumed += jobPtr->consumed;
+                fps.produced += produced;
+                fps.flushed  += flushed;
+                fps.nbActiveWorkers += (jobPtr->consumed < jobPtr->src.size);
+            }
+            ZSTD_pthread_mutex_unlock(&mtctx->jobs[wJobID].job_mutex);
+        }
+    }
+    return fps;
+}
+
+
+size_t ZSTDMT_toFlushNow(ZSTDMT_CCtx* mtctx)
+{
+    size_t toFlush;
+    unsigned const jobID = mtctx->doneJobID;
+    assert(jobID <= mtctx->nextJobID);
+    if (jobID == mtctx->nextJobID) return 0;   /* no active job => nothing to flush */
+
+    /* look into oldest non-fully-flushed job */
+    {   unsigned const wJobID = jobID & mtctx->jobIDMask;
+        ZSTDMT_jobDescription* const jobPtr = &mtctx->jobs[wJobID];
+        ZSTD_pthread_mutex_lock(&jobPtr->job_mutex);
+        {   size_t const cResult = jobPtr->cSize;
+            size_t const produced = ZSTD_isError(cResult) ? 0 : cResult;
+            size_t const flushed = ZSTD_isError(cResult) ? 0 : jobPtr->dstFlushed;
+            assert(flushed <= produced);
+            assert(jobPtr->consumed <= jobPtr->src.size);
+            toFlush = produced - flushed;
+            /* if toFlush==0, nothing is available to flush.
+             * However, jobID is expected to still be active:
+             * if jobID was already completed and fully flushed,
+             * ZSTDMT_flushProduced() should have already moved onto next job.
+             * Therefore, some input has not yet been consumed. */
+            if (toFlush==0) {
+                assert(jobPtr->consumed < jobPtr->src.size);
+            }
+        }
+        ZSTD_pthread_mutex_unlock(&mtctx->jobs[wJobID].job_mutex);
+    }
+
+    return toFlush;
+}
+
+
+/* ------------------------------------------ */
+/* =====   Multi-threaded compression   ===== */
+/* ------------------------------------------ */
+
+static unsigned ZSTDMT_computeTargetJobLog(const ZSTD_CCtx_params* params)
+{
+    unsigned jobLog;
+    if (params->ldmParams.enableLdm == ZSTD_ps_enable) {
+        /* In Long Range Mode, the windowLog is typically oversized.
+         * In which case, it's preferable to determine the jobSize
+         * based on cycleLog instead. */
+        jobLog = MAX(21, ZSTD_cycleLog(params->cParams.chainLog, params->cParams.strategy) + 3);
+    } else {
+        jobLog = MAX(20, params->cParams.windowLog + 2);
+    }
+    return MIN(jobLog, (unsigned)ZSTDMT_JOBLOG_MAX);
+}
+
+static int ZSTDMT_overlapLog_default(ZSTD_strategy strat)
+{
+    switch(strat)
+    {
+        case ZSTD_btultra2:
+            return 9;
+        case ZSTD_btultra:
+        case ZSTD_btopt:
+            return 8;
+        case ZSTD_btlazy2:
+        case ZSTD_lazy2:
+            return 7;
+        case ZSTD_lazy:
+        case ZSTD_greedy:
+        case ZSTD_dfast:
+        case ZSTD_fast:
+        default:;
+    }
+    return 6;
+}
+
+static int ZSTDMT_overlapLog(int ovlog, ZSTD_strategy strat)
+{
+    assert(0 <= ovlog && ovlog <= 9);
+    if (ovlog == 0) return ZSTDMT_overlapLog_default(strat);
+    return ovlog;
+}
+
+static size_t ZSTDMT_computeOverlapSize(const ZSTD_CCtx_params* params)
+{
+    int const overlapRLog = 9 - ZSTDMT_overlapLog(params->overlapLog, params->cParams.strategy);
+    int ovLog = (overlapRLog >= 8) ? 0 : (params->cParams.windowLog - overlapRLog);
+    assert(0 <= overlapRLog && overlapRLog <= 8);
+    if (params->ldmParams.enableLdm == ZSTD_ps_enable) {
+        /* In Long Range Mode, the windowLog is typically oversized.
+         * In which case, it's preferable to determine the jobSize
+         * based on chainLog instead.
+         * Then, ovLog becomes a fraction of the jobSize, rather than windowSize */
+        ovLog = MIN(params->cParams.windowLog, ZSTDMT_computeTargetJobLog(params) - 2)
+                - overlapRLog;
+    }
+    assert(0 <= ovLog && ovLog <= ZSTD_WINDOWLOG_MAX);
+    DEBUGLOG(4, "overlapLog : %i", params->overlapLog);
+    DEBUGLOG(4, "overlap size : %i", 1 << ovLog);
+    return (ovLog==0) ? 0 : (size_t)1 << ovLog;
+}
+
+/* ====================================== */
+/* =======      Streaming API     ======= */
+/* ====================================== */
+
+size_t ZSTDMT_initCStream_internal(
+        ZSTDMT_CCtx* mtctx,
+        const void* dict, size_t dictSize, ZSTD_dictContentType_e dictContentType,
+        const ZSTD_CDict* cdict, ZSTD_CCtx_params params,
+        unsigned long long pledgedSrcSize)
+{
+    DEBUGLOG(4, "ZSTDMT_initCStream_internal (pledgedSrcSize=%u, nbWorkers=%u, cctxPool=%u)",
+                (U32)pledgedSrcSize, params.nbWorkers, mtctx->cctxPool->totalCCtx);
+
+    /* params supposed partially fully validated at this point */
+    assert(!ZSTD_isError(ZSTD_checkCParams(params.cParams)));
+    assert(!((dict) && (cdict)));  /* either dict or cdict, not both */
+
+    /* init */
+    if (params.nbWorkers != mtctx->params.nbWorkers)
+        FORWARD_IF_ERROR( ZSTDMT_resize(mtctx, params.nbWorkers) , "");
+
+    if (params.jobSize != 0 && params.jobSize < ZSTDMT_JOBSIZE_MIN) params.jobSize = ZSTDMT_JOBSIZE_MIN;
+    if (params.jobSize > (size_t)ZSTDMT_JOBSIZE_MAX) params.jobSize = (size_t)ZSTDMT_JOBSIZE_MAX;
+
+    DEBUGLOG(4, "ZSTDMT_initCStream_internal: %u workers", params.nbWorkers);
+
+    if (mtctx->allJobsCompleted == 0) {   /* previous compression not correctly finished */
+        ZSTDMT_waitForAllJobsCompleted(mtctx);
+        ZSTDMT_releaseAllJobResources(mtctx);
+        mtctx->allJobsCompleted = 1;
+    }
+
+    mtctx->params = params;
+    mtctx->frameContentSize = pledgedSrcSize;
+    if (dict) {
+        ZSTD_freeCDict(mtctx->cdictLocal);
+        mtctx->cdictLocal = ZSTD_createCDict_advanced(dict, dictSize,
+                                                    ZSTD_dlm_byCopy, dictContentType, /* note : a loadPrefix becomes an internal CDict */
+                                                    params.cParams, mtctx->cMem);
+        mtctx->cdict = mtctx->cdictLocal;
+        if (mtctx->cdictLocal == NULL) return ERROR(memory_allocation);
+    } else {
+        ZSTD_freeCDict(mtctx->cdictLocal);
+        mtctx->cdictLocal = NULL;
+        mtctx->cdict = cdict;
+    }
+
+    mtctx->targetPrefixSize = ZSTDMT_computeOverlapSize(&params);
+    DEBUGLOG(4, "overlapLog=%i => %u KB", params.overlapLog, (U32)(mtctx->targetPrefixSize>>10));
+    mtctx->targetSectionSize = params.jobSize;
+    if (mtctx->targetSectionSize == 0) {
+        mtctx->targetSectionSize = 1ULL << ZSTDMT_computeTargetJobLog(&params);
+    }
+    assert(mtctx->targetSectionSize <= (size_t)ZSTDMT_JOBSIZE_MAX);
+
+    if (params.rsyncable) {
+        /* Aim for the targetsectionSize as the average job size. */
+        U32 const jobSizeKB = (U32)(mtctx->targetSectionSize >> 10);
+        U32 const rsyncBits = (assert(jobSizeKB >= 1), ZSTD_highbit32(jobSizeKB) + 10);
+        /* We refuse to create jobs < RSYNC_MIN_BLOCK_SIZE bytes, so make sure our
+         * expected job size is at least 4x larger. */
+        assert(rsyncBits >= RSYNC_MIN_BLOCK_LOG + 2);
+        DEBUGLOG(4, "rsyncLog = %u", rsyncBits);
+        mtctx->rsync.hash = 0;
+        mtctx->rsync.hitMask = (1ULL << rsyncBits) - 1;
+        mtctx->rsync.primePower = ZSTD_rollingHash_primePower(RSYNC_LENGTH);
+    }
+    if (mtctx->targetSectionSize < mtctx->targetPrefixSize) mtctx->targetSectionSize = mtctx->targetPrefixSize;  /* job size must be >= overlap size */
+    DEBUGLOG(4, "Job Size : %u KB (note : set to %u)", (U32)(mtctx->targetSectionSize>>10), (U32)params.jobSize);
+    DEBUGLOG(4, "inBuff Size : %u KB", (U32)(mtctx->targetSectionSize>>10));
+    ZSTDMT_setBufferSize(mtctx->bufPool, ZSTD_compressBound(mtctx->targetSectionSize));
+    {
+        /* If ldm is enabled we need windowSize space. */
+        size_t const windowSize = mtctx->params.ldmParams.enableLdm == ZSTD_ps_enable ? (1U << mtctx->params.cParams.windowLog) : 0;
+        /* Two buffers of slack, plus extra space for the overlap
+         * This is the minimum slack that LDM works with. One extra because
+         * flush might waste up to targetSectionSize-1 bytes. Another extra
+         * for the overlap (if > 0), then one to fill which doesn't overlap
+         * with the LDM window.
+         */
+        size_t const nbSlackBuffers = 2 + (mtctx->targetPrefixSize > 0);
+        size_t const slackSize = mtctx->targetSectionSize * nbSlackBuffers;
+        /* Compute the total size, and always have enough slack */
+        size_t const nbWorkers = MAX(mtctx->params.nbWorkers, 1);
+        size_t const sectionsSize = mtctx->targetSectionSize * nbWorkers;
+        size_t const capacity = MAX(windowSize, sectionsSize) + slackSize;
+        if (mtctx->roundBuff.capacity < capacity) {
+            if (mtctx->roundBuff.buffer)
+                ZSTD_customFree(mtctx->roundBuff.buffer, mtctx->cMem);
+            mtctx->roundBuff.buffer = (BYTE*)ZSTD_customMalloc(capacity, mtctx->cMem);
+            if (mtctx->roundBuff.buffer == NULL) {
+                mtctx->roundBuff.capacity = 0;
+                return ERROR(memory_allocation);
+            }
+            mtctx->roundBuff.capacity = capacity;
+        }
+    }
+    DEBUGLOG(4, "roundBuff capacity : %u KB", (U32)(mtctx->roundBuff.capacity>>10));
+    mtctx->roundBuff.pos = 0;
+    mtctx->inBuff.buffer = g_nullBuffer;
+    mtctx->inBuff.filled = 0;
+    mtctx->inBuff.prefix = kNullRange;
+    mtctx->doneJobID = 0;
+    mtctx->nextJobID = 0;
+    mtctx->frameEnded = 0;
+    mtctx->allJobsCompleted = 0;
+    mtctx->consumed = 0;
+    mtctx->produced = 0;
+    if (ZSTDMT_serialState_reset(&mtctx->serial, mtctx->seqPool, params, mtctx->targetSectionSize,
+                                 dict, dictSize, dictContentType))
+        return ERROR(memory_allocation);
+    return 0;
+}
+
+
+/* ZSTDMT_writeLastEmptyBlock()
+ * Write a single empty block with an end-of-frame to finish a frame.
+ * Job must be created from streaming variant.
+ * This function is always successful if expected conditions are fulfilled.
+ */
+static void ZSTDMT_writeLastEmptyBlock(ZSTDMT_jobDescription* job)
+{
+    assert(job->lastJob == 1);
+    assert(job->src.size == 0);   /* last job is empty -> will be simplified into a last empty block */
+    assert(job->firstJob == 0);   /* cannot be first job, as it also needs to create frame header */
+    assert(job->dstBuff.start == NULL);   /* invoked from streaming variant only (otherwise, dstBuff might be user's output) */
+    job->dstBuff = ZSTDMT_getBuffer(job->bufPool);
+    if (job->dstBuff.start == NULL) {
+      job->cSize = ERROR(memory_allocation);
+      return;
+    }
+    assert(job->dstBuff.capacity >= ZSTD_blockHeaderSize);   /* no buffer should ever be that small */
+    job->src = kNullRange;
+    job->cSize = ZSTD_writeLastEmptyBlock(job->dstBuff.start, job->dstBuff.capacity);
+    assert(!ZSTD_isError(job->cSize));
+    assert(job->consumed == 0);
+}
+
+static size_t ZSTDMT_createCompressionJob(ZSTDMT_CCtx* mtctx, size_t srcSize, ZSTD_EndDirective endOp)
+{
+    unsigned const jobID = mtctx->nextJobID & mtctx->jobIDMask;
+    int const endFrame = (endOp == ZSTD_e_end);
+
+    if (mtctx->nextJobID > mtctx->doneJobID + mtctx->jobIDMask) {
+        DEBUGLOG(5, "ZSTDMT_createCompressionJob: will not create new job : table is full");
+        assert((mtctx->nextJobID & mtctx->jobIDMask) == (mtctx->doneJobID & mtctx->jobIDMask));
+        return 0;
+    }
+
+    if (!mtctx->jobReady) {
+        BYTE const* src = (BYTE const*)mtctx->inBuff.buffer.start;
+        DEBUGLOG(5, "ZSTDMT_createCompressionJob: preparing job %u to compress %u bytes with %u preload ",
+                    mtctx->nextJobID, (U32)srcSize, (U32)mtctx->inBuff.prefix.size);
+        mtctx->jobs[jobID].src.start = src;
+        mtctx->jobs[jobID].src.size = srcSize;
+        assert(mtctx->inBuff.filled >= srcSize);
+        mtctx->jobs[jobID].prefix = mtctx->inBuff.prefix;
+        mtctx->jobs[jobID].consumed = 0;
+        mtctx->jobs[jobID].cSize = 0;
+        mtctx->jobs[jobID].params = mtctx->params;
+        mtctx->jobs[jobID].cdict = mtctx->nextJobID==0 ? mtctx->cdict : NULL;
+        mtctx->jobs[jobID].fullFrameSize = mtctx->frameContentSize;
+        mtctx->jobs[jobID].dstBuff = g_nullBuffer;
+        mtctx->jobs[jobID].cctxPool = mtctx->cctxPool;
+        mtctx->jobs[jobID].bufPool = mtctx->bufPool;
+        mtctx->jobs[jobID].seqPool = mtctx->seqPool;
+        mtctx->jobs[jobID].serial = &mtctx->serial;
+        mtctx->jobs[jobID].jobID = mtctx->nextJobID;
+        mtctx->jobs[jobID].firstJob = (mtctx->nextJobID==0);
+        mtctx->jobs[jobID].lastJob = endFrame;
+        mtctx->jobs[jobID].frameChecksumNeeded = mtctx->params.fParams.checksumFlag && endFrame && (mtctx->nextJobID>0);
+        mtctx->jobs[jobID].dstFlushed = 0;
+
+        /* Update the round buffer pos and clear the input buffer to be reset */
+        mtctx->roundBuff.pos += srcSize;
+        mtctx->inBuff.buffer = g_nullBuffer;
+        mtctx->inBuff.filled = 0;
+        /* Set the prefix */
+        if (!endFrame) {
+            size_t const newPrefixSize = MIN(srcSize, mtctx->targetPrefixSize);
+            mtctx->inBuff.prefix.start = src + srcSize - newPrefixSize;
+            mtctx->inBuff.prefix.size = newPrefixSize;
+        } else {   /* endFrame==1 => no need for another input buffer */
+            mtctx->inBuff.prefix = kNullRange;
+            mtctx->frameEnded = endFrame;
+            if (mtctx->nextJobID == 0) {
+                /* single job exception : checksum is already calculated directly within worker thread */
+                mtctx->params.fParams.checksumFlag = 0;
+        }   }
+
+        if ( (srcSize == 0)
+          && (mtctx->nextJobID>0)/*single job must also write frame header*/ ) {
+            DEBUGLOG(5, "ZSTDMT_createCompressionJob: creating a last empty block to end frame");
+            assert(endOp == ZSTD_e_end);  /* only possible case : need to end the frame with an empty last block */
+            ZSTDMT_writeLastEmptyBlock(mtctx->jobs + jobID);
+            mtctx->nextJobID++;
+            return 0;
+        }
+    }
+
+    DEBUGLOG(5, "ZSTDMT_createCompressionJob: posting job %u : %u bytes  (end:%u, jobNb == %u (mod:%u))",
+                mtctx->nextJobID,
+                (U32)mtctx->jobs[jobID].src.size,
+                mtctx->jobs[jobID].lastJob,
+                mtctx->nextJobID,
+                jobID);
+    if (POOL_tryAdd(mtctx->factory, ZSTDMT_compressionJob, &mtctx->jobs[jobID])) {
+        mtctx->nextJobID++;
+        mtctx->jobReady = 0;
+    } else {
+        DEBUGLOG(5, "ZSTDMT_createCompressionJob: no worker available for job %u", mtctx->nextJobID);
+        mtctx->jobReady = 1;
+    }
+    return 0;
+}
+
+
+/*! ZSTDMT_flushProduced() :
+ *  flush whatever data has been produced but not yet flushed in current job.
+ *  move to next job if current one is fully flushed.
+ * `output` : `pos` will be updated with amount of data flushed .
+ * `blockToFlush` : if >0, the function will block and wait if there is no data available to flush .
+ * @return : amount of data remaining within internal buffer, 0 if no more, 1 if unknown but > 0, or an error code */
+static size_t ZSTDMT_flushProduced(ZSTDMT_CCtx* mtctx, ZSTD_outBuffer* output, unsigned blockToFlush, ZSTD_EndDirective end)
+{
+    unsigned const wJobID = mtctx->doneJobID & mtctx->jobIDMask;
+    DEBUGLOG(5, "ZSTDMT_flushProduced (blocking:%u , job %u <= %u)",
+                blockToFlush, mtctx->doneJobID, mtctx->nextJobID);
+    assert(output->size >= output->pos);
+
+    ZSTD_PTHREAD_MUTEX_LOCK(&mtctx->jobs[wJobID].job_mutex);
+    if (  blockToFlush
+      && (mtctx->doneJobID < mtctx->nextJobID) ) {
+        assert(mtctx->jobs[wJobID].dstFlushed <= mtctx->jobs[wJobID].cSize);
+        while (mtctx->jobs[wJobID].dstFlushed == mtctx->jobs[wJobID].cSize) {  /* nothing to flush */
+            if (mtctx->jobs[wJobID].consumed == mtctx->jobs[wJobID].src.size) {
+                DEBUGLOG(5, "job %u is completely consumed (%u == %u) => don't wait for cond, there will be none",
+                            mtctx->doneJobID, (U32)mtctx->jobs[wJobID].consumed, (U32)mtctx->jobs[wJobID].src.size);
+                break;
+            }
+            DEBUGLOG(5, "waiting for something to flush from job %u (currently flushed: %u bytes)",
+                        mtctx->doneJobID, (U32)mtctx->jobs[wJobID].dstFlushed);
+            ZSTD_pthread_cond_wait(&mtctx->jobs[wJobID].job_cond, &mtctx->jobs[wJobID].job_mutex);  /* block when nothing to flush but some to come */
+    }   }
+
+    /* try to flush something */
+    {   size_t cSize = mtctx->jobs[wJobID].cSize;                  /* shared */
+        size_t const srcConsumed = mtctx->jobs[wJobID].consumed;   /* shared */
+        size_t const srcSize = mtctx->jobs[wJobID].src.size;       /* read-only, could be done after mutex lock, but no-declaration-after-statement */
+        ZSTD_pthread_mutex_unlock(&mtctx->jobs[wJobID].job_mutex);
+        if (ZSTD_isError(cSize)) {
+            DEBUGLOG(5, "ZSTDMT_flushProduced: job %u : compression error detected : %s",
+                        mtctx->doneJobID, ZSTD_getErrorName(cSize));
+            ZSTDMT_waitForAllJobsCompleted(mtctx);
+            ZSTDMT_releaseAllJobResources(mtctx);
+            return cSize;
+        }
+        /* add frame checksum if necessary (can only happen once) */
+        assert(srcConsumed <= srcSize);
+        if ( (srcConsumed == srcSize)   /* job completed -> worker no longer active */
+          && mtctx->jobs[wJobID].frameChecksumNeeded ) {
+            U32 const checksum = (U32)XXH64_digest(&mtctx->serial.xxhState);
+            DEBUGLOG(4, "ZSTDMT_flushProduced: writing checksum : %08X \n", checksum);
+            MEM_writeLE32((char*)mtctx->jobs[wJobID].dstBuff.start + mtctx->jobs[wJobID].cSize, checksum);
+            cSize += 4;
+            mtctx->jobs[wJobID].cSize += 4;  /* can write this shared value, as worker is no longer active */
+            mtctx->jobs[wJobID].frameChecksumNeeded = 0;
+        }
+
+        if (cSize > 0) {   /* compression is ongoing or completed */
+            size_t const toFlush = MIN(cSize - mtctx->jobs[wJobID].dstFlushed, output->size - output->pos);
+            DEBUGLOG(5, "ZSTDMT_flushProduced: Flushing %u bytes from job %u (completion:%u/%u, generated:%u)",
+                        (U32)toFlush, mtctx->doneJobID, (U32)srcConsumed, (U32)srcSize, (U32)cSize);
+            assert(mtctx->doneJobID < mtctx->nextJobID);
+            assert(cSize >= mtctx->jobs[wJobID].dstFlushed);
+            assert(mtctx->jobs[wJobID].dstBuff.start != NULL);
+            if (toFlush > 0) {
+                ZSTD_memcpy((char*)output->dst + output->pos,
+                    (const char*)mtctx->jobs[wJobID].dstBuff.start + mtctx->jobs[wJobID].dstFlushed,
+                    toFlush);
+            }
+            output->pos += toFlush;
+            mtctx->jobs[wJobID].dstFlushed += toFlush;  /* can write : this value is only used by mtctx */
+
+            if ( (srcConsumed == srcSize)    /* job is completed */
+              && (mtctx->jobs[wJobID].dstFlushed == cSize) ) {   /* output buffer fully flushed => free this job position */
+                DEBUGLOG(5, "Job %u completed (%u bytes), moving to next one",
+                        mtctx->doneJobID, (U32)mtctx->jobs[wJobID].dstFlushed);
+                ZSTDMT_releaseBuffer(mtctx->bufPool, mtctx->jobs[wJobID].dstBuff);
+                DEBUGLOG(5, "dstBuffer released");
+                mtctx->jobs[wJobID].dstBuff = g_nullBuffer;
+                mtctx->jobs[wJobID].cSize = 0;   /* ensure this job slot is considered "not started" in future check */
+                mtctx->consumed += srcSize;
+                mtctx->produced += cSize;
+                mtctx->doneJobID++;
+        }   }
+
+        /* return value : how many bytes left in buffer ; fake it to 1 when unknown but >0 */
+        if (cSize > mtctx->jobs[wJobID].dstFlushed) return (cSize - mtctx->jobs[wJobID].dstFlushed);
+        if (srcSize > srcConsumed) return 1;   /* current job not completely compressed */
+    }
+    if (mtctx->doneJobID < mtctx->nextJobID) return 1;   /* some more jobs ongoing */
+    if (mtctx->jobReady) return 1;      /* one job is ready to push, just not yet in the list */
+    if (mtctx->inBuff.filled > 0) return 1;   /* input is not empty, and still needs to be converted into a job */
+    mtctx->allJobsCompleted = mtctx->frameEnded;   /* all jobs are entirely flushed => if this one is last one, frame is completed */
+    if (end == ZSTD_e_end) return !mtctx->frameEnded;  /* for ZSTD_e_end, question becomes : is frame completed ? instead of : are internal buffers fully flushed ? */
+    return 0;   /* internal buffers fully flushed */
+}
+
+/**
+ * Returns the range of data used by the earliest job that is not yet complete.
+ * If the data of the first job is broken up into two segments, we cover both
+ * sections.
+ */
+static range_t ZSTDMT_getInputDataInUse(ZSTDMT_CCtx* mtctx)
+{
+    unsigned const firstJobID = mtctx->doneJobID;
+    unsigned const lastJobID = mtctx->nextJobID;
+    unsigned jobID;
+
+    for (jobID = firstJobID; jobID < lastJobID; ++jobID) {
+        unsigned const wJobID = jobID & mtctx->jobIDMask;
+        size_t consumed;
+
+        ZSTD_PTHREAD_MUTEX_LOCK(&mtctx->jobs[wJobID].job_mutex);
+        consumed = mtctx->jobs[wJobID].consumed;
+        ZSTD_pthread_mutex_unlock(&mtctx->jobs[wJobID].job_mutex);
+
+        if (consumed < mtctx->jobs[wJobID].src.size) {
+            range_t range = mtctx->jobs[wJobID].prefix;
+            if (range.size == 0) {
+                /* Empty prefix */
+                range = mtctx->jobs[wJobID].src;
+            }
+            /* Job source in multiple segments not supported yet */
+            assert(range.start <= mtctx->jobs[wJobID].src.start);
+            return range;
+        }
+    }
+    return kNullRange;
+}
+
+/**
+ * Returns non-zero iff buffer and range overlap.
+ */
+static int ZSTDMT_isOverlapped(buffer_t buffer, range_t range)
+{
+    BYTE const* const bufferStart = (BYTE const*)buffer.start;
+    BYTE const* const rangeStart = (BYTE const*)range.start;
+
+    if (rangeStart == NULL || bufferStart == NULL)
+        return 0;
+
+    {
+        BYTE const* const bufferEnd = bufferStart + buffer.capacity;
+        BYTE const* const rangeEnd = rangeStart + range.size;
+
+        /* Empty ranges cannot overlap */
+        if (bufferStart == bufferEnd || rangeStart == rangeEnd)
+            return 0;
+
+        return bufferStart < rangeEnd && rangeStart < bufferEnd;
+    }
+}
+
+static int ZSTDMT_doesOverlapWindow(buffer_t buffer, ZSTD_window_t window)
+{
+    range_t extDict;
+    range_t prefix;
+
+    DEBUGLOG(5, "ZSTDMT_doesOverlapWindow");
+    extDict.start = window.dictBase + window.lowLimit;
+    extDict.size = window.dictLimit - window.lowLimit;
+
+    prefix.start = window.base + window.dictLimit;
+    prefix.size = window.nextSrc - (window.base + window.dictLimit);
+    DEBUGLOG(5, "extDict [0x%zx, 0x%zx)",
+                (size_t)extDict.start,
+                (size_t)extDict.start + extDict.size);
+    DEBUGLOG(5, "prefix  [0x%zx, 0x%zx)",
+                (size_t)prefix.start,
+                (size_t)prefix.start + prefix.size);
+
+    return ZSTDMT_isOverlapped(buffer, extDict)
+        || ZSTDMT_isOverlapped(buffer, prefix);
+}
+
+static void ZSTDMT_waitForLdmComplete(ZSTDMT_CCtx* mtctx, buffer_t buffer)
+{
+    if (mtctx->params.ldmParams.enableLdm == ZSTD_ps_enable) {
+        ZSTD_pthread_mutex_t* mutex = &mtctx->serial.ldmWindowMutex;
+        DEBUGLOG(5, "ZSTDMT_waitForLdmComplete");
+        DEBUGLOG(5, "source  [0x%zx, 0x%zx)",
+                    (size_t)buffer.start,
+                    (size_t)buffer.start + buffer.capacity);
+        ZSTD_PTHREAD_MUTEX_LOCK(mutex);
+        while (ZSTDMT_doesOverlapWindow(buffer, mtctx->serial.ldmWindow)) {
+            DEBUGLOG(5, "Waiting for LDM to finish...");
+            ZSTD_pthread_cond_wait(&mtctx->serial.ldmWindowCond, mutex);
+        }
+        DEBUGLOG(6, "Done waiting for LDM to finish");
+        ZSTD_pthread_mutex_unlock(mutex);
+    }
+}
+
+/**
+ * Attempts to set the inBuff to the next section to fill.
+ * If any part of the new section is still in use we give up.
+ * Returns non-zero if the buffer is filled.
+ */
+static int ZSTDMT_tryGetInputRange(ZSTDMT_CCtx* mtctx)
+{
+    range_t const inUse = ZSTDMT_getInputDataInUse(mtctx);
+    size_t const spaceLeft = mtctx->roundBuff.capacity - mtctx->roundBuff.pos;
+    size_t const target = mtctx->targetSectionSize;
+    buffer_t buffer;
+
+    DEBUGLOG(5, "ZSTDMT_tryGetInputRange");
+    assert(mtctx->inBuff.buffer.start == NULL);
+    assert(mtctx->roundBuff.capacity >= target);
+
+    if (spaceLeft < target) {
+        /* ZSTD_invalidateRepCodes() doesn't work for extDict variants.
+         * Simply copy the prefix to the beginning in that case.
+         */
+        BYTE* const start = (BYTE*)mtctx->roundBuff.buffer;
+        size_t const prefixSize = mtctx->inBuff.prefix.size;
+
+        buffer.start = start;
+        buffer.capacity = prefixSize;
+        if (ZSTDMT_isOverlapped(buffer, inUse)) {
+            DEBUGLOG(5, "Waiting for buffer...");
+            return 0;
+        }
+        ZSTDMT_waitForLdmComplete(mtctx, buffer);
+        ZSTD_memmove(start, mtctx->inBuff.prefix.start, prefixSize);
+        mtctx->inBuff.prefix.start = start;
+        mtctx->roundBuff.pos = prefixSize;
+    }
+    buffer.start = mtctx->roundBuff.buffer + mtctx->roundBuff.pos;
+    buffer.capacity = target;
+
+    if (ZSTDMT_isOverlapped(buffer, inUse)) {
+        DEBUGLOG(5, "Waiting for buffer...");
+        return 0;
+    }
+    assert(!ZSTDMT_isOverlapped(buffer, mtctx->inBuff.prefix));
+
+    ZSTDMT_waitForLdmComplete(mtctx, buffer);
+
+    DEBUGLOG(5, "Using prefix range [%zx, %zx)",
+                (size_t)mtctx->inBuff.prefix.start,
+                (size_t)mtctx->inBuff.prefix.start + mtctx->inBuff.prefix.size);
+    DEBUGLOG(5, "Using source range [%zx, %zx)",
+                (size_t)buffer.start,
+                (size_t)buffer.start + buffer.capacity);
+
+
+    mtctx->inBuff.buffer = buffer;
+    mtctx->inBuff.filled = 0;
+    assert(mtctx->roundBuff.pos + buffer.capacity <= mtctx->roundBuff.capacity);
+    return 1;
+}
+
+typedef struct {
+  size_t toLoad;  /* The number of bytes to load from the input. */
+  int flush;      /* Boolean declaring if we must flush because we found a synchronization point. */
+} syncPoint_t;
+
+/**
+ * Searches through the input for a synchronization point. If one is found, we
+ * will instruct the caller to flush, and return the number of bytes to load.
+ * Otherwise, we will load as many bytes as possible and instruct the caller
+ * to continue as normal.
+ */
+static syncPoint_t
+findSynchronizationPoint(ZSTDMT_CCtx const* mtctx, ZSTD_inBuffer const input)
+{
+    BYTE const* const istart = (BYTE const*)input.src + input.pos;
+    U64 const primePower = mtctx->rsync.primePower;
+    U64 const hitMask = mtctx->rsync.hitMask;
+
+    syncPoint_t syncPoint;
+    U64 hash;
+    BYTE const* prev;
+    size_t pos;
+
+    syncPoint.toLoad = MIN(input.size - input.pos, mtctx->targetSectionSize - mtctx->inBuff.filled);
+    syncPoint.flush = 0;
+    if (!mtctx->params.rsyncable)
+        /* Rsync is disabled. */
+        return syncPoint;
+    if (mtctx->inBuff.filled + input.size - input.pos < RSYNC_MIN_BLOCK_SIZE)
+        /* We don't emit synchronization points if it would produce too small blocks.
+         * We don't have enough input to find a synchronization point, so don't look.
+         */
+        return syncPoint;
+    if (mtctx->inBuff.filled + syncPoint.toLoad < RSYNC_LENGTH)
+        /* Not enough to compute the hash.
+         * We will miss any synchronization points in this RSYNC_LENGTH byte
+         * window. However, since it depends only in the internal buffers, if the
+         * state is already synchronized, we will remain synchronized.
+         * Additionally, the probability that we miss a synchronization point is
+         * low: RSYNC_LENGTH / targetSectionSize.
+         */
+        return syncPoint;
+    /* Initialize the loop variables. */
+    if (mtctx->inBuff.filled < RSYNC_MIN_BLOCK_SIZE) {
+        /* We don't need to scan the first RSYNC_MIN_BLOCK_SIZE positions
+         * because they can't possibly be a sync point. So we can start
+         * part way through the input buffer.
+         */
+        pos = RSYNC_MIN_BLOCK_SIZE - mtctx->inBuff.filled;
+        if (pos >= RSYNC_LENGTH) {
+            prev = istart + pos - RSYNC_LENGTH;
+            hash = ZSTD_rollingHash_compute(prev, RSYNC_LENGTH);
+        } else {
+            assert(mtctx->inBuff.filled >= RSYNC_LENGTH);
+            prev = (BYTE const*)mtctx->inBuff.buffer.start + mtctx->inBuff.filled - RSYNC_LENGTH;
+            hash = ZSTD_rollingHash_compute(prev + pos, (RSYNC_LENGTH - pos));
+            hash = ZSTD_rollingHash_append(hash, istart, pos);
+        }
+    } else {
+        /* We have enough bytes buffered to initialize the hash,
+         * and have processed enough bytes to find a sync point.
+         * Start scanning at the beginning of the input.
+         */
+        assert(mtctx->inBuff.filled >= RSYNC_MIN_BLOCK_SIZE);
+        assert(RSYNC_MIN_BLOCK_SIZE >= RSYNC_LENGTH);
+        pos = 0;
+        prev = (BYTE const*)mtctx->inBuff.buffer.start + mtctx->inBuff.filled - RSYNC_LENGTH;
+        hash = ZSTD_rollingHash_compute(prev, RSYNC_LENGTH);
+        if ((hash & hitMask) == hitMask) {
+            /* We're already at a sync point so don't load any more until
+             * we're able to flush this sync point.
+             * This likely happened because the job table was full so we
+             * couldn't add our job.
+             */
+            syncPoint.toLoad = 0;
+            syncPoint.flush = 1;
+            return syncPoint;
+        }
+    }
+    /* Starting with the hash of the previous RSYNC_LENGTH bytes, roll
+     * through the input. If we hit a synchronization point, then cut the
+     * job off, and tell the compressor to flush the job. Otherwise, load
+     * all the bytes and continue as normal.
+     * If we go too long without a synchronization point (targetSectionSize)
+     * then a block will be emitted anyways, but this is okay, since if we
+     * are already synchronized we will remain synchronized.
+     */
+    assert(pos < RSYNC_LENGTH || ZSTD_rollingHash_compute(istart + pos - RSYNC_LENGTH, RSYNC_LENGTH) == hash);
+    for (; pos < syncPoint.toLoad; ++pos) {
+        BYTE const toRemove = pos < RSYNC_LENGTH ? prev[pos] : istart[pos - RSYNC_LENGTH];
+        /* This assert is very expensive, and Debian compiles with asserts enabled.
+         * So disable it for now. We can get similar coverage by checking it at the
+         * beginning & end of the loop.
+         * assert(pos < RSYNC_LENGTH || ZSTD_rollingHash_compute(istart + pos - RSYNC_LENGTH, RSYNC_LENGTH) == hash);
+         */
+        hash = ZSTD_rollingHash_rotate(hash, toRemove, istart[pos], primePower);
+        assert(mtctx->inBuff.filled + pos >= RSYNC_MIN_BLOCK_SIZE);
+        if ((hash & hitMask) == hitMask) {
+            syncPoint.toLoad = pos + 1;
+            syncPoint.flush = 1;
+            ++pos; /* for assert */
+            break;
+        }
+    }
+    assert(pos < RSYNC_LENGTH || ZSTD_rollingHash_compute(istart + pos - RSYNC_LENGTH, RSYNC_LENGTH) == hash);
+    return syncPoint;
+}
+
+size_t ZSTDMT_nextInputSizeHint(const ZSTDMT_CCtx* mtctx)
+{
+    size_t hintInSize = mtctx->targetSectionSize - mtctx->inBuff.filled;
+    if (hintInSize==0) hintInSize = mtctx->targetSectionSize;
+    return hintInSize;
+}
+
+/** ZSTDMT_compressStream_generic() :
+ *  internal use only - exposed to be invoked from zstd_compress.c
+ *  assumption : output and input are valid (pos <= size)
+ * @return : minimum amount of data remaining to flush, 0 if none */
+size_t ZSTDMT_compressStream_generic(ZSTDMT_CCtx* mtctx,
+                                     ZSTD_outBuffer* output,
+                                     ZSTD_inBuffer* input,
+                                     ZSTD_EndDirective endOp)
+{
+    unsigned forwardInputProgress = 0;
+    DEBUGLOG(5, "ZSTDMT_compressStream_generic (endOp=%u, srcSize=%u)",
+                (U32)endOp, (U32)(input->size - input->pos));
+    assert(output->pos <= output->size);
+    assert(input->pos  <= input->size);
+
+    if ((mtctx->frameEnded) && (endOp==ZSTD_e_continue)) {
+        /* current frame being ended. Only flush/end are allowed */
+        return ERROR(stage_wrong);
+    }
+
+    /* fill input buffer */
+    if ( (!mtctx->jobReady)
+      && (input->size > input->pos) ) {   /* support NULL input */
+        if (mtctx->inBuff.buffer.start == NULL) {
+            assert(mtctx->inBuff.filled == 0); /* Can't fill an empty buffer */
+            if (!ZSTDMT_tryGetInputRange(mtctx)) {
+                /* It is only possible for this operation to fail if there are
+                 * still compression jobs ongoing.
+                 */
+                DEBUGLOG(5, "ZSTDMT_tryGetInputRange failed");
+                assert(mtctx->doneJobID != mtctx->nextJobID);
+            } else
+                DEBUGLOG(5, "ZSTDMT_tryGetInputRange completed successfully : mtctx->inBuff.buffer.start = %p", mtctx->inBuff.buffer.start);
+        }
+        if (mtctx->inBuff.buffer.start != NULL) {
+            syncPoint_t const syncPoint = findSynchronizationPoint(mtctx, *input);
+            if (syncPoint.flush && endOp == ZSTD_e_continue) {
+                endOp = ZSTD_e_flush;
+            }
+            assert(mtctx->inBuff.buffer.capacity >= mtctx->targetSectionSize);
+            DEBUGLOG(5, "ZSTDMT_compressStream_generic: adding %u bytes on top of %u to buffer of size %u",
+                        (U32)syncPoint.toLoad, (U32)mtctx->inBuff.filled, (U32)mtctx->targetSectionSize);
+            ZSTD_memcpy((char*)mtctx->inBuff.buffer.start + mtctx->inBuff.filled, (const char*)input->src + input->pos, syncPoint.toLoad);
+            input->pos += syncPoint.toLoad;
+            mtctx->inBuff.filled += syncPoint.toLoad;
+            forwardInputProgress = syncPoint.toLoad>0;
+        }
+    }
+    if ((input->pos < input->size) && (endOp == ZSTD_e_end)) {
+        /* Can't end yet because the input is not fully consumed.
+            * We are in one of these cases:
+            * - mtctx->inBuff is NULL & empty: we couldn't get an input buffer so don't create a new job.
+            * - We filled the input buffer: flush this job but don't end the frame.
+            * - We hit a synchronization point: flush this job but don't end the frame.
+            */
+        assert(mtctx->inBuff.filled == 0 || mtctx->inBuff.filled == mtctx->targetSectionSize || mtctx->params.rsyncable);
+        endOp = ZSTD_e_flush;
+    }
+
+    if ( (mtctx->jobReady)
+      || (mtctx->inBuff.filled >= mtctx->targetSectionSize)  /* filled enough : let's compress */
+      || ((endOp != ZSTD_e_continue) && (mtctx->inBuff.filled > 0))  /* something to flush : let's go */
+      || ((endOp == ZSTD_e_end) && (!mtctx->frameEnded)) ) {   /* must finish the frame with a zero-size block */
+        size_t const jobSize = mtctx->inBuff.filled;
+        assert(mtctx->inBuff.filled <= mtctx->targetSectionSize);
+        FORWARD_IF_ERROR( ZSTDMT_createCompressionJob(mtctx, jobSize, endOp) , "");
+    }
+
+    /* check for potential compressed data ready to be flushed */
+    {   size_t const remainingToFlush = ZSTDMT_flushProduced(mtctx, output, !forwardInputProgress, endOp); /* block if there was no forward input progress */
+        if (input->pos < input->size) return MAX(remainingToFlush, 1);  /* input not consumed : do not end flush yet */
+        DEBUGLOG(5, "end of ZSTDMT_compressStream_generic: remainingToFlush = %u", (U32)remainingToFlush);
+        return remainingToFlush;
+    }
+}
diff --git a/src/3rdparty/zstd/src/compress/zstdmt_compress.h b/src/3rdparty/zstd/src/compress/zstdmt_compress.h
new file mode 100644
index 0000000000..ed4dc0e99d
--- /dev/null
+++ b/src/3rdparty/zstd/src/compress/zstdmt_compress.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+ #ifndef ZSTDMT_COMPRESS_H
+ #define ZSTDMT_COMPRESS_H
+
+ #if defined (__cplusplus)
+ extern "C" {
+ #endif
+
+
+/* Note : This is an internal API.
+ *        These APIs used to be exposed with ZSTDLIB_API,
+ *        because it used to be the only way to invoke MT compression.
+ *        Now, you must use ZSTD_compress2 and ZSTD_compressStream2() instead.
+ *
+ *        This API requires ZSTD_MULTITHREAD to be defined during compilation,
+ *        otherwise ZSTDMT_createCCtx*() will fail.
+ */
+
+/* ===   Dependencies   === */
+#include "../common/zstd_deps.h"   /* size_t */
+#define ZSTD_STATIC_LINKING_ONLY   /* ZSTD_parameters */
+#include "../zstd.h"            /* ZSTD_inBuffer, ZSTD_outBuffer, ZSTDLIB_API */
+
+
+/* ===   Constants   === */
+#ifndef ZSTDMT_NBWORKERS_MAX /* a different value can be selected at compile time */
+#  define ZSTDMT_NBWORKERS_MAX ((sizeof(void*)==4) /*32-bit*/ ? 64 : 256)
+#endif
+#ifndef ZSTDMT_JOBSIZE_MIN   /* a different value can be selected at compile time */
+#  define ZSTDMT_JOBSIZE_MIN (512 KB)
+#endif
+#define ZSTDMT_JOBLOG_MAX   (MEM_32bits() ? 29 : 30)
+#define ZSTDMT_JOBSIZE_MAX  (MEM_32bits() ? (512 MB) : (1024 MB))
+
+
+/* ========================================================
+ * ===  Private interface, for use by ZSTD_compress.c   ===
+ * ===  Not exposed in libzstd. Never invoke directly   ===
+ * ======================================================== */
+
+/* ===   Memory management   === */
+typedef struct ZSTDMT_CCtx_s ZSTDMT_CCtx;
+/* Requires ZSTD_MULTITHREAD to be defined during compilation, otherwise it will return NULL. */
+ZSTDMT_CCtx* ZSTDMT_createCCtx_advanced(unsigned nbWorkers,
+                                        ZSTD_customMem cMem,
+					ZSTD_threadPool *pool);
+size_t ZSTDMT_freeCCtx(ZSTDMT_CCtx* mtctx);
+
+size_t ZSTDMT_sizeof_CCtx(ZSTDMT_CCtx* mtctx);
+
+/* ===   Streaming functions   === */
+
+size_t ZSTDMT_nextInputSizeHint(const ZSTDMT_CCtx* mtctx);
+
+/*! ZSTDMT_initCStream_internal() :
+ *  Private use only. Init streaming operation.
+ *  expects params to be valid.
+ *  must receive dict, or cdict, or none, but not both.
+ *  mtctx can be freshly constructed or reused from a prior compression.
+ *  If mtctx is reused, memory allocations from the prior compression may not be freed,
+ *  even if they are not needed for the current compression.
+ *  @return : 0, or an error code */
+size_t ZSTDMT_initCStream_internal(ZSTDMT_CCtx* mtctx,
+                    const void* dict, size_t dictSize, ZSTD_dictContentType_e dictContentType,
+                    const ZSTD_CDict* cdict,
+                    ZSTD_CCtx_params params, unsigned long long pledgedSrcSize);
+
+/*! ZSTDMT_compressStream_generic() :
+ *  Combines ZSTDMT_compressStream() with optional ZSTDMT_flushStream() or ZSTDMT_endStream()
+ *  depending on flush directive.
+ * @return : minimum amount of data still to be flushed
+ *           0 if fully flushed
+ *           or an error code
+ *  note : needs to be init using any ZSTD_initCStream*() variant */
+size_t ZSTDMT_compressStream_generic(ZSTDMT_CCtx* mtctx,
+                                     ZSTD_outBuffer* output,
+                                     ZSTD_inBuffer* input,
+                                     ZSTD_EndDirective endOp);
+
+ /*! ZSTDMT_toFlushNow()
+  *  Tell how many bytes are ready to be flushed immediately.
+  *  Probe the oldest active job (not yet entirely flushed) and check its output buffer.
+  *  If return 0, it means there is no active job,
+  *  or, it means oldest job is still active, but everything produced has been flushed so far,
+  *  therefore flushing is limited by speed of oldest job. */
+size_t ZSTDMT_toFlushNow(ZSTDMT_CCtx* mtctx);
+
+/*! ZSTDMT_updateCParams_whileCompressing() :
+ *  Updates only a selected set of compression parameters, to remain compatible with current frame.
+ *  New parameters will be applied to next compression job. */
+void ZSTDMT_updateCParams_whileCompressing(ZSTDMT_CCtx* mtctx, const ZSTD_CCtx_params* cctxParams);
+
+/*! ZSTDMT_getFrameProgression():
+ *  tells how much data has been consumed (input) and produced (output) for current frame.
+ *  able to count progression inside worker threads.
+ */
+ZSTD_frameProgression ZSTDMT_getFrameProgression(ZSTDMT_CCtx* mtctx);
+
+
+#if defined (__cplusplus)
+}
+#endif
+
+#endif   /* ZSTDMT_COMPRESS_H */
diff --git a/src/3rdparty/zstd/src/decompress/huf_decompress.c b/src/3rdparty/zstd/src/decompress/huf_decompress.c
new file mode 100644
index 0000000000..5b217ac586
--- /dev/null
+++ b/src/3rdparty/zstd/src/decompress/huf_decompress.c
@@ -0,0 +1,1882 @@
+/* ******************************************************************
+ * huff0 huffman decoder,
+ * part of Finite State Entropy library
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ *  You can contact the author at :
+ *  - FSE+HUF source repository : https://github.com/Cyan4973/FiniteStateEntropy
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+****************************************************************** */
+
+/* **************************************************************
+*  Dependencies
+****************************************************************/
+#include "../common/zstd_deps.h"  /* ZSTD_memcpy, ZSTD_memset */
+#include "../common/compiler.h"
+#include "../common/bitstream.h"  /* BIT_* */
+#include "../common/fse.h"        /* to compress headers */
+#include "../common/huf.h"
+#include "../common/error_private.h"
+#include "../common/zstd_internal.h"
+#include "../common/bits.h"       /* ZSTD_highbit32, ZSTD_countTrailingZeros64 */
+
+/* **************************************************************
+*  Constants
+****************************************************************/
+
+#define HUF_DECODER_FAST_TABLELOG 11
+
+/* **************************************************************
+*  Macros
+****************************************************************/
+
+/* These two optional macros force the use one way or another of the two
+ * Huffman decompression implementations. You can't force in both directions
+ * at the same time.
+ */
+#if defined(HUF_FORCE_DECOMPRESS_X1) && \
+    defined(HUF_FORCE_DECOMPRESS_X2)
+#error "Cannot force the use of the X1 and X2 decoders at the same time!"
+#endif
+
+/* When DYNAMIC_BMI2 is enabled, fast decoders are only called when bmi2 is
+ * supported at runtime, so we can add the BMI2 target attribute.
+ * When it is disabled, we will still get BMI2 if it is enabled statically.
+ */
+#if DYNAMIC_BMI2
+# define HUF_FAST_BMI2_ATTRS BMI2_TARGET_ATTRIBUTE
+#else
+# define HUF_FAST_BMI2_ATTRS
+#endif
+
+#ifdef __cplusplus
+# define HUF_EXTERN_C extern "C"
+#else
+# define HUF_EXTERN_C
+#endif
+#define HUF_ASM_DECL HUF_EXTERN_C
+
+#if DYNAMIC_BMI2
+# define HUF_NEED_BMI2_FUNCTION 1
+#else
+# define HUF_NEED_BMI2_FUNCTION 0
+#endif
+
+/* **************************************************************
+*  Error Management
+****************************************************************/
+#define HUF_isError ERR_isError
+
+
+/* **************************************************************
+*  Byte alignment for workSpace management
+****************************************************************/
+#define HUF_ALIGN(x, a)         HUF_ALIGN_MASK((x), (a) - 1)
+#define HUF_ALIGN_MASK(x, mask) (((x) + (mask)) & ~(mask))
+
+
+/* **************************************************************
+*  BMI2 Variant Wrappers
+****************************************************************/
+typedef size_t (*HUF_DecompressUsingDTableFn)(void *dst, size_t dstSize,
+                                              const void *cSrc,
+                                              size_t cSrcSize,
+                                              const HUF_DTable *DTable);
+
+#if DYNAMIC_BMI2
+
+#define HUF_DGEN(fn)                                                        \
+                                                                            \
+    static size_t fn##_default(                                             \
+                  void* dst,  size_t dstSize,                               \
+            const void* cSrc, size_t cSrcSize,                              \
+            const HUF_DTable* DTable)                                       \
+    {                                                                       \
+        return fn##_body(dst, dstSize, cSrc, cSrcSize, DTable);             \
+    }                                                                       \
+                                                                            \
+    static BMI2_TARGET_ATTRIBUTE size_t fn##_bmi2(                          \
+                  void* dst,  size_t dstSize,                               \
+            const void* cSrc, size_t cSrcSize,                              \
+            const HUF_DTable* DTable)                                       \
+    {                                                                       \
+        return fn##_body(dst, dstSize, cSrc, cSrcSize, DTable);             \
+    }                                                                       \
+                                                                            \
+    static size_t fn(void* dst, size_t dstSize, void const* cSrc,           \
+                     size_t cSrcSize, HUF_DTable const* DTable, int flags)  \
+    {                                                                       \
+        if (flags & HUF_flags_bmi2) {                                       \
+            return fn##_bmi2(dst, dstSize, cSrc, cSrcSize, DTable);         \
+        }                                                                   \
+        return fn##_default(dst, dstSize, cSrc, cSrcSize, DTable);          \
+    }
+
+#else
+
+#define HUF_DGEN(fn)                                                        \
+    static size_t fn(void* dst, size_t dstSize, void const* cSrc,           \
+                     size_t cSrcSize, HUF_DTable const* DTable, int flags)  \
+    {                                                                       \
+        (void)flags;                                                        \
+        return fn##_body(dst, dstSize, cSrc, cSrcSize, DTable);             \
+    }
+
+#endif
+
+
+/*-***************************/
+/*  generic DTableDesc       */
+/*-***************************/
+typedef struct { BYTE maxTableLog; BYTE tableType; BYTE tableLog; BYTE reserved; } DTableDesc;
+
+static DTableDesc HUF_getDTableDesc(const HUF_DTable* table)
+{
+    DTableDesc dtd;
+    ZSTD_memcpy(&dtd, table, sizeof(dtd));
+    return dtd;
+}
+
+static size_t HUF_initFastDStream(BYTE const* ip) {
+    BYTE const lastByte = ip[7];
+    size_t const bitsConsumed = lastByte ? 8 - ZSTD_highbit32(lastByte) : 0;
+    size_t const value = MEM_readLEST(ip) | 1;
+    assert(bitsConsumed <= 8);
+    assert(sizeof(size_t) == 8);
+    return value << bitsConsumed;
+}
+
+
+/**
+ * The input/output arguments to the Huffman fast decoding loop:
+ *
+ * ip [in/out] - The input pointers, must be updated to reflect what is consumed.
+ * op [in/out] - The output pointers, must be updated to reflect what is written.
+ * bits [in/out] - The bitstream containers, must be updated to reflect the current state.
+ * dt [in] - The decoding table.
+ * ilimit [in] - The input limit, stop when any input pointer is below ilimit.
+ * oend [in] - The end of the output stream. op[3] must not cross oend.
+ * iend [in] - The end of each input stream. ip[i] may cross iend[i],
+ *             as long as it is above ilimit, but that indicates corruption.
+ */
+typedef struct {
+    BYTE const* ip[4];
+    BYTE* op[4];
+    U64 bits[4];
+    void const* dt;
+    BYTE const* ilimit;
+    BYTE* oend;
+    BYTE const* iend[4];
+} HUF_DecompressFastArgs;
+
+typedef void (*HUF_DecompressFastLoopFn)(HUF_DecompressFastArgs*);
+
+/**
+ * Initializes args for the fast decoding loop.
+ * @returns 1 on success
+ *          0 if the fallback implementation should be used.
+ *          Or an error code on failure.
+ */
+static size_t HUF_DecompressFastArgs_init(HUF_DecompressFastArgs* args, void* dst, size_t dstSize, void const* src, size_t srcSize, const HUF_DTable* DTable)
+{
+    void const* dt = DTable + 1;
+    U32 const dtLog = HUF_getDTableDesc(DTable).tableLog;
+
+    const BYTE* const ilimit = (const BYTE*)src + 6 + 8;
+
+    BYTE* const oend = (BYTE*)dst + dstSize;
+
+    /* The fast decoding loop assumes 64-bit little-endian.
+     * This condition is false on x32.
+     */
+    if (!MEM_isLittleEndian() || MEM_32bits())
+        return 0;
+
+    /* strict minimum : jump table + 1 byte per stream */
+    if (srcSize < 10)
+        return ERROR(corruption_detected);
+
+    /* Must have at least 8 bytes per stream because we don't handle initializing smaller bit containers.
+     * If table log is not correct at this point, fallback to the old decoder.
+     * On small inputs we don't have enough data to trigger the fast loop, so use the old decoder.
+     */
+    if (dtLog != HUF_DECODER_FAST_TABLELOG)
+        return 0;
+
+    /* Read the jump table. */
+    {
+        const BYTE* const istart = (const BYTE*)src;
+        size_t const length1 = MEM_readLE16(istart);
+        size_t const length2 = MEM_readLE16(istart+2);
+        size_t const length3 = MEM_readLE16(istart+4);
+        size_t const length4 = srcSize - (length1 + length2 + length3 + 6);
+        args->iend[0] = istart + 6;  /* jumpTable */
+        args->iend[1] = args->iend[0] + length1;
+        args->iend[2] = args->iend[1] + length2;
+        args->iend[3] = args->iend[2] + length3;
+
+        /* HUF_initFastDStream() requires this, and this small of an input
+         * won't benefit from the ASM loop anyways.
+         * length1 must be >= 16 so that ip[0] >= ilimit before the loop
+         * starts.
+         */
+        if (length1 < 16 || length2 < 8 || length3 < 8 || length4 < 8)
+            return 0;
+        if (length4 > srcSize) return ERROR(corruption_detected);   /* overflow */
+    }
+    /* ip[] contains the position that is currently loaded into bits[]. */
+    args->ip[0] = args->iend[1] - sizeof(U64);
+    args->ip[1] = args->iend[2] - sizeof(U64);
+    args->ip[2] = args->iend[3] - sizeof(U64);
+    args->ip[3] = (BYTE const*)src + srcSize - sizeof(U64);
+
+    /* op[] contains the output pointers. */
+    args->op[0] = (BYTE*)dst;
+    args->op[1] = args->op[0] + (dstSize+3)/4;
+    args->op[2] = args->op[1] + (dstSize+3)/4;
+    args->op[3] = args->op[2] + (dstSize+3)/4;
+
+    /* No point to call the ASM loop for tiny outputs. */
+    if (args->op[3] >= oend)
+        return 0;
+
+    /* bits[] is the bit container.
+        * It is read from the MSB down to the LSB.
+        * It is shifted left as it is read, and zeros are
+        * shifted in. After the lowest valid bit a 1 is
+        * set, so that CountTrailingZeros(bits[]) can be used
+        * to count how many bits we've consumed.
+        */
+    args->bits[0] = HUF_initFastDStream(args->ip[0]);
+    args->bits[1] = HUF_initFastDStream(args->ip[1]);
+    args->bits[2] = HUF_initFastDStream(args->ip[2]);
+    args->bits[3] = HUF_initFastDStream(args->ip[3]);
+
+    /* If ip[] >= ilimit, it is guaranteed to be safe to
+        * reload bits[]. It may be beyond its section, but is
+        * guaranteed to be valid (>= istart).
+        */
+    args->ilimit = ilimit;
+
+    args->oend = oend;
+    args->dt = dt;
+
+    return 1;
+}
+
+static size_t HUF_initRemainingDStream(BIT_DStream_t* bit, HUF_DecompressFastArgs const* args, int stream, BYTE* segmentEnd)
+{
+    /* Validate that we haven't overwritten. */
+    if (args->op[stream] > segmentEnd)
+        return ERROR(corruption_detected);
+    /* Validate that we haven't read beyond iend[].
+        * Note that ip[] may be < iend[] because the MSB is
+        * the next bit to read, and we may have consumed 100%
+        * of the stream, so down to iend[i] - 8 is valid.
+        */
+    if (args->ip[stream] < args->iend[stream] - 8)
+        return ERROR(corruption_detected);
+
+    /* Construct the BIT_DStream_t. */
+    assert(sizeof(size_t) == 8);
+    bit->bitContainer = MEM_readLEST(args->ip[stream]);
+    bit->bitsConsumed = ZSTD_countTrailingZeros64(args->bits[stream]);
+    bit->start = (const char*)args->iend[0];
+    bit->limitPtr = bit->start + sizeof(size_t);
+    bit->ptr = (const char*)args->ip[stream];
+
+    return 0;
+}
+
+
+#ifndef HUF_FORCE_DECOMPRESS_X2
+
+/*-***************************/
+/*  single-symbol decoding   */
+/*-***************************/
+typedef struct { BYTE nbBits; BYTE byte; } HUF_DEltX1;   /* single-symbol decoding */
+
+/**
+ * Packs 4 HUF_DEltX1 structs into a U64. This is used to lay down 4 entries at
+ * a time.
+ */
+static U64 HUF_DEltX1_set4(BYTE symbol, BYTE nbBits) {
+    U64 D4;
+    if (MEM_isLittleEndian()) {
+        D4 = (U64)((symbol << 8) + nbBits);
+    } else {
+        D4 = (U64)(symbol + (nbBits << 8));
+    }
+    assert(D4 < (1U << 16));
+    D4 *= 0x0001000100010001ULL;
+    return D4;
+}
+
+/**
+ * Increase the tableLog to targetTableLog and rescales the stats.
+ * If tableLog > targetTableLog this is a no-op.
+ * @returns New tableLog
+ */
+static U32 HUF_rescaleStats(BYTE* huffWeight, U32* rankVal, U32 nbSymbols, U32 tableLog, U32 targetTableLog)
+{
+    if (tableLog > targetTableLog)
+        return tableLog;
+    if (tableLog < targetTableLog) {
+        U32 const scale = targetTableLog - tableLog;
+        U32 s;
+        /* Increase the weight for all non-zero probability symbols by scale. */
+        for (s = 0; s < nbSymbols; ++s) {
+            huffWeight[s] += (BYTE)((huffWeight[s] == 0) ? 0 : scale);
+        }
+        /* Update rankVal to reflect the new weights.
+         * All weights except 0 get moved to weight + scale.
+         * Weights [1, scale] are empty.
+         */
+        for (s = targetTableLog; s > scale; --s) {
+            rankVal[s] = rankVal[s - scale];
+        }
+        for (s = scale; s > 0; --s) {
+            rankVal[s] = 0;
+        }
+    }
+    return targetTableLog;
+}
+
+typedef struct {
+        U32 rankVal[HUF_TABLELOG_ABSOLUTEMAX + 1];
+        U32 rankStart[HUF_TABLELOG_ABSOLUTEMAX + 1];
+        U32 statsWksp[HUF_READ_STATS_WORKSPACE_SIZE_U32];
+        BYTE symbols[HUF_SYMBOLVALUE_MAX + 1];
+        BYTE huffWeight[HUF_SYMBOLVALUE_MAX + 1];
+} HUF_ReadDTableX1_Workspace;
+
+size_t HUF_readDTableX1_wksp(HUF_DTable* DTable, const void* src, size_t srcSize, void* workSpace, size_t wkspSize, int flags)
+{
+    U32 tableLog = 0;
+    U32 nbSymbols = 0;
+    size_t iSize;
+    void* const dtPtr = DTable + 1;
+    HUF_DEltX1* const dt = (HUF_DEltX1*)dtPtr;
+    HUF_ReadDTableX1_Workspace* wksp = (HUF_ReadDTableX1_Workspace*)workSpace;
+
+    DEBUG_STATIC_ASSERT(HUF_DECOMPRESS_WORKSPACE_SIZE >= sizeof(*wksp));
+    if (sizeof(*wksp) > wkspSize) return ERROR(tableLog_tooLarge);
+
+    DEBUG_STATIC_ASSERT(sizeof(DTableDesc) == sizeof(HUF_DTable));
+    /* ZSTD_memset(huffWeight, 0, sizeof(huffWeight)); */   /* is not necessary, even though some analyzer complain ... */
+
+    iSize = HUF_readStats_wksp(wksp->huffWeight, HUF_SYMBOLVALUE_MAX + 1, wksp->rankVal, &nbSymbols, &tableLog, src, srcSize, wksp->statsWksp, sizeof(wksp->statsWksp), flags);
+    if (HUF_isError(iSize)) return iSize;
+
+
+    /* Table header */
+    {   DTableDesc dtd = HUF_getDTableDesc(DTable);
+        U32 const maxTableLog = dtd.maxTableLog + 1;
+        U32 const targetTableLog = MIN(maxTableLog, HUF_DECODER_FAST_TABLELOG);
+        tableLog = HUF_rescaleStats(wksp->huffWeight, wksp->rankVal, nbSymbols, tableLog, targetTableLog);
+        if (tableLog > (U32)(dtd.maxTableLog+1)) return ERROR(tableLog_tooLarge);   /* DTable too small, Huffman tree cannot fit in */
+        dtd.tableType = 0;
+        dtd.tableLog = (BYTE)tableLog;
+        ZSTD_memcpy(DTable, &dtd, sizeof(dtd));
+    }
+
+    /* Compute symbols and rankStart given rankVal:
+     *
+     * rankVal already contains the number of values of each weight.
+     *
+     * symbols contains the symbols ordered by weight. First are the rankVal[0]
+     * weight 0 symbols, followed by the rankVal[1] weight 1 symbols, and so on.
+     * symbols[0] is filled (but unused) to avoid a branch.
+     *
+     * rankStart contains the offset where each rank belongs in the DTable.
+     * rankStart[0] is not filled because there are no entries in the table for
+     * weight 0.
+     */
+    {   int n;
+        U32 nextRankStart = 0;
+        int const unroll = 4;
+        int const nLimit = (int)nbSymbols - unroll + 1;
+        for (n=0; n<(int)tableLog+1; n++) {
+            U32 const curr = nextRankStart;
+            nextRankStart += wksp->rankVal[n];
+            wksp->rankStart[n] = curr;
+        }
+        for (n=0; n < nLimit; n += unroll) {
+            int u;
+            for (u=0; u < unroll; ++u) {
+                size_t const w = wksp->huffWeight[n+u];
+                wksp->symbols[wksp->rankStart[w]++] = (BYTE)(n+u);
+            }
+        }
+        for (; n < (int)nbSymbols; ++n) {
+            size_t const w = wksp->huffWeight[n];
+            wksp->symbols[wksp->rankStart[w]++] = (BYTE)n;
+        }
+    }
+
+    /* fill DTable
+     * We fill all entries of each weight in order.
+     * That way length is a constant for each iteration of the outer loop.
+     * We can switch based on the length to a different inner loop which is
+     * optimized for that particular case.
+     */
+    {   U32 w;
+        int symbol = wksp->rankVal[0];
+        int rankStart = 0;
+        for (w=1; w<tableLog+1; ++w) {
+            int const symbolCount = wksp->rankVal[w];
+            int const length = (1 << w) >> 1;
+            int uStart = rankStart;
+            BYTE const nbBits = (BYTE)(tableLog + 1 - w);
+            int s;
+            int u;
+            switch (length) {
+            case 1:
+                for (s=0; s<symbolCount; ++s) {
+                    HUF_DEltX1 D;
+                    D.byte = wksp->symbols[symbol + s];
+                    D.nbBits = nbBits;
+                    dt[uStart] = D;
+                    uStart += 1;
+                }
+                break;
+            case 2:
+                for (s=0; s<symbolCount; ++s) {
+                    HUF_DEltX1 D;
+                    D.byte = wksp->symbols[symbol + s];
+                    D.nbBits = nbBits;
+                    dt[uStart+0] = D;
+                    dt[uStart+1] = D;
+                    uStart += 2;
+                }
+                break;
+            case 4:
+                for (s=0; s<symbolCount; ++s) {
+                    U64 const D4 = HUF_DEltX1_set4(wksp->symbols[symbol + s], nbBits);
+                    MEM_write64(dt + uStart, D4);
+                    uStart += 4;
+                }
+                break;
+            case 8:
+                for (s=0; s<symbolCount; ++s) {
+                    U64 const D4 = HUF_DEltX1_set4(wksp->symbols[symbol + s], nbBits);
+                    MEM_write64(dt + uStart, D4);
+                    MEM_write64(dt + uStart + 4, D4);
+                    uStart += 8;
+                }
+                break;
+            default:
+                for (s=0; s<symbolCount; ++s) {
+                    U64 const D4 = HUF_DEltX1_set4(wksp->symbols[symbol + s], nbBits);
+                    for (u=0; u < length; u += 16) {
+                        MEM_write64(dt + uStart + u + 0, D4);
+                        MEM_write64(dt + uStart + u + 4, D4);
+                        MEM_write64(dt + uStart + u + 8, D4);
+                        MEM_write64(dt + uStart + u + 12, D4);
+                    }
+                    assert(u == length);
+                    uStart += length;
+                }
+                break;
+            }
+            symbol += symbolCount;
+            rankStart += symbolCount * length;
+        }
+    }
+    return iSize;
+}
+
+FORCE_INLINE_TEMPLATE BYTE
+HUF_decodeSymbolX1(BIT_DStream_t* Dstream, const HUF_DEltX1* dt, const U32 dtLog)
+{
+    size_t const val = BIT_lookBitsFast(Dstream, dtLog); /* note : dtLog >= 1 */
+    BYTE const c = dt[val].byte;
+    BIT_skipBits(Dstream, dt[val].nbBits);
+    return c;
+}
+
+#define HUF_DECODE_SYMBOLX1_0(ptr, DStreamPtr) \
+    *ptr++ = HUF_decodeSymbolX1(DStreamPtr, dt, dtLog)
+
+#define HUF_DECODE_SYMBOLX1_1(ptr, DStreamPtr)  \
+    if (MEM_64bits() || (HUF_TABLELOG_MAX<=12)) \
+        HUF_DECODE_SYMBOLX1_0(ptr, DStreamPtr)
+
+#define HUF_DECODE_SYMBOLX1_2(ptr, DStreamPtr) \
+    if (MEM_64bits()) \
+        HUF_DECODE_SYMBOLX1_0(ptr, DStreamPtr)
+
+HINT_INLINE size_t
+HUF_decodeStreamX1(BYTE* p, BIT_DStream_t* const bitDPtr, BYTE* const pEnd, const HUF_DEltX1* const dt, const U32 dtLog)
+{
+    BYTE* const pStart = p;
+
+    /* up to 4 symbols at a time */
+    if ((pEnd - p) > 3) {
+        while ((BIT_reloadDStream(bitDPtr) == BIT_DStream_unfinished) & (p < pEnd-3)) {
+            HUF_DECODE_SYMBOLX1_2(p, bitDPtr);
+            HUF_DECODE_SYMBOLX1_1(p, bitDPtr);
+            HUF_DECODE_SYMBOLX1_2(p, bitDPtr);
+            HUF_DECODE_SYMBOLX1_0(p, bitDPtr);
+        }
+    } else {
+        BIT_reloadDStream(bitDPtr);
+    }
+
+    /* [0-3] symbols remaining */
+    if (MEM_32bits())
+        while ((BIT_reloadDStream(bitDPtr) == BIT_DStream_unfinished) & (p < pEnd))
+            HUF_DECODE_SYMBOLX1_0(p, bitDPtr);
+
+    /* no more data to retrieve from bitstream, no need to reload */
+    while (p < pEnd)
+        HUF_DECODE_SYMBOLX1_0(p, bitDPtr);
+
+    return (size_t)(pEnd-pStart);
+}
+
+FORCE_INLINE_TEMPLATE size_t
+HUF_decompress1X1_usingDTable_internal_body(
+          void* dst,  size_t dstSize,
+    const void* cSrc, size_t cSrcSize,
+    const HUF_DTable* DTable)
+{
+    BYTE* op = (BYTE*)dst;
+    BYTE* const oend = op + dstSize;
+    const void* dtPtr = DTable + 1;
+    const HUF_DEltX1* const dt = (const HUF_DEltX1*)dtPtr;
+    BIT_DStream_t bitD;
+    DTableDesc const dtd = HUF_getDTableDesc(DTable);
+    U32 const dtLog = dtd.tableLog;
+
+    CHECK_F( BIT_initDStream(&bitD, cSrc, cSrcSize) );
+
+    HUF_decodeStreamX1(op, &bitD, oend, dt, dtLog);
+
+    if (!BIT_endOfDStream(&bitD)) return ERROR(corruption_detected);
+
+    return dstSize;
+}
+
+/* HUF_decompress4X1_usingDTable_internal_body():
+ * Conditions :
+ * @dstSize >= 6
+ */
+FORCE_INLINE_TEMPLATE size_t
+HUF_decompress4X1_usingDTable_internal_body(
+          void* dst,  size_t dstSize,
+    const void* cSrc, size_t cSrcSize,
+    const HUF_DTable* DTable)
+{
+    /* Check */
+    if (cSrcSize < 10) return ERROR(corruption_detected);  /* strict minimum : jump table + 1 byte per stream */
+
+    {   const BYTE* const istart = (const BYTE*) cSrc;
+        BYTE* const ostart = (BYTE*) dst;
+        BYTE* const oend = ostart + dstSize;
+        BYTE* const olimit = oend - 3;
+        const void* const dtPtr = DTable + 1;
+        const HUF_DEltX1* const dt = (const HUF_DEltX1*)dtPtr;
+
+        /* Init */
+        BIT_DStream_t bitD1;
+        BIT_DStream_t bitD2;
+        BIT_DStream_t bitD3;
+        BIT_DStream_t bitD4;
+        size_t const length1 = MEM_readLE16(istart);
+        size_t const length2 = MEM_readLE16(istart+2);
+        size_t const length3 = MEM_readLE16(istart+4);
+        size_t const length4 = cSrcSize - (length1 + length2 + length3 + 6);
+        const BYTE* const istart1 = istart + 6;  /* jumpTable */
+        const BYTE* const istart2 = istart1 + length1;
+        const BYTE* const istart3 = istart2 + length2;
+        const BYTE* const istart4 = istart3 + length3;
+        const size_t segmentSize = (dstSize+3) / 4;
+        BYTE* const opStart2 = ostart + segmentSize;
+        BYTE* const opStart3 = opStart2 + segmentSize;
+        BYTE* const opStart4 = opStart3 + segmentSize;
+        BYTE* op1 = ostart;
+        BYTE* op2 = opStart2;
+        BYTE* op3 = opStart3;
+        BYTE* op4 = opStart4;
+        DTableDesc const dtd = HUF_getDTableDesc(DTable);
+        U32 const dtLog = dtd.tableLog;
+        U32 endSignal = 1;
+
+        if (length4 > cSrcSize) return ERROR(corruption_detected);   /* overflow */
+        if (opStart4 > oend) return ERROR(corruption_detected);      /* overflow */
+        if (dstSize < 6) return ERROR(corruption_detected);         /* stream 4-split doesn't work */
+        CHECK_F( BIT_initDStream(&bitD1, istart1, length1) );
+        CHECK_F( BIT_initDStream(&bitD2, istart2, length2) );
+        CHECK_F( BIT_initDStream(&bitD3, istart3, length3) );
+        CHECK_F( BIT_initDStream(&bitD4, istart4, length4) );
+
+        /* up to 16 symbols per loop (4 symbols per stream) in 64-bit mode */
+        if ((size_t)(oend - op4) >= sizeof(size_t)) {
+            for ( ; (endSignal) & (op4 < olimit) ; ) {
+                HUF_DECODE_SYMBOLX1_2(op1, &bitD1);
+                HUF_DECODE_SYMBOLX1_2(op2, &bitD2);
+                HUF_DECODE_SYMBOLX1_2(op3, &bitD3);
+                HUF_DECODE_SYMBOLX1_2(op4, &bitD4);
+                HUF_DECODE_SYMBOLX1_1(op1, &bitD1);
+                HUF_DECODE_SYMBOLX1_1(op2, &bitD2);
+                HUF_DECODE_SYMBOLX1_1(op3, &bitD3);
+                HUF_DECODE_SYMBOLX1_1(op4, &bitD4);
+                HUF_DECODE_SYMBOLX1_2(op1, &bitD1);
+                HUF_DECODE_SYMBOLX1_2(op2, &bitD2);
+                HUF_DECODE_SYMBOLX1_2(op3, &bitD3);
+                HUF_DECODE_SYMBOLX1_2(op4, &bitD4);
+                HUF_DECODE_SYMBOLX1_0(op1, &bitD1);
+                HUF_DECODE_SYMBOLX1_0(op2, &bitD2);
+                HUF_DECODE_SYMBOLX1_0(op3, &bitD3);
+                HUF_DECODE_SYMBOLX1_0(op4, &bitD4);
+                endSignal &= BIT_reloadDStreamFast(&bitD1) == BIT_DStream_unfinished;
+                endSignal &= BIT_reloadDStreamFast(&bitD2) == BIT_DStream_unfinished;
+                endSignal &= BIT_reloadDStreamFast(&bitD3) == BIT_DStream_unfinished;
+                endSignal &= BIT_reloadDStreamFast(&bitD4) == BIT_DStream_unfinished;
+            }
+        }
+
+        /* check corruption */
+        /* note : should not be necessary : op# advance in lock step, and we control op4.
+         *        but curiously, binary generated by gcc 7.2 & 7.3 with -mbmi2 runs faster when >=1 test is present */
+        if (op1 > opStart2) return ERROR(corruption_detected);
+        if (op2 > opStart3) return ERROR(corruption_detected);
+        if (op3 > opStart4) return ERROR(corruption_detected);
+        /* note : op4 supposed already verified within main loop */
+
+        /* finish bitStreams one by one */
+        HUF_decodeStreamX1(op1, &bitD1, opStart2, dt, dtLog);
+        HUF_decodeStreamX1(op2, &bitD2, opStart3, dt, dtLog);
+        HUF_decodeStreamX1(op3, &bitD3, opStart4, dt, dtLog);
+        HUF_decodeStreamX1(op4, &bitD4, oend,     dt, dtLog);
+
+        /* check */
+        { U32 const endCheck = BIT_endOfDStream(&bitD1) & BIT_endOfDStream(&bitD2) & BIT_endOfDStream(&bitD3) & BIT_endOfDStream(&bitD4);
+          if (!endCheck) return ERROR(corruption_detected); }
+
+        /* decoded size */
+        return dstSize;
+    }
+}
+
+#if HUF_NEED_BMI2_FUNCTION
+static BMI2_TARGET_ATTRIBUTE
+size_t HUF_decompress4X1_usingDTable_internal_bmi2(void* dst, size_t dstSize, void const* cSrc,
+                    size_t cSrcSize, HUF_DTable const* DTable) {
+    return HUF_decompress4X1_usingDTable_internal_body(dst, dstSize, cSrc, cSrcSize, DTable);
+}
+#endif
+
+static
+size_t HUF_decompress4X1_usingDTable_internal_default(void* dst, size_t dstSize, void const* cSrc,
+                    size_t cSrcSize, HUF_DTable const* DTable) {
+    return HUF_decompress4X1_usingDTable_internal_body(dst, dstSize, cSrc, cSrcSize, DTable);
+}
+
+#if ZSTD_ENABLE_ASM_X86_64_BMI2
+
+HUF_ASM_DECL void HUF_decompress4X1_usingDTable_internal_fast_asm_loop(HUF_DecompressFastArgs* args) ZSTDLIB_HIDDEN;
+
+#endif
+
+static HUF_FAST_BMI2_ATTRS
+void HUF_decompress4X1_usingDTable_internal_fast_c_loop(HUF_DecompressFastArgs* args)
+{
+    U64 bits[4];
+    BYTE const* ip[4];
+    BYTE* op[4];
+    U16 const* const dtable = (U16 const*)args->dt;
+    BYTE* const oend = args->oend;
+    BYTE const* const ilimit = args->ilimit;
+
+    /* Copy the arguments to local variables */
+    ZSTD_memcpy(&bits, &args->bits, sizeof(bits));
+    ZSTD_memcpy((void*)(&ip), &args->ip, sizeof(ip));
+    ZSTD_memcpy(&op, &args->op, sizeof(op));
+
+    assert(MEM_isLittleEndian());
+    assert(!MEM_32bits());
+
+    for (;;) {
+        BYTE* olimit;
+        int stream;
+        int symbol;
+
+        /* Assert loop preconditions */
+#ifndef NDEBUG
+        for (stream = 0; stream < 4; ++stream) {
+            assert(op[stream] <= (stream == 3 ? oend : op[stream + 1]));
+            assert(ip[stream] >= ilimit);
+        }
+#endif
+        /* Compute olimit */
+        {
+            /* Each iteration produces 5 output symbols per stream */
+            size_t const oiters = (size_t)(oend - op[3]) / 5;
+            /* Each iteration consumes up to 11 bits * 5 = 55 bits < 7 bytes
+             * per stream.
+             */
+            size_t const iiters = (size_t)(ip[0] - ilimit) / 7;
+            /* We can safely run iters iterations before running bounds checks */
+            size_t const iters = MIN(oiters, iiters);
+            size_t const symbols = iters * 5;
+
+            /* We can simply check that op[3] < olimit, instead of checking all
+             * of our bounds, since we can't hit the other bounds until we've run
+             * iters iterations, which only happens when op[3] == olimit.
+             */
+            olimit = op[3] + symbols;
+
+            /* Exit fast decoding loop once we get close to the end. */
+            if (op[3] + 20 > olimit)
+                break;
+
+            /* Exit the decoding loop if any input pointer has crossed the
+             * previous one. This indicates corruption, and a precondition
+             * to our loop is that ip[i] >= ip[0].
+             */
+            for (stream = 1; stream < 4; ++stream) {
+                if (ip[stream] < ip[stream - 1])
+                    goto _out;
+            }
+        }
+
+#ifndef NDEBUG
+        for (stream = 1; stream < 4; ++stream) {
+            assert(ip[stream] >= ip[stream - 1]);
+        }
+#endif
+
+        do {
+            /* Decode 5 symbols in each of the 4 streams */
+            for (symbol = 0; symbol < 5; ++symbol) {
+                for (stream = 0; stream < 4; ++stream) {
+                    int const index = (int)(bits[stream] >> 53);
+                    int const entry = (int)dtable[index];
+                    bits[stream] <<= (entry & 63);
+                    op[stream][symbol] = (BYTE)((entry >> 8) & 0xFF);
+                }
+            }
+            /* Reload the bitstreams */
+            for (stream = 0; stream < 4; ++stream) {
+                int const ctz = ZSTD_countTrailingZeros64(bits[stream]);
+                int const nbBits = ctz & 7;
+                int const nbBytes = ctz >> 3;
+                op[stream] += 5;
+                ip[stream] -= nbBytes;
+                bits[stream] = MEM_read64(ip[stream]) | 1;
+                bits[stream] <<= nbBits;
+            }
+        } while (op[3] < olimit);
+    }
+
+_out:
+
+    /* Save the final values of each of the state variables back to args. */
+    ZSTD_memcpy(&args->bits, &bits, sizeof(bits));
+    ZSTD_memcpy((void*)(&args->ip), &ip, sizeof(ip));
+    ZSTD_memcpy(&args->op, &op, sizeof(op));
+}
+
+/**
+ * @returns @p dstSize on success (>= 6)
+ *          0 if the fallback implementation should be used
+ *          An error if an error occurred
+ */
+static HUF_FAST_BMI2_ATTRS
+size_t
+HUF_decompress4X1_usingDTable_internal_fast(
+          void* dst,  size_t dstSize,
+    const void* cSrc, size_t cSrcSize,
+    const HUF_DTable* DTable,
+    HUF_DecompressFastLoopFn loopFn)
+{
+    void const* dt = DTable + 1;
+    const BYTE* const iend = (const BYTE*)cSrc + 6;
+    BYTE* const oend = (BYTE*)dst + dstSize;
+    HUF_DecompressFastArgs args;
+    {   size_t const ret = HUF_DecompressFastArgs_init(&args, dst, dstSize, cSrc, cSrcSize, DTable);
+        FORWARD_IF_ERROR(ret, "Failed to init fast loop args");
+        if (ret == 0)
+            return 0;
+    }
+
+    assert(args.ip[0] >= args.ilimit);
+    loopFn(&args);
+
+    /* Our loop guarantees that ip[] >= ilimit and that we haven't
+    * overwritten any op[].
+    */
+    assert(args.ip[0] >= iend);
+    assert(args.ip[1] >= iend);
+    assert(args.ip[2] >= iend);
+    assert(args.ip[3] >= iend);
+    assert(args.op[3] <= oend);
+    (void)iend;
+
+    /* finish bit streams one by one. */
+    {   size_t const segmentSize = (dstSize+3) / 4;
+        BYTE* segmentEnd = (BYTE*)dst;
+        int i;
+        for (i = 0; i < 4; ++i) {
+            BIT_DStream_t bit;
+            if (segmentSize <= (size_t)(oend - segmentEnd))
+                segmentEnd += segmentSize;
+            else
+                segmentEnd = oend;
+            FORWARD_IF_ERROR(HUF_initRemainingDStream(&bit, &args, i, segmentEnd), "corruption");
+            /* Decompress and validate that we've produced exactly the expected length. */
+            args.op[i] += HUF_decodeStreamX1(args.op[i], &bit, segmentEnd, (HUF_DEltX1 const*)dt, HUF_DECODER_FAST_TABLELOG);
+            if (args.op[i] != segmentEnd) return ERROR(corruption_detected);
+        }
+    }
+
+    /* decoded size */
+    assert(dstSize != 0);
+    return dstSize;
+}
+
+HUF_DGEN(HUF_decompress1X1_usingDTable_internal)
+
+static size_t HUF_decompress4X1_usingDTable_internal(void* dst, size_t dstSize, void const* cSrc,
+                    size_t cSrcSize, HUF_DTable const* DTable, int flags)
+{
+    HUF_DecompressUsingDTableFn fallbackFn = HUF_decompress4X1_usingDTable_internal_default;
+    HUF_DecompressFastLoopFn loopFn = HUF_decompress4X1_usingDTable_internal_fast_c_loop;
+
+#if DYNAMIC_BMI2
+    if (flags & HUF_flags_bmi2) {
+        fallbackFn = HUF_decompress4X1_usingDTable_internal_bmi2;
+# if ZSTD_ENABLE_ASM_X86_64_BMI2
+        if (!(flags & HUF_flags_disableAsm)) {
+            loopFn = HUF_decompress4X1_usingDTable_internal_fast_asm_loop;
+        }
+# endif
+    } else {
+        return fallbackFn(dst, dstSize, cSrc, cSrcSize, DTable);
+    }
+#endif
+
+#if ZSTD_ENABLE_ASM_X86_64_BMI2 && defined(__BMI2__)
+    if (!(flags & HUF_flags_disableAsm)) {
+        loopFn = HUF_decompress4X1_usingDTable_internal_fast_asm_loop;
+    }
+#endif
+
+    if (!(flags & HUF_flags_disableFast)) {
+        size_t const ret = HUF_decompress4X1_usingDTable_internal_fast(dst, dstSize, cSrc, cSrcSize, DTable, loopFn);
+        if (ret != 0)
+            return ret;
+    }
+    return fallbackFn(dst, dstSize, cSrc, cSrcSize, DTable);
+}
+
+static size_t HUF_decompress4X1_DCtx_wksp(HUF_DTable* dctx, void* dst, size_t dstSize,
+                                   const void* cSrc, size_t cSrcSize,
+                                   void* workSpace, size_t wkspSize, int flags)
+{
+    const BYTE* ip = (const BYTE*) cSrc;
+
+    size_t const hSize = HUF_readDTableX1_wksp(dctx, cSrc, cSrcSize, workSpace, wkspSize, flags);
+    if (HUF_isError(hSize)) return hSize;
+    if (hSize >= cSrcSize) return ERROR(srcSize_wrong);
+    ip += hSize; cSrcSize -= hSize;
+
+    return HUF_decompress4X1_usingDTable_internal(dst, dstSize, ip, cSrcSize, dctx, flags);
+}
+
+#endif /* HUF_FORCE_DECOMPRESS_X2 */
+
+
+#ifndef HUF_FORCE_DECOMPRESS_X1
+
+/* *************************/
+/* double-symbols decoding */
+/* *************************/
+
+typedef struct { U16 sequence; BYTE nbBits; BYTE length; } HUF_DEltX2;  /* double-symbols decoding */
+typedef struct { BYTE symbol; } sortedSymbol_t;
+typedef U32 rankValCol_t[HUF_TABLELOG_MAX + 1];
+typedef rankValCol_t rankVal_t[HUF_TABLELOG_MAX];
+
+/**
+ * Constructs a HUF_DEltX2 in a U32.
+ */
+static U32 HUF_buildDEltX2U32(U32 symbol, U32 nbBits, U32 baseSeq, int level)
+{
+    U32 seq;
+    DEBUG_STATIC_ASSERT(offsetof(HUF_DEltX2, sequence) == 0);
+    DEBUG_STATIC_ASSERT(offsetof(HUF_DEltX2, nbBits) == 2);
+    DEBUG_STATIC_ASSERT(offsetof(HUF_DEltX2, length) == 3);
+    DEBUG_STATIC_ASSERT(sizeof(HUF_DEltX2) == sizeof(U32));
+    if (MEM_isLittleEndian()) {
+        seq = level == 1 ? symbol : (baseSeq + (symbol << 8));
+        return seq + (nbBits << 16) + ((U32)level << 24);
+    } else {
+        seq = level == 1 ? (symbol << 8) : ((baseSeq << 8) + symbol);
+        return (seq << 16) + (nbBits << 8) + (U32)level;
+    }
+}
+
+/**
+ * Constructs a HUF_DEltX2.
+ */
+static HUF_DEltX2 HUF_buildDEltX2(U32 symbol, U32 nbBits, U32 baseSeq, int level)
+{
+    HUF_DEltX2 DElt;
+    U32 const val = HUF_buildDEltX2U32(symbol, nbBits, baseSeq, level);
+    DEBUG_STATIC_ASSERT(sizeof(DElt) == sizeof(val));
+    ZSTD_memcpy(&DElt, &val, sizeof(val));
+    return DElt;
+}
+
+/**
+ * Constructs 2 HUF_DEltX2s and packs them into a U64.
+ */
+static U64 HUF_buildDEltX2U64(U32 symbol, U32 nbBits, U16 baseSeq, int level)
+{
+    U32 DElt = HUF_buildDEltX2U32(symbol, nbBits, baseSeq, level);
+    return (U64)DElt + ((U64)DElt << 32);
+}
+
+/**
+ * Fills the DTable rank with all the symbols from [begin, end) that are each
+ * nbBits long.
+ *
+ * @param DTableRank The start of the rank in the DTable.
+ * @param begin The first symbol to fill (inclusive).
+ * @param end The last symbol to fill (exclusive).
+ * @param nbBits Each symbol is nbBits long.
+ * @param tableLog The table log.
+ * @param baseSeq If level == 1 { 0 } else { the first level symbol }
+ * @param level The level in the table. Must be 1 or 2.
+ */
+static void HUF_fillDTableX2ForWeight(
+    HUF_DEltX2* DTableRank,
+    sortedSymbol_t const* begin, sortedSymbol_t const* end,
+    U32 nbBits, U32 tableLog,
+    U16 baseSeq, int const level)
+{
+    U32 const length = 1U << ((tableLog - nbBits) & 0x1F /* quiet static-analyzer */);
+    const sortedSymbol_t* ptr;
+    assert(level >= 1 && level <= 2);
+    switch (length) {
+    case 1:
+        for (ptr = begin; ptr != end; ++ptr) {
+            HUF_DEltX2 const DElt = HUF_buildDEltX2(ptr->symbol, nbBits, baseSeq, level);
+            *DTableRank++ = DElt;
+        }
+        break;
+    case 2:
+        for (ptr = begin; ptr != end; ++ptr) {
+            HUF_DEltX2 const DElt = HUF_buildDEltX2(ptr->symbol, nbBits, baseSeq, level);
+            DTableRank[0] = DElt;
+            DTableRank[1] = DElt;
+            DTableRank += 2;
+        }
+        break;
+    case 4:
+        for (ptr = begin; ptr != end; ++ptr) {
+            U64 const DEltX2 = HUF_buildDEltX2U64(ptr->symbol, nbBits, baseSeq, level);
+            ZSTD_memcpy(DTableRank + 0, &DEltX2, sizeof(DEltX2));
+            ZSTD_memcpy(DTableRank + 2, &DEltX2, sizeof(DEltX2));
+            DTableRank += 4;
+        }
+        break;
+    case 8:
+        for (ptr = begin; ptr != end; ++ptr) {
+            U64 const DEltX2 = HUF_buildDEltX2U64(ptr->symbol, nbBits, baseSeq, level);
+            ZSTD_memcpy(DTableRank + 0, &DEltX2, sizeof(DEltX2));
+            ZSTD_memcpy(DTableRank + 2, &DEltX2, sizeof(DEltX2));
+            ZSTD_memcpy(DTableRank + 4, &DEltX2, sizeof(DEltX2));
+            ZSTD_memcpy(DTableRank + 6, &DEltX2, sizeof(DEltX2));
+            DTableRank += 8;
+        }
+        break;
+    default:
+        for (ptr = begin; ptr != end; ++ptr) {
+            U64 const DEltX2 = HUF_buildDEltX2U64(ptr->symbol, nbBits, baseSeq, level);
+            HUF_DEltX2* const DTableRankEnd = DTableRank + length;
+            for (; DTableRank != DTableRankEnd; DTableRank += 8) {
+                ZSTD_memcpy(DTableRank + 0, &DEltX2, sizeof(DEltX2));
+                ZSTD_memcpy(DTableRank + 2, &DEltX2, sizeof(DEltX2));
+                ZSTD_memcpy(DTableRank + 4, &DEltX2, sizeof(DEltX2));
+                ZSTD_memcpy(DTableRank + 6, &DEltX2, sizeof(DEltX2));
+            }
+        }
+        break;
+    }
+}
+
+/* HUF_fillDTableX2Level2() :
+ * `rankValOrigin` must be a table of at least (HUF_TABLELOG_MAX + 1) U32 */
+static void HUF_fillDTableX2Level2(HUF_DEltX2* DTable, U32 targetLog, const U32 consumedBits,
+                           const U32* rankVal, const int minWeight, const int maxWeight1,
+                           const sortedSymbol_t* sortedSymbols, U32 const* rankStart,
+                           U32 nbBitsBaseline, U16 baseSeq)
+{
+    /* Fill skipped values (all positions up to rankVal[minWeight]).
+     * These are positions only get a single symbol because the combined weight
+     * is too large.
+     */
+    if (minWeight>1) {
+        U32 const length = 1U << ((targetLog - consumedBits) & 0x1F /* quiet static-analyzer */);
+        U64 const DEltX2 = HUF_buildDEltX2U64(baseSeq, consumedBits, /* baseSeq */ 0, /* level */ 1);
+        int const skipSize = rankVal[minWeight];
+        assert(length > 1);
+        assert((U32)skipSize < length);
+        switch (length) {
+        case 2:
+            assert(skipSize == 1);
+            ZSTD_memcpy(DTable, &DEltX2, sizeof(DEltX2));
+            break;
+        case 4:
+            assert(skipSize <= 4);
+            ZSTD_memcpy(DTable + 0, &DEltX2, sizeof(DEltX2));
+            ZSTD_memcpy(DTable + 2, &DEltX2, sizeof(DEltX2));
+            break;
+        default:
+            {
+                int i;
+                for (i = 0; i < skipSize; i += 8) {
+                    ZSTD_memcpy(DTable + i + 0, &DEltX2, sizeof(DEltX2));
+                    ZSTD_memcpy(DTable + i + 2, &DEltX2, sizeof(DEltX2));
+                    ZSTD_memcpy(DTable + i + 4, &DEltX2, sizeof(DEltX2));
+                    ZSTD_memcpy(DTable + i + 6, &DEltX2, sizeof(DEltX2));
+                }
+            }
+        }
+    }
+
+    /* Fill each of the second level symbols by weight. */
+    {
+        int w;
+        for (w = minWeight; w < maxWeight1; ++w) {
+            int const begin = rankStart[w];
+            int const end = rankStart[w+1];
+            U32 const nbBits = nbBitsBaseline - w;
+            U32 const totalBits = nbBits + consumedBits;
+            HUF_fillDTableX2ForWeight(
+                DTable + rankVal[w],
+                sortedSymbols + begin, sortedSymbols + end,
+                totalBits, targetLog,
+                baseSeq, /* level */ 2);
+        }
+    }
+}
+
+static void HUF_fillDTableX2(HUF_DEltX2* DTable, const U32 targetLog,
+                           const sortedSymbol_t* sortedList,
+                           const U32* rankStart, rankValCol_t* rankValOrigin, const U32 maxWeight,
+                           const U32 nbBitsBaseline)
+{
+    U32* const rankVal = rankValOrigin[0];
+    const int scaleLog = nbBitsBaseline - targetLog;   /* note : targetLog >= srcLog, hence scaleLog <= 1 */
+    const U32 minBits  = nbBitsBaseline - maxWeight;
+    int w;
+    int const wEnd = (int)maxWeight + 1;
+
+    /* Fill DTable in order of weight. */
+    for (w = 1; w < wEnd; ++w) {
+        int const begin = (int)rankStart[w];
+        int const end = (int)rankStart[w+1];
+        U32 const nbBits = nbBitsBaseline - w;
+
+        if (targetLog-nbBits >= minBits) {
+            /* Enough room for a second symbol. */
+            int start = rankVal[w];
+            U32 const length = 1U << ((targetLog - nbBits) & 0x1F /* quiet static-analyzer */);
+            int minWeight = nbBits + scaleLog;
+            int s;
+            if (minWeight < 1) minWeight = 1;
+            /* Fill the DTable for every symbol of weight w.
+             * These symbols get at least 1 second symbol.
+             */
+            for (s = begin; s != end; ++s) {
+                HUF_fillDTableX2Level2(
+                    DTable + start, targetLog, nbBits,
+                    rankValOrigin[nbBits], minWeight, wEnd,
+                    sortedList, rankStart,
+                    nbBitsBaseline, sortedList[s].symbol);
+                start += length;
+            }
+        } else {
+            /* Only a single symbol. */
+            HUF_fillDTableX2ForWeight(
+                DTable + rankVal[w],
+                sortedList + begin, sortedList + end,
+                nbBits, targetLog,
+                /* baseSeq */ 0, /* level */ 1);
+        }
+    }
+}
+
+typedef struct {
+    rankValCol_t rankVal[HUF_TABLELOG_MAX];
+    U32 rankStats[HUF_TABLELOG_MAX + 1];
+    U32 rankStart0[HUF_TABLELOG_MAX + 3];
+    sortedSymbol_t sortedSymbol[HUF_SYMBOLVALUE_MAX + 1];
+    BYTE weightList[HUF_SYMBOLVALUE_MAX + 1];
+    U32 calleeWksp[HUF_READ_STATS_WORKSPACE_SIZE_U32];
+} HUF_ReadDTableX2_Workspace;
+
+size_t HUF_readDTableX2_wksp(HUF_DTable* DTable,
+                       const void* src, size_t srcSize,
+                             void* workSpace, size_t wkspSize, int flags)
+{
+    U32 tableLog, maxW, nbSymbols;
+    DTableDesc dtd = HUF_getDTableDesc(DTable);
+    U32 maxTableLog = dtd.maxTableLog;
+    size_t iSize;
+    void* dtPtr = DTable+1;   /* force compiler to avoid strict-aliasing */
+    HUF_DEltX2* const dt = (HUF_DEltX2*)dtPtr;
+    U32 *rankStart;
+
+    HUF_ReadDTableX2_Workspace* const wksp = (HUF_ReadDTableX2_Workspace*)workSpace;
+
+    if (sizeof(*wksp) > wkspSize) return ERROR(GENERIC);
+
+    rankStart = wksp->rankStart0 + 1;
+    ZSTD_memset(wksp->rankStats, 0, sizeof(wksp->rankStats));
+    ZSTD_memset(wksp->rankStart0, 0, sizeof(wksp->rankStart0));
+
+    DEBUG_STATIC_ASSERT(sizeof(HUF_DEltX2) == sizeof(HUF_DTable));   /* if compiler fails here, assertion is wrong */
+    if (maxTableLog > HUF_TABLELOG_MAX) return ERROR(tableLog_tooLarge);
+    /* ZSTD_memset(weightList, 0, sizeof(weightList)); */  /* is not necessary, even though some analyzer complain ... */
+
+    iSize = HUF_readStats_wksp(wksp->weightList, HUF_SYMBOLVALUE_MAX + 1, wksp->rankStats, &nbSymbols, &tableLog, src, srcSize, wksp->calleeWksp, sizeof(wksp->calleeWksp), flags);
+    if (HUF_isError(iSize)) return iSize;
+
+    /* check result */
+    if (tableLog > maxTableLog) return ERROR(tableLog_tooLarge);   /* DTable can't fit code depth */
+    if (tableLog <= HUF_DECODER_FAST_TABLELOG && maxTableLog > HUF_DECODER_FAST_TABLELOG) maxTableLog = HUF_DECODER_FAST_TABLELOG;
+
+    /* find maxWeight */
+    for (maxW = tableLog; wksp->rankStats[maxW]==0; maxW--) {}  /* necessarily finds a solution before 0 */
+
+    /* Get start index of each weight */
+    {   U32 w, nextRankStart = 0;
+        for (w=1; w<maxW+1; w++) {
+            U32 curr = nextRankStart;
+            nextRankStart += wksp->rankStats[w];
+            rankStart[w] = curr;
+        }
+        rankStart[0] = nextRankStart;   /* put all 0w symbols at the end of sorted list*/
+        rankStart[maxW+1] = nextRankStart;
+    }
+
+    /* sort symbols by weight */
+    {   U32 s;
+        for (s=0; s<nbSymbols; s++) {
+            U32 const w = wksp->weightList[s];
+            U32 const r = rankStart[w]++;
+            wksp->sortedSymbol[r].symbol = (BYTE)s;
+        }
+        rankStart[0] = 0;   /* forget 0w symbols; this is beginning of weight(1) */
+    }
+
+    /* Build rankVal */
+    {   U32* const rankVal0 = wksp->rankVal[0];
+        {   int const rescale = (maxTableLog-tableLog) - 1;   /* tableLog <= maxTableLog */
+            U32 nextRankVal = 0;
+            U32 w;
+            for (w=1; w<maxW+1; w++) {
+                U32 curr = nextRankVal;
+                nextRankVal += wksp->rankStats[w] << (w+rescale);
+                rankVal0[w] = curr;
+        }   }
+        {   U32 const minBits = tableLog+1 - maxW;
+            U32 consumed;
+            for (consumed = minBits; consumed < maxTableLog - minBits + 1; consumed++) {
+                U32* const rankValPtr = wksp->rankVal[consumed];
+                U32 w;
+                for (w = 1; w < maxW+1; w++) {
+                    rankValPtr[w] = rankVal0[w] >> consumed;
+    }   }   }   }
+
+    HUF_fillDTableX2(dt, maxTableLog,
+                   wksp->sortedSymbol,
+                   wksp->rankStart0, wksp->rankVal, maxW,
+                   tableLog+1);
+
+    dtd.tableLog = (BYTE)maxTableLog;
+    dtd.tableType = 1;
+    ZSTD_memcpy(DTable, &dtd, sizeof(dtd));
+    return iSize;
+}
+
+
+FORCE_INLINE_TEMPLATE U32
+HUF_decodeSymbolX2(void* op, BIT_DStream_t* DStream, const HUF_DEltX2* dt, const U32 dtLog)
+{
+    size_t const val = BIT_lookBitsFast(DStream, dtLog);   /* note : dtLog >= 1 */
+    ZSTD_memcpy(op, &dt[val].sequence, 2);
+    BIT_skipBits(DStream, dt[val].nbBits);
+    return dt[val].length;
+}
+
+FORCE_INLINE_TEMPLATE U32
+HUF_decodeLastSymbolX2(void* op, BIT_DStream_t* DStream, const HUF_DEltX2* dt, const U32 dtLog)
+{
+    size_t const val = BIT_lookBitsFast(DStream, dtLog);   /* note : dtLog >= 1 */
+    ZSTD_memcpy(op, &dt[val].sequence, 1);
+    if (dt[val].length==1) {
+        BIT_skipBits(DStream, dt[val].nbBits);
+    } else {
+        if (DStream->bitsConsumed < (sizeof(DStream->bitContainer)*8)) {
+            BIT_skipBits(DStream, dt[val].nbBits);
+            if (DStream->bitsConsumed > (sizeof(DStream->bitContainer)*8))
+                /* ugly hack; works only because it's the last symbol. Note : can't easily extract nbBits from just this symbol */
+                DStream->bitsConsumed = (sizeof(DStream->bitContainer)*8);
+        }
+    }
+    return 1;
+}
+
+#define HUF_DECODE_SYMBOLX2_0(ptr, DStreamPtr) \
+    ptr += HUF_decodeSymbolX2(ptr, DStreamPtr, dt, dtLog)
+
+#define HUF_DECODE_SYMBOLX2_1(ptr, DStreamPtr) \
+    if (MEM_64bits() || (HUF_TABLELOG_MAX<=12)) \
+        ptr += HUF_decodeSymbolX2(ptr, DStreamPtr, dt, dtLog)
+
+#define HUF_DECODE_SYMBOLX2_2(ptr, DStreamPtr) \
+    if (MEM_64bits()) \
+        ptr += HUF_decodeSymbolX2(ptr, DStreamPtr, dt, dtLog)
+
+HINT_INLINE size_t
+HUF_decodeStreamX2(BYTE* p, BIT_DStream_t* bitDPtr, BYTE* const pEnd,
+                const HUF_DEltX2* const dt, const U32 dtLog)
+{
+    BYTE* const pStart = p;
+
+    /* up to 8 symbols at a time */
+    if ((size_t)(pEnd - p) >= sizeof(bitDPtr->bitContainer)) {
+        if (dtLog <= 11 && MEM_64bits()) {
+            /* up to 10 symbols at a time */
+            while ((BIT_reloadDStream(bitDPtr) == BIT_DStream_unfinished) & (p < pEnd-9)) {
+                HUF_DECODE_SYMBOLX2_0(p, bitDPtr);
+                HUF_DECODE_SYMBOLX2_0(p, bitDPtr);
+                HUF_DECODE_SYMBOLX2_0(p, bitDPtr);
+                HUF_DECODE_SYMBOLX2_0(p, bitDPtr);
+                HUF_DECODE_SYMBOLX2_0(p, bitDPtr);
+            }
+        } else {
+            /* up to 8 symbols at a time */
+            while ((BIT_reloadDStream(bitDPtr) == BIT_DStream_unfinished) & (p < pEnd-(sizeof(bitDPtr->bitContainer)-1))) {
+                HUF_DECODE_SYMBOLX2_2(p, bitDPtr);
+                HUF_DECODE_SYMBOLX2_1(p, bitDPtr);
+                HUF_DECODE_SYMBOLX2_2(p, bitDPtr);
+                HUF_DECODE_SYMBOLX2_0(p, bitDPtr);
+            }
+        }
+    } else {
+        BIT_reloadDStream(bitDPtr);
+    }
+
+    /* closer to end : up to 2 symbols at a time */
+    if ((size_t)(pEnd - p) >= 2) {
+        while ((BIT_reloadDStream(bitDPtr) == BIT_DStream_unfinished) & (p <= pEnd-2))
+            HUF_DECODE_SYMBOLX2_0(p, bitDPtr);
+
+        while (p <= pEnd-2)
+            HUF_DECODE_SYMBOLX2_0(p, bitDPtr);   /* no need to reload : reached the end of DStream */
+    }
+
+    if (p < pEnd)
+        p += HUF_decodeLastSymbolX2(p, bitDPtr, dt, dtLog);
+
+    return p-pStart;
+}
+
+FORCE_INLINE_TEMPLATE size_t
+HUF_decompress1X2_usingDTable_internal_body(
+          void* dst,  size_t dstSize,
+    const void* cSrc, size_t cSrcSize,
+    const HUF_DTable* DTable)
+{
+    BIT_DStream_t bitD;
+
+    /* Init */
+    CHECK_F( BIT_initDStream(&bitD, cSrc, cSrcSize) );
+
+    /* decode */
+    {   BYTE* const ostart = (BYTE*) dst;
+        BYTE* const oend = ostart + dstSize;
+        const void* const dtPtr = DTable+1;   /* force compiler to not use strict-aliasing */
+        const HUF_DEltX2* const dt = (const HUF_DEltX2*)dtPtr;
+        DTableDesc const dtd = HUF_getDTableDesc(DTable);
+        HUF_decodeStreamX2(ostart, &bitD, oend, dt, dtd.tableLog);
+    }
+
+    /* check */
+    if (!BIT_endOfDStream(&bitD)) return ERROR(corruption_detected);
+
+    /* decoded size */
+    return dstSize;
+}
+
+/* HUF_decompress4X2_usingDTable_internal_body():
+ * Conditions:
+ * @dstSize >= 6
+ */
+FORCE_INLINE_TEMPLATE size_t
+HUF_decompress4X2_usingDTable_internal_body(
+          void* dst,  size_t dstSize,
+    const void* cSrc, size_t cSrcSize,
+    const HUF_DTable* DTable)
+{
+    if (cSrcSize < 10) return ERROR(corruption_detected);   /* strict minimum : jump table + 1 byte per stream */
+
+    {   const BYTE* const istart = (const BYTE*) cSrc;
+        BYTE* const ostart = (BYTE*) dst;
+        BYTE* const oend = ostart + dstSize;
+        BYTE* const olimit = oend - (sizeof(size_t)-1);
+        const void* const dtPtr = DTable+1;
+        const HUF_DEltX2* const dt = (const HUF_DEltX2*)dtPtr;
+
+        /* Init */
+        BIT_DStream_t bitD1;
+        BIT_DStream_t bitD2;
+        BIT_DStream_t bitD3;
+        BIT_DStream_t bitD4;
+        size_t const length1 = MEM_readLE16(istart);
+        size_t const length2 = MEM_readLE16(istart+2);
+        size_t const length3 = MEM_readLE16(istart+4);
+        size_t const length4 = cSrcSize - (length1 + length2 + length3 + 6);
+        const BYTE* const istart1 = istart + 6;  /* jumpTable */
+        const BYTE* const istart2 = istart1 + length1;
+        const BYTE* const istart3 = istart2 + length2;
+        const BYTE* const istart4 = istart3 + length3;
+        size_t const segmentSize = (dstSize+3) / 4;
+        BYTE* const opStart2 = ostart + segmentSize;
+        BYTE* const opStart3 = opStart2 + segmentSize;
+        BYTE* const opStart4 = opStart3 + segmentSize;
+        BYTE* op1 = ostart;
+        BYTE* op2 = opStart2;
+        BYTE* op3 = opStart3;
+        BYTE* op4 = opStart4;
+        U32 endSignal = 1;
+        DTableDesc const dtd = HUF_getDTableDesc(DTable);
+        U32 const dtLog = dtd.tableLog;
+
+        if (length4 > cSrcSize) return ERROR(corruption_detected);  /* overflow */
+        if (opStart4 > oend) return ERROR(corruption_detected);     /* overflow */
+        if (dstSize < 6) return ERROR(corruption_detected);         /* stream 4-split doesn't work */
+        CHECK_F( BIT_initDStream(&bitD1, istart1, length1) );
+        CHECK_F( BIT_initDStream(&bitD2, istart2, length2) );
+        CHECK_F( BIT_initDStream(&bitD3, istart3, length3) );
+        CHECK_F( BIT_initDStream(&bitD4, istart4, length4) );
+
+        /* 16-32 symbols per loop (4-8 symbols per stream) */
+        if ((size_t)(oend - op4) >= sizeof(size_t)) {
+            for ( ; (endSignal) & (op4 < olimit); ) {
+#if defined(__clang__) && (defined(__x86_64__) || defined(__i386__))
+                HUF_DECODE_SYMBOLX2_2(op1, &bitD1);
+                HUF_DECODE_SYMBOLX2_1(op1, &bitD1);
+                HUF_DECODE_SYMBOLX2_2(op1, &bitD1);
+                HUF_DECODE_SYMBOLX2_0(op1, &bitD1);
+                HUF_DECODE_SYMBOLX2_2(op2, &bitD2);
+                HUF_DECODE_SYMBOLX2_1(op2, &bitD2);
+                HUF_DECODE_SYMBOLX2_2(op2, &bitD2);
+                HUF_DECODE_SYMBOLX2_0(op2, &bitD2);
+                endSignal &= BIT_reloadDStreamFast(&bitD1) == BIT_DStream_unfinished;
+                endSignal &= BIT_reloadDStreamFast(&bitD2) == BIT_DStream_unfinished;
+                HUF_DECODE_SYMBOLX2_2(op3, &bitD3);
+                HUF_DECODE_SYMBOLX2_1(op3, &bitD3);
+                HUF_DECODE_SYMBOLX2_2(op3, &bitD3);
+                HUF_DECODE_SYMBOLX2_0(op3, &bitD3);
+                HUF_DECODE_SYMBOLX2_2(op4, &bitD4);
+                HUF_DECODE_SYMBOLX2_1(op4, &bitD4);
+                HUF_DECODE_SYMBOLX2_2(op4, &bitD4);
+                HUF_DECODE_SYMBOLX2_0(op4, &bitD4);
+                endSignal &= BIT_reloadDStreamFast(&bitD3) == BIT_DStream_unfinished;
+                endSignal &= BIT_reloadDStreamFast(&bitD4) == BIT_DStream_unfinished;
+#else
+                HUF_DECODE_SYMBOLX2_2(op1, &bitD1);
+                HUF_DECODE_SYMBOLX2_2(op2, &bitD2);
+                HUF_DECODE_SYMBOLX2_2(op3, &bitD3);
+                HUF_DECODE_SYMBOLX2_2(op4, &bitD4);
+                HUF_DECODE_SYMBOLX2_1(op1, &bitD1);
+                HUF_DECODE_SYMBOLX2_1(op2, &bitD2);
+                HUF_DECODE_SYMBOLX2_1(op3, &bitD3);
+                HUF_DECODE_SYMBOLX2_1(op4, &bitD4);
+                HUF_DECODE_SYMBOLX2_2(op1, &bitD1);
+                HUF_DECODE_SYMBOLX2_2(op2, &bitD2);
+                HUF_DECODE_SYMBOLX2_2(op3, &bitD3);
+                HUF_DECODE_SYMBOLX2_2(op4, &bitD4);
+                HUF_DECODE_SYMBOLX2_0(op1, &bitD1);
+                HUF_DECODE_SYMBOLX2_0(op2, &bitD2);
+                HUF_DECODE_SYMBOLX2_0(op3, &bitD3);
+                HUF_DECODE_SYMBOLX2_0(op4, &bitD4);
+                endSignal = (U32)LIKELY((U32)
+                            (BIT_reloadDStreamFast(&bitD1) == BIT_DStream_unfinished)
+                        & (BIT_reloadDStreamFast(&bitD2) == BIT_DStream_unfinished)
+                        & (BIT_reloadDStreamFast(&bitD3) == BIT_DStream_unfinished)
+                        & (BIT_reloadDStreamFast(&bitD4) == BIT_DStream_unfinished));
+#endif
+            }
+        }
+
+        /* check corruption */
+        if (op1 > opStart2) return ERROR(corruption_detected);
+        if (op2 > opStart3) return ERROR(corruption_detected);
+        if (op3 > opStart4) return ERROR(corruption_detected);
+        /* note : op4 already verified within main loop */
+
+        /* finish bitStreams one by one */
+        HUF_decodeStreamX2(op1, &bitD1, opStart2, dt, dtLog);
+        HUF_decodeStreamX2(op2, &bitD2, opStart3, dt, dtLog);
+        HUF_decodeStreamX2(op3, &bitD3, opStart4, dt, dtLog);
+        HUF_decodeStreamX2(op4, &bitD4, oend,     dt, dtLog);
+
+        /* check */
+        { U32 const endCheck = BIT_endOfDStream(&bitD1) & BIT_endOfDStream(&bitD2) & BIT_endOfDStream(&bitD3) & BIT_endOfDStream(&bitD4);
+          if (!endCheck) return ERROR(corruption_detected); }
+
+        /* decoded size */
+        return dstSize;
+    }
+}
+
+#if HUF_NEED_BMI2_FUNCTION
+static BMI2_TARGET_ATTRIBUTE
+size_t HUF_decompress4X2_usingDTable_internal_bmi2(void* dst, size_t dstSize, void const* cSrc,
+                    size_t cSrcSize, HUF_DTable const* DTable) {
+    return HUF_decompress4X2_usingDTable_internal_body(dst, dstSize, cSrc, cSrcSize, DTable);
+}
+#endif
+
+static
+size_t HUF_decompress4X2_usingDTable_internal_default(void* dst, size_t dstSize, void const* cSrc,
+                    size_t cSrcSize, HUF_DTable const* DTable) {
+    return HUF_decompress4X2_usingDTable_internal_body(dst, dstSize, cSrc, cSrcSize, DTable);
+}
+
+#if ZSTD_ENABLE_ASM_X86_64_BMI2
+
+HUF_ASM_DECL void HUF_decompress4X2_usingDTable_internal_fast_asm_loop(HUF_DecompressFastArgs* args) ZSTDLIB_HIDDEN;
+
+#endif
+
+static HUF_FAST_BMI2_ATTRS
+void HUF_decompress4X2_usingDTable_internal_fast_c_loop(HUF_DecompressFastArgs* args)
+{
+    U64 bits[4];
+    BYTE const* ip[4];
+    BYTE* op[4];
+    BYTE* oend[4];
+    HUF_DEltX2 const* const dtable = (HUF_DEltX2 const*)args->dt;
+    BYTE const* const ilimit = args->ilimit;
+
+    /* Copy the arguments to local registers. */
+    ZSTD_memcpy(&bits, &args->bits, sizeof(bits));
+    ZSTD_memcpy((void*)(&ip), &args->ip, sizeof(ip));
+    ZSTD_memcpy(&op, &args->op, sizeof(op));
+
+    oend[0] = op[1];
+    oend[1] = op[2];
+    oend[2] = op[3];
+    oend[3] = args->oend;
+
+    assert(MEM_isLittleEndian());
+    assert(!MEM_32bits());
+
+    for (;;) {
+        BYTE* olimit;
+        int stream;
+        int symbol;
+
+        /* Assert loop preconditions */
+#ifndef NDEBUG
+        for (stream = 0; stream < 4; ++stream) {
+            assert(op[stream] <= oend[stream]);
+            assert(ip[stream] >= ilimit);
+        }
+#endif
+        /* Compute olimit */
+        {
+            /* Each loop does 5 table lookups for each of the 4 streams.
+             * Each table lookup consumes up to 11 bits of input, and produces
+             * up to 2 bytes of output.
+             */
+            /* We can consume up to 7 bytes of input per iteration per stream.
+             * We also know that each input pointer is >= ip[0]. So we can run
+             * iters loops before running out of input.
+             */
+            size_t iters = (size_t)(ip[0] - ilimit) / 7;
+            /* Each iteration can produce up to 10 bytes of output per stream.
+             * Each output stream my advance at different rates. So take the
+             * minimum number of safe iterations among all the output streams.
+             */
+            for (stream = 0; stream < 4; ++stream) {
+                size_t const oiters = (size_t)(oend[stream] - op[stream]) / 10;
+                iters = MIN(iters, oiters);
+            }
+
+            /* Each iteration produces at least 5 output symbols. So until
+             * op[3] crosses olimit, we know we haven't executed iters
+             * iterations yet. This saves us maintaining an iters counter,
+             * at the expense of computing the remaining # of iterations
+             * more frequently.
+             */
+            olimit = op[3] + (iters * 5);
+
+            /* Exit the fast decoding loop if we are too close to the end. */
+            if (op[3] + 10 > olimit)
+                break;
+
+            /* Exit the decoding loop if any input pointer has crossed the
+             * previous one. This indicates corruption, and a precondition
+             * to our loop is that ip[i] >= ip[0].
+             */
+            for (stream = 1; stream < 4; ++stream) {
+                if (ip[stream] < ip[stream - 1])
+                    goto _out;
+            }
+        }
+
+#ifndef NDEBUG
+        for (stream = 1; stream < 4; ++stream) {
+            assert(ip[stream] >= ip[stream - 1]);
+        }
+#endif
+
+        do {
+            /* Do 5 table lookups for each of the first 3 streams */
+            for (symbol = 0; symbol < 5; ++symbol) {
+                for (stream = 0; stream < 3; ++stream) {
+                    int const index = (int)(bits[stream] >> 53);
+                    HUF_DEltX2 const entry = dtable[index];
+                    MEM_write16(op[stream], entry.sequence);
+                    bits[stream] <<= (entry.nbBits);
+                    op[stream] += (entry.length);
+                }
+            }
+            /* Do 1 table lookup from the final stream */
+            {
+                int const index = (int)(bits[3] >> 53);
+                HUF_DEltX2 const entry = dtable[index];
+                MEM_write16(op[3], entry.sequence);
+                bits[3] <<= (entry.nbBits);
+                op[3] += (entry.length);
+            }
+            /* Do 4 table lookups from the final stream & reload bitstreams */
+            for (stream = 0; stream < 4; ++stream) {
+                /* Do a table lookup from the final stream.
+                 * This is interleaved with the reloading to reduce register
+                 * pressure. This shouldn't be necessary, but compilers can
+                 * struggle with codegen with high register pressure.
+                 */
+                {
+                    int const index = (int)(bits[3] >> 53);
+                    HUF_DEltX2 const entry = dtable[index];
+                    MEM_write16(op[3], entry.sequence);
+                    bits[3] <<= (entry.nbBits);
+                    op[3] += (entry.length);
+                }
+                /* Reload the bistreams. The final bitstream must be reloaded
+                 * after the 5th symbol was decoded.
+                 */
+                {
+                    int const ctz = ZSTD_countTrailingZeros64(bits[stream]);
+                    int const nbBits = ctz & 7;
+                    int const nbBytes = ctz >> 3;
+                    ip[stream] -= nbBytes;
+                    bits[stream] = MEM_read64(ip[stream]) | 1;
+                    bits[stream] <<= nbBits;
+                }
+            }
+        } while (op[3] < olimit);
+    }
+
+_out:
+
+    /* Save the final values of each of the state variables back to args. */
+    ZSTD_memcpy(&args->bits, &bits, sizeof(bits));
+    ZSTD_memcpy((void*)(&args->ip), &ip, sizeof(ip));
+    ZSTD_memcpy(&args->op, &op, sizeof(op));
+}
+
+
+static HUF_FAST_BMI2_ATTRS size_t
+HUF_decompress4X2_usingDTable_internal_fast(
+          void* dst,  size_t dstSize,
+    const void* cSrc, size_t cSrcSize,
+    const HUF_DTable* DTable,
+    HUF_DecompressFastLoopFn loopFn) {
+    void const* dt = DTable + 1;
+    const BYTE* const iend = (const BYTE*)cSrc + 6;
+    BYTE* const oend = (BYTE*)dst + dstSize;
+    HUF_DecompressFastArgs args;
+    {
+        size_t const ret = HUF_DecompressFastArgs_init(&args, dst, dstSize, cSrc, cSrcSize, DTable);
+        FORWARD_IF_ERROR(ret, "Failed to init asm args");
+        if (ret == 0)
+            return 0;
+    }
+
+    assert(args.ip[0] >= args.ilimit);
+    loopFn(&args);
+
+    /* note : op4 already verified within main loop */
+    assert(args.ip[0] >= iend);
+    assert(args.ip[1] >= iend);
+    assert(args.ip[2] >= iend);
+    assert(args.ip[3] >= iend);
+    assert(args.op[3] <= oend);
+    (void)iend;
+
+    /* finish bitStreams one by one */
+    {
+        size_t const segmentSize = (dstSize+3) / 4;
+        BYTE* segmentEnd = (BYTE*)dst;
+        int i;
+        for (i = 0; i < 4; ++i) {
+            BIT_DStream_t bit;
+            if (segmentSize <= (size_t)(oend - segmentEnd))
+                segmentEnd += segmentSize;
+            else
+                segmentEnd = oend;
+            FORWARD_IF_ERROR(HUF_initRemainingDStream(&bit, &args, i, segmentEnd), "corruption");
+            args.op[i] += HUF_decodeStreamX2(args.op[i], &bit, segmentEnd, (HUF_DEltX2 const*)dt, HUF_DECODER_FAST_TABLELOG);
+            if (args.op[i] != segmentEnd)
+                return ERROR(corruption_detected);
+        }
+    }
+
+    /* decoded size */
+    return dstSize;
+}
+
+static size_t HUF_decompress4X2_usingDTable_internal(void* dst, size_t dstSize, void const* cSrc,
+                    size_t cSrcSize, HUF_DTable const* DTable, int flags)
+{
+    HUF_DecompressUsingDTableFn fallbackFn = HUF_decompress4X2_usingDTable_internal_default;
+    HUF_DecompressFastLoopFn loopFn = HUF_decompress4X2_usingDTable_internal_fast_c_loop;
+
+#if DYNAMIC_BMI2
+    if (flags & HUF_flags_bmi2) {
+        fallbackFn = HUF_decompress4X2_usingDTable_internal_bmi2;
+# if ZSTD_ENABLE_ASM_X86_64_BMI2
+        if (!(flags & HUF_flags_disableAsm)) {
+            loopFn = HUF_decompress4X2_usingDTable_internal_fast_asm_loop;
+        }
+# endif
+    } else {
+        return fallbackFn(dst, dstSize, cSrc, cSrcSize, DTable);
+    }
+#endif
+
+#if ZSTD_ENABLE_ASM_X86_64_BMI2 && defined(__BMI2__)
+    if (!(flags & HUF_flags_disableAsm)) {
+        loopFn = HUF_decompress4X2_usingDTable_internal_fast_asm_loop;
+    }
+#endif
+
+    if (!(flags & HUF_flags_disableFast)) {
+        size_t const ret = HUF_decompress4X2_usingDTable_internal_fast(dst, dstSize, cSrc, cSrcSize, DTable, loopFn);
+        if (ret != 0)
+            return ret;
+    }
+    return fallbackFn(dst, dstSize, cSrc, cSrcSize, DTable);
+}
+
+HUF_DGEN(HUF_decompress1X2_usingDTable_internal)
+
+size_t HUF_decompress1X2_DCtx_wksp(HUF_DTable* DCtx, void* dst, size_t dstSize,
+                                   const void* cSrc, size_t cSrcSize,
+                                   void* workSpace, size_t wkspSize, int flags)
+{
+    const BYTE* ip = (const BYTE*) cSrc;
+
+    size_t const hSize = HUF_readDTableX2_wksp(DCtx, cSrc, cSrcSize,
+                                               workSpace, wkspSize, flags);
+    if (HUF_isError(hSize)) return hSize;
+    if (hSize >= cSrcSize) return ERROR(srcSize_wrong);
+    ip += hSize; cSrcSize -= hSize;
+
+    return HUF_decompress1X2_usingDTable_internal(dst, dstSize, ip, cSrcSize, DCtx, flags);
+}
+
+static size_t HUF_decompress4X2_DCtx_wksp(HUF_DTable* dctx, void* dst, size_t dstSize,
+                                   const void* cSrc, size_t cSrcSize,
+                                   void* workSpace, size_t wkspSize, int flags)
+{
+    const BYTE* ip = (const BYTE*) cSrc;
+
+    size_t hSize = HUF_readDTableX2_wksp(dctx, cSrc, cSrcSize,
+                                         workSpace, wkspSize, flags);
+    if (HUF_isError(hSize)) return hSize;
+    if (hSize >= cSrcSize) return ERROR(srcSize_wrong);
+    ip += hSize; cSrcSize -= hSize;
+
+    return HUF_decompress4X2_usingDTable_internal(dst, dstSize, ip, cSrcSize, dctx, flags);
+}
+
+#endif /* HUF_FORCE_DECOMPRESS_X1 */
+
+
+/* ***********************************/
+/* Universal decompression selectors */
+/* ***********************************/
+
+
+#if !defined(HUF_FORCE_DECOMPRESS_X1) && !defined(HUF_FORCE_DECOMPRESS_X2)
+typedef struct { U32 tableTime; U32 decode256Time; } algo_time_t;
+static const algo_time_t algoTime[16 /* Quantization */][2 /* single, double */] =
+{
+    /* single, double, quad */
+    {{0,0}, {1,1}},  /* Q==0 : impossible */
+    {{0,0}, {1,1}},  /* Q==1 : impossible */
+    {{ 150,216}, { 381,119}},   /* Q == 2 : 12-18% */
+    {{ 170,205}, { 514,112}},   /* Q == 3 : 18-25% */
+    {{ 177,199}, { 539,110}},   /* Q == 4 : 25-32% */
+    {{ 197,194}, { 644,107}},   /* Q == 5 : 32-38% */
+    {{ 221,192}, { 735,107}},   /* Q == 6 : 38-44% */
+    {{ 256,189}, { 881,106}},   /* Q == 7 : 44-50% */
+    {{ 359,188}, {1167,109}},   /* Q == 8 : 50-56% */
+    {{ 582,187}, {1570,114}},   /* Q == 9 : 56-62% */
+    {{ 688,187}, {1712,122}},   /* Q ==10 : 62-69% */
+    {{ 825,186}, {1965,136}},   /* Q ==11 : 69-75% */
+    {{ 976,185}, {2131,150}},   /* Q ==12 : 75-81% */
+    {{1180,186}, {2070,175}},   /* Q ==13 : 81-87% */
+    {{1377,185}, {1731,202}},   /* Q ==14 : 87-93% */
+    {{1412,185}, {1695,202}},   /* Q ==15 : 93-99% */
+};
+#endif
+
+/** HUF_selectDecoder() :
+ *  Tells which decoder is likely to decode faster,
+ *  based on a set of pre-computed metrics.
+ * @return : 0==HUF_decompress4X1, 1==HUF_decompress4X2 .
+ *  Assumption : 0 < dstSize <= 128 KB */
+U32 HUF_selectDecoder (size_t dstSize, size_t cSrcSize)
+{
+    assert(dstSize > 0);
+    assert(dstSize <= 128*1024);
+#if defined(HUF_FORCE_DECOMPRESS_X1)
+    (void)dstSize;
+    (void)cSrcSize;
+    return 0;
+#elif defined(HUF_FORCE_DECOMPRESS_X2)
+    (void)dstSize;
+    (void)cSrcSize;
+    return 1;
+#else
+    /* decoder timing evaluation */
+    {   U32 const Q = (cSrcSize >= dstSize) ? 15 : (U32)(cSrcSize * 16 / dstSize);   /* Q < 16 */
+        U32 const D256 = (U32)(dstSize >> 8);
+        U32 const DTime0 = algoTime[Q][0].tableTime + (algoTime[Q][0].decode256Time * D256);
+        U32 DTime1 = algoTime[Q][1].tableTime + (algoTime[Q][1].decode256Time * D256);
+        DTime1 += DTime1 >> 5;  /* small advantage to algorithm using less memory, to reduce cache eviction */
+        return DTime1 < DTime0;
+    }
+#endif
+}
+
+size_t HUF_decompress1X_DCtx_wksp(HUF_DTable* dctx, void* dst, size_t dstSize,
+                                  const void* cSrc, size_t cSrcSize,
+                                  void* workSpace, size_t wkspSize, int flags)
+{
+    /* validation checks */
+    if (dstSize == 0) return ERROR(dstSize_tooSmall);
+    if (cSrcSize > dstSize) return ERROR(corruption_detected);   /* invalid */
+    if (cSrcSize == dstSize) { ZSTD_memcpy(dst, cSrc, dstSize); return dstSize; }   /* not compressed */
+    if (cSrcSize == 1) { ZSTD_memset(dst, *(const BYTE*)cSrc, dstSize); return dstSize; }   /* RLE */
+
+    {   U32 const algoNb = HUF_selectDecoder(dstSize, cSrcSize);
+#if defined(HUF_FORCE_DECOMPRESS_X1)
+        (void)algoNb;
+        assert(algoNb == 0);
+        return HUF_decompress1X1_DCtx_wksp(dctx, dst, dstSize, cSrc,
+                                cSrcSize, workSpace, wkspSize, flags);
+#elif defined(HUF_FORCE_DECOMPRESS_X2)
+        (void)algoNb;
+        assert(algoNb == 1);
+        return HUF_decompress1X2_DCtx_wksp(dctx, dst, dstSize, cSrc,
+                                cSrcSize, workSpace, wkspSize, flags);
+#else
+        return algoNb ? HUF_decompress1X2_DCtx_wksp(dctx, dst, dstSize, cSrc,
+                                cSrcSize, workSpace, wkspSize, flags):
+                        HUF_decompress1X1_DCtx_wksp(dctx, dst, dstSize, cSrc,
+                                cSrcSize, workSpace, wkspSize, flags);
+#endif
+    }
+}
+
+
+size_t HUF_decompress1X_usingDTable(void* dst, size_t maxDstSize, const void* cSrc, size_t cSrcSize, const HUF_DTable* DTable, int flags)
+{
+    DTableDesc const dtd = HUF_getDTableDesc(DTable);
+#if defined(HUF_FORCE_DECOMPRESS_X1)
+    (void)dtd;
+    assert(dtd.tableType == 0);
+    return HUF_decompress1X1_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, flags);
+#elif defined(HUF_FORCE_DECOMPRESS_X2)
+    (void)dtd;
+    assert(dtd.tableType == 1);
+    return HUF_decompress1X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, flags);
+#else
+    return dtd.tableType ? HUF_decompress1X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, flags) :
+                           HUF_decompress1X1_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, flags);
+#endif
+}
+
+#ifndef HUF_FORCE_DECOMPRESS_X2
+size_t HUF_decompress1X1_DCtx_wksp(HUF_DTable* dctx, void* dst, size_t dstSize, const void* cSrc, size_t cSrcSize, void* workSpace, size_t wkspSize, int flags)
+{
+    const BYTE* ip = (const BYTE*) cSrc;
+
+    size_t const hSize = HUF_readDTableX1_wksp(dctx, cSrc, cSrcSize, workSpace, wkspSize, flags);
+    if (HUF_isError(hSize)) return hSize;
+    if (hSize >= cSrcSize) return ERROR(srcSize_wrong);
+    ip += hSize; cSrcSize -= hSize;
+
+    return HUF_decompress1X1_usingDTable_internal(dst, dstSize, ip, cSrcSize, dctx, flags);
+}
+#endif
+
+size_t HUF_decompress4X_usingDTable(void* dst, size_t maxDstSize, const void* cSrc, size_t cSrcSize, const HUF_DTable* DTable, int flags)
+{
+    DTableDesc const dtd = HUF_getDTableDesc(DTable);
+#if defined(HUF_FORCE_DECOMPRESS_X1)
+    (void)dtd;
+    assert(dtd.tableType == 0);
+    return HUF_decompress4X1_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, flags);
+#elif defined(HUF_FORCE_DECOMPRESS_X2)
+    (void)dtd;
+    assert(dtd.tableType == 1);
+    return HUF_decompress4X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, flags);
+#else
+    return dtd.tableType ? HUF_decompress4X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, flags) :
+                           HUF_decompress4X1_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, flags);
+#endif
+}
+
+size_t HUF_decompress4X_hufOnly_wksp(HUF_DTable* dctx, void* dst, size_t dstSize, const void* cSrc, size_t cSrcSize, void* workSpace, size_t wkspSize, int flags)
+{
+    /* validation checks */
+    if (dstSize == 0) return ERROR(dstSize_tooSmall);
+    if (cSrcSize == 0) return ERROR(corruption_detected);
+
+    {   U32 const algoNb = HUF_selectDecoder(dstSize, cSrcSize);
+#if defined(HUF_FORCE_DECOMPRESS_X1)
+        (void)algoNb;
+        assert(algoNb == 0);
+        return HUF_decompress4X1_DCtx_wksp(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize, flags);
+#elif defined(HUF_FORCE_DECOMPRESS_X2)
+        (void)algoNb;
+        assert(algoNb == 1);
+        return HUF_decompress4X2_DCtx_wksp(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize, flags);
+#else
+        return algoNb ? HUF_decompress4X2_DCtx_wksp(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize, flags) :
+                        HUF_decompress4X1_DCtx_wksp(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize, flags);
+#endif
+    }
+}
diff --git a/src/3rdparty/zstd/src/decompress/huf_decompress_amd64.S b/src/3rdparty/zstd/src/decompress/huf_decompress_amd64.S
new file mode 100644
index 0000000000..671624fe34
--- /dev/null
+++ b/src/3rdparty/zstd/src/decompress/huf_decompress_amd64.S
@@ -0,0 +1,576 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#include "../common/portability_macros.h"
+
+/* Stack marking
+ * ref: https://wiki.gentoo.org/wiki/Hardened/GNU_stack_quickstart
+ */
+#if defined(__ELF__) && defined(__GNUC__)
+.section .note.GNU-stack,"",%progbits
+#endif
+
+#if ZSTD_ENABLE_ASM_X86_64_BMI2
+
+/* Calling convention:
+ *
+ * %rdi contains the first argument: HUF_DecompressAsmArgs*.
+ * %rbp isn't maintained (no frame pointer).
+ * %rsp contains the stack pointer that grows down.
+ *      No red-zone is assumed, only addresses >= %rsp are used.
+ * All register contents are preserved.
+ *
+ * TODO: Support Windows calling convention.
+ */
+
+ZSTD_HIDE_ASM_FUNCTION(HUF_decompress4X1_usingDTable_internal_fast_asm_loop)
+ZSTD_HIDE_ASM_FUNCTION(HUF_decompress4X2_usingDTable_internal_fast_asm_loop)
+ZSTD_HIDE_ASM_FUNCTION(_HUF_decompress4X2_usingDTable_internal_fast_asm_loop)
+ZSTD_HIDE_ASM_FUNCTION(_HUF_decompress4X1_usingDTable_internal_fast_asm_loop)
+.global HUF_decompress4X1_usingDTable_internal_fast_asm_loop
+.global HUF_decompress4X2_usingDTable_internal_fast_asm_loop
+.global _HUF_decompress4X1_usingDTable_internal_fast_asm_loop
+.global _HUF_decompress4X2_usingDTable_internal_fast_asm_loop
+.text
+
+/* Sets up register mappings for clarity.
+ * op[], bits[], dtable & ip[0] each get their own register.
+ * ip[1,2,3] & olimit alias var[].
+ * %rax is a scratch register.
+ */
+
+#define op0    rsi
+#define op1    rbx
+#define op2    rcx
+#define op3    rdi
+
+#define ip0    r8
+#define ip1    r9
+#define ip2    r10
+#define ip3    r11
+
+#define bits0  rbp
+#define bits1  rdx
+#define bits2  r12
+#define bits3  r13
+#define dtable r14
+#define olimit r15
+
+/* var[] aliases ip[1,2,3] & olimit
+ * ip[1,2,3] are saved every iteration.
+ * olimit is only used in compute_olimit.
+ */
+#define var0   r15
+#define var1   r9
+#define var2   r10
+#define var3   r11
+
+/* 32-bit var registers */
+#define vard0  r15d
+#define vard1  r9d
+#define vard2  r10d
+#define vard3  r11d
+
+/* Calls X(N) for each stream 0, 1, 2, 3. */
+#define FOR_EACH_STREAM(X) \
+    X(0);                  \
+    X(1);                  \
+    X(2);                  \
+    X(3)
+
+/* Calls X(N, idx) for each stream 0, 1, 2, 3. */
+#define FOR_EACH_STREAM_WITH_INDEX(X, idx) \
+    X(0, idx);                             \
+    X(1, idx);                             \
+    X(2, idx);                             \
+    X(3, idx)
+
+/* Define both _HUF_* & HUF_* symbols because MacOS
+ * C symbols are prefixed with '_' & Linux symbols aren't.
+ */
+_HUF_decompress4X1_usingDTable_internal_fast_asm_loop:
+HUF_decompress4X1_usingDTable_internal_fast_asm_loop:
+    ZSTD_CET_ENDBRANCH
+    /* Save all registers - even if they are callee saved for simplicity. */
+    push %rax
+    push %rbx
+    push %rcx
+    push %rdx
+    push %rbp
+    push %rsi
+    push %rdi
+    push %r8
+    push %r9
+    push %r10
+    push %r11
+    push %r12
+    push %r13
+    push %r14
+    push %r15
+
+    /* Read HUF_DecompressAsmArgs* args from %rax */
+    movq %rdi, %rax
+    movq  0(%rax), %ip0
+    movq  8(%rax), %ip1
+    movq 16(%rax), %ip2
+    movq 24(%rax), %ip3
+    movq 32(%rax), %op0
+    movq 40(%rax), %op1
+    movq 48(%rax), %op2
+    movq 56(%rax), %op3
+    movq 64(%rax), %bits0
+    movq 72(%rax), %bits1
+    movq 80(%rax), %bits2
+    movq 88(%rax), %bits3
+    movq 96(%rax), %dtable
+    push %rax      /* argument */
+    push 104(%rax) /* ilimit */
+    push 112(%rax) /* oend */
+    push %olimit   /* olimit space */
+
+    subq $24, %rsp
+
+.L_4X1_compute_olimit:
+    /* Computes how many iterations we can do safely
+     * %r15, %rax may be clobbered
+     * rbx, rdx must be saved
+     * op3 & ip0 mustn't be clobbered
+     */
+    movq %rbx, 0(%rsp)
+    movq %rdx, 8(%rsp)
+
+    movq 32(%rsp), %rax /* rax = oend */
+    subq %op3,    %rax  /* rax = oend - op3 */
+
+    /* r15 = (oend - op3) / 5 */
+    movabsq $-3689348814741910323, %rdx
+    mulq %rdx
+    movq %rdx, %r15
+    shrq $2, %r15
+
+    movq %ip0,     %rax /* rax = ip0 */
+    movq 40(%rsp), %rdx /* rdx = ilimit */
+    subq %rdx,     %rax /* rax = ip0 - ilimit */
+    movq %rax,     %rbx /* rbx = ip0 - ilimit */
+
+    /* rdx = (ip0 - ilimit) / 7 */
+    movabsq $2635249153387078803, %rdx
+    mulq %rdx
+    subq %rdx, %rbx
+    shrq %rbx
+    addq %rbx, %rdx
+    shrq $2, %rdx
+
+    /* r15 = min(%rdx, %r15) */
+    cmpq %rdx, %r15
+    cmova %rdx, %r15
+
+    /* r15 = r15 * 5 */
+    leaq (%r15, %r15, 4), %r15
+
+    /* olimit = op3 + r15 */
+    addq %op3, %olimit
+
+    movq 8(%rsp), %rdx
+    movq 0(%rsp), %rbx
+
+    /* If (op3 + 20 > olimit) */
+    movq %op3, %rax    /* rax = op3 */
+    addq $20,  %rax    /* rax = op3 + 20 */
+    cmpq %rax, %olimit /* op3 + 20 > olimit */
+    jb .L_4X1_exit
+
+    /* If (ip1 < ip0) go to exit */
+    cmpq %ip0, %ip1
+    jb .L_4X1_exit
+
+    /* If (ip2 < ip1) go to exit */
+    cmpq %ip1, %ip2
+    jb .L_4X1_exit
+
+    /* If (ip3 < ip2) go to exit */
+    cmpq %ip2, %ip3
+    jb .L_4X1_exit
+
+/* Reads top 11 bits from bits[n]
+ * Loads dt[bits[n]] into var[n]
+ */
+#define GET_NEXT_DELT(n)                \
+    movq $53, %var##n;                  \
+    shrxq %var##n, %bits##n, %var##n;   \
+    movzwl (%dtable,%var##n,2),%vard##n
+
+/* var[n] must contain the DTable entry computed with GET_NEXT_DELT
+ * Moves var[n] to %rax
+ * bits[n] <<= var[n] & 63
+ * op[n][idx] = %rax >> 8
+ * %ah is a way to access bits [8, 16) of %rax
+ */
+#define DECODE_FROM_DELT(n, idx)       \
+    movq %var##n, %rax;                \
+    shlxq %var##n, %bits##n, %bits##n; \
+    movb %ah, idx(%op##n)
+
+/* Assumes GET_NEXT_DELT has been called.
+ * Calls DECODE_FROM_DELT then GET_NEXT_DELT
+ */
+#define DECODE_AND_GET_NEXT(n, idx) \
+    DECODE_FROM_DELT(n, idx);       \
+    GET_NEXT_DELT(n)                \
+
+/* // ctz & nbBytes is stored in bits[n]
+ * // nbBits is stored in %rax
+ * ctz  = CTZ[bits[n]]
+ * nbBits  = ctz & 7
+ * nbBytes = ctz >> 3
+ * op[n]  += 5
+ * ip[n]  -= nbBytes
+ * // Note: x86-64 is little-endian ==> no bswap
+ * bits[n] = MEM_readST(ip[n]) | 1
+ * bits[n] <<= nbBits
+ */
+#define RELOAD_BITS(n)             \
+    bsfq %bits##n, %bits##n;       \
+    movq %bits##n, %rax;           \
+    andq $7, %rax;                 \
+    shrq $3, %bits##n;             \
+    leaq 5(%op##n), %op##n;        \
+    subq %bits##n, %ip##n;         \
+    movq (%ip##n), %bits##n;       \
+    orq $1, %bits##n;              \
+    shlx %rax, %bits##n, %bits##n
+
+    /* Store clobbered variables on the stack */
+    movq %olimit, 24(%rsp)
+    movq %ip1, 0(%rsp)
+    movq %ip2, 8(%rsp)
+    movq %ip3, 16(%rsp)
+
+    /* Call GET_NEXT_DELT for each stream */
+    FOR_EACH_STREAM(GET_NEXT_DELT)
+
+    .p2align 6
+
+.L_4X1_loop_body:
+    /* Decode 5 symbols in each of the 4 streams (20 total)
+     * Must have called GET_NEXT_DELT for each stream
+     */
+    FOR_EACH_STREAM_WITH_INDEX(DECODE_AND_GET_NEXT, 0)
+    FOR_EACH_STREAM_WITH_INDEX(DECODE_AND_GET_NEXT, 1)
+    FOR_EACH_STREAM_WITH_INDEX(DECODE_AND_GET_NEXT, 2)
+    FOR_EACH_STREAM_WITH_INDEX(DECODE_AND_GET_NEXT, 3)
+    FOR_EACH_STREAM_WITH_INDEX(DECODE_FROM_DELT, 4)
+
+    /* Load ip[1,2,3] from stack (var[] aliases them)
+     * ip[] is needed for RELOAD_BITS
+     * Each will be stored back to the stack after RELOAD
+     */
+    movq 0(%rsp), %ip1
+    movq 8(%rsp), %ip2
+    movq 16(%rsp), %ip3
+
+    /* Reload each stream & fetch the next table entry
+     * to prepare for the next iteration
+     */
+    RELOAD_BITS(0)
+    GET_NEXT_DELT(0)
+
+    RELOAD_BITS(1)
+    movq %ip1, 0(%rsp)
+    GET_NEXT_DELT(1)
+
+    RELOAD_BITS(2)
+    movq %ip2, 8(%rsp)
+    GET_NEXT_DELT(2)
+
+    RELOAD_BITS(3)
+    movq %ip3, 16(%rsp)
+    GET_NEXT_DELT(3)
+
+    /* If op3 < olimit: continue the loop */
+    cmp %op3, 24(%rsp)
+    ja .L_4X1_loop_body
+
+    /* Reload ip[1,2,3] from stack */
+    movq 0(%rsp), %ip1
+    movq 8(%rsp), %ip2
+    movq 16(%rsp), %ip3
+
+    /* Re-compute olimit */
+    jmp .L_4X1_compute_olimit
+
+#undef GET_NEXT_DELT
+#undef DECODE_FROM_DELT
+#undef DECODE
+#undef RELOAD_BITS
+.L_4X1_exit:
+    addq $24, %rsp
+
+    /* Restore stack (oend & olimit) */
+    pop %rax /* olimit */
+    pop %rax /* oend */
+    pop %rax /* ilimit */
+    pop %rax /* arg */
+
+    /* Save ip / op / bits */
+    movq %ip0,  0(%rax)
+    movq %ip1,  8(%rax)
+    movq %ip2, 16(%rax)
+    movq %ip3, 24(%rax)
+    movq %op0, 32(%rax)
+    movq %op1, 40(%rax)
+    movq %op2, 48(%rax)
+    movq %op3, 56(%rax)
+    movq %bits0, 64(%rax)
+    movq %bits1, 72(%rax)
+    movq %bits2, 80(%rax)
+    movq %bits3, 88(%rax)
+
+    /* Restore registers */
+    pop %r15
+    pop %r14
+    pop %r13
+    pop %r12
+    pop %r11
+    pop %r10
+    pop %r9
+    pop %r8
+    pop %rdi
+    pop %rsi
+    pop %rbp
+    pop %rdx
+    pop %rcx
+    pop %rbx
+    pop %rax
+    ret
+
+_HUF_decompress4X2_usingDTable_internal_fast_asm_loop:
+HUF_decompress4X2_usingDTable_internal_fast_asm_loop:
+    ZSTD_CET_ENDBRANCH
+    /* Save all registers - even if they are callee saved for simplicity. */
+    push %rax
+    push %rbx
+    push %rcx
+    push %rdx
+    push %rbp
+    push %rsi
+    push %rdi
+    push %r8
+    push %r9
+    push %r10
+    push %r11
+    push %r12
+    push %r13
+    push %r14
+    push %r15
+
+    movq %rdi, %rax
+    movq  0(%rax), %ip0
+    movq  8(%rax), %ip1
+    movq 16(%rax), %ip2
+    movq 24(%rax), %ip3
+    movq 32(%rax), %op0
+    movq 40(%rax), %op1
+    movq 48(%rax), %op2
+    movq 56(%rax), %op3
+    movq 64(%rax), %bits0
+    movq 72(%rax), %bits1
+    movq 80(%rax), %bits2
+    movq 88(%rax), %bits3
+    movq 96(%rax), %dtable
+    push %rax      /* argument */
+    push %rax      /* olimit */
+    push 104(%rax) /* ilimit */
+
+    movq 112(%rax), %rax
+    push %rax /* oend3 */
+
+    movq %op3, %rax
+    push %rax /* oend2 */
+
+    movq %op2, %rax
+    push %rax /* oend1 */
+
+    movq %op1, %rax
+    push %rax /* oend0 */
+
+    /* Scratch space */
+    subq $8, %rsp
+
+.L_4X2_compute_olimit:
+    /* Computes how many iterations we can do safely
+     * %r15, %rax may be clobbered
+     * rdx must be saved
+     * op[1,2,3,4] & ip0 mustn't be clobbered
+     */
+    movq %rdx, 0(%rsp)
+
+    /* We can consume up to 7 input bytes each iteration. */
+    movq %ip0,     %rax  /* rax = ip0 */
+    movq 40(%rsp), %rdx  /* rdx = ilimit */
+    subq %rdx,     %rax  /* rax = ip0 - ilimit */
+    movq %rax,    %r15   /* r15 = ip0 - ilimit */
+
+    /* rdx = rax / 7 */
+    movabsq $2635249153387078803, %rdx
+    mulq %rdx
+    subq %rdx, %r15
+    shrq %r15
+    addq %r15, %rdx
+    shrq $2, %rdx
+
+    /* r15 = (ip0 - ilimit) / 7 */
+    movq %rdx, %r15
+
+    /* r15 = min(r15, min(oend0 - op0, oend1 - op1, oend2 - op2, oend3 - op3) / 10) */
+    movq 8(%rsp),  %rax /* rax = oend0 */
+    subq %op0,     %rax /* rax = oend0 - op0 */
+    movq 16(%rsp), %rdx /* rdx = oend1 */
+    subq %op1,     %rdx /* rdx = oend1 - op1 */
+
+    cmpq  %rax,    %rdx
+    cmova %rax,    %rdx /* rdx = min(%rdx, %rax) */
+
+    movq 24(%rsp), %rax /* rax = oend2 */
+    subq %op2,     %rax /* rax = oend2 - op2 */
+
+    cmpq  %rax,    %rdx
+    cmova %rax,    %rdx /* rdx = min(%rdx, %rax) */
+
+    movq 32(%rsp), %rax /* rax = oend3 */
+    subq %op3,     %rax /* rax = oend3 - op3 */
+
+    cmpq  %rax,    %rdx
+    cmova %rax,    %rdx /* rdx = min(%rdx, %rax) */
+
+    movabsq $-3689348814741910323, %rax
+    mulq %rdx
+    shrq $3,       %rdx /* rdx = rdx / 10 */
+
+    /* r15 = min(%rdx, %r15) */
+    cmpq  %rdx, %r15
+    cmova %rdx, %r15
+
+    /* olimit = op3 + 5 * r15 */
+    movq %r15, %rax
+    leaq (%op3, %rax, 4), %olimit
+    addq %rax, %olimit
+
+    movq 0(%rsp), %rdx
+
+    /* If (op3 + 10 > olimit) */
+    movq %op3, %rax    /* rax = op3 */
+    addq $10,  %rax    /* rax = op3 + 10 */
+    cmpq %rax, %olimit /* op3 + 10 > olimit */
+    jb .L_4X2_exit
+
+    /* If (ip1 < ip0) go to exit */
+    cmpq %ip0, %ip1
+    jb .L_4X2_exit
+
+    /* If (ip2 < ip1) go to exit */
+    cmpq %ip1, %ip2
+    jb .L_4X2_exit
+
+    /* If (ip3 < ip2) go to exit */
+    cmpq %ip2, %ip3
+    jb .L_4X2_exit
+
+#define DECODE(n, idx)              \
+    movq %bits##n, %rax;            \
+    shrq $53, %rax;                 \
+    movzwl 0(%dtable,%rax,4),%r8d;  \
+    movzbl 2(%dtable,%rax,4),%r15d; \
+    movzbl 3(%dtable,%rax,4),%eax;  \
+    movw %r8w, (%op##n);            \
+    shlxq %r15, %bits##n, %bits##n; \
+    addq %rax, %op##n
+
+#define RELOAD_BITS(n)              \
+    bsfq %bits##n, %bits##n;        \
+    movq %bits##n, %rax;            \
+    shrq $3, %bits##n;              \
+    andq $7, %rax;                  \
+    subq %bits##n, %ip##n;          \
+    movq (%ip##n), %bits##n;        \
+    orq $1, %bits##n;               \
+    shlxq %rax, %bits##n, %bits##n
+
+
+    movq %olimit, 48(%rsp)
+
+    .p2align 6
+
+.L_4X2_loop_body:
+    /* We clobber r8, so store it on the stack */
+    movq %r8, 0(%rsp)
+
+    /* Decode 5 symbols from each of the 4 streams (20 symbols total). */
+    FOR_EACH_STREAM_WITH_INDEX(DECODE, 0)
+    FOR_EACH_STREAM_WITH_INDEX(DECODE, 1)
+    FOR_EACH_STREAM_WITH_INDEX(DECODE, 2)
+    FOR_EACH_STREAM_WITH_INDEX(DECODE, 3)
+    FOR_EACH_STREAM_WITH_INDEX(DECODE, 4)
+
+    /* Reload r8 */
+    movq 0(%rsp), %r8
+
+    FOR_EACH_STREAM(RELOAD_BITS)
+
+    cmp %op3, 48(%rsp)
+    ja .L_4X2_loop_body
+    jmp .L_4X2_compute_olimit
+
+#undef DECODE
+#undef RELOAD_BITS
+.L_4X2_exit:
+    addq $8, %rsp
+    /* Restore stack (oend & olimit) */
+    pop %rax /* oend0 */
+    pop %rax /* oend1 */
+    pop %rax /* oend2 */
+    pop %rax /* oend3 */
+    pop %rax /* ilimit */
+    pop %rax /* olimit */
+    pop %rax /* arg */
+
+    /* Save ip / op / bits */
+    movq %ip0,  0(%rax)
+    movq %ip1,  8(%rax)
+    movq %ip2, 16(%rax)
+    movq %ip3, 24(%rax)
+    movq %op0, 32(%rax)
+    movq %op1, 40(%rax)
+    movq %op2, 48(%rax)
+    movq %op3, 56(%rax)
+    movq %bits0, 64(%rax)
+    movq %bits1, 72(%rax)
+    movq %bits2, 80(%rax)
+    movq %bits3, 88(%rax)
+
+    /* Restore registers */
+    pop %r15
+    pop %r14
+    pop %r13
+    pop %r12
+    pop %r11
+    pop %r10
+    pop %r9
+    pop %r8
+    pop %rdi
+    pop %rsi
+    pop %rbp
+    pop %rdx
+    pop %rcx
+    pop %rbx
+    pop %rax
+    ret
+
+#endif
diff --git a/src/3rdparty/zstd/src/decompress/zstd_ddict.c b/src/3rdparty/zstd/src/decompress/zstd_ddict.c
new file mode 100644
index 0000000000..309ec0d036
--- /dev/null
+++ b/src/3rdparty/zstd/src/decompress/zstd_ddict.c
@@ -0,0 +1,244 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+/* zstd_ddict.c :
+ * concentrates all logic that needs to know the internals of ZSTD_DDict object */
+
+/*-*******************************************************
+*  Dependencies
+*********************************************************/
+#include "../common/allocations.h"  /* ZSTD_customMalloc, ZSTD_customFree */
+#include "../common/zstd_deps.h"   /* ZSTD_memcpy, ZSTD_memmove, ZSTD_memset */
+#include "../common/cpu.h"         /* bmi2 */
+#include "../common/mem.h"         /* low level memory routines */
+#define FSE_STATIC_LINKING_ONLY
+#include "../common/fse.h"
+#include "../common/huf.h"
+#include "zstd_decompress_internal.h"
+#include "zstd_ddict.h"
+
+#if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT>=1)
+#  include "../legacy/zstd_legacy.h"
+#endif
+
+
+
+/*-*******************************************************
+*  Types
+*********************************************************/
+struct ZSTD_DDict_s {
+    void* dictBuffer;
+    const void* dictContent;
+    size_t dictSize;
+    ZSTD_entropyDTables_t entropy;
+    U32 dictID;
+    U32 entropyPresent;
+    ZSTD_customMem cMem;
+};  /* typedef'd to ZSTD_DDict within "zstd.h" */
+
+const void* ZSTD_DDict_dictContent(const ZSTD_DDict* ddict)
+{
+    assert(ddict != NULL);
+    return ddict->dictContent;
+}
+
+size_t ZSTD_DDict_dictSize(const ZSTD_DDict* ddict)
+{
+    assert(ddict != NULL);
+    return ddict->dictSize;
+}
+
+void ZSTD_copyDDictParameters(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict)
+{
+    DEBUGLOG(4, "ZSTD_copyDDictParameters");
+    assert(dctx != NULL);
+    assert(ddict != NULL);
+    dctx->dictID = ddict->dictID;
+    dctx->prefixStart = ddict->dictContent;
+    dctx->virtualStart = ddict->dictContent;
+    dctx->dictEnd = (const BYTE*)ddict->dictContent + ddict->dictSize;
+    dctx->previousDstEnd = dctx->dictEnd;
+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+    dctx->dictContentBeginForFuzzing = dctx->prefixStart;
+    dctx->dictContentEndForFuzzing = dctx->previousDstEnd;
+#endif
+    if (ddict->entropyPresent) {
+        dctx->litEntropy = 1;
+        dctx->fseEntropy = 1;
+        dctx->LLTptr = ddict->entropy.LLTable;
+        dctx->MLTptr = ddict->entropy.MLTable;
+        dctx->OFTptr = ddict->entropy.OFTable;
+        dctx->HUFptr = ddict->entropy.hufTable;
+        dctx->entropy.rep[0] = ddict->entropy.rep[0];
+        dctx->entropy.rep[1] = ddict->entropy.rep[1];
+        dctx->entropy.rep[2] = ddict->entropy.rep[2];
+    } else {
+        dctx->litEntropy = 0;
+        dctx->fseEntropy = 0;
+    }
+}
+
+
+static size_t
+ZSTD_loadEntropy_intoDDict(ZSTD_DDict* ddict,
+                           ZSTD_dictContentType_e dictContentType)
+{
+    ddict->dictID = 0;
+    ddict->entropyPresent = 0;
+    if (dictContentType == ZSTD_dct_rawContent) return 0;
+
+    if (ddict->dictSize < 8) {
+        if (dictContentType == ZSTD_dct_fullDict)
+            return ERROR(dictionary_corrupted);   /* only accept specified dictionaries */
+        return 0;   /* pure content mode */
+    }
+    {   U32 const magic = MEM_readLE32(ddict->dictContent);
+        if (magic != ZSTD_MAGIC_DICTIONARY) {
+            if (dictContentType == ZSTD_dct_fullDict)
+                return ERROR(dictionary_corrupted);   /* only accept specified dictionaries */
+            return 0;   /* pure content mode */
+        }
+    }
+    ddict->dictID = MEM_readLE32((const char*)ddict->dictContent + ZSTD_FRAMEIDSIZE);
+
+    /* load entropy tables */
+    RETURN_ERROR_IF(ZSTD_isError(ZSTD_loadDEntropy(
+            &ddict->entropy, ddict->dictContent, ddict->dictSize)),
+        dictionary_corrupted, "");
+    ddict->entropyPresent = 1;
+    return 0;
+}
+
+
+static size_t ZSTD_initDDict_internal(ZSTD_DDict* ddict,
+                                      const void* dict, size_t dictSize,
+                                      ZSTD_dictLoadMethod_e dictLoadMethod,
+                                      ZSTD_dictContentType_e dictContentType)
+{
+    if ((dictLoadMethod == ZSTD_dlm_byRef) || (!dict) || (!dictSize)) {
+        ddict->dictBuffer = NULL;
+        ddict->dictContent = dict;
+        if (!dict) dictSize = 0;
+    } else {
+        void* const internalBuffer = ZSTD_customMalloc(dictSize, ddict->cMem);
+        ddict->dictBuffer = internalBuffer;
+        ddict->dictContent = internalBuffer;
+        if (!internalBuffer) return ERROR(memory_allocation);
+        ZSTD_memcpy(internalBuffer, dict, dictSize);
+    }
+    ddict->dictSize = dictSize;
+    ddict->entropy.hufTable[0] = (HUF_DTable)((ZSTD_HUFFDTABLE_CAPACITY_LOG)*0x1000001);  /* cover both little and big endian */
+
+    /* parse dictionary content */
+    FORWARD_IF_ERROR( ZSTD_loadEntropy_intoDDict(ddict, dictContentType) , "");
+
+    return 0;
+}
+
+ZSTD_DDict* ZSTD_createDDict_advanced(const void* dict, size_t dictSize,
+                                      ZSTD_dictLoadMethod_e dictLoadMethod,
+                                      ZSTD_dictContentType_e dictContentType,
+                                      ZSTD_customMem customMem)
+{
+    if ((!customMem.customAlloc) ^ (!customMem.customFree)) return NULL;
+
+    {   ZSTD_DDict* const ddict = (ZSTD_DDict*) ZSTD_customMalloc(sizeof(ZSTD_DDict), customMem);
+        if (ddict == NULL) return NULL;
+        ddict->cMem = customMem;
+        {   size_t const initResult = ZSTD_initDDict_internal(ddict,
+                                            dict, dictSize,
+                                            dictLoadMethod, dictContentType);
+            if (ZSTD_isError(initResult)) {
+                ZSTD_freeDDict(ddict);
+                return NULL;
+        }   }
+        return ddict;
+    }
+}
+
+/*! ZSTD_createDDict() :
+*   Create a digested dictionary, to start decompression without startup delay.
+*   `dict` content is copied inside DDict.
+*   Consequently, `dict` can be released after `ZSTD_DDict` creation */
+ZSTD_DDict* ZSTD_createDDict(const void* dict, size_t dictSize)
+{
+    ZSTD_customMem const allocator = { NULL, NULL, NULL };
+    return ZSTD_createDDict_advanced(dict, dictSize, ZSTD_dlm_byCopy, ZSTD_dct_auto, allocator);
+}
+
+/*! ZSTD_createDDict_byReference() :
+ *  Create a digested dictionary, to start decompression without startup delay.
+ *  Dictionary content is simply referenced, it will be accessed during decompression.
+ *  Warning : dictBuffer must outlive DDict (DDict must be freed before dictBuffer) */
+ZSTD_DDict* ZSTD_createDDict_byReference(const void* dictBuffer, size_t dictSize)
+{
+    ZSTD_customMem const allocator = { NULL, NULL, NULL };
+    return ZSTD_createDDict_advanced(dictBuffer, dictSize, ZSTD_dlm_byRef, ZSTD_dct_auto, allocator);
+}
+
+
+const ZSTD_DDict* ZSTD_initStaticDDict(
+                                void* sBuffer, size_t sBufferSize,
+                                const void* dict, size_t dictSize,
+                                ZSTD_dictLoadMethod_e dictLoadMethod,
+                                ZSTD_dictContentType_e dictContentType)
+{
+    size_t const neededSpace = sizeof(ZSTD_DDict)
+                             + (dictLoadMethod == ZSTD_dlm_byRef ? 0 : dictSize);
+    ZSTD_DDict* const ddict = (ZSTD_DDict*)sBuffer;
+    assert(sBuffer != NULL);
+    assert(dict != NULL);
+    if ((size_t)sBuffer & 7) return NULL;   /* 8-aligned */
+    if (sBufferSize < neededSpace) return NULL;
+    if (dictLoadMethod == ZSTD_dlm_byCopy) {
+        ZSTD_memcpy(ddict+1, dict, dictSize);  /* local copy */
+        dict = ddict+1;
+    }
+    if (ZSTD_isError( ZSTD_initDDict_internal(ddict,
+                                              dict, dictSize,
+                                              ZSTD_dlm_byRef, dictContentType) ))
+        return NULL;
+    return ddict;
+}
+
+
+size_t ZSTD_freeDDict(ZSTD_DDict* ddict)
+{
+    if (ddict==NULL) return 0;   /* support free on NULL */
+    {   ZSTD_customMem const cMem = ddict->cMem;
+        ZSTD_customFree(ddict->dictBuffer, cMem);
+        ZSTD_customFree(ddict, cMem);
+        return 0;
+    }
+}
+
+/*! ZSTD_estimateDDictSize() :
+ *  Estimate amount of memory that will be needed to create a dictionary for decompression.
+ *  Note : dictionary created by reference using ZSTD_dlm_byRef are smaller */
+size_t ZSTD_estimateDDictSize(size_t dictSize, ZSTD_dictLoadMethod_e dictLoadMethod)
+{
+    return sizeof(ZSTD_DDict) + (dictLoadMethod == ZSTD_dlm_byRef ? 0 : dictSize);
+}
+
+size_t ZSTD_sizeof_DDict(const ZSTD_DDict* ddict)
+{
+    if (ddict==NULL) return 0;   /* support sizeof on NULL */
+    return sizeof(*ddict) + (ddict->dictBuffer ? ddict->dictSize : 0) ;
+}
+
+/*! ZSTD_getDictID_fromDDict() :
+ *  Provides the dictID of the dictionary loaded into `ddict`.
+ *  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
+ *  Non-conformant dictionaries can still be loaded, but as content-only dictionaries. */
+unsigned ZSTD_getDictID_fromDDict(const ZSTD_DDict* ddict)
+{
+    if (ddict==NULL) return 0;
+    return ddict->dictID;
+}
diff --git a/src/3rdparty/zstd/src/decompress/zstd_ddict.h b/src/3rdparty/zstd/src/decompress/zstd_ddict.h
new file mode 100644
index 0000000000..c4ca8877a0
--- /dev/null
+++ b/src/3rdparty/zstd/src/decompress/zstd_ddict.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+
+#ifndef ZSTD_DDICT_H
+#define ZSTD_DDICT_H
+
+/*-*******************************************************
+ *  Dependencies
+ *********************************************************/
+#include "../common/zstd_deps.h"   /* size_t */
+#include "../zstd.h"     /* ZSTD_DDict, and several public functions */
+
+
+/*-*******************************************************
+ *  Interface
+ *********************************************************/
+
+/* note: several prototypes are already published in `zstd.h` :
+ * ZSTD_createDDict()
+ * ZSTD_createDDict_byReference()
+ * ZSTD_createDDict_advanced()
+ * ZSTD_freeDDict()
+ * ZSTD_initStaticDDict()
+ * ZSTD_sizeof_DDict()
+ * ZSTD_estimateDDictSize()
+ * ZSTD_getDictID_fromDict()
+ */
+
+const void* ZSTD_DDict_dictContent(const ZSTD_DDict* ddict);
+size_t ZSTD_DDict_dictSize(const ZSTD_DDict* ddict);
+
+void ZSTD_copyDDictParameters(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict);
+
+
+
+#endif /* ZSTD_DDICT_H */
diff --git a/src/3rdparty/zstd/src/decompress/zstd_decompress.c b/src/3rdparty/zstd/src/decompress/zstd_decompress.c
new file mode 100644
index 0000000000..7bc2713429
--- /dev/null
+++ b/src/3rdparty/zstd/src/decompress/zstd_decompress.c
@@ -0,0 +1,2355 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+
+/* ***************************************************************
+*  Tuning parameters
+*****************************************************************/
+/*!
+ * HEAPMODE :
+ * Select how default decompression function ZSTD_decompress() allocates its context,
+ * on stack (0), or into heap (1, default; requires malloc()).
+ * Note that functions with explicit context such as ZSTD_decompressDCtx() are unaffected.
+ */
+#ifndef ZSTD_HEAPMODE
+#  define ZSTD_HEAPMODE 1
+#endif
+
+/*!
+*  LEGACY_SUPPORT :
+*  if set to 1+, ZSTD_decompress() can decode older formats (v0.1+)
+*/
+#ifndef ZSTD_LEGACY_SUPPORT
+#  define ZSTD_LEGACY_SUPPORT 0
+#endif
+
+/*!
+ *  MAXWINDOWSIZE_DEFAULT :
+ *  maximum window size accepted by DStream __by default__.
+ *  Frames requiring more memory will be rejected.
+ *  It's possible to set a different limit using ZSTD_DCtx_setMaxWindowSize().
+ */
+#ifndef ZSTD_MAXWINDOWSIZE_DEFAULT
+#  define ZSTD_MAXWINDOWSIZE_DEFAULT (((U32)1 << ZSTD_WINDOWLOG_LIMIT_DEFAULT) + 1)
+#endif
+
+/*!
+ *  NO_FORWARD_PROGRESS_MAX :
+ *  maximum allowed nb of calls to ZSTD_decompressStream()
+ *  without any forward progress
+ *  (defined as: no byte read from input, and no byte flushed to output)
+ *  before triggering an error.
+ */
+#ifndef ZSTD_NO_FORWARD_PROGRESS_MAX
+#  define ZSTD_NO_FORWARD_PROGRESS_MAX 16
+#endif
+
+
+/*-*******************************************************
+*  Dependencies
+*********************************************************/
+#include "../common/allocations.h"  /* ZSTD_customMalloc, ZSTD_customCalloc, ZSTD_customFree */
+#include "../common/zstd_deps.h"   /* ZSTD_memcpy, ZSTD_memmove, ZSTD_memset */
+#include "../common/mem.h"         /* low level memory routines */
+#define FSE_STATIC_LINKING_ONLY
+#include "../common/fse.h"
+#include "../common/huf.h"
+#include "../common/xxhash.h" /* XXH64_reset, XXH64_update, XXH64_digest, XXH64 */
+#include "../common/zstd_internal.h"  /* blockProperties_t */
+#include "zstd_decompress_internal.h"   /* ZSTD_DCtx */
+#include "zstd_ddict.h"  /* ZSTD_DDictDictContent */
+#include "zstd_decompress_block.h"   /* ZSTD_decompressBlock_internal */
+#include "../common/bits.h"  /* ZSTD_highbit32 */
+
+#if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT>=1)
+#  include "../legacy/zstd_legacy.h"
+#endif
+
+
+
+/*************************************
+ * Multiple DDicts Hashset internals *
+ *************************************/
+
+#define DDICT_HASHSET_MAX_LOAD_FACTOR_COUNT_MULT 4
+#define DDICT_HASHSET_MAX_LOAD_FACTOR_SIZE_MULT 3  /* These two constants represent SIZE_MULT/COUNT_MULT load factor without using a float.
+                                                    * Currently, that means a 0.75 load factor.
+                                                    * So, if count * COUNT_MULT / size * SIZE_MULT != 0, then we've exceeded
+                                                    * the load factor of the ddict hash set.
+                                                    */
+
+#define DDICT_HASHSET_TABLE_BASE_SIZE 64
+#define DDICT_HASHSET_RESIZE_FACTOR 2
+
+/* Hash function to determine starting position of dict insertion within the table
+ * Returns an index between [0, hashSet->ddictPtrTableSize]
+ */
+static size_t ZSTD_DDictHashSet_getIndex(const ZSTD_DDictHashSet* hashSet, U32 dictID) {
+    const U64 hash = XXH64(&dictID, sizeof(U32), 0);
+    /* DDict ptr table size is a multiple of 2, use size - 1 as mask to get index within [0, hashSet->ddictPtrTableSize) */
+    return hash & (hashSet->ddictPtrTableSize - 1);
+}
+
+/* Adds DDict to a hashset without resizing it.
+ * If inserting a DDict with a dictID that already exists in the set, replaces the one in the set.
+ * Returns 0 if successful, or a zstd error code if something went wrong.
+ */
+static size_t ZSTD_DDictHashSet_emplaceDDict(ZSTD_DDictHashSet* hashSet, const ZSTD_DDict* ddict) {
+    const U32 dictID = ZSTD_getDictID_fromDDict(ddict);
+    size_t idx = ZSTD_DDictHashSet_getIndex(hashSet, dictID);
+    const size_t idxRangeMask = hashSet->ddictPtrTableSize - 1;
+    RETURN_ERROR_IF(hashSet->ddictPtrCount == hashSet->ddictPtrTableSize, GENERIC, "Hash set is full!");
+    DEBUGLOG(4, "Hashed index: for dictID: %u is %zu", dictID, idx);
+    while (hashSet->ddictPtrTable[idx] != NULL) {
+        /* Replace existing ddict if inserting ddict with same dictID */
+        if (ZSTD_getDictID_fromDDict(hashSet->ddictPtrTable[idx]) == dictID) {
+            DEBUGLOG(4, "DictID already exists, replacing rather than adding");
+            hashSet->ddictPtrTable[idx] = ddict;
+            return 0;
+        }
+        idx &= idxRangeMask;
+        idx++;
+    }
+    DEBUGLOG(4, "Final idx after probing for dictID %u is: %zu", dictID, idx);
+    hashSet->ddictPtrTable[idx] = ddict;
+    hashSet->ddictPtrCount++;
+    return 0;
+}
+
+/* Expands hash table by factor of DDICT_HASHSET_RESIZE_FACTOR and
+ * rehashes all values, allocates new table, frees old table.
+ * Returns 0 on success, otherwise a zstd error code.
+ */
+static size_t ZSTD_DDictHashSet_expand(ZSTD_DDictHashSet* hashSet, ZSTD_customMem customMem) {
+    size_t newTableSize = hashSet->ddictPtrTableSize * DDICT_HASHSET_RESIZE_FACTOR;
+    const ZSTD_DDict** newTable = (const ZSTD_DDict**)ZSTD_customCalloc(sizeof(ZSTD_DDict*) * newTableSize, customMem);
+    const ZSTD_DDict** oldTable = hashSet->ddictPtrTable;
+    size_t oldTableSize = hashSet->ddictPtrTableSize;
+    size_t i;
+
+    DEBUGLOG(4, "Expanding DDict hash table! Old size: %zu new size: %zu", oldTableSize, newTableSize);
+    RETURN_ERROR_IF(!newTable, memory_allocation, "Expanded hashset allocation failed!");
+    hashSet->ddictPtrTable = newTable;
+    hashSet->ddictPtrTableSize = newTableSize;
+    hashSet->ddictPtrCount = 0;
+    for (i = 0; i < oldTableSize; ++i) {
+        if (oldTable[i] != NULL) {
+            FORWARD_IF_ERROR(ZSTD_DDictHashSet_emplaceDDict(hashSet, oldTable[i]), "");
+        }
+    }
+    ZSTD_customFree((void*)oldTable, customMem);
+    DEBUGLOG(4, "Finished re-hash");
+    return 0;
+}
+
+/* Fetches a DDict with the given dictID
+ * Returns the ZSTD_DDict* with the requested dictID. If it doesn't exist, then returns NULL.
+ */
+static const ZSTD_DDict* ZSTD_DDictHashSet_getDDict(ZSTD_DDictHashSet* hashSet, U32 dictID) {
+    size_t idx = ZSTD_DDictHashSet_getIndex(hashSet, dictID);
+    const size_t idxRangeMask = hashSet->ddictPtrTableSize - 1;
+    DEBUGLOG(4, "Hashed index: for dictID: %u is %zu", dictID, idx);
+    for (;;) {
+        size_t currDictID = ZSTD_getDictID_fromDDict(hashSet->ddictPtrTable[idx]);
+        if (currDictID == dictID || currDictID == 0) {
+            /* currDictID == 0 implies a NULL ddict entry */
+            break;
+        } else {
+            idx &= idxRangeMask;    /* Goes to start of table when we reach the end */
+            idx++;
+        }
+    }
+    DEBUGLOG(4, "Final idx after probing for dictID %u is: %zu", dictID, idx);
+    return hashSet->ddictPtrTable[idx];
+}
+
+/* Allocates space for and returns a ddict hash set
+ * The hash set's ZSTD_DDict* table has all values automatically set to NULL to begin with.
+ * Returns NULL if allocation failed.
+ */
+static ZSTD_DDictHashSet* ZSTD_createDDictHashSet(ZSTD_customMem customMem) {
+    ZSTD_DDictHashSet* ret = (ZSTD_DDictHashSet*)ZSTD_customMalloc(sizeof(ZSTD_DDictHashSet), customMem);
+    DEBUGLOG(4, "Allocating new hash set");
+    if (!ret)
+        return NULL;
+    ret->ddictPtrTable = (const ZSTD_DDict**)ZSTD_customCalloc(DDICT_HASHSET_TABLE_BASE_SIZE * sizeof(ZSTD_DDict*), customMem);
+    if (!ret->ddictPtrTable) {
+        ZSTD_customFree(ret, customMem);
+        return NULL;
+    }
+    ret->ddictPtrTableSize = DDICT_HASHSET_TABLE_BASE_SIZE;
+    ret->ddictPtrCount = 0;
+    return ret;
+}
+
+/* Frees the table of ZSTD_DDict* within a hashset, then frees the hashset itself.
+ * Note: The ZSTD_DDict* within the table are NOT freed.
+ */
+static void ZSTD_freeDDictHashSet(ZSTD_DDictHashSet* hashSet, ZSTD_customMem customMem) {
+    DEBUGLOG(4, "Freeing ddict hash set");
+    if (hashSet && hashSet->ddictPtrTable) {
+        ZSTD_customFree((void*)hashSet->ddictPtrTable, customMem);
+    }
+    if (hashSet) {
+        ZSTD_customFree(hashSet, customMem);
+    }
+}
+
+/* Public function: Adds a DDict into the ZSTD_DDictHashSet, possibly triggering a resize of the hash set.
+ * Returns 0 on success, or a ZSTD error.
+ */
+static size_t ZSTD_DDictHashSet_addDDict(ZSTD_DDictHashSet* hashSet, const ZSTD_DDict* ddict, ZSTD_customMem customMem) {
+    DEBUGLOG(4, "Adding dict ID: %u to hashset with - Count: %zu Tablesize: %zu", ZSTD_getDictID_fromDDict(ddict), hashSet->ddictPtrCount, hashSet->ddictPtrTableSize);
+    if (hashSet->ddictPtrCount * DDICT_HASHSET_MAX_LOAD_FACTOR_COUNT_MULT / hashSet->ddictPtrTableSize * DDICT_HASHSET_MAX_LOAD_FACTOR_SIZE_MULT != 0) {
+        FORWARD_IF_ERROR(ZSTD_DDictHashSet_expand(hashSet, customMem), "");
+    }
+    FORWARD_IF_ERROR(ZSTD_DDictHashSet_emplaceDDict(hashSet, ddict), "");
+    return 0;
+}
+
+/*-*************************************************************
+*   Context management
+***************************************************************/
+size_t ZSTD_sizeof_DCtx (const ZSTD_DCtx* dctx)
+{
+    if (dctx==NULL) return 0;   /* support sizeof NULL */
+    return sizeof(*dctx)
+           + ZSTD_sizeof_DDict(dctx->ddictLocal)
+           + dctx->inBuffSize + dctx->outBuffSize;
+}
+
+size_t ZSTD_estimateDCtxSize(void) { return sizeof(ZSTD_DCtx); }
+
+
+static size_t ZSTD_startingInputLength(ZSTD_format_e format)
+{
+    size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);
+    /* only supports formats ZSTD_f_zstd1 and ZSTD_f_zstd1_magicless */
+    assert( (format == ZSTD_f_zstd1) || (format == ZSTD_f_zstd1_magicless) );
+    return startingInputLength;
+}
+
+static void ZSTD_DCtx_resetParameters(ZSTD_DCtx* dctx)
+{
+    assert(dctx->streamStage == zdss_init);
+    dctx->format = ZSTD_f_zstd1;
+    dctx->maxWindowSize = ZSTD_MAXWINDOWSIZE_DEFAULT;
+    dctx->outBufferMode = ZSTD_bm_buffered;
+    dctx->forceIgnoreChecksum = ZSTD_d_validateChecksum;
+    dctx->refMultipleDDicts = ZSTD_rmd_refSingleDDict;
+    dctx->disableHufAsm = 0;
+}
+
+static void ZSTD_initDCtx_internal(ZSTD_DCtx* dctx)
+{
+    dctx->staticSize  = 0;
+    dctx->ddict       = NULL;
+    dctx->ddictLocal  = NULL;
+    dctx->dictEnd     = NULL;
+    dctx->ddictIsCold = 0;
+    dctx->dictUses = ZSTD_dont_use;
+    dctx->inBuff      = NULL;
+    dctx->inBuffSize  = 0;
+    dctx->outBuffSize = 0;
+    dctx->streamStage = zdss_init;
+#if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT>=1)
+    dctx->legacyContext = NULL;
+    dctx->previousLegacyVersion = 0;
+#endif
+    dctx->noForwardProgress = 0;
+    dctx->oversizedDuration = 0;
+#if DYNAMIC_BMI2
+    dctx->bmi2 = ZSTD_cpuSupportsBmi2();
+#endif
+    dctx->ddictSet = NULL;
+    ZSTD_DCtx_resetParameters(dctx);
+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+    dctx->dictContentEndForFuzzing = NULL;
+#endif
+}
+
+ZSTD_DCtx* ZSTD_initStaticDCtx(void *workspace, size_t workspaceSize)
+{
+    ZSTD_DCtx* const dctx = (ZSTD_DCtx*) workspace;
+
+    if ((size_t)workspace & 7) return NULL;  /* 8-aligned */
+    if (workspaceSize < sizeof(ZSTD_DCtx)) return NULL;  /* minimum size */
+
+    ZSTD_initDCtx_internal(dctx);
+    dctx->staticSize = workspaceSize;
+    dctx->inBuff = (char*)(dctx+1);
+    return dctx;
+}
+
+static ZSTD_DCtx* ZSTD_createDCtx_internal(ZSTD_customMem customMem) {
+    if ((!customMem.customAlloc) ^ (!customMem.customFree)) return NULL;
+
+    {   ZSTD_DCtx* const dctx = (ZSTD_DCtx*)ZSTD_customMalloc(sizeof(*dctx), customMem);
+        if (!dctx) return NULL;
+        dctx->customMem = customMem;
+        ZSTD_initDCtx_internal(dctx);
+        return dctx;
+    }
+}
+
+ZSTD_DCtx* ZSTD_createDCtx_advanced(ZSTD_customMem customMem)
+{
+    return ZSTD_createDCtx_internal(customMem);
+}
+
+ZSTD_DCtx* ZSTD_createDCtx(void)
+{
+    DEBUGLOG(3, "ZSTD_createDCtx");
+    return ZSTD_createDCtx_internal(ZSTD_defaultCMem);
+}
+
+static void ZSTD_clearDict(ZSTD_DCtx* dctx)
+{
+    ZSTD_freeDDict(dctx->ddictLocal);
+    dctx->ddictLocal = NULL;
+    dctx->ddict = NULL;
+    dctx->dictUses = ZSTD_dont_use;
+}
+
+size_t ZSTD_freeDCtx(ZSTD_DCtx* dctx)
+{
+    if (dctx==NULL) return 0;   /* support free on NULL */
+    RETURN_ERROR_IF(dctx->staticSize, memory_allocation, "not compatible with static DCtx");
+    {   ZSTD_customMem const cMem = dctx->customMem;
+        ZSTD_clearDict(dctx);
+        ZSTD_customFree(dctx->inBuff, cMem);
+        dctx->inBuff = NULL;
+#if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT >= 1)
+        if (dctx->legacyContext)
+            ZSTD_freeLegacyStreamContext(dctx->legacyContext, dctx->previousLegacyVersion);
+#endif
+        if (dctx->ddictSet) {
+            ZSTD_freeDDictHashSet(dctx->ddictSet, cMem);
+            dctx->ddictSet = NULL;
+        }
+        ZSTD_customFree(dctx, cMem);
+        return 0;
+    }
+}
+
+/* no longer useful */
+void ZSTD_copyDCtx(ZSTD_DCtx* dstDCtx, const ZSTD_DCtx* srcDCtx)
+{
+    size_t const toCopy = (size_t)((char*)(&dstDCtx->inBuff) - (char*)dstDCtx);
+    ZSTD_memcpy(dstDCtx, srcDCtx, toCopy);  /* no need to copy workspace */
+}
+
+/* Given a dctx with a digested frame params, re-selects the correct ZSTD_DDict based on
+ * the requested dict ID from the frame. If there exists a reference to the correct ZSTD_DDict, then
+ * accordingly sets the ddict to be used to decompress the frame.
+ *
+ * If no DDict is found, then no action is taken, and the ZSTD_DCtx::ddict remains as-is.
+ *
+ * ZSTD_d_refMultipleDDicts must be enabled for this function to be called.
+ */
+static void ZSTD_DCtx_selectFrameDDict(ZSTD_DCtx* dctx) {
+    assert(dctx->refMultipleDDicts && dctx->ddictSet);
+    DEBUGLOG(4, "Adjusting DDict based on requested dict ID from frame");
+    if (dctx->ddict) {
+        const ZSTD_DDict* frameDDict = ZSTD_DDictHashSet_getDDict(dctx->ddictSet, dctx->fParams.dictID);
+        if (frameDDict) {
+            DEBUGLOG(4, "DDict found!");
+            ZSTD_clearDict(dctx);
+            dctx->dictID = dctx->fParams.dictID;
+            dctx->ddict = frameDDict;
+            dctx->dictUses = ZSTD_use_indefinitely;
+        }
+    }
+}
+
+
+/*-*************************************************************
+ *   Frame header decoding
+ ***************************************************************/
+
+/*! ZSTD_isFrame() :
+ *  Tells if the content of `buffer` starts with a valid Frame Identifier.
+ *  Note : Frame Identifier is 4 bytes. If `size < 4`, @return will always be 0.
+ *  Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled.
+ *  Note 3 : Skippable Frame Identifiers are considered valid. */
+unsigned ZSTD_isFrame(const void* buffer, size_t size)
+{
+    if (size < ZSTD_FRAMEIDSIZE) return 0;
+    {   U32 const magic = MEM_readLE32(buffer);
+        if (magic == ZSTD_MAGICNUMBER) return 1;
+        if ((magic & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) return 1;
+    }
+#if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT >= 1)
+    if (ZSTD_isLegacy(buffer, size)) return 1;
+#endif
+    return 0;
+}
+
+/*! ZSTD_isSkippableFrame() :
+ *  Tells if the content of `buffer` starts with a valid Frame Identifier for a skippable frame.
+ *  Note : Frame Identifier is 4 bytes. If `size < 4`, @return will always be 0.
+ */
+unsigned ZSTD_isSkippableFrame(const void* buffer, size_t size)
+{
+    if (size < ZSTD_FRAMEIDSIZE) return 0;
+    {   U32 const magic = MEM_readLE32(buffer);
+        if ((magic & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) return 1;
+    }
+    return 0;
+}
+
+/** ZSTD_frameHeaderSize_internal() :
+ *  srcSize must be large enough to reach header size fields.
+ *  note : only works for formats ZSTD_f_zstd1 and ZSTD_f_zstd1_magicless.
+ * @return : size of the Frame Header
+ *           or an error code, which can be tested with ZSTD_isError() */
+static size_t ZSTD_frameHeaderSize_internal(const void* src, size_t srcSize, ZSTD_format_e format)
+{
+    size_t const minInputSize = ZSTD_startingInputLength(format);
+    RETURN_ERROR_IF(srcSize < minInputSize, srcSize_wrong, "");
+
+    {   BYTE const fhd = ((const BYTE*)src)[minInputSize-1];
+        U32 const dictID= fhd & 3;
+        U32 const singleSegment = (fhd >> 5) & 1;
+        U32 const fcsId = fhd >> 6;
+        return minInputSize + !singleSegment
+             + ZSTD_did_fieldSize[dictID] + ZSTD_fcs_fieldSize[fcsId]
+             + (singleSegment && !fcsId);
+    }
+}
+
+/** ZSTD_frameHeaderSize() :
+ *  srcSize must be >= ZSTD_frameHeaderSize_prefix.
+ * @return : size of the Frame Header,
+ *           or an error code (if srcSize is too small) */
+size_t ZSTD_frameHeaderSize(const void* src, size_t srcSize)
+{
+    return ZSTD_frameHeaderSize_internal(src, srcSize, ZSTD_f_zstd1);
+}
+
+
+/** ZSTD_getFrameHeader_advanced() :
+ *  decode Frame Header, or require larger `srcSize`.
+ *  note : only works for formats ZSTD_f_zstd1 and ZSTD_f_zstd1_magicless
+ * @return : 0, `zfhPtr` is correctly filled,
+ *          >0, `srcSize` is too small, value is wanted `srcSize` amount,
+**           or an error code, which can be tested using ZSTD_isError() */
+size_t ZSTD_getFrameHeader_advanced(ZSTD_frameHeader* zfhPtr, const void* src, size_t srcSize, ZSTD_format_e format)
+{
+    const BYTE* ip = (const BYTE*)src;
+    size_t const minInputSize = ZSTD_startingInputLength(format);
+
+    DEBUGLOG(5, "ZSTD_getFrameHeader_advanced: minInputSize = %zu, srcSize = %zu", minInputSize, srcSize);
+
+    if (srcSize > 0) {
+        /* note : technically could be considered an assert(), since it's an invalid entry */
+        RETURN_ERROR_IF(src==NULL, GENERIC, "invalid parameter : src==NULL, but srcSize>0");
+    }
+    if (srcSize < minInputSize) {
+        if (srcSize > 0 && format != ZSTD_f_zstd1_magicless) {
+            /* when receiving less than @minInputSize bytes,
+             * control these bytes at least correspond to a supported magic number
+             * in order to error out early if they don't.
+            **/
+            size_t const toCopy = MIN(4, srcSize);
+            unsigned char hbuf[4]; MEM_writeLE32(hbuf, ZSTD_MAGICNUMBER);
+            assert(src != NULL);
+            ZSTD_memcpy(hbuf, src, toCopy);
+            if ( MEM_readLE32(hbuf) != ZSTD_MAGICNUMBER ) {
+                /* not a zstd frame : let's check if it's a skippable frame */
+                MEM_writeLE32(hbuf, ZSTD_MAGIC_SKIPPABLE_START);
+                ZSTD_memcpy(hbuf, src, toCopy);
+                if ((MEM_readLE32(hbuf) & ZSTD_MAGIC_SKIPPABLE_MASK) != ZSTD_MAGIC_SKIPPABLE_START) {
+                    RETURN_ERROR(prefix_unknown,
+                                "first bytes don't correspond to any supported magic number");
+        }   }   }
+        return minInputSize;
+    }
+
+    ZSTD_memset(zfhPtr, 0, sizeof(*zfhPtr));   /* not strictly necessary, but static analyzers may not understand that zfhPtr will be read only if return value is zero, since they are 2 different signals */
+    if ( (format != ZSTD_f_zstd1_magicless)
+      && (MEM_readLE32(src) != ZSTD_MAGICNUMBER) ) {
+        if ((MEM_readLE32(src) & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {
+            /* skippable frame */
+            if (srcSize < ZSTD_SKIPPABLEHEADERSIZE)
+                return ZSTD_SKIPPABLEHEADERSIZE; /* magic number + frame length */
+            ZSTD_memset(zfhPtr, 0, sizeof(*zfhPtr));
+            zfhPtr->frameContentSize = MEM_readLE32((const char *)src + ZSTD_FRAMEIDSIZE);
+            zfhPtr->frameType = ZSTD_skippableFrame;
+            return 0;
+        }
+        RETURN_ERROR(prefix_unknown, "");
+    }
+
+    /* ensure there is enough `srcSize` to fully read/decode frame header */
+    {   size_t const fhsize = ZSTD_frameHeaderSize_internal(src, srcSize, format);
+        if (srcSize < fhsize) return fhsize;
+        zfhPtr->headerSize = (U32)fhsize;
+    }
+
+    {   BYTE const fhdByte = ip[minInputSize-1];
+        size_t pos = minInputSize;
+        U32 const dictIDSizeCode = fhdByte&3;
+        U32 const checksumFlag = (fhdByte>>2)&1;
+        U32 const singleSegment = (fhdByte>>5)&1;
+        U32 const fcsID = fhdByte>>6;
+        U64 windowSize = 0;
+        U32 dictID = 0;
+        U64 frameContentSize = ZSTD_CONTENTSIZE_UNKNOWN;
+        RETURN_ERROR_IF((fhdByte & 0x08) != 0, frameParameter_unsupported,
+                        "reserved bits, must be zero");
+
+        if (!singleSegment) {
+            BYTE const wlByte = ip[pos++];
+            U32 const windowLog = (wlByte >> 3) + ZSTD_WINDOWLOG_ABSOLUTEMIN;
+            RETURN_ERROR_IF(windowLog > ZSTD_WINDOWLOG_MAX, frameParameter_windowTooLarge, "");
+            windowSize = (1ULL << windowLog);
+            windowSize += (windowSize >> 3) * (wlByte&7);
+        }
+        switch(dictIDSizeCode)
+        {
+            default:
+                assert(0);  /* impossible */
+                ZSTD_FALLTHROUGH;
+            case 0 : break;
+            case 1 : dictID = ip[pos]; pos++; break;
+            case 2 : dictID = MEM_readLE16(ip+pos); pos+=2; break;
+            case 3 : dictID = MEM_readLE32(ip+pos); pos+=4; break;
+        }
+        switch(fcsID)
+        {
+            default:
+                assert(0);  /* impossible */
+                ZSTD_FALLTHROUGH;
+            case 0 : if (singleSegment) frameContentSize = ip[pos]; break;
+            case 1 : frameContentSize = MEM_readLE16(ip+pos)+256; break;
+            case 2 : frameContentSize = MEM_readLE32(ip+pos); break;
+            case 3 : frameContentSize = MEM_readLE64(ip+pos); break;
+        }
+        if (singleSegment) windowSize = frameContentSize;
+
+        zfhPtr->frameType = ZSTD_frame;
+        zfhPtr->frameContentSize = frameContentSize;
+        zfhPtr->windowSize = windowSize;
+        zfhPtr->blockSizeMax = (unsigned) MIN(windowSize, ZSTD_BLOCKSIZE_MAX);
+        zfhPtr->dictID = dictID;
+        zfhPtr->checksumFlag = checksumFlag;
+    }
+    return 0;
+}
+
+/** ZSTD_getFrameHeader() :
+ *  decode Frame Header, or require larger `srcSize`.
+ *  note : this function does not consume input, it only reads it.
+ * @return : 0, `zfhPtr` is correctly filled,
+ *          >0, `srcSize` is too small, value is wanted `srcSize` amount,
+ *           or an error code, which can be tested using ZSTD_isError() */
+size_t ZSTD_getFrameHeader(ZSTD_frameHeader* zfhPtr, const void* src, size_t srcSize)
+{
+    return ZSTD_getFrameHeader_advanced(zfhPtr, src, srcSize, ZSTD_f_zstd1);
+}
+
+/** ZSTD_getFrameContentSize() :
+ *  compatible with legacy mode
+ * @return : decompressed size of the single frame pointed to be `src` if known, otherwise
+ *         - ZSTD_CONTENTSIZE_UNKNOWN if the size cannot be determined
+ *         - ZSTD_CONTENTSIZE_ERROR if an error occurred (e.g. invalid magic number, srcSize too small) */
+unsigned long long ZSTD_getFrameContentSize(const void *src, size_t srcSize)
+{
+#if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT >= 1)
+    if (ZSTD_isLegacy(src, srcSize)) {
+        unsigned long long const ret = ZSTD_getDecompressedSize_legacy(src, srcSize);
+        return ret == 0 ? ZSTD_CONTENTSIZE_UNKNOWN : ret;
+    }
+#endif
+    {   ZSTD_frameHeader zfh;
+        if (ZSTD_getFrameHeader(&zfh, src, srcSize) != 0)
+            return ZSTD_CONTENTSIZE_ERROR;
+        if (zfh.frameType == ZSTD_skippableFrame) {
+            return 0;
+        } else {
+            return zfh.frameContentSize;
+    }   }
+}
+
+static size_t readSkippableFrameSize(void const* src, size_t srcSize)
+{
+    size_t const skippableHeaderSize = ZSTD_SKIPPABLEHEADERSIZE;
+    U32 sizeU32;
+
+    RETURN_ERROR_IF(srcSize < ZSTD_SKIPPABLEHEADERSIZE, srcSize_wrong, "");
+
+    sizeU32 = MEM_readLE32((BYTE const*)src + ZSTD_FRAMEIDSIZE);
+    RETURN_ERROR_IF((U32)(sizeU32 + ZSTD_SKIPPABLEHEADERSIZE) < sizeU32,
+                    frameParameter_unsupported, "");
+    {   size_t const skippableSize = skippableHeaderSize + sizeU32;
+        RETURN_ERROR_IF(skippableSize > srcSize, srcSize_wrong, "");
+        return skippableSize;
+    }
+}
+
+/*! ZSTD_readSkippableFrame() :
+ * Retrieves content of a skippable frame, and writes it to dst buffer.
+ *
+ * The parameter magicVariant will receive the magicVariant that was supplied when the frame was written,
+ * i.e. magicNumber - ZSTD_MAGIC_SKIPPABLE_START.  This can be NULL if the caller is not interested
+ * in the magicVariant.
+ *
+ * Returns an error if destination buffer is not large enough, or if this is not a valid skippable frame.
+ *
+ * @return : number of bytes written or a ZSTD error.
+ */
+size_t ZSTD_readSkippableFrame(void* dst, size_t dstCapacity,
+                               unsigned* magicVariant,  /* optional, can be NULL */
+                         const void* src, size_t srcSize)
+{
+    RETURN_ERROR_IF(srcSize < ZSTD_SKIPPABLEHEADERSIZE, srcSize_wrong, "");
+
+    {   U32 const magicNumber = MEM_readLE32(src);
+        size_t skippableFrameSize = readSkippableFrameSize(src, srcSize);
+        size_t skippableContentSize = skippableFrameSize - ZSTD_SKIPPABLEHEADERSIZE;
+
+        /* check input validity */
+        RETURN_ERROR_IF(!ZSTD_isSkippableFrame(src, srcSize), frameParameter_unsupported, "");
+        RETURN_ERROR_IF(skippableFrameSize < ZSTD_SKIPPABLEHEADERSIZE || skippableFrameSize > srcSize, srcSize_wrong, "");
+        RETURN_ERROR_IF(skippableContentSize > dstCapacity, dstSize_tooSmall, "");
+
+        /* deliver payload */
+        if (skippableContentSize > 0  && dst != NULL)
+            ZSTD_memcpy(dst, (const BYTE *)src + ZSTD_SKIPPABLEHEADERSIZE, skippableContentSize);
+        if (magicVariant != NULL)
+            *magicVariant = magicNumber - ZSTD_MAGIC_SKIPPABLE_START;
+        return skippableContentSize;
+    }
+}
+
+/** ZSTD_findDecompressedSize() :
+ *  `srcSize` must be the exact length of some number of ZSTD compressed and/or
+ *      skippable frames
+ *  note: compatible with legacy mode
+ * @return : decompressed size of the frames contained */
+unsigned long long ZSTD_findDecompressedSize(const void* src, size_t srcSize)
+{
+    unsigned long long totalDstSize = 0;
+
+    while (srcSize >= ZSTD_startingInputLength(ZSTD_f_zstd1)) {
+        U32 const magicNumber = MEM_readLE32(src);
+
+        if ((magicNumber & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {
+            size_t const skippableSize = readSkippableFrameSize(src, srcSize);
+            if (ZSTD_isError(skippableSize)) return ZSTD_CONTENTSIZE_ERROR;
+            assert(skippableSize <= srcSize);
+
+            src = (const BYTE *)src + skippableSize;
+            srcSize -= skippableSize;
+            continue;
+        }
+
+        {   unsigned long long const fcs = ZSTD_getFrameContentSize(src, srcSize);
+            if (fcs >= ZSTD_CONTENTSIZE_ERROR) return fcs;
+
+            if (totalDstSize + fcs < totalDstSize)
+                return ZSTD_CONTENTSIZE_ERROR; /* check for overflow */
+            totalDstSize += fcs;
+        }
+        /* skip to next frame */
+        {   size_t const frameSrcSize = ZSTD_findFrameCompressedSize(src, srcSize);
+            if (ZSTD_isError(frameSrcSize)) return ZSTD_CONTENTSIZE_ERROR;
+            assert(frameSrcSize <= srcSize);
+
+            src = (const BYTE *)src + frameSrcSize;
+            srcSize -= frameSrcSize;
+        }
+    }  /* while (srcSize >= ZSTD_frameHeaderSize_prefix) */
+
+    if (srcSize) return ZSTD_CONTENTSIZE_ERROR;
+
+    return totalDstSize;
+}
+
+/** ZSTD_getDecompressedSize() :
+ *  compatible with legacy mode
+ * @return : decompressed size if known, 0 otherwise
+             note : 0 can mean any of the following :
+                   - frame content is empty
+                   - decompressed size field is not present in frame header
+                   - frame header unknown / not supported
+                   - frame header not complete (`srcSize` too small) */
+unsigned long long ZSTD_getDecompressedSize(const void* src, size_t srcSize)
+{
+    unsigned long long const ret = ZSTD_getFrameContentSize(src, srcSize);
+    ZSTD_STATIC_ASSERT(ZSTD_CONTENTSIZE_ERROR < ZSTD_CONTENTSIZE_UNKNOWN);
+    return (ret >= ZSTD_CONTENTSIZE_ERROR) ? 0 : ret;
+}
+
+
+/** ZSTD_decodeFrameHeader() :
+ * `headerSize` must be the size provided by ZSTD_frameHeaderSize().
+ * If multiple DDict references are enabled, also will choose the correct DDict to use.
+ * @return : 0 if success, or an error code, which can be tested using ZSTD_isError() */
+static size_t ZSTD_decodeFrameHeader(ZSTD_DCtx* dctx, const void* src, size_t headerSize)
+{
+    size_t const result = ZSTD_getFrameHeader_advanced(&(dctx->fParams), src, headerSize, dctx->format);
+    if (ZSTD_isError(result)) return result;    /* invalid header */
+    RETURN_ERROR_IF(result>0, srcSize_wrong, "headerSize too small");
+
+    /* Reference DDict requested by frame if dctx references multiple ddicts */
+    if (dctx->refMultipleDDicts == ZSTD_rmd_refMultipleDDicts && dctx->ddictSet) {
+        ZSTD_DCtx_selectFrameDDict(dctx);
+    }
+
+#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+    /* Skip the dictID check in fuzzing mode, because it makes the search
+     * harder.
+     */
+    RETURN_ERROR_IF(dctx->fParams.dictID && (dctx->dictID != dctx->fParams.dictID),
+                    dictionary_wrong, "");
+#endif
+    dctx->validateChecksum = (dctx->fParams.checksumFlag && !dctx->forceIgnoreChecksum) ? 1 : 0;
+    if (dctx->validateChecksum) XXH64_reset(&dctx->xxhState, 0);
+    dctx->processedCSize += headerSize;
+    return 0;
+}
+
+static ZSTD_frameSizeInfo ZSTD_errorFrameSizeInfo(size_t ret)
+{
+    ZSTD_frameSizeInfo frameSizeInfo;
+    frameSizeInfo.compressedSize = ret;
+    frameSizeInfo.decompressedBound = ZSTD_CONTENTSIZE_ERROR;
+    return frameSizeInfo;
+}
+
+static ZSTD_frameSizeInfo ZSTD_findFrameSizeInfo(const void* src, size_t srcSize)
+{
+    ZSTD_frameSizeInfo frameSizeInfo;
+    ZSTD_memset(&frameSizeInfo, 0, sizeof(ZSTD_frameSizeInfo));
+
+#if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT >= 1)
+    if (ZSTD_isLegacy(src, srcSize))
+        return ZSTD_findFrameSizeInfoLegacy(src, srcSize);
+#endif
+
+    if ((srcSize >= ZSTD_SKIPPABLEHEADERSIZE)
+        && (MEM_readLE32(src) & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {
+        frameSizeInfo.compressedSize = readSkippableFrameSize(src, srcSize);
+        assert(ZSTD_isError(frameSizeInfo.compressedSize) ||
+               frameSizeInfo.compressedSize <= srcSize);
+        return frameSizeInfo;
+    } else {
+        const BYTE* ip = (const BYTE*)src;
+        const BYTE* const ipstart = ip;
+        size_t remainingSize = srcSize;
+        size_t nbBlocks = 0;
+        ZSTD_frameHeader zfh;
+
+        /* Extract Frame Header */
+        {   size_t const ret = ZSTD_getFrameHeader(&zfh, src, srcSize);
+            if (ZSTD_isError(ret))
+                return ZSTD_errorFrameSizeInfo(ret);
+            if (ret > 0)
+                return ZSTD_errorFrameSizeInfo(ERROR(srcSize_wrong));
+        }
+
+        ip += zfh.headerSize;
+        remainingSize -= zfh.headerSize;
+
+        /* Iterate over each block */
+        while (1) {
+            blockProperties_t blockProperties;
+            size_t const cBlockSize = ZSTD_getcBlockSize(ip, remainingSize, &blockProperties);
+            if (ZSTD_isError(cBlockSize))
+                return ZSTD_errorFrameSizeInfo(cBlockSize);
+
+            if (ZSTD_blockHeaderSize + cBlockSize > remainingSize)
+                return ZSTD_errorFrameSizeInfo(ERROR(srcSize_wrong));
+
+            ip += ZSTD_blockHeaderSize + cBlockSize;
+            remainingSize -= ZSTD_blockHeaderSize + cBlockSize;
+            nbBlocks++;
+
+            if (blockProperties.lastBlock) break;
+        }
+
+        /* Final frame content checksum */
+        if (zfh.checksumFlag) {
+            if (remainingSize < 4)
+                return ZSTD_errorFrameSizeInfo(ERROR(srcSize_wrong));
+            ip += 4;
+        }
+
+        frameSizeInfo.nbBlocks = nbBlocks;
+        frameSizeInfo.compressedSize = (size_t)(ip - ipstart);
+        frameSizeInfo.decompressedBound = (zfh.frameContentSize != ZSTD_CONTENTSIZE_UNKNOWN)
+                                        ? zfh.frameContentSize
+                                        : (unsigned long long)nbBlocks * zfh.blockSizeMax;
+        return frameSizeInfo;
+    }
+}
+
+/** ZSTD_findFrameCompressedSize() :
+ *  compatible with legacy mode
+ *  `src` must point to the start of a ZSTD frame, ZSTD legacy frame, or skippable frame
+ *  `srcSize` must be at least as large as the frame contained
+ *  @return : the compressed size of the frame starting at `src` */
+size_t ZSTD_findFrameCompressedSize(const void *src, size_t srcSize)
+{
+    ZSTD_frameSizeInfo const frameSizeInfo = ZSTD_findFrameSizeInfo(src, srcSize);
+    return frameSizeInfo.compressedSize;
+}
+
+/** ZSTD_decompressBound() :
+ *  compatible with legacy mode
+ *  `src` must point to the start of a ZSTD frame or a skippeable frame
+ *  `srcSize` must be at least as large as the frame contained
+ *  @return : the maximum decompressed size of the compressed source
+ */
+unsigned long long ZSTD_decompressBound(const void* src, size_t srcSize)
+{
+    unsigned long long bound = 0;
+    /* Iterate over each frame */
+    while (srcSize > 0) {
+        ZSTD_frameSizeInfo const frameSizeInfo = ZSTD_findFrameSizeInfo(src, srcSize);
+        size_t const compressedSize = frameSizeInfo.compressedSize;
+        unsigned long long const decompressedBound = frameSizeInfo.decompressedBound;
+        if (ZSTD_isError(compressedSize) || decompressedBound == ZSTD_CONTENTSIZE_ERROR)
+            return ZSTD_CONTENTSIZE_ERROR;
+        assert(srcSize >= compressedSize);
+        src = (const BYTE*)src + compressedSize;
+        srcSize -= compressedSize;
+        bound += decompressedBound;
+    }
+    return bound;
+}
+
+size_t ZSTD_decompressionMargin(void const* src, size_t srcSize)
+{
+    size_t margin = 0;
+    unsigned maxBlockSize = 0;
+
+    /* Iterate over each frame */
+    while (srcSize > 0) {
+        ZSTD_frameSizeInfo const frameSizeInfo = ZSTD_findFrameSizeInfo(src, srcSize);
+        size_t const compressedSize = frameSizeInfo.compressedSize;
+        unsigned long long const decompressedBound = frameSizeInfo.decompressedBound;
+        ZSTD_frameHeader zfh;
+
+        FORWARD_IF_ERROR(ZSTD_getFrameHeader(&zfh, src, srcSize), "");
+        if (ZSTD_isError(compressedSize) || decompressedBound == ZSTD_CONTENTSIZE_ERROR)
+            return ERROR(corruption_detected);
+
+        if (zfh.frameType == ZSTD_frame) {
+            /* Add the frame header to our margin */
+            margin += zfh.headerSize;
+            /* Add the checksum to our margin */
+            margin += zfh.checksumFlag ? 4 : 0;
+            /* Add 3 bytes per block */
+            margin += 3 * frameSizeInfo.nbBlocks;
+
+            /* Compute the max block size */
+            maxBlockSize = MAX(maxBlockSize, zfh.blockSizeMax);
+        } else {
+            assert(zfh.frameType == ZSTD_skippableFrame);
+            /* Add the entire skippable frame size to our margin. */
+            margin += compressedSize;
+        }
+
+        assert(srcSize >= compressedSize);
+        src = (const BYTE*)src + compressedSize;
+        srcSize -= compressedSize;
+    }
+
+    /* Add the max block size back to the margin. */
+    margin += maxBlockSize;
+
+    return margin;
+}
+
+/*-*************************************************************
+ *   Frame decoding
+ ***************************************************************/
+
+/** ZSTD_insertBlock() :
+ *  insert `src` block into `dctx` history. Useful to track uncompressed blocks. */
+size_t ZSTD_insertBlock(ZSTD_DCtx* dctx, const void* blockStart, size_t blockSize)
+{
+    DEBUGLOG(5, "ZSTD_insertBlock: %u bytes", (unsigned)blockSize);
+    ZSTD_checkContinuity(dctx, blockStart, blockSize);
+    dctx->previousDstEnd = (const char*)blockStart + blockSize;
+    return blockSize;
+}
+
+
+static size_t ZSTD_copyRawBlock(void* dst, size_t dstCapacity,
+                          const void* src, size_t srcSize)
+{
+    DEBUGLOG(5, "ZSTD_copyRawBlock");
+    RETURN_ERROR_IF(srcSize > dstCapacity, dstSize_tooSmall, "");
+    if (dst == NULL) {
+        if (srcSize == 0) return 0;
+        RETURN_ERROR(dstBuffer_null, "");
+    }
+    ZSTD_memmove(dst, src, srcSize);
+    return srcSize;
+}
+
+static size_t ZSTD_setRleBlock(void* dst, size_t dstCapacity,
+                               BYTE b,
+                               size_t regenSize)
+{
+    RETURN_ERROR_IF(regenSize > dstCapacity, dstSize_tooSmall, "");
+    if (dst == NULL) {
+        if (regenSize == 0) return 0;
+        RETURN_ERROR(dstBuffer_null, "");
+    }
+    ZSTD_memset(dst, b, regenSize);
+    return regenSize;
+}
+
+static void ZSTD_DCtx_trace_end(ZSTD_DCtx const* dctx, U64 uncompressedSize, U64 compressedSize, unsigned streaming)
+{
+#if ZSTD_TRACE
+    if (dctx->traceCtx && ZSTD_trace_decompress_end != NULL) {
+        ZSTD_Trace trace;
+        ZSTD_memset(&trace, 0, sizeof(trace));
+        trace.version = ZSTD_VERSION_NUMBER;
+        trace.streaming = streaming;
+        if (dctx->ddict) {
+            trace.dictionaryID = ZSTD_getDictID_fromDDict(dctx->ddict);
+            trace.dictionarySize = ZSTD_DDict_dictSize(dctx->ddict);
+            trace.dictionaryIsCold = dctx->ddictIsCold;
+        }
+        trace.uncompressedSize = (size_t)uncompressedSize;
+        trace.compressedSize = (size_t)compressedSize;
+        trace.dctx = dctx;
+        ZSTD_trace_decompress_end(dctx->traceCtx, &trace);
+    }
+#else
+    (void)dctx;
+    (void)uncompressedSize;
+    (void)compressedSize;
+    (void)streaming;
+#endif
+}
+
+
+/*! ZSTD_decompressFrame() :
+ * @dctx must be properly initialized
+ *  will update *srcPtr and *srcSizePtr,
+ *  to make *srcPtr progress by one frame. */
+static size_t ZSTD_decompressFrame(ZSTD_DCtx* dctx,
+                                   void* dst, size_t dstCapacity,
+                             const void** srcPtr, size_t *srcSizePtr)
+{
+    const BYTE* const istart = (const BYTE*)(*srcPtr);
+    const BYTE* ip = istart;
+    BYTE* const ostart = (BYTE*)dst;
+    BYTE* const oend = dstCapacity != 0 ? ostart + dstCapacity : ostart;
+    BYTE* op = ostart;
+    size_t remainingSrcSize = *srcSizePtr;
+
+    DEBUGLOG(4, "ZSTD_decompressFrame (srcSize:%i)", (int)*srcSizePtr);
+
+    /* check */
+    RETURN_ERROR_IF(
+        remainingSrcSize < ZSTD_FRAMEHEADERSIZE_MIN(dctx->format)+ZSTD_blockHeaderSize,
+        srcSize_wrong, "");
+
+    /* Frame Header */
+    {   size_t const frameHeaderSize = ZSTD_frameHeaderSize_internal(
+                ip, ZSTD_FRAMEHEADERSIZE_PREFIX(dctx->format), dctx->format);
+        if (ZSTD_isError(frameHeaderSize)) return frameHeaderSize;
+        RETURN_ERROR_IF(remainingSrcSize < frameHeaderSize+ZSTD_blockHeaderSize,
+                        srcSize_wrong, "");
+        FORWARD_IF_ERROR( ZSTD_decodeFrameHeader(dctx, ip, frameHeaderSize) , "");
+        ip += frameHeaderSize; remainingSrcSize -= frameHeaderSize;
+    }
+
+    /* Loop on each block */
+    while (1) {
+        BYTE* oBlockEnd = oend;
+        size_t decodedSize;
+        blockProperties_t blockProperties;
+        size_t const cBlockSize = ZSTD_getcBlockSize(ip, remainingSrcSize, &blockProperties);
+        if (ZSTD_isError(cBlockSize)) return cBlockSize;
+
+        ip += ZSTD_blockHeaderSize;
+        remainingSrcSize -= ZSTD_blockHeaderSize;
+        RETURN_ERROR_IF(cBlockSize > remainingSrcSize, srcSize_wrong, "");
+
+        if (ip >= op && ip < oBlockEnd) {
+            /* We are decompressing in-place. Limit the output pointer so that we
+             * don't overwrite the block that we are currently reading. This will
+             * fail decompression if the input & output pointers aren't spaced
+             * far enough apart.
+             *
+             * This is important to set, even when the pointers are far enough
+             * apart, because ZSTD_decompressBlock_internal() can decide to store
+             * literals in the output buffer, after the block it is decompressing.
+             * Since we don't want anything to overwrite our input, we have to tell
+             * ZSTD_decompressBlock_internal to never write past ip.
+             *
+             * See ZSTD_allocateLiteralsBuffer() for reference.
+             */
+            oBlockEnd = op + (ip - op);
+        }
+
+        switch(blockProperties.blockType)
+        {
+        case bt_compressed:
+            decodedSize = ZSTD_decompressBlock_internal(dctx, op, (size_t)(oBlockEnd-op), ip, cBlockSize, /* frame */ 1, not_streaming);
+            break;
+        case bt_raw :
+            /* Use oend instead of oBlockEnd because this function is safe to overlap. It uses memmove. */
+            decodedSize = ZSTD_copyRawBlock(op, (size_t)(oend-op), ip, cBlockSize);
+            break;
+        case bt_rle :
+            decodedSize = ZSTD_setRleBlock(op, (size_t)(oBlockEnd-op), *ip, blockProperties.origSize);
+            break;
+        case bt_reserved :
+        default:
+            RETURN_ERROR(corruption_detected, "invalid block type");
+        }
+
+        if (ZSTD_isError(decodedSize)) return decodedSize;
+        if (dctx->validateChecksum)
+            XXH64_update(&dctx->xxhState, op, decodedSize);
+        if (decodedSize != 0)
+            op += decodedSize;
+        assert(ip != NULL);
+        ip += cBlockSize;
+        remainingSrcSize -= cBlockSize;
+        if (blockProperties.lastBlock) break;
+    }
+
+    if (dctx->fParams.frameContentSize != ZSTD_CONTENTSIZE_UNKNOWN) {
+        RETURN_ERROR_IF((U64)(op-ostart) != dctx->fParams.frameContentSize,
+                        corruption_detected, "");
+    }
+    if (dctx->fParams.checksumFlag) { /* Frame content checksum verification */
+        RETURN_ERROR_IF(remainingSrcSize<4, checksum_wrong, "");
+        if (!dctx->forceIgnoreChecksum) {
+            U32 const checkCalc = (U32)XXH64_digest(&dctx->xxhState);
+            U32 checkRead;
+            checkRead = MEM_readLE32(ip);
+            RETURN_ERROR_IF(checkRead != checkCalc, checksum_wrong, "");
+        }
+        ip += 4;
+        remainingSrcSize -= 4;
+    }
+    ZSTD_DCtx_trace_end(dctx, (U64)(op-ostart), (U64)(ip-istart), /* streaming */ 0);
+    /* Allow caller to get size read */
+    DEBUGLOG(4, "ZSTD_decompressFrame: decompressed frame of size %zi, consuming %zi bytes of input", op-ostart, ip - (const BYTE*)*srcPtr);
+    *srcPtr = ip;
+    *srcSizePtr = remainingSrcSize;
+    return (size_t)(op-ostart);
+}
+
+static size_t ZSTD_decompressMultiFrame(ZSTD_DCtx* dctx,
+                                        void* dst, size_t dstCapacity,
+                                  const void* src, size_t srcSize,
+                                  const void* dict, size_t dictSize,
+                                  const ZSTD_DDict* ddict)
+{
+    void* const dststart = dst;
+    int moreThan1Frame = 0;
+
+    DEBUGLOG(5, "ZSTD_decompressMultiFrame");
+    assert(dict==NULL || ddict==NULL);  /* either dict or ddict set, not both */
+
+    if (ddict) {
+        dict = ZSTD_DDict_dictContent(ddict);
+        dictSize = ZSTD_DDict_dictSize(ddict);
+    }
+
+    while (srcSize >= ZSTD_startingInputLength(dctx->format)) {
+
+#if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT >= 1)
+        if (ZSTD_isLegacy(src, srcSize)) {
+            size_t decodedSize;
+            size_t const frameSize = ZSTD_findFrameCompressedSizeLegacy(src, srcSize);
+            if (ZSTD_isError(frameSize)) return frameSize;
+            RETURN_ERROR_IF(dctx->staticSize, memory_allocation,
+                "legacy support is not compatible with static dctx");
+
+            decodedSize = ZSTD_decompressLegacy(dst, dstCapacity, src, frameSize, dict, dictSize);
+            if (ZSTD_isError(decodedSize)) return decodedSize;
+
+            assert(decodedSize <= dstCapacity);
+            dst = (BYTE*)dst + decodedSize;
+            dstCapacity -= decodedSize;
+
+            src = (const BYTE*)src + frameSize;
+            srcSize -= frameSize;
+
+            continue;
+        }
+#endif
+
+        if (srcSize >= 4) {
+            U32 const magicNumber = MEM_readLE32(src);
+            DEBUGLOG(5, "reading magic number %08X", (unsigned)magicNumber);
+            if ((magicNumber & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {
+                /* skippable frame detected : skip it */
+                size_t const skippableSize = readSkippableFrameSize(src, srcSize);
+                FORWARD_IF_ERROR(skippableSize, "invalid skippable frame");
+                assert(skippableSize <= srcSize);
+
+                src = (const BYTE *)src + skippableSize;
+                srcSize -= skippableSize;
+                continue; /* check next frame */
+        }   }
+
+        if (ddict) {
+            /* we were called from ZSTD_decompress_usingDDict */
+            FORWARD_IF_ERROR(ZSTD_decompressBegin_usingDDict(dctx, ddict), "");
+        } else {
+            /* this will initialize correctly with no dict if dict == NULL, so
+             * use this in all cases but ddict */
+            FORWARD_IF_ERROR(ZSTD_decompressBegin_usingDict(dctx, dict, dictSize), "");
+        }
+        ZSTD_checkContinuity(dctx, dst, dstCapacity);
+
+        {   const size_t res = ZSTD_decompressFrame(dctx, dst, dstCapacity,
+                                                    &src, &srcSize);
+            RETURN_ERROR_IF(
+                (ZSTD_getErrorCode(res) == ZSTD_error_prefix_unknown)
+             && (moreThan1Frame==1),
+                srcSize_wrong,
+                "At least one frame successfully completed, "
+                "but following bytes are garbage: "
+                "it's more likely to be a srcSize error, "
+                "specifying more input bytes than size of frame(s). "
+                "Note: one could be unlucky, it might be a corruption error instead, "
+                "happening right at the place where we expect zstd magic bytes. "
+                "But this is _much_ less likely than a srcSize field error.");
+            if (ZSTD_isError(res)) return res;
+            assert(res <= dstCapacity);
+            if (res != 0)
+                dst = (BYTE*)dst + res;
+            dstCapacity -= res;
+        }
+        moreThan1Frame = 1;
+    }  /* while (srcSize >= ZSTD_frameHeaderSize_prefix) */
+
+    RETURN_ERROR_IF(srcSize, srcSize_wrong, "input not entirely consumed");
+
+    return (size_t)((BYTE*)dst - (BYTE*)dststart);
+}
+
+size_t ZSTD_decompress_usingDict(ZSTD_DCtx* dctx,
+                                 void* dst, size_t dstCapacity,
+                           const void* src, size_t srcSize,
+                           const void* dict, size_t dictSize)
+{
+    return ZSTD_decompressMultiFrame(dctx, dst, dstCapacity, src, srcSize, dict, dictSize, NULL);
+}
+
+
+static ZSTD_DDict const* ZSTD_getDDict(ZSTD_DCtx* dctx)
+{
+    switch (dctx->dictUses) {
+    default:
+        assert(0 /* Impossible */);
+        ZSTD_FALLTHROUGH;
+    case ZSTD_dont_use:
+        ZSTD_clearDict(dctx);
+        return NULL;
+    case ZSTD_use_indefinitely:
+        return dctx->ddict;
+    case ZSTD_use_once:
+        dctx->dictUses = ZSTD_dont_use;
+        return dctx->ddict;
+    }
+}
+
+size_t ZSTD_decompressDCtx(ZSTD_DCtx* dctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize)
+{
+    return ZSTD_decompress_usingDDict(dctx, dst, dstCapacity, src, srcSize, ZSTD_getDDict(dctx));
+}
+
+
+size_t ZSTD_decompress(void* dst, size_t dstCapacity, const void* src, size_t srcSize)
+{
+#if defined(ZSTD_HEAPMODE) && (ZSTD_HEAPMODE>=1)
+    size_t regenSize;
+    ZSTD_DCtx* const dctx =  ZSTD_createDCtx_internal(ZSTD_defaultCMem);
+    RETURN_ERROR_IF(dctx==NULL, memory_allocation, "NULL pointer!");
+    regenSize = ZSTD_decompressDCtx(dctx, dst, dstCapacity, src, srcSize);
+    ZSTD_freeDCtx(dctx);
+    return regenSize;
+#else   /* stack mode */
+    ZSTD_DCtx dctx;
+    ZSTD_initDCtx_internal(&dctx);
+    return ZSTD_decompressDCtx(&dctx, dst, dstCapacity, src, srcSize);
+#endif
+}
+
+
+/*-**************************************
+*   Advanced Streaming Decompression API
+*   Bufferless and synchronous
+****************************************/
+size_t ZSTD_nextSrcSizeToDecompress(ZSTD_DCtx* dctx) { return dctx->expected; }
+
+/**
+ * Similar to ZSTD_nextSrcSizeToDecompress(), but when a block input can be streamed, we
+ * allow taking a partial block as the input. Currently only raw uncompressed blocks can
+ * be streamed.
+ *
+ * For blocks that can be streamed, this allows us to reduce the latency until we produce
+ * output, and avoid copying the input.
+ *
+ * @param inputSize - The total amount of input that the caller currently has.
+ */
+static size_t ZSTD_nextSrcSizeToDecompressWithInputSize(ZSTD_DCtx* dctx, size_t inputSize) {
+    if (!(dctx->stage == ZSTDds_decompressBlock || dctx->stage == ZSTDds_decompressLastBlock))
+        return dctx->expected;
+    if (dctx->bType != bt_raw)
+        return dctx->expected;
+    return BOUNDED(1, inputSize, dctx->expected);
+}
+
+ZSTD_nextInputType_e ZSTD_nextInputType(ZSTD_DCtx* dctx) {
+    switch(dctx->stage)
+    {
+    default:   /* should not happen */
+        assert(0);
+        ZSTD_FALLTHROUGH;
+    case ZSTDds_getFrameHeaderSize:
+        ZSTD_FALLTHROUGH;
+    case ZSTDds_decodeFrameHeader:
+        return ZSTDnit_frameHeader;
+    case ZSTDds_decodeBlockHeader:
+        return ZSTDnit_blockHeader;
+    case ZSTDds_decompressBlock:
+        return ZSTDnit_block;
+    case ZSTDds_decompressLastBlock:
+        return ZSTDnit_lastBlock;
+    case ZSTDds_checkChecksum:
+        return ZSTDnit_checksum;
+    case ZSTDds_decodeSkippableHeader:
+        ZSTD_FALLTHROUGH;
+    case ZSTDds_skipFrame:
+        return ZSTDnit_skippableFrame;
+    }
+}
+
+static int ZSTD_isSkipFrame(ZSTD_DCtx* dctx) { return dctx->stage == ZSTDds_skipFrame; }
+
+/** ZSTD_decompressContinue() :
+ *  srcSize : must be the exact nb of bytes expected (see ZSTD_nextSrcSizeToDecompress())
+ *  @return : nb of bytes generated into `dst` (necessarily <= `dstCapacity)
+ *            or an error code, which can be tested using ZSTD_isError() */
+size_t ZSTD_decompressContinue(ZSTD_DCtx* dctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize)
+{
+    DEBUGLOG(5, "ZSTD_decompressContinue (srcSize:%u)", (unsigned)srcSize);
+    /* Sanity check */
+    RETURN_ERROR_IF(srcSize != ZSTD_nextSrcSizeToDecompressWithInputSize(dctx, srcSize), srcSize_wrong, "not allowed");
+    ZSTD_checkContinuity(dctx, dst, dstCapacity);
+
+    dctx->processedCSize += srcSize;
+
+    switch (dctx->stage)
+    {
+    case ZSTDds_getFrameHeaderSize :
+        assert(src != NULL);
+        if (dctx->format == ZSTD_f_zstd1) {  /* allows header */
+            assert(srcSize >= ZSTD_FRAMEIDSIZE);  /* to read skippable magic number */
+            if ((MEM_readLE32(src) & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {        /* skippable frame */
+                ZSTD_memcpy(dctx->headerBuffer, src, srcSize);
+                dctx->expected = ZSTD_SKIPPABLEHEADERSIZE - srcSize;  /* remaining to load to get full skippable frame header */
+                dctx->stage = ZSTDds_decodeSkippableHeader;
+                return 0;
+        }   }
+        dctx->headerSize = ZSTD_frameHeaderSize_internal(src, srcSize, dctx->format);
+        if (ZSTD_isError(dctx->headerSize)) return dctx->headerSize;
+        ZSTD_memcpy(dctx->headerBuffer, src, srcSize);
+        dctx->expected = dctx->headerSize - srcSize;
+        dctx->stage = ZSTDds_decodeFrameHeader;
+        return 0;
+
+    case ZSTDds_decodeFrameHeader:
+        assert(src != NULL);
+        ZSTD_memcpy(dctx->headerBuffer + (dctx->headerSize - srcSize), src, srcSize);
+        FORWARD_IF_ERROR(ZSTD_decodeFrameHeader(dctx, dctx->headerBuffer, dctx->headerSize), "");
+        dctx->expected = ZSTD_blockHeaderSize;
+        dctx->stage = ZSTDds_decodeBlockHeader;
+        return 0;
+
+    case ZSTDds_decodeBlockHeader:
+        {   blockProperties_t bp;
+            size_t const cBlockSize = ZSTD_getcBlockSize(src, ZSTD_blockHeaderSize, &bp);
+            if (ZSTD_isError(cBlockSize)) return cBlockSize;
+            RETURN_ERROR_IF(cBlockSize > dctx->fParams.blockSizeMax, corruption_detected, "Block Size Exceeds Maximum");
+            dctx->expected = cBlockSize;
+            dctx->bType = bp.blockType;
+            dctx->rleSize = bp.origSize;
+            if (cBlockSize) {
+                dctx->stage = bp.lastBlock ? ZSTDds_decompressLastBlock : ZSTDds_decompressBlock;
+                return 0;
+            }
+            /* empty block */
+            if (bp.lastBlock) {
+                if (dctx->fParams.checksumFlag) {
+                    dctx->expected = 4;
+                    dctx->stage = ZSTDds_checkChecksum;
+                } else {
+                    dctx->expected = 0; /* end of frame */
+                    dctx->stage = ZSTDds_getFrameHeaderSize;
+                }
+            } else {
+                dctx->expected = ZSTD_blockHeaderSize;  /* jump to next header */
+                dctx->stage = ZSTDds_decodeBlockHeader;
+            }
+            return 0;
+        }
+
+    case ZSTDds_decompressLastBlock:
+    case ZSTDds_decompressBlock:
+        DEBUGLOG(5, "ZSTD_decompressContinue: case ZSTDds_decompressBlock");
+        {   size_t rSize;
+            switch(dctx->bType)
+            {
+            case bt_compressed:
+                DEBUGLOG(5, "ZSTD_decompressContinue: case bt_compressed");
+                rSize = ZSTD_decompressBlock_internal(dctx, dst, dstCapacity, src, srcSize, /* frame */ 1, is_streaming);
+                dctx->expected = 0;  /* Streaming not supported */
+                break;
+            case bt_raw :
+                assert(srcSize <= dctx->expected);
+                rSize = ZSTD_copyRawBlock(dst, dstCapacity, src, srcSize);
+                FORWARD_IF_ERROR(rSize, "ZSTD_copyRawBlock failed");
+                assert(rSize == srcSize);
+                dctx->expected -= rSize;
+                break;
+            case bt_rle :
+                rSize = ZSTD_setRleBlock(dst, dstCapacity, *(const BYTE*)src, dctx->rleSize);
+                dctx->expected = 0;  /* Streaming not supported */
+                break;
+            case bt_reserved :   /* should never happen */
+            default:
+                RETURN_ERROR(corruption_detected, "invalid block type");
+            }
+            FORWARD_IF_ERROR(rSize, "");
+            RETURN_ERROR_IF(rSize > dctx->fParams.blockSizeMax, corruption_detected, "Decompressed Block Size Exceeds Maximum");
+            DEBUGLOG(5, "ZSTD_decompressContinue: decoded size from block : %u", (unsigned)rSize);
+            dctx->decodedSize += rSize;
+            if (dctx->validateChecksum) XXH64_update(&dctx->xxhState, dst, rSize);
+            dctx->previousDstEnd = (char*)dst + rSize;
+
+            /* Stay on the same stage until we are finished streaming the block. */
+            if (dctx->expected > 0) {
+                return rSize;
+            }
+
+            if (dctx->stage == ZSTDds_decompressLastBlock) {   /* end of frame */
+                DEBUGLOG(4, "ZSTD_decompressContinue: decoded size from frame : %u", (unsigned)dctx->decodedSize);
+                RETURN_ERROR_IF(
+                    dctx->fParams.frameContentSize != ZSTD_CONTENTSIZE_UNKNOWN
+                 && dctx->decodedSize != dctx->fParams.frameContentSize,
+                    corruption_detected, "");
+                if (dctx->fParams.checksumFlag) {  /* another round for frame checksum */
+                    dctx->expected = 4;
+                    dctx->stage = ZSTDds_checkChecksum;
+                } else {
+                    ZSTD_DCtx_trace_end(dctx, dctx->decodedSize, dctx->processedCSize, /* streaming */ 1);
+                    dctx->expected = 0;   /* ends here */
+                    dctx->stage = ZSTDds_getFrameHeaderSize;
+                }
+            } else {
+                dctx->stage = ZSTDds_decodeBlockHeader;
+                dctx->expected = ZSTD_blockHeaderSize;
+            }
+            return rSize;
+        }
+
+    case ZSTDds_checkChecksum:
+        assert(srcSize == 4);  /* guaranteed by dctx->expected */
+        {
+            if (dctx->validateChecksum) {
+                U32 const h32 = (U32)XXH64_digest(&dctx->xxhState);
+                U32 const check32 = MEM_readLE32(src);
+                DEBUGLOG(4, "ZSTD_decompressContinue: checksum : calculated %08X :: %08X read", (unsigned)h32, (unsigned)check32);
+                RETURN_ERROR_IF(check32 != h32, checksum_wrong, "");
+            }
+            ZSTD_DCtx_trace_end(dctx, dctx->decodedSize, dctx->processedCSize, /* streaming */ 1);
+            dctx->expected = 0;
+            dctx->stage = ZSTDds_getFrameHeaderSize;
+            return 0;
+        }
+
+    case ZSTDds_decodeSkippableHeader:
+        assert(src != NULL);
+        assert(srcSize <= ZSTD_SKIPPABLEHEADERSIZE);
+        ZSTD_memcpy(dctx->headerBuffer + (ZSTD_SKIPPABLEHEADERSIZE - srcSize), src, srcSize);   /* complete skippable header */
+        dctx->expected = MEM_readLE32(dctx->headerBuffer + ZSTD_FRAMEIDSIZE);   /* note : dctx->expected can grow seriously large, beyond local buffer size */
+        dctx->stage = ZSTDds_skipFrame;
+        return 0;
+
+    case ZSTDds_skipFrame:
+        dctx->expected = 0;
+        dctx->stage = ZSTDds_getFrameHeaderSize;
+        return 0;
+
+    default:
+        assert(0);   /* impossible */
+        RETURN_ERROR(GENERIC, "impossible to reach");   /* some compilers require default to do something */
+    }
+}
+
+
+static size_t ZSTD_refDictContent(ZSTD_DCtx* dctx, const void* dict, size_t dictSize)
+{
+    dctx->dictEnd = dctx->previousDstEnd;
+    dctx->virtualStart = (const char*)dict - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));
+    dctx->prefixStart = dict;
+    dctx->previousDstEnd = (const char*)dict + dictSize;
+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+    dctx->dictContentBeginForFuzzing = dctx->prefixStart;
+    dctx->dictContentEndForFuzzing = dctx->previousDstEnd;
+#endif
+    return 0;
+}
+
+/*! ZSTD_loadDEntropy() :
+ *  dict : must point at beginning of a valid zstd dictionary.
+ * @return : size of entropy tables read */
+size_t
+ZSTD_loadDEntropy(ZSTD_entropyDTables_t* entropy,
+                  const void* const dict, size_t const dictSize)
+{
+    const BYTE* dictPtr = (const BYTE*)dict;
+    const BYTE* const dictEnd = dictPtr + dictSize;
+
+    RETURN_ERROR_IF(dictSize <= 8, dictionary_corrupted, "dict is too small");
+    assert(MEM_readLE32(dict) == ZSTD_MAGIC_DICTIONARY);   /* dict must be valid */
+    dictPtr += 8;   /* skip header = magic + dictID */
+
+    ZSTD_STATIC_ASSERT(offsetof(ZSTD_entropyDTables_t, OFTable) == offsetof(ZSTD_entropyDTables_t, LLTable) + sizeof(entropy->LLTable));
+    ZSTD_STATIC_ASSERT(offsetof(ZSTD_entropyDTables_t, MLTable) == offsetof(ZSTD_entropyDTables_t, OFTable) + sizeof(entropy->OFTable));
+    ZSTD_STATIC_ASSERT(sizeof(entropy->LLTable) + sizeof(entropy->OFTable) + sizeof(entropy->MLTable) >= HUF_DECOMPRESS_WORKSPACE_SIZE);
+    {   void* const workspace = &entropy->LLTable;   /* use fse tables as temporary workspace; implies fse tables are grouped together */
+        size_t const workspaceSize = sizeof(entropy->LLTable) + sizeof(entropy->OFTable) + sizeof(entropy->MLTable);
+#ifdef HUF_FORCE_DECOMPRESS_X1
+        /* in minimal huffman, we always use X1 variants */
+        size_t const hSize = HUF_readDTableX1_wksp(entropy->hufTable,
+                                                dictPtr, dictEnd - dictPtr,
+                                                workspace, workspaceSize, /* flags */ 0);
+#else
+        size_t const hSize = HUF_readDTableX2_wksp(entropy->hufTable,
+                                                dictPtr, (size_t)(dictEnd - dictPtr),
+                                                workspace, workspaceSize, /* flags */ 0);
+#endif
+        RETURN_ERROR_IF(HUF_isError(hSize), dictionary_corrupted, "");
+        dictPtr += hSize;
+    }
+
+    {   short offcodeNCount[MaxOff+1];
+        unsigned offcodeMaxValue = MaxOff, offcodeLog;
+        size_t const offcodeHeaderSize = FSE_readNCount(offcodeNCount, &offcodeMaxValue, &offcodeLog, dictPtr, (size_t)(dictEnd-dictPtr));
+        RETURN_ERROR_IF(FSE_isError(offcodeHeaderSize), dictionary_corrupted, "");
+        RETURN_ERROR_IF(offcodeMaxValue > MaxOff, dictionary_corrupted, "");
+        RETURN_ERROR_IF(offcodeLog > OffFSELog, dictionary_corrupted, "");
+        ZSTD_buildFSETable( entropy->OFTable,
+                            offcodeNCount, offcodeMaxValue,
+                            OF_base, OF_bits,
+                            offcodeLog,
+                            entropy->workspace, sizeof(entropy->workspace),
+                            /* bmi2 */0);
+        dictPtr += offcodeHeaderSize;
+    }
+
+    {   short matchlengthNCount[MaxML+1];
+        unsigned matchlengthMaxValue = MaxML, matchlengthLog;
+        size_t const matchlengthHeaderSize = FSE_readNCount(matchlengthNCount, &matchlengthMaxValue, &matchlengthLog, dictPtr, (size_t)(dictEnd-dictPtr));
+        RETURN_ERROR_IF(FSE_isError(matchlengthHeaderSize), dictionary_corrupted, "");
+        RETURN_ERROR_IF(matchlengthMaxValue > MaxML, dictionary_corrupted, "");
+        RETURN_ERROR_IF(matchlengthLog > MLFSELog, dictionary_corrupted, "");
+        ZSTD_buildFSETable( entropy->MLTable,
+                            matchlengthNCount, matchlengthMaxValue,
+                            ML_base, ML_bits,
+                            matchlengthLog,
+                            entropy->workspace, sizeof(entropy->workspace),
+                            /* bmi2 */ 0);
+        dictPtr += matchlengthHeaderSize;
+    }
+
+    {   short litlengthNCount[MaxLL+1];
+        unsigned litlengthMaxValue = MaxLL, litlengthLog;
+        size_t const litlengthHeaderSize = FSE_readNCount(litlengthNCount, &litlengthMaxValue, &litlengthLog, dictPtr, (size_t)(dictEnd-dictPtr));
+        RETURN_ERROR_IF(FSE_isError(litlengthHeaderSize), dictionary_corrupted, "");
+        RETURN_ERROR_IF(litlengthMaxValue > MaxLL, dictionary_corrupted, "");
+        RETURN_ERROR_IF(litlengthLog > LLFSELog, dictionary_corrupted, "");
+        ZSTD_buildFSETable( entropy->LLTable,
+                            litlengthNCount, litlengthMaxValue,
+                            LL_base, LL_bits,
+                            litlengthLog,
+                            entropy->workspace, sizeof(entropy->workspace),
+                            /* bmi2 */ 0);
+        dictPtr += litlengthHeaderSize;
+    }
+
+    RETURN_ERROR_IF(dictPtr+12 > dictEnd, dictionary_corrupted, "");
+    {   int i;
+        size_t const dictContentSize = (size_t)(dictEnd - (dictPtr+12));
+        for (i=0; i<3; i++) {
+            U32 const rep = MEM_readLE32(dictPtr); dictPtr += 4;
+            RETURN_ERROR_IF(rep==0 || rep > dictContentSize,
+                            dictionary_corrupted, "");
+            entropy->rep[i] = rep;
+    }   }
+
+    return (size_t)(dictPtr - (const BYTE*)dict);
+}
+
+static size_t ZSTD_decompress_insertDictionary(ZSTD_DCtx* dctx, const void* dict, size_t dictSize)
+{
+    if (dictSize < 8) return ZSTD_refDictContent(dctx, dict, dictSize);
+    {   U32 const magic = MEM_readLE32(dict);
+        if (magic != ZSTD_MAGIC_DICTIONARY) {
+            return ZSTD_refDictContent(dctx, dict, dictSize);   /* pure content mode */
+    }   }
+    dctx->dictID = MEM_readLE32((const char*)dict + ZSTD_FRAMEIDSIZE);
+
+    /* load entropy tables */
+    {   size_t const eSize = ZSTD_loadDEntropy(&dctx->entropy, dict, dictSize);
+        RETURN_ERROR_IF(ZSTD_isError(eSize), dictionary_corrupted, "");
+        dict = (const char*)dict + eSize;
+        dictSize -= eSize;
+    }
+    dctx->litEntropy = dctx->fseEntropy = 1;
+
+    /* reference dictionary content */
+    return ZSTD_refDictContent(dctx, dict, dictSize);
+}
+
+size_t ZSTD_decompressBegin(ZSTD_DCtx* dctx)
+{
+    assert(dctx != NULL);
+#if ZSTD_TRACE
+    dctx->traceCtx = (ZSTD_trace_decompress_begin != NULL) ? ZSTD_trace_decompress_begin(dctx) : 0;
+#endif
+    dctx->expected = ZSTD_startingInputLength(dctx->format);  /* dctx->format must be properly set */
+    dctx->stage = ZSTDds_getFrameHeaderSize;
+    dctx->processedCSize = 0;
+    dctx->decodedSize = 0;
+    dctx->previousDstEnd = NULL;
+    dctx->prefixStart = NULL;
+    dctx->virtualStart = NULL;
+    dctx->dictEnd = NULL;
+    dctx->entropy.hufTable[0] = (HUF_DTable)((ZSTD_HUFFDTABLE_CAPACITY_LOG)*0x1000001);  /* cover both little and big endian */
+    dctx->litEntropy = dctx->fseEntropy = 0;
+    dctx->dictID = 0;
+    dctx->bType = bt_reserved;
+    ZSTD_STATIC_ASSERT(sizeof(dctx->entropy.rep) == sizeof(repStartValue));
+    ZSTD_memcpy(dctx->entropy.rep, repStartValue, sizeof(repStartValue));  /* initial repcodes */
+    dctx->LLTptr = dctx->entropy.LLTable;
+    dctx->MLTptr = dctx->entropy.MLTable;
+    dctx->OFTptr = dctx->entropy.OFTable;
+    dctx->HUFptr = dctx->entropy.hufTable;
+    return 0;
+}
+
+size_t ZSTD_decompressBegin_usingDict(ZSTD_DCtx* dctx, const void* dict, size_t dictSize)
+{
+    FORWARD_IF_ERROR( ZSTD_decompressBegin(dctx) , "");
+    if (dict && dictSize)
+        RETURN_ERROR_IF(
+            ZSTD_isError(ZSTD_decompress_insertDictionary(dctx, dict, dictSize)),
+            dictionary_corrupted, "");
+    return 0;
+}
+
+
+/* ======   ZSTD_DDict   ====== */
+
+size_t ZSTD_decompressBegin_usingDDict(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict)
+{
+    DEBUGLOG(4, "ZSTD_decompressBegin_usingDDict");
+    assert(dctx != NULL);
+    if (ddict) {
+        const char* const dictStart = (const char*)ZSTD_DDict_dictContent(ddict);
+        size_t const dictSize = ZSTD_DDict_dictSize(ddict);
+        const void* const dictEnd = dictStart + dictSize;
+        dctx->ddictIsCold = (dctx->dictEnd != dictEnd);
+        DEBUGLOG(4, "DDict is %s",
+                    dctx->ddictIsCold ? "~cold~" : "hot!");
+    }
+    FORWARD_IF_ERROR( ZSTD_decompressBegin(dctx) , "");
+    if (ddict) {   /* NULL ddict is equivalent to no dictionary */
+        ZSTD_copyDDictParameters(dctx, ddict);
+    }
+    return 0;
+}
+
+/*! ZSTD_getDictID_fromDict() :
+ *  Provides the dictID stored within dictionary.
+ *  if @return == 0, the dictionary is not conformant with Zstandard specification.
+ *  It can still be loaded, but as a content-only dictionary. */
+unsigned ZSTD_getDictID_fromDict(const void* dict, size_t dictSize)
+{
+    if (dictSize < 8) return 0;
+    if (MEM_readLE32(dict) != ZSTD_MAGIC_DICTIONARY) return 0;
+    return MEM_readLE32((const char*)dict + ZSTD_FRAMEIDSIZE);
+}
+
+/*! ZSTD_getDictID_fromFrame() :
+ *  Provides the dictID required to decompress frame stored within `src`.
+ *  If @return == 0, the dictID could not be decoded.
+ *  This could for one of the following reasons :
+ *  - The frame does not require a dictionary (most common case).
+ *  - The frame was built with dictID intentionally removed.
+ *    Needed dictionary is a hidden piece of information.
+ *    Note : this use case also happens when using a non-conformant dictionary.
+ *  - `srcSize` is too small, and as a result, frame header could not be decoded.
+ *    Note : possible if `srcSize < ZSTD_FRAMEHEADERSIZE_MAX`.
+ *  - This is not a Zstandard frame.
+ *  When identifying the exact failure cause, it's possible to use
+ *  ZSTD_getFrameHeader(), which will provide a more precise error code. */
+unsigned ZSTD_getDictID_fromFrame(const void* src, size_t srcSize)
+{
+    ZSTD_frameHeader zfp = { 0, 0, 0, ZSTD_frame, 0, 0, 0, 0, 0 };
+    size_t const hError = ZSTD_getFrameHeader(&zfp, src, srcSize);
+    if (ZSTD_isError(hError)) return 0;
+    return zfp.dictID;
+}
+
+
+/*! ZSTD_decompress_usingDDict() :
+*   Decompression using a pre-digested Dictionary
+*   Use dictionary without significant overhead. */
+size_t ZSTD_decompress_usingDDict(ZSTD_DCtx* dctx,
+                                  void* dst, size_t dstCapacity,
+                            const void* src, size_t srcSize,
+                            const ZSTD_DDict* ddict)
+{
+    /* pass content and size in case legacy frames are encountered */
+    return ZSTD_decompressMultiFrame(dctx, dst, dstCapacity, src, srcSize,
+                                     NULL, 0,
+                                     ddict);
+}
+
+
+/*=====================================
+*   Streaming decompression
+*====================================*/
+
+ZSTD_DStream* ZSTD_createDStream(void)
+{
+    DEBUGLOG(3, "ZSTD_createDStream");
+    return ZSTD_createDCtx_internal(ZSTD_defaultCMem);
+}
+
+ZSTD_DStream* ZSTD_initStaticDStream(void *workspace, size_t workspaceSize)
+{
+    return ZSTD_initStaticDCtx(workspace, workspaceSize);
+}
+
+ZSTD_DStream* ZSTD_createDStream_advanced(ZSTD_customMem customMem)
+{
+    return ZSTD_createDCtx_internal(customMem);
+}
+
+size_t ZSTD_freeDStream(ZSTD_DStream* zds)
+{
+    return ZSTD_freeDCtx(zds);
+}
+
+
+/* ***  Initialization  *** */
+
+size_t ZSTD_DStreamInSize(void)  { return ZSTD_BLOCKSIZE_MAX + ZSTD_blockHeaderSize; }
+size_t ZSTD_DStreamOutSize(void) { return ZSTD_BLOCKSIZE_MAX; }
+
+size_t ZSTD_DCtx_loadDictionary_advanced(ZSTD_DCtx* dctx,
+                                   const void* dict, size_t dictSize,
+                                         ZSTD_dictLoadMethod_e dictLoadMethod,
+                                         ZSTD_dictContentType_e dictContentType)
+{
+    RETURN_ERROR_IF(dctx->streamStage != zdss_init, stage_wrong, "");
+    ZSTD_clearDict(dctx);
+    if (dict && dictSize != 0) {
+        dctx->ddictLocal = ZSTD_createDDict_advanced(dict, dictSize, dictLoadMethod, dictContentType, dctx->customMem);
+        RETURN_ERROR_IF(dctx->ddictLocal == NULL, memory_allocation, "NULL pointer!");
+        dctx->ddict = dctx->ddictLocal;
+        dctx->dictUses = ZSTD_use_indefinitely;
+    }
+    return 0;
+}
+
+size_t ZSTD_DCtx_loadDictionary_byReference(ZSTD_DCtx* dctx, const void* dict, size_t dictSize)
+{
+    return ZSTD_DCtx_loadDictionary_advanced(dctx, dict, dictSize, ZSTD_dlm_byRef, ZSTD_dct_auto);
+}
+
+size_t ZSTD_DCtx_loadDictionary(ZSTD_DCtx* dctx, const void* dict, size_t dictSize)
+{
+    return ZSTD_DCtx_loadDictionary_advanced(dctx, dict, dictSize, ZSTD_dlm_byCopy, ZSTD_dct_auto);
+}
+
+size_t ZSTD_DCtx_refPrefix_advanced(ZSTD_DCtx* dctx, const void* prefix, size_t prefixSize, ZSTD_dictContentType_e dictContentType)
+{
+    FORWARD_IF_ERROR(ZSTD_DCtx_loadDictionary_advanced(dctx, prefix, prefixSize, ZSTD_dlm_byRef, dictContentType), "");
+    dctx->dictUses = ZSTD_use_once;
+    return 0;
+}
+
+size_t ZSTD_DCtx_refPrefix(ZSTD_DCtx* dctx, const void* prefix, size_t prefixSize)
+{
+    return ZSTD_DCtx_refPrefix_advanced(dctx, prefix, prefixSize, ZSTD_dct_rawContent);
+}
+
+
+/* ZSTD_initDStream_usingDict() :
+ * return : expected size, aka ZSTD_startingInputLength().
+ * this function cannot fail */
+size_t ZSTD_initDStream_usingDict(ZSTD_DStream* zds, const void* dict, size_t dictSize)
+{
+    DEBUGLOG(4, "ZSTD_initDStream_usingDict");
+    FORWARD_IF_ERROR( ZSTD_DCtx_reset(zds, ZSTD_reset_session_only) , "");
+    FORWARD_IF_ERROR( ZSTD_DCtx_loadDictionary(zds, dict, dictSize) , "");
+    return ZSTD_startingInputLength(zds->format);
+}
+
+/* note : this variant can't fail */
+size_t ZSTD_initDStream(ZSTD_DStream* zds)
+{
+    DEBUGLOG(4, "ZSTD_initDStream");
+    FORWARD_IF_ERROR(ZSTD_DCtx_reset(zds, ZSTD_reset_session_only), "");
+    FORWARD_IF_ERROR(ZSTD_DCtx_refDDict(zds, NULL), "");
+    return ZSTD_startingInputLength(zds->format);
+}
+
+/* ZSTD_initDStream_usingDDict() :
+ * ddict will just be referenced, and must outlive decompression session
+ * this function cannot fail */
+size_t ZSTD_initDStream_usingDDict(ZSTD_DStream* dctx, const ZSTD_DDict* ddict)
+{
+    DEBUGLOG(4, "ZSTD_initDStream_usingDDict");
+    FORWARD_IF_ERROR( ZSTD_DCtx_reset(dctx, ZSTD_reset_session_only) , "");
+    FORWARD_IF_ERROR( ZSTD_DCtx_refDDict(dctx, ddict) , "");
+    return ZSTD_startingInputLength(dctx->format);
+}
+
+/* ZSTD_resetDStream() :
+ * return : expected size, aka ZSTD_startingInputLength().
+ * this function cannot fail */
+size_t ZSTD_resetDStream(ZSTD_DStream* dctx)
+{
+    DEBUGLOG(4, "ZSTD_resetDStream");
+    FORWARD_IF_ERROR(ZSTD_DCtx_reset(dctx, ZSTD_reset_session_only), "");
+    return ZSTD_startingInputLength(dctx->format);
+}
+
+
+size_t ZSTD_DCtx_refDDict(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict)
+{
+    RETURN_ERROR_IF(dctx->streamStage != zdss_init, stage_wrong, "");
+    ZSTD_clearDict(dctx);
+    if (ddict) {
+        dctx->ddict = ddict;
+        dctx->dictUses = ZSTD_use_indefinitely;
+        if (dctx->refMultipleDDicts == ZSTD_rmd_refMultipleDDicts) {
+            if (dctx->ddictSet == NULL) {
+                dctx->ddictSet = ZSTD_createDDictHashSet(dctx->customMem);
+                if (!dctx->ddictSet) {
+                    RETURN_ERROR(memory_allocation, "Failed to allocate memory for hash set!");
+                }
+            }
+            assert(!dctx->staticSize);  /* Impossible: ddictSet cannot have been allocated if static dctx */
+            FORWARD_IF_ERROR(ZSTD_DDictHashSet_addDDict(dctx->ddictSet, ddict, dctx->customMem), "");
+        }
+    }
+    return 0;
+}
+
+/* ZSTD_DCtx_setMaxWindowSize() :
+ * note : no direct equivalence in ZSTD_DCtx_setParameter,
+ * since this version sets windowSize, and the other sets windowLog */
+size_t ZSTD_DCtx_setMaxWindowSize(ZSTD_DCtx* dctx, size_t maxWindowSize)
+{
+    ZSTD_bounds const bounds = ZSTD_dParam_getBounds(ZSTD_d_windowLogMax);
+    size_t const min = (size_t)1 << bounds.lowerBound;
+    size_t const max = (size_t)1 << bounds.upperBound;
+    RETURN_ERROR_IF(dctx->streamStage != zdss_init, stage_wrong, "");
+    RETURN_ERROR_IF(maxWindowSize < min, parameter_outOfBound, "");
+    RETURN_ERROR_IF(maxWindowSize > max, parameter_outOfBound, "");
+    dctx->maxWindowSize = maxWindowSize;
+    return 0;
+}
+
+size_t ZSTD_DCtx_setFormat(ZSTD_DCtx* dctx, ZSTD_format_e format)
+{
+    return ZSTD_DCtx_setParameter(dctx, ZSTD_d_format, (int)format);
+}
+
+ZSTD_bounds ZSTD_dParam_getBounds(ZSTD_dParameter dParam)
+{
+    ZSTD_bounds bounds = { 0, 0, 0 };
+    switch(dParam) {
+        case ZSTD_d_windowLogMax:
+            bounds.lowerBound = ZSTD_WINDOWLOG_ABSOLUTEMIN;
+            bounds.upperBound = ZSTD_WINDOWLOG_MAX;
+            return bounds;
+        case ZSTD_d_format:
+            bounds.lowerBound = (int)ZSTD_f_zstd1;
+            bounds.upperBound = (int)ZSTD_f_zstd1_magicless;
+            ZSTD_STATIC_ASSERT(ZSTD_f_zstd1 < ZSTD_f_zstd1_magicless);
+            return bounds;
+        case ZSTD_d_stableOutBuffer:
+            bounds.lowerBound = (int)ZSTD_bm_buffered;
+            bounds.upperBound = (int)ZSTD_bm_stable;
+            return bounds;
+        case ZSTD_d_forceIgnoreChecksum:
+            bounds.lowerBound = (int)ZSTD_d_validateChecksum;
+            bounds.upperBound = (int)ZSTD_d_ignoreChecksum;
+            return bounds;
+        case ZSTD_d_refMultipleDDicts:
+            bounds.lowerBound = (int)ZSTD_rmd_refSingleDDict;
+            bounds.upperBound = (int)ZSTD_rmd_refMultipleDDicts;
+            return bounds;
+        case ZSTD_d_disableHuffmanAssembly:
+            bounds.lowerBound = 0;
+            bounds.upperBound = 1;
+            return bounds;
+
+        default:;
+    }
+    bounds.error = ERROR(parameter_unsupported);
+    return bounds;
+}
+
+/* ZSTD_dParam_withinBounds:
+ * @return 1 if value is within dParam bounds,
+ * 0 otherwise */
+static int ZSTD_dParam_withinBounds(ZSTD_dParameter dParam, int value)
+{
+    ZSTD_bounds const bounds = ZSTD_dParam_getBounds(dParam);
+    if (ZSTD_isError(bounds.error)) return 0;
+    if (value < bounds.lowerBound) return 0;
+    if (value > bounds.upperBound) return 0;
+    return 1;
+}
+
+#define CHECK_DBOUNDS(p,v) {                \
+    RETURN_ERROR_IF(!ZSTD_dParam_withinBounds(p, v), parameter_outOfBound, ""); \
+}
+
+size_t ZSTD_DCtx_getParameter(ZSTD_DCtx* dctx, ZSTD_dParameter param, int* value)
+{
+    switch (param) {
+        case ZSTD_d_windowLogMax:
+            *value = (int)ZSTD_highbit32((U32)dctx->maxWindowSize);
+            return 0;
+        case ZSTD_d_format:
+            *value = (int)dctx->format;
+            return 0;
+        case ZSTD_d_stableOutBuffer:
+            *value = (int)dctx->outBufferMode;
+            return 0;
+        case ZSTD_d_forceIgnoreChecksum:
+            *value = (int)dctx->forceIgnoreChecksum;
+            return 0;
+        case ZSTD_d_refMultipleDDicts:
+            *value = (int)dctx->refMultipleDDicts;
+            return 0;
+        case ZSTD_d_disableHuffmanAssembly:
+            *value = (int)dctx->disableHufAsm;
+            return 0;
+        default:;
+    }
+    RETURN_ERROR(parameter_unsupported, "");
+}
+
+size_t ZSTD_DCtx_setParameter(ZSTD_DCtx* dctx, ZSTD_dParameter dParam, int value)
+{
+    RETURN_ERROR_IF(dctx->streamStage != zdss_init, stage_wrong, "");
+    switch(dParam) {
+        case ZSTD_d_windowLogMax:
+            if (value == 0) value = ZSTD_WINDOWLOG_LIMIT_DEFAULT;
+            CHECK_DBOUNDS(ZSTD_d_windowLogMax, value);
+            dctx->maxWindowSize = ((size_t)1) << value;
+            return 0;
+        case ZSTD_d_format:
+            CHECK_DBOUNDS(ZSTD_d_format, value);
+            dctx->format = (ZSTD_format_e)value;
+            return 0;
+        case ZSTD_d_stableOutBuffer:
+            CHECK_DBOUNDS(ZSTD_d_stableOutBuffer, value);
+            dctx->outBufferMode = (ZSTD_bufferMode_e)value;
+            return 0;
+        case ZSTD_d_forceIgnoreChecksum:
+            CHECK_DBOUNDS(ZSTD_d_forceIgnoreChecksum, value);
+            dctx->forceIgnoreChecksum = (ZSTD_forceIgnoreChecksum_e)value;
+            return 0;
+        case ZSTD_d_refMultipleDDicts:
+            CHECK_DBOUNDS(ZSTD_d_refMultipleDDicts, value);
+            if (dctx->staticSize != 0) {
+                RETURN_ERROR(parameter_unsupported, "Static dctx does not support multiple DDicts!");
+            }
+            dctx->refMultipleDDicts = (ZSTD_refMultipleDDicts_e)value;
+            return 0;
+        case ZSTD_d_disableHuffmanAssembly:
+            CHECK_DBOUNDS(ZSTD_d_disableHuffmanAssembly, value);
+            dctx->disableHufAsm = value != 0;
+            return 0;
+        default:;
+    }
+    RETURN_ERROR(parameter_unsupported, "");
+}
+
+size_t ZSTD_DCtx_reset(ZSTD_DCtx* dctx, ZSTD_ResetDirective reset)
+{
+    if ( (reset == ZSTD_reset_session_only)
+      || (reset == ZSTD_reset_session_and_parameters) ) {
+        dctx->streamStage = zdss_init;
+        dctx->noForwardProgress = 0;
+    }
+    if ( (reset == ZSTD_reset_parameters)
+      || (reset == ZSTD_reset_session_and_parameters) ) {
+        RETURN_ERROR_IF(dctx->streamStage != zdss_init, stage_wrong, "");
+        ZSTD_clearDict(dctx);
+        ZSTD_DCtx_resetParameters(dctx);
+    }
+    return 0;
+}
+
+
+size_t ZSTD_sizeof_DStream(const ZSTD_DStream* dctx)
+{
+    return ZSTD_sizeof_DCtx(dctx);
+}
+
+size_t ZSTD_decodingBufferSize_min(unsigned long long windowSize, unsigned long long frameContentSize)
+{
+    size_t const blockSize = (size_t) MIN(windowSize, ZSTD_BLOCKSIZE_MAX);
+    /* space is needed to store the litbuffer after the output of a given block without stomping the extDict of a previous run, as well as to cover both windows against wildcopy*/
+    unsigned long long const neededRBSize = windowSize + blockSize + ZSTD_BLOCKSIZE_MAX + (WILDCOPY_OVERLENGTH * 2);
+    unsigned long long const neededSize = MIN(frameContentSize, neededRBSize);
+    size_t const minRBSize = (size_t) neededSize;
+    RETURN_ERROR_IF((unsigned long long)minRBSize != neededSize,
+                    frameParameter_windowTooLarge, "");
+    return minRBSize;
+}
+
+size_t ZSTD_estimateDStreamSize(size_t windowSize)
+{
+    size_t const blockSize = MIN(windowSize, ZSTD_BLOCKSIZE_MAX);
+    size_t const inBuffSize = blockSize;  /* no block can be larger */
+    size_t const outBuffSize = ZSTD_decodingBufferSize_min(windowSize, ZSTD_CONTENTSIZE_UNKNOWN);
+    return ZSTD_estimateDCtxSize() + inBuffSize + outBuffSize;
+}
+
+size_t ZSTD_estimateDStreamSize_fromFrame(const void* src, size_t srcSize)
+{
+    U32 const windowSizeMax = 1U << ZSTD_WINDOWLOG_MAX;   /* note : should be user-selectable, but requires an additional parameter (or a dctx) */
+    ZSTD_frameHeader zfh;
+    size_t const err = ZSTD_getFrameHeader(&zfh, src, srcSize);
+    if (ZSTD_isError(err)) return err;
+    RETURN_ERROR_IF(err>0, srcSize_wrong, "");
+    RETURN_ERROR_IF(zfh.windowSize > windowSizeMax,
+                    frameParameter_windowTooLarge, "");
+    return ZSTD_estimateDStreamSize((size_t)zfh.windowSize);
+}
+
+
+/* *****   Decompression   ***** */
+
+static int ZSTD_DCtx_isOverflow(ZSTD_DStream* zds, size_t const neededInBuffSize, size_t const neededOutBuffSize)
+{
+    return (zds->inBuffSize + zds->outBuffSize) >= (neededInBuffSize + neededOutBuffSize) * ZSTD_WORKSPACETOOLARGE_FACTOR;
+}
+
+static void ZSTD_DCtx_updateOversizedDuration(ZSTD_DStream* zds, size_t const neededInBuffSize, size_t const neededOutBuffSize)
+{
+    if (ZSTD_DCtx_isOverflow(zds, neededInBuffSize, neededOutBuffSize))
+        zds->oversizedDuration++;
+    else
+        zds->oversizedDuration = 0;
+}
+
+static int ZSTD_DCtx_isOversizedTooLong(ZSTD_DStream* zds)
+{
+    return zds->oversizedDuration >= ZSTD_WORKSPACETOOLARGE_MAXDURATION;
+}
+
+/* Checks that the output buffer hasn't changed if ZSTD_obm_stable is used. */
+static size_t ZSTD_checkOutBuffer(ZSTD_DStream const* zds, ZSTD_outBuffer const* output)
+{
+    ZSTD_outBuffer const expect = zds->expectedOutBuffer;
+    /* No requirement when ZSTD_obm_stable is not enabled. */
+    if (zds->outBufferMode != ZSTD_bm_stable)
+        return 0;
+    /* Any buffer is allowed in zdss_init, this must be the same for every other call until
+     * the context is reset.
+     */
+    if (zds->streamStage == zdss_init)
+        return 0;
+    /* The buffer must match our expectation exactly. */
+    if (expect.dst == output->dst && expect.pos == output->pos && expect.size == output->size)
+        return 0;
+    RETURN_ERROR(dstBuffer_wrong, "ZSTD_d_stableOutBuffer enabled but output differs!");
+}
+
+/* Calls ZSTD_decompressContinue() with the right parameters for ZSTD_decompressStream()
+ * and updates the stage and the output buffer state. This call is extracted so it can be
+ * used both when reading directly from the ZSTD_inBuffer, and in buffered input mode.
+ * NOTE: You must break after calling this function since the streamStage is modified.
+ */
+static size_t ZSTD_decompressContinueStream(
+            ZSTD_DStream* zds, char** op, char* oend,
+            void const* src, size_t srcSize) {
+    int const isSkipFrame = ZSTD_isSkipFrame(zds);
+    if (zds->outBufferMode == ZSTD_bm_buffered) {
+        size_t const dstSize = isSkipFrame ? 0 : zds->outBuffSize - zds->outStart;
+        size_t const decodedSize = ZSTD_decompressContinue(zds,
+                zds->outBuff + zds->outStart, dstSize, src, srcSize);
+        FORWARD_IF_ERROR(decodedSize, "");
+        if (!decodedSize && !isSkipFrame) {
+            zds->streamStage = zdss_read;
+        } else {
+            zds->outEnd = zds->outStart + decodedSize;
+            zds->streamStage = zdss_flush;
+        }
+    } else {
+        /* Write directly into the output buffer */
+        size_t const dstSize = isSkipFrame ? 0 : (size_t)(oend - *op);
+        size_t const decodedSize = ZSTD_decompressContinue(zds, *op, dstSize, src, srcSize);
+        FORWARD_IF_ERROR(decodedSize, "");
+        *op += decodedSize;
+        /* Flushing is not needed. */
+        zds->streamStage = zdss_read;
+        assert(*op <= oend);
+        assert(zds->outBufferMode == ZSTD_bm_stable);
+    }
+    return 0;
+}
+
+size_t ZSTD_decompressStream(ZSTD_DStream* zds, ZSTD_outBuffer* output, ZSTD_inBuffer* input)
+{
+    const char* const src = (const char*)input->src;
+    const char* const istart = input->pos != 0 ? src + input->pos : src;
+    const char* const iend = input->size != 0 ? src + input->size : src;
+    const char* ip = istart;
+    char* const dst = (char*)output->dst;
+    char* const ostart = output->pos != 0 ? dst + output->pos : dst;
+    char* const oend = output->size != 0 ? dst + output->size : dst;
+    char* op = ostart;
+    U32 someMoreWork = 1;
+
+    DEBUGLOG(5, "ZSTD_decompressStream");
+    RETURN_ERROR_IF(
+        input->pos > input->size,
+        srcSize_wrong,
+        "forbidden. in: pos: %u   vs size: %u",
+        (U32)input->pos, (U32)input->size);
+    RETURN_ERROR_IF(
+        output->pos > output->size,
+        dstSize_tooSmall,
+        "forbidden. out: pos: %u   vs size: %u",
+        (U32)output->pos, (U32)output->size);
+    DEBUGLOG(5, "input size : %u", (U32)(input->size - input->pos));
+    FORWARD_IF_ERROR(ZSTD_checkOutBuffer(zds, output), "");
+
+    while (someMoreWork) {
+        switch(zds->streamStage)
+        {
+        case zdss_init :
+            DEBUGLOG(5, "stage zdss_init => transparent reset ");
+            zds->streamStage = zdss_loadHeader;
+            zds->lhSize = zds->inPos = zds->outStart = zds->outEnd = 0;
+#if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT>=1)
+            zds->legacyVersion = 0;
+#endif
+            zds->hostageByte = 0;
+            zds->expectedOutBuffer = *output;
+            ZSTD_FALLTHROUGH;
+
+        case zdss_loadHeader :
+            DEBUGLOG(5, "stage zdss_loadHeader (srcSize : %u)", (U32)(iend - ip));
+#if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT>=1)
+            if (zds->legacyVersion) {
+                RETURN_ERROR_IF(zds->staticSize, memory_allocation,
+                    "legacy support is incompatible with static dctx");
+                {   size_t const hint = ZSTD_decompressLegacyStream(zds->legacyContext, zds->legacyVersion, output, input);
+                    if (hint==0) zds->streamStage = zdss_init;
+                    return hint;
+            }   }
+#endif
+            {   size_t const hSize = ZSTD_getFrameHeader_advanced(&zds->fParams, zds->headerBuffer, zds->lhSize, zds->format);
+                if (zds->refMultipleDDicts && zds->ddictSet) {
+                    ZSTD_DCtx_selectFrameDDict(zds);
+                }
+                if (ZSTD_isError(hSize)) {
+#if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT>=1)
+                    U32 const legacyVersion = ZSTD_isLegacy(istart, iend-istart);
+                    if (legacyVersion) {
+                        ZSTD_DDict const* const ddict = ZSTD_getDDict(zds);
+                        const void* const dict = ddict ? ZSTD_DDict_dictContent(ddict) : NULL;
+                        size_t const dictSize = ddict ? ZSTD_DDict_dictSize(ddict) : 0;
+                        DEBUGLOG(5, "ZSTD_decompressStream: detected legacy version v0.%u", legacyVersion);
+                        RETURN_ERROR_IF(zds->staticSize, memory_allocation,
+                            "legacy support is incompatible with static dctx");
+                        FORWARD_IF_ERROR(ZSTD_initLegacyStream(&zds->legacyContext,
+                                    zds->previousLegacyVersion, legacyVersion,
+                                    dict, dictSize), "");
+                        zds->legacyVersion = zds->previousLegacyVersion = legacyVersion;
+                        {   size_t const hint = ZSTD_decompressLegacyStream(zds->legacyContext, legacyVersion, output, input);
+                            if (hint==0) zds->streamStage = zdss_init;   /* or stay in stage zdss_loadHeader */
+                            return hint;
+                    }   }
+#endif
+                    return hSize;   /* error */
+                }
+                if (hSize != 0) {   /* need more input */
+                    size_t const toLoad = hSize - zds->lhSize;   /* if hSize!=0, hSize > zds->lhSize */
+                    size_t const remainingInput = (size_t)(iend-ip);
+                    assert(iend >= ip);
+                    if (toLoad > remainingInput) {   /* not enough input to load full header */
+                        if (remainingInput > 0) {
+                            ZSTD_memcpy(zds->headerBuffer + zds->lhSize, ip, remainingInput);
+                            zds->lhSize += remainingInput;
+                        }
+                        input->pos = input->size;
+                        /* check first few bytes */
+                        FORWARD_IF_ERROR(
+                            ZSTD_getFrameHeader_advanced(&zds->fParams, zds->headerBuffer, zds->lhSize, zds->format),
+                            "First few bytes detected incorrect" );
+                        /* return hint input size */
+                        return (MAX((size_t)ZSTD_FRAMEHEADERSIZE_MIN(zds->format), hSize) - zds->lhSize) + ZSTD_blockHeaderSize;   /* remaining header bytes + next block header */
+                    }
+                    assert(ip != NULL);
+                    ZSTD_memcpy(zds->headerBuffer + zds->lhSize, ip, toLoad); zds->lhSize = hSize; ip += toLoad;
+                    break;
+            }   }
+
+            /* check for single-pass mode opportunity */
+            if (zds->fParams.frameContentSize != ZSTD_CONTENTSIZE_UNKNOWN
+                && zds->fParams.frameType != ZSTD_skippableFrame
+                && (U64)(size_t)(oend-op) >= zds->fParams.frameContentSize) {
+                size_t const cSize = ZSTD_findFrameCompressedSize(istart, (size_t)(iend-istart));
+                if (cSize <= (size_t)(iend-istart)) {
+                    /* shortcut : using single-pass mode */
+                    size_t const decompressedSize = ZSTD_decompress_usingDDict(zds, op, (size_t)(oend-op), istart, cSize, ZSTD_getDDict(zds));
+                    if (ZSTD_isError(decompressedSize)) return decompressedSize;
+                    DEBUGLOG(4, "shortcut to single-pass ZSTD_decompress_usingDDict()")
+                    assert(istart != NULL);
+                    ip = istart + cSize;
+                    op = op ? op + decompressedSize : op; /* can occur if frameContentSize = 0 (empty frame) */
+                    zds->expected = 0;
+                    zds->streamStage = zdss_init;
+                    someMoreWork = 0;
+                    break;
+            }   }
+
+            /* Check output buffer is large enough for ZSTD_odm_stable. */
+            if (zds->outBufferMode == ZSTD_bm_stable
+                && zds->fParams.frameType != ZSTD_skippableFrame
+                && zds->fParams.frameContentSize != ZSTD_CONTENTSIZE_UNKNOWN
+                && (U64)(size_t)(oend-op) < zds->fParams.frameContentSize) {
+                RETURN_ERROR(dstSize_tooSmall, "ZSTD_obm_stable passed but ZSTD_outBuffer is too small");
+            }
+
+            /* Consume header (see ZSTDds_decodeFrameHeader) */
+            DEBUGLOG(4, "Consume header");
+            FORWARD_IF_ERROR(ZSTD_decompressBegin_usingDDict(zds, ZSTD_getDDict(zds)), "");
+
+            if ((MEM_readLE32(zds->headerBuffer) & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {  /* skippable frame */
+                zds->expected = MEM_readLE32(zds->headerBuffer + ZSTD_FRAMEIDSIZE);
+                zds->stage = ZSTDds_skipFrame;
+            } else {
+                FORWARD_IF_ERROR(ZSTD_decodeFrameHeader(zds, zds->headerBuffer, zds->lhSize), "");
+                zds->expected = ZSTD_blockHeaderSize;
+                zds->stage = ZSTDds_decodeBlockHeader;
+            }
+
+            /* control buffer memory usage */
+            DEBUGLOG(4, "Control max memory usage (%u KB <= max %u KB)",
+                        (U32)(zds->fParams.windowSize >>10),
+                        (U32)(zds->maxWindowSize >> 10) );
+            zds->fParams.windowSize = MAX(zds->fParams.windowSize, 1U << ZSTD_WINDOWLOG_ABSOLUTEMIN);
+            RETURN_ERROR_IF(zds->fParams.windowSize > zds->maxWindowSize,
+                            frameParameter_windowTooLarge, "");
+
+            /* Adapt buffer sizes to frame header instructions */
+            {   size_t const neededInBuffSize = MAX(zds->fParams.blockSizeMax, 4 /* frame checksum */);
+                size_t const neededOutBuffSize = zds->outBufferMode == ZSTD_bm_buffered
+                        ? ZSTD_decodingBufferSize_min(zds->fParams.windowSize, zds->fParams.frameContentSize)
+                        : 0;
+
+                ZSTD_DCtx_updateOversizedDuration(zds, neededInBuffSize, neededOutBuffSize);
+
+                {   int const tooSmall = (zds->inBuffSize < neededInBuffSize) || (zds->outBuffSize < neededOutBuffSize);
+                    int const tooLarge = ZSTD_DCtx_isOversizedTooLong(zds);
+
+                    if (tooSmall || tooLarge) {
+                        size_t const bufferSize = neededInBuffSize + neededOutBuffSize;
+                        DEBUGLOG(4, "inBuff  : from %u to %u",
+                                    (U32)zds->inBuffSize, (U32)neededInBuffSize);
+                        DEBUGLOG(4, "outBuff : from %u to %u",
+                                    (U32)zds->outBuffSize, (U32)neededOutBuffSize);
+                        if (zds->staticSize) {  /* static DCtx */
+                            DEBUGLOG(4, "staticSize : %u", (U32)zds->staticSize);
+                            assert(zds->staticSize >= sizeof(ZSTD_DCtx));  /* controlled at init */
+                            RETURN_ERROR_IF(
+                                bufferSize > zds->staticSize - sizeof(ZSTD_DCtx),
+                                memory_allocation, "");
+                        } else {
+                            ZSTD_customFree(zds->inBuff, zds->customMem);
+                            zds->inBuffSize = 0;
+                            zds->outBuffSize = 0;
+                            zds->inBuff = (char*)ZSTD_customMalloc(bufferSize, zds->customMem);
+                            RETURN_ERROR_IF(zds->inBuff == NULL, memory_allocation, "");
+                        }
+                        zds->inBuffSize = neededInBuffSize;
+                        zds->outBuff = zds->inBuff + zds->inBuffSize;
+                        zds->outBuffSize = neededOutBuffSize;
+            }   }   }
+            zds->streamStage = zdss_read;
+            ZSTD_FALLTHROUGH;
+
+        case zdss_read:
+            DEBUGLOG(5, "stage zdss_read");
+            {   size_t const neededInSize = ZSTD_nextSrcSizeToDecompressWithInputSize(zds, (size_t)(iend - ip));
+                DEBUGLOG(5, "neededInSize = %u", (U32)neededInSize);
+                if (neededInSize==0) {  /* end of frame */
+                    zds->streamStage = zdss_init;
+                    someMoreWork = 0;
+                    break;
+                }
+                if ((size_t)(iend-ip) >= neededInSize) {  /* decode directly from src */
+                    FORWARD_IF_ERROR(ZSTD_decompressContinueStream(zds, &op, oend, ip, neededInSize), "");
+                    assert(ip != NULL);
+                    ip += neededInSize;
+                    /* Function modifies the stage so we must break */
+                    break;
+            }   }
+            if (ip==iend) { someMoreWork = 0; break; }   /* no more input */
+            zds->streamStage = zdss_load;
+            ZSTD_FALLTHROUGH;
+
+        case zdss_load:
+            {   size_t const neededInSize = ZSTD_nextSrcSizeToDecompress(zds);
+                size_t const toLoad = neededInSize - zds->inPos;
+                int const isSkipFrame = ZSTD_isSkipFrame(zds);
+                size_t loadedSize;
+                /* At this point we shouldn't be decompressing a block that we can stream. */
+                assert(neededInSize == ZSTD_nextSrcSizeToDecompressWithInputSize(zds, (size_t)(iend - ip)));
+                if (isSkipFrame) {
+                    loadedSize = MIN(toLoad, (size_t)(iend-ip));
+                } else {
+                    RETURN_ERROR_IF(toLoad > zds->inBuffSize - zds->inPos,
+                                    corruption_detected,
+                                    "should never happen");
+                    loadedSize = ZSTD_limitCopy(zds->inBuff + zds->inPos, toLoad, ip, (size_t)(iend-ip));
+                }
+                if (loadedSize != 0) {
+                    /* ip may be NULL */
+                    ip += loadedSize;
+                    zds->inPos += loadedSize;
+                }
+                if (loadedSize < toLoad) { someMoreWork = 0; break; }   /* not enough input, wait for more */
+
+                /* decode loaded input */
+                zds->inPos = 0;   /* input is consumed */
+                FORWARD_IF_ERROR(ZSTD_decompressContinueStream(zds, &op, oend, zds->inBuff, neededInSize), "");
+                /* Function modifies the stage so we must break */
+                break;
+            }
+        case zdss_flush:
+            {
+                size_t const toFlushSize = zds->outEnd - zds->outStart;
+                size_t const flushedSize = ZSTD_limitCopy(op, (size_t)(oend-op), zds->outBuff + zds->outStart, toFlushSize);
+
+                op = op ? op + flushedSize : op;
+
+                zds->outStart += flushedSize;
+                if (flushedSize == toFlushSize) {  /* flush completed */
+                    zds->streamStage = zdss_read;
+                    if ( (zds->outBuffSize < zds->fParams.frameContentSize)
+                        && (zds->outStart + zds->fParams.blockSizeMax > zds->outBuffSize) ) {
+                        DEBUGLOG(5, "restart filling outBuff from beginning (left:%i, needed:%u)",
+                                (int)(zds->outBuffSize - zds->outStart),
+                                (U32)zds->fParams.blockSizeMax);
+                        zds->outStart = zds->outEnd = 0;
+                    }
+                    break;
+            }   }
+            /* cannot complete flush */
+            someMoreWork = 0;
+            break;
+
+        default:
+            assert(0);    /* impossible */
+            RETURN_ERROR(GENERIC, "impossible to reach");   /* some compilers require default to do something */
+    }   }
+
+    /* result */
+    input->pos = (size_t)(ip - (const char*)(input->src));
+    output->pos = (size_t)(op - (char*)(output->dst));
+
+    /* Update the expected output buffer for ZSTD_obm_stable. */
+    zds->expectedOutBuffer = *output;
+
+    if ((ip==istart) && (op==ostart)) {  /* no forward progress */
+        zds->noForwardProgress ++;
+        if (zds->noForwardProgress >= ZSTD_NO_FORWARD_PROGRESS_MAX) {
+            RETURN_ERROR_IF(op==oend, noForwardProgress_destFull, "");
+            RETURN_ERROR_IF(ip==iend, noForwardProgress_inputEmpty, "");
+            assert(0);
+        }
+    } else {
+        zds->noForwardProgress = 0;
+    }
+    {   size_t nextSrcSizeHint = ZSTD_nextSrcSizeToDecompress(zds);
+        if (!nextSrcSizeHint) {   /* frame fully decoded */
+            if (zds->outEnd == zds->outStart) {  /* output fully flushed */
+                if (zds->hostageByte) {
+                    if (input->pos >= input->size) {
+                        /* can't release hostage (not present) */
+                        zds->streamStage = zdss_read;
+                        return 1;
+                    }
+                    input->pos++;  /* release hostage */
+                }   /* zds->hostageByte */
+                return 0;
+            }  /* zds->outEnd == zds->outStart */
+            if (!zds->hostageByte) { /* output not fully flushed; keep last byte as hostage; will be released when all output is flushed */
+                input->pos--;   /* note : pos > 0, otherwise, impossible to finish reading last block */
+                zds->hostageByte=1;
+            }
+            return 1;
+        }  /* nextSrcSizeHint==0 */
+        nextSrcSizeHint += ZSTD_blockHeaderSize * (ZSTD_nextInputType(zds) == ZSTDnit_block);   /* preload header of next block */
+        assert(zds->inPos <= nextSrcSizeHint);
+        nextSrcSizeHint -= zds->inPos;   /* part already loaded*/
+        return nextSrcSizeHint;
+    }
+}
+
+size_t ZSTD_decompressStream_simpleArgs (
+                            ZSTD_DCtx* dctx,
+                            void* dst, size_t dstCapacity, size_t* dstPos,
+                      const void* src, size_t srcSize, size_t* srcPos)
+{
+    ZSTD_outBuffer output;
+    ZSTD_inBuffer  input;
+    output.dst = dst;
+    output.size = dstCapacity;
+    output.pos = *dstPos;
+    input.src = src;
+    input.size = srcSize;
+    input.pos = *srcPos;
+    {   size_t const cErr = ZSTD_decompressStream(dctx, &output, &input);
+        *dstPos = output.pos;
+        *srcPos = input.pos;
+        return cErr;
+    }
+}
diff --git a/src/3rdparty/zstd/src/decompress/zstd_decompress_block.c b/src/3rdparty/zstd/src/decompress/zstd_decompress_block.c
new file mode 100644
index 0000000000..09896a931e
--- /dev/null
+++ b/src/3rdparty/zstd/src/decompress/zstd_decompress_block.c
@@ -0,0 +1,2192 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+/* zstd_decompress_block :
+ * this module takes care of decompressing _compressed_ block */
+
+/*-*******************************************************
+*  Dependencies
+*********************************************************/
+#include "../common/zstd_deps.h"   /* ZSTD_memcpy, ZSTD_memmove, ZSTD_memset */
+#include "../common/compiler.h"    /* prefetch */
+#include "../common/cpu.h"         /* bmi2 */
+#include "../common/mem.h"         /* low level memory routines */
+#define FSE_STATIC_LINKING_ONLY
+#include "../common/fse.h"
+#include "../common/huf.h"
+#include "../common/zstd_internal.h"
+#include "zstd_decompress_internal.h"   /* ZSTD_DCtx */
+#include "zstd_ddict.h"  /* ZSTD_DDictDictContent */
+#include "zstd_decompress_block.h"
+#include "../common/bits.h"  /* ZSTD_highbit32 */
+
+/*_*******************************************************
+*  Macros
+**********************************************************/
+
+/* These two optional macros force the use one way or another of the two
+ * ZSTD_decompressSequences implementations. You can't force in both directions
+ * at the same time.
+ */
+#if defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \
+    defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)
+#error "Cannot force the use of the short and the long ZSTD_decompressSequences variants!"
+#endif
+
+
+/*_*******************************************************
+*  Memory operations
+**********************************************************/
+static void ZSTD_copy4(void* dst, const void* src) { ZSTD_memcpy(dst, src, 4); }
+
+
+/*-*************************************************************
+ *   Block decoding
+ ***************************************************************/
+
+/*! ZSTD_getcBlockSize() :
+ *  Provides the size of compressed block from block header `src` */
+size_t ZSTD_getcBlockSize(const void* src, size_t srcSize,
+                          blockProperties_t* bpPtr)
+{
+    RETURN_ERROR_IF(srcSize < ZSTD_blockHeaderSize, srcSize_wrong, "");
+
+    {   U32 const cBlockHeader = MEM_readLE24(src);
+        U32 const cSize = cBlockHeader >> 3;
+        bpPtr->lastBlock = cBlockHeader & 1;
+        bpPtr->blockType = (blockType_e)((cBlockHeader >> 1) & 3);
+        bpPtr->origSize = cSize;   /* only useful for RLE */
+        if (bpPtr->blockType == bt_rle) return 1;
+        RETURN_ERROR_IF(bpPtr->blockType == bt_reserved, corruption_detected, "");
+        return cSize;
+    }
+}
+
+/* Allocate buffer for literals, either overlapping current dst, or split between dst and litExtraBuffer, or stored entirely within litExtraBuffer */
+static void ZSTD_allocateLiteralsBuffer(ZSTD_DCtx* dctx, void* const dst, const size_t dstCapacity, const size_t litSize,
+    const streaming_operation streaming, const size_t expectedWriteSize, const unsigned splitImmediately)
+{
+    if (streaming == not_streaming && dstCapacity > ZSTD_BLOCKSIZE_MAX + WILDCOPY_OVERLENGTH + litSize + WILDCOPY_OVERLENGTH)
+    {
+        /* room for litbuffer to fit without read faulting */
+        dctx->litBuffer = (BYTE*)dst + ZSTD_BLOCKSIZE_MAX + WILDCOPY_OVERLENGTH;
+        dctx->litBufferEnd = dctx->litBuffer + litSize;
+        dctx->litBufferLocation = ZSTD_in_dst;
+    }
+    else if (litSize > ZSTD_LITBUFFEREXTRASIZE)
+    {
+        /* won't fit in litExtraBuffer, so it will be split between end of dst and extra buffer */
+        if (splitImmediately) {
+            /* won't fit in litExtraBuffer, so it will be split between end of dst and extra buffer */
+            dctx->litBuffer = (BYTE*)dst + expectedWriteSize - litSize + ZSTD_LITBUFFEREXTRASIZE - WILDCOPY_OVERLENGTH;
+            dctx->litBufferEnd = dctx->litBuffer + litSize - ZSTD_LITBUFFEREXTRASIZE;
+        }
+        else {
+            /* initially this will be stored entirely in dst during huffman decoding, it will partially be shifted to litExtraBuffer after */
+            dctx->litBuffer = (BYTE*)dst + expectedWriteSize - litSize;
+            dctx->litBufferEnd = (BYTE*)dst + expectedWriteSize;
+        }
+        dctx->litBufferLocation = ZSTD_split;
+    }
+    else
+    {
+        /* fits entirely within litExtraBuffer, so no split is necessary */
+        dctx->litBuffer = dctx->litExtraBuffer;
+        dctx->litBufferEnd = dctx->litBuffer + litSize;
+        dctx->litBufferLocation = ZSTD_not_in_dst;
+    }
+}
+
+/* Hidden declaration for fullbench */
+size_t ZSTD_decodeLiteralsBlock(ZSTD_DCtx* dctx,
+                          const void* src, size_t srcSize,
+                          void* dst, size_t dstCapacity, const streaming_operation streaming);
+/*! ZSTD_decodeLiteralsBlock() :
+ * Where it is possible to do so without being stomped by the output during decompression, the literals block will be stored
+ * in the dstBuffer.  If there is room to do so, it will be stored in full in the excess dst space after where the current
+ * block will be output.  Otherwise it will be stored at the end of the current dst blockspace, with a small portion being
+ * stored in dctx->litExtraBuffer to help keep it "ahead" of the current output write.
+ *
+ * @return : nb of bytes read from src (< srcSize )
+ *  note : symbol not declared but exposed for fullbench */
+size_t ZSTD_decodeLiteralsBlock(ZSTD_DCtx* dctx,
+                          const void* src, size_t srcSize,   /* note : srcSize < BLOCKSIZE */
+                          void* dst, size_t dstCapacity, const streaming_operation streaming)
+{
+    DEBUGLOG(5, "ZSTD_decodeLiteralsBlock");
+    RETURN_ERROR_IF(srcSize < MIN_CBLOCK_SIZE, corruption_detected, "");
+
+    {   const BYTE* const istart = (const BYTE*) src;
+        symbolEncodingType_e const litEncType = (symbolEncodingType_e)(istart[0] & 3);
+
+        switch(litEncType)
+        {
+        case set_repeat:
+            DEBUGLOG(5, "set_repeat flag : re-using stats from previous compressed literals block");
+            RETURN_ERROR_IF(dctx->litEntropy==0, dictionary_corrupted, "");
+            ZSTD_FALLTHROUGH;
+
+        case set_compressed:
+            RETURN_ERROR_IF(srcSize < 5, corruption_detected, "srcSize >= MIN_CBLOCK_SIZE == 2; here we need up to 5 for case 3");
+            {   size_t lhSize, litSize, litCSize;
+                U32 singleStream=0;
+                U32 const lhlCode = (istart[0] >> 2) & 3;
+                U32 const lhc = MEM_readLE32(istart);
+                size_t hufSuccess;
+                size_t expectedWriteSize = MIN(ZSTD_BLOCKSIZE_MAX, dstCapacity);
+                int const flags = 0
+                    | (ZSTD_DCtx_get_bmi2(dctx) ? HUF_flags_bmi2 : 0)
+                    | (dctx->disableHufAsm ? HUF_flags_disableAsm : 0);
+                switch(lhlCode)
+                {
+                case 0: case 1: default:   /* note : default is impossible, since lhlCode into [0..3] */
+                    /* 2 - 2 - 10 - 10 */
+                    singleStream = !lhlCode;
+                    lhSize = 3;
+                    litSize  = (lhc >> 4) & 0x3FF;
+                    litCSize = (lhc >> 14) & 0x3FF;
+                    break;
+                case 2:
+                    /* 2 - 2 - 14 - 14 */
+                    lhSize = 4;
+                    litSize  = (lhc >> 4) & 0x3FFF;
+                    litCSize = lhc >> 18;
+                    break;
+                case 3:
+                    /* 2 - 2 - 18 - 18 */
+                    lhSize = 5;
+                    litSize  = (lhc >> 4) & 0x3FFFF;
+                    litCSize = (lhc >> 22) + ((size_t)istart[4] << 10);
+                    break;
+                }
+                RETURN_ERROR_IF(litSize > 0 && dst == NULL, dstSize_tooSmall, "NULL not handled");
+                RETURN_ERROR_IF(litSize > ZSTD_BLOCKSIZE_MAX, corruption_detected, "");
+                if (!singleStream)
+                    RETURN_ERROR_IF(litSize < MIN_LITERALS_FOR_4_STREAMS, literals_headerWrong,
+                        "Not enough literals (%zu) for the 4-streams mode (min %u)",
+                        litSize, MIN_LITERALS_FOR_4_STREAMS);
+                RETURN_ERROR_IF(litCSize + lhSize > srcSize, corruption_detected, "");
+                RETURN_ERROR_IF(expectedWriteSize < litSize , dstSize_tooSmall, "");
+                ZSTD_allocateLiteralsBuffer(dctx, dst, dstCapacity, litSize, streaming, expectedWriteSize, 0);
+
+                /* prefetch huffman table if cold */
+                if (dctx->ddictIsCold && (litSize > 768 /* heuristic */)) {
+                    PREFETCH_AREA(dctx->HUFptr, sizeof(dctx->entropy.hufTable));
+                }
+
+                if (litEncType==set_repeat) {
+                    if (singleStream) {
+                        hufSuccess = HUF_decompress1X_usingDTable(
+                            dctx->litBuffer, litSize, istart+lhSize, litCSize,
+                            dctx->HUFptr, flags);
+                    } else {
+                        assert(litSize >= MIN_LITERALS_FOR_4_STREAMS);
+                        hufSuccess = HUF_decompress4X_usingDTable(
+                            dctx->litBuffer, litSize, istart+lhSize, litCSize,
+                            dctx->HUFptr, flags);
+                    }
+                } else {
+                    if (singleStream) {
+#if defined(HUF_FORCE_DECOMPRESS_X2)
+                        hufSuccess = HUF_decompress1X_DCtx_wksp(
+                            dctx->entropy.hufTable, dctx->litBuffer, litSize,
+                            istart+lhSize, litCSize, dctx->workspace,
+                            sizeof(dctx->workspace), flags);
+#else
+                        hufSuccess = HUF_decompress1X1_DCtx_wksp(
+                            dctx->entropy.hufTable, dctx->litBuffer, litSize,
+                            istart+lhSize, litCSize, dctx->workspace,
+                            sizeof(dctx->workspace), flags);
+#endif
+                    } else {
+                        hufSuccess = HUF_decompress4X_hufOnly_wksp(
+                            dctx->entropy.hufTable, dctx->litBuffer, litSize,
+                            istart+lhSize, litCSize, dctx->workspace,
+                            sizeof(dctx->workspace), flags);
+                    }
+                }
+                if (dctx->litBufferLocation == ZSTD_split)
+                {
+                    ZSTD_memcpy(dctx->litExtraBuffer, dctx->litBufferEnd - ZSTD_LITBUFFEREXTRASIZE, ZSTD_LITBUFFEREXTRASIZE);
+                    ZSTD_memmove(dctx->litBuffer + ZSTD_LITBUFFEREXTRASIZE - WILDCOPY_OVERLENGTH, dctx->litBuffer, litSize - ZSTD_LITBUFFEREXTRASIZE);
+                    dctx->litBuffer += ZSTD_LITBUFFEREXTRASIZE - WILDCOPY_OVERLENGTH;
+                    dctx->litBufferEnd -= WILDCOPY_OVERLENGTH;
+                }
+
+                RETURN_ERROR_IF(HUF_isError(hufSuccess), corruption_detected, "");
+
+                dctx->litPtr = dctx->litBuffer;
+                dctx->litSize = litSize;
+                dctx->litEntropy = 1;
+                if (litEncType==set_compressed) dctx->HUFptr = dctx->entropy.hufTable;
+                return litCSize + lhSize;
+            }
+
+        case set_basic:
+            {   size_t litSize, lhSize;
+                U32 const lhlCode = ((istart[0]) >> 2) & 3;
+                size_t expectedWriteSize = MIN(ZSTD_BLOCKSIZE_MAX, dstCapacity);
+                switch(lhlCode)
+                {
+                case 0: case 2: default:   /* note : default is impossible, since lhlCode into [0..3] */
+                    lhSize = 1;
+                    litSize = istart[0] >> 3;
+                    break;
+                case 1:
+                    lhSize = 2;
+                    litSize = MEM_readLE16(istart) >> 4;
+                    break;
+                case 3:
+                    lhSize = 3;
+                    RETURN_ERROR_IF(srcSize<3, corruption_detected, "srcSize >= MIN_CBLOCK_SIZE == 2; here we need lhSize = 3");
+                    litSize = MEM_readLE24(istart) >> 4;
+                    break;
+                }
+
+                RETURN_ERROR_IF(litSize > 0 && dst == NULL, dstSize_tooSmall, "NULL not handled");
+                RETURN_ERROR_IF(expectedWriteSize < litSize, dstSize_tooSmall, "");
+                ZSTD_allocateLiteralsBuffer(dctx, dst, dstCapacity, litSize, streaming, expectedWriteSize, 1);
+                if (lhSize+litSize+WILDCOPY_OVERLENGTH > srcSize) {  /* risk reading beyond src buffer with wildcopy */
+                    RETURN_ERROR_IF(litSize+lhSize > srcSize, corruption_detected, "");
+                    if (dctx->litBufferLocation == ZSTD_split)
+                    {
+                        ZSTD_memcpy(dctx->litBuffer, istart + lhSize, litSize - ZSTD_LITBUFFEREXTRASIZE);
+                        ZSTD_memcpy(dctx->litExtraBuffer, istart + lhSize + litSize - ZSTD_LITBUFFEREXTRASIZE, ZSTD_LITBUFFEREXTRASIZE);
+                    }
+                    else
+                    {
+                        ZSTD_memcpy(dctx->litBuffer, istart + lhSize, litSize);
+                    }
+                    dctx->litPtr = dctx->litBuffer;
+                    dctx->litSize = litSize;
+                    return lhSize+litSize;
+                }
+                /* direct reference into compressed stream */
+                dctx->litPtr = istart+lhSize;
+                dctx->litSize = litSize;
+                dctx->litBufferEnd = dctx->litPtr + litSize;
+                dctx->litBufferLocation = ZSTD_not_in_dst;
+                return lhSize+litSize;
+            }
+
+        case set_rle:
+            {   U32 const lhlCode = ((istart[0]) >> 2) & 3;
+                size_t litSize, lhSize;
+                size_t expectedWriteSize = MIN(ZSTD_BLOCKSIZE_MAX, dstCapacity);
+                switch(lhlCode)
+                {
+                case 0: case 2: default:   /* note : default is impossible, since lhlCode into [0..3] */
+                    lhSize = 1;
+                    litSize = istart[0] >> 3;
+                    break;
+                case 1:
+                    lhSize = 2;
+                    RETURN_ERROR_IF(srcSize<3, corruption_detected, "srcSize >= MIN_CBLOCK_SIZE == 2; here we need lhSize+1 = 3");
+                    litSize = MEM_readLE16(istart) >> 4;
+                    break;
+                case 3:
+                    lhSize = 3;
+                    RETURN_ERROR_IF(srcSize<4, corruption_detected, "srcSize >= MIN_CBLOCK_SIZE == 2; here we need lhSize+1 = 4");
+                    litSize = MEM_readLE24(istart) >> 4;
+                    break;
+                }
+                RETURN_ERROR_IF(litSize > 0 && dst == NULL, dstSize_tooSmall, "NULL not handled");
+                RETURN_ERROR_IF(litSize > ZSTD_BLOCKSIZE_MAX, corruption_detected, "");
+                RETURN_ERROR_IF(expectedWriteSize < litSize, dstSize_tooSmall, "");
+                ZSTD_allocateLiteralsBuffer(dctx, dst, dstCapacity, litSize, streaming, expectedWriteSize, 1);
+                if (dctx->litBufferLocation == ZSTD_split)
+                {
+                    ZSTD_memset(dctx->litBuffer, istart[lhSize], litSize - ZSTD_LITBUFFEREXTRASIZE);
+                    ZSTD_memset(dctx->litExtraBuffer, istart[lhSize], ZSTD_LITBUFFEREXTRASIZE);
+                }
+                else
+                {
+                    ZSTD_memset(dctx->litBuffer, istart[lhSize], litSize);
+                }
+                dctx->litPtr = dctx->litBuffer;
+                dctx->litSize = litSize;
+                return lhSize+1;
+            }
+        default:
+            RETURN_ERROR(corruption_detected, "impossible");
+        }
+    }
+}
+
+/* Default FSE distribution tables.
+ * These are pre-calculated FSE decoding tables using default distributions as defined in specification :
+ * https://github.com/facebook/zstd/blob/release/doc/zstd_compression_format.md#default-distributions
+ * They were generated programmatically with following method :
+ * - start from default distributions, present in /lib/common/zstd_internal.h
+ * - generate tables normally, using ZSTD_buildFSETable()
+ * - printout the content of tables
+ * - pretify output, report below, test with fuzzer to ensure it's correct */
+
+/* Default FSE distribution table for Literal Lengths */
+static const ZSTD_seqSymbol LL_defaultDTable[(1<<LL_DEFAULTNORMLOG)+1] = {
+     {  1,  1,  1, LL_DEFAULTNORMLOG},  /* header : fastMode, tableLog */
+     /* nextState, nbAddBits, nbBits, baseVal */
+     {  0,  0,  4,    0},  { 16,  0,  4,    0},
+     { 32,  0,  5,    1},  {  0,  0,  5,    3},
+     {  0,  0,  5,    4},  {  0,  0,  5,    6},
+     {  0,  0,  5,    7},  {  0,  0,  5,    9},
+     {  0,  0,  5,   10},  {  0,  0,  5,   12},
+     {  0,  0,  6,   14},  {  0,  1,  5,   16},
+     {  0,  1,  5,   20},  {  0,  1,  5,   22},
+     {  0,  2,  5,   28},  {  0,  3,  5,   32},
+     {  0,  4,  5,   48},  { 32,  6,  5,   64},
+     {  0,  7,  5,  128},  {  0,  8,  6,  256},
+     {  0, 10,  6, 1024},  {  0, 12,  6, 4096},
+     { 32,  0,  4,    0},  {  0,  0,  4,    1},
+     {  0,  0,  5,    2},  { 32,  0,  5,    4},
+     {  0,  0,  5,    5},  { 32,  0,  5,    7},
+     {  0,  0,  5,    8},  { 32,  0,  5,   10},
+     {  0,  0,  5,   11},  {  0,  0,  6,   13},
+     { 32,  1,  5,   16},  {  0,  1,  5,   18},
+     { 32,  1,  5,   22},  {  0,  2,  5,   24},
+     { 32,  3,  5,   32},  {  0,  3,  5,   40},
+     {  0,  6,  4,   64},  { 16,  6,  4,   64},
+     { 32,  7,  5,  128},  {  0,  9,  6,  512},
+     {  0, 11,  6, 2048},  { 48,  0,  4,    0},
+     { 16,  0,  4,    1},  { 32,  0,  5,    2},
+     { 32,  0,  5,    3},  { 32,  0,  5,    5},
+     { 32,  0,  5,    6},  { 32,  0,  5,    8},
+     { 32,  0,  5,    9},  { 32,  0,  5,   11},
+     { 32,  0,  5,   12},  {  0,  0,  6,   15},
+     { 32,  1,  5,   18},  { 32,  1,  5,   20},
+     { 32,  2,  5,   24},  { 32,  2,  5,   28},
+     { 32,  3,  5,   40},  { 32,  4,  5,   48},
+     {  0, 16,  6,65536},  {  0, 15,  6,32768},
+     {  0, 14,  6,16384},  {  0, 13,  6, 8192},
+};   /* LL_defaultDTable */
+
+/* Default FSE distribution table for Offset Codes */
+static const ZSTD_seqSymbol OF_defaultDTable[(1<<OF_DEFAULTNORMLOG)+1] = {
+    {  1,  1,  1, OF_DEFAULTNORMLOG},  /* header : fastMode, tableLog */
+    /* nextState, nbAddBits, nbBits, baseVal */
+    {  0,  0,  5,    0},     {  0,  6,  4,   61},
+    {  0,  9,  5,  509},     {  0, 15,  5,32765},
+    {  0, 21,  5,2097149},   {  0,  3,  5,    5},
+    {  0,  7,  4,  125},     {  0, 12,  5, 4093},
+    {  0, 18,  5,262141},    {  0, 23,  5,8388605},
+    {  0,  5,  5,   29},     {  0,  8,  4,  253},
+    {  0, 14,  5,16381},     {  0, 20,  5,1048573},
+    {  0,  2,  5,    1},     { 16,  7,  4,  125},
+    {  0, 11,  5, 2045},     {  0, 17,  5,131069},
+    {  0, 22,  5,4194301},   {  0,  4,  5,   13},
+    { 16,  8,  4,  253},     {  0, 13,  5, 8189},
+    {  0, 19,  5,524285},    {  0,  1,  5,    1},
+    { 16,  6,  4,   61},     {  0, 10,  5, 1021},
+    {  0, 16,  5,65533},     {  0, 28,  5,268435453},
+    {  0, 27,  5,134217725}, {  0, 26,  5,67108861},
+    {  0, 25,  5,33554429},  {  0, 24,  5,16777213},
+};   /* OF_defaultDTable */
+
+
+/* Default FSE distribution table for Match Lengths */
+static const ZSTD_seqSymbol ML_defaultDTable[(1<<ML_DEFAULTNORMLOG)+1] = {
+    {  1,  1,  1, ML_DEFAULTNORMLOG},  /* header : fastMode, tableLog */
+    /* nextState, nbAddBits, nbBits, baseVal */
+    {  0,  0,  6,    3},  {  0,  0,  4,    4},
+    { 32,  0,  5,    5},  {  0,  0,  5,    6},
+    {  0,  0,  5,    8},  {  0,  0,  5,    9},
+    {  0,  0,  5,   11},  {  0,  0,  6,   13},
+    {  0,  0,  6,   16},  {  0,  0,  6,   19},
+    {  0,  0,  6,   22},  {  0,  0,  6,   25},
+    {  0,  0,  6,   28},  {  0,  0,  6,   31},
+    {  0,  0,  6,   34},  {  0,  1,  6,   37},
+    {  0,  1,  6,   41},  {  0,  2,  6,   47},
+    {  0,  3,  6,   59},  {  0,  4,  6,   83},
+    {  0,  7,  6,  131},  {  0,  9,  6,  515},
+    { 16,  0,  4,    4},  {  0,  0,  4,    5},
+    { 32,  0,  5,    6},  {  0,  0,  5,    7},
+    { 32,  0,  5,    9},  {  0,  0,  5,   10},
+    {  0,  0,  6,   12},  {  0,  0,  6,   15},
+    {  0,  0,  6,   18},  {  0,  0,  6,   21},
+    {  0,  0,  6,   24},  {  0,  0,  6,   27},
+    {  0,  0,  6,   30},  {  0,  0,  6,   33},
+    {  0,  1,  6,   35},  {  0,  1,  6,   39},
+    {  0,  2,  6,   43},  {  0,  3,  6,   51},
+    {  0,  4,  6,   67},  {  0,  5,  6,   99},
+    {  0,  8,  6,  259},  { 32,  0,  4,    4},
+    { 48,  0,  4,    4},  { 16,  0,  4,    5},
+    { 32,  0,  5,    7},  { 32,  0,  5,    8},
+    { 32,  0,  5,   10},  { 32,  0,  5,   11},
+    {  0,  0,  6,   14},  {  0,  0,  6,   17},
+    {  0,  0,  6,   20},  {  0,  0,  6,   23},
+    {  0,  0,  6,   26},  {  0,  0,  6,   29},
+    {  0,  0,  6,   32},  {  0, 16,  6,65539},
+    {  0, 15,  6,32771},  {  0, 14,  6,16387},
+    {  0, 13,  6, 8195},  {  0, 12,  6, 4099},
+    {  0, 11,  6, 2051},  {  0, 10,  6, 1027},
+};   /* ML_defaultDTable */
+
+
+static void ZSTD_buildSeqTable_rle(ZSTD_seqSymbol* dt, U32 baseValue, U8 nbAddBits)
+{
+    void* ptr = dt;
+    ZSTD_seqSymbol_header* const DTableH = (ZSTD_seqSymbol_header*)ptr;
+    ZSTD_seqSymbol* const cell = dt + 1;
+
+    DTableH->tableLog = 0;
+    DTableH->fastMode = 0;
+
+    cell->nbBits = 0;
+    cell->nextState = 0;
+    assert(nbAddBits < 255);
+    cell->nbAdditionalBits = nbAddBits;
+    cell->baseValue = baseValue;
+}
+
+
+/* ZSTD_buildFSETable() :
+ * generate FSE decoding table for one symbol (ll, ml or off)
+ * cannot fail if input is valid =>
+ * all inputs are presumed validated at this stage */
+FORCE_INLINE_TEMPLATE
+void ZSTD_buildFSETable_body(ZSTD_seqSymbol* dt,
+            const short* normalizedCounter, unsigned maxSymbolValue,
+            const U32* baseValue, const U8* nbAdditionalBits,
+            unsigned tableLog, void* wksp, size_t wkspSize)
+{
+    ZSTD_seqSymbol* const tableDecode = dt+1;
+    U32 const maxSV1 = maxSymbolValue + 1;
+    U32 const tableSize = 1 << tableLog;
+
+    U16* symbolNext = (U16*)wksp;
+    BYTE* spread = (BYTE*)(symbolNext + MaxSeq + 1);
+    U32 highThreshold = tableSize - 1;
+
+
+    /* Sanity Checks */
+    assert(maxSymbolValue <= MaxSeq);
+    assert(tableLog <= MaxFSELog);
+    assert(wkspSize >= ZSTD_BUILD_FSE_TABLE_WKSP_SIZE);
+    (void)wkspSize;
+    /* Init, lay down lowprob symbols */
+    {   ZSTD_seqSymbol_header DTableH;
+        DTableH.tableLog = tableLog;
+        DTableH.fastMode = 1;
+        {   S16 const largeLimit= (S16)(1 << (tableLog-1));
+            U32 s;
+            for (s=0; s<maxSV1; s++) {
+                if (normalizedCounter[s]==-1) {
+                    tableDecode[highThreshold--].baseValue = s;
+                    symbolNext[s] = 1;
+                } else {
+                    if (normalizedCounter[s] >= largeLimit) DTableH.fastMode=0;
+                    assert(normalizedCounter[s]>=0);
+                    symbolNext[s] = (U16)normalizedCounter[s];
+        }   }   }
+        ZSTD_memcpy(dt, &DTableH, sizeof(DTableH));
+    }
+
+    /* Spread symbols */
+    assert(tableSize <= 512);
+    /* Specialized symbol spreading for the case when there are
+     * no low probability (-1 count) symbols. When compressing
+     * small blocks we avoid low probability symbols to hit this
+     * case, since header decoding speed matters more.
+     */
+    if (highThreshold == tableSize - 1) {
+        size_t const tableMask = tableSize-1;
+        size_t const step = FSE_TABLESTEP(tableSize);
+        /* First lay down the symbols in order.
+         * We use a uint64_t to lay down 8 bytes at a time. This reduces branch
+         * misses since small blocks generally have small table logs, so nearly
+         * all symbols have counts <= 8. We ensure we have 8 bytes at the end of
+         * our buffer to handle the over-write.
+         */
+        {
+            U64 const add = 0x0101010101010101ull;
+            size_t pos = 0;
+            U64 sv = 0;
+            U32 s;
+            for (s=0; s<maxSV1; ++s, sv += add) {
+                int i;
+                int const n = normalizedCounter[s];
+                MEM_write64(spread + pos, sv);
+                for (i = 8; i < n; i += 8) {
+                    MEM_write64(spread + pos + i, sv);
+                }
+                assert(n>=0);
+                pos += (size_t)n;
+            }
+        }
+        /* Now we spread those positions across the table.
+         * The benefit of doing it in two stages is that we avoid the
+         * variable size inner loop, which caused lots of branch misses.
+         * Now we can run through all the positions without any branch misses.
+         * We unroll the loop twice, since that is what empirically worked best.
+         */
+        {
+            size_t position = 0;
+            size_t s;
+            size_t const unroll = 2;
+            assert(tableSize % unroll == 0); /* FSE_MIN_TABLELOG is 5 */
+            for (s = 0; s < (size_t)tableSize; s += unroll) {
+                size_t u;
+                for (u = 0; u < unroll; ++u) {
+                    size_t const uPosition = (position + (u * step)) & tableMask;
+                    tableDecode[uPosition].baseValue = spread[s + u];
+                }
+                position = (position + (unroll * step)) & tableMask;
+            }
+            assert(position == 0);
+        }
+    } else {
+        U32 const tableMask = tableSize-1;
+        U32 const step = FSE_TABLESTEP(tableSize);
+        U32 s, position = 0;
+        for (s=0; s<maxSV1; s++) {
+            int i;
+            int const n = normalizedCounter[s];
+            for (i=0; i<n; i++) {
+                tableDecode[position].baseValue = s;
+                position = (position + step) & tableMask;
+                while (UNLIKELY(position > highThreshold)) position = (position + step) & tableMask;   /* lowprob area */
+        }   }
+        assert(position == 0); /* position must reach all cells once, otherwise normalizedCounter is incorrect */
+    }
+
+    /* Build Decoding table */
+    {
+        U32 u;
+        for (u=0; u<tableSize; u++) {
+            U32 const symbol = tableDecode[u].baseValue;
+            U32 const nextState = symbolNext[symbol]++;
+            tableDecode[u].nbBits = (BYTE) (tableLog - ZSTD_highbit32(nextState) );
+            tableDecode[u].nextState = (U16) ( (nextState << tableDecode[u].nbBits) - tableSize);
+            assert(nbAdditionalBits[symbol] < 255);
+            tableDecode[u].nbAdditionalBits = nbAdditionalBits[symbol];
+            tableDecode[u].baseValue = baseValue[symbol];
+        }
+    }
+}
+
+/* Avoids the FORCE_INLINE of the _body() function. */
+static void ZSTD_buildFSETable_body_default(ZSTD_seqSymbol* dt,
+            const short* normalizedCounter, unsigned maxSymbolValue,
+            const U32* baseValue, const U8* nbAdditionalBits,
+            unsigned tableLog, void* wksp, size_t wkspSize)
+{
+    ZSTD_buildFSETable_body(dt, normalizedCounter, maxSymbolValue,
+            baseValue, nbAdditionalBits, tableLog, wksp, wkspSize);
+}
+
+#if DYNAMIC_BMI2
+BMI2_TARGET_ATTRIBUTE static void ZSTD_buildFSETable_body_bmi2(ZSTD_seqSymbol* dt,
+            const short* normalizedCounter, unsigned maxSymbolValue,
+            const U32* baseValue, const U8* nbAdditionalBits,
+            unsigned tableLog, void* wksp, size_t wkspSize)
+{
+    ZSTD_buildFSETable_body(dt, normalizedCounter, maxSymbolValue,
+            baseValue, nbAdditionalBits, tableLog, wksp, wkspSize);
+}
+#endif
+
+void ZSTD_buildFSETable(ZSTD_seqSymbol* dt,
+            const short* normalizedCounter, unsigned maxSymbolValue,
+            const U32* baseValue, const U8* nbAdditionalBits,
+            unsigned tableLog, void* wksp, size_t wkspSize, int bmi2)
+{
+#if DYNAMIC_BMI2
+    if (bmi2) {
+        ZSTD_buildFSETable_body_bmi2(dt, normalizedCounter, maxSymbolValue,
+                baseValue, nbAdditionalBits, tableLog, wksp, wkspSize);
+        return;
+    }
+#endif
+    (void)bmi2;
+    ZSTD_buildFSETable_body_default(dt, normalizedCounter, maxSymbolValue,
+            baseValue, nbAdditionalBits, tableLog, wksp, wkspSize);
+}
+
+
+/*! ZSTD_buildSeqTable() :
+ * @return : nb bytes read from src,
+ *           or an error code if it fails */
+static size_t ZSTD_buildSeqTable(ZSTD_seqSymbol* DTableSpace, const ZSTD_seqSymbol** DTablePtr,
+                                 symbolEncodingType_e type, unsigned max, U32 maxLog,
+                                 const void* src, size_t srcSize,
+                                 const U32* baseValue, const U8* nbAdditionalBits,
+                                 const ZSTD_seqSymbol* defaultTable, U32 flagRepeatTable,
+                                 int ddictIsCold, int nbSeq, U32* wksp, size_t wkspSize,
+                                 int bmi2)
+{
+    switch(type)
+    {
+    case set_rle :
+        RETURN_ERROR_IF(!srcSize, srcSize_wrong, "");
+        RETURN_ERROR_IF((*(const BYTE*)src) > max, corruption_detected, "");
+        {   U32 const symbol = *(const BYTE*)src;
+            U32 const baseline = baseValue[symbol];
+            U8 const nbBits = nbAdditionalBits[symbol];
+            ZSTD_buildSeqTable_rle(DTableSpace, baseline, nbBits);
+        }
+        *DTablePtr = DTableSpace;
+        return 1;
+    case set_basic :
+        *DTablePtr = defaultTable;
+        return 0;
+    case set_repeat:
+        RETURN_ERROR_IF(!flagRepeatTable, corruption_detected, "");
+        /* prefetch FSE table if used */
+        if (ddictIsCold && (nbSeq > 24 /* heuristic */)) {
+            const void* const pStart = *DTablePtr;
+            size_t const pSize = sizeof(ZSTD_seqSymbol) * (SEQSYMBOL_TABLE_SIZE(maxLog));
+            PREFETCH_AREA(pStart, pSize);
+        }
+        return 0;
+    case set_compressed :
+        {   unsigned tableLog;
+            S16 norm[MaxSeq+1];
+            size_t const headerSize = FSE_readNCount(norm, &max, &tableLog, src, srcSize);
+            RETURN_ERROR_IF(FSE_isError(headerSize), corruption_detected, "");
+            RETURN_ERROR_IF(tableLog > maxLog, corruption_detected, "");
+            ZSTD_buildFSETable(DTableSpace, norm, max, baseValue, nbAdditionalBits, tableLog, wksp, wkspSize, bmi2);
+            *DTablePtr = DTableSpace;
+            return headerSize;
+        }
+    default :
+        assert(0);
+        RETURN_ERROR(GENERIC, "impossible");
+    }
+}
+
+size_t ZSTD_decodeSeqHeaders(ZSTD_DCtx* dctx, int* nbSeqPtr,
+                             const void* src, size_t srcSize)
+{
+    const BYTE* const istart = (const BYTE*)src;
+    const BYTE* const iend = istart + srcSize;
+    const BYTE* ip = istart;
+    int nbSeq;
+    DEBUGLOG(5, "ZSTD_decodeSeqHeaders");
+
+    /* check */
+    RETURN_ERROR_IF(srcSize < MIN_SEQUENCES_SIZE, srcSize_wrong, "");
+
+    /* SeqHead */
+    nbSeq = *ip++;
+    if (!nbSeq) {
+        *nbSeqPtr=0;
+        RETURN_ERROR_IF(srcSize != 1, srcSize_wrong, "");
+        return 1;
+    }
+    if (nbSeq > 0x7F) {
+        if (nbSeq == 0xFF) {
+            RETURN_ERROR_IF(ip+2 > iend, srcSize_wrong, "");
+            nbSeq = MEM_readLE16(ip) + LONGNBSEQ;
+            ip+=2;
+        } else {
+            RETURN_ERROR_IF(ip >= iend, srcSize_wrong, "");
+            nbSeq = ((nbSeq-0x80)<<8) + *ip++;
+        }
+    }
+    *nbSeqPtr = nbSeq;
+
+    /* FSE table descriptors */
+    RETURN_ERROR_IF(ip+1 > iend, srcSize_wrong, ""); /* minimum possible size: 1 byte for symbol encoding types */
+    {   symbolEncodingType_e const LLtype = (symbolEncodingType_e)(*ip >> 6);
+        symbolEncodingType_e const OFtype = (symbolEncodingType_e)((*ip >> 4) & 3);
+        symbolEncodingType_e const MLtype = (symbolEncodingType_e)((*ip >> 2) & 3);
+        ip++;
+
+        /* Build DTables */
+        {   size_t const llhSize = ZSTD_buildSeqTable(dctx->entropy.LLTable, &dctx->LLTptr,
+                                                      LLtype, MaxLL, LLFSELog,
+                                                      ip, iend-ip,
+                                                      LL_base, LL_bits,
+                                                      LL_defaultDTable, dctx->fseEntropy,
+                                                      dctx->ddictIsCold, nbSeq,
+                                                      dctx->workspace, sizeof(dctx->workspace),
+                                                      ZSTD_DCtx_get_bmi2(dctx));
+            RETURN_ERROR_IF(ZSTD_isError(llhSize), corruption_detected, "ZSTD_buildSeqTable failed");
+            ip += llhSize;
+        }
+
+        {   size_t const ofhSize = ZSTD_buildSeqTable(dctx->entropy.OFTable, &dctx->OFTptr,
+                                                      OFtype, MaxOff, OffFSELog,
+                                                      ip, iend-ip,
+                                                      OF_base, OF_bits,
+                                                      OF_defaultDTable, dctx->fseEntropy,
+                                                      dctx->ddictIsCold, nbSeq,
+                                                      dctx->workspace, sizeof(dctx->workspace),
+                                                      ZSTD_DCtx_get_bmi2(dctx));
+            RETURN_ERROR_IF(ZSTD_isError(ofhSize), corruption_detected, "ZSTD_buildSeqTable failed");
+            ip += ofhSize;
+        }
+
+        {   size_t const mlhSize = ZSTD_buildSeqTable(dctx->entropy.MLTable, &dctx->MLTptr,
+                                                      MLtype, MaxML, MLFSELog,
+                                                      ip, iend-ip,
+                                                      ML_base, ML_bits,
+                                                      ML_defaultDTable, dctx->fseEntropy,
+                                                      dctx->ddictIsCold, nbSeq,
+                                                      dctx->workspace, sizeof(dctx->workspace),
+                                                      ZSTD_DCtx_get_bmi2(dctx));
+            RETURN_ERROR_IF(ZSTD_isError(mlhSize), corruption_detected, "ZSTD_buildSeqTable failed");
+            ip += mlhSize;
+        }
+    }
+
+    return ip-istart;
+}
+
+
+typedef struct {
+    size_t litLength;
+    size_t matchLength;
+    size_t offset;
+} seq_t;
+
+typedef struct {
+    size_t state;
+    const ZSTD_seqSymbol* table;
+} ZSTD_fseState;
+
+typedef struct {
+    BIT_DStream_t DStream;
+    ZSTD_fseState stateLL;
+    ZSTD_fseState stateOffb;
+    ZSTD_fseState stateML;
+    size_t prevOffset[ZSTD_REP_NUM];
+} seqState_t;
+
+/*! ZSTD_overlapCopy8() :
+ *  Copies 8 bytes from ip to op and updates op and ip where ip <= op.
+ *  If the offset is < 8 then the offset is spread to at least 8 bytes.
+ *
+ *  Precondition: *ip <= *op
+ *  Postcondition: *op - *op >= 8
+ */
+HINT_INLINE void ZSTD_overlapCopy8(BYTE** op, BYTE const** ip, size_t offset) {
+    assert(*ip <= *op);
+    if (offset < 8) {
+        /* close range match, overlap */
+        static const U32 dec32table[] = { 0, 1, 2, 1, 4, 4, 4, 4 };   /* added */
+        static const int dec64table[] = { 8, 8, 8, 7, 8, 9,10,11 };   /* subtracted */
+        int const sub2 = dec64table[offset];
+        (*op)[0] = (*ip)[0];
+        (*op)[1] = (*ip)[1];
+        (*op)[2] = (*ip)[2];
+        (*op)[3] = (*ip)[3];
+        *ip += dec32table[offset];
+        ZSTD_copy4(*op+4, *ip);
+        *ip -= sub2;
+    } else {
+        ZSTD_copy8(*op, *ip);
+    }
+    *ip += 8;
+    *op += 8;
+    assert(*op - *ip >= 8);
+}
+
+/*! ZSTD_safecopy() :
+ *  Specialized version of memcpy() that is allowed to READ up to WILDCOPY_OVERLENGTH past the input buffer
+ *  and write up to 16 bytes past oend_w (op >= oend_w is allowed).
+ *  This function is only called in the uncommon case where the sequence is near the end of the block. It
+ *  should be fast for a single long sequence, but can be slow for several short sequences.
+ *
+ *  @param ovtype controls the overlap detection
+ *         - ZSTD_no_overlap: The source and destination are guaranteed to be at least WILDCOPY_VECLEN bytes apart.
+ *         - ZSTD_overlap_src_before_dst: The src and dst may overlap and may be any distance apart.
+ *           The src buffer must be before the dst buffer.
+ */
+static void ZSTD_safecopy(BYTE* op, const BYTE* const oend_w, BYTE const* ip, ptrdiff_t length, ZSTD_overlap_e ovtype) {
+    ptrdiff_t const diff = op - ip;
+    BYTE* const oend = op + length;
+
+    assert((ovtype == ZSTD_no_overlap && (diff <= -8 || diff >= 8 || op >= oend_w)) ||
+           (ovtype == ZSTD_overlap_src_before_dst && diff >= 0));
+
+    if (length < 8) {
+        /* Handle short lengths. */
+        while (op < oend) *op++ = *ip++;
+        return;
+    }
+    if (ovtype == ZSTD_overlap_src_before_dst) {
+        /* Copy 8 bytes and ensure the offset >= 8 when there can be overlap. */
+        assert(length >= 8);
+        ZSTD_overlapCopy8(&op, &ip, diff);
+        length -= 8;
+        assert(op - ip >= 8);
+        assert(op <= oend);
+    }
+
+    if (oend <= oend_w) {
+        /* No risk of overwrite. */
+        ZSTD_wildcopy(op, ip, length, ovtype);
+        return;
+    }
+    if (op <= oend_w) {
+        /* Wildcopy until we get close to the end. */
+        assert(oend > oend_w);
+        ZSTD_wildcopy(op, ip, oend_w - op, ovtype);
+        ip += oend_w - op;
+        op += oend_w - op;
+    }
+    /* Handle the leftovers. */
+    while (op < oend) *op++ = *ip++;
+}
+
+/* ZSTD_safecopyDstBeforeSrc():
+ * This version allows overlap with dst before src, or handles the non-overlap case with dst after src
+ * Kept separate from more common ZSTD_safecopy case to avoid performance impact to the safecopy common case */
+static void ZSTD_safecopyDstBeforeSrc(BYTE* op, BYTE const* ip, ptrdiff_t length) {
+    ptrdiff_t const diff = op - ip;
+    BYTE* const oend = op + length;
+
+    if (length < 8 || diff > -8) {
+        /* Handle short lengths, close overlaps, and dst not before src. */
+        while (op < oend) *op++ = *ip++;
+        return;
+    }
+
+    if (op <= oend - WILDCOPY_OVERLENGTH && diff < -WILDCOPY_VECLEN) {
+        ZSTD_wildcopy(op, ip, oend - WILDCOPY_OVERLENGTH - op, ZSTD_no_overlap);
+        ip += oend - WILDCOPY_OVERLENGTH - op;
+        op += oend - WILDCOPY_OVERLENGTH - op;
+    }
+
+    /* Handle the leftovers. */
+    while (op < oend) *op++ = *ip++;
+}
+
+/* ZSTD_execSequenceEnd():
+ * This version handles cases that are near the end of the output buffer. It requires
+ * more careful checks to make sure there is no overflow. By separating out these hard
+ * and unlikely cases, we can speed up the common cases.
+ *
+ * NOTE: This function needs to be fast for a single long sequence, but doesn't need
+ * to be optimized for many small sequences, since those fall into ZSTD_execSequence().
+ */
+FORCE_NOINLINE
+size_t ZSTD_execSequenceEnd(BYTE* op,
+    BYTE* const oend, seq_t sequence,
+    const BYTE** litPtr, const BYTE* const litLimit,
+    const BYTE* const prefixStart, const BYTE* const virtualStart, const BYTE* const dictEnd)
+{
+    BYTE* const oLitEnd = op + sequence.litLength;
+    size_t const sequenceLength = sequence.litLength + sequence.matchLength;
+    const BYTE* const iLitEnd = *litPtr + sequence.litLength;
+    const BYTE* match = oLitEnd - sequence.offset;
+    BYTE* const oend_w = oend - WILDCOPY_OVERLENGTH;
+
+    /* bounds checks : careful of address space overflow in 32-bit mode */
+    RETURN_ERROR_IF(sequenceLength > (size_t)(oend - op), dstSize_tooSmall, "last match must fit within dstBuffer");
+    RETURN_ERROR_IF(sequence.litLength > (size_t)(litLimit - *litPtr), corruption_detected, "try to read beyond literal buffer");
+    assert(op < op + sequenceLength);
+    assert(oLitEnd < op + sequenceLength);
+
+    /* copy literals */
+    ZSTD_safecopy(op, oend_w, *litPtr, sequence.litLength, ZSTD_no_overlap);
+    op = oLitEnd;
+    *litPtr = iLitEnd;
+
+    /* copy Match */
+    if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {
+        /* offset beyond prefix */
+        RETURN_ERROR_IF(sequence.offset > (size_t)(oLitEnd - virtualStart), corruption_detected, "");
+        match = dictEnd - (prefixStart - match);
+        if (match + sequence.matchLength <= dictEnd) {
+            ZSTD_memmove(oLitEnd, match, sequence.matchLength);
+            return sequenceLength;
+        }
+        /* span extDict & currentPrefixSegment */
+        {   size_t const length1 = dictEnd - match;
+        ZSTD_memmove(oLitEnd, match, length1);
+        op = oLitEnd + length1;
+        sequence.matchLength -= length1;
+        match = prefixStart;
+        }
+    }
+    ZSTD_safecopy(op, oend_w, match, sequence.matchLength, ZSTD_overlap_src_before_dst);
+    return sequenceLength;
+}
+
+/* ZSTD_execSequenceEndSplitLitBuffer():
+ * This version is intended to be used during instances where the litBuffer is still split.  It is kept separate to avoid performance impact for the good case.
+ */
+FORCE_NOINLINE
+size_t ZSTD_execSequenceEndSplitLitBuffer(BYTE* op,
+    BYTE* const oend, const BYTE* const oend_w, seq_t sequence,
+    const BYTE** litPtr, const BYTE* const litLimit,
+    const BYTE* const prefixStart, const BYTE* const virtualStart, const BYTE* const dictEnd)
+{
+    BYTE* const oLitEnd = op + sequence.litLength;
+    size_t const sequenceLength = sequence.litLength + sequence.matchLength;
+    const BYTE* const iLitEnd = *litPtr + sequence.litLength;
+    const BYTE* match = oLitEnd - sequence.offset;
+
+
+    /* bounds checks : careful of address space overflow in 32-bit mode */
+    RETURN_ERROR_IF(sequenceLength > (size_t)(oend - op), dstSize_tooSmall, "last match must fit within dstBuffer");
+    RETURN_ERROR_IF(sequence.litLength > (size_t)(litLimit - *litPtr), corruption_detected, "try to read beyond literal buffer");
+    assert(op < op + sequenceLength);
+    assert(oLitEnd < op + sequenceLength);
+
+    /* copy literals */
+    RETURN_ERROR_IF(op > *litPtr && op < *litPtr + sequence.litLength, dstSize_tooSmall, "output should not catch up to and overwrite literal buffer");
+    ZSTD_safecopyDstBeforeSrc(op, *litPtr, sequence.litLength);
+    op = oLitEnd;
+    *litPtr = iLitEnd;
+
+    /* copy Match */
+    if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {
+        /* offset beyond prefix */
+        RETURN_ERROR_IF(sequence.offset > (size_t)(oLitEnd - virtualStart), corruption_detected, "");
+        match = dictEnd - (prefixStart - match);
+        if (match + sequence.matchLength <= dictEnd) {
+            ZSTD_memmove(oLitEnd, match, sequence.matchLength);
+            return sequenceLength;
+        }
+        /* span extDict & currentPrefixSegment */
+        {   size_t const length1 = dictEnd - match;
+        ZSTD_memmove(oLitEnd, match, length1);
+        op = oLitEnd + length1;
+        sequence.matchLength -= length1;
+        match = prefixStart;
+        }
+    }
+    ZSTD_safecopy(op, oend_w, match, sequence.matchLength, ZSTD_overlap_src_before_dst);
+    return sequenceLength;
+}
+
+HINT_INLINE
+size_t ZSTD_execSequence(BYTE* op,
+    BYTE* const oend, seq_t sequence,
+    const BYTE** litPtr, const BYTE* const litLimit,
+    const BYTE* const prefixStart, const BYTE* const virtualStart, const BYTE* const dictEnd)
+{
+    BYTE* const oLitEnd = op + sequence.litLength;
+    size_t const sequenceLength = sequence.litLength + sequence.matchLength;
+    BYTE* const oMatchEnd = op + sequenceLength;   /* risk : address space overflow (32-bits) */
+    BYTE* const oend_w = oend - WILDCOPY_OVERLENGTH;   /* risk : address space underflow on oend=NULL */
+    const BYTE* const iLitEnd = *litPtr + sequence.litLength;
+    const BYTE* match = oLitEnd - sequence.offset;
+
+    assert(op != NULL /* Precondition */);
+    assert(oend_w < oend /* No underflow */);
+
+#if defined(__aarch64__)
+    /* prefetch sequence starting from match that will be used for copy later */
+    PREFETCH_L1(match);
+#endif
+    /* Handle edge cases in a slow path:
+     *   - Read beyond end of literals
+     *   - Match end is within WILDCOPY_OVERLIMIT of oend
+     *   - 32-bit mode and the match length overflows
+     */
+    if (UNLIKELY(
+        iLitEnd > litLimit ||
+        oMatchEnd > oend_w ||
+        (MEM_32bits() && (size_t)(oend - op) < sequenceLength + WILDCOPY_OVERLENGTH)))
+        return ZSTD_execSequenceEnd(op, oend, sequence, litPtr, litLimit, prefixStart, virtualStart, dictEnd);
+
+    /* Assumptions (everything else goes into ZSTD_execSequenceEnd()) */
+    assert(op <= oLitEnd /* No overflow */);
+    assert(oLitEnd < oMatchEnd /* Non-zero match & no overflow */);
+    assert(oMatchEnd <= oend /* No underflow */);
+    assert(iLitEnd <= litLimit /* Literal length is in bounds */);
+    assert(oLitEnd <= oend_w /* Can wildcopy literals */);
+    assert(oMatchEnd <= oend_w /* Can wildcopy matches */);
+
+    /* Copy Literals:
+     * Split out litLength <= 16 since it is nearly always true. +1.6% on gcc-9.
+     * We likely don't need the full 32-byte wildcopy.
+     */
+    assert(WILDCOPY_OVERLENGTH >= 16);
+    ZSTD_copy16(op, (*litPtr));
+    if (UNLIKELY(sequence.litLength > 16)) {
+        ZSTD_wildcopy(op + 16, (*litPtr) + 16, sequence.litLength - 16, ZSTD_no_overlap);
+    }
+    op = oLitEnd;
+    *litPtr = iLitEnd;   /* update for next sequence */
+
+    /* Copy Match */
+    if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {
+        /* offset beyond prefix -> go into extDict */
+        RETURN_ERROR_IF(UNLIKELY(sequence.offset > (size_t)(oLitEnd - virtualStart)), corruption_detected, "");
+        match = dictEnd + (match - prefixStart);
+        if (match + sequence.matchLength <= dictEnd) {
+            ZSTD_memmove(oLitEnd, match, sequence.matchLength);
+            return sequenceLength;
+        }
+        /* span extDict & currentPrefixSegment */
+        {   size_t const length1 = dictEnd - match;
+        ZSTD_memmove(oLitEnd, match, length1);
+        op = oLitEnd + length1;
+        sequence.matchLength -= length1;
+        match = prefixStart;
+        }
+    }
+    /* Match within prefix of 1 or more bytes */
+    assert(op <= oMatchEnd);
+    assert(oMatchEnd <= oend_w);
+    assert(match >= prefixStart);
+    assert(sequence.matchLength >= 1);
+
+    /* Nearly all offsets are >= WILDCOPY_VECLEN bytes, which means we can use wildcopy
+     * without overlap checking.
+     */
+    if (LIKELY(sequence.offset >= WILDCOPY_VECLEN)) {
+        /* We bet on a full wildcopy for matches, since we expect matches to be
+         * longer than literals (in general). In silesia, ~10% of matches are longer
+         * than 16 bytes.
+         */
+        ZSTD_wildcopy(op, match, (ptrdiff_t)sequence.matchLength, ZSTD_no_overlap);
+        return sequenceLength;
+    }
+    assert(sequence.offset < WILDCOPY_VECLEN);
+
+    /* Copy 8 bytes and spread the offset to be >= 8. */
+    ZSTD_overlapCopy8(&op, &match, sequence.offset);
+
+    /* If the match length is > 8 bytes, then continue with the wildcopy. */
+    if (sequence.matchLength > 8) {
+        assert(op < oMatchEnd);
+        ZSTD_wildcopy(op, match, (ptrdiff_t)sequence.matchLength - 8, ZSTD_overlap_src_before_dst);
+    }
+    return sequenceLength;
+}
+
+HINT_INLINE
+size_t ZSTD_execSequenceSplitLitBuffer(BYTE* op,
+    BYTE* const oend, const BYTE* const oend_w, seq_t sequence,
+    const BYTE** litPtr, const BYTE* const litLimit,
+    const BYTE* const prefixStart, const BYTE* const virtualStart, const BYTE* const dictEnd)
+{
+    BYTE* const oLitEnd = op + sequence.litLength;
+    size_t const sequenceLength = sequence.litLength + sequence.matchLength;
+    BYTE* const oMatchEnd = op + sequenceLength;   /* risk : address space overflow (32-bits) */
+    const BYTE* const iLitEnd = *litPtr + sequence.litLength;
+    const BYTE* match = oLitEnd - sequence.offset;
+
+    assert(op != NULL /* Precondition */);
+    assert(oend_w < oend /* No underflow */);
+    /* Handle edge cases in a slow path:
+     *   - Read beyond end of literals
+     *   - Match end is within WILDCOPY_OVERLIMIT of oend
+     *   - 32-bit mode and the match length overflows
+     */
+    if (UNLIKELY(
+            iLitEnd > litLimit ||
+            oMatchEnd > oend_w ||
+            (MEM_32bits() && (size_t)(oend - op) < sequenceLength + WILDCOPY_OVERLENGTH)))
+        return ZSTD_execSequenceEndSplitLitBuffer(op, oend, oend_w, sequence, litPtr, litLimit, prefixStart, virtualStart, dictEnd);
+
+    /* Assumptions (everything else goes into ZSTD_execSequenceEnd()) */
+    assert(op <= oLitEnd /* No overflow */);
+    assert(oLitEnd < oMatchEnd /* Non-zero match & no overflow */);
+    assert(oMatchEnd <= oend /* No underflow */);
+    assert(iLitEnd <= litLimit /* Literal length is in bounds */);
+    assert(oLitEnd <= oend_w /* Can wildcopy literals */);
+    assert(oMatchEnd <= oend_w /* Can wildcopy matches */);
+
+    /* Copy Literals:
+     * Split out litLength <= 16 since it is nearly always true. +1.6% on gcc-9.
+     * We likely don't need the full 32-byte wildcopy.
+     */
+    assert(WILDCOPY_OVERLENGTH >= 16);
+    ZSTD_copy16(op, (*litPtr));
+    if (UNLIKELY(sequence.litLength > 16)) {
+        ZSTD_wildcopy(op+16, (*litPtr)+16, sequence.litLength-16, ZSTD_no_overlap);
+    }
+    op = oLitEnd;
+    *litPtr = iLitEnd;   /* update for next sequence */
+
+    /* Copy Match */
+    if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {
+        /* offset beyond prefix -> go into extDict */
+        RETURN_ERROR_IF(UNLIKELY(sequence.offset > (size_t)(oLitEnd - virtualStart)), corruption_detected, "");
+        match = dictEnd + (match - prefixStart);
+        if (match + sequence.matchLength <= dictEnd) {
+            ZSTD_memmove(oLitEnd, match, sequence.matchLength);
+            return sequenceLength;
+        }
+        /* span extDict & currentPrefixSegment */
+        {   size_t const length1 = dictEnd - match;
+            ZSTD_memmove(oLitEnd, match, length1);
+            op = oLitEnd + length1;
+            sequence.matchLength -= length1;
+            match = prefixStart;
+    }   }
+    /* Match within prefix of 1 or more bytes */
+    assert(op <= oMatchEnd);
+    assert(oMatchEnd <= oend_w);
+    assert(match >= prefixStart);
+    assert(sequence.matchLength >= 1);
+
+    /* Nearly all offsets are >= WILDCOPY_VECLEN bytes, which means we can use wildcopy
+     * without overlap checking.
+     */
+    if (LIKELY(sequence.offset >= WILDCOPY_VECLEN)) {
+        /* We bet on a full wildcopy for matches, since we expect matches to be
+         * longer than literals (in general). In silesia, ~10% of matches are longer
+         * than 16 bytes.
+         */
+        ZSTD_wildcopy(op, match, (ptrdiff_t)sequence.matchLength, ZSTD_no_overlap);
+        return sequenceLength;
+    }
+    assert(sequence.offset < WILDCOPY_VECLEN);
+
+    /* Copy 8 bytes and spread the offset to be >= 8. */
+    ZSTD_overlapCopy8(&op, &match, sequence.offset);
+
+    /* If the match length is > 8 bytes, then continue with the wildcopy. */
+    if (sequence.matchLength > 8) {
+        assert(op < oMatchEnd);
+        ZSTD_wildcopy(op, match, (ptrdiff_t)sequence.matchLength-8, ZSTD_overlap_src_before_dst);
+    }
+    return sequenceLength;
+}
+
+
+static void
+ZSTD_initFseState(ZSTD_fseState* DStatePtr, BIT_DStream_t* bitD, const ZSTD_seqSymbol* dt)
+{
+    const void* ptr = dt;
+    const ZSTD_seqSymbol_header* const DTableH = (const ZSTD_seqSymbol_header*)ptr;
+    DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);
+    DEBUGLOG(6, "ZSTD_initFseState : val=%u using %u bits",
+                (U32)DStatePtr->state, DTableH->tableLog);
+    BIT_reloadDStream(bitD);
+    DStatePtr->table = dt + 1;
+}
+
+FORCE_INLINE_TEMPLATE void
+ZSTD_updateFseStateWithDInfo(ZSTD_fseState* DStatePtr, BIT_DStream_t* bitD, U16 nextState, U32 nbBits)
+{
+    size_t const lowBits = BIT_readBits(bitD, nbBits);
+    DStatePtr->state = nextState + lowBits;
+}
+
+/* We need to add at most (ZSTD_WINDOWLOG_MAX_32 - 1) bits to read the maximum
+ * offset bits. But we can only read at most STREAM_ACCUMULATOR_MIN_32
+ * bits before reloading. This value is the maximum number of bytes we read
+ * after reloading when we are decoding long offsets.
+ */
+#define LONG_OFFSETS_MAX_EXTRA_BITS_32                       \
+    (ZSTD_WINDOWLOG_MAX_32 > STREAM_ACCUMULATOR_MIN_32       \
+        ? ZSTD_WINDOWLOG_MAX_32 - STREAM_ACCUMULATOR_MIN_32  \
+        : 0)
+
+typedef enum { ZSTD_lo_isRegularOffset, ZSTD_lo_isLongOffset=1 } ZSTD_longOffset_e;
+
+FORCE_INLINE_TEMPLATE seq_t
+ZSTD_decodeSequence(seqState_t* seqState, const ZSTD_longOffset_e longOffsets)
+{
+    seq_t seq;
+    /*
+     * ZSTD_seqSymbol is a structure with a total of 64 bits wide. So it can be
+     * loaded in one operation and extracted its fields by simply shifting or
+     * bit-extracting on aarch64.
+     * GCC doesn't recognize this and generates more unnecessary ldr/ldrb/ldrh
+     * operations that cause performance drop. This can be avoided by using this
+     * ZSTD_memcpy hack.
+     */
+#if defined(__aarch64__) && (defined(__GNUC__) && !defined(__clang__))
+    ZSTD_seqSymbol llDInfoS, mlDInfoS, ofDInfoS;
+    ZSTD_seqSymbol* const llDInfo = &llDInfoS;
+    ZSTD_seqSymbol* const mlDInfo = &mlDInfoS;
+    ZSTD_seqSymbol* const ofDInfo = &ofDInfoS;
+    ZSTD_memcpy(llDInfo, seqState->stateLL.table + seqState->stateLL.state, sizeof(ZSTD_seqSymbol));
+    ZSTD_memcpy(mlDInfo, seqState->stateML.table + seqState->stateML.state, sizeof(ZSTD_seqSymbol));
+    ZSTD_memcpy(ofDInfo, seqState->stateOffb.table + seqState->stateOffb.state, sizeof(ZSTD_seqSymbol));
+#else
+    const ZSTD_seqSymbol* const llDInfo = seqState->stateLL.table + seqState->stateLL.state;
+    const ZSTD_seqSymbol* const mlDInfo = seqState->stateML.table + seqState->stateML.state;
+    const ZSTD_seqSymbol* const ofDInfo = seqState->stateOffb.table + seqState->stateOffb.state;
+#endif
+    seq.matchLength = mlDInfo->baseValue;
+    seq.litLength = llDInfo->baseValue;
+    {   U32 const ofBase = ofDInfo->baseValue;
+        BYTE const llBits = llDInfo->nbAdditionalBits;
+        BYTE const mlBits = mlDInfo->nbAdditionalBits;
+        BYTE const ofBits = ofDInfo->nbAdditionalBits;
+        BYTE const totalBits = llBits+mlBits+ofBits;
+
+        U16 const llNext = llDInfo->nextState;
+        U16 const mlNext = mlDInfo->nextState;
+        U16 const ofNext = ofDInfo->nextState;
+        U32 const llnbBits = llDInfo->nbBits;
+        U32 const mlnbBits = mlDInfo->nbBits;
+        U32 const ofnbBits = ofDInfo->nbBits;
+
+        assert(llBits <= MaxLLBits);
+        assert(mlBits <= MaxMLBits);
+        assert(ofBits <= MaxOff);
+        /*
+         * As gcc has better branch and block analyzers, sometimes it is only
+         * valuable to mark likeliness for clang, it gives around 3-4% of
+         * performance.
+         */
+
+        /* sequence */
+        {   size_t offset;
+            if (ofBits > 1) {
+                ZSTD_STATIC_ASSERT(ZSTD_lo_isLongOffset == 1);
+                ZSTD_STATIC_ASSERT(LONG_OFFSETS_MAX_EXTRA_BITS_32 == 5);
+                ZSTD_STATIC_ASSERT(STREAM_ACCUMULATOR_MIN_32 > LONG_OFFSETS_MAX_EXTRA_BITS_32);
+                ZSTD_STATIC_ASSERT(STREAM_ACCUMULATOR_MIN_32 - LONG_OFFSETS_MAX_EXTRA_BITS_32 >= MaxMLBits);
+                if (MEM_32bits() && longOffsets && (ofBits >= STREAM_ACCUMULATOR_MIN_32)) {
+                    /* Always read extra bits, this keeps the logic simple,
+                     * avoids branches, and avoids accidentally reading 0 bits.
+                     */
+                    U32 const extraBits = LONG_OFFSETS_MAX_EXTRA_BITS_32;
+                    offset = ofBase + (BIT_readBitsFast(&seqState->DStream, ofBits - extraBits) << extraBits);
+                    BIT_reloadDStream(&seqState->DStream);
+                    offset += BIT_readBitsFast(&seqState->DStream, extraBits);
+                } else {
+                    offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits/*>0*/);   /* <=  (ZSTD_WINDOWLOG_MAX-1) bits */
+                    if (MEM_32bits()) BIT_reloadDStream(&seqState->DStream);
+                }
+                seqState->prevOffset[2] = seqState->prevOffset[1];
+                seqState->prevOffset[1] = seqState->prevOffset[0];
+                seqState->prevOffset[0] = offset;
+            } else {
+                U32 const ll0 = (llDInfo->baseValue == 0);
+                if (LIKELY((ofBits == 0))) {
+                    offset = seqState->prevOffset[ll0];
+                    seqState->prevOffset[1] = seqState->prevOffset[!ll0];
+                    seqState->prevOffset[0] = offset;
+                } else {
+                    offset = ofBase + ll0 + BIT_readBitsFast(&seqState->DStream, 1);
+                    {   size_t temp = (offset==3) ? seqState->prevOffset[0] - 1 : seqState->prevOffset[offset];
+                        temp += !temp;   /* 0 is not valid; input is corrupted; force offset to 1 */
+                        if (offset != 1) seqState->prevOffset[2] = seqState->prevOffset[1];
+                        seqState->prevOffset[1] = seqState->prevOffset[0];
+                        seqState->prevOffset[0] = offset = temp;
+            }   }   }
+            seq.offset = offset;
+        }
+
+        if (mlBits > 0)
+            seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits/*>0*/);
+
+        if (MEM_32bits() && (mlBits+llBits >= STREAM_ACCUMULATOR_MIN_32-LONG_OFFSETS_MAX_EXTRA_BITS_32))
+            BIT_reloadDStream(&seqState->DStream);
+        if (MEM_64bits() && UNLIKELY(totalBits >= STREAM_ACCUMULATOR_MIN_64-(LLFSELog+MLFSELog+OffFSELog)))
+            BIT_reloadDStream(&seqState->DStream);
+        /* Ensure there are enough bits to read the rest of data in 64-bit mode. */
+        ZSTD_STATIC_ASSERT(16+LLFSELog+MLFSELog+OffFSELog < STREAM_ACCUMULATOR_MIN_64);
+
+        if (llBits > 0)
+            seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits/*>0*/);
+
+        if (MEM_32bits())
+            BIT_reloadDStream(&seqState->DStream);
+
+        DEBUGLOG(6, "seq: litL=%u, matchL=%u, offset=%u",
+                    (U32)seq.litLength, (U32)seq.matchLength, (U32)seq.offset);
+
+        ZSTD_updateFseStateWithDInfo(&seqState->stateLL, &seqState->DStream, llNext, llnbBits);    /* <=  9 bits */
+        ZSTD_updateFseStateWithDInfo(&seqState->stateML, &seqState->DStream, mlNext, mlnbBits);    /* <=  9 bits */
+        if (MEM_32bits()) BIT_reloadDStream(&seqState->DStream);    /* <= 18 bits */
+        ZSTD_updateFseStateWithDInfo(&seqState->stateOffb, &seqState->DStream, ofNext, ofnbBits);  /* <=  8 bits */
+    }
+
+    return seq;
+}
+
+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+MEM_STATIC int ZSTD_dictionaryIsActive(ZSTD_DCtx const* dctx, BYTE const* prefixStart, BYTE const* oLitEnd)
+{
+    size_t const windowSize = dctx->fParams.windowSize;
+    /* No dictionary used. */
+    if (dctx->dictContentEndForFuzzing == NULL) return 0;
+    /* Dictionary is our prefix. */
+    if (prefixStart == dctx->dictContentBeginForFuzzing) return 1;
+    /* Dictionary is not our ext-dict. */
+    if (dctx->dictEnd != dctx->dictContentEndForFuzzing) return 0;
+    /* Dictionary is not within our window size. */
+    if ((size_t)(oLitEnd - prefixStart) >= windowSize) return 0;
+    /* Dictionary is active. */
+    return 1;
+}
+
+MEM_STATIC void ZSTD_assertValidSequence(
+        ZSTD_DCtx const* dctx,
+        BYTE const* op, BYTE const* oend,
+        seq_t const seq,
+        BYTE const* prefixStart, BYTE const* virtualStart)
+{
+#if DEBUGLEVEL >= 1
+    size_t const windowSize = dctx->fParams.windowSize;
+    size_t const sequenceSize = seq.litLength + seq.matchLength;
+    BYTE const* const oLitEnd = op + seq.litLength;
+    DEBUGLOG(6, "Checking sequence: litL=%u matchL=%u offset=%u",
+            (U32)seq.litLength, (U32)seq.matchLength, (U32)seq.offset);
+    assert(op <= oend);
+    assert((size_t)(oend - op) >= sequenceSize);
+    assert(sequenceSize <= ZSTD_BLOCKSIZE_MAX);
+    if (ZSTD_dictionaryIsActive(dctx, prefixStart, oLitEnd)) {
+        size_t const dictSize = (size_t)((char const*)dctx->dictContentEndForFuzzing - (char const*)dctx->dictContentBeginForFuzzing);
+        /* Offset must be within the dictionary. */
+        assert(seq.offset <= (size_t)(oLitEnd - virtualStart));
+        assert(seq.offset <= windowSize + dictSize);
+    } else {
+        /* Offset must be within our window. */
+        assert(seq.offset <= windowSize);
+    }
+#else
+    (void)dctx, (void)op, (void)oend, (void)seq, (void)prefixStart, (void)virtualStart;
+#endif
+}
+#endif
+
+#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG
+
+
+FORCE_INLINE_TEMPLATE size_t
+DONT_VECTORIZE
+ZSTD_decompressSequences_bodySplitLitBuffer( ZSTD_DCtx* dctx,
+                               void* dst, size_t maxDstSize,
+                         const void* seqStart, size_t seqSize, int nbSeq,
+                         const ZSTD_longOffset_e isLongOffset,
+                         const int frame)
+{
+    const BYTE* ip = (const BYTE*)seqStart;
+    const BYTE* const iend = ip + seqSize;
+    BYTE* const ostart = (BYTE*)dst;
+    BYTE* const oend = ostart + maxDstSize;
+    BYTE* op = ostart;
+    const BYTE* litPtr = dctx->litPtr;
+    const BYTE* litBufferEnd = dctx->litBufferEnd;
+    const BYTE* const prefixStart = (const BYTE*) (dctx->prefixStart);
+    const BYTE* const vBase = (const BYTE*) (dctx->virtualStart);
+    const BYTE* const dictEnd = (const BYTE*) (dctx->dictEnd);
+    DEBUGLOG(5, "ZSTD_decompressSequences_bodySplitLitBuffer");
+    (void)frame;
+
+    /* Regen sequences */
+    if (nbSeq) {
+        seqState_t seqState;
+        dctx->fseEntropy = 1;
+        { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) seqState.prevOffset[i] = dctx->entropy.rep[i]; }
+        RETURN_ERROR_IF(
+            ERR_isError(BIT_initDStream(&seqState.DStream, ip, iend-ip)),
+            corruption_detected, "");
+        ZSTD_initFseState(&seqState.stateLL, &seqState.DStream, dctx->LLTptr);
+        ZSTD_initFseState(&seqState.stateOffb, &seqState.DStream, dctx->OFTptr);
+        ZSTD_initFseState(&seqState.stateML, &seqState.DStream, dctx->MLTptr);
+        assert(dst != NULL);
+
+        ZSTD_STATIC_ASSERT(
+                BIT_DStream_unfinished < BIT_DStream_completed &&
+                BIT_DStream_endOfBuffer < BIT_DStream_completed &&
+                BIT_DStream_completed < BIT_DStream_overflow);
+
+        /* decompress without overrunning litPtr begins */
+        {
+            seq_t sequence = ZSTD_decodeSequence(&seqState, isLongOffset);
+            /* Align the decompression loop to 32 + 16 bytes.
+                *
+                * zstd compiled with gcc-9 on an Intel i9-9900k shows 10% decompression
+                * speed swings based on the alignment of the decompression loop. This
+                * performance swing is caused by parts of the decompression loop falling
+                * out of the DSB. The entire decompression loop should fit in the DSB,
+                * when it can't we get much worse performance. You can measure if you've
+                * hit the good case or the bad case with this perf command for some
+                * compressed file test.zst:
+                *
+                *   perf stat -e cycles -e instructions -e idq.all_dsb_cycles_any_uops \
+                *             -e idq.all_mite_cycles_any_uops -- ./zstd -tq test.zst
+                *
+                * If you see most cycles served out of the MITE you've hit the bad case.
+                * If you see most cycles served out of the DSB you've hit the good case.
+                * If it is pretty even then you may be in an okay case.
+                *
+                * This issue has been reproduced on the following CPUs:
+                *   - Kabylake: Macbook Pro (15-inch, 2019) 2.4 GHz Intel Core i9
+                *               Use Instruments->Counters to get DSB/MITE cycles.
+                *               I never got performance swings, but I was able to
+                *               go from the good case of mostly DSB to half of the
+                *               cycles served from MITE.
+                *   - Coffeelake: Intel i9-9900k
+                *   - Coffeelake: Intel i7-9700k
+                *
+                * I haven't been able to reproduce the instability or DSB misses on any
+                * of the following CPUS:
+                *   - Haswell
+                *   - Broadwell: Intel(R) Xeon(R) CPU E5-2680 v4 @ 2.40GH
+                *   - Skylake
+                *
+                * Alignment is done for each of the three major decompression loops:
+                *   - ZSTD_decompressSequences_bodySplitLitBuffer - presplit section of the literal buffer
+                *   - ZSTD_decompressSequences_bodySplitLitBuffer - postsplit section of the literal buffer
+                *   - ZSTD_decompressSequences_body
+                * Alignment choices are made to minimize large swings on bad cases and influence on performance
+                * from changes external to this code, rather than to overoptimize on the current commit.
+                *
+                * If you are seeing performance stability this script can help test.
+                * It tests on 4 commits in zstd where I saw performance change.
+                *
+                *   https://gist.github.com/terrelln/9889fc06a423fd5ca6e99351564473f4
+                */
+#if defined(__GNUC__) && defined(__x86_64__)
+            __asm__(".p2align 6");
+#  if __GNUC__ >= 7
+	    /* good for gcc-7, gcc-9, and gcc-11 */
+            __asm__("nop");
+            __asm__(".p2align 5");
+            __asm__("nop");
+            __asm__(".p2align 4");
+#    if __GNUC__ == 8 || __GNUC__ == 10
+	    /* good for gcc-8 and gcc-10 */
+            __asm__("nop");
+            __asm__(".p2align 3");
+#    endif
+#  endif
+#endif
+
+            /* Handle the initial state where litBuffer is currently split between dst and litExtraBuffer */
+            for (; litPtr + sequence.litLength <= dctx->litBufferEnd; ) {
+                size_t const oneSeqSize = ZSTD_execSequenceSplitLitBuffer(op, oend, litPtr + sequence.litLength - WILDCOPY_OVERLENGTH, sequence, &litPtr, litBufferEnd, prefixStart, vBase, dictEnd);
+#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)
+                assert(!ZSTD_isError(oneSeqSize));
+                if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequence, prefixStart, vBase);
+#endif
+                if (UNLIKELY(ZSTD_isError(oneSeqSize)))
+                    return oneSeqSize;
+                DEBUGLOG(6, "regenerated sequence size : %u", (U32)oneSeqSize);
+                op += oneSeqSize;
+                if (UNLIKELY(!--nbSeq))
+                    break;
+                BIT_reloadDStream(&(seqState.DStream));
+                sequence = ZSTD_decodeSequence(&seqState, isLongOffset);
+            }
+
+            /* If there are more sequences, they will need to read literals from litExtraBuffer; copy over the remainder from dst and update litPtr and litEnd */
+            if (nbSeq > 0) {
+                const size_t leftoverLit = dctx->litBufferEnd - litPtr;
+                if (leftoverLit)
+                {
+                    RETURN_ERROR_IF(leftoverLit > (size_t)(oend - op), dstSize_tooSmall, "remaining lit must fit within dstBuffer");
+                    ZSTD_safecopyDstBeforeSrc(op, litPtr, leftoverLit);
+                    sequence.litLength -= leftoverLit;
+                    op += leftoverLit;
+                }
+                litPtr = dctx->litExtraBuffer;
+                litBufferEnd = dctx->litExtraBuffer + ZSTD_LITBUFFEREXTRASIZE;
+                dctx->litBufferLocation = ZSTD_not_in_dst;
+                {
+                    size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequence, &litPtr, litBufferEnd, prefixStart, vBase, dictEnd);
+#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)
+                    assert(!ZSTD_isError(oneSeqSize));
+                    if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequence, prefixStart, vBase);
+#endif
+                    if (UNLIKELY(ZSTD_isError(oneSeqSize)))
+                        return oneSeqSize;
+                    DEBUGLOG(6, "regenerated sequence size : %u", (U32)oneSeqSize);
+                    op += oneSeqSize;
+                    if (--nbSeq)
+                        BIT_reloadDStream(&(seqState.DStream));
+                }
+            }
+        }
+
+        if (nbSeq > 0) /* there is remaining lit from extra buffer */
+        {
+
+#if defined(__GNUC__) && defined(__x86_64__)
+            __asm__(".p2align 6");
+            __asm__("nop");
+#  if __GNUC__ != 7
+            /* worse for gcc-7 better for gcc-8, gcc-9, and gcc-10 and clang */
+            __asm__(".p2align 4");
+            __asm__("nop");
+            __asm__(".p2align 3");
+#  elif __GNUC__ >= 11
+            __asm__(".p2align 3");
+#  else
+            __asm__(".p2align 5");
+            __asm__("nop");
+            __asm__(".p2align 3");
+#  endif
+#endif
+
+            for (; ; ) {
+                seq_t const sequence = ZSTD_decodeSequence(&seqState, isLongOffset);
+                size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequence, &litPtr, litBufferEnd, prefixStart, vBase, dictEnd);
+#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)
+                assert(!ZSTD_isError(oneSeqSize));
+                if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequence, prefixStart, vBase);
+#endif
+                if (UNLIKELY(ZSTD_isError(oneSeqSize)))
+                    return oneSeqSize;
+                DEBUGLOG(6, "regenerated sequence size : %u", (U32)oneSeqSize);
+                op += oneSeqSize;
+                if (UNLIKELY(!--nbSeq))
+                    break;
+                BIT_reloadDStream(&(seqState.DStream));
+            }
+        }
+
+        /* check if reached exact end */
+        DEBUGLOG(5, "ZSTD_decompressSequences_bodySplitLitBuffer: after decode loop, remaining nbSeq : %i", nbSeq);
+        RETURN_ERROR_IF(nbSeq, corruption_detected, "");
+        RETURN_ERROR_IF(BIT_reloadDStream(&seqState.DStream) < BIT_DStream_completed, corruption_detected, "");
+        /* save reps for next block */
+        { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) dctx->entropy.rep[i] = (U32)(seqState.prevOffset[i]); }
+    }
+
+    /* last literal segment */
+    if (dctx->litBufferLocation == ZSTD_split)  /* split hasn't been reached yet, first get dst then copy litExtraBuffer */
+    {
+        size_t const lastLLSize = litBufferEnd - litPtr;
+        RETURN_ERROR_IF(lastLLSize > (size_t)(oend - op), dstSize_tooSmall, "");
+        if (op != NULL) {
+            ZSTD_memmove(op, litPtr, lastLLSize);
+            op += lastLLSize;
+        }
+        litPtr = dctx->litExtraBuffer;
+        litBufferEnd = dctx->litExtraBuffer + ZSTD_LITBUFFEREXTRASIZE;
+        dctx->litBufferLocation = ZSTD_not_in_dst;
+    }
+    {   size_t const lastLLSize = litBufferEnd - litPtr;
+        RETURN_ERROR_IF(lastLLSize > (size_t)(oend-op), dstSize_tooSmall, "");
+        if (op != NULL) {
+            ZSTD_memcpy(op, litPtr, lastLLSize);
+            op += lastLLSize;
+        }
+    }
+
+    return op-ostart;
+}
+
+FORCE_INLINE_TEMPLATE size_t
+DONT_VECTORIZE
+ZSTD_decompressSequences_body(ZSTD_DCtx* dctx,
+    void* dst, size_t maxDstSize,
+    const void* seqStart, size_t seqSize, int nbSeq,
+    const ZSTD_longOffset_e isLongOffset,
+    const int frame)
+{
+    const BYTE* ip = (const BYTE*)seqStart;
+    const BYTE* const iend = ip + seqSize;
+    BYTE* const ostart = (BYTE*)dst;
+    BYTE* const oend = dctx->litBufferLocation == ZSTD_not_in_dst ? ostart + maxDstSize : dctx->litBuffer;
+    BYTE* op = ostart;
+    const BYTE* litPtr = dctx->litPtr;
+    const BYTE* const litEnd = litPtr + dctx->litSize;
+    const BYTE* const prefixStart = (const BYTE*)(dctx->prefixStart);
+    const BYTE* const vBase = (const BYTE*)(dctx->virtualStart);
+    const BYTE* const dictEnd = (const BYTE*)(dctx->dictEnd);
+    DEBUGLOG(5, "ZSTD_decompressSequences_body: nbSeq = %d", nbSeq);
+    (void)frame;
+
+    /* Regen sequences */
+    if (nbSeq) {
+        seqState_t seqState;
+        dctx->fseEntropy = 1;
+        { U32 i; for (i = 0; i < ZSTD_REP_NUM; i++) seqState.prevOffset[i] = dctx->entropy.rep[i]; }
+        RETURN_ERROR_IF(
+            ERR_isError(BIT_initDStream(&seqState.DStream, ip, iend - ip)),
+            corruption_detected, "");
+        ZSTD_initFseState(&seqState.stateLL, &seqState.DStream, dctx->LLTptr);
+        ZSTD_initFseState(&seqState.stateOffb, &seqState.DStream, dctx->OFTptr);
+        ZSTD_initFseState(&seqState.stateML, &seqState.DStream, dctx->MLTptr);
+        assert(dst != NULL);
+
+        ZSTD_STATIC_ASSERT(
+            BIT_DStream_unfinished < BIT_DStream_completed &&
+            BIT_DStream_endOfBuffer < BIT_DStream_completed &&
+            BIT_DStream_completed < BIT_DStream_overflow);
+
+#if defined(__GNUC__) && defined(__x86_64__)
+            __asm__(".p2align 6");
+            __asm__("nop");
+#  if __GNUC__ >= 7
+            __asm__(".p2align 5");
+            __asm__("nop");
+            __asm__(".p2align 3");
+#  else
+            __asm__(".p2align 4");
+            __asm__("nop");
+            __asm__(".p2align 3");
+#  endif
+#endif
+
+        for ( ; ; ) {
+            seq_t const sequence = ZSTD_decodeSequence(&seqState, isLongOffset);
+            size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequence, &litPtr, litEnd, prefixStart, vBase, dictEnd);
+#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)
+            assert(!ZSTD_isError(oneSeqSize));
+            if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequence, prefixStart, vBase);
+#endif
+            if (UNLIKELY(ZSTD_isError(oneSeqSize)))
+                return oneSeqSize;
+            DEBUGLOG(6, "regenerated sequence size : %u", (U32)oneSeqSize);
+            op += oneSeqSize;
+            if (UNLIKELY(!--nbSeq))
+                break;
+            BIT_reloadDStream(&(seqState.DStream));
+        }
+
+        /* check if reached exact end */
+        DEBUGLOG(5, "ZSTD_decompressSequences_body: after decode loop, remaining nbSeq : %i", nbSeq);
+        RETURN_ERROR_IF(nbSeq, corruption_detected, "");
+        RETURN_ERROR_IF(BIT_reloadDStream(&seqState.DStream) < BIT_DStream_completed, corruption_detected, "");
+        /* save reps for next block */
+        { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) dctx->entropy.rep[i] = (U32)(seqState.prevOffset[i]); }
+    }
+
+    /* last literal segment */
+    {   size_t const lastLLSize = litEnd - litPtr;
+        RETURN_ERROR_IF(lastLLSize > (size_t)(oend-op), dstSize_tooSmall, "");
+        if (op != NULL) {
+            ZSTD_memcpy(op, litPtr, lastLLSize);
+            op += lastLLSize;
+        }
+    }
+
+    return op-ostart;
+}
+
+static size_t
+ZSTD_decompressSequences_default(ZSTD_DCtx* dctx,
+                                 void* dst, size_t maxDstSize,
+                           const void* seqStart, size_t seqSize, int nbSeq,
+                           const ZSTD_longOffset_e isLongOffset,
+                           const int frame)
+{
+    return ZSTD_decompressSequences_body(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);
+}
+
+static size_t
+ZSTD_decompressSequencesSplitLitBuffer_default(ZSTD_DCtx* dctx,
+                                               void* dst, size_t maxDstSize,
+                                         const void* seqStart, size_t seqSize, int nbSeq,
+                                         const ZSTD_longOffset_e isLongOffset,
+                                         const int frame)
+{
+    return ZSTD_decompressSequences_bodySplitLitBuffer(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);
+}
+#endif /* ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG */
+
+#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT
+
+FORCE_INLINE_TEMPLATE size_t
+ZSTD_prefetchMatch(size_t prefetchPos, seq_t const sequence,
+                   const BYTE* const prefixStart, const BYTE* const dictEnd)
+{
+    prefetchPos += sequence.litLength;
+    {   const BYTE* const matchBase = (sequence.offset > prefetchPos) ? dictEnd : prefixStart;
+        const BYTE* const match = matchBase + prefetchPos - sequence.offset; /* note : this operation can overflow when seq.offset is really too large, which can only happen when input is corrupted.
+                                                                              * No consequence though : memory address is only used for prefetching, not for dereferencing */
+        PREFETCH_L1(match); PREFETCH_L1(match+CACHELINE_SIZE);   /* note : it's safe to invoke PREFETCH() on any memory address, including invalid ones */
+    }
+    return prefetchPos + sequence.matchLength;
+}
+
+/* This decoding function employs prefetching
+ * to reduce latency impact of cache misses.
+ * It's generally employed when block contains a significant portion of long-distance matches
+ * or when coupled with a "cold" dictionary */
+FORCE_INLINE_TEMPLATE size_t
+ZSTD_decompressSequencesLong_body(
+                               ZSTD_DCtx* dctx,
+                               void* dst, size_t maxDstSize,
+                         const void* seqStart, size_t seqSize, int nbSeq,
+                         const ZSTD_longOffset_e isLongOffset,
+                         const int frame)
+{
+    const BYTE* ip = (const BYTE*)seqStart;
+    const BYTE* const iend = ip + seqSize;
+    BYTE* const ostart = (BYTE*)dst;
+    BYTE* const oend = dctx->litBufferLocation == ZSTD_in_dst ? dctx->litBuffer : ostart + maxDstSize;
+    BYTE* op = ostart;
+    const BYTE* litPtr = dctx->litPtr;
+    const BYTE* litBufferEnd = dctx->litBufferEnd;
+    const BYTE* const prefixStart = (const BYTE*) (dctx->prefixStart);
+    const BYTE* const dictStart = (const BYTE*) (dctx->virtualStart);
+    const BYTE* const dictEnd = (const BYTE*) (dctx->dictEnd);
+    (void)frame;
+
+    /* Regen sequences */
+    if (nbSeq) {
+#define STORED_SEQS 8
+#define STORED_SEQS_MASK (STORED_SEQS-1)
+#define ADVANCED_SEQS STORED_SEQS
+        seq_t sequences[STORED_SEQS];
+        int const seqAdvance = MIN(nbSeq, ADVANCED_SEQS);
+        seqState_t seqState;
+        int seqNb;
+        size_t prefetchPos = (size_t)(op-prefixStart); /* track position relative to prefixStart */
+
+        dctx->fseEntropy = 1;
+        { int i; for (i=0; i<ZSTD_REP_NUM; i++) seqState.prevOffset[i] = dctx->entropy.rep[i]; }
+        assert(dst != NULL);
+        assert(iend >= ip);
+        RETURN_ERROR_IF(
+            ERR_isError(BIT_initDStream(&seqState.DStream, ip, iend-ip)),
+            corruption_detected, "");
+        ZSTD_initFseState(&seqState.stateLL, &seqState.DStream, dctx->LLTptr);
+        ZSTD_initFseState(&seqState.stateOffb, &seqState.DStream, dctx->OFTptr);
+        ZSTD_initFseState(&seqState.stateML, &seqState.DStream, dctx->MLTptr);
+
+        /* prepare in advance */
+        for (seqNb=0; (BIT_reloadDStream(&seqState.DStream) <= BIT_DStream_completed) && (seqNb<seqAdvance); seqNb++) {
+            seq_t const sequence = ZSTD_decodeSequence(&seqState, isLongOffset);
+            prefetchPos = ZSTD_prefetchMatch(prefetchPos, sequence, prefixStart, dictEnd);
+            sequences[seqNb] = sequence;
+        }
+        RETURN_ERROR_IF(seqNb<seqAdvance, corruption_detected, "");
+
+        /* decompress without stomping litBuffer */
+        for (; (BIT_reloadDStream(&(seqState.DStream)) <= BIT_DStream_completed) && (seqNb < nbSeq); seqNb++) {
+            seq_t sequence = ZSTD_decodeSequence(&seqState, isLongOffset);
+            size_t oneSeqSize;
+
+            if (dctx->litBufferLocation == ZSTD_split && litPtr + sequences[(seqNb - ADVANCED_SEQS) & STORED_SEQS_MASK].litLength > dctx->litBufferEnd)
+            {
+                /* lit buffer is reaching split point, empty out the first buffer and transition to litExtraBuffer */
+                const size_t leftoverLit = dctx->litBufferEnd - litPtr;
+                if (leftoverLit)
+                {
+                    RETURN_ERROR_IF(leftoverLit > (size_t)(oend - op), dstSize_tooSmall, "remaining lit must fit within dstBuffer");
+                    ZSTD_safecopyDstBeforeSrc(op, litPtr, leftoverLit);
+                    sequences[(seqNb - ADVANCED_SEQS) & STORED_SEQS_MASK].litLength -= leftoverLit;
+                    op += leftoverLit;
+                }
+                litPtr = dctx->litExtraBuffer;
+                litBufferEnd = dctx->litExtraBuffer + ZSTD_LITBUFFEREXTRASIZE;
+                dctx->litBufferLocation = ZSTD_not_in_dst;
+                oneSeqSize = ZSTD_execSequence(op, oend, sequences[(seqNb - ADVANCED_SEQS) & STORED_SEQS_MASK], &litPtr, litBufferEnd, prefixStart, dictStart, dictEnd);
+#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)
+                assert(!ZSTD_isError(oneSeqSize));
+                if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequences[(seqNb - ADVANCED_SEQS) & STORED_SEQS_MASK], prefixStart, dictStart);
+#endif
+                if (ZSTD_isError(oneSeqSize)) return oneSeqSize;
+
+                prefetchPos = ZSTD_prefetchMatch(prefetchPos, sequence, prefixStart, dictEnd);
+                sequences[seqNb & STORED_SEQS_MASK] = sequence;
+                op += oneSeqSize;
+            }
+            else
+            {
+                /* lit buffer is either wholly contained in first or second split, or not split at all*/
+                oneSeqSize = dctx->litBufferLocation == ZSTD_split ?
+                    ZSTD_execSequenceSplitLitBuffer(op, oend, litPtr + sequences[(seqNb - ADVANCED_SEQS) & STORED_SEQS_MASK].litLength - WILDCOPY_OVERLENGTH, sequences[(seqNb - ADVANCED_SEQS) & STORED_SEQS_MASK], &litPtr, litBufferEnd, prefixStart, dictStart, dictEnd) :
+                    ZSTD_execSequence(op, oend, sequences[(seqNb - ADVANCED_SEQS) & STORED_SEQS_MASK], &litPtr, litBufferEnd, prefixStart, dictStart, dictEnd);
+#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)
+                assert(!ZSTD_isError(oneSeqSize));
+                if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequences[(seqNb - ADVANCED_SEQS) & STORED_SEQS_MASK], prefixStart, dictStart);
+#endif
+                if (ZSTD_isError(oneSeqSize)) return oneSeqSize;
+
+                prefetchPos = ZSTD_prefetchMatch(prefetchPos, sequence, prefixStart, dictEnd);
+                sequences[seqNb & STORED_SEQS_MASK] = sequence;
+                op += oneSeqSize;
+            }
+        }
+        RETURN_ERROR_IF(seqNb<nbSeq, corruption_detected, "");
+
+        /* finish queue */
+        seqNb -= seqAdvance;
+        for ( ; seqNb<nbSeq ; seqNb++) {
+            seq_t *sequence = &(sequences[seqNb&STORED_SEQS_MASK]);
+            if (dctx->litBufferLocation == ZSTD_split && litPtr + sequence->litLength > dctx->litBufferEnd)
+            {
+                const size_t leftoverLit = dctx->litBufferEnd - litPtr;
+                if (leftoverLit)
+                {
+                    RETURN_ERROR_IF(leftoverLit > (size_t)(oend - op), dstSize_tooSmall, "remaining lit must fit within dstBuffer");
+                    ZSTD_safecopyDstBeforeSrc(op, litPtr, leftoverLit);
+                    sequence->litLength -= leftoverLit;
+                    op += leftoverLit;
+                }
+                litPtr = dctx->litExtraBuffer;
+                litBufferEnd = dctx->litExtraBuffer + ZSTD_LITBUFFEREXTRASIZE;
+                dctx->litBufferLocation = ZSTD_not_in_dst;
+                {
+                    size_t const oneSeqSize = ZSTD_execSequence(op, oend, *sequence, &litPtr, litBufferEnd, prefixStart, dictStart, dictEnd);
+#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)
+                    assert(!ZSTD_isError(oneSeqSize));
+                    if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequences[seqNb&STORED_SEQS_MASK], prefixStart, dictStart);
+#endif
+                    if (ZSTD_isError(oneSeqSize)) return oneSeqSize;
+                    op += oneSeqSize;
+                }
+            }
+            else
+            {
+                size_t const oneSeqSize = dctx->litBufferLocation == ZSTD_split ?
+                    ZSTD_execSequenceSplitLitBuffer(op, oend, litPtr + sequence->litLength - WILDCOPY_OVERLENGTH, *sequence, &litPtr, litBufferEnd, prefixStart, dictStart, dictEnd) :
+                    ZSTD_execSequence(op, oend, *sequence, &litPtr, litBufferEnd, prefixStart, dictStart, dictEnd);
+#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)
+                assert(!ZSTD_isError(oneSeqSize));
+                if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequences[seqNb&STORED_SEQS_MASK], prefixStart, dictStart);
+#endif
+                if (ZSTD_isError(oneSeqSize)) return oneSeqSize;
+                op += oneSeqSize;
+            }
+        }
+
+        /* save reps for next block */
+        { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) dctx->entropy.rep[i] = (U32)(seqState.prevOffset[i]); }
+    }
+
+    /* last literal segment */
+    if (dctx->litBufferLocation == ZSTD_split)  /* first deplete literal buffer in dst, then copy litExtraBuffer */
+    {
+        size_t const lastLLSize = litBufferEnd - litPtr;
+        RETURN_ERROR_IF(lastLLSize > (size_t)(oend - op), dstSize_tooSmall, "");
+        if (op != NULL) {
+            ZSTD_memmove(op, litPtr, lastLLSize);
+            op += lastLLSize;
+        }
+        litPtr = dctx->litExtraBuffer;
+        litBufferEnd = dctx->litExtraBuffer + ZSTD_LITBUFFEREXTRASIZE;
+    }
+    {   size_t const lastLLSize = litBufferEnd - litPtr;
+        RETURN_ERROR_IF(lastLLSize > (size_t)(oend-op), dstSize_tooSmall, "");
+        if (op != NULL) {
+            ZSTD_memmove(op, litPtr, lastLLSize);
+            op += lastLLSize;
+        }
+    }
+
+    return op-ostart;
+}
+
+static size_t
+ZSTD_decompressSequencesLong_default(ZSTD_DCtx* dctx,
+                                 void* dst, size_t maxDstSize,
+                           const void* seqStart, size_t seqSize, int nbSeq,
+                           const ZSTD_longOffset_e isLongOffset,
+                           const int frame)
+{
+    return ZSTD_decompressSequencesLong_body(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);
+}
+#endif /* ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT */
+
+
+
+#if DYNAMIC_BMI2
+
+#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG
+static BMI2_TARGET_ATTRIBUTE size_t
+DONT_VECTORIZE
+ZSTD_decompressSequences_bmi2(ZSTD_DCtx* dctx,
+                                 void* dst, size_t maxDstSize,
+                           const void* seqStart, size_t seqSize, int nbSeq,
+                           const ZSTD_longOffset_e isLongOffset,
+                           const int frame)
+{
+    return ZSTD_decompressSequences_body(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);
+}
+static BMI2_TARGET_ATTRIBUTE size_t
+DONT_VECTORIZE
+ZSTD_decompressSequencesSplitLitBuffer_bmi2(ZSTD_DCtx* dctx,
+                                 void* dst, size_t maxDstSize,
+                           const void* seqStart, size_t seqSize, int nbSeq,
+                           const ZSTD_longOffset_e isLongOffset,
+                           const int frame)
+{
+    return ZSTD_decompressSequences_bodySplitLitBuffer(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);
+}
+#endif /* ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG */
+
+#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT
+static BMI2_TARGET_ATTRIBUTE size_t
+ZSTD_decompressSequencesLong_bmi2(ZSTD_DCtx* dctx,
+                                 void* dst, size_t maxDstSize,
+                           const void* seqStart, size_t seqSize, int nbSeq,
+                           const ZSTD_longOffset_e isLongOffset,
+                           const int frame)
+{
+    return ZSTD_decompressSequencesLong_body(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);
+}
+#endif /* ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT */
+
+#endif /* DYNAMIC_BMI2 */
+
+typedef size_t (*ZSTD_decompressSequences_t)(
+                            ZSTD_DCtx* dctx,
+                            void* dst, size_t maxDstSize,
+                            const void* seqStart, size_t seqSize, int nbSeq,
+                            const ZSTD_longOffset_e isLongOffset,
+                            const int frame);
+
+#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG
+static size_t
+ZSTD_decompressSequences(ZSTD_DCtx* dctx, void* dst, size_t maxDstSize,
+                   const void* seqStart, size_t seqSize, int nbSeq,
+                   const ZSTD_longOffset_e isLongOffset,
+                   const int frame)
+{
+    DEBUGLOG(5, "ZSTD_decompressSequences");
+#if DYNAMIC_BMI2
+    if (ZSTD_DCtx_get_bmi2(dctx)) {
+        return ZSTD_decompressSequences_bmi2(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);
+    }
+#endif
+    return ZSTD_decompressSequences_default(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);
+}
+static size_t
+ZSTD_decompressSequencesSplitLitBuffer(ZSTD_DCtx* dctx, void* dst, size_t maxDstSize,
+                                 const void* seqStart, size_t seqSize, int nbSeq,
+                                 const ZSTD_longOffset_e isLongOffset,
+                                 const int frame)
+{
+    DEBUGLOG(5, "ZSTD_decompressSequencesSplitLitBuffer");
+#if DYNAMIC_BMI2
+    if (ZSTD_DCtx_get_bmi2(dctx)) {
+        return ZSTD_decompressSequencesSplitLitBuffer_bmi2(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);
+    }
+#endif
+    return ZSTD_decompressSequencesSplitLitBuffer_default(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);
+}
+#endif /* ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG */
+
+
+#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT
+/* ZSTD_decompressSequencesLong() :
+ * decompression function triggered when a minimum share of offsets is considered "long",
+ * aka out of cache.
+ * note : "long" definition seems overloaded here, sometimes meaning "wider than bitstream register", and sometimes meaning "farther than memory cache distance".
+ * This function will try to mitigate main memory latency through the use of prefetching */
+static size_t
+ZSTD_decompressSequencesLong(ZSTD_DCtx* dctx,
+                             void* dst, size_t maxDstSize,
+                             const void* seqStart, size_t seqSize, int nbSeq,
+                             const ZSTD_longOffset_e isLongOffset,
+                             const int frame)
+{
+    DEBUGLOG(5, "ZSTD_decompressSequencesLong");
+#if DYNAMIC_BMI2
+    if (ZSTD_DCtx_get_bmi2(dctx)) {
+        return ZSTD_decompressSequencesLong_bmi2(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);
+    }
+#endif
+  return ZSTD_decompressSequencesLong_default(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);
+}
+#endif /* ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT */
+
+
+/**
+ * @returns The total size of the history referenceable by zstd, including
+ * both the prefix and the extDict. At @p op any offset larger than this
+ * is invalid.
+ */
+static size_t ZSTD_totalHistorySize(BYTE* op, BYTE const* virtualStart)
+{
+    return (size_t)(op - virtualStart);
+}
+
+typedef struct {
+    unsigned longOffsetShare;
+    unsigned maxNbAdditionalBits;
+} ZSTD_OffsetInfo;
+
+/* ZSTD_getOffsetInfo() :
+ * condition : offTable must be valid
+ * @return : "share" of long offsets (arbitrarily defined as > (1<<23))
+ *           compared to maximum possible of (1<<OffFSELog),
+ *           as well as the maximum number additional bits required.
+ */
+static ZSTD_OffsetInfo
+ZSTD_getOffsetInfo(const ZSTD_seqSymbol* offTable, int nbSeq)
+{
+    ZSTD_OffsetInfo info = {0, 0};
+    /* If nbSeq == 0, then the offTable is uninitialized, but we have
+     * no sequences, so both values should be 0.
+     */
+    if (nbSeq != 0) {
+        const void* ptr = offTable;
+        U32 const tableLog = ((const ZSTD_seqSymbol_header*)ptr)[0].tableLog;
+        const ZSTD_seqSymbol* table = offTable + 1;
+        U32 const max = 1 << tableLog;
+        U32 u;
+        DEBUGLOG(5, "ZSTD_getLongOffsetsShare: (tableLog=%u)", tableLog);
+
+        assert(max <= (1 << OffFSELog));  /* max not too large */
+        for (u=0; u<max; u++) {
+            info.maxNbAdditionalBits = MAX(info.maxNbAdditionalBits, table[u].nbAdditionalBits);
+            if (table[u].nbAdditionalBits > 22) info.longOffsetShare += 1;
+        }
+
+        assert(tableLog <= OffFSELog);
+        info.longOffsetShare <<= (OffFSELog - tableLog);  /* scale to OffFSELog */
+    }
+
+    return info;
+}
+
+/**
+ * @returns The maximum offset we can decode in one read of our bitstream, without
+ * reloading more bits in the middle of the offset bits read. Any offsets larger
+ * than this must use the long offset decoder.
+ */
+static size_t ZSTD_maxShortOffset(void)
+{
+    if (MEM_64bits()) {
+        /* We can decode any offset without reloading bits.
+         * This might change if the max window size grows.
+         */
+        ZSTD_STATIC_ASSERT(ZSTD_WINDOWLOG_MAX <= 31);
+        return (size_t)-1;
+    } else {
+        /* The maximum offBase is (1 << (STREAM_ACCUMULATOR_MIN + 1)) - 1.
+         * This offBase would require STREAM_ACCUMULATOR_MIN extra bits.
+         * Then we have to subtract ZSTD_REP_NUM to get the maximum possible offset.
+         */
+        size_t const maxOffbase = ((size_t)1 << (STREAM_ACCUMULATOR_MIN + 1)) - 1;
+        size_t const maxOffset = maxOffbase - ZSTD_REP_NUM;
+        assert(ZSTD_highbit32((U32)maxOffbase) == STREAM_ACCUMULATOR_MIN);
+        return maxOffset;
+    }
+}
+
+size_t
+ZSTD_decompressBlock_internal(ZSTD_DCtx* dctx,
+                              void* dst, size_t dstCapacity,
+                        const void* src, size_t srcSize, const int frame, const streaming_operation streaming)
+{   /* blockType == blockCompressed */
+    const BYTE* ip = (const BYTE*)src;
+    DEBUGLOG(5, "ZSTD_decompressBlock_internal (size : %u)", (U32)srcSize);
+
+    /* Note : the wording of the specification
+     * allows compressed block to be sized exactly ZSTD_BLOCKSIZE_MAX.
+     * This generally does not happen, as it makes little sense,
+     * since an uncompressed block would feature same size and have no decompression cost.
+     * Also, note that decoder from reference libzstd before < v1.5.4
+     * would consider this edge case as an error.
+     * As a consequence, avoid generating compressed blocks of size ZSTD_BLOCKSIZE_MAX
+     * for broader compatibility with the deployed ecosystem of zstd decoders */
+    RETURN_ERROR_IF(srcSize > ZSTD_BLOCKSIZE_MAX, srcSize_wrong, "");
+
+    /* Decode literals section */
+    {   size_t const litCSize = ZSTD_decodeLiteralsBlock(dctx, src, srcSize, dst, dstCapacity, streaming);
+        DEBUGLOG(5, "ZSTD_decodeLiteralsBlock : cSize=%u, nbLiterals=%zu", (U32)litCSize, dctx->litSize);
+        if (ZSTD_isError(litCSize)) return litCSize;
+        ip += litCSize;
+        srcSize -= litCSize;
+    }
+
+    /* Build Decoding Tables */
+    {
+        /* Compute the maximum block size, which must also work when !frame and fParams are unset.
+         * Additionally, take the min with dstCapacity to ensure that the totalHistorySize fits in a size_t.
+         */
+        size_t const blockSizeMax = MIN(dstCapacity, (frame ? dctx->fParams.blockSizeMax : ZSTD_BLOCKSIZE_MAX));
+        size_t const totalHistorySize = ZSTD_totalHistorySize((BYTE*)dst + blockSizeMax, (BYTE const*)dctx->virtualStart);
+        /* isLongOffset must be true if there are long offsets.
+         * Offsets are long if they are larger than ZSTD_maxShortOffset().
+         * We don't expect that to be the case in 64-bit mode.
+         *
+         * We check here to see if our history is large enough to allow long offsets.
+         * If it isn't, then we can't possible have (valid) long offsets. If the offset
+         * is invalid, then it is okay to read it incorrectly.
+         *
+         * If isLongOffsets is true, then we will later check our decoding table to see
+         * if it is even possible to generate long offsets.
+         */
+        ZSTD_longOffset_e isLongOffset = (ZSTD_longOffset_e)(MEM_32bits() && (totalHistorySize > ZSTD_maxShortOffset()));
+        /* These macros control at build-time which decompressor implementation
+         * we use. If neither is defined, we do some inspection and dispatch at
+         * runtime.
+         */
+#if !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \
+    !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)
+        int usePrefetchDecoder = dctx->ddictIsCold;
+#else
+        /* Set to 1 to avoid computing offset info if we don't need to.
+         * Otherwise this value is ignored.
+         */
+        int usePrefetchDecoder = 1;
+#endif
+        int nbSeq;
+        size_t const seqHSize = ZSTD_decodeSeqHeaders(dctx, &nbSeq, ip, srcSize);
+        if (ZSTD_isError(seqHSize)) return seqHSize;
+        ip += seqHSize;
+        srcSize -= seqHSize;
+
+        RETURN_ERROR_IF((dst == NULL || dstCapacity == 0) && nbSeq > 0, dstSize_tooSmall, "NULL not handled");
+        RETURN_ERROR_IF(MEM_64bits() && sizeof(size_t) == sizeof(void*) && (size_t)(-1) - (size_t)dst < (size_t)(1 << 20), dstSize_tooSmall,
+                "invalid dst");
+
+        /* If we could potentially have long offsets, or we might want to use the prefetch decoder,
+         * compute information about the share of long offsets, and the maximum nbAdditionalBits.
+         * NOTE: could probably use a larger nbSeq limit
+         */
+        if (isLongOffset || (!usePrefetchDecoder && (totalHistorySize > (1u << 24)) && (nbSeq > 8))) {
+            ZSTD_OffsetInfo const info = ZSTD_getOffsetInfo(dctx->OFTptr, nbSeq);
+            if (isLongOffset && info.maxNbAdditionalBits <= STREAM_ACCUMULATOR_MIN) {
+                /* If isLongOffset, but the maximum number of additional bits that we see in our table is small
+                 * enough, then we know it is impossible to have too long an offset in this block, so we can
+                 * use the regular offset decoder.
+                 */
+                isLongOffset = ZSTD_lo_isRegularOffset;
+            }
+            if (!usePrefetchDecoder) {
+                U32 const minShare = MEM_64bits() ? 7 : 20; /* heuristic values, correspond to 2.73% and 7.81% */
+                usePrefetchDecoder = (info.longOffsetShare >= minShare);
+            }
+        }
+
+        dctx->ddictIsCold = 0;
+
+#if !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \
+    !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)
+        if (usePrefetchDecoder) {
+#else
+        (void)usePrefetchDecoder;
+        {
+#endif
+#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT
+            return ZSTD_decompressSequencesLong(dctx, dst, dstCapacity, ip, srcSize, nbSeq, isLongOffset, frame);
+#endif
+        }
+
+#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG
+        /* else */
+        if (dctx->litBufferLocation == ZSTD_split)
+            return ZSTD_decompressSequencesSplitLitBuffer(dctx, dst, dstCapacity, ip, srcSize, nbSeq, isLongOffset, frame);
+        else
+            return ZSTD_decompressSequences(dctx, dst, dstCapacity, ip, srcSize, nbSeq, isLongOffset, frame);
+#endif
+    }
+}
+
+
+void ZSTD_checkContinuity(ZSTD_DCtx* dctx, const void* dst, size_t dstSize)
+{
+    if (dst != dctx->previousDstEnd && dstSize > 0) {   /* not contiguous */
+        dctx->dictEnd = dctx->previousDstEnd;
+        dctx->virtualStart = (const char*)dst - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));
+        dctx->prefixStart = dst;
+        dctx->previousDstEnd = dst;
+    }
+}
+
+
+size_t ZSTD_decompressBlock_deprecated(ZSTD_DCtx* dctx,
+                                       void* dst, size_t dstCapacity,
+                                 const void* src, size_t srcSize)
+{
+    size_t dSize;
+    ZSTD_checkContinuity(dctx, dst, dstCapacity);
+    dSize = ZSTD_decompressBlock_internal(dctx, dst, dstCapacity, src, srcSize, /* frame */ 0, not_streaming);
+    dctx->previousDstEnd = (char*)dst + dSize;
+    return dSize;
+}
+
+
+/* NOTE: Must just wrap ZSTD_decompressBlock_deprecated() */
+size_t ZSTD_decompressBlock(ZSTD_DCtx* dctx,
+                            void* dst, size_t dstCapacity,
+                      const void* src, size_t srcSize)
+{
+    return ZSTD_decompressBlock_deprecated(dctx, dst, dstCapacity, src, srcSize);
+}
diff --git a/src/3rdparty/zstd/src/decompress/zstd_decompress_block.h b/src/3rdparty/zstd/src/decompress/zstd_decompress_block.h
new file mode 100644
index 0000000000..9d1318882d
--- /dev/null
+++ b/src/3rdparty/zstd/src/decompress/zstd_decompress_block.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+
+#ifndef ZSTD_DEC_BLOCK_H
+#define ZSTD_DEC_BLOCK_H
+
+/*-*******************************************************
+ *  Dependencies
+ *********************************************************/
+#include "../common/zstd_deps.h"   /* size_t */
+#include "../zstd.h"    /* DCtx, and some public functions */
+#include "../common/zstd_internal.h"  /* blockProperties_t, and some public functions */
+#include "zstd_decompress_internal.h"  /* ZSTD_seqSymbol */
+
+
+/* ===   Prototypes   === */
+
+/* note: prototypes already published within `zstd.h` :
+ * ZSTD_decompressBlock()
+ */
+
+/* note: prototypes already published within `zstd_internal.h` :
+ * ZSTD_getcBlockSize()
+ * ZSTD_decodeSeqHeaders()
+ */
+
+
+ /* Streaming state is used to inform allocation of the literal buffer */
+typedef enum {
+    not_streaming = 0,
+    is_streaming = 1
+} streaming_operation;
+
+/* ZSTD_decompressBlock_internal() :
+ * decompress block, starting at `src`,
+ * into destination buffer `dst`.
+ * @return : decompressed block size,
+ *           or an error code (which can be tested using ZSTD_isError())
+ */
+size_t ZSTD_decompressBlock_internal(ZSTD_DCtx* dctx,
+                               void* dst, size_t dstCapacity,
+                         const void* src, size_t srcSize, const int frame, const streaming_operation streaming);
+
+/* ZSTD_buildFSETable() :
+ * generate FSE decoding table for one symbol (ll, ml or off)
+ * this function must be called with valid parameters only
+ * (dt is large enough, normalizedCounter distribution total is a power of 2, max is within range, etc.)
+ * in which case it cannot fail.
+ * The workspace must be 4-byte aligned and at least ZSTD_BUILD_FSE_TABLE_WKSP_SIZE bytes, which is
+ * defined in zstd_decompress_internal.h.
+ * Internal use only.
+ */
+void ZSTD_buildFSETable(ZSTD_seqSymbol* dt,
+             const short* normalizedCounter, unsigned maxSymbolValue,
+             const U32* baseValue, const U8* nbAdditionalBits,
+                   unsigned tableLog, void* wksp, size_t wkspSize,
+                   int bmi2);
+
+/* Internal definition of ZSTD_decompressBlock() to avoid deprecation warnings. */
+size_t ZSTD_decompressBlock_deprecated(ZSTD_DCtx* dctx,
+                            void* dst, size_t dstCapacity,
+                      const void* src, size_t srcSize);
+
+
+#endif /* ZSTD_DEC_BLOCK_H */
diff --git a/src/3rdparty/zstd/src/decompress/zstd_decompress_internal.h b/src/3rdparty/zstd/src/decompress/zstd_decompress_internal.h
new file mode 100644
index 0000000000..c2ec5d9fbe
--- /dev/null
+++ b/src/3rdparty/zstd/src/decompress/zstd_decompress_internal.h
@@ -0,0 +1,238 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+
+/* zstd_decompress_internal:
+ * objects and definitions shared within lib/decompress modules */
+
+ #ifndef ZSTD_DECOMPRESS_INTERNAL_H
+ #define ZSTD_DECOMPRESS_INTERNAL_H
+
+
+/*-*******************************************************
+ *  Dependencies
+ *********************************************************/
+#include "../common/mem.h"             /* BYTE, U16, U32 */
+#include "../common/zstd_internal.h"   /* constants : MaxLL, MaxML, MaxOff, LLFSELog, etc. */
+
+
+
+/*-*******************************************************
+ *  Constants
+ *********************************************************/
+static UNUSED_ATTR const U32 LL_base[MaxLL+1] = {
+                 0,    1,    2,     3,     4,     5,     6,      7,
+                 8,    9,   10,    11,    12,    13,    14,     15,
+                16,   18,   20,    22,    24,    28,    32,     40,
+                48,   64, 0x80, 0x100, 0x200, 0x400, 0x800, 0x1000,
+                0x2000, 0x4000, 0x8000, 0x10000 };
+
+static UNUSED_ATTR const U32 OF_base[MaxOff+1] = {
+                 0,        1,       1,       5,     0xD,     0x1D,     0x3D,     0x7D,
+                 0xFD,   0x1FD,   0x3FD,   0x7FD,   0xFFD,   0x1FFD,   0x3FFD,   0x7FFD,
+                 0xFFFD, 0x1FFFD, 0x3FFFD, 0x7FFFD, 0xFFFFD, 0x1FFFFD, 0x3FFFFD, 0x7FFFFD,
+                 0xFFFFFD, 0x1FFFFFD, 0x3FFFFFD, 0x7FFFFFD, 0xFFFFFFD, 0x1FFFFFFD, 0x3FFFFFFD, 0x7FFFFFFD };
+
+static UNUSED_ATTR const U8 OF_bits[MaxOff+1] = {
+                     0,  1,  2,  3,  4,  5,  6,  7,
+                     8,  9, 10, 11, 12, 13, 14, 15,
+                    16, 17, 18, 19, 20, 21, 22, 23,
+                    24, 25, 26, 27, 28, 29, 30, 31 };
+
+static UNUSED_ATTR const U32 ML_base[MaxML+1] = {
+                     3,  4,  5,    6,     7,     8,     9,    10,
+                    11, 12, 13,   14,    15,    16,    17,    18,
+                    19, 20, 21,   22,    23,    24,    25,    26,
+                    27, 28, 29,   30,    31,    32,    33,    34,
+                    35, 37, 39,   41,    43,    47,    51,    59,
+                    67, 83, 99, 0x83, 0x103, 0x203, 0x403, 0x803,
+                    0x1003, 0x2003, 0x4003, 0x8003, 0x10003 };
+
+
+/*-*******************************************************
+ *  Decompression types
+ *********************************************************/
+ typedef struct {
+     U32 fastMode;
+     U32 tableLog;
+ } ZSTD_seqSymbol_header;
+
+ typedef struct {
+     U16  nextState;
+     BYTE nbAdditionalBits;
+     BYTE nbBits;
+     U32  baseValue;
+ } ZSTD_seqSymbol;
+
+ #define SEQSYMBOL_TABLE_SIZE(log)   (1 + (1 << (log)))
+
+#define ZSTD_BUILD_FSE_TABLE_WKSP_SIZE (sizeof(S16) * (MaxSeq + 1) + (1u << MaxFSELog) + sizeof(U64))
+#define ZSTD_BUILD_FSE_TABLE_WKSP_SIZE_U32 ((ZSTD_BUILD_FSE_TABLE_WKSP_SIZE + sizeof(U32) - 1) / sizeof(U32))
+#define ZSTD_HUFFDTABLE_CAPACITY_LOG 12
+
+typedef struct {
+    ZSTD_seqSymbol LLTable[SEQSYMBOL_TABLE_SIZE(LLFSELog)];    /* Note : Space reserved for FSE Tables */
+    ZSTD_seqSymbol OFTable[SEQSYMBOL_TABLE_SIZE(OffFSELog)];   /* is also used as temporary workspace while building hufTable during DDict creation */
+    ZSTD_seqSymbol MLTable[SEQSYMBOL_TABLE_SIZE(MLFSELog)];    /* and therefore must be at least HUF_DECOMPRESS_WORKSPACE_SIZE large */
+    HUF_DTable hufTable[HUF_DTABLE_SIZE(ZSTD_HUFFDTABLE_CAPACITY_LOG)];  /* can accommodate HUF_decompress4X */
+    U32 rep[ZSTD_REP_NUM];
+    U32 workspace[ZSTD_BUILD_FSE_TABLE_WKSP_SIZE_U32];
+} ZSTD_entropyDTables_t;
+
+typedef enum { ZSTDds_getFrameHeaderSize, ZSTDds_decodeFrameHeader,
+               ZSTDds_decodeBlockHeader, ZSTDds_decompressBlock,
+               ZSTDds_decompressLastBlock, ZSTDds_checkChecksum,
+               ZSTDds_decodeSkippableHeader, ZSTDds_skipFrame } ZSTD_dStage;
+
+typedef enum { zdss_init=0, zdss_loadHeader,
+               zdss_read, zdss_load, zdss_flush } ZSTD_dStreamStage;
+
+typedef enum {
+    ZSTD_use_indefinitely = -1,  /* Use the dictionary indefinitely */
+    ZSTD_dont_use = 0,           /* Do not use the dictionary (if one exists free it) */
+    ZSTD_use_once = 1            /* Use the dictionary once and set to ZSTD_dont_use */
+} ZSTD_dictUses_e;
+
+/* Hashset for storing references to multiple ZSTD_DDict within ZSTD_DCtx */
+typedef struct {
+    const ZSTD_DDict** ddictPtrTable;
+    size_t ddictPtrTableSize;
+    size_t ddictPtrCount;
+} ZSTD_DDictHashSet;
+
+#ifndef ZSTD_DECODER_INTERNAL_BUFFER
+#  define ZSTD_DECODER_INTERNAL_BUFFER  (1 << 16)
+#endif
+
+#define ZSTD_LBMIN 64
+#define ZSTD_LBMAX (128 << 10)
+
+/* extra buffer, compensates when dst is not large enough to store litBuffer */
+#define ZSTD_LITBUFFEREXTRASIZE  BOUNDED(ZSTD_LBMIN, ZSTD_DECODER_INTERNAL_BUFFER, ZSTD_LBMAX)
+
+typedef enum {
+    ZSTD_not_in_dst = 0,  /* Stored entirely within litExtraBuffer */
+    ZSTD_in_dst = 1,           /* Stored entirely within dst (in memory after current output write) */
+    ZSTD_split = 2            /* Split between litExtraBuffer and dst */
+} ZSTD_litLocation_e;
+
+struct ZSTD_DCtx_s
+{
+    const ZSTD_seqSymbol* LLTptr;
+    const ZSTD_seqSymbol* MLTptr;
+    const ZSTD_seqSymbol* OFTptr;
+    const HUF_DTable* HUFptr;
+    ZSTD_entropyDTables_t entropy;
+    U32 workspace[HUF_DECOMPRESS_WORKSPACE_SIZE_U32];   /* space needed when building huffman tables */
+    const void* previousDstEnd;   /* detect continuity */
+    const void* prefixStart;      /* start of current segment */
+    const void* virtualStart;     /* virtual start of previous segment if it was just before current one */
+    const void* dictEnd;          /* end of previous segment */
+    size_t expected;
+    ZSTD_frameHeader fParams;
+    U64 processedCSize;
+    U64 decodedSize;
+    blockType_e bType;            /* used in ZSTD_decompressContinue(), store blockType between block header decoding and block decompression stages */
+    ZSTD_dStage stage;
+    U32 litEntropy;
+    U32 fseEntropy;
+    XXH64_state_t xxhState;
+    size_t headerSize;
+    ZSTD_format_e format;
+    ZSTD_forceIgnoreChecksum_e forceIgnoreChecksum;   /* User specified: if == 1, will ignore checksums in compressed frame. Default == 0 */
+    U32 validateChecksum;         /* if == 1, will validate checksum. Is == 1 if (fParams.checksumFlag == 1) and (forceIgnoreChecksum == 0). */
+    const BYTE* litPtr;
+    ZSTD_customMem customMem;
+    size_t litSize;
+    size_t rleSize;
+    size_t staticSize;
+#if DYNAMIC_BMI2 != 0
+    int bmi2;                     /* == 1 if the CPU supports BMI2 and 0 otherwise. CPU support is determined dynamically once per context lifetime. */
+#endif
+
+    /* dictionary */
+    ZSTD_DDict* ddictLocal;
+    const ZSTD_DDict* ddict;     /* set by ZSTD_initDStream_usingDDict(), or ZSTD_DCtx_refDDict() */
+    U32 dictID;
+    int ddictIsCold;             /* if == 1 : dictionary is "new" for working context, and presumed "cold" (not in cpu cache) */
+    ZSTD_dictUses_e dictUses;
+    ZSTD_DDictHashSet* ddictSet;                    /* Hash set for multiple ddicts */
+    ZSTD_refMultipleDDicts_e refMultipleDDicts;     /* User specified: if == 1, will allow references to multiple DDicts. Default == 0 (disabled) */
+    int disableHufAsm;
+
+    /* streaming */
+    ZSTD_dStreamStage streamStage;
+    char*  inBuff;
+    size_t inBuffSize;
+    size_t inPos;
+    size_t maxWindowSize;
+    char*  outBuff;
+    size_t outBuffSize;
+    size_t outStart;
+    size_t outEnd;
+    size_t lhSize;
+#if defined(ZSTD_LEGACY_SUPPORT) && (ZSTD_LEGACY_SUPPORT>=1)
+    void* legacyContext;
+    U32 previousLegacyVersion;
+    U32 legacyVersion;
+#endif
+    U32 hostageByte;
+    int noForwardProgress;
+    ZSTD_bufferMode_e outBufferMode;
+    ZSTD_outBuffer expectedOutBuffer;
+
+    /* workspace */
+    BYTE* litBuffer;
+    const BYTE* litBufferEnd;
+    ZSTD_litLocation_e litBufferLocation;
+    BYTE litExtraBuffer[ZSTD_LITBUFFEREXTRASIZE + WILDCOPY_OVERLENGTH]; /* literal buffer can be split between storage within dst and within this scratch buffer */
+    BYTE headerBuffer[ZSTD_FRAMEHEADERSIZE_MAX];
+
+    size_t oversizedDuration;
+
+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+    void const* dictContentBeginForFuzzing;
+    void const* dictContentEndForFuzzing;
+#endif
+
+    /* Tracing */
+#if ZSTD_TRACE
+    ZSTD_TraceCtx traceCtx;
+#endif
+};  /* typedef'd to ZSTD_DCtx within "zstd.h" */
+
+MEM_STATIC int ZSTD_DCtx_get_bmi2(const struct ZSTD_DCtx_s *dctx) {
+#if DYNAMIC_BMI2 != 0
+	return dctx->bmi2;
+#else
+    (void)dctx;
+	return 0;
+#endif
+}
+
+/*-*******************************************************
+ *  Shared internal functions
+ *********************************************************/
+
+/*! ZSTD_loadDEntropy() :
+ *  dict : must point at beginning of a valid zstd dictionary.
+ * @return : size of dictionary header (size of magic number + dict ID + entropy tables) */
+size_t ZSTD_loadDEntropy(ZSTD_entropyDTables_t* entropy,
+                   const void* const dict, size_t const dictSize);
+
+/*! ZSTD_checkContinuity() :
+ *  check if next `dst` follows previous position, where decompression ended.
+ *  If yes, do nothing (continue on current segment).
+ *  If not, classify previous segment as "external dictionary", and start a new segment.
+ *  This function cannot fail. */
+void ZSTD_checkContinuity(ZSTD_DCtx* dctx, const void* dst, size_t dstSize);
+
+
+#endif /* ZSTD_DECOMPRESS_INTERNAL_H */
diff --git a/src/3rdparty/zstd/src/dictBuilder/cover.c b/src/3rdparty/zstd/src/dictBuilder/cover.c
new file mode 100644
index 0000000000..9e5e7d5b55
--- /dev/null
+++ b/src/3rdparty/zstd/src/dictBuilder/cover.c
@@ -0,0 +1,1257 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+/* *****************************************************************************
+ * Constructs a dictionary using a heuristic based on the following paper:
+ *
+ * Liao, Petri, Moffat, Wirth
+ * Effective Construction of Relative Lempel-Ziv Dictionaries
+ * Published in WWW 2016.
+ *
+ * Adapted from code originally written by @ot (Giuseppe Ottaviano).
+ ******************************************************************************/
+
+/*-*************************************
+*  Dependencies
+***************************************/
+#include <stdio.h>  /* fprintf */
+#include <stdlib.h> /* malloc, free, qsort */
+#include <string.h> /* memset */
+#include <time.h>   /* clock */
+
+#ifndef ZDICT_STATIC_LINKING_ONLY
+#  define ZDICT_STATIC_LINKING_ONLY
+#endif
+
+#include "../common/mem.h" /* read */
+#include "../common/pool.h"
+#include "../common/threading.h"
+#include "../common/zstd_internal.h" /* includes zstd.h */
+#include "../common/bits.h" /* ZSTD_highbit32 */
+#include "../zdict.h"
+#include "cover.h"
+
+/*-*************************************
+*  Constants
+***************************************/
+/**
+* There are 32bit indexes used to ref samples, so limit samples size to 4GB
+* on 64bit builds.
+* For 32bit builds we choose 1 GB.
+* Most 32bit platforms have 2GB user-mode addressable space and we allocate a large
+* contiguous buffer, so 1GB is already a high limit.
+*/
+#define COVER_MAX_SAMPLES_SIZE (sizeof(size_t) == 8 ? ((unsigned)-1) : ((unsigned)1 GB))
+#define COVER_DEFAULT_SPLITPOINT 1.0
+
+/*-*************************************
+*  Console display
+***************************************/
+#ifndef LOCALDISPLAYLEVEL
+static int g_displayLevel = 0;
+#endif
+#undef  DISPLAY
+#define DISPLAY(...)                                                           \
+  {                                                                            \
+    fprintf(stderr, __VA_ARGS__);                                              \
+    fflush(stderr);                                                            \
+  }
+#undef  LOCALDISPLAYLEVEL
+#define LOCALDISPLAYLEVEL(displayLevel, l, ...)                                \
+  if (displayLevel >= l) {                                                     \
+    DISPLAY(__VA_ARGS__);                                                      \
+  } /* 0 : no display;   1: errors;   2: default;  3: details;  4: debug */
+#undef  DISPLAYLEVEL
+#define DISPLAYLEVEL(l, ...) LOCALDISPLAYLEVEL(g_displayLevel, l, __VA_ARGS__)
+
+#ifndef LOCALDISPLAYUPDATE
+static const clock_t g_refreshRate = CLOCKS_PER_SEC * 15 / 100;
+static clock_t g_time = 0;
+#endif
+#undef  LOCALDISPLAYUPDATE
+#define LOCALDISPLAYUPDATE(displayLevel, l, ...)                               \
+  if (displayLevel >= l) {                                                     \
+    if ((clock() - g_time > g_refreshRate) || (displayLevel >= 4)) {             \
+      g_time = clock();                                                        \
+      DISPLAY(__VA_ARGS__);                                                    \
+    }                                                                          \
+  }
+#undef  DISPLAYUPDATE
+#define DISPLAYUPDATE(l, ...) LOCALDISPLAYUPDATE(g_displayLevel, l, __VA_ARGS__)
+
+/*-*************************************
+* Hash table
+***************************************
+* A small specialized hash map for storing activeDmers.
+* The map does not resize, so if it becomes full it will loop forever.
+* Thus, the map must be large enough to store every value.
+* The map implements linear probing and keeps its load less than 0.5.
+*/
+
+#define MAP_EMPTY_VALUE ((U32)-1)
+typedef struct COVER_map_pair_t_s {
+  U32 key;
+  U32 value;
+} COVER_map_pair_t;
+
+typedef struct COVER_map_s {
+  COVER_map_pair_t *data;
+  U32 sizeLog;
+  U32 size;
+  U32 sizeMask;
+} COVER_map_t;
+
+/**
+ * Clear the map.
+ */
+static void COVER_map_clear(COVER_map_t *map) {
+  memset(map->data, MAP_EMPTY_VALUE, map->size * sizeof(COVER_map_pair_t));
+}
+
+/**
+ * Initializes a map of the given size.
+ * Returns 1 on success and 0 on failure.
+ * The map must be destroyed with COVER_map_destroy().
+ * The map is only guaranteed to be large enough to hold size elements.
+ */
+static int COVER_map_init(COVER_map_t *map, U32 size) {
+  map->sizeLog = ZSTD_highbit32(size) + 2;
+  map->size = (U32)1 << map->sizeLog;
+  map->sizeMask = map->size - 1;
+  map->data = (COVER_map_pair_t *)malloc(map->size * sizeof(COVER_map_pair_t));
+  if (!map->data) {
+    map->sizeLog = 0;
+    map->size = 0;
+    return 0;
+  }
+  COVER_map_clear(map);
+  return 1;
+}
+
+/**
+ * Internal hash function
+ */
+static const U32 COVER_prime4bytes = 2654435761U;
+static U32 COVER_map_hash(COVER_map_t *map, U32 key) {
+  return (key * COVER_prime4bytes) >> (32 - map->sizeLog);
+}
+
+/**
+ * Helper function that returns the index that a key should be placed into.
+ */
+static U32 COVER_map_index(COVER_map_t *map, U32 key) {
+  const U32 hash = COVER_map_hash(map, key);
+  U32 i;
+  for (i = hash;; i = (i + 1) & map->sizeMask) {
+    COVER_map_pair_t *pos = &map->data[i];
+    if (pos->value == MAP_EMPTY_VALUE) {
+      return i;
+    }
+    if (pos->key == key) {
+      return i;
+    }
+  }
+}
+
+/**
+ * Returns the pointer to the value for key.
+ * If key is not in the map, it is inserted and the value is set to 0.
+ * The map must not be full.
+ */
+static U32 *COVER_map_at(COVER_map_t *map, U32 key) {
+  COVER_map_pair_t *pos = &map->data[COVER_map_index(map, key)];
+  if (pos->value == MAP_EMPTY_VALUE) {
+    pos->key = key;
+    pos->value = 0;
+  }
+  return &pos->value;
+}
+
+/**
+ * Deletes key from the map if present.
+ */
+static void COVER_map_remove(COVER_map_t *map, U32 key) {
+  U32 i = COVER_map_index(map, key);
+  COVER_map_pair_t *del = &map->data[i];
+  U32 shift = 1;
+  if (del->value == MAP_EMPTY_VALUE) {
+    return;
+  }
+  for (i = (i + 1) & map->sizeMask;; i = (i + 1) & map->sizeMask) {
+    COVER_map_pair_t *const pos = &map->data[i];
+    /* If the position is empty we are done */
+    if (pos->value == MAP_EMPTY_VALUE) {
+      del->value = MAP_EMPTY_VALUE;
+      return;
+    }
+    /* If pos can be moved to del do so */
+    if (((i - COVER_map_hash(map, pos->key)) & map->sizeMask) >= shift) {
+      del->key = pos->key;
+      del->value = pos->value;
+      del = pos;
+      shift = 1;
+    } else {
+      ++shift;
+    }
+  }
+}
+
+/**
+ * Destroys a map that is inited with COVER_map_init().
+ */
+static void COVER_map_destroy(COVER_map_t *map) {
+  if (map->data) {
+    free(map->data);
+  }
+  map->data = NULL;
+  map->size = 0;
+}
+
+/*-*************************************
+* Context
+***************************************/
+
+typedef struct {
+  const BYTE *samples;
+  size_t *offsets;
+  const size_t *samplesSizes;
+  size_t nbSamples;
+  size_t nbTrainSamples;
+  size_t nbTestSamples;
+  U32 *suffix;
+  size_t suffixSize;
+  U32 *freqs;
+  U32 *dmerAt;
+  unsigned d;
+} COVER_ctx_t;
+
+/* We need a global context for qsort... */
+static COVER_ctx_t *g_coverCtx = NULL;
+
+/*-*************************************
+*  Helper functions
+***************************************/
+
+/**
+ * Returns the sum of the sample sizes.
+ */
+size_t COVER_sum(const size_t *samplesSizes, unsigned nbSamples) {
+  size_t sum = 0;
+  unsigned i;
+  for (i = 0; i < nbSamples; ++i) {
+    sum += samplesSizes[i];
+  }
+  return sum;
+}
+
+/**
+ * Returns -1 if the dmer at lp is less than the dmer at rp.
+ * Return 0 if the dmers at lp and rp are equal.
+ * Returns 1 if the dmer at lp is greater than the dmer at rp.
+ */
+static int COVER_cmp(COVER_ctx_t *ctx, const void *lp, const void *rp) {
+  U32 const lhs = *(U32 const *)lp;
+  U32 const rhs = *(U32 const *)rp;
+  return memcmp(ctx->samples + lhs, ctx->samples + rhs, ctx->d);
+}
+/**
+ * Faster version for d <= 8.
+ */
+static int COVER_cmp8(COVER_ctx_t *ctx, const void *lp, const void *rp) {
+  U64 const mask = (ctx->d == 8) ? (U64)-1 : (((U64)1 << (8 * ctx->d)) - 1);
+  U64 const lhs = MEM_readLE64(ctx->samples + *(U32 const *)lp) & mask;
+  U64 const rhs = MEM_readLE64(ctx->samples + *(U32 const *)rp) & mask;
+  if (lhs < rhs) {
+    return -1;
+  }
+  return (lhs > rhs);
+}
+
+/**
+ * Same as COVER_cmp() except ties are broken by pointer value
+ * NOTE: g_coverCtx must be set to call this function.  A global is required because
+ * qsort doesn't take an opaque pointer.
+ */
+static int WIN_CDECL COVER_strict_cmp(const void *lp, const void *rp) {
+  int result = COVER_cmp(g_coverCtx, lp, rp);
+  if (result == 0) {
+    result = lp < rp ? -1 : 1;
+  }
+  return result;
+}
+/**
+ * Faster version for d <= 8.
+ */
+static int WIN_CDECL COVER_strict_cmp8(const void *lp, const void *rp) {
+  int result = COVER_cmp8(g_coverCtx, lp, rp);
+  if (result == 0) {
+    result = lp < rp ? -1 : 1;
+  }
+  return result;
+}
+
+/**
+ * Returns the first pointer in [first, last) whose element does not compare
+ * less than value.  If no such element exists it returns last.
+ */
+static const size_t *COVER_lower_bound(const size_t *first, const size_t *last,
+                                       size_t value) {
+  size_t count = last - first;
+  while (count != 0) {
+    size_t step = count / 2;
+    const size_t *ptr = first;
+    ptr += step;
+    if (*ptr < value) {
+      first = ++ptr;
+      count -= step + 1;
+    } else {
+      count = step;
+    }
+  }
+  return first;
+}
+
+/**
+ * Generic groupBy function.
+ * Groups an array sorted by cmp into groups with equivalent values.
+ * Calls grp for each group.
+ */
+static void
+COVER_groupBy(const void *data, size_t count, size_t size, COVER_ctx_t *ctx,
+              int (*cmp)(COVER_ctx_t *, const void *, const void *),
+              void (*grp)(COVER_ctx_t *, const void *, const void *)) {
+  const BYTE *ptr = (const BYTE *)data;
+  size_t num = 0;
+  while (num < count) {
+    const BYTE *grpEnd = ptr + size;
+    ++num;
+    while (num < count && cmp(ctx, ptr, grpEnd) == 0) {
+      grpEnd += size;
+      ++num;
+    }
+    grp(ctx, ptr, grpEnd);
+    ptr = grpEnd;
+  }
+}
+
+/*-*************************************
+*  Cover functions
+***************************************/
+
+/**
+ * Called on each group of positions with the same dmer.
+ * Counts the frequency of each dmer and saves it in the suffix array.
+ * Fills `ctx->dmerAt`.
+ */
+static void COVER_group(COVER_ctx_t *ctx, const void *group,
+                        const void *groupEnd) {
+  /* The group consists of all the positions with the same first d bytes. */
+  const U32 *grpPtr = (const U32 *)group;
+  const U32 *grpEnd = (const U32 *)groupEnd;
+  /* The dmerId is how we will reference this dmer.
+   * This allows us to map the whole dmer space to a much smaller space, the
+   * size of the suffix array.
+   */
+  const U32 dmerId = (U32)(grpPtr - ctx->suffix);
+  /* Count the number of samples this dmer shows up in */
+  U32 freq = 0;
+  /* Details */
+  const size_t *curOffsetPtr = ctx->offsets;
+  const size_t *offsetsEnd = ctx->offsets + ctx->nbSamples;
+  /* Once *grpPtr >= curSampleEnd this occurrence of the dmer is in a
+   * different sample than the last.
+   */
+  size_t curSampleEnd = ctx->offsets[0];
+  for (; grpPtr != grpEnd; ++grpPtr) {
+    /* Save the dmerId for this position so we can get back to it. */
+    ctx->dmerAt[*grpPtr] = dmerId;
+    /* Dictionaries only help for the first reference to the dmer.
+     * After that zstd can reference the match from the previous reference.
+     * So only count each dmer once for each sample it is in.
+     */
+    if (*grpPtr < curSampleEnd) {
+      continue;
+    }
+    freq += 1;
+    /* Binary search to find the end of the sample *grpPtr is in.
+     * In the common case that grpPtr + 1 == grpEnd we can skip the binary
+     * search because the loop is over.
+     */
+    if (grpPtr + 1 != grpEnd) {
+      const size_t *sampleEndPtr =
+          COVER_lower_bound(curOffsetPtr, offsetsEnd, *grpPtr);
+      curSampleEnd = *sampleEndPtr;
+      curOffsetPtr = sampleEndPtr + 1;
+    }
+  }
+  /* At this point we are never going to look at this segment of the suffix
+   * array again.  We take advantage of this fact to save memory.
+   * We store the frequency of the dmer in the first position of the group,
+   * which is dmerId.
+   */
+  ctx->suffix[dmerId] = freq;
+}
+
+
+/**
+ * Selects the best segment in an epoch.
+ * Segments of are scored according to the function:
+ *
+ * Let F(d) be the frequency of dmer d.
+ * Let S_i be the dmer at position i of segment S which has length k.
+ *
+ *     Score(S) = F(S_1) + F(S_2) + ... + F(S_{k-d+1})
+ *
+ * Once the dmer d is in the dictionary we set F(d) = 0.
+ */
+static COVER_segment_t COVER_selectSegment(const COVER_ctx_t *ctx, U32 *freqs,
+                                           COVER_map_t *activeDmers, U32 begin,
+                                           U32 end,
+                                           ZDICT_cover_params_t parameters) {
+  /* Constants */
+  const U32 k = parameters.k;
+  const U32 d = parameters.d;
+  const U32 dmersInK = k - d + 1;
+  /* Try each segment (activeSegment) and save the best (bestSegment) */
+  COVER_segment_t bestSegment = {0, 0, 0};
+  COVER_segment_t activeSegment;
+  /* Reset the activeDmers in the segment */
+  COVER_map_clear(activeDmers);
+  /* The activeSegment starts at the beginning of the epoch. */
+  activeSegment.begin = begin;
+  activeSegment.end = begin;
+  activeSegment.score = 0;
+  /* Slide the activeSegment through the whole epoch.
+   * Save the best segment in bestSegment.
+   */
+  while (activeSegment.end < end) {
+    /* The dmerId for the dmer at the next position */
+    U32 newDmer = ctx->dmerAt[activeSegment.end];
+    /* The entry in activeDmers for this dmerId */
+    U32 *newDmerOcc = COVER_map_at(activeDmers, newDmer);
+    /* If the dmer isn't already present in the segment add its score. */
+    if (*newDmerOcc == 0) {
+      /* The paper suggest using the L-0.5 norm, but experiments show that it
+       * doesn't help.
+       */
+      activeSegment.score += freqs[newDmer];
+    }
+    /* Add the dmer to the segment */
+    activeSegment.end += 1;
+    *newDmerOcc += 1;
+
+    /* If the window is now too large, drop the first position */
+    if (activeSegment.end - activeSegment.begin == dmersInK + 1) {
+      U32 delDmer = ctx->dmerAt[activeSegment.begin];
+      U32 *delDmerOcc = COVER_map_at(activeDmers, delDmer);
+      activeSegment.begin += 1;
+      *delDmerOcc -= 1;
+      /* If this is the last occurrence of the dmer, subtract its score */
+      if (*delDmerOcc == 0) {
+        COVER_map_remove(activeDmers, delDmer);
+        activeSegment.score -= freqs[delDmer];
+      }
+    }
+
+    /* If this segment is the best so far save it */
+    if (activeSegment.score > bestSegment.score) {
+      bestSegment = activeSegment;
+    }
+  }
+  {
+    /* Trim off the zero frequency head and tail from the segment. */
+    U32 newBegin = bestSegment.end;
+    U32 newEnd = bestSegment.begin;
+    U32 pos;
+    for (pos = bestSegment.begin; pos != bestSegment.end; ++pos) {
+      U32 freq = freqs[ctx->dmerAt[pos]];
+      if (freq != 0) {
+        newBegin = MIN(newBegin, pos);
+        newEnd = pos + 1;
+      }
+    }
+    bestSegment.begin = newBegin;
+    bestSegment.end = newEnd;
+  }
+  {
+    /* Zero out the frequency of each dmer covered by the chosen segment. */
+    U32 pos;
+    for (pos = bestSegment.begin; pos != bestSegment.end; ++pos) {
+      freqs[ctx->dmerAt[pos]] = 0;
+    }
+  }
+  return bestSegment;
+}
+
+/**
+ * Check the validity of the parameters.
+ * Returns non-zero if the parameters are valid and 0 otherwise.
+ */
+static int COVER_checkParameters(ZDICT_cover_params_t parameters,
+                                 size_t maxDictSize) {
+  /* k and d are required parameters */
+  if (parameters.d == 0 || parameters.k == 0) {
+    return 0;
+  }
+  /* k <= maxDictSize */
+  if (parameters.k > maxDictSize) {
+    return 0;
+  }
+  /* d <= k */
+  if (parameters.d > parameters.k) {
+    return 0;
+  }
+  /* 0 < splitPoint <= 1 */
+  if (parameters.splitPoint <= 0 || parameters.splitPoint > 1){
+    return 0;
+  }
+  return 1;
+}
+
+/**
+ * Clean up a context initialized with `COVER_ctx_init()`.
+ */
+static void COVER_ctx_destroy(COVER_ctx_t *ctx) {
+  if (!ctx) {
+    return;
+  }
+  if (ctx->suffix) {
+    free(ctx->suffix);
+    ctx->suffix = NULL;
+  }
+  if (ctx->freqs) {
+    free(ctx->freqs);
+    ctx->freqs = NULL;
+  }
+  if (ctx->dmerAt) {
+    free(ctx->dmerAt);
+    ctx->dmerAt = NULL;
+  }
+  if (ctx->offsets) {
+    free(ctx->offsets);
+    ctx->offsets = NULL;
+  }
+}
+
+/**
+ * Prepare a context for dictionary building.
+ * The context is only dependent on the parameter `d` and can be used multiple
+ * times.
+ * Returns 0 on success or error code on error.
+ * The context must be destroyed with `COVER_ctx_destroy()`.
+ */
+static size_t COVER_ctx_init(COVER_ctx_t *ctx, const void *samplesBuffer,
+                          const size_t *samplesSizes, unsigned nbSamples,
+                          unsigned d, double splitPoint) {
+  const BYTE *const samples = (const BYTE *)samplesBuffer;
+  const size_t totalSamplesSize = COVER_sum(samplesSizes, nbSamples);
+  /* Split samples into testing and training sets */
+  const unsigned nbTrainSamples = splitPoint < 1.0 ? (unsigned)((double)nbSamples * splitPoint) : nbSamples;
+  const unsigned nbTestSamples = splitPoint < 1.0 ? nbSamples - nbTrainSamples : nbSamples;
+  const size_t trainingSamplesSize = splitPoint < 1.0 ? COVER_sum(samplesSizes, nbTrainSamples) : totalSamplesSize;
+  const size_t testSamplesSize = splitPoint < 1.0 ? COVER_sum(samplesSizes + nbTrainSamples, nbTestSamples) : totalSamplesSize;
+  /* Checks */
+  if (totalSamplesSize < MAX(d, sizeof(U64)) ||
+      totalSamplesSize >= (size_t)COVER_MAX_SAMPLES_SIZE) {
+    DISPLAYLEVEL(1, "Total samples size is too large (%u MB), maximum size is %u MB\n",
+                 (unsigned)(totalSamplesSize>>20), (COVER_MAX_SAMPLES_SIZE >> 20));
+    return ERROR(srcSize_wrong);
+  }
+  /* Check if there are at least 5 training samples */
+  if (nbTrainSamples < 5) {
+    DISPLAYLEVEL(1, "Total number of training samples is %u and is invalid.", nbTrainSamples);
+    return ERROR(srcSize_wrong);
+  }
+  /* Check if there's testing sample */
+  if (nbTestSamples < 1) {
+    DISPLAYLEVEL(1, "Total number of testing samples is %u and is invalid.", nbTestSamples);
+    return ERROR(srcSize_wrong);
+  }
+  /* Zero the context */
+  memset(ctx, 0, sizeof(*ctx));
+  DISPLAYLEVEL(2, "Training on %u samples of total size %u\n", nbTrainSamples,
+               (unsigned)trainingSamplesSize);
+  DISPLAYLEVEL(2, "Testing on %u samples of total size %u\n", nbTestSamples,
+               (unsigned)testSamplesSize);
+  ctx->samples = samples;
+  ctx->samplesSizes = samplesSizes;
+  ctx->nbSamples = nbSamples;
+  ctx->nbTrainSamples = nbTrainSamples;
+  ctx->nbTestSamples = nbTestSamples;
+  /* Partial suffix array */
+  ctx->suffixSize = trainingSamplesSize - MAX(d, sizeof(U64)) + 1;
+  ctx->suffix = (U32 *)malloc(ctx->suffixSize * sizeof(U32));
+  /* Maps index to the dmerID */
+  ctx->dmerAt = (U32 *)malloc(ctx->suffixSize * sizeof(U32));
+  /* The offsets of each file */
+  ctx->offsets = (size_t *)malloc((nbSamples + 1) * sizeof(size_t));
+  if (!ctx->suffix || !ctx->dmerAt || !ctx->offsets) {
+    DISPLAYLEVEL(1, "Failed to allocate scratch buffers\n");
+    COVER_ctx_destroy(ctx);
+    return ERROR(memory_allocation);
+  }
+  ctx->freqs = NULL;
+  ctx->d = d;
+
+  /* Fill offsets from the samplesSizes */
+  {
+    U32 i;
+    ctx->offsets[0] = 0;
+    for (i = 1; i <= nbSamples; ++i) {
+      ctx->offsets[i] = ctx->offsets[i - 1] + samplesSizes[i - 1];
+    }
+  }
+  DISPLAYLEVEL(2, "Constructing partial suffix array\n");
+  {
+    /* suffix is a partial suffix array.
+     * It only sorts suffixes by their first parameters.d bytes.
+     * The sort is stable, so each dmer group is sorted by position in input.
+     */
+    U32 i;
+    for (i = 0; i < ctx->suffixSize; ++i) {
+      ctx->suffix[i] = i;
+    }
+    /* qsort doesn't take an opaque pointer, so pass as a global.
+     * On OpenBSD qsort() is not guaranteed to be stable, their mergesort() is.
+     */
+    g_coverCtx = ctx;
+#if defined(__OpenBSD__)
+    mergesort(ctx->suffix, ctx->suffixSize, sizeof(U32),
+          (ctx->d <= 8 ? &COVER_strict_cmp8 : &COVER_strict_cmp));
+#else
+    qsort(ctx->suffix, ctx->suffixSize, sizeof(U32),
+          (ctx->d <= 8 ? &COVER_strict_cmp8 : &COVER_strict_cmp));
+#endif
+  }
+  DISPLAYLEVEL(2, "Computing frequencies\n");
+  /* For each dmer group (group of positions with the same first d bytes):
+   * 1. For each position we set dmerAt[position] = dmerID.  The dmerID is
+   *    (groupBeginPtr - suffix).  This allows us to go from position to
+   *    dmerID so we can look up values in freq.
+   * 2. We calculate how many samples the dmer occurs in and save it in
+   *    freqs[dmerId].
+   */
+  COVER_groupBy(ctx->suffix, ctx->suffixSize, sizeof(U32), ctx,
+                (ctx->d <= 8 ? &COVER_cmp8 : &COVER_cmp), &COVER_group);
+  ctx->freqs = ctx->suffix;
+  ctx->suffix = NULL;
+  return 0;
+}
+
+void COVER_warnOnSmallCorpus(size_t maxDictSize, size_t nbDmers, int displayLevel)
+{
+  const double ratio = (double)nbDmers / (double)maxDictSize;
+  if (ratio >= 10) {
+      return;
+  }
+  LOCALDISPLAYLEVEL(displayLevel, 1,
+                    "WARNING: The maximum dictionary size %u is too large "
+                    "compared to the source size %u! "
+                    "size(source)/size(dictionary) = %f, but it should be >= "
+                    "10! This may lead to a subpar dictionary! We recommend "
+                    "training on sources at least 10x, and preferably 100x "
+                    "the size of the dictionary! \n", (U32)maxDictSize,
+                    (U32)nbDmers, ratio);
+}
+
+COVER_epoch_info_t COVER_computeEpochs(U32 maxDictSize,
+                                       U32 nbDmers, U32 k, U32 passes)
+{
+  const U32 minEpochSize = k * 10;
+  COVER_epoch_info_t epochs;
+  epochs.num = MAX(1, maxDictSize / k / passes);
+  epochs.size = nbDmers / epochs.num;
+  if (epochs.size >= minEpochSize) {
+      assert(epochs.size * epochs.num <= nbDmers);
+      return epochs;
+  }
+  epochs.size = MIN(minEpochSize, nbDmers);
+  epochs.num = nbDmers / epochs.size;
+  assert(epochs.size * epochs.num <= nbDmers);
+  return epochs;
+}
+
+/**
+ * Given the prepared context build the dictionary.
+ */
+static size_t COVER_buildDictionary(const COVER_ctx_t *ctx, U32 *freqs,
+                                    COVER_map_t *activeDmers, void *dictBuffer,
+                                    size_t dictBufferCapacity,
+                                    ZDICT_cover_params_t parameters) {
+  BYTE *const dict = (BYTE *)dictBuffer;
+  size_t tail = dictBufferCapacity;
+  /* Divide the data into epochs. We will select one segment from each epoch. */
+  const COVER_epoch_info_t epochs = COVER_computeEpochs(
+      (U32)dictBufferCapacity, (U32)ctx->suffixSize, parameters.k, 4);
+  const size_t maxZeroScoreRun = MAX(10, MIN(100, epochs.num >> 3));
+  size_t zeroScoreRun = 0;
+  size_t epoch;
+  DISPLAYLEVEL(2, "Breaking content into %u epochs of size %u\n",
+                (U32)epochs.num, (U32)epochs.size);
+  /* Loop through the epochs until there are no more segments or the dictionary
+   * is full.
+   */
+  for (epoch = 0; tail > 0; epoch = (epoch + 1) % epochs.num) {
+    const U32 epochBegin = (U32)(epoch * epochs.size);
+    const U32 epochEnd = epochBegin + epochs.size;
+    size_t segmentSize;
+    /* Select a segment */
+    COVER_segment_t segment = COVER_selectSegment(
+        ctx, freqs, activeDmers, epochBegin, epochEnd, parameters);
+    /* If the segment covers no dmers, then we are out of content.
+     * There may be new content in other epochs, for continue for some time.
+     */
+    if (segment.score == 0) {
+      if (++zeroScoreRun >= maxZeroScoreRun) {
+          break;
+      }
+      continue;
+    }
+    zeroScoreRun = 0;
+    /* Trim the segment if necessary and if it is too small then we are done */
+    segmentSize = MIN(segment.end - segment.begin + parameters.d - 1, tail);
+    if (segmentSize < parameters.d) {
+      break;
+    }
+    /* We fill the dictionary from the back to allow the best segments to be
+     * referenced with the smallest offsets.
+     */
+    tail -= segmentSize;
+    memcpy(dict + tail, ctx->samples + segment.begin, segmentSize);
+    DISPLAYUPDATE(
+        2, "\r%u%%       ",
+        (unsigned)(((dictBufferCapacity - tail) * 100) / dictBufferCapacity));
+  }
+  DISPLAYLEVEL(2, "\r%79s\r", "");
+  return tail;
+}
+
+ZDICTLIB_API size_t ZDICT_trainFromBuffer_cover(
+    void *dictBuffer, size_t dictBufferCapacity,
+    const void *samplesBuffer, const size_t *samplesSizes, unsigned nbSamples,
+    ZDICT_cover_params_t parameters)
+{
+  BYTE* const dict = (BYTE*)dictBuffer;
+  COVER_ctx_t ctx;
+  COVER_map_t activeDmers;
+  parameters.splitPoint = 1.0;
+  /* Initialize global data */
+  g_displayLevel = (int)parameters.zParams.notificationLevel;
+  /* Checks */
+  if (!COVER_checkParameters(parameters, dictBufferCapacity)) {
+    DISPLAYLEVEL(1, "Cover parameters incorrect\n");
+    return ERROR(parameter_outOfBound);
+  }
+  if (nbSamples == 0) {
+    DISPLAYLEVEL(1, "Cover must have at least one input file\n");
+    return ERROR(srcSize_wrong);
+  }
+  if (dictBufferCapacity < ZDICT_DICTSIZE_MIN) {
+    DISPLAYLEVEL(1, "dictBufferCapacity must be at least %u\n",
+                 ZDICT_DICTSIZE_MIN);
+    return ERROR(dstSize_tooSmall);
+  }
+  /* Initialize context and activeDmers */
+  {
+    size_t const initVal = COVER_ctx_init(&ctx, samplesBuffer, samplesSizes, nbSamples,
+                      parameters.d, parameters.splitPoint);
+    if (ZSTD_isError(initVal)) {
+      return initVal;
+    }
+  }
+  COVER_warnOnSmallCorpus(dictBufferCapacity, ctx.suffixSize, g_displayLevel);
+  if (!COVER_map_init(&activeDmers, parameters.k - parameters.d + 1)) {
+    DISPLAYLEVEL(1, "Failed to allocate dmer map: out of memory\n");
+    COVER_ctx_destroy(&ctx);
+    return ERROR(memory_allocation);
+  }
+
+  DISPLAYLEVEL(2, "Building dictionary\n");
+  {
+    const size_t tail =
+        COVER_buildDictionary(&ctx, ctx.freqs, &activeDmers, dictBuffer,
+                              dictBufferCapacity, parameters);
+    const size_t dictionarySize = ZDICT_finalizeDictionary(
+        dict, dictBufferCapacity, dict + tail, dictBufferCapacity - tail,
+        samplesBuffer, samplesSizes, nbSamples, parameters.zParams);
+    if (!ZSTD_isError(dictionarySize)) {
+      DISPLAYLEVEL(2, "Constructed dictionary of size %u\n",
+                   (unsigned)dictionarySize);
+    }
+    COVER_ctx_destroy(&ctx);
+    COVER_map_destroy(&activeDmers);
+    return dictionarySize;
+  }
+}
+
+
+
+size_t COVER_checkTotalCompressedSize(const ZDICT_cover_params_t parameters,
+                                    const size_t *samplesSizes, const BYTE *samples,
+                                    size_t *offsets,
+                                    size_t nbTrainSamples, size_t nbSamples,
+                                    BYTE *const dict, size_t dictBufferCapacity) {
+  size_t totalCompressedSize = ERROR(GENERIC);
+  /* Pointers */
+  ZSTD_CCtx *cctx;
+  ZSTD_CDict *cdict;
+  void *dst;
+  /* Local variables */
+  size_t dstCapacity;
+  size_t i;
+  /* Allocate dst with enough space to compress the maximum sized sample */
+  {
+    size_t maxSampleSize = 0;
+    i = parameters.splitPoint < 1.0 ? nbTrainSamples : 0;
+    for (; i < nbSamples; ++i) {
+      maxSampleSize = MAX(samplesSizes[i], maxSampleSize);
+    }
+    dstCapacity = ZSTD_compressBound(maxSampleSize);
+    dst = malloc(dstCapacity);
+  }
+  /* Create the cctx and cdict */
+  cctx = ZSTD_createCCtx();
+  cdict = ZSTD_createCDict(dict, dictBufferCapacity,
+                           parameters.zParams.compressionLevel);
+  if (!dst || !cctx || !cdict) {
+    goto _compressCleanup;
+  }
+  /* Compress each sample and sum their sizes (or error) */
+  totalCompressedSize = dictBufferCapacity;
+  i = parameters.splitPoint < 1.0 ? nbTrainSamples : 0;
+  for (; i < nbSamples; ++i) {
+    const size_t size = ZSTD_compress_usingCDict(
+        cctx, dst, dstCapacity, samples + offsets[i],
+        samplesSizes[i], cdict);
+    if (ZSTD_isError(size)) {
+      totalCompressedSize = size;
+      goto _compressCleanup;
+    }
+    totalCompressedSize += size;
+  }
+_compressCleanup:
+  ZSTD_freeCCtx(cctx);
+  ZSTD_freeCDict(cdict);
+  if (dst) {
+    free(dst);
+  }
+  return totalCompressedSize;
+}
+
+
+/**
+ * Initialize the `COVER_best_t`.
+ */
+void COVER_best_init(COVER_best_t *best) {
+  if (best==NULL) return; /* compatible with init on NULL */
+  (void)ZSTD_pthread_mutex_init(&best->mutex, NULL);
+  (void)ZSTD_pthread_cond_init(&best->cond, NULL);
+  best->liveJobs = 0;
+  best->dict = NULL;
+  best->dictSize = 0;
+  best->compressedSize = (size_t)-1;
+  memset(&best->parameters, 0, sizeof(best->parameters));
+}
+
+/**
+ * Wait until liveJobs == 0.
+ */
+void COVER_best_wait(COVER_best_t *best) {
+  if (!best) {
+    return;
+  }
+  ZSTD_pthread_mutex_lock(&best->mutex);
+  while (best->liveJobs != 0) {
+    ZSTD_pthread_cond_wait(&best->cond, &best->mutex);
+  }
+  ZSTD_pthread_mutex_unlock(&best->mutex);
+}
+
+/**
+ * Call COVER_best_wait() and then destroy the COVER_best_t.
+ */
+void COVER_best_destroy(COVER_best_t *best) {
+  if (!best) {
+    return;
+  }
+  COVER_best_wait(best);
+  if (best->dict) {
+    free(best->dict);
+  }
+  ZSTD_pthread_mutex_destroy(&best->mutex);
+  ZSTD_pthread_cond_destroy(&best->cond);
+}
+
+/**
+ * Called when a thread is about to be launched.
+ * Increments liveJobs.
+ */
+void COVER_best_start(COVER_best_t *best) {
+  if (!best) {
+    return;
+  }
+  ZSTD_pthread_mutex_lock(&best->mutex);
+  ++best->liveJobs;
+  ZSTD_pthread_mutex_unlock(&best->mutex);
+}
+
+/**
+ * Called when a thread finishes executing, both on error or success.
+ * Decrements liveJobs and signals any waiting threads if liveJobs == 0.
+ * If this dictionary is the best so far save it and its parameters.
+ */
+void COVER_best_finish(COVER_best_t *best, ZDICT_cover_params_t parameters,
+                              COVER_dictSelection_t selection) {
+  void* dict = selection.dictContent;
+  size_t compressedSize = selection.totalCompressedSize;
+  size_t dictSize = selection.dictSize;
+  if (!best) {
+    return;
+  }
+  {
+    size_t liveJobs;
+    ZSTD_pthread_mutex_lock(&best->mutex);
+    --best->liveJobs;
+    liveJobs = best->liveJobs;
+    /* If the new dictionary is better */
+    if (compressedSize < best->compressedSize) {
+      /* Allocate space if necessary */
+      if (!best->dict || best->dictSize < dictSize) {
+        if (best->dict) {
+          free(best->dict);
+        }
+        best->dict = malloc(dictSize);
+        if (!best->dict) {
+          best->compressedSize = ERROR(GENERIC);
+          best->dictSize = 0;
+          ZSTD_pthread_cond_signal(&best->cond);
+          ZSTD_pthread_mutex_unlock(&best->mutex);
+          return;
+        }
+      }
+      /* Save the dictionary, parameters, and size */
+      if (dict) {
+        memcpy(best->dict, dict, dictSize);
+        best->dictSize = dictSize;
+        best->parameters = parameters;
+        best->compressedSize = compressedSize;
+      }
+    }
+    if (liveJobs == 0) {
+      ZSTD_pthread_cond_broadcast(&best->cond);
+    }
+    ZSTD_pthread_mutex_unlock(&best->mutex);
+  }
+}
+
+static COVER_dictSelection_t setDictSelection(BYTE* buf, size_t s, size_t csz)
+{
+    COVER_dictSelection_t ds;
+    ds.dictContent = buf;
+    ds.dictSize = s;
+    ds.totalCompressedSize = csz;
+    return ds;
+}
+
+COVER_dictSelection_t COVER_dictSelectionError(size_t error) {
+    return setDictSelection(NULL, 0, error);
+}
+
+unsigned COVER_dictSelectionIsError(COVER_dictSelection_t selection) {
+  return (ZSTD_isError(selection.totalCompressedSize) || !selection.dictContent);
+}
+
+void COVER_dictSelectionFree(COVER_dictSelection_t selection){
+  free(selection.dictContent);
+}
+
+COVER_dictSelection_t COVER_selectDict(BYTE* customDictContent, size_t dictBufferCapacity,
+        size_t dictContentSize, const BYTE* samplesBuffer, const size_t* samplesSizes, unsigned nbFinalizeSamples,
+        size_t nbCheckSamples, size_t nbSamples, ZDICT_cover_params_t params, size_t* offsets, size_t totalCompressedSize) {
+
+  size_t largestDict = 0;
+  size_t largestCompressed = 0;
+  BYTE* customDictContentEnd = customDictContent + dictContentSize;
+
+  BYTE * largestDictbuffer = (BYTE *)malloc(dictBufferCapacity);
+  BYTE * candidateDictBuffer = (BYTE *)malloc(dictBufferCapacity);
+  double regressionTolerance = ((double)params.shrinkDictMaxRegression / 100.0) + 1.00;
+
+  if (!largestDictbuffer || !candidateDictBuffer) {
+    free(largestDictbuffer);
+    free(candidateDictBuffer);
+    return COVER_dictSelectionError(dictContentSize);
+  }
+
+  /* Initial dictionary size and compressed size */
+  memcpy(largestDictbuffer, customDictContent, dictContentSize);
+  dictContentSize = ZDICT_finalizeDictionary(
+    largestDictbuffer, dictBufferCapacity, customDictContent, dictContentSize,
+    samplesBuffer, samplesSizes, nbFinalizeSamples, params.zParams);
+
+  if (ZDICT_isError(dictContentSize)) {
+    free(largestDictbuffer);
+    free(candidateDictBuffer);
+    return COVER_dictSelectionError(dictContentSize);
+  }
+
+  totalCompressedSize = COVER_checkTotalCompressedSize(params, samplesSizes,
+                                                       samplesBuffer, offsets,
+                                                       nbCheckSamples, nbSamples,
+                                                       largestDictbuffer, dictContentSize);
+
+  if (ZSTD_isError(totalCompressedSize)) {
+    free(largestDictbuffer);
+    free(candidateDictBuffer);
+    return COVER_dictSelectionError(totalCompressedSize);
+  }
+
+  if (params.shrinkDict == 0) {
+    free(candidateDictBuffer);
+    return setDictSelection(largestDictbuffer, dictContentSize, totalCompressedSize);
+  }
+
+  largestDict = dictContentSize;
+  largestCompressed = totalCompressedSize;
+  dictContentSize = ZDICT_DICTSIZE_MIN;
+
+  /* Largest dict is initially at least ZDICT_DICTSIZE_MIN */
+  while (dictContentSize < largestDict) {
+    memcpy(candidateDictBuffer, largestDictbuffer, largestDict);
+    dictContentSize = ZDICT_finalizeDictionary(
+      candidateDictBuffer, dictBufferCapacity, customDictContentEnd - dictContentSize, dictContentSize,
+      samplesBuffer, samplesSizes, nbFinalizeSamples, params.zParams);
+
+    if (ZDICT_isError(dictContentSize)) {
+      free(largestDictbuffer);
+      free(candidateDictBuffer);
+      return COVER_dictSelectionError(dictContentSize);
+
+    }
+
+    totalCompressedSize = COVER_checkTotalCompressedSize(params, samplesSizes,
+                                                         samplesBuffer, offsets,
+                                                         nbCheckSamples, nbSamples,
+                                                         candidateDictBuffer, dictContentSize);
+
+    if (ZSTD_isError(totalCompressedSize)) {
+      free(largestDictbuffer);
+      free(candidateDictBuffer);
+      return COVER_dictSelectionError(totalCompressedSize);
+    }
+
+    if ((double)totalCompressedSize <= (double)largestCompressed * regressionTolerance) {
+      free(largestDictbuffer);
+      return setDictSelection( candidateDictBuffer, dictContentSize, totalCompressedSize );
+    }
+    dictContentSize *= 2;
+  }
+  dictContentSize = largestDict;
+  totalCompressedSize = largestCompressed;
+  free(candidateDictBuffer);
+  return setDictSelection( largestDictbuffer, dictContentSize, totalCompressedSize );
+}
+
+/**
+ * Parameters for COVER_tryParameters().
+ */
+typedef struct COVER_tryParameters_data_s {
+  const COVER_ctx_t *ctx;
+  COVER_best_t *best;
+  size_t dictBufferCapacity;
+  ZDICT_cover_params_t parameters;
+} COVER_tryParameters_data_t;
+
+/**
+ * Tries a set of parameters and updates the COVER_best_t with the results.
+ * This function is thread safe if zstd is compiled with multithreaded support.
+ * It takes its parameters as an *OWNING* opaque pointer to support threading.
+ */
+static void COVER_tryParameters(void *opaque)
+{
+  /* Save parameters as local variables */
+  COVER_tryParameters_data_t *const data = (COVER_tryParameters_data_t*)opaque;
+  const COVER_ctx_t *const ctx = data->ctx;
+  const ZDICT_cover_params_t parameters = data->parameters;
+  size_t dictBufferCapacity = data->dictBufferCapacity;
+  size_t totalCompressedSize = ERROR(GENERIC);
+  /* Allocate space for hash table, dict, and freqs */
+  COVER_map_t activeDmers;
+  BYTE* const dict = (BYTE*)malloc(dictBufferCapacity);
+  COVER_dictSelection_t selection = COVER_dictSelectionError(ERROR(GENERIC));
+  U32* const freqs = (U32*)malloc(ctx->suffixSize * sizeof(U32));
+  if (!COVER_map_init(&activeDmers, parameters.k - parameters.d + 1)) {
+    DISPLAYLEVEL(1, "Failed to allocate dmer map: out of memory\n");
+    goto _cleanup;
+  }
+  if (!dict || !freqs) {
+    DISPLAYLEVEL(1, "Failed to allocate buffers: out of memory\n");
+    goto _cleanup;
+  }
+  /* Copy the frequencies because we need to modify them */
+  memcpy(freqs, ctx->freqs, ctx->suffixSize * sizeof(U32));
+  /* Build the dictionary */
+  {
+    const size_t tail = COVER_buildDictionary(ctx, freqs, &activeDmers, dict,
+                                              dictBufferCapacity, parameters);
+    selection = COVER_selectDict(dict + tail, dictBufferCapacity, dictBufferCapacity - tail,
+        ctx->samples, ctx->samplesSizes, (unsigned)ctx->nbTrainSamples, ctx->nbTrainSamples, ctx->nbSamples, parameters, ctx->offsets,
+        totalCompressedSize);
+
+    if (COVER_dictSelectionIsError(selection)) {
+      DISPLAYLEVEL(1, "Failed to select dictionary\n");
+      goto _cleanup;
+    }
+  }
+_cleanup:
+  free(dict);
+  COVER_best_finish(data->best, parameters, selection);
+  free(data);
+  COVER_map_destroy(&activeDmers);
+  COVER_dictSelectionFree(selection);
+  free(freqs);
+}
+
+ZDICTLIB_API size_t ZDICT_optimizeTrainFromBuffer_cover(
+    void* dictBuffer, size_t dictBufferCapacity, const void* samplesBuffer,
+    const size_t* samplesSizes, unsigned nbSamples,
+    ZDICT_cover_params_t* parameters)
+{
+  /* constants */
+  const unsigned nbThreads = parameters->nbThreads;
+  const double splitPoint =
+      parameters->splitPoint <= 0.0 ? COVER_DEFAULT_SPLITPOINT : parameters->splitPoint;
+  const unsigned kMinD = parameters->d == 0 ? 6 : parameters->d;
+  const unsigned kMaxD = parameters->d == 0 ? 8 : parameters->d;
+  const unsigned kMinK = parameters->k == 0 ? 50 : parameters->k;
+  const unsigned kMaxK = parameters->k == 0 ? 2000 : parameters->k;
+  const unsigned kSteps = parameters->steps == 0 ? 40 : parameters->steps;
+  const unsigned kStepSize = MAX((kMaxK - kMinK) / kSteps, 1);
+  const unsigned kIterations =
+      (1 + (kMaxD - kMinD) / 2) * (1 + (kMaxK - kMinK) / kStepSize);
+  const unsigned shrinkDict = 0;
+  /* Local variables */
+  const int displayLevel = parameters->zParams.notificationLevel;
+  unsigned iteration = 1;
+  unsigned d;
+  unsigned k;
+  COVER_best_t best;
+  POOL_ctx *pool = NULL;
+  int warned = 0;
+
+  /* Checks */
+  if (splitPoint <= 0 || splitPoint > 1) {
+    LOCALDISPLAYLEVEL(displayLevel, 1, "Incorrect parameters\n");
+    return ERROR(parameter_outOfBound);
+  }
+  if (kMinK < kMaxD || kMaxK < kMinK) {
+    LOCALDISPLAYLEVEL(displayLevel, 1, "Incorrect parameters\n");
+    return ERROR(parameter_outOfBound);
+  }
+  if (nbSamples == 0) {
+    DISPLAYLEVEL(1, "Cover must have at least one input file\n");
+    return ERROR(srcSize_wrong);
+  }
+  if (dictBufferCapacity < ZDICT_DICTSIZE_MIN) {
+    DISPLAYLEVEL(1, "dictBufferCapacity must be at least %u\n",
+                 ZDICT_DICTSIZE_MIN);
+    return ERROR(dstSize_tooSmall);
+  }
+  if (nbThreads > 1) {
+    pool = POOL_create(nbThreads, 1);
+    if (!pool) {
+      return ERROR(memory_allocation);
+    }
+  }
+  /* Initialization */
+  COVER_best_init(&best);
+  /* Turn down global display level to clean up display at level 2 and below */
+  g_displayLevel = displayLevel == 0 ? 0 : displayLevel - 1;
+  /* Loop through d first because each new value needs a new context */
+  LOCALDISPLAYLEVEL(displayLevel, 2, "Trying %u different sets of parameters\n",
+                    kIterations);
+  for (d = kMinD; d <= kMaxD; d += 2) {
+    /* Initialize the context for this value of d */
+    COVER_ctx_t ctx;
+    LOCALDISPLAYLEVEL(displayLevel, 3, "d=%u\n", d);
+    {
+      const size_t initVal = COVER_ctx_init(&ctx, samplesBuffer, samplesSizes, nbSamples, d, splitPoint);
+      if (ZSTD_isError(initVal)) {
+        LOCALDISPLAYLEVEL(displayLevel, 1, "Failed to initialize context\n");
+        COVER_best_destroy(&best);
+        POOL_free(pool);
+        return initVal;
+      }
+    }
+    if (!warned) {
+      COVER_warnOnSmallCorpus(dictBufferCapacity, ctx.suffixSize, displayLevel);
+      warned = 1;
+    }
+    /* Loop through k reusing the same context */
+    for (k = kMinK; k <= kMaxK; k += kStepSize) {
+      /* Prepare the arguments */
+      COVER_tryParameters_data_t *data = (COVER_tryParameters_data_t *)malloc(
+          sizeof(COVER_tryParameters_data_t));
+      LOCALDISPLAYLEVEL(displayLevel, 3, "k=%u\n", k);
+      if (!data) {
+        LOCALDISPLAYLEVEL(displayLevel, 1, "Failed to allocate parameters\n");
+        COVER_best_destroy(&best);
+        COVER_ctx_destroy(&ctx);
+        POOL_free(pool);
+        return ERROR(memory_allocation);
+      }
+      data->ctx = &ctx;
+      data->best = &best;
+      data->dictBufferCapacity = dictBufferCapacity;
+      data->parameters = *parameters;
+      data->parameters.k = k;
+      data->parameters.d = d;
+      data->parameters.splitPoint = splitPoint;
+      data->parameters.steps = kSteps;
+      data->parameters.shrinkDict = shrinkDict;
+      data->parameters.zParams.notificationLevel = g_displayLevel;
+      /* Check the parameters */
+      if (!COVER_checkParameters(data->parameters, dictBufferCapacity)) {
+        DISPLAYLEVEL(1, "Cover parameters incorrect\n");
+        free(data);
+        continue;
+      }
+      /* Call the function and pass ownership of data to it */
+      COVER_best_start(&best);
+      if (pool) {
+        POOL_add(pool, &COVER_tryParameters, data);
+      } else {
+        COVER_tryParameters(data);
+      }
+      /* Print status */
+      LOCALDISPLAYUPDATE(displayLevel, 2, "\r%u%%       ",
+                         (unsigned)((iteration * 100) / kIterations));
+      ++iteration;
+    }
+    COVER_best_wait(&best);
+    COVER_ctx_destroy(&ctx);
+  }
+  LOCALDISPLAYLEVEL(displayLevel, 2, "\r%79s\r", "");
+  /* Fill the output buffer and parameters with output of the best parameters */
+  {
+    const size_t dictSize = best.dictSize;
+    if (ZSTD_isError(best.compressedSize)) {
+      const size_t compressedSize = best.compressedSize;
+      COVER_best_destroy(&best);
+      POOL_free(pool);
+      return compressedSize;
+    }
+    *parameters = best.parameters;
+    memcpy(dictBuffer, best.dict, dictSize);
+    COVER_best_destroy(&best);
+    POOL_free(pool);
+    return dictSize;
+  }
+}
diff --git a/src/3rdparty/zstd/src/dictBuilder/cover.h b/src/3rdparty/zstd/src/dictBuilder/cover.h
new file mode 100644
index 0000000000..252624bdeb
--- /dev/null
+++ b/src/3rdparty/zstd/src/dictBuilder/cover.h
@@ -0,0 +1,158 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZDICT_STATIC_LINKING_ONLY
+#  define ZDICT_STATIC_LINKING_ONLY
+#endif
+
+#include <stdio.h>  /* fprintf */
+#include <stdlib.h> /* malloc, free, qsort */
+#include <string.h> /* memset */
+#include <time.h>   /* clock */
+#include "../common/mem.h" /* read */
+#include "../common/pool.h"
+#include "../common/threading.h"
+#include "../common/zstd_internal.h" /* includes zstd.h */
+#include "../zdict.h"
+
+/**
+ * COVER_best_t is used for two purposes:
+ * 1. Synchronizing threads.
+ * 2. Saving the best parameters and dictionary.
+ *
+ * All of the methods except COVER_best_init() are thread safe if zstd is
+ * compiled with multithreaded support.
+ */
+typedef struct COVER_best_s {
+  ZSTD_pthread_mutex_t mutex;
+  ZSTD_pthread_cond_t cond;
+  size_t liveJobs;
+  void *dict;
+  size_t dictSize;
+  ZDICT_cover_params_t parameters;
+  size_t compressedSize;
+} COVER_best_t;
+
+/**
+ * A segment is a range in the source as well as the score of the segment.
+ */
+typedef struct {
+  U32 begin;
+  U32 end;
+  U32 score;
+} COVER_segment_t;
+
+/**
+ *Number of epochs and size of each epoch.
+ */
+typedef struct {
+  U32 num;
+  U32 size;
+} COVER_epoch_info_t;
+
+/**
+ * Struct used for the dictionary selection function.
+ */
+typedef struct COVER_dictSelection {
+  BYTE* dictContent;
+  size_t dictSize;
+  size_t totalCompressedSize;
+} COVER_dictSelection_t;
+
+/**
+ * Computes the number of epochs and the size of each epoch.
+ * We will make sure that each epoch gets at least 10 * k bytes.
+ *
+ * The COVER algorithms divide the data up into epochs of equal size and
+ * select one segment from each epoch.
+ *
+ * @param maxDictSize The maximum allowed dictionary size.
+ * @param nbDmers     The number of dmers we are training on.
+ * @param k           The parameter k (segment size).
+ * @param passes      The target number of passes over the dmer corpus.
+ *                    More passes means a better dictionary.
+ */
+COVER_epoch_info_t COVER_computeEpochs(U32 maxDictSize, U32 nbDmers,
+                                       U32 k, U32 passes);
+
+/**
+ * Warns the user when their corpus is too small.
+ */
+void COVER_warnOnSmallCorpus(size_t maxDictSize, size_t nbDmers, int displayLevel);
+
+/**
+ *  Checks total compressed size of a dictionary
+ */
+size_t COVER_checkTotalCompressedSize(const ZDICT_cover_params_t parameters,
+                                      const size_t *samplesSizes, const BYTE *samples,
+                                      size_t *offsets,
+                                      size_t nbTrainSamples, size_t nbSamples,
+                                      BYTE *const dict, size_t dictBufferCapacity);
+
+/**
+ * Returns the sum of the sample sizes.
+ */
+size_t COVER_sum(const size_t *samplesSizes, unsigned nbSamples) ;
+
+/**
+ * Initialize the `COVER_best_t`.
+ */
+void COVER_best_init(COVER_best_t *best);
+
+/**
+ * Wait until liveJobs == 0.
+ */
+void COVER_best_wait(COVER_best_t *best);
+
+/**
+ * Call COVER_best_wait() and then destroy the COVER_best_t.
+ */
+void COVER_best_destroy(COVER_best_t *best);
+
+/**
+ * Called when a thread is about to be launched.
+ * Increments liveJobs.
+ */
+void COVER_best_start(COVER_best_t *best);
+
+/**
+ * Called when a thread finishes executing, both on error or success.
+ * Decrements liveJobs and signals any waiting threads if liveJobs == 0.
+ * If this dictionary is the best so far save it and its parameters.
+ */
+void COVER_best_finish(COVER_best_t *best, ZDICT_cover_params_t parameters,
+                       COVER_dictSelection_t selection);
+/**
+ * Error function for COVER_selectDict function. Checks if the return
+ * value is an error.
+ */
+unsigned COVER_dictSelectionIsError(COVER_dictSelection_t selection);
+
+ /**
+  * Error function for COVER_selectDict function. Returns a struct where
+  * return.totalCompressedSize is a ZSTD error.
+  */
+COVER_dictSelection_t COVER_dictSelectionError(size_t error);
+
+/**
+ * Always call after selectDict is called to free up used memory from
+ * newly created dictionary.
+ */
+void COVER_dictSelectionFree(COVER_dictSelection_t selection);
+
+/**
+ * Called to finalize the dictionary and select one based on whether or not
+ * the shrink-dict flag was enabled. If enabled the dictionary used is the
+ * smallest dictionary within a specified regression of the compressed size
+ * from the largest dictionary.
+ */
+ COVER_dictSelection_t COVER_selectDict(BYTE* customDictContent, size_t dictBufferCapacity,
+                       size_t dictContentSize, const BYTE* samplesBuffer, const size_t* samplesSizes, unsigned nbFinalizeSamples,
+                       size_t nbCheckSamples, size_t nbSamples, ZDICT_cover_params_t params, size_t* offsets, size_t totalCompressedSize);
diff --git a/src/3rdparty/zstd/src/dictBuilder/divsufsort.c b/src/3rdparty/zstd/src/dictBuilder/divsufsort.c
new file mode 100644
index 0000000000..a2870fb3ba
--- /dev/null
+++ b/src/3rdparty/zstd/src/dictBuilder/divsufsort.c
@@ -0,0 +1,1913 @@
+/*
+ * divsufsort.c for libdivsufsort-lite
+ * Copyright (c) 2003-2008 Yuta Mori All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*- Compiler specifics -*/
+#ifdef __clang__
+#pragma clang diagnostic ignored "-Wshorten-64-to-32"
+#endif
+
+#if defined(_MSC_VER)
+#  pragma warning(disable : 4244)
+#  pragma warning(disable : 4127)    /* C4127 : Condition expression is constant */
+#endif
+
+
+/*- Dependencies -*/
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "divsufsort.h"
+
+/*- Constants -*/
+#if defined(INLINE)
+# undef INLINE
+#endif
+#if !defined(INLINE)
+# define INLINE __inline
+#endif
+#if defined(ALPHABET_SIZE) && (ALPHABET_SIZE < 1)
+# undef ALPHABET_SIZE
+#endif
+#if !defined(ALPHABET_SIZE)
+# define ALPHABET_SIZE (256)
+#endif
+#define BUCKET_A_SIZE (ALPHABET_SIZE)
+#define BUCKET_B_SIZE (ALPHABET_SIZE * ALPHABET_SIZE)
+#if defined(SS_INSERTIONSORT_THRESHOLD)
+# if SS_INSERTIONSORT_THRESHOLD < 1
+#  undef SS_INSERTIONSORT_THRESHOLD
+#  define SS_INSERTIONSORT_THRESHOLD (1)
+# endif
+#else
+# define SS_INSERTIONSORT_THRESHOLD (8)
+#endif
+#if defined(SS_BLOCKSIZE)
+# if SS_BLOCKSIZE < 0
+#  undef SS_BLOCKSIZE
+#  define SS_BLOCKSIZE (0)
+# elif 32768 <= SS_BLOCKSIZE
+#  undef SS_BLOCKSIZE
+#  define SS_BLOCKSIZE (32767)
+# endif
+#else
+# define SS_BLOCKSIZE (1024)
+#endif
+/* minstacksize = log(SS_BLOCKSIZE) / log(3) * 2 */
+#if SS_BLOCKSIZE == 0
+# define SS_MISORT_STACKSIZE (96)
+#elif SS_BLOCKSIZE <= 4096
+# define SS_MISORT_STACKSIZE (16)
+#else
+# define SS_MISORT_STACKSIZE (24)
+#endif
+#define SS_SMERGE_STACKSIZE (32)
+#define TR_INSERTIONSORT_THRESHOLD (8)
+#define TR_STACKSIZE (64)
+
+
+/*- Macros -*/
+#ifndef SWAP
+# define SWAP(_a, _b) do { t = (_a); (_a) = (_b); (_b) = t; } while(0)
+#endif /* SWAP */
+#ifndef MIN
+# define MIN(_a, _b) (((_a) < (_b)) ? (_a) : (_b))
+#endif /* MIN */
+#ifndef MAX
+# define MAX(_a, _b) (((_a) > (_b)) ? (_a) : (_b))
+#endif /* MAX */
+#define STACK_PUSH(_a, _b, _c, _d)\
+  do {\
+    assert(ssize < STACK_SIZE);\
+    stack[ssize].a = (_a), stack[ssize].b = (_b),\
+    stack[ssize].c = (_c), stack[ssize++].d = (_d);\
+  } while(0)
+#define STACK_PUSH5(_a, _b, _c, _d, _e)\
+  do {\
+    assert(ssize < STACK_SIZE);\
+    stack[ssize].a = (_a), stack[ssize].b = (_b),\
+    stack[ssize].c = (_c), stack[ssize].d = (_d), stack[ssize++].e = (_e);\
+  } while(0)
+#define STACK_POP(_a, _b, _c, _d)\
+  do {\
+    assert(0 <= ssize);\
+    if(ssize == 0) { return; }\
+    (_a) = stack[--ssize].a, (_b) = stack[ssize].b,\
+    (_c) = stack[ssize].c, (_d) = stack[ssize].d;\
+  } while(0)
+#define STACK_POP5(_a, _b, _c, _d, _e)\
+  do {\
+    assert(0 <= ssize);\
+    if(ssize == 0) { return; }\
+    (_a) = stack[--ssize].a, (_b) = stack[ssize].b,\
+    (_c) = stack[ssize].c, (_d) = stack[ssize].d, (_e) = stack[ssize].e;\
+  } while(0)
+#define BUCKET_A(_c0) bucket_A[(_c0)]
+#if ALPHABET_SIZE == 256
+#define BUCKET_B(_c0, _c1) (bucket_B[((_c1) << 8) | (_c0)])
+#define BUCKET_BSTAR(_c0, _c1) (bucket_B[((_c0) << 8) | (_c1)])
+#else
+#define BUCKET_B(_c0, _c1) (bucket_B[(_c1) * ALPHABET_SIZE + (_c0)])
+#define BUCKET_BSTAR(_c0, _c1) (bucket_B[(_c0) * ALPHABET_SIZE + (_c1)])
+#endif
+
+
+/*- Private Functions -*/
+
+static const int lg_table[256]= {
+ -1,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
+};
+
+#if (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE)
+
+static INLINE
+int
+ss_ilg(int n) {
+#if SS_BLOCKSIZE == 0
+  return (n & 0xffff0000) ?
+          ((n & 0xff000000) ?
+            24 + lg_table[(n >> 24) & 0xff] :
+            16 + lg_table[(n >> 16) & 0xff]) :
+          ((n & 0x0000ff00) ?
+             8 + lg_table[(n >>  8) & 0xff] :
+             0 + lg_table[(n >>  0) & 0xff]);
+#elif SS_BLOCKSIZE < 256
+  return lg_table[n];
+#else
+  return (n & 0xff00) ?
+          8 + lg_table[(n >> 8) & 0xff] :
+          0 + lg_table[(n >> 0) & 0xff];
+#endif
+}
+
+#endif /* (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE) */
+
+#if SS_BLOCKSIZE != 0
+
+static const int sqq_table[256] = {
+  0,  16,  22,  27,  32,  35,  39,  42,  45,  48,  50,  53,  55,  57,  59,  61,
+ 64,  65,  67,  69,  71,  73,  75,  76,  78,  80,  81,  83,  84,  86,  87,  89,
+ 90,  91,  93,  94,  96,  97,  98,  99, 101, 102, 103, 104, 106, 107, 108, 109,
+110, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126,
+128, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142,
+143, 144, 144, 145, 146, 147, 148, 149, 150, 150, 151, 152, 153, 154, 155, 155,
+156, 157, 158, 159, 160, 160, 161, 162, 163, 163, 164, 165, 166, 167, 167, 168,
+169, 170, 170, 171, 172, 173, 173, 174, 175, 176, 176, 177, 178, 178, 179, 180,
+181, 181, 182, 183, 183, 184, 185, 185, 186, 187, 187, 188, 189, 189, 190, 191,
+192, 192, 193, 193, 194, 195, 195, 196, 197, 197, 198, 199, 199, 200, 201, 201,
+202, 203, 203, 204, 204, 205, 206, 206, 207, 208, 208, 209, 209, 210, 211, 211,
+212, 212, 213, 214, 214, 215, 215, 216, 217, 217, 218, 218, 219, 219, 220, 221,
+221, 222, 222, 223, 224, 224, 225, 225, 226, 226, 227, 227, 228, 229, 229, 230,
+230, 231, 231, 232, 232, 233, 234, 234, 235, 235, 236, 236, 237, 237, 238, 238,
+239, 240, 240, 241, 241, 242, 242, 243, 243, 244, 244, 245, 245, 246, 246, 247,
+247, 248, 248, 249, 249, 250, 250, 251, 251, 252, 252, 253, 253, 254, 254, 255
+};
+
+static INLINE
+int
+ss_isqrt(int x) {
+  int y, e;
+
+  if(x >= (SS_BLOCKSIZE * SS_BLOCKSIZE)) { return SS_BLOCKSIZE; }
+  e = (x & 0xffff0000) ?
+        ((x & 0xff000000) ?
+          24 + lg_table[(x >> 24) & 0xff] :
+          16 + lg_table[(x >> 16) & 0xff]) :
+        ((x & 0x0000ff00) ?
+           8 + lg_table[(x >>  8) & 0xff] :
+           0 + lg_table[(x >>  0) & 0xff]);
+
+  if(e >= 16) {
+    y = sqq_table[x >> ((e - 6) - (e & 1))] << ((e >> 1) - 7);
+    if(e >= 24) { y = (y + 1 + x / y) >> 1; }
+    y = (y + 1 + x / y) >> 1;
+  } else if(e >= 8) {
+    y = (sqq_table[x >> ((e - 6) - (e & 1))] >> (7 - (e >> 1))) + 1;
+  } else {
+    return sqq_table[x] >> 4;
+  }
+
+  return (x < (y * y)) ? y - 1 : y;
+}
+
+#endif /* SS_BLOCKSIZE != 0 */
+
+
+/*---------------------------------------------------------------------------*/
+
+/* Compares two suffixes. */
+static INLINE
+int
+ss_compare(const unsigned char *T,
+           const int *p1, const int *p2,
+           int depth) {
+  const unsigned char *U1, *U2, *U1n, *U2n;
+
+  for(U1 = T + depth + *p1,
+      U2 = T + depth + *p2,
+      U1n = T + *(p1 + 1) + 2,
+      U2n = T + *(p2 + 1) + 2;
+      (U1 < U1n) && (U2 < U2n) && (*U1 == *U2);
+      ++U1, ++U2) {
+  }
+
+  return U1 < U1n ?
+        (U2 < U2n ? *U1 - *U2 : 1) :
+        (U2 < U2n ? -1 : 0);
+}
+
+
+/*---------------------------------------------------------------------------*/
+
+#if (SS_BLOCKSIZE != 1) && (SS_INSERTIONSORT_THRESHOLD != 1)
+
+/* Insertionsort for small size groups */
+static
+void
+ss_insertionsort(const unsigned char *T, const int *PA,
+                 int *first, int *last, int depth) {
+  int *i, *j;
+  int t;
+  int r;
+
+  for(i = last - 2; first <= i; --i) {
+    for(t = *i, j = i + 1; 0 < (r = ss_compare(T, PA + t, PA + *j, depth));) {
+      do { *(j - 1) = *j; } while((++j < last) && (*j < 0));
+      if(last <= j) { break; }
+    }
+    if(r == 0) { *j = ~*j; }
+    *(j - 1) = t;
+  }
+}
+
+#endif /* (SS_BLOCKSIZE != 1) && (SS_INSERTIONSORT_THRESHOLD != 1) */
+
+
+/*---------------------------------------------------------------------------*/
+
+#if (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE)
+
+static INLINE
+void
+ss_fixdown(const unsigned char *Td, const int *PA,
+           int *SA, int i, int size) {
+  int j, k;
+  int v;
+  int c, d, e;
+
+  for(v = SA[i], c = Td[PA[v]]; (j = 2 * i + 1) < size; SA[i] = SA[k], i = k) {
+    d = Td[PA[SA[k = j++]]];
+    if(d < (e = Td[PA[SA[j]]])) { k = j; d = e; }
+    if(d <= c) { break; }
+  }
+  SA[i] = v;
+}
+
+/* Simple top-down heapsort. */
+static
+void
+ss_heapsort(const unsigned char *Td, const int *PA, int *SA, int size) {
+  int i, m;
+  int t;
+
+  m = size;
+  if((size % 2) == 0) {
+    m--;
+    if(Td[PA[SA[m / 2]]] < Td[PA[SA[m]]]) { SWAP(SA[m], SA[m / 2]); }
+  }
+
+  for(i = m / 2 - 1; 0 <= i; --i) { ss_fixdown(Td, PA, SA, i, m); }
+  if((size % 2) == 0) { SWAP(SA[0], SA[m]); ss_fixdown(Td, PA, SA, 0, m); }
+  for(i = m - 1; 0 < i; --i) {
+    t = SA[0], SA[0] = SA[i];
+    ss_fixdown(Td, PA, SA, 0, i);
+    SA[i] = t;
+  }
+}
+
+
+/*---------------------------------------------------------------------------*/
+
+/* Returns the median of three elements. */
+static INLINE
+int *
+ss_median3(const unsigned char *Td, const int *PA,
+           int *v1, int *v2, int *v3) {
+  int *t;
+  if(Td[PA[*v1]] > Td[PA[*v2]]) { SWAP(v1, v2); }
+  if(Td[PA[*v2]] > Td[PA[*v3]]) {
+    if(Td[PA[*v1]] > Td[PA[*v3]]) { return v1; }
+    else { return v3; }
+  }
+  return v2;
+}
+
+/* Returns the median of five elements. */
+static INLINE
+int *
+ss_median5(const unsigned char *Td, const int *PA,
+           int *v1, int *v2, int *v3, int *v4, int *v5) {
+  int *t;
+  if(Td[PA[*v2]] > Td[PA[*v3]]) { SWAP(v2, v3); }
+  if(Td[PA[*v4]] > Td[PA[*v5]]) { SWAP(v4, v5); }
+  if(Td[PA[*v2]] > Td[PA[*v4]]) { SWAP(v2, v4); SWAP(v3, v5); }
+  if(Td[PA[*v1]] > Td[PA[*v3]]) { SWAP(v1, v3); }
+  if(Td[PA[*v1]] > Td[PA[*v4]]) { SWAP(v1, v4); SWAP(v3, v5); }
+  if(Td[PA[*v3]] > Td[PA[*v4]]) { return v4; }
+  return v3;
+}
+
+/* Returns the pivot element. */
+static INLINE
+int *
+ss_pivot(const unsigned char *Td, const int *PA, int *first, int *last) {
+  int *middle;
+  int t;
+
+  t = last - first;
+  middle = first + t / 2;
+
+  if(t <= 512) {
+    if(t <= 32) {
+      return ss_median3(Td, PA, first, middle, last - 1);
+    } else {
+      t >>= 2;
+      return ss_median5(Td, PA, first, first + t, middle, last - 1 - t, last - 1);
+    }
+  }
+  t >>= 3;
+  first  = ss_median3(Td, PA, first, first + t, first + (t << 1));
+  middle = ss_median3(Td, PA, middle - t, middle, middle + t);
+  last   = ss_median3(Td, PA, last - 1 - (t << 1), last - 1 - t, last - 1);
+  return ss_median3(Td, PA, first, middle, last);
+}
+
+
+/*---------------------------------------------------------------------------*/
+
+/* Binary partition for substrings. */
+static INLINE
+int *
+ss_partition(const int *PA,
+                    int *first, int *last, int depth) {
+  int *a, *b;
+  int t;
+  for(a = first - 1, b = last;;) {
+    for(; (++a < b) && ((PA[*a] + depth) >= (PA[*a + 1] + 1));) { *a = ~*a; }
+    for(; (a < --b) && ((PA[*b] + depth) <  (PA[*b + 1] + 1));) { }
+    if(b <= a) { break; }
+    t = ~*b;
+    *b = *a;
+    *a = t;
+  }
+  if(first < a) { *first = ~*first; }
+  return a;
+}
+
+/* Multikey introsort for medium size groups. */
+static
+void
+ss_mintrosort(const unsigned char *T, const int *PA,
+              int *first, int *last,
+              int depth) {
+#define STACK_SIZE SS_MISORT_STACKSIZE
+  struct { int *a, *b, c; int d; } stack[STACK_SIZE];
+  const unsigned char *Td;
+  int *a, *b, *c, *d, *e, *f;
+  int s, t;
+  int ssize;
+  int limit;
+  int v, x = 0;
+
+  for(ssize = 0, limit = ss_ilg(last - first);;) {
+
+    if((last - first) <= SS_INSERTIONSORT_THRESHOLD) {
+#if 1 < SS_INSERTIONSORT_THRESHOLD
+      if(1 < (last - first)) { ss_insertionsort(T, PA, first, last, depth); }
+#endif
+      STACK_POP(first, last, depth, limit);
+      continue;
+    }
+
+    Td = T + depth;
+    if(limit-- == 0) { ss_heapsort(Td, PA, first, last - first); }
+    if(limit < 0) {
+      for(a = first + 1, v = Td[PA[*first]]; a < last; ++a) {
+        if((x = Td[PA[*a]]) != v) {
+          if(1 < (a - first)) { break; }
+          v = x;
+          first = a;
+        }
+      }
+      if(Td[PA[*first] - 1] < v) {
+        first = ss_partition(PA, first, a, depth);
+      }
+      if((a - first) <= (last - a)) {
+        if(1 < (a - first)) {
+          STACK_PUSH(a, last, depth, -1);
+          last = a, depth += 1, limit = ss_ilg(a - first);
+        } else {
+          first = a, limit = -1;
+        }
+      } else {
+        if(1 < (last - a)) {
+          STACK_PUSH(first, a, depth + 1, ss_ilg(a - first));
+          first = a, limit = -1;
+        } else {
+          last = a, depth += 1, limit = ss_ilg(a - first);
+        }
+      }
+      continue;
+    }
+
+    /* choose pivot */
+    a = ss_pivot(Td, PA, first, last);
+    v = Td[PA[*a]];
+    SWAP(*first, *a);
+
+    /* partition */
+    for(b = first; (++b < last) && ((x = Td[PA[*b]]) == v);) { }
+    if(((a = b) < last) && (x < v)) {
+      for(; (++b < last) && ((x = Td[PA[*b]]) <= v);) {
+        if(x == v) { SWAP(*b, *a); ++a; }
+      }
+    }
+    for(c = last; (b < --c) && ((x = Td[PA[*c]]) == v);) { }
+    if((b < (d = c)) && (x > v)) {
+      for(; (b < --c) && ((x = Td[PA[*c]]) >= v);) {
+        if(x == v) { SWAP(*c, *d); --d; }
+      }
+    }
+    for(; b < c;) {
+      SWAP(*b, *c);
+      for(; (++b < c) && ((x = Td[PA[*b]]) <= v);) {
+        if(x == v) { SWAP(*b, *a); ++a; }
+      }
+      for(; (b < --c) && ((x = Td[PA[*c]]) >= v);) {
+        if(x == v) { SWAP(*c, *d); --d; }
+      }
+    }
+
+    if(a <= d) {
+      c = b - 1;
+
+      if((s = a - first) > (t = b - a)) { s = t; }
+      for(e = first, f = b - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }
+      if((s = d - c) > (t = last - d - 1)) { s = t; }
+      for(e = b, f = last - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }
+
+      a = first + (b - a), c = last - (d - c);
+      b = (v <= Td[PA[*a] - 1]) ? a : ss_partition(PA, a, c, depth);
+
+      if((a - first) <= (last - c)) {
+        if((last - c) <= (c - b)) {
+          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));
+          STACK_PUSH(c, last, depth, limit);
+          last = a;
+        } else if((a - first) <= (c - b)) {
+          STACK_PUSH(c, last, depth, limit);
+          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));
+          last = a;
+        } else {
+          STACK_PUSH(c, last, depth, limit);
+          STACK_PUSH(first, a, depth, limit);
+          first = b, last = c, depth += 1, limit = ss_ilg(c - b);
+        }
+      } else {
+        if((a - first) <= (c - b)) {
+          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));
+          STACK_PUSH(first, a, depth, limit);
+          first = c;
+        } else if((last - c) <= (c - b)) {
+          STACK_PUSH(first, a, depth, limit);
+          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));
+          first = c;
+        } else {
+          STACK_PUSH(first, a, depth, limit);
+          STACK_PUSH(c, last, depth, limit);
+          first = b, last = c, depth += 1, limit = ss_ilg(c - b);
+        }
+      }
+    } else {
+      limit += 1;
+      if(Td[PA[*first] - 1] < v) {
+        first = ss_partition(PA, first, last, depth);
+        limit = ss_ilg(last - first);
+      }
+      depth += 1;
+    }
+  }
+#undef STACK_SIZE
+}
+
+#endif /* (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE) */
+
+
+/*---------------------------------------------------------------------------*/
+
+#if SS_BLOCKSIZE != 0
+
+static INLINE
+void
+ss_blockswap(int *a, int *b, int n) {
+  int t;
+  for(; 0 < n; --n, ++a, ++b) {
+    t = *a, *a = *b, *b = t;
+  }
+}
+
+static INLINE
+void
+ss_rotate(int *first, int *middle, int *last) {
+  int *a, *b, t;
+  int l, r;
+  l = middle - first, r = last - middle;
+  for(; (0 < l) && (0 < r);) {
+    if(l == r) { ss_blockswap(first, middle, l); break; }
+    if(l < r) {
+      a = last - 1, b = middle - 1;
+      t = *a;
+      do {
+        *a-- = *b, *b-- = *a;
+        if(b < first) {
+          *a = t;
+          last = a;
+          if((r -= l + 1) <= l) { break; }
+          a -= 1, b = middle - 1;
+          t = *a;
+        }
+      } while(1);
+    } else {
+      a = first, b = middle;
+      t = *a;
+      do {
+        *a++ = *b, *b++ = *a;
+        if(last <= b) {
+          *a = t;
+          first = a + 1;
+          if((l -= r + 1) <= r) { break; }
+          a += 1, b = middle;
+          t = *a;
+        }
+      } while(1);
+    }
+  }
+}
+
+
+/*---------------------------------------------------------------------------*/
+
+static
+void
+ss_inplacemerge(const unsigned char *T, const int *PA,
+                int *first, int *middle, int *last,
+                int depth) {
+  const int *p;
+  int *a, *b;
+  int len, half;
+  int q, r;
+  int x;
+
+  for(;;) {
+    if(*(last - 1) < 0) { x = 1; p = PA + ~*(last - 1); }
+    else                { x = 0; p = PA +  *(last - 1); }
+    for(a = first, len = middle - first, half = len >> 1, r = -1;
+        0 < len;
+        len = half, half >>= 1) {
+      b = a + half;
+      q = ss_compare(T, PA + ((0 <= *b) ? *b : ~*b), p, depth);
+      if(q < 0) {
+        a = b + 1;
+        half -= (len & 1) ^ 1;
+      } else {
+        r = q;
+      }
+    }
+    if(a < middle) {
+      if(r == 0) { *a = ~*a; }
+      ss_rotate(a, middle, last);
+      last -= middle - a;
+      middle = a;
+      if(first == middle) { break; }
+    }
+    --last;
+    if(x != 0) { while(*--last < 0) { } }
+    if(middle == last) { break; }
+  }
+}
+
+
+/*---------------------------------------------------------------------------*/
+
+/* Merge-forward with internal buffer. */
+static
+void
+ss_mergeforward(const unsigned char *T, const int *PA,
+                int *first, int *middle, int *last,
+                int *buf, int depth) {
+  int *a, *b, *c, *bufend;
+  int t;
+  int r;
+
+  bufend = buf + (middle - first) - 1;
+  ss_blockswap(buf, first, middle - first);
+
+  for(t = *(a = first), b = buf, c = middle;;) {
+    r = ss_compare(T, PA + *b, PA + *c, depth);
+    if(r < 0) {
+      do {
+        *a++ = *b;
+        if(bufend <= b) { *bufend = t; return; }
+        *b++ = *a;
+      } while(*b < 0);
+    } else if(r > 0) {
+      do {
+        *a++ = *c, *c++ = *a;
+        if(last <= c) {
+          while(b < bufend) { *a++ = *b, *b++ = *a; }
+          *a = *b, *b = t;
+          return;
+        }
+      } while(*c < 0);
+    } else {
+      *c = ~*c;
+      do {
+        *a++ = *b;
+        if(bufend <= b) { *bufend = t; return; }
+        *b++ = *a;
+      } while(*b < 0);
+
+      do {
+        *a++ = *c, *c++ = *a;
+        if(last <= c) {
+          while(b < bufend) { *a++ = *b, *b++ = *a; }
+          *a = *b, *b = t;
+          return;
+        }
+      } while(*c < 0);
+    }
+  }
+}
+
+/* Merge-backward with internal buffer. */
+static
+void
+ss_mergebackward(const unsigned char *T, const int *PA,
+                 int *first, int *middle, int *last,
+                 int *buf, int depth) {
+  const int *p1, *p2;
+  int *a, *b, *c, *bufend;
+  int t;
+  int r;
+  int x;
+
+  bufend = buf + (last - middle) - 1;
+  ss_blockswap(buf, middle, last - middle);
+
+  x = 0;
+  if(*bufend < 0)       { p1 = PA + ~*bufend; x |= 1; }
+  else                  { p1 = PA +  *bufend; }
+  if(*(middle - 1) < 0) { p2 = PA + ~*(middle - 1); x |= 2; }
+  else                  { p2 = PA +  *(middle - 1); }
+  for(t = *(a = last - 1), b = bufend, c = middle - 1;;) {
+    r = ss_compare(T, p1, p2, depth);
+    if(0 < r) {
+      if(x & 1) { do { *a-- = *b, *b-- = *a; } while(*b < 0); x ^= 1; }
+      *a-- = *b;
+      if(b <= buf) { *buf = t; break; }
+      *b-- = *a;
+      if(*b < 0) { p1 = PA + ~*b; x |= 1; }
+      else       { p1 = PA +  *b; }
+    } else if(r < 0) {
+      if(x & 2) { do { *a-- = *c, *c-- = *a; } while(*c < 0); x ^= 2; }
+      *a-- = *c, *c-- = *a;
+      if(c < first) {
+        while(buf < b) { *a-- = *b, *b-- = *a; }
+        *a = *b, *b = t;
+        break;
+      }
+      if(*c < 0) { p2 = PA + ~*c; x |= 2; }
+      else       { p2 = PA +  *c; }
+    } else {
+      if(x & 1) { do { *a-- = *b, *b-- = *a; } while(*b < 0); x ^= 1; }
+      *a-- = ~*b;
+      if(b <= buf) { *buf = t; break; }
+      *b-- = *a;
+      if(x & 2) { do { *a-- = *c, *c-- = *a; } while(*c < 0); x ^= 2; }
+      *a-- = *c, *c-- = *a;
+      if(c < first) {
+        while(buf < b) { *a-- = *b, *b-- = *a; }
+        *a = *b, *b = t;
+        break;
+      }
+      if(*b < 0) { p1 = PA + ~*b; x |= 1; }
+      else       { p1 = PA +  *b; }
+      if(*c < 0) { p2 = PA + ~*c; x |= 2; }
+      else       { p2 = PA +  *c; }
+    }
+  }
+}
+
+/* D&C based merge. */
+static
+void
+ss_swapmerge(const unsigned char *T, const int *PA,
+             int *first, int *middle, int *last,
+             int *buf, int bufsize, int depth) {
+#define STACK_SIZE SS_SMERGE_STACKSIZE
+#define GETIDX(a) ((0 <= (a)) ? (a) : (~(a)))
+#define MERGE_CHECK(a, b, c)\
+  do {\
+    if(((c) & 1) ||\
+       (((c) & 2) && (ss_compare(T, PA + GETIDX(*((a) - 1)), PA + *(a), depth) == 0))) {\
+      *(a) = ~*(a);\
+    }\
+    if(((c) & 4) && ((ss_compare(T, PA + GETIDX(*((b) - 1)), PA + *(b), depth) == 0))) {\
+      *(b) = ~*(b);\
+    }\
+  } while(0)
+  struct { int *a, *b, *c; int d; } stack[STACK_SIZE];
+  int *l, *r, *lm, *rm;
+  int m, len, half;
+  int ssize;
+  int check, next;
+
+  for(check = 0, ssize = 0;;) {
+    if((last - middle) <= bufsize) {
+      if((first < middle) && (middle < last)) {
+        ss_mergebackward(T, PA, first, middle, last, buf, depth);
+      }
+      MERGE_CHECK(first, last, check);
+      STACK_POP(first, middle, last, check);
+      continue;
+    }
+
+    if((middle - first) <= bufsize) {
+      if(first < middle) {
+        ss_mergeforward(T, PA, first, middle, last, buf, depth);
+      }
+      MERGE_CHECK(first, last, check);
+      STACK_POP(first, middle, last, check);
+      continue;
+    }
+
+    for(m = 0, len = MIN(middle - first, last - middle), half = len >> 1;
+        0 < len;
+        len = half, half >>= 1) {
+      if(ss_compare(T, PA + GETIDX(*(middle + m + half)),
+                       PA + GETIDX(*(middle - m - half - 1)), depth) < 0) {
+        m += half + 1;
+        half -= (len & 1) ^ 1;
+      }
+    }
+
+    if(0 < m) {
+      lm = middle - m, rm = middle + m;
+      ss_blockswap(lm, middle, m);
+      l = r = middle, next = 0;
+      if(rm < last) {
+        if(*rm < 0) {
+          *rm = ~*rm;
+          if(first < lm) { for(; *--l < 0;) { } next |= 4; }
+          next |= 1;
+        } else if(first < lm) {
+          for(; *r < 0; ++r) { }
+          next |= 2;
+        }
+      }
+
+      if((l - first) <= (last - r)) {
+        STACK_PUSH(r, rm, last, (next & 3) | (check & 4));
+        middle = lm, last = l, check = (check & 3) | (next & 4);
+      } else {
+        if((next & 2) && (r == middle)) { next ^= 6; }
+        STACK_PUSH(first, lm, l, (check & 3) | (next & 4));
+        first = r, middle = rm, check = (next & 3) | (check & 4);
+      }
+    } else {
+      if(ss_compare(T, PA + GETIDX(*(middle - 1)), PA + *middle, depth) == 0) {
+        *middle = ~*middle;
+      }
+      MERGE_CHECK(first, last, check);
+      STACK_POP(first, middle, last, check);
+    }
+  }
+#undef STACK_SIZE
+}
+
+#endif /* SS_BLOCKSIZE != 0 */
+
+
+/*---------------------------------------------------------------------------*/
+
+/* Substring sort */
+static
+void
+sssort(const unsigned char *T, const int *PA,
+       int *first, int *last,
+       int *buf, int bufsize,
+       int depth, int n, int lastsuffix) {
+  int *a;
+#if SS_BLOCKSIZE != 0
+  int *b, *middle, *curbuf;
+  int j, k, curbufsize, limit;
+#endif
+  int i;
+
+  if(lastsuffix != 0) { ++first; }
+
+#if SS_BLOCKSIZE == 0
+  ss_mintrosort(T, PA, first, last, depth);
+#else
+  if((bufsize < SS_BLOCKSIZE) &&
+      (bufsize < (last - first)) &&
+      (bufsize < (limit = ss_isqrt(last - first)))) {
+    if(SS_BLOCKSIZE < limit) { limit = SS_BLOCKSIZE; }
+    buf = middle = last - limit, bufsize = limit;
+  } else {
+    middle = last, limit = 0;
+  }
+  for(a = first, i = 0; SS_BLOCKSIZE < (middle - a); a += SS_BLOCKSIZE, ++i) {
+#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE
+    ss_mintrosort(T, PA, a, a + SS_BLOCKSIZE, depth);
+#elif 1 < SS_BLOCKSIZE
+    ss_insertionsort(T, PA, a, a + SS_BLOCKSIZE, depth);
+#endif
+    curbufsize = last - (a + SS_BLOCKSIZE);
+    curbuf = a + SS_BLOCKSIZE;
+    if(curbufsize <= bufsize) { curbufsize = bufsize, curbuf = buf; }
+    for(b = a, k = SS_BLOCKSIZE, j = i; j & 1; b -= k, k <<= 1, j >>= 1) {
+      ss_swapmerge(T, PA, b - k, b, b + k, curbuf, curbufsize, depth);
+    }
+  }
+#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE
+  ss_mintrosort(T, PA, a, middle, depth);
+#elif 1 < SS_BLOCKSIZE
+  ss_insertionsort(T, PA, a, middle, depth);
+#endif
+  for(k = SS_BLOCKSIZE; i != 0; k <<= 1, i >>= 1) {
+    if(i & 1) {
+      ss_swapmerge(T, PA, a - k, a, middle, buf, bufsize, depth);
+      a -= k;
+    }
+  }
+  if(limit != 0) {
+#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE
+    ss_mintrosort(T, PA, middle, last, depth);
+#elif 1 < SS_BLOCKSIZE
+    ss_insertionsort(T, PA, middle, last, depth);
+#endif
+    ss_inplacemerge(T, PA, first, middle, last, depth);
+  }
+#endif
+
+  if(lastsuffix != 0) {
+    /* Insert last type B* suffix. */
+    int PAi[2]; PAi[0] = PA[*(first - 1)], PAi[1] = n - 2;
+    for(a = first, i = *(first - 1);
+        (a < last) && ((*a < 0) || (0 < ss_compare(T, &(PAi[0]), PA + *a, depth)));
+        ++a) {
+      *(a - 1) = *a;
+    }
+    *(a - 1) = i;
+  }
+}
+
+
+/*---------------------------------------------------------------------------*/
+
+static INLINE
+int
+tr_ilg(int n) {
+  return (n & 0xffff0000) ?
+          ((n & 0xff000000) ?
+            24 + lg_table[(n >> 24) & 0xff] :
+            16 + lg_table[(n >> 16) & 0xff]) :
+          ((n & 0x0000ff00) ?
+             8 + lg_table[(n >>  8) & 0xff] :
+             0 + lg_table[(n >>  0) & 0xff]);
+}
+
+
+/*---------------------------------------------------------------------------*/
+
+/* Simple insertionsort for small size groups. */
+static
+void
+tr_insertionsort(const int *ISAd, int *first, int *last) {
+  int *a, *b;
+  int t, r;
+
+  for(a = first + 1; a < last; ++a) {
+    for(t = *a, b = a - 1; 0 > (r = ISAd[t] - ISAd[*b]);) {
+      do { *(b + 1) = *b; } while((first <= --b) && (*b < 0));
+      if(b < first) { break; }
+    }
+    if(r == 0) { *b = ~*b; }
+    *(b + 1) = t;
+  }
+}
+
+
+/*---------------------------------------------------------------------------*/
+
+static INLINE
+void
+tr_fixdown(const int *ISAd, int *SA, int i, int size) {
+  int j, k;
+  int v;
+  int c, d, e;
+
+  for(v = SA[i], c = ISAd[v]; (j = 2 * i + 1) < size; SA[i] = SA[k], i = k) {
+    d = ISAd[SA[k = j++]];
+    if(d < (e = ISAd[SA[j]])) { k = j; d = e; }
+    if(d <= c) { break; }
+  }
+  SA[i] = v;
+}
+
+/* Simple top-down heapsort. */
+static
+void
+tr_heapsort(const int *ISAd, int *SA, int size) {
+  int i, m;
+  int t;
+
+  m = size;
+  if((size % 2) == 0) {
+    m--;
+    if(ISAd[SA[m / 2]] < ISAd[SA[m]]) { SWAP(SA[m], SA[m / 2]); }
+  }
+
+  for(i = m / 2 - 1; 0 <= i; --i) { tr_fixdown(ISAd, SA, i, m); }
+  if((size % 2) == 0) { SWAP(SA[0], SA[m]); tr_fixdown(ISAd, SA, 0, m); }
+  for(i = m - 1; 0 < i; --i) {
+    t = SA[0], SA[0] = SA[i];
+    tr_fixdown(ISAd, SA, 0, i);
+    SA[i] = t;
+  }
+}
+
+
+/*---------------------------------------------------------------------------*/
+
+/* Returns the median of three elements. */
+static INLINE
+int *
+tr_median3(const int *ISAd, int *v1, int *v2, int *v3) {
+  int *t;
+  if(ISAd[*v1] > ISAd[*v2]) { SWAP(v1, v2); }
+  if(ISAd[*v2] > ISAd[*v3]) {
+    if(ISAd[*v1] > ISAd[*v3]) { return v1; }
+    else { return v3; }
+  }
+  return v2;
+}
+
+/* Returns the median of five elements. */
+static INLINE
+int *
+tr_median5(const int *ISAd,
+           int *v1, int *v2, int *v3, int *v4, int *v5) {
+  int *t;
+  if(ISAd[*v2] > ISAd[*v3]) { SWAP(v2, v3); }
+  if(ISAd[*v4] > ISAd[*v5]) { SWAP(v4, v5); }
+  if(ISAd[*v2] > ISAd[*v4]) { SWAP(v2, v4); SWAP(v3, v5); }
+  if(ISAd[*v1] > ISAd[*v3]) { SWAP(v1, v3); }
+  if(ISAd[*v1] > ISAd[*v4]) { SWAP(v1, v4); SWAP(v3, v5); }
+  if(ISAd[*v3] > ISAd[*v4]) { return v4; }
+  return v3;
+}
+
+/* Returns the pivot element. */
+static INLINE
+int *
+tr_pivot(const int *ISAd, int *first, int *last) {
+  int *middle;
+  int t;
+
+  t = last - first;
+  middle = first + t / 2;
+
+  if(t <= 512) {
+    if(t <= 32) {
+      return tr_median3(ISAd, first, middle, last - 1);
+    } else {
+      t >>= 2;
+      return tr_median5(ISAd, first, first + t, middle, last - 1 - t, last - 1);
+    }
+  }
+  t >>= 3;
+  first  = tr_median3(ISAd, first, first + t, first + (t << 1));
+  middle = tr_median3(ISAd, middle - t, middle, middle + t);
+  last   = tr_median3(ISAd, last - 1 - (t << 1), last - 1 - t, last - 1);
+  return tr_median3(ISAd, first, middle, last);
+}
+
+
+/*---------------------------------------------------------------------------*/
+
+typedef struct _trbudget_t trbudget_t;
+struct _trbudget_t {
+  int chance;
+  int remain;
+  int incval;
+  int count;
+};
+
+static INLINE
+void
+trbudget_init(trbudget_t *budget, int chance, int incval) {
+  budget->chance = chance;
+  budget->remain = budget->incval = incval;
+}
+
+static INLINE
+int
+trbudget_check(trbudget_t *budget, int size) {
+  if(size <= budget->remain) { budget->remain -= size; return 1; }
+  if(budget->chance == 0) { budget->count += size; return 0; }
+  budget->remain += budget->incval - size;
+  budget->chance -= 1;
+  return 1;
+}
+
+
+/*---------------------------------------------------------------------------*/
+
+static INLINE
+void
+tr_partition(const int *ISAd,
+             int *first, int *middle, int *last,
+             int **pa, int **pb, int v) {
+  int *a, *b, *c, *d, *e, *f;
+  int t, s;
+  int x = 0;
+
+  for(b = middle - 1; (++b < last) && ((x = ISAd[*b]) == v);) { }
+  if(((a = b) < last) && (x < v)) {
+    for(; (++b < last) && ((x = ISAd[*b]) <= v);) {
+      if(x == v) { SWAP(*b, *a); ++a; }
+    }
+  }
+  for(c = last; (b < --c) && ((x = ISAd[*c]) == v);) { }
+  if((b < (d = c)) && (x > v)) {
+    for(; (b < --c) && ((x = ISAd[*c]) >= v);) {
+      if(x == v) { SWAP(*c, *d); --d; }
+    }
+  }
+  for(; b < c;) {
+    SWAP(*b, *c);
+    for(; (++b < c) && ((x = ISAd[*b]) <= v);) {
+      if(x == v) { SWAP(*b, *a); ++a; }
+    }
+    for(; (b < --c) && ((x = ISAd[*c]) >= v);) {
+      if(x == v) { SWAP(*c, *d); --d; }
+    }
+  }
+
+  if(a <= d) {
+    c = b - 1;
+    if((s = a - first) > (t = b - a)) { s = t; }
+    for(e = first, f = b - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }
+    if((s = d - c) > (t = last - d - 1)) { s = t; }
+    for(e = b, f = last - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }
+    first += (b - a), last -= (d - c);
+  }
+  *pa = first, *pb = last;
+}
+
+static
+void
+tr_copy(int *ISA, const int *SA,
+        int *first, int *a, int *b, int *last,
+        int depth) {
+  /* sort suffixes of middle partition
+     by using sorted order of suffixes of left and right partition. */
+  int *c, *d, *e;
+  int s, v;
+
+  v = b - SA - 1;
+  for(c = first, d = a - 1; c <= d; ++c) {
+    if((0 <= (s = *c - depth)) && (ISA[s] == v)) {
+      *++d = s;
+      ISA[s] = d - SA;
+    }
+  }
+  for(c = last - 1, e = d + 1, d = b; e < d; --c) {
+    if((0 <= (s = *c - depth)) && (ISA[s] == v)) {
+      *--d = s;
+      ISA[s] = d - SA;
+    }
+  }
+}
+
+static
+void
+tr_partialcopy(int *ISA, const int *SA,
+               int *first, int *a, int *b, int *last,
+               int depth) {
+  int *c, *d, *e;
+  int s, v;
+  int rank, lastrank, newrank = -1;
+
+  v = b - SA - 1;
+  lastrank = -1;
+  for(c = first, d = a - 1; c <= d; ++c) {
+    if((0 <= (s = *c - depth)) && (ISA[s] == v)) {
+      *++d = s;
+      rank = ISA[s + depth];
+      if(lastrank != rank) { lastrank = rank; newrank = d - SA; }
+      ISA[s] = newrank;
+    }
+  }
+
+  lastrank = -1;
+  for(e = d; first <= e; --e) {
+    rank = ISA[*e];
+    if(lastrank != rank) { lastrank = rank; newrank = e - SA; }
+    if(newrank != rank) { ISA[*e] = newrank; }
+  }
+
+  lastrank = -1;
+  for(c = last - 1, e = d + 1, d = b; e < d; --c) {
+    if((0 <= (s = *c - depth)) && (ISA[s] == v)) {
+      *--d = s;
+      rank = ISA[s + depth];
+      if(lastrank != rank) { lastrank = rank; newrank = d - SA; }
+      ISA[s] = newrank;
+    }
+  }
+}
+
+static
+void
+tr_introsort(int *ISA, const int *ISAd,
+             int *SA, int *first, int *last,
+             trbudget_t *budget) {
+#define STACK_SIZE TR_STACKSIZE
+  struct { const int *a; int *b, *c; int d, e; }stack[STACK_SIZE];
+  int *a, *b, *c;
+  int t;
+  int v, x = 0;
+  int incr = ISAd - ISA;
+  int limit, next;
+  int ssize, trlink = -1;
+
+  for(ssize = 0, limit = tr_ilg(last - first);;) {
+
+    if(limit < 0) {
+      if(limit == -1) {
+        /* tandem repeat partition */
+        tr_partition(ISAd - incr, first, first, last, &a, &b, last - SA - 1);
+
+        /* update ranks */
+        if(a < last) {
+          for(c = first, v = a - SA - 1; c < a; ++c) { ISA[*c] = v; }
+        }
+        if(b < last) {
+          for(c = a, v = b - SA - 1; c < b; ++c) { ISA[*c] = v; }
+        }
+
+        /* push */
+        if(1 < (b - a)) {
+          STACK_PUSH5(NULL, a, b, 0, 0);
+          STACK_PUSH5(ISAd - incr, first, last, -2, trlink);
+          trlink = ssize - 2;
+        }
+        if((a - first) <= (last - b)) {
+          if(1 < (a - first)) {
+            STACK_PUSH5(ISAd, b, last, tr_ilg(last - b), trlink);
+            last = a, limit = tr_ilg(a - first);
+          } else if(1 < (last - b)) {
+            first = b, limit = tr_ilg(last - b);
+          } else {
+            STACK_POP5(ISAd, first, last, limit, trlink);
+          }
+        } else {
+          if(1 < (last - b)) {
+            STACK_PUSH5(ISAd, first, a, tr_ilg(a - first), trlink);
+            first = b, limit = tr_ilg(last - b);
+          } else if(1 < (a - first)) {
+            last = a, limit = tr_ilg(a - first);
+          } else {
+            STACK_POP5(ISAd, first, last, limit, trlink);
+          }
+        }
+      } else if(limit == -2) {
+        /* tandem repeat copy */
+        a = stack[--ssize].b, b = stack[ssize].c;
+        if(stack[ssize].d == 0) {
+          tr_copy(ISA, SA, first, a, b, last, ISAd - ISA);
+        } else {
+          if(0 <= trlink) { stack[trlink].d = -1; }
+          tr_partialcopy(ISA, SA, first, a, b, last, ISAd - ISA);
+        }
+        STACK_POP5(ISAd, first, last, limit, trlink);
+      } else {
+        /* sorted partition */
+        if(0 <= *first) {
+          a = first;
+          do { ISA[*a] = a - SA; } while((++a < last) && (0 <= *a));
+          first = a;
+        }
+        if(first < last) {
+          a = first; do { *a = ~*a; } while(*++a < 0);
+          next = (ISA[*a] != ISAd[*a]) ? tr_ilg(a - first + 1) : -1;
+          if(++a < last) { for(b = first, v = a - SA - 1; b < a; ++b) { ISA[*b] = v; } }
+
+          /* push */
+          if(trbudget_check(budget, a - first)) {
+            if((a - first) <= (last - a)) {
+              STACK_PUSH5(ISAd, a, last, -3, trlink);
+              ISAd += incr, last = a, limit = next;
+            } else {
+              if(1 < (last - a)) {
+                STACK_PUSH5(ISAd + incr, first, a, next, trlink);
+                first = a, limit = -3;
+              } else {
+                ISAd += incr, last = a, limit = next;
+              }
+            }
+          } else {
+            if(0 <= trlink) { stack[trlink].d = -1; }
+            if(1 < (last - a)) {
+              first = a, limit = -3;
+            } else {
+              STACK_POP5(ISAd, first, last, limit, trlink);
+            }
+          }
+        } else {
+          STACK_POP5(ISAd, first, last, limit, trlink);
+        }
+      }
+      continue;
+    }
+
+    if((last - first) <= TR_INSERTIONSORT_THRESHOLD) {
+      tr_insertionsort(ISAd, first, last);
+      limit = -3;
+      continue;
+    }
+
+    if(limit-- == 0) {
+      tr_heapsort(ISAd, first, last - first);
+      for(a = last - 1; first < a; a = b) {
+        for(x = ISAd[*a], b = a - 1; (first <= b) && (ISAd[*b] == x); --b) { *b = ~*b; }
+      }
+      limit = -3;
+      continue;
+    }
+
+    /* choose pivot */
+    a = tr_pivot(ISAd, first, last);
+    SWAP(*first, *a);
+    v = ISAd[*first];
+
+    /* partition */
+    tr_partition(ISAd, first, first + 1, last, &a, &b, v);
+    if((last - first) != (b - a)) {
+      next = (ISA[*a] != v) ? tr_ilg(b - a) : -1;
+
+      /* update ranks */
+      for(c = first, v = a - SA - 1; c < a; ++c) { ISA[*c] = v; }
+      if(b < last) { for(c = a, v = b - SA - 1; c < b; ++c) { ISA[*c] = v; } }
+
+      /* push */
+      if((1 < (b - a)) && (trbudget_check(budget, b - a))) {
+        if((a - first) <= (last - b)) {
+          if((last - b) <= (b - a)) {
+            if(1 < (a - first)) {
+              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
+              STACK_PUSH5(ISAd, b, last, limit, trlink);
+              last = a;
+            } else if(1 < (last - b)) {
+              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
+              first = b;
+            } else {
+              ISAd += incr, first = a, last = b, limit = next;
+            }
+          } else if((a - first) <= (b - a)) {
+            if(1 < (a - first)) {
+              STACK_PUSH5(ISAd, b, last, limit, trlink);
+              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
+              last = a;
+            } else {
+              STACK_PUSH5(ISAd, b, last, limit, trlink);
+              ISAd += incr, first = a, last = b, limit = next;
+            }
+          } else {
+            STACK_PUSH5(ISAd, b, last, limit, trlink);
+            STACK_PUSH5(ISAd, first, a, limit, trlink);
+            ISAd += incr, first = a, last = b, limit = next;
+          }
+        } else {
+          if((a - first) <= (b - a)) {
+            if(1 < (last - b)) {
+              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
+              STACK_PUSH5(ISAd, first, a, limit, trlink);
+              first = b;
+            } else if(1 < (a - first)) {
+              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
+              last = a;
+            } else {
+              ISAd += incr, first = a, last = b, limit = next;
+            }
+          } else if((last - b) <= (b - a)) {
+            if(1 < (last - b)) {
+              STACK_PUSH5(ISAd, first, a, limit, trlink);
+              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
+              first = b;
+            } else {
+              STACK_PUSH5(ISAd, first, a, limit, trlink);
+              ISAd += incr, first = a, last = b, limit = next;
+            }
+          } else {
+            STACK_PUSH5(ISAd, first, a, limit, trlink);
+            STACK_PUSH5(ISAd, b, last, limit, trlink);
+            ISAd += incr, first = a, last = b, limit = next;
+          }
+        }
+      } else {
+        if((1 < (b - a)) && (0 <= trlink)) { stack[trlink].d = -1; }
+        if((a - first) <= (last - b)) {
+          if(1 < (a - first)) {
+            STACK_PUSH5(ISAd, b, last, limit, trlink);
+            last = a;
+          } else if(1 < (last - b)) {
+            first = b;
+          } else {
+            STACK_POP5(ISAd, first, last, limit, trlink);
+          }
+        } else {
+          if(1 < (last - b)) {
+            STACK_PUSH5(ISAd, first, a, limit, trlink);
+            first = b;
+          } else if(1 < (a - first)) {
+            last = a;
+          } else {
+            STACK_POP5(ISAd, first, last, limit, trlink);
+          }
+        }
+      }
+    } else {
+      if(trbudget_check(budget, last - first)) {
+        limit = tr_ilg(last - first), ISAd += incr;
+      } else {
+        if(0 <= trlink) { stack[trlink].d = -1; }
+        STACK_POP5(ISAd, first, last, limit, trlink);
+      }
+    }
+  }
+#undef STACK_SIZE
+}
+
+
+
+/*---------------------------------------------------------------------------*/
+
+/* Tandem repeat sort */
+static
+void
+trsort(int *ISA, int *SA, int n, int depth) {
+  int *ISAd;
+  int *first, *last;
+  trbudget_t budget;
+  int t, skip, unsorted;
+
+  trbudget_init(&budget, tr_ilg(n) * 2 / 3, n);
+/*  trbudget_init(&budget, tr_ilg(n) * 3 / 4, n); */
+  for(ISAd = ISA + depth; -n < *SA; ISAd += ISAd - ISA) {
+    first = SA;
+    skip = 0;
+    unsorted = 0;
+    do {
+      if((t = *first) < 0) { first -= t; skip += t; }
+      else {
+        if(skip != 0) { *(first + skip) = skip; skip = 0; }
+        last = SA + ISA[t] + 1;
+        if(1 < (last - first)) {
+          budget.count = 0;
+          tr_introsort(ISA, ISAd, SA, first, last, &budget);
+          if(budget.count != 0) { unsorted += budget.count; }
+          else { skip = first - last; }
+        } else if((last - first) == 1) {
+          skip = -1;
+        }
+        first = last;
+      }
+    } while(first < (SA + n));
+    if(skip != 0) { *(first + skip) = skip; }
+    if(unsorted == 0) { break; }
+  }
+}
+
+
+/*---------------------------------------------------------------------------*/
+
+/* Sorts suffixes of type B*. */
+static
+int
+sort_typeBstar(const unsigned char *T, int *SA,
+               int *bucket_A, int *bucket_B,
+               int n, int openMP) {
+  int *PAb, *ISAb, *buf;
+#ifdef LIBBSC_OPENMP
+  int *curbuf;
+  int l;
+#endif
+  int i, j, k, t, m, bufsize;
+  int c0, c1;
+#ifdef LIBBSC_OPENMP
+  int d0, d1;
+#endif
+  (void)openMP;
+
+  /* Initialize bucket arrays. */
+  for(i = 0; i < BUCKET_A_SIZE; ++i) { bucket_A[i] = 0; }
+  for(i = 0; i < BUCKET_B_SIZE; ++i) { bucket_B[i] = 0; }
+
+  /* Count the number of occurrences of the first one or two characters of each
+     type A, B and B* suffix. Moreover, store the beginning position of all
+     type B* suffixes into the array SA. */
+  for(i = n - 1, m = n, c0 = T[n - 1]; 0 <= i;) {
+    /* type A suffix. */
+    do { ++BUCKET_A(c1 = c0); } while((0 <= --i) && ((c0 = T[i]) >= c1));
+    if(0 <= i) {
+      /* type B* suffix. */
+      ++BUCKET_BSTAR(c0, c1);
+      SA[--m] = i;
+      /* type B suffix. */
+      for(--i, c1 = c0; (0 <= i) && ((c0 = T[i]) <= c1); --i, c1 = c0) {
+        ++BUCKET_B(c0, c1);
+      }
+    }
+  }
+  m = n - m;
+/*
+note:
+  A type B* suffix is lexicographically smaller than a type B suffix that
+  begins with the same first two characters.
+*/
+
+  /* Calculate the index of start/end point of each bucket. */
+  for(c0 = 0, i = 0, j = 0; c0 < ALPHABET_SIZE; ++c0) {
+    t = i + BUCKET_A(c0);
+    BUCKET_A(c0) = i + j; /* start point */
+    i = t + BUCKET_B(c0, c0);
+    for(c1 = c0 + 1; c1 < ALPHABET_SIZE; ++c1) {
+      j += BUCKET_BSTAR(c0, c1);
+      BUCKET_BSTAR(c0, c1) = j; /* end point */
+      i += BUCKET_B(c0, c1);
+    }
+  }
+
+  if(0 < m) {
+    /* Sort the type B* suffixes by their first two characters. */
+    PAb = SA + n - m; ISAb = SA + m;
+    for(i = m - 2; 0 <= i; --i) {
+      t = PAb[i], c0 = T[t], c1 = T[t + 1];
+      SA[--BUCKET_BSTAR(c0, c1)] = i;
+    }
+    t = PAb[m - 1], c0 = T[t], c1 = T[t + 1];
+    SA[--BUCKET_BSTAR(c0, c1)] = m - 1;
+
+    /* Sort the type B* substrings using sssort. */
+#ifdef LIBBSC_OPENMP
+    if (openMP)
+    {
+        buf = SA + m;
+        c0 = ALPHABET_SIZE - 2, c1 = ALPHABET_SIZE - 1, j = m;
+#pragma omp parallel default(shared) private(bufsize, curbuf, k, l, d0, d1)
+        {
+          bufsize = (n - (2 * m)) / omp_get_num_threads();
+          curbuf = buf + omp_get_thread_num() * bufsize;
+          k = 0;
+          for(;;) {
+            #pragma omp critical(sssort_lock)
+            {
+              if(0 < (l = j)) {
+                d0 = c0, d1 = c1;
+                do {
+                  k = BUCKET_BSTAR(d0, d1);
+                  if(--d1 <= d0) {
+                    d1 = ALPHABET_SIZE - 1;
+                    if(--d0 < 0) { break; }
+                  }
+                } while(((l - k) <= 1) && (0 < (l = k)));
+                c0 = d0, c1 = d1, j = k;
+              }
+            }
+            if(l == 0) { break; }
+            sssort(T, PAb, SA + k, SA + l,
+                   curbuf, bufsize, 2, n, *(SA + k) == (m - 1));
+          }
+        }
+    }
+    else
+    {
+        buf = SA + m, bufsize = n - (2 * m);
+        for(c0 = ALPHABET_SIZE - 2, j = m; 0 < j; --c0) {
+          for(c1 = ALPHABET_SIZE - 1; c0 < c1; j = i, --c1) {
+            i = BUCKET_BSTAR(c0, c1);
+            if(1 < (j - i)) {
+              sssort(T, PAb, SA + i, SA + j,
+                     buf, bufsize, 2, n, *(SA + i) == (m - 1));
+            }
+          }
+        }
+    }
+#else
+    buf = SA + m, bufsize = n - (2 * m);
+    for(c0 = ALPHABET_SIZE - 2, j = m; 0 < j; --c0) {
+      for(c1 = ALPHABET_SIZE - 1; c0 < c1; j = i, --c1) {
+        i = BUCKET_BSTAR(c0, c1);
+        if(1 < (j - i)) {
+          sssort(T, PAb, SA + i, SA + j,
+                 buf, bufsize, 2, n, *(SA + i) == (m - 1));
+        }
+      }
+    }
+#endif
+
+    /* Compute ranks of type B* substrings. */
+    for(i = m - 1; 0 <= i; --i) {
+      if(0 <= SA[i]) {
+        j = i;
+        do { ISAb[SA[i]] = i; } while((0 <= --i) && (0 <= SA[i]));
+        SA[i + 1] = i - j;
+        if(i <= 0) { break; }
+      }
+      j = i;
+      do { ISAb[SA[i] = ~SA[i]] = j; } while(SA[--i] < 0);
+      ISAb[SA[i]] = j;
+    }
+
+    /* Construct the inverse suffix array of type B* suffixes using trsort. */
+    trsort(ISAb, SA, m, 1);
+
+    /* Set the sorted order of type B* suffixes. */
+    for(i = n - 1, j = m, c0 = T[n - 1]; 0 <= i;) {
+      for(--i, c1 = c0; (0 <= i) && ((c0 = T[i]) >= c1); --i, c1 = c0) { }
+      if(0 <= i) {
+        t = i;
+        for(--i, c1 = c0; (0 <= i) && ((c0 = T[i]) <= c1); --i, c1 = c0) { }
+        SA[ISAb[--j]] = ((t == 0) || (1 < (t - i))) ? t : ~t;
+      }
+    }
+
+    /* Calculate the index of start/end point of each bucket. */
+    BUCKET_B(ALPHABET_SIZE - 1, ALPHABET_SIZE - 1) = n; /* end point */
+    for(c0 = ALPHABET_SIZE - 2, k = m - 1; 0 <= c0; --c0) {
+      i = BUCKET_A(c0 + 1) - 1;
+      for(c1 = ALPHABET_SIZE - 1; c0 < c1; --c1) {
+        t = i - BUCKET_B(c0, c1);
+        BUCKET_B(c0, c1) = i; /* end point */
+
+        /* Move all type B* suffixes to the correct position. */
+        for(i = t, j = BUCKET_BSTAR(c0, c1);
+            j <= k;
+            --i, --k) { SA[i] = SA[k]; }
+      }
+      BUCKET_BSTAR(c0, c0 + 1) = i - BUCKET_B(c0, c0) + 1; /* start point */
+      BUCKET_B(c0, c0) = i; /* end point */
+    }
+  }
+
+  return m;
+}
+
+/* Constructs the suffix array by using the sorted order of type B* suffixes. */
+static
+void
+construct_SA(const unsigned char *T, int *SA,
+             int *bucket_A, int *bucket_B,
+             int n, int m) {
+  int *i, *j, *k;
+  int s;
+  int c0, c1, c2;
+
+  if(0 < m) {
+    /* Construct the sorted order of type B suffixes by using
+       the sorted order of type B* suffixes. */
+    for(c1 = ALPHABET_SIZE - 2; 0 <= c1; --c1) {
+      /* Scan the suffix array from right to left. */
+      for(i = SA + BUCKET_BSTAR(c1, c1 + 1),
+          j = SA + BUCKET_A(c1 + 1) - 1, k = NULL, c2 = -1;
+          i <= j;
+          --j) {
+        if(0 < (s = *j)) {
+          assert(T[s] == c1);
+          assert(((s + 1) < n) && (T[s] <= T[s + 1]));
+          assert(T[s - 1] <= T[s]);
+          *j = ~s;
+          c0 = T[--s];
+          if((0 < s) && (T[s - 1] > c0)) { s = ~s; }
+          if(c0 != c2) {
+            if(0 <= c2) { BUCKET_B(c2, c1) = k - SA; }
+            k = SA + BUCKET_B(c2 = c0, c1);
+          }
+          assert(k < j); assert(k != NULL);
+          *k-- = s;
+        } else {
+          assert(((s == 0) && (T[s] == c1)) || (s < 0));
+          *j = ~s;
+        }
+      }
+    }
+  }
+
+  /* Construct the suffix array by using
+     the sorted order of type B suffixes. */
+  k = SA + BUCKET_A(c2 = T[n - 1]);
+  *k++ = (T[n - 2] < c2) ? ~(n - 1) : (n - 1);
+  /* Scan the suffix array from left to right. */
+  for(i = SA, j = SA + n; i < j; ++i) {
+    if(0 < (s = *i)) {
+      assert(T[s - 1] >= T[s]);
+      c0 = T[--s];
+      if((s == 0) || (T[s - 1] < c0)) { s = ~s; }
+      if(c0 != c2) {
+        BUCKET_A(c2) = k - SA;
+        k = SA + BUCKET_A(c2 = c0);
+      }
+      assert(i < k);
+      *k++ = s;
+    } else {
+      assert(s < 0);
+      *i = ~s;
+    }
+  }
+}
+
+/* Constructs the burrows-wheeler transformed string directly
+   by using the sorted order of type B* suffixes. */
+static
+int
+construct_BWT(const unsigned char *T, int *SA,
+              int *bucket_A, int *bucket_B,
+              int n, int m) {
+  int *i, *j, *k, *orig;
+  int s;
+  int c0, c1, c2;
+
+  if(0 < m) {
+    /* Construct the sorted order of type B suffixes by using
+       the sorted order of type B* suffixes. */
+    for(c1 = ALPHABET_SIZE - 2; 0 <= c1; --c1) {
+      /* Scan the suffix array from right to left. */
+      for(i = SA + BUCKET_BSTAR(c1, c1 + 1),
+          j = SA + BUCKET_A(c1 + 1) - 1, k = NULL, c2 = -1;
+          i <= j;
+          --j) {
+        if(0 < (s = *j)) {
+          assert(T[s] == c1);
+          assert(((s + 1) < n) && (T[s] <= T[s + 1]));
+          assert(T[s - 1] <= T[s]);
+          c0 = T[--s];
+          *j = ~((int)c0);
+          if((0 < s) && (T[s - 1] > c0)) { s = ~s; }
+          if(c0 != c2) {
+            if(0 <= c2) { BUCKET_B(c2, c1) = k - SA; }
+            k = SA + BUCKET_B(c2 = c0, c1);
+          }
+          assert(k < j); assert(k != NULL);
+          *k-- = s;
+        } else if(s != 0) {
+          *j = ~s;
+#ifndef NDEBUG
+        } else {
+          assert(T[s] == c1);
+#endif
+        }
+      }
+    }
+  }
+
+  /* Construct the BWTed string by using
+     the sorted order of type B suffixes. */
+  k = SA + BUCKET_A(c2 = T[n - 1]);
+  *k++ = (T[n - 2] < c2) ? ~((int)T[n - 2]) : (n - 1);
+  /* Scan the suffix array from left to right. */
+  for(i = SA, j = SA + n, orig = SA; i < j; ++i) {
+    if(0 < (s = *i)) {
+      assert(T[s - 1] >= T[s]);
+      c0 = T[--s];
+      *i = c0;
+      if((0 < s) && (T[s - 1] < c0)) { s = ~((int)T[s - 1]); }
+      if(c0 != c2) {
+        BUCKET_A(c2) = k - SA;
+        k = SA + BUCKET_A(c2 = c0);
+      }
+      assert(i < k);
+      *k++ = s;
+    } else if(s != 0) {
+      *i = ~s;
+    } else {
+      orig = i;
+    }
+  }
+
+  return orig - SA;
+}
+
+/* Constructs the burrows-wheeler transformed string directly
+   by using the sorted order of type B* suffixes. */
+static
+int
+construct_BWT_indexes(const unsigned char *T, int *SA,
+                      int *bucket_A, int *bucket_B,
+                      int n, int m,
+                      unsigned char * num_indexes, int * indexes) {
+  int *i, *j, *k, *orig;
+  int s;
+  int c0, c1, c2;
+
+  int mod = n / 8;
+  {
+      mod |= mod >> 1;  mod |= mod >> 2;
+      mod |= mod >> 4;  mod |= mod >> 8;
+      mod |= mod >> 16; mod >>= 1;
+
+      *num_indexes = (unsigned char)((n - 1) / (mod + 1));
+  }
+
+  if(0 < m) {
+    /* Construct the sorted order of type B suffixes by using
+       the sorted order of type B* suffixes. */
+    for(c1 = ALPHABET_SIZE - 2; 0 <= c1; --c1) {
+      /* Scan the suffix array from right to left. */
+      for(i = SA + BUCKET_BSTAR(c1, c1 + 1),
+          j = SA + BUCKET_A(c1 + 1) - 1, k = NULL, c2 = -1;
+          i <= j;
+          --j) {
+        if(0 < (s = *j)) {
+          assert(T[s] == c1);
+          assert(((s + 1) < n) && (T[s] <= T[s + 1]));
+          assert(T[s - 1] <= T[s]);
+
+          if ((s & mod) == 0) indexes[s / (mod + 1) - 1] = j - SA;
+
+          c0 = T[--s];
+          *j = ~((int)c0);
+          if((0 < s) && (T[s - 1] > c0)) { s = ~s; }
+          if(c0 != c2) {
+            if(0 <= c2) { BUCKET_B(c2, c1) = k - SA; }
+            k = SA + BUCKET_B(c2 = c0, c1);
+          }
+          assert(k < j); assert(k != NULL);
+          *k-- = s;
+        } else if(s != 0) {
+          *j = ~s;
+#ifndef NDEBUG
+        } else {
+          assert(T[s] == c1);
+#endif
+        }
+      }
+    }
+  }
+
+  /* Construct the BWTed string by using
+     the sorted order of type B suffixes. */
+  k = SA + BUCKET_A(c2 = T[n - 1]);
+  if (T[n - 2] < c2) {
+    if (((n - 1) & mod) == 0) indexes[(n - 1) / (mod + 1) - 1] = k - SA;
+    *k++ = ~((int)T[n - 2]);
+  }
+  else {
+    *k++ = n - 1;
+  }
+
+  /* Scan the suffix array from left to right. */
+  for(i = SA, j = SA + n, orig = SA; i < j; ++i) {
+    if(0 < (s = *i)) {
+      assert(T[s - 1] >= T[s]);
+
+      if ((s & mod) == 0) indexes[s / (mod + 1) - 1] = i - SA;
+
+      c0 = T[--s];
+      *i = c0;
+      if(c0 != c2) {
+        BUCKET_A(c2) = k - SA;
+        k = SA + BUCKET_A(c2 = c0);
+      }
+      assert(i < k);
+      if((0 < s) && (T[s - 1] < c0)) {
+          if ((s & mod) == 0) indexes[s / (mod + 1) - 1] = k - SA;
+          *k++ = ~((int)T[s - 1]);
+      } else
+        *k++ = s;
+    } else if(s != 0) {
+      *i = ~s;
+    } else {
+      orig = i;
+    }
+  }
+
+  return orig - SA;
+}
+
+
+/*---------------------------------------------------------------------------*/
+
+/*- Function -*/
+
+int
+divsufsort(const unsigned char *T, int *SA, int n, int openMP) {
+  int *bucket_A, *bucket_B;
+  int m;
+  int err = 0;
+
+  /* Check arguments. */
+  if((T == NULL) || (SA == NULL) || (n < 0)) { return -1; }
+  else if(n == 0) { return 0; }
+  else if(n == 1) { SA[0] = 0; return 0; }
+  else if(n == 2) { m = (T[0] < T[1]); SA[m ^ 1] = 0, SA[m] = 1; return 0; }
+
+  bucket_A = (int *)malloc(BUCKET_A_SIZE * sizeof(int));
+  bucket_B = (int *)malloc(BUCKET_B_SIZE * sizeof(int));
+
+  /* Suffixsort. */
+  if((bucket_A != NULL) && (bucket_B != NULL)) {
+    m = sort_typeBstar(T, SA, bucket_A, bucket_B, n, openMP);
+    construct_SA(T, SA, bucket_A, bucket_B, n, m);
+  } else {
+    err = -2;
+  }
+
+  free(bucket_B);
+  free(bucket_A);
+
+  return err;
+}
+
+int
+divbwt(const unsigned char *T, unsigned char *U, int *A, int n, unsigned char * num_indexes, int * indexes, int openMP) {
+  int *B;
+  int *bucket_A, *bucket_B;
+  int m, pidx, i;
+
+  /* Check arguments. */
+  if((T == NULL) || (U == NULL) || (n < 0)) { return -1; }
+  else if(n <= 1) { if(n == 1) { U[0] = T[0]; } return n; }
+
+  if((B = A) == NULL) { B = (int *)malloc((size_t)(n + 1) * sizeof(int)); }
+  bucket_A = (int *)malloc(BUCKET_A_SIZE * sizeof(int));
+  bucket_B = (int *)malloc(BUCKET_B_SIZE * sizeof(int));
+
+  /* Burrows-Wheeler Transform. */
+  if((B != NULL) && (bucket_A != NULL) && (bucket_B != NULL)) {
+    m = sort_typeBstar(T, B, bucket_A, bucket_B, n, openMP);
+
+    if (num_indexes == NULL || indexes == NULL) {
+        pidx = construct_BWT(T, B, bucket_A, bucket_B, n, m);
+    } else {
+        pidx = construct_BWT_indexes(T, B, bucket_A, bucket_B, n, m, num_indexes, indexes);
+    }
+
+    /* Copy to output string. */
+    U[0] = T[n - 1];
+    for(i = 0; i < pidx; ++i) { U[i + 1] = (unsigned char)B[i]; }
+    for(i += 1; i < n; ++i) { U[i] = (unsigned char)B[i]; }
+    pidx += 1;
+  } else {
+    pidx = -2;
+  }
+
+  free(bucket_B);
+  free(bucket_A);
+  if(A == NULL) { free(B); }
+
+  return pidx;
+}
diff --git a/src/3rdparty/zstd/src/dictBuilder/divsufsort.h b/src/3rdparty/zstd/src/dictBuilder/divsufsort.h
new file mode 100644
index 0000000000..5440994af1
--- /dev/null
+++ b/src/3rdparty/zstd/src/dictBuilder/divsufsort.h
@@ -0,0 +1,67 @@
+/*
+ * divsufsort.h for libdivsufsort-lite
+ * Copyright (c) 2003-2008 Yuta Mori All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DIVSUFSORT_H
+#define _DIVSUFSORT_H 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/*- Prototypes -*/
+
+/**
+ * Constructs the suffix array of a given string.
+ * @param T [0..n-1] The input string.
+ * @param SA [0..n-1] The output array of suffixes.
+ * @param n The length of the given string.
+ * @param openMP enables OpenMP optimization.
+ * @return 0 if no error occurred, -1 or -2 otherwise.
+ */
+int
+divsufsort(const unsigned char *T, int *SA, int n, int openMP);
+
+/**
+ * Constructs the burrows-wheeler transformed string of a given string.
+ * @param T [0..n-1] The input string.
+ * @param U [0..n-1] The output string. (can be T)
+ * @param A [0..n-1] The temporary array. (can be NULL)
+ * @param n The length of the given string.
+ * @param num_indexes The length of secondary indexes array. (can be NULL)
+ * @param indexes The secondary indexes array. (can be NULL)
+ * @param openMP enables OpenMP optimization.
+ * @return The primary index if no error occurred, -1 or -2 otherwise.
+ */
+int
+divbwt(const unsigned char *T, unsigned char *U, int *A, int n, unsigned char * num_indexes, int * indexes, int openMP);
+
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif /* __cplusplus */
+
+#endif /* _DIVSUFSORT_H */
diff --git a/src/3rdparty/zstd/src/dictBuilder/fastcover.c b/src/3rdparty/zstd/src/dictBuilder/fastcover.c
new file mode 100644
index 0000000000..46bba0120b
--- /dev/null
+++ b/src/3rdparty/zstd/src/dictBuilder/fastcover.c
@@ -0,0 +1,766 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+/*-*************************************
+*  Dependencies
+***************************************/
+#include <stdio.h>  /* fprintf */
+#include <stdlib.h> /* malloc, free, qsort */
+#include <string.h> /* memset */
+#include <time.h>   /* clock */
+
+#ifndef ZDICT_STATIC_LINKING_ONLY
+#  define ZDICT_STATIC_LINKING_ONLY
+#endif
+
+#include "../common/mem.h" /* read */
+#include "../common/pool.h"
+#include "../common/threading.h"
+#include "../common/zstd_internal.h" /* includes zstd.h */
+#include "../compress/zstd_compress_internal.h" /* ZSTD_hash*() */
+#include "../zdict.h"
+#include "cover.h"
+
+
+/*-*************************************
+*  Constants
+***************************************/
+/**
+* There are 32bit indexes used to ref samples, so limit samples size to 4GB
+* on 64bit builds.
+* For 32bit builds we choose 1 GB.
+* Most 32bit platforms have 2GB user-mode addressable space and we allocate a large
+* contiguous buffer, so 1GB is already a high limit.
+*/
+#define FASTCOVER_MAX_SAMPLES_SIZE (sizeof(size_t) == 8 ? ((unsigned)-1) : ((unsigned)1 GB))
+#define FASTCOVER_MAX_F 31
+#define FASTCOVER_MAX_ACCEL 10
+#define FASTCOVER_DEFAULT_SPLITPOINT 0.75
+#define DEFAULT_F 20
+#define DEFAULT_ACCEL 1
+
+
+/*-*************************************
+*  Console display
+***************************************/
+#ifndef LOCALDISPLAYLEVEL
+static int g_displayLevel = 0;
+#endif
+#undef  DISPLAY
+#define DISPLAY(...)                                                           \
+  {                                                                            \
+    fprintf(stderr, __VA_ARGS__);                                              \
+    fflush(stderr);                                                            \
+  }
+#undef  LOCALDISPLAYLEVEL
+#define LOCALDISPLAYLEVEL(displayLevel, l, ...)                                \
+  if (displayLevel >= l) {                                                     \
+    DISPLAY(__VA_ARGS__);                                                      \
+  } /* 0 : no display;   1: errors;   2: default;  3: details;  4: debug */
+#undef  DISPLAYLEVEL
+#define DISPLAYLEVEL(l, ...) LOCALDISPLAYLEVEL(g_displayLevel, l, __VA_ARGS__)
+
+#ifndef LOCALDISPLAYUPDATE
+static const clock_t g_refreshRate = CLOCKS_PER_SEC * 15 / 100;
+static clock_t g_time = 0;
+#endif
+#undef  LOCALDISPLAYUPDATE
+#define LOCALDISPLAYUPDATE(displayLevel, l, ...)                               \
+  if (displayLevel >= l) {                                                     \
+    if ((clock() - g_time > g_refreshRate) || (displayLevel >= 4)) {             \
+      g_time = clock();                                                        \
+      DISPLAY(__VA_ARGS__);                                                    \
+    }                                                                          \
+  }
+#undef  DISPLAYUPDATE
+#define DISPLAYUPDATE(l, ...) LOCALDISPLAYUPDATE(g_displayLevel, l, __VA_ARGS__)
+
+
+/*-*************************************
+* Hash Functions
+***************************************/
+/**
+ * Hash the d-byte value pointed to by p and mod 2^f into the frequency vector
+ */
+static size_t FASTCOVER_hashPtrToIndex(const void* p, U32 f, unsigned d) {
+  if (d == 6) {
+    return ZSTD_hash6Ptr(p, f);
+  }
+  return ZSTD_hash8Ptr(p, f);
+}
+
+
+/*-*************************************
+* Acceleration
+***************************************/
+typedef struct {
+  unsigned finalize;    /* Percentage of training samples used for ZDICT_finalizeDictionary */
+  unsigned skip;        /* Number of dmer skipped between each dmer counted in computeFrequency */
+} FASTCOVER_accel_t;
+
+
+static const FASTCOVER_accel_t FASTCOVER_defaultAccelParameters[FASTCOVER_MAX_ACCEL+1] = {
+  { 100, 0 },   /* accel = 0, should not happen because accel = 0 defaults to accel = 1 */
+  { 100, 0 },   /* accel = 1 */
+  { 50, 1 },   /* accel = 2 */
+  { 34, 2 },   /* accel = 3 */
+  { 25, 3 },   /* accel = 4 */
+  { 20, 4 },   /* accel = 5 */
+  { 17, 5 },   /* accel = 6 */
+  { 14, 6 },   /* accel = 7 */
+  { 13, 7 },   /* accel = 8 */
+  { 11, 8 },   /* accel = 9 */
+  { 10, 9 },   /* accel = 10 */
+};
+
+
+/*-*************************************
+* Context
+***************************************/
+typedef struct {
+  const BYTE *samples;
+  size_t *offsets;
+  const size_t *samplesSizes;
+  size_t nbSamples;
+  size_t nbTrainSamples;
+  size_t nbTestSamples;
+  size_t nbDmers;
+  U32 *freqs;
+  unsigned d;
+  unsigned f;
+  FASTCOVER_accel_t accelParams;
+} FASTCOVER_ctx_t;
+
+
+/*-*************************************
+*  Helper functions
+***************************************/
+/**
+ * Selects the best segment in an epoch.
+ * Segments of are scored according to the function:
+ *
+ * Let F(d) be the frequency of all dmers with hash value d.
+ * Let S_i be hash value of the dmer at position i of segment S which has length k.
+ *
+ *     Score(S) = F(S_1) + F(S_2) + ... + F(S_{k-d+1})
+ *
+ * Once the dmer with hash value d is in the dictionary we set F(d) = 0.
+ */
+static COVER_segment_t FASTCOVER_selectSegment(const FASTCOVER_ctx_t *ctx,
+                                              U32 *freqs, U32 begin, U32 end,
+                                              ZDICT_cover_params_t parameters,
+                                              U16* segmentFreqs) {
+  /* Constants */
+  const U32 k = parameters.k;
+  const U32 d = parameters.d;
+  const U32 f = ctx->f;
+  const U32 dmersInK = k - d + 1;
+
+  /* Try each segment (activeSegment) and save the best (bestSegment) */
+  COVER_segment_t bestSegment = {0, 0, 0};
+  COVER_segment_t activeSegment;
+
+  /* Reset the activeDmers in the segment */
+  /* The activeSegment starts at the beginning of the epoch. */
+  activeSegment.begin = begin;
+  activeSegment.end = begin;
+  activeSegment.score = 0;
+
+  /* Slide the activeSegment through the whole epoch.
+   * Save the best segment in bestSegment.
+   */
+  while (activeSegment.end < end) {
+    /* Get hash value of current dmer */
+    const size_t idx = FASTCOVER_hashPtrToIndex(ctx->samples + activeSegment.end, f, d);
+
+    /* Add frequency of this index to score if this is the first occurrence of index in active segment */
+    if (segmentFreqs[idx] == 0) {
+      activeSegment.score += freqs[idx];
+    }
+    /* Increment end of segment and segmentFreqs*/
+    activeSegment.end += 1;
+    segmentFreqs[idx] += 1;
+    /* If the window is now too large, drop the first position */
+    if (activeSegment.end - activeSegment.begin == dmersInK + 1) {
+      /* Get hash value of the dmer to be eliminated from active segment */
+      const size_t delIndex = FASTCOVER_hashPtrToIndex(ctx->samples + activeSegment.begin, f, d);
+      segmentFreqs[delIndex] -= 1;
+      /* Subtract frequency of this index from score if this is the last occurrence of this index in active segment */
+      if (segmentFreqs[delIndex] == 0) {
+        activeSegment.score -= freqs[delIndex];
+      }
+      /* Increment start of segment */
+      activeSegment.begin += 1;
+    }
+
+    /* If this segment is the best so far save it */
+    if (activeSegment.score > bestSegment.score) {
+      bestSegment = activeSegment;
+    }
+  }
+
+  /* Zero out rest of segmentFreqs array */
+  while (activeSegment.begin < end) {
+    const size_t delIndex = FASTCOVER_hashPtrToIndex(ctx->samples + activeSegment.begin, f, d);
+    segmentFreqs[delIndex] -= 1;
+    activeSegment.begin += 1;
+  }
+
+  {
+    /*  Zero the frequency of hash value of each dmer covered by the chosen segment. */
+    U32 pos;
+    for (pos = bestSegment.begin; pos != bestSegment.end; ++pos) {
+      const size_t i = FASTCOVER_hashPtrToIndex(ctx->samples + pos, f, d);
+      freqs[i] = 0;
+    }
+  }
+
+  return bestSegment;
+}
+
+
+static int FASTCOVER_checkParameters(ZDICT_cover_params_t parameters,
+                                     size_t maxDictSize, unsigned f,
+                                     unsigned accel) {
+  /* k, d, and f are required parameters */
+  if (parameters.d == 0 || parameters.k == 0) {
+    return 0;
+  }
+  /* d has to be 6 or 8 */
+  if (parameters.d != 6 && parameters.d != 8) {
+    return 0;
+  }
+  /* k <= maxDictSize */
+  if (parameters.k > maxDictSize) {
+    return 0;
+  }
+  /* d <= k */
+  if (parameters.d > parameters.k) {
+    return 0;
+  }
+  /* 0 < f <= FASTCOVER_MAX_F*/
+  if (f > FASTCOVER_MAX_F || f == 0) {
+    return 0;
+  }
+  /* 0 < splitPoint <= 1 */
+  if (parameters.splitPoint <= 0 || parameters.splitPoint > 1) {
+    return 0;
+  }
+  /* 0 < accel <= 10 */
+  if (accel > 10 || accel == 0) {
+    return 0;
+  }
+  return 1;
+}
+
+
+/**
+ * Clean up a context initialized with `FASTCOVER_ctx_init()`.
+ */
+static void
+FASTCOVER_ctx_destroy(FASTCOVER_ctx_t* ctx)
+{
+    if (!ctx) return;
+
+    free(ctx->freqs);
+    ctx->freqs = NULL;
+
+    free(ctx->offsets);
+    ctx->offsets = NULL;
+}
+
+
+/**
+ * Calculate for frequency of hash value of each dmer in ctx->samples
+ */
+static void
+FASTCOVER_computeFrequency(U32* freqs, const FASTCOVER_ctx_t* ctx)
+{
+    const unsigned f = ctx->f;
+    const unsigned d = ctx->d;
+    const unsigned skip = ctx->accelParams.skip;
+    const unsigned readLength = MAX(d, 8);
+    size_t i;
+    assert(ctx->nbTrainSamples >= 5);
+    assert(ctx->nbTrainSamples <= ctx->nbSamples);
+    for (i = 0; i < ctx->nbTrainSamples; i++) {
+        size_t start = ctx->offsets[i];  /* start of current dmer */
+        size_t const currSampleEnd = ctx->offsets[i+1];
+        while (start + readLength <= currSampleEnd) {
+            const size_t dmerIndex = FASTCOVER_hashPtrToIndex(ctx->samples + start, f, d);
+            freqs[dmerIndex]++;
+            start = start + skip + 1;
+        }
+    }
+}
+
+
+/**
+ * Prepare a context for dictionary building.
+ * The context is only dependent on the parameter `d` and can be used multiple
+ * times.
+ * Returns 0 on success or error code on error.
+ * The context must be destroyed with `FASTCOVER_ctx_destroy()`.
+ */
+static size_t
+FASTCOVER_ctx_init(FASTCOVER_ctx_t* ctx,
+                   const void* samplesBuffer,
+                   const size_t* samplesSizes, unsigned nbSamples,
+                   unsigned d, double splitPoint, unsigned f,
+                   FASTCOVER_accel_t accelParams)
+{
+    const BYTE* const samples = (const BYTE*)samplesBuffer;
+    const size_t totalSamplesSize = COVER_sum(samplesSizes, nbSamples);
+    /* Split samples into testing and training sets */
+    const unsigned nbTrainSamples = splitPoint < 1.0 ? (unsigned)((double)nbSamples * splitPoint) : nbSamples;
+    const unsigned nbTestSamples = splitPoint < 1.0 ? nbSamples - nbTrainSamples : nbSamples;
+    const size_t trainingSamplesSize = splitPoint < 1.0 ? COVER_sum(samplesSizes, nbTrainSamples) : totalSamplesSize;
+    const size_t testSamplesSize = splitPoint < 1.0 ? COVER_sum(samplesSizes + nbTrainSamples, nbTestSamples) : totalSamplesSize;
+
+    /* Checks */
+    if (totalSamplesSize < MAX(d, sizeof(U64)) ||
+        totalSamplesSize >= (size_t)FASTCOVER_MAX_SAMPLES_SIZE) {
+        DISPLAYLEVEL(1, "Total samples size is too large (%u MB), maximum size is %u MB\n",
+                    (unsigned)(totalSamplesSize >> 20), (FASTCOVER_MAX_SAMPLES_SIZE >> 20));
+        return ERROR(srcSize_wrong);
+    }
+
+    /* Check if there are at least 5 training samples */
+    if (nbTrainSamples < 5) {
+        DISPLAYLEVEL(1, "Total number of training samples is %u and is invalid\n", nbTrainSamples);
+        return ERROR(srcSize_wrong);
+    }
+
+    /* Check if there's testing sample */
+    if (nbTestSamples < 1) {
+        DISPLAYLEVEL(1, "Total number of testing samples is %u and is invalid.\n", nbTestSamples);
+        return ERROR(srcSize_wrong);
+    }
+
+    /* Zero the context */
+    memset(ctx, 0, sizeof(*ctx));
+    DISPLAYLEVEL(2, "Training on %u samples of total size %u\n", nbTrainSamples,
+                    (unsigned)trainingSamplesSize);
+    DISPLAYLEVEL(2, "Testing on %u samples of total size %u\n", nbTestSamples,
+                    (unsigned)testSamplesSize);
+
+    ctx->samples = samples;
+    ctx->samplesSizes = samplesSizes;
+    ctx->nbSamples = nbSamples;
+    ctx->nbTrainSamples = nbTrainSamples;
+    ctx->nbTestSamples = nbTestSamples;
+    ctx->nbDmers = trainingSamplesSize - MAX(d, sizeof(U64)) + 1;
+    ctx->d = d;
+    ctx->f = f;
+    ctx->accelParams = accelParams;
+
+    /* The offsets of each file */
+    ctx->offsets = (size_t*)calloc((nbSamples + 1), sizeof(size_t));
+    if (ctx->offsets == NULL) {
+        DISPLAYLEVEL(1, "Failed to allocate scratch buffers \n");
+        FASTCOVER_ctx_destroy(ctx);
+        return ERROR(memory_allocation);
+    }
+
+    /* Fill offsets from the samplesSizes */
+    {   U32 i;
+        ctx->offsets[0] = 0;
+        assert(nbSamples >= 5);
+        for (i = 1; i <= nbSamples; ++i) {
+            ctx->offsets[i] = ctx->offsets[i - 1] + samplesSizes[i - 1];
+        }
+    }
+
+    /* Initialize frequency array of size 2^f */
+    ctx->freqs = (U32*)calloc(((U64)1 << f), sizeof(U32));
+    if (ctx->freqs == NULL) {
+        DISPLAYLEVEL(1, "Failed to allocate frequency table \n");
+        FASTCOVER_ctx_destroy(ctx);
+        return ERROR(memory_allocation);
+    }
+
+    DISPLAYLEVEL(2, "Computing frequencies\n");
+    FASTCOVER_computeFrequency(ctx->freqs, ctx);
+
+    return 0;
+}
+
+
+/**
+ * Given the prepared context build the dictionary.
+ */
+static size_t
+FASTCOVER_buildDictionary(const FASTCOVER_ctx_t* ctx,
+                          U32* freqs,
+                          void* dictBuffer, size_t dictBufferCapacity,
+                          ZDICT_cover_params_t parameters,
+                          U16* segmentFreqs)
+{
+  BYTE *const dict = (BYTE *)dictBuffer;
+  size_t tail = dictBufferCapacity;
+  /* Divide the data into epochs. We will select one segment from each epoch. */
+  const COVER_epoch_info_t epochs = COVER_computeEpochs(
+      (U32)dictBufferCapacity, (U32)ctx->nbDmers, parameters.k, 1);
+  const size_t maxZeroScoreRun = 10;
+  size_t zeroScoreRun = 0;
+  size_t epoch;
+  DISPLAYLEVEL(2, "Breaking content into %u epochs of size %u\n",
+                (U32)epochs.num, (U32)epochs.size);
+  /* Loop through the epochs until there are no more segments or the dictionary
+   * is full.
+   */
+  for (epoch = 0; tail > 0; epoch = (epoch + 1) % epochs.num) {
+    const U32 epochBegin = (U32)(epoch * epochs.size);
+    const U32 epochEnd = epochBegin + epochs.size;
+    size_t segmentSize;
+    /* Select a segment */
+    COVER_segment_t segment = FASTCOVER_selectSegment(
+        ctx, freqs, epochBegin, epochEnd, parameters, segmentFreqs);
+
+    /* If the segment covers no dmers, then we are out of content.
+     * There may be new content in other epochs, for continue for some time.
+     */
+    if (segment.score == 0) {
+      if (++zeroScoreRun >= maxZeroScoreRun) {
+          break;
+      }
+      continue;
+    }
+    zeroScoreRun = 0;
+
+    /* Trim the segment if necessary and if it is too small then we are done */
+    segmentSize = MIN(segment.end - segment.begin + parameters.d - 1, tail);
+    if (segmentSize < parameters.d) {
+      break;
+    }
+
+    /* We fill the dictionary from the back to allow the best segments to be
+     * referenced with the smallest offsets.
+     */
+    tail -= segmentSize;
+    memcpy(dict + tail, ctx->samples + segment.begin, segmentSize);
+    DISPLAYUPDATE(
+        2, "\r%u%%       ",
+        (unsigned)(((dictBufferCapacity - tail) * 100) / dictBufferCapacity));
+  }
+  DISPLAYLEVEL(2, "\r%79s\r", "");
+  return tail;
+}
+
+/**
+ * Parameters for FASTCOVER_tryParameters().
+ */
+typedef struct FASTCOVER_tryParameters_data_s {
+    const FASTCOVER_ctx_t* ctx;
+    COVER_best_t* best;
+    size_t dictBufferCapacity;
+    ZDICT_cover_params_t parameters;
+} FASTCOVER_tryParameters_data_t;
+
+
+/**
+ * Tries a set of parameters and updates the COVER_best_t with the results.
+ * This function is thread safe if zstd is compiled with multithreaded support.
+ * It takes its parameters as an *OWNING* opaque pointer to support threading.
+ */
+static void FASTCOVER_tryParameters(void* opaque)
+{
+  /* Save parameters as local variables */
+  FASTCOVER_tryParameters_data_t *const data = (FASTCOVER_tryParameters_data_t*)opaque;
+  const FASTCOVER_ctx_t *const ctx = data->ctx;
+  const ZDICT_cover_params_t parameters = data->parameters;
+  size_t dictBufferCapacity = data->dictBufferCapacity;
+  size_t totalCompressedSize = ERROR(GENERIC);
+  /* Initialize array to keep track of frequency of dmer within activeSegment */
+  U16* segmentFreqs = (U16*)calloc(((U64)1 << ctx->f), sizeof(U16));
+  /* Allocate space for hash table, dict, and freqs */
+  BYTE *const dict = (BYTE*)malloc(dictBufferCapacity);
+  COVER_dictSelection_t selection = COVER_dictSelectionError(ERROR(GENERIC));
+  U32* freqs = (U32*) malloc(((U64)1 << ctx->f) * sizeof(U32));
+  if (!segmentFreqs || !dict || !freqs) {
+    DISPLAYLEVEL(1, "Failed to allocate buffers: out of memory\n");
+    goto _cleanup;
+  }
+  /* Copy the frequencies because we need to modify them */
+  memcpy(freqs, ctx->freqs, ((U64)1 << ctx->f) * sizeof(U32));
+  /* Build the dictionary */
+  { const size_t tail = FASTCOVER_buildDictionary(ctx, freqs, dict, dictBufferCapacity,
+                                                    parameters, segmentFreqs);
+
+    const unsigned nbFinalizeSamples = (unsigned)(ctx->nbTrainSamples * ctx->accelParams.finalize / 100);
+    selection = COVER_selectDict(dict + tail, dictBufferCapacity, dictBufferCapacity - tail,
+         ctx->samples, ctx->samplesSizes, nbFinalizeSamples, ctx->nbTrainSamples, ctx->nbSamples, parameters, ctx->offsets,
+         totalCompressedSize);
+
+    if (COVER_dictSelectionIsError(selection)) {
+      DISPLAYLEVEL(1, "Failed to select dictionary\n");
+      goto _cleanup;
+    }
+  }
+_cleanup:
+  free(dict);
+  COVER_best_finish(data->best, parameters, selection);
+  free(data);
+  free(segmentFreqs);
+  COVER_dictSelectionFree(selection);
+  free(freqs);
+}
+
+
+static void
+FASTCOVER_convertToCoverParams(ZDICT_fastCover_params_t fastCoverParams,
+                               ZDICT_cover_params_t* coverParams)
+{
+    coverParams->k = fastCoverParams.k;
+    coverParams->d = fastCoverParams.d;
+    coverParams->steps = fastCoverParams.steps;
+    coverParams->nbThreads = fastCoverParams.nbThreads;
+    coverParams->splitPoint = fastCoverParams.splitPoint;
+    coverParams->zParams = fastCoverParams.zParams;
+    coverParams->shrinkDict = fastCoverParams.shrinkDict;
+}
+
+
+static void
+FASTCOVER_convertToFastCoverParams(ZDICT_cover_params_t coverParams,
+                                   ZDICT_fastCover_params_t* fastCoverParams,
+                                   unsigned f, unsigned accel)
+{
+    fastCoverParams->k = coverParams.k;
+    fastCoverParams->d = coverParams.d;
+    fastCoverParams->steps = coverParams.steps;
+    fastCoverParams->nbThreads = coverParams.nbThreads;
+    fastCoverParams->splitPoint = coverParams.splitPoint;
+    fastCoverParams->f = f;
+    fastCoverParams->accel = accel;
+    fastCoverParams->zParams = coverParams.zParams;
+    fastCoverParams->shrinkDict = coverParams.shrinkDict;
+}
+
+
+ZDICTLIB_API size_t
+ZDICT_trainFromBuffer_fastCover(void* dictBuffer, size_t dictBufferCapacity,
+                                const void* samplesBuffer,
+                                const size_t* samplesSizes, unsigned nbSamples,
+                                ZDICT_fastCover_params_t parameters)
+{
+    BYTE* const dict = (BYTE*)dictBuffer;
+    FASTCOVER_ctx_t ctx;
+    ZDICT_cover_params_t coverParams;
+    FASTCOVER_accel_t accelParams;
+    /* Initialize global data */
+    g_displayLevel = (int)parameters.zParams.notificationLevel;
+    /* Assign splitPoint and f if not provided */
+    parameters.splitPoint = 1.0;
+    parameters.f = parameters.f == 0 ? DEFAULT_F : parameters.f;
+    parameters.accel = parameters.accel == 0 ? DEFAULT_ACCEL : parameters.accel;
+    /* Convert to cover parameter */
+    memset(&coverParams, 0 , sizeof(coverParams));
+    FASTCOVER_convertToCoverParams(parameters, &coverParams);
+    /* Checks */
+    if (!FASTCOVER_checkParameters(coverParams, dictBufferCapacity, parameters.f,
+                                   parameters.accel)) {
+      DISPLAYLEVEL(1, "FASTCOVER parameters incorrect\n");
+      return ERROR(parameter_outOfBound);
+    }
+    if (nbSamples == 0) {
+      DISPLAYLEVEL(1, "FASTCOVER must have at least one input file\n");
+      return ERROR(srcSize_wrong);
+    }
+    if (dictBufferCapacity < ZDICT_DICTSIZE_MIN) {
+      DISPLAYLEVEL(1, "dictBufferCapacity must be at least %u\n",
+                   ZDICT_DICTSIZE_MIN);
+      return ERROR(dstSize_tooSmall);
+    }
+    /* Assign corresponding FASTCOVER_accel_t to accelParams*/
+    accelParams = FASTCOVER_defaultAccelParameters[parameters.accel];
+    /* Initialize context */
+    {
+      size_t const initVal = FASTCOVER_ctx_init(&ctx, samplesBuffer, samplesSizes, nbSamples,
+                            coverParams.d, parameters.splitPoint, parameters.f,
+                            accelParams);
+      if (ZSTD_isError(initVal)) {
+        DISPLAYLEVEL(1, "Failed to initialize context\n");
+        return initVal;
+      }
+    }
+    COVER_warnOnSmallCorpus(dictBufferCapacity, ctx.nbDmers, g_displayLevel);
+    /* Build the dictionary */
+    DISPLAYLEVEL(2, "Building dictionary\n");
+    {
+      /* Initialize array to keep track of frequency of dmer within activeSegment */
+      U16* segmentFreqs = (U16 *)calloc(((U64)1 << parameters.f), sizeof(U16));
+      const size_t tail = FASTCOVER_buildDictionary(&ctx, ctx.freqs, dictBuffer,
+                                                dictBufferCapacity, coverParams, segmentFreqs);
+      const unsigned nbFinalizeSamples = (unsigned)(ctx.nbTrainSamples * ctx.accelParams.finalize / 100);
+      const size_t dictionarySize = ZDICT_finalizeDictionary(
+          dict, dictBufferCapacity, dict + tail, dictBufferCapacity - tail,
+          samplesBuffer, samplesSizes, nbFinalizeSamples, coverParams.zParams);
+      if (!ZSTD_isError(dictionarySize)) {
+          DISPLAYLEVEL(2, "Constructed dictionary of size %u\n",
+                      (unsigned)dictionarySize);
+      }
+      FASTCOVER_ctx_destroy(&ctx);
+      free(segmentFreqs);
+      return dictionarySize;
+    }
+}
+
+
+ZDICTLIB_API size_t
+ZDICT_optimizeTrainFromBuffer_fastCover(
+                    void* dictBuffer, size_t dictBufferCapacity,
+                    const void* samplesBuffer,
+                    const size_t* samplesSizes, unsigned nbSamples,
+                    ZDICT_fastCover_params_t* parameters)
+{
+    ZDICT_cover_params_t coverParams;
+    FASTCOVER_accel_t accelParams;
+    /* constants */
+    const unsigned nbThreads = parameters->nbThreads;
+    const double splitPoint =
+        parameters->splitPoint <= 0.0 ? FASTCOVER_DEFAULT_SPLITPOINT : parameters->splitPoint;
+    const unsigned kMinD = parameters->d == 0 ? 6 : parameters->d;
+    const unsigned kMaxD = parameters->d == 0 ? 8 : parameters->d;
+    const unsigned kMinK = parameters->k == 0 ? 50 : parameters->k;
+    const unsigned kMaxK = parameters->k == 0 ? 2000 : parameters->k;
+    const unsigned kSteps = parameters->steps == 0 ? 40 : parameters->steps;
+    const unsigned kStepSize = MAX((kMaxK - kMinK) / kSteps, 1);
+    const unsigned kIterations =
+        (1 + (kMaxD - kMinD) / 2) * (1 + (kMaxK - kMinK) / kStepSize);
+    const unsigned f = parameters->f == 0 ? DEFAULT_F : parameters->f;
+    const unsigned accel = parameters->accel == 0 ? DEFAULT_ACCEL : parameters->accel;
+    const unsigned shrinkDict = 0;
+    /* Local variables */
+    const int displayLevel = (int)parameters->zParams.notificationLevel;
+    unsigned iteration = 1;
+    unsigned d;
+    unsigned k;
+    COVER_best_t best;
+    POOL_ctx *pool = NULL;
+    int warned = 0;
+    /* Checks */
+    if (splitPoint <= 0 || splitPoint > 1) {
+      LOCALDISPLAYLEVEL(displayLevel, 1, "Incorrect splitPoint\n");
+      return ERROR(parameter_outOfBound);
+    }
+    if (accel == 0 || accel > FASTCOVER_MAX_ACCEL) {
+      LOCALDISPLAYLEVEL(displayLevel, 1, "Incorrect accel\n");
+      return ERROR(parameter_outOfBound);
+    }
+    if (kMinK < kMaxD || kMaxK < kMinK) {
+      LOCALDISPLAYLEVEL(displayLevel, 1, "Incorrect k\n");
+      return ERROR(parameter_outOfBound);
+    }
+    if (nbSamples == 0) {
+      LOCALDISPLAYLEVEL(displayLevel, 1, "FASTCOVER must have at least one input file\n");
+      return ERROR(srcSize_wrong);
+    }
+    if (dictBufferCapacity < ZDICT_DICTSIZE_MIN) {
+      LOCALDISPLAYLEVEL(displayLevel, 1, "dictBufferCapacity must be at least %u\n",
+                   ZDICT_DICTSIZE_MIN);
+      return ERROR(dstSize_tooSmall);
+    }
+    if (nbThreads > 1) {
+      pool = POOL_create(nbThreads, 1);
+      if (!pool) {
+        return ERROR(memory_allocation);
+      }
+    }
+    /* Initialization */
+    COVER_best_init(&best);
+    memset(&coverParams, 0 , sizeof(coverParams));
+    FASTCOVER_convertToCoverParams(*parameters, &coverParams);
+    accelParams = FASTCOVER_defaultAccelParameters[accel];
+    /* Turn down global display level to clean up display at level 2 and below */
+    g_displayLevel = displayLevel == 0 ? 0 : displayLevel - 1;
+    /* Loop through d first because each new value needs a new context */
+    LOCALDISPLAYLEVEL(displayLevel, 2, "Trying %u different sets of parameters\n",
+                      kIterations);
+    for (d = kMinD; d <= kMaxD; d += 2) {
+      /* Initialize the context for this value of d */
+      FASTCOVER_ctx_t ctx;
+      LOCALDISPLAYLEVEL(displayLevel, 3, "d=%u\n", d);
+      {
+        size_t const initVal = FASTCOVER_ctx_init(&ctx, samplesBuffer, samplesSizes, nbSamples, d, splitPoint, f, accelParams);
+        if (ZSTD_isError(initVal)) {
+          LOCALDISPLAYLEVEL(displayLevel, 1, "Failed to initialize context\n");
+          COVER_best_destroy(&best);
+          POOL_free(pool);
+          return initVal;
+        }
+      }
+      if (!warned) {
+        COVER_warnOnSmallCorpus(dictBufferCapacity, ctx.nbDmers, displayLevel);
+        warned = 1;
+      }
+      /* Loop through k reusing the same context */
+      for (k = kMinK; k <= kMaxK; k += kStepSize) {
+        /* Prepare the arguments */
+        FASTCOVER_tryParameters_data_t *data = (FASTCOVER_tryParameters_data_t *)malloc(
+            sizeof(FASTCOVER_tryParameters_data_t));
+        LOCALDISPLAYLEVEL(displayLevel, 3, "k=%u\n", k);
+        if (!data) {
+          LOCALDISPLAYLEVEL(displayLevel, 1, "Failed to allocate parameters\n");
+          COVER_best_destroy(&best);
+          FASTCOVER_ctx_destroy(&ctx);
+          POOL_free(pool);
+          return ERROR(memory_allocation);
+        }
+        data->ctx = &ctx;
+        data->best = &best;
+        data->dictBufferCapacity = dictBufferCapacity;
+        data->parameters = coverParams;
+        data->parameters.k = k;
+        data->parameters.d = d;
+        data->parameters.splitPoint = splitPoint;
+        data->parameters.steps = kSteps;
+        data->parameters.shrinkDict = shrinkDict;
+        data->parameters.zParams.notificationLevel = (unsigned)g_displayLevel;
+        /* Check the parameters */
+        if (!FASTCOVER_checkParameters(data->parameters, dictBufferCapacity,
+                                       data->ctx->f, accel)) {
+          DISPLAYLEVEL(1, "FASTCOVER parameters incorrect\n");
+          free(data);
+          continue;
+        }
+        /* Call the function and pass ownership of data to it */
+        COVER_best_start(&best);
+        if (pool) {
+          POOL_add(pool, &FASTCOVER_tryParameters, data);
+        } else {
+          FASTCOVER_tryParameters(data);
+        }
+        /* Print status */
+        LOCALDISPLAYUPDATE(displayLevel, 2, "\r%u%%       ",
+                           (unsigned)((iteration * 100) / kIterations));
+        ++iteration;
+      }
+      COVER_best_wait(&best);
+      FASTCOVER_ctx_destroy(&ctx);
+    }
+    LOCALDISPLAYLEVEL(displayLevel, 2, "\r%79s\r", "");
+    /* Fill the output buffer and parameters with output of the best parameters */
+    {
+      const size_t dictSize = best.dictSize;
+      if (ZSTD_isError(best.compressedSize)) {
+        const size_t compressedSize = best.compressedSize;
+        COVER_best_destroy(&best);
+        POOL_free(pool);
+        return compressedSize;
+      }
+      FASTCOVER_convertToFastCoverParams(best.parameters, parameters, f, accel);
+      memcpy(dictBuffer, best.dict, dictSize);
+      COVER_best_destroy(&best);
+      POOL_free(pool);
+      return dictSize;
+    }
+
+}
diff --git a/src/3rdparty/zstd/src/dictBuilder/zdict.c b/src/3rdparty/zstd/src/dictBuilder/zdict.c
new file mode 100644
index 0000000000..58290f450d
--- /dev/null
+++ b/src/3rdparty/zstd/src/dictBuilder/zdict.c
@@ -0,0 +1,1127 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+
+/*-**************************************
+*  Tuning parameters
+****************************************/
+#define MINRATIO 4   /* minimum nb of apparition to be selected in dictionary */
+#define ZDICT_MAX_SAMPLES_SIZE (2000U << 20)
+#define ZDICT_MIN_SAMPLES_SIZE (ZDICT_CONTENTSIZE_MIN * MINRATIO)
+
+
+/*-**************************************
+*  Compiler Options
+****************************************/
+/* Unix Large Files support (>4GB) */
+#define _FILE_OFFSET_BITS 64
+#if (defined(__sun__) && (!defined(__LP64__)))   /* Sun Solaris 32-bits requires specific definitions */
+#  ifndef _LARGEFILE_SOURCE
+#  define _LARGEFILE_SOURCE
+#  endif
+#elif ! defined(__LP64__)                        /* No point defining Large file for 64 bit */
+#  ifndef _LARGEFILE64_SOURCE
+#  define _LARGEFILE64_SOURCE
+#  endif
+#endif
+
+
+/*-*************************************
+*  Dependencies
+***************************************/
+#include <stdlib.h>        /* malloc, free */
+#include <string.h>        /* memset */
+#include <stdio.h>         /* fprintf, fopen, ftello64 */
+#include <time.h>          /* clock */
+
+#ifndef ZDICT_STATIC_LINKING_ONLY
+#  define ZDICT_STATIC_LINKING_ONLY
+#endif
+
+#include "../common/mem.h"           /* read */
+#include "../common/fse.h"           /* FSE_normalizeCount, FSE_writeNCount */
+#include "../common/huf.h"           /* HUF_buildCTable, HUF_writeCTable */
+#include "../common/zstd_internal.h" /* includes zstd.h */
+#include "../common/xxhash.h"        /* XXH64 */
+#include "../compress/zstd_compress_internal.h" /* ZSTD_loadCEntropy() */
+#include "../zdict.h"
+#include "divsufsort.h"
+#include "../common/bits.h"          /* ZSTD_NbCommonBytes */
+
+
+/*-*************************************
+*  Constants
+***************************************/
+#define KB *(1 <<10)
+#define MB *(1 <<20)
+#define GB *(1U<<30)
+
+#define DICTLISTSIZE_DEFAULT 10000
+
+#define NOISELENGTH 32
+
+static const U32 g_selectivity_default = 9;
+
+
+/*-*************************************
+*  Console display
+***************************************/
+#undef  DISPLAY
+#define DISPLAY(...)         { fprintf(stderr, __VA_ARGS__); fflush( stderr ); }
+#undef  DISPLAYLEVEL
+#define DISPLAYLEVEL(l, ...) if (notificationLevel>=l) { DISPLAY(__VA_ARGS__); }    /* 0 : no display;   1: errors;   2: default;  3: details;  4: debug */
+
+static clock_t ZDICT_clockSpan(clock_t nPrevious) { return clock() - nPrevious; }
+
+static void ZDICT_printHex(const void* ptr, size_t length)
+{
+    const BYTE* const b = (const BYTE*)ptr;
+    size_t u;
+    for (u=0; u<length; u++) {
+        BYTE c = b[u];
+        if (c<32 || c>126) c = '.';   /* non-printable char */
+        DISPLAY("%c", c);
+    }
+}
+
+
+/*-********************************************************
+*  Helper functions
+**********************************************************/
+unsigned ZDICT_isError(size_t errorCode) { return ERR_isError(errorCode); }
+
+const char* ZDICT_getErrorName(size_t errorCode) { return ERR_getErrorName(errorCode); }
+
+unsigned ZDICT_getDictID(const void* dictBuffer, size_t dictSize)
+{
+    if (dictSize < 8) return 0;
+    if (MEM_readLE32(dictBuffer) != ZSTD_MAGIC_DICTIONARY) return 0;
+    return MEM_readLE32((const char*)dictBuffer + 4);
+}
+
+size_t ZDICT_getDictHeaderSize(const void* dictBuffer, size_t dictSize)
+{
+    size_t headerSize;
+    if (dictSize <= 8 || MEM_readLE32(dictBuffer) != ZSTD_MAGIC_DICTIONARY) return ERROR(dictionary_corrupted);
+
+    {   ZSTD_compressedBlockState_t* bs = (ZSTD_compressedBlockState_t*)malloc(sizeof(ZSTD_compressedBlockState_t));
+        U32* wksp = (U32*)malloc(HUF_WORKSPACE_SIZE);
+        if (!bs || !wksp) {
+            headerSize = ERROR(memory_allocation);
+        } else {
+            ZSTD_reset_compressedBlockState(bs);
+            headerSize = ZSTD_loadCEntropy(bs, wksp, dictBuffer, dictSize);
+        }
+
+        free(bs);
+        free(wksp);
+    }
+
+    return headerSize;
+}
+
+/*-********************************************************
+*  Dictionary training functions
+**********************************************************/
+/*! ZDICT_count() :
+    Count the nb of common bytes between 2 pointers.
+    Note : this function presumes end of buffer followed by noisy guard band.
+*/
+static size_t ZDICT_count(const void* pIn, const void* pMatch)
+{
+    const char* const pStart = (const char*)pIn;
+    for (;;) {
+        size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);
+        if (!diff) {
+            pIn = (const char*)pIn+sizeof(size_t);
+            pMatch = (const char*)pMatch+sizeof(size_t);
+            continue;
+        }
+        pIn = (const char*)pIn+ZSTD_NbCommonBytes(diff);
+        return (size_t)((const char*)pIn - pStart);
+    }
+}
+
+
+typedef struct {
+    U32 pos;
+    U32 length;
+    U32 savings;
+} dictItem;
+
+static void ZDICT_initDictItem(dictItem* d)
+{
+    d->pos = 1;
+    d->length = 0;
+    d->savings = (U32)(-1);
+}
+
+
+#define LLIMIT 64          /* heuristic determined experimentally */
+#define MINMATCHLENGTH 7   /* heuristic determined experimentally */
+static dictItem ZDICT_analyzePos(
+                       BYTE* doneMarks,
+                       const int* suffix, U32 start,
+                       const void* buffer, U32 minRatio, U32 notificationLevel)
+{
+    U32 lengthList[LLIMIT] = {0};
+    U32 cumulLength[LLIMIT] = {0};
+    U32 savings[LLIMIT] = {0};
+    const BYTE* b = (const BYTE*)buffer;
+    size_t maxLength = LLIMIT;
+    size_t pos = (size_t)suffix[start];
+    U32 end = start;
+    dictItem solution;
+
+    /* init */
+    memset(&solution, 0, sizeof(solution));
+    doneMarks[pos] = 1;
+
+    /* trivial repetition cases */
+    if ( (MEM_read16(b+pos+0) == MEM_read16(b+pos+2))
+       ||(MEM_read16(b+pos+1) == MEM_read16(b+pos+3))
+       ||(MEM_read16(b+pos+2) == MEM_read16(b+pos+4)) ) {
+        /* skip and mark segment */
+        U16 const pattern16 = MEM_read16(b+pos+4);
+        U32 u, patternEnd = 6;
+        while (MEM_read16(b+pos+patternEnd) == pattern16) patternEnd+=2 ;
+        if (b[pos+patternEnd] == b[pos+patternEnd-1]) patternEnd++;
+        for (u=1; u<patternEnd; u++)
+            doneMarks[pos+u] = 1;
+        return solution;
+    }
+
+    /* look forward */
+    {   size_t length;
+        do {
+            end++;
+            length = ZDICT_count(b + pos, b + suffix[end]);
+        } while (length >= MINMATCHLENGTH);
+    }
+
+    /* look backward */
+    {   size_t length;
+        do {
+            length = ZDICT_count(b + pos, b + *(suffix+start-1));
+            if (length >=MINMATCHLENGTH) start--;
+        } while(length >= MINMATCHLENGTH);
+    }
+
+    /* exit if not found a minimum nb of repetitions */
+    if (end-start < minRatio) {
+        U32 idx;
+        for(idx=start; idx<end; idx++)
+            doneMarks[suffix[idx]] = 1;
+        return solution;
+    }
+
+    {   int i;
+        U32 mml;
+        U32 refinedStart = start;
+        U32 refinedEnd = end;
+
+        DISPLAYLEVEL(4, "\n");
+        DISPLAYLEVEL(4, "found %3u matches of length >= %i at pos %7u  ", (unsigned)(end-start), MINMATCHLENGTH, (unsigned)pos);
+        DISPLAYLEVEL(4, "\n");
+
+        for (mml = MINMATCHLENGTH ; ; mml++) {
+            BYTE currentChar = 0;
+            U32 currentCount = 0;
+            U32 currentID = refinedStart;
+            U32 id;
+            U32 selectedCount = 0;
+            U32 selectedID = currentID;
+            for (id =refinedStart; id < refinedEnd; id++) {
+                if (b[suffix[id] + mml] != currentChar) {
+                    if (currentCount > selectedCount) {
+                        selectedCount = currentCount;
+                        selectedID = currentID;
+                    }
+                    currentID = id;
+                    currentChar = b[ suffix[id] + mml];
+                    currentCount = 0;
+                }
+                currentCount ++;
+            }
+            if (currentCount > selectedCount) {  /* for last */
+                selectedCount = currentCount;
+                selectedID = currentID;
+            }
+
+            if (selectedCount < minRatio)
+                break;
+            refinedStart = selectedID;
+            refinedEnd = refinedStart + selectedCount;
+        }
+
+        /* evaluate gain based on new dict */
+        start = refinedStart;
+        pos = suffix[refinedStart];
+        end = start;
+        memset(lengthList, 0, sizeof(lengthList));
+
+        /* look forward */
+        {   size_t length;
+            do {
+                end++;
+                length = ZDICT_count(b + pos, b + suffix[end]);
+                if (length >= LLIMIT) length = LLIMIT-1;
+                lengthList[length]++;
+            } while (length >=MINMATCHLENGTH);
+        }
+
+        /* look backward */
+        {   size_t length = MINMATCHLENGTH;
+            while ((length >= MINMATCHLENGTH) & (start > 0)) {
+                length = ZDICT_count(b + pos, b + suffix[start - 1]);
+                if (length >= LLIMIT) length = LLIMIT - 1;
+                lengthList[length]++;
+                if (length >= MINMATCHLENGTH) start--;
+            }
+        }
+
+        /* largest useful length */
+        memset(cumulLength, 0, sizeof(cumulLength));
+        cumulLength[maxLength-1] = lengthList[maxLength-1];
+        for (i=(int)(maxLength-2); i>=0; i--)
+            cumulLength[i] = cumulLength[i+1] + lengthList[i];
+
+        for (i=LLIMIT-1; i>=MINMATCHLENGTH; i--) if (cumulLength[i]>=minRatio) break;
+        maxLength = i;
+
+        /* reduce maxLength in case of final into repetitive data */
+        {   U32 l = (U32)maxLength;
+            BYTE const c = b[pos + maxLength-1];
+            while (b[pos+l-2]==c) l--;
+            maxLength = l;
+        }
+        if (maxLength < MINMATCHLENGTH) return solution;   /* skip : no long-enough solution */
+
+        /* calculate savings */
+        savings[5] = 0;
+        for (i=MINMATCHLENGTH; i<=(int)maxLength; i++)
+            savings[i] = savings[i-1] + (lengthList[i] * (i-3));
+
+        DISPLAYLEVEL(4, "Selected dict at position %u, of length %u : saves %u (ratio: %.2f)  \n",
+                     (unsigned)pos, (unsigned)maxLength, (unsigned)savings[maxLength], (double)savings[maxLength] / (double)maxLength);
+
+        solution.pos = (U32)pos;
+        solution.length = (U32)maxLength;
+        solution.savings = savings[maxLength];
+
+        /* mark positions done */
+        {   U32 id;
+            for (id=start; id<end; id++) {
+                U32 p, pEnd, length;
+                U32 const testedPos = (U32)suffix[id];
+                if (testedPos == pos)
+                    length = solution.length;
+                else {
+                    length = (U32)ZDICT_count(b+pos, b+testedPos);
+                    if (length > solution.length) length = solution.length;
+                }
+                pEnd = (U32)(testedPos + length);
+                for (p=testedPos; p<pEnd; p++)
+                    doneMarks[p] = 1;
+    }   }   }
+
+    return solution;
+}
+
+
+static int isIncluded(const void* in, const void* container, size_t length)
+{
+    const char* const ip = (const char*) in;
+    const char* const into = (const char*) container;
+    size_t u;
+
+    for (u=0; u<length; u++) {  /* works because end of buffer is a noisy guard band */
+        if (ip[u] != into[u]) break;
+    }
+
+    return u==length;
+}
+
+/*! ZDICT_tryMerge() :
+    check if dictItem can be merged, do it if possible
+    @return : id of destination elt, 0 if not merged
+*/
+static U32 ZDICT_tryMerge(dictItem* table, dictItem elt, U32 eltNbToSkip, const void* buffer)
+{
+    const U32 tableSize = table->pos;
+    const U32 eltEnd = elt.pos + elt.length;
+    const char* const buf = (const char*) buffer;
+
+    /* tail overlap */
+    U32 u; for (u=1; u<tableSize; u++) {
+        if (u==eltNbToSkip) continue;
+        if ((table[u].pos > elt.pos) && (table[u].pos <= eltEnd)) {  /* overlap, existing > new */
+            /* append */
+            U32 const addedLength = table[u].pos - elt.pos;
+            table[u].length += addedLength;
+            table[u].pos = elt.pos;
+            table[u].savings += elt.savings * addedLength / elt.length;   /* rough approx */
+            table[u].savings += elt.length / 8;    /* rough approx bonus */
+            elt = table[u];
+            /* sort : improve rank */
+            while ((u>1) && (table[u-1].savings < elt.savings))
+                table[u] = table[u-1], u--;
+            table[u] = elt;
+            return u;
+    }   }
+
+    /* front overlap */
+    for (u=1; u<tableSize; u++) {
+        if (u==eltNbToSkip) continue;
+
+        if ((table[u].pos + table[u].length >= elt.pos) && (table[u].pos < elt.pos)) {  /* overlap, existing < new */
+            /* append */
+            int const addedLength = (int)eltEnd - (int)(table[u].pos + table[u].length);
+            table[u].savings += elt.length / 8;    /* rough approx bonus */
+            if (addedLength > 0) {   /* otherwise, elt fully included into existing */
+                table[u].length += addedLength;
+                table[u].savings += elt.savings * addedLength / elt.length;   /* rough approx */
+            }
+            /* sort : improve rank */
+            elt = table[u];
+            while ((u>1) && (table[u-1].savings < elt.savings))
+                table[u] = table[u-1], u--;
+            table[u] = elt;
+            return u;
+        }
+
+        if (MEM_read64(buf + table[u].pos) == MEM_read64(buf + elt.pos + 1)) {
+            if (isIncluded(buf + table[u].pos, buf + elt.pos + 1, table[u].length)) {
+                size_t const addedLength = MAX( (int)elt.length - (int)table[u].length , 1 );
+                table[u].pos = elt.pos;
+                table[u].savings += (U32)(elt.savings * addedLength / elt.length);
+                table[u].length = MIN(elt.length, table[u].length + 1);
+                return u;
+            }
+        }
+    }
+
+    return 0;
+}
+
+
+static void ZDICT_removeDictItem(dictItem* table, U32 id)
+{
+    /* convention : table[0].pos stores nb of elts */
+    U32 const max = table[0].pos;
+    U32 u;
+    if (!id) return;   /* protection, should never happen */
+    for (u=id; u<max-1; u++)
+        table[u] = table[u+1];
+    table->pos--;
+}
+
+
+static void ZDICT_insertDictItem(dictItem* table, U32 maxSize, dictItem elt, const void* buffer)
+{
+    /* merge if possible */
+    U32 mergeId = ZDICT_tryMerge(table, elt, 0, buffer);
+    if (mergeId) {
+        U32 newMerge = 1;
+        while (newMerge) {
+            newMerge = ZDICT_tryMerge(table, table[mergeId], mergeId, buffer);
+            if (newMerge) ZDICT_removeDictItem(table, mergeId);
+            mergeId = newMerge;
+        }
+        return;
+    }
+
+    /* insert */
+    {   U32 current;
+        U32 nextElt = table->pos;
+        if (nextElt >= maxSize) nextElt = maxSize-1;
+        current = nextElt-1;
+        while (table[current].savings < elt.savings) {
+            table[current+1] = table[current];
+            current--;
+        }
+        table[current+1] = elt;
+        table->pos = nextElt+1;
+    }
+}
+
+
+static U32 ZDICT_dictSize(const dictItem* dictList)
+{
+    U32 u, dictSize = 0;
+    for (u=1; u<dictList[0].pos; u++)
+        dictSize += dictList[u].length;
+    return dictSize;
+}
+
+
+static size_t ZDICT_trainBuffer_legacy(dictItem* dictList, U32 dictListSize,
+                            const void* const buffer, size_t bufferSize,   /* buffer must end with noisy guard band */
+                            const size_t* fileSizes, unsigned nbFiles,
+                            unsigned minRatio, U32 notificationLevel)
+{
+    int* const suffix0 = (int*)malloc((bufferSize+2)*sizeof(*suffix0));
+    int* const suffix = suffix0+1;
+    U32* reverseSuffix = (U32*)malloc((bufferSize)*sizeof(*reverseSuffix));
+    BYTE* doneMarks = (BYTE*)malloc((bufferSize+16)*sizeof(*doneMarks));   /* +16 for overflow security */
+    U32* filePos = (U32*)malloc(nbFiles * sizeof(*filePos));
+    size_t result = 0;
+    clock_t displayClock = 0;
+    clock_t const refreshRate = CLOCKS_PER_SEC * 3 / 10;
+
+#   undef  DISPLAYUPDATE
+#   define DISPLAYUPDATE(l, ...) if (notificationLevel>=l) { \
+            if (ZDICT_clockSpan(displayClock) > refreshRate)  \
+            { displayClock = clock(); DISPLAY(__VA_ARGS__); \
+            if (notificationLevel>=4) fflush(stderr); } }
+
+    /* init */
+    DISPLAYLEVEL(2, "\r%70s\r", "");   /* clean display line */
+    if (!suffix0 || !reverseSuffix || !doneMarks || !filePos) {
+        result = ERROR(memory_allocation);
+        goto _cleanup;
+    }
+    if (minRatio < MINRATIO) minRatio = MINRATIO;
+    memset(doneMarks, 0, bufferSize+16);
+
+    /* limit sample set size (divsufsort limitation)*/
+    if (bufferSize > ZDICT_MAX_SAMPLES_SIZE) DISPLAYLEVEL(3, "sample set too large : reduced to %u MB ...\n", (unsigned)(ZDICT_MAX_SAMPLES_SIZE>>20));
+    while (bufferSize > ZDICT_MAX_SAMPLES_SIZE) bufferSize -= fileSizes[--nbFiles];
+
+    /* sort */
+    DISPLAYLEVEL(2, "sorting %u files of total size %u MB ...\n", nbFiles, (unsigned)(bufferSize>>20));
+    {   int const divSuftSortResult = divsufsort((const unsigned char*)buffer, suffix, (int)bufferSize, 0);
+        if (divSuftSortResult != 0) { result = ERROR(GENERIC); goto _cleanup; }
+    }
+    suffix[bufferSize] = (int)bufferSize;   /* leads into noise */
+    suffix0[0] = (int)bufferSize;           /* leads into noise */
+    /* build reverse suffix sort */
+    {   size_t pos;
+        for (pos=0; pos < bufferSize; pos++)
+            reverseSuffix[suffix[pos]] = (U32)pos;
+        /* note filePos tracks borders between samples.
+           It's not used at this stage, but planned to become useful in a later update */
+        filePos[0] = 0;
+        for (pos=1; pos<nbFiles; pos++)
+            filePos[pos] = (U32)(filePos[pos-1] + fileSizes[pos-1]);
+    }
+
+    DISPLAYLEVEL(2, "finding patterns ... \n");
+    DISPLAYLEVEL(3, "minimum ratio : %u \n", minRatio);
+
+    {   U32 cursor; for (cursor=0; cursor < bufferSize; ) {
+            dictItem solution;
+            if (doneMarks[cursor]) { cursor++; continue; }
+            solution = ZDICT_analyzePos(doneMarks, suffix, reverseSuffix[cursor], buffer, minRatio, notificationLevel);
+            if (solution.length==0) { cursor++; continue; }
+            ZDICT_insertDictItem(dictList, dictListSize, solution, buffer);
+            cursor += solution.length;
+            DISPLAYUPDATE(2, "\r%4.2f %% \r", (double)cursor / (double)bufferSize * 100.0);
+    }   }
+
+_cleanup:
+    free(suffix0);
+    free(reverseSuffix);
+    free(doneMarks);
+    free(filePos);
+    return result;
+}
+
+
+static void ZDICT_fillNoise(void* buffer, size_t length)
+{
+    unsigned const prime1 = 2654435761U;
+    unsigned const prime2 = 2246822519U;
+    unsigned acc = prime1;
+    size_t p=0;
+    for (p=0; p<length; p++) {
+        acc *= prime2;
+        ((unsigned char*)buffer)[p] = (unsigned char)(acc >> 21);
+    }
+}
+
+
+typedef struct
+{
+    ZSTD_CDict* dict;    /* dictionary */
+    ZSTD_CCtx* zc;     /* working context */
+    void* workPlace;   /* must be ZSTD_BLOCKSIZE_MAX allocated */
+} EStats_ress_t;
+
+#define MAXREPOFFSET 1024
+
+static void ZDICT_countEStats(EStats_ress_t esr, const ZSTD_parameters* params,
+                              unsigned* countLit, unsigned* offsetcodeCount, unsigned* matchlengthCount, unsigned* litlengthCount, U32* repOffsets,
+                              const void* src, size_t srcSize,
+                              U32 notificationLevel)
+{
+    size_t const blockSizeMax = MIN (ZSTD_BLOCKSIZE_MAX, 1 << params->cParams.windowLog);
+    size_t cSize;
+
+    if (srcSize > blockSizeMax) srcSize = blockSizeMax;   /* protection vs large samples */
+    {   size_t const errorCode = ZSTD_compressBegin_usingCDict_deprecated(esr.zc, esr.dict);
+        if (ZSTD_isError(errorCode)) { DISPLAYLEVEL(1, "warning : ZSTD_compressBegin_usingCDict failed \n"); return; }
+
+    }
+    cSize = ZSTD_compressBlock_deprecated(esr.zc, esr.workPlace, ZSTD_BLOCKSIZE_MAX, src, srcSize);
+    if (ZSTD_isError(cSize)) { DISPLAYLEVEL(3, "warning : could not compress sample size %u \n", (unsigned)srcSize); return; }
+
+    if (cSize) {  /* if == 0; block is not compressible */
+        const seqStore_t* const seqStorePtr = ZSTD_getSeqStore(esr.zc);
+
+        /* literals stats */
+        {   const BYTE* bytePtr;
+            for(bytePtr = seqStorePtr->litStart; bytePtr < seqStorePtr->lit; bytePtr++)
+                countLit[*bytePtr]++;
+        }
+
+        /* seqStats */
+        {   U32 const nbSeq = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);
+            ZSTD_seqToCodes(seqStorePtr);
+
+            {   const BYTE* codePtr = seqStorePtr->ofCode;
+                U32 u;
+                for (u=0; u<nbSeq; u++) offsetcodeCount[codePtr[u]]++;
+            }
+
+            {   const BYTE* codePtr = seqStorePtr->mlCode;
+                U32 u;
+                for (u=0; u<nbSeq; u++) matchlengthCount[codePtr[u]]++;
+            }
+
+            {   const BYTE* codePtr = seqStorePtr->llCode;
+                U32 u;
+                for (u=0; u<nbSeq; u++) litlengthCount[codePtr[u]]++;
+            }
+
+            if (nbSeq >= 2) { /* rep offsets */
+                const seqDef* const seq = seqStorePtr->sequencesStart;
+                U32 offset1 = seq[0].offBase - ZSTD_REP_NUM;
+                U32 offset2 = seq[1].offBase - ZSTD_REP_NUM;
+                if (offset1 >= MAXREPOFFSET) offset1 = 0;
+                if (offset2 >= MAXREPOFFSET) offset2 = 0;
+                repOffsets[offset1] += 3;
+                repOffsets[offset2] += 1;
+    }   }   }
+}
+
+static size_t ZDICT_totalSampleSize(const size_t* fileSizes, unsigned nbFiles)
+{
+    size_t total=0;
+    unsigned u;
+    for (u=0; u<nbFiles; u++) total += fileSizes[u];
+    return total;
+}
+
+typedef struct { U32 offset; U32 count; } offsetCount_t;
+
+static void ZDICT_insertSortCount(offsetCount_t table[ZSTD_REP_NUM+1], U32 val, U32 count)
+{
+    U32 u;
+    table[ZSTD_REP_NUM].offset = val;
+    table[ZSTD_REP_NUM].count = count;
+    for (u=ZSTD_REP_NUM; u>0; u--) {
+        offsetCount_t tmp;
+        if (table[u-1].count >= table[u].count) break;
+        tmp = table[u-1];
+        table[u-1] = table[u];
+        table[u] = tmp;
+    }
+}
+
+/* ZDICT_flatLit() :
+ * rewrite `countLit` to contain a mostly flat but still compressible distribution of literals.
+ * necessary to avoid generating a non-compressible distribution that HUF_writeCTable() cannot encode.
+ */
+static void ZDICT_flatLit(unsigned* countLit)
+{
+    int u;
+    for (u=1; u<256; u++) countLit[u] = 2;
+    countLit[0]   = 4;
+    countLit[253] = 1;
+    countLit[254] = 1;
+}
+
+#define OFFCODE_MAX 30  /* only applicable to first block */
+static size_t ZDICT_analyzeEntropy(void*  dstBuffer, size_t maxDstSize,
+                                   int compressionLevel,
+                             const void*  srcBuffer, const size_t* fileSizes, unsigned nbFiles,
+                             const void* dictBuffer, size_t  dictBufferSize,
+                                   unsigned notificationLevel)
+{
+    unsigned countLit[256];
+    HUF_CREATE_STATIC_CTABLE(hufTable, 255);
+    unsigned offcodeCount[OFFCODE_MAX+1];
+    short offcodeNCount[OFFCODE_MAX+1];
+    U32 offcodeMax = ZSTD_highbit32((U32)(dictBufferSize + 128 KB));
+    unsigned matchLengthCount[MaxML+1];
+    short matchLengthNCount[MaxML+1];
+    unsigned litLengthCount[MaxLL+1];
+    short litLengthNCount[MaxLL+1];
+    U32 repOffset[MAXREPOFFSET];
+    offsetCount_t bestRepOffset[ZSTD_REP_NUM+1];
+    EStats_ress_t esr = { NULL, NULL, NULL };
+    ZSTD_parameters params;
+    U32 u, huffLog = 11, Offlog = OffFSELog, mlLog = MLFSELog, llLog = LLFSELog, total;
+    size_t pos = 0, errorCode;
+    size_t eSize = 0;
+    size_t const totalSrcSize = ZDICT_totalSampleSize(fileSizes, nbFiles);
+    size_t const averageSampleSize = totalSrcSize / (nbFiles + !nbFiles);
+    BYTE* dstPtr = (BYTE*)dstBuffer;
+    U32 wksp[HUF_CTABLE_WORKSPACE_SIZE_U32];
+
+    /* init */
+    DEBUGLOG(4, "ZDICT_analyzeEntropy");
+    if (offcodeMax>OFFCODE_MAX) { eSize = ERROR(dictionaryCreation_failed); goto _cleanup; }   /* too large dictionary */
+    for (u=0; u<256; u++) countLit[u] = 1;   /* any character must be described */
+    for (u=0; u<=offcodeMax; u++) offcodeCount[u] = 1;
+    for (u=0; u<=MaxML; u++) matchLengthCount[u] = 1;
+    for (u=0; u<=MaxLL; u++) litLengthCount[u] = 1;
+    memset(repOffset, 0, sizeof(repOffset));
+    repOffset[1] = repOffset[4] = repOffset[8] = 1;
+    memset(bestRepOffset, 0, sizeof(bestRepOffset));
+    if (compressionLevel==0) compressionLevel = ZSTD_CLEVEL_DEFAULT;
+    params = ZSTD_getParams(compressionLevel, averageSampleSize, dictBufferSize);
+
+    esr.dict = ZSTD_createCDict_advanced(dictBuffer, dictBufferSize, ZSTD_dlm_byRef, ZSTD_dct_rawContent, params.cParams, ZSTD_defaultCMem);
+    esr.zc = ZSTD_createCCtx();
+    esr.workPlace = malloc(ZSTD_BLOCKSIZE_MAX);
+    if (!esr.dict || !esr.zc || !esr.workPlace) {
+        eSize = ERROR(memory_allocation);
+        DISPLAYLEVEL(1, "Not enough memory \n");
+        goto _cleanup;
+    }
+
+    /* collect stats on all samples */
+    for (u=0; u<nbFiles; u++) {
+        ZDICT_countEStats(esr, &params,
+                          countLit, offcodeCount, matchLengthCount, litLengthCount, repOffset,
+                         (const char*)srcBuffer + pos, fileSizes[u],
+                          notificationLevel);
+        pos += fileSizes[u];
+    }
+
+    if (notificationLevel >= 4) {
+        /* writeStats */
+        DISPLAYLEVEL(4, "Offset Code Frequencies : \n");
+        for (u=0; u<=offcodeMax; u++) {
+            DISPLAYLEVEL(4, "%2u :%7u \n", u, offcodeCount[u]);
+    }   }
+
+    /* analyze, build stats, starting with literals */
+    {   size_t maxNbBits = HUF_buildCTable_wksp(hufTable, countLit, 255, huffLog, wksp, sizeof(wksp));
+        if (HUF_isError(maxNbBits)) {
+            eSize = maxNbBits;
+            DISPLAYLEVEL(1, " HUF_buildCTable error \n");
+            goto _cleanup;
+        }
+        if (maxNbBits==8) {  /* not compressible : will fail on HUF_writeCTable() */
+            DISPLAYLEVEL(2, "warning : pathological dataset : literals are not compressible : samples are noisy or too regular \n");
+            ZDICT_flatLit(countLit);  /* replace distribution by a fake "mostly flat but still compressible" distribution, that HUF_writeCTable() can encode */
+            maxNbBits = HUF_buildCTable_wksp(hufTable, countLit, 255, huffLog, wksp, sizeof(wksp));
+            assert(maxNbBits==9);
+        }
+        huffLog = (U32)maxNbBits;
+    }
+
+    /* looking for most common first offsets */
+    {   U32 offset;
+        for (offset=1; offset<MAXREPOFFSET; offset++)
+            ZDICT_insertSortCount(bestRepOffset, offset, repOffset[offset]);
+    }
+    /* note : the result of this phase should be used to better appreciate the impact on statistics */
+
+    total=0; for (u=0; u<=offcodeMax; u++) total+=offcodeCount[u];
+    errorCode = FSE_normalizeCount(offcodeNCount, Offlog, offcodeCount, total, offcodeMax, /* useLowProbCount */ 1);
+    if (FSE_isError(errorCode)) {
+        eSize = errorCode;
+        DISPLAYLEVEL(1, "FSE_normalizeCount error with offcodeCount \n");
+        goto _cleanup;
+    }
+    Offlog = (U32)errorCode;
+
+    total=0; for (u=0; u<=MaxML; u++) total+=matchLengthCount[u];
+    errorCode = FSE_normalizeCount(matchLengthNCount, mlLog, matchLengthCount, total, MaxML, /* useLowProbCount */ 1);
+    if (FSE_isError(errorCode)) {
+        eSize = errorCode;
+        DISPLAYLEVEL(1, "FSE_normalizeCount error with matchLengthCount \n");
+        goto _cleanup;
+    }
+    mlLog = (U32)errorCode;
+
+    total=0; for (u=0; u<=MaxLL; u++) total+=litLengthCount[u];
+    errorCode = FSE_normalizeCount(litLengthNCount, llLog, litLengthCount, total, MaxLL, /* useLowProbCount */ 1);
+    if (FSE_isError(errorCode)) {
+        eSize = errorCode;
+        DISPLAYLEVEL(1, "FSE_normalizeCount error with litLengthCount \n");
+        goto _cleanup;
+    }
+    llLog = (U32)errorCode;
+
+    /* write result to buffer */
+    {   size_t const hhSize = HUF_writeCTable_wksp(dstPtr, maxDstSize, hufTable, 255, huffLog, wksp, sizeof(wksp));
+        if (HUF_isError(hhSize)) {
+            eSize = hhSize;
+            DISPLAYLEVEL(1, "HUF_writeCTable error \n");
+            goto _cleanup;
+        }
+        dstPtr += hhSize;
+        maxDstSize -= hhSize;
+        eSize += hhSize;
+    }
+
+    {   size_t const ohSize = FSE_writeNCount(dstPtr, maxDstSize, offcodeNCount, OFFCODE_MAX, Offlog);
+        if (FSE_isError(ohSize)) {
+            eSize = ohSize;
+            DISPLAYLEVEL(1, "FSE_writeNCount error with offcodeNCount \n");
+            goto _cleanup;
+        }
+        dstPtr += ohSize;
+        maxDstSize -= ohSize;
+        eSize += ohSize;
+    }
+
+    {   size_t const mhSize = FSE_writeNCount(dstPtr, maxDstSize, matchLengthNCount, MaxML, mlLog);
+        if (FSE_isError(mhSize)) {
+            eSize = mhSize;
+            DISPLAYLEVEL(1, "FSE_writeNCount error with matchLengthNCount \n");
+            goto _cleanup;
+        }
+        dstPtr += mhSize;
+        maxDstSize -= mhSize;
+        eSize += mhSize;
+    }
+
+    {   size_t const lhSize = FSE_writeNCount(dstPtr, maxDstSize, litLengthNCount, MaxLL, llLog);
+        if (FSE_isError(lhSize)) {
+            eSize = lhSize;
+            DISPLAYLEVEL(1, "FSE_writeNCount error with litlengthNCount \n");
+            goto _cleanup;
+        }
+        dstPtr += lhSize;
+        maxDstSize -= lhSize;
+        eSize += lhSize;
+    }
+
+    if (maxDstSize<12) {
+        eSize = ERROR(dstSize_tooSmall);
+        DISPLAYLEVEL(1, "not enough space to write RepOffsets \n");
+        goto _cleanup;
+    }
+# if 0
+    MEM_writeLE32(dstPtr+0, bestRepOffset[0].offset);
+    MEM_writeLE32(dstPtr+4, bestRepOffset[1].offset);
+    MEM_writeLE32(dstPtr+8, bestRepOffset[2].offset);
+#else
+    /* at this stage, we don't use the result of "most common first offset",
+     * as the impact of statistics is not properly evaluated */
+    MEM_writeLE32(dstPtr+0, repStartValue[0]);
+    MEM_writeLE32(dstPtr+4, repStartValue[1]);
+    MEM_writeLE32(dstPtr+8, repStartValue[2]);
+#endif
+    eSize += 12;
+
+_cleanup:
+    ZSTD_freeCDict(esr.dict);
+    ZSTD_freeCCtx(esr.zc);
+    free(esr.workPlace);
+
+    return eSize;
+}
+
+
+/**
+ * @returns the maximum repcode value
+ */
+static U32 ZDICT_maxRep(U32 const reps[ZSTD_REP_NUM])
+{
+    U32 maxRep = reps[0];
+    int r;
+    for (r = 1; r < ZSTD_REP_NUM; ++r)
+        maxRep = MAX(maxRep, reps[r]);
+    return maxRep;
+}
+
+size_t ZDICT_finalizeDictionary(void* dictBuffer, size_t dictBufferCapacity,
+                          const void* customDictContent, size_t dictContentSize,
+                          const void* samplesBuffer, const size_t* samplesSizes,
+                          unsigned nbSamples, ZDICT_params_t params)
+{
+    size_t hSize;
+#define HBUFFSIZE 256   /* should prove large enough for all entropy headers */
+    BYTE header[HBUFFSIZE];
+    int const compressionLevel = (params.compressionLevel == 0) ? ZSTD_CLEVEL_DEFAULT : params.compressionLevel;
+    U32 const notificationLevel = params.notificationLevel;
+    /* The final dictionary content must be at least as large as the largest repcode */
+    size_t const minContentSize = (size_t)ZDICT_maxRep(repStartValue);
+    size_t paddingSize;
+
+    /* check conditions */
+    DEBUGLOG(4, "ZDICT_finalizeDictionary");
+    if (dictBufferCapacity < dictContentSize) return ERROR(dstSize_tooSmall);
+    if (dictBufferCapacity < ZDICT_DICTSIZE_MIN) return ERROR(dstSize_tooSmall);
+
+    /* dictionary header */
+    MEM_writeLE32(header, ZSTD_MAGIC_DICTIONARY);
+    {   U64 const randomID = XXH64(customDictContent, dictContentSize, 0);
+        U32 const compliantID = (randomID % ((1U<<31)-32768)) + 32768;
+        U32 const dictID = params.dictID ? params.dictID : compliantID;
+        MEM_writeLE32(header+4, dictID);
+    }
+    hSize = 8;
+
+    /* entropy tables */
+    DISPLAYLEVEL(2, "\r%70s\r", "");   /* clean display line */
+    DISPLAYLEVEL(2, "statistics ... \n");
+    {   size_t const eSize = ZDICT_analyzeEntropy(header+hSize, HBUFFSIZE-hSize,
+                                  compressionLevel,
+                                  samplesBuffer, samplesSizes, nbSamples,
+                                  customDictContent, dictContentSize,
+                                  notificationLevel);
+        if (ZDICT_isError(eSize)) return eSize;
+        hSize += eSize;
+    }
+
+    /* Shrink the content size if it doesn't fit in the buffer */
+    if (hSize + dictContentSize > dictBufferCapacity) {
+        dictContentSize = dictBufferCapacity - hSize;
+    }
+
+    /* Pad the dictionary content with zeros if it is too small */
+    if (dictContentSize < minContentSize) {
+        RETURN_ERROR_IF(hSize + minContentSize > dictBufferCapacity, dstSize_tooSmall,
+                        "dictBufferCapacity too small to fit max repcode");
+        paddingSize = minContentSize - dictContentSize;
+    } else {
+        paddingSize = 0;
+    }
+
+    {
+        size_t const dictSize = hSize + paddingSize + dictContentSize;
+
+        /* The dictionary consists of the header, optional padding, and the content.
+         * The padding comes before the content because the "best" position in the
+         * dictionary is the last byte.
+         */
+        BYTE* const outDictHeader = (BYTE*)dictBuffer;
+        BYTE* const outDictPadding = outDictHeader + hSize;
+        BYTE* const outDictContent = outDictPadding + paddingSize;
+
+        assert(dictSize <= dictBufferCapacity);
+        assert(outDictContent + dictContentSize == (BYTE*)dictBuffer + dictSize);
+
+        /* First copy the customDictContent into its final location.
+         * `customDictContent` and `dictBuffer` may overlap, so we must
+         * do this before any other writes into the output buffer.
+         * Then copy the header & padding into the output buffer.
+         */
+        memmove(outDictContent, customDictContent, dictContentSize);
+        memcpy(outDictHeader, header, hSize);
+        memset(outDictPadding, 0, paddingSize);
+
+        return dictSize;
+    }
+}
+
+
+static size_t ZDICT_addEntropyTablesFromBuffer_advanced(
+        void* dictBuffer, size_t dictContentSize, size_t dictBufferCapacity,
+        const void* samplesBuffer, const size_t* samplesSizes, unsigned nbSamples,
+        ZDICT_params_t params)
+{
+    int const compressionLevel = (params.compressionLevel == 0) ? ZSTD_CLEVEL_DEFAULT : params.compressionLevel;
+    U32 const notificationLevel = params.notificationLevel;
+    size_t hSize = 8;
+
+    /* calculate entropy tables */
+    DISPLAYLEVEL(2, "\r%70s\r", "");   /* clean display line */
+    DISPLAYLEVEL(2, "statistics ... \n");
+    {   size_t const eSize = ZDICT_analyzeEntropy((char*)dictBuffer+hSize, dictBufferCapacity-hSize,
+                                  compressionLevel,
+                                  samplesBuffer, samplesSizes, nbSamples,
+                                  (char*)dictBuffer + dictBufferCapacity - dictContentSize, dictContentSize,
+                                  notificationLevel);
+        if (ZDICT_isError(eSize)) return eSize;
+        hSize += eSize;
+    }
+
+    /* add dictionary header (after entropy tables) */
+    MEM_writeLE32(dictBuffer, ZSTD_MAGIC_DICTIONARY);
+    {   U64 const randomID = XXH64((char*)dictBuffer + dictBufferCapacity - dictContentSize, dictContentSize, 0);
+        U32 const compliantID = (randomID % ((1U<<31)-32768)) + 32768;
+        U32 const dictID = params.dictID ? params.dictID : compliantID;
+        MEM_writeLE32((char*)dictBuffer+4, dictID);
+    }
+
+    if (hSize + dictContentSize < dictBufferCapacity)
+        memmove((char*)dictBuffer + hSize, (char*)dictBuffer + dictBufferCapacity - dictContentSize, dictContentSize);
+    return MIN(dictBufferCapacity, hSize+dictContentSize);
+}
+
+/*! ZDICT_trainFromBuffer_unsafe_legacy() :
+*   Warning : `samplesBuffer` must be followed by noisy guard band !!!
+*   @return : size of dictionary, or an error code which can be tested with ZDICT_isError()
+*/
+static size_t ZDICT_trainFromBuffer_unsafe_legacy(
+                            void* dictBuffer, size_t maxDictSize,
+                            const void* samplesBuffer, const size_t* samplesSizes, unsigned nbSamples,
+                            ZDICT_legacy_params_t params)
+{
+    U32 const dictListSize = MAX(MAX(DICTLISTSIZE_DEFAULT, nbSamples), (U32)(maxDictSize/16));
+    dictItem* const dictList = (dictItem*)malloc(dictListSize * sizeof(*dictList));
+    unsigned const selectivity = params.selectivityLevel == 0 ? g_selectivity_default : params.selectivityLevel;
+    unsigned const minRep = (selectivity > 30) ? MINRATIO : nbSamples >> selectivity;
+    size_t const targetDictSize = maxDictSize;
+    size_t const samplesBuffSize = ZDICT_totalSampleSize(samplesSizes, nbSamples);
+    size_t dictSize = 0;
+    U32 const notificationLevel = params.zParams.notificationLevel;
+
+    /* checks */
+    if (!dictList) return ERROR(memory_allocation);
+    if (maxDictSize < ZDICT_DICTSIZE_MIN) { free(dictList); return ERROR(dstSize_tooSmall); }   /* requested dictionary size is too small */
+    if (samplesBuffSize < ZDICT_MIN_SAMPLES_SIZE) { free(dictList); return ERROR(dictionaryCreation_failed); }   /* not enough source to create dictionary */
+
+    /* init */
+    ZDICT_initDictItem(dictList);
+
+    /* build dictionary */
+    ZDICT_trainBuffer_legacy(dictList, dictListSize,
+                       samplesBuffer, samplesBuffSize,
+                       samplesSizes, nbSamples,
+                       minRep, notificationLevel);
+
+    /* display best matches */
+    if (params.zParams.notificationLevel>= 3) {
+        unsigned const nb = MIN(25, dictList[0].pos);
+        unsigned const dictContentSize = ZDICT_dictSize(dictList);
+        unsigned u;
+        DISPLAYLEVEL(3, "\n %u segments found, of total size %u \n", (unsigned)dictList[0].pos-1, dictContentSize);
+        DISPLAYLEVEL(3, "list %u best segments \n", nb-1);
+        for (u=1; u<nb; u++) {
+            unsigned const pos = dictList[u].pos;
+            unsigned const length = dictList[u].length;
+            U32 const printedLength = MIN(40, length);
+            if ((pos > samplesBuffSize) || ((pos + length) > samplesBuffSize)) {
+                free(dictList);
+                return ERROR(GENERIC);   /* should never happen */
+            }
+            DISPLAYLEVEL(3, "%3u:%3u bytes at pos %8u, savings %7u bytes |",
+                         u, length, pos, (unsigned)dictList[u].savings);
+            ZDICT_printHex((const char*)samplesBuffer+pos, printedLength);
+            DISPLAYLEVEL(3, "| \n");
+    }   }
+
+
+    /* create dictionary */
+    {   unsigned dictContentSize = ZDICT_dictSize(dictList);
+        if (dictContentSize < ZDICT_CONTENTSIZE_MIN) { free(dictList); return ERROR(dictionaryCreation_failed); }   /* dictionary content too small */
+        if (dictContentSize < targetDictSize/4) {
+            DISPLAYLEVEL(2, "!  warning : selected content significantly smaller than requested (%u < %u) \n", dictContentSize, (unsigned)maxDictSize);
+            if (samplesBuffSize < 10 * targetDictSize)
+                DISPLAYLEVEL(2, "!  consider increasing the number of samples (total size : %u MB)\n", (unsigned)(samplesBuffSize>>20));
+            if (minRep > MINRATIO) {
+                DISPLAYLEVEL(2, "!  consider increasing selectivity to produce larger dictionary (-s%u) \n", selectivity+1);
+                DISPLAYLEVEL(2, "!  note : larger dictionaries are not necessarily better, test its efficiency on samples \n");
+            }
+        }
+
+        if ((dictContentSize > targetDictSize*3) && (nbSamples > 2*MINRATIO) && (selectivity>1)) {
+            unsigned proposedSelectivity = selectivity-1;
+            while ((nbSamples >> proposedSelectivity) <= MINRATIO) { proposedSelectivity--; }
+            DISPLAYLEVEL(2, "!  note : calculated dictionary significantly larger than requested (%u > %u) \n", dictContentSize, (unsigned)maxDictSize);
+            DISPLAYLEVEL(2, "!  consider increasing dictionary size, or produce denser dictionary (-s%u) \n", proposedSelectivity);
+            DISPLAYLEVEL(2, "!  always test dictionary efficiency on real samples \n");
+        }
+
+        /* limit dictionary size */
+        {   U32 const max = dictList->pos;   /* convention : nb of useful elts within dictList */
+            U32 currentSize = 0;
+            U32 n; for (n=1; n<max; n++) {
+                currentSize += dictList[n].length;
+                if (currentSize > targetDictSize) { currentSize -= dictList[n].length; break; }
+            }
+            dictList->pos = n;
+            dictContentSize = currentSize;
+        }
+
+        /* build dict content */
+        {   U32 u;
+            BYTE* ptr = (BYTE*)dictBuffer + maxDictSize;
+            for (u=1; u<dictList->pos; u++) {
+                U32 l = dictList[u].length;
+                ptr -= l;
+                if (ptr<(BYTE*)dictBuffer) { free(dictList); return ERROR(GENERIC); }   /* should not happen */
+                memcpy(ptr, (const char*)samplesBuffer+dictList[u].pos, l);
+        }   }
+
+        dictSize = ZDICT_addEntropyTablesFromBuffer_advanced(dictBuffer, dictContentSize, maxDictSize,
+                                                             samplesBuffer, samplesSizes, nbSamples,
+                                                             params.zParams);
+    }
+
+    /* clean up */
+    free(dictList);
+    return dictSize;
+}
+
+
+/* ZDICT_trainFromBuffer_legacy() :
+ * issue : samplesBuffer need to be followed by a noisy guard band.
+ * work around : duplicate the buffer, and add the noise */
+size_t ZDICT_trainFromBuffer_legacy(void* dictBuffer, size_t dictBufferCapacity,
+                              const void* samplesBuffer, const size_t* samplesSizes, unsigned nbSamples,
+                              ZDICT_legacy_params_t params)
+{
+    size_t result;
+    void* newBuff;
+    size_t const sBuffSize = ZDICT_totalSampleSize(samplesSizes, nbSamples);
+    if (sBuffSize < ZDICT_MIN_SAMPLES_SIZE) return 0;   /* not enough content => no dictionary */
+
+    newBuff = malloc(sBuffSize + NOISELENGTH);
+    if (!newBuff) return ERROR(memory_allocation);
+
+    memcpy(newBuff, samplesBuffer, sBuffSize);
+    ZDICT_fillNoise((char*)newBuff + sBuffSize, NOISELENGTH);   /* guard band, for end of buffer condition */
+
+    result =
+        ZDICT_trainFromBuffer_unsafe_legacy(dictBuffer, dictBufferCapacity, newBuff,
+                                            samplesSizes, nbSamples, params);
+    free(newBuff);
+    return result;
+}
+
+
+size_t ZDICT_trainFromBuffer(void* dictBuffer, size_t dictBufferCapacity,
+                             const void* samplesBuffer, const size_t* samplesSizes, unsigned nbSamples)
+{
+    ZDICT_fastCover_params_t params;
+    DEBUGLOG(3, "ZDICT_trainFromBuffer");
+    memset(&params, 0, sizeof(params));
+    params.d = 8;
+    params.steps = 4;
+    /* Use default level since no compression level information is available */
+    params.zParams.compressionLevel = ZSTD_CLEVEL_DEFAULT;
+#if defined(DEBUGLEVEL) && (DEBUGLEVEL>=1)
+    params.zParams.notificationLevel = DEBUGLEVEL;
+#endif
+    return ZDICT_optimizeTrainFromBuffer_fastCover(dictBuffer, dictBufferCapacity,
+                                               samplesBuffer, samplesSizes, nbSamples,
+                                               &params);
+}
+
+size_t ZDICT_addEntropyTablesFromBuffer(void* dictBuffer, size_t dictContentSize, size_t dictBufferCapacity,
+                                  const void* samplesBuffer, const size_t* samplesSizes, unsigned nbSamples)
+{
+    ZDICT_params_t params;
+    memset(&params, 0, sizeof(params));
+    return ZDICT_addEntropyTablesFromBuffer_advanced(dictBuffer, dictContentSize, dictBufferCapacity,
+                                                     samplesBuffer, samplesSizes, nbSamples,
+                                                     params);
+}
diff --git a/src/3rdparty/zstd/src/zdict.h b/src/3rdparty/zstd/src/zdict.h
new file mode 100644
index 0000000000..2268f948a5
--- /dev/null
+++ b/src/3rdparty/zstd/src/zdict.h
@@ -0,0 +1,474 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#ifndef ZSTD_ZDICT_H
+#define ZSTD_ZDICT_H
+
+/*======  Dependencies  ======*/
+#include <stddef.h>  /* size_t */
+
+
+/* =====   ZDICTLIB_API : control library symbols visibility   ===== */
+#ifndef ZDICTLIB_VISIBLE
+   /* Backwards compatibility with old macro name */
+#  ifdef ZDICTLIB_VISIBILITY
+#    define ZDICTLIB_VISIBLE ZDICTLIB_VISIBILITY
+#  elif defined(__GNUC__) && (__GNUC__ >= 4) && !defined(__MINGW32__)
+#    define ZDICTLIB_VISIBLE __attribute__ ((visibility ("default")))
+#  else
+#    define ZDICTLIB_VISIBLE
+#  endif
+#endif
+
+#ifndef ZDICTLIB_HIDDEN
+#  if defined(__GNUC__) && (__GNUC__ >= 4) && !defined(__MINGW32__)
+#    define ZDICTLIB_HIDDEN __attribute__ ((visibility ("hidden")))
+#  else
+#    define ZDICTLIB_HIDDEN
+#  endif
+#endif
+
+#if defined(ZSTD_DLL_EXPORT) && (ZSTD_DLL_EXPORT==1)
+#  define ZDICTLIB_API __declspec(dllexport) ZDICTLIB_VISIBLE
+#elif defined(ZSTD_DLL_IMPORT) && (ZSTD_DLL_IMPORT==1)
+#  define ZDICTLIB_API __declspec(dllimport) ZDICTLIB_VISIBLE /* It isn't required but allows to generate better code, saving a function pointer load from the IAT and an indirect jump.*/
+#else
+#  define ZDICTLIB_API ZDICTLIB_VISIBLE
+#endif
+
+/*******************************************************************************
+ * Zstd dictionary builder
+ *
+ * FAQ
+ * ===
+ * Why should I use a dictionary?
+ * ------------------------------
+ *
+ * Zstd can use dictionaries to improve compression ratio of small data.
+ * Traditionally small files don't compress well because there is very little
+ * repetition in a single sample, since it is small. But, if you are compressing
+ * many similar files, like a bunch of JSON records that share the same
+ * structure, you can train a dictionary on ahead of time on some samples of
+ * these files. Then, zstd can use the dictionary to find repetitions that are
+ * present across samples. This can vastly improve compression ratio.
+ *
+ * When is a dictionary useful?
+ * ----------------------------
+ *
+ * Dictionaries are useful when compressing many small files that are similar.
+ * The larger a file is, the less benefit a dictionary will have. Generally,
+ * we don't expect dictionary compression to be effective past 100KB. And the
+ * smaller a file is, the more we would expect the dictionary to help.
+ *
+ * How do I use a dictionary?
+ * --------------------------
+ *
+ * Simply pass the dictionary to the zstd compressor with
+ * `ZSTD_CCtx_loadDictionary()`. The same dictionary must then be passed to
+ * the decompressor, using `ZSTD_DCtx_loadDictionary()`. There are other
+ * more advanced functions that allow selecting some options, see zstd.h for
+ * complete documentation.
+ *
+ * What is a zstd dictionary?
+ * --------------------------
+ *
+ * A zstd dictionary has two pieces: Its header, and its content. The header
+ * contains a magic number, the dictionary ID, and entropy tables. These
+ * entropy tables allow zstd to save on header costs in the compressed file,
+ * which really matters for small data. The content is just bytes, which are
+ * repeated content that is common across many samples.
+ *
+ * What is a raw content dictionary?
+ * ---------------------------------
+ *
+ * A raw content dictionary is just bytes. It doesn't have a zstd dictionary
+ * header, a dictionary ID, or entropy tables. Any buffer is a valid raw
+ * content dictionary.
+ *
+ * How do I train a dictionary?
+ * ----------------------------
+ *
+ * Gather samples from your use case. These samples should be similar to each
+ * other. If you have several use cases, you could try to train one dictionary
+ * per use case.
+ *
+ * Pass those samples to `ZDICT_trainFromBuffer()` and that will train your
+ * dictionary. There are a few advanced versions of this function, but this
+ * is a great starting point. If you want to further tune your dictionary
+ * you could try `ZDICT_optimizeTrainFromBuffer_cover()`. If that is too slow
+ * you can try `ZDICT_optimizeTrainFromBuffer_fastCover()`.
+ *
+ * If the dictionary training function fails, that is likely because you
+ * either passed too few samples, or a dictionary would not be effective
+ * for your data. Look at the messages that the dictionary trainer printed,
+ * if it doesn't say too few samples, then a dictionary would not be effective.
+ *
+ * How large should my dictionary be?
+ * ----------------------------------
+ *
+ * A reasonable dictionary size, the `dictBufferCapacity`, is about 100KB.
+ * The zstd CLI defaults to a 110KB dictionary. You likely don't need a
+ * dictionary larger than that. But, most use cases can get away with a
+ * smaller dictionary. The advanced dictionary builders can automatically
+ * shrink the dictionary for you, and select the smallest size that doesn't
+ * hurt compression ratio too much. See the `shrinkDict` parameter.
+ * A smaller dictionary can save memory, and potentially speed up
+ * compression.
+ *
+ * How many samples should I provide to the dictionary builder?
+ * ------------------------------------------------------------
+ *
+ * We generally recommend passing ~100x the size of the dictionary
+ * in samples. A few thousand should suffice. Having too few samples
+ * can hurt the dictionaries effectiveness. Having more samples will
+ * only improve the dictionaries effectiveness. But having too many
+ * samples can slow down the dictionary builder.
+ *
+ * How do I determine if a dictionary will be effective?
+ * -----------------------------------------------------
+ *
+ * Simply train a dictionary and try it out. You can use zstd's built in
+ * benchmarking tool to test the dictionary effectiveness.
+ *
+ *   # Benchmark levels 1-3 without a dictionary
+ *   zstd -b1e3 -r /path/to/my/files
+ *   # Benchmark levels 1-3 with a dictionary
+ *   zstd -b1e3 -r /path/to/my/files -D /path/to/my/dictionary
+ *
+ * When should I retrain a dictionary?
+ * -----------------------------------
+ *
+ * You should retrain a dictionary when its effectiveness drops. Dictionary
+ * effectiveness drops as the data you are compressing changes. Generally, we do
+ * expect dictionaries to "decay" over time, as your data changes, but the rate
+ * at which they decay depends on your use case. Internally, we regularly
+ * retrain dictionaries, and if the new dictionary performs significantly
+ * better than the old dictionary, we will ship the new dictionary.
+ *
+ * I have a raw content dictionary, how do I turn it into a zstd dictionary?
+ * -------------------------------------------------------------------------
+ *
+ * If you have a raw content dictionary, e.g. by manually constructing it, or
+ * using a third-party dictionary builder, you can turn it into a zstd
+ * dictionary by using `ZDICT_finalizeDictionary()`. You'll also have to
+ * provide some samples of the data. It will add the zstd header to the
+ * raw content, which contains a dictionary ID and entropy tables, which
+ * will improve compression ratio, and allow zstd to write the dictionary ID
+ * into the frame, if you so choose.
+ *
+ * Do I have to use zstd's dictionary builder?
+ * -------------------------------------------
+ *
+ * No! You can construct dictionary content however you please, it is just
+ * bytes. It will always be valid as a raw content dictionary. If you want
+ * a zstd dictionary, which can improve compression ratio, use
+ * `ZDICT_finalizeDictionary()`.
+ *
+ * What is the attack surface of a zstd dictionary?
+ * ------------------------------------------------
+ *
+ * Zstd is heavily fuzz tested, including loading fuzzed dictionaries, so
+ * zstd should never crash, or access out-of-bounds memory no matter what
+ * the dictionary is. However, if an attacker can control the dictionary
+ * during decompression, they can cause zstd to generate arbitrary bytes,
+ * just like if they controlled the compressed data.
+ *
+ ******************************************************************************/
+
+
+/*! ZDICT_trainFromBuffer():
+ *  Train a dictionary from an array of samples.
+ *  Redirect towards ZDICT_optimizeTrainFromBuffer_fastCover() single-threaded, with d=8, steps=4,
+ *  f=20, and accel=1.
+ *  Samples must be stored concatenated in a single flat buffer `samplesBuffer`,
+ *  supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order.
+ *  The resulting dictionary will be saved into `dictBuffer`.
+ * @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)
+ *          or an error code, which can be tested with ZDICT_isError().
+ *  Note:  Dictionary training will fail if there are not enough samples to construct a
+ *         dictionary, or if most of the samples are too small (< 8 bytes being the lower limit).
+ *         If dictionary training fails, you should use zstd without a dictionary, as the dictionary
+ *         would've been ineffective anyways. If you believe your samples would benefit from a dictionary
+ *         please open an issue with details, and we can look into it.
+ *  Note: ZDICT_trainFromBuffer()'s memory usage is about 6 MB.
+ *  Tips: In general, a reasonable dictionary has a size of ~ 100 KB.
+ *        It's possible to select smaller or larger size, just by specifying `dictBufferCapacity`.
+ *        In general, it's recommended to provide a few thousands samples, though this can vary a lot.
+ *        It's recommended that total size of all samples be about ~x100 times the target size of dictionary.
+ */
+ZDICTLIB_API size_t ZDICT_trainFromBuffer(void* dictBuffer, size_t dictBufferCapacity,
+                                    const void* samplesBuffer,
+                                    const size_t* samplesSizes, unsigned nbSamples);
+
+typedef struct {
+    int      compressionLevel;   /**< optimize for a specific zstd compression level; 0 means default */
+    unsigned notificationLevel;  /**< Write log to stderr; 0 = none (default); 1 = errors; 2 = progression; 3 = details; 4 = debug; */
+    unsigned dictID;             /**< force dictID value; 0 means auto mode (32-bits random value)
+                                  *   NOTE: The zstd format reserves some dictionary IDs for future use.
+                                  *         You may use them in private settings, but be warned that they
+                                  *         may be used by zstd in a public dictionary registry in the future.
+                                  *         These dictionary IDs are:
+                                  *           - low range  : <= 32767
+                                  *           - high range : >= (2^31)
+                                  */
+} ZDICT_params_t;
+
+/*! ZDICT_finalizeDictionary():
+ * Given a custom content as a basis for dictionary, and a set of samples,
+ * finalize dictionary by adding headers and statistics according to the zstd
+ * dictionary format.
+ *
+ * Samples must be stored concatenated in a flat buffer `samplesBuffer`,
+ * supplied with an array of sizes `samplesSizes`, providing the size of each
+ * sample in order. The samples are used to construct the statistics, so they
+ * should be representative of what you will compress with this dictionary.
+ *
+ * The compression level can be set in `parameters`. You should pass the
+ * compression level you expect to use in production. The statistics for each
+ * compression level differ, so tuning the dictionary for the compression level
+ * can help quite a bit.
+ *
+ * You can set an explicit dictionary ID in `parameters`, or allow us to pick
+ * a random dictionary ID for you, but we can't guarantee no collisions.
+ *
+ * The dstDictBuffer and the dictContent may overlap, and the content will be
+ * appended to the end of the header. If the header + the content doesn't fit in
+ * maxDictSize the beginning of the content is truncated to make room, since it
+ * is presumed that the most profitable content is at the end of the dictionary,
+ * since that is the cheapest to reference.
+ *
+ * `maxDictSize` must be >= max(dictContentSize, ZSTD_DICTSIZE_MIN).
+ *
+ * @return: size of dictionary stored into `dstDictBuffer` (<= `maxDictSize`),
+ *          or an error code, which can be tested by ZDICT_isError().
+ * Note: ZDICT_finalizeDictionary() will push notifications into stderr if
+ *       instructed to, using notificationLevel>0.
+ * NOTE: This function currently may fail in several edge cases including:
+ *         * Not enough samples
+ *         * Samples are uncompressible
+ *         * Samples are all exactly the same
+ */
+ZDICTLIB_API size_t ZDICT_finalizeDictionary(void* dstDictBuffer, size_t maxDictSize,
+                                const void* dictContent, size_t dictContentSize,
+                                const void* samplesBuffer, const size_t* samplesSizes, unsigned nbSamples,
+                                ZDICT_params_t parameters);
+
+
+/*======   Helper functions   ======*/
+ZDICTLIB_API unsigned ZDICT_getDictID(const void* dictBuffer, size_t dictSize);  /**< extracts dictID; @return zero if error (not a valid dictionary) */
+ZDICTLIB_API size_t ZDICT_getDictHeaderSize(const void* dictBuffer, size_t dictSize);  /* returns dict header size; returns a ZSTD error code on failure */
+ZDICTLIB_API unsigned ZDICT_isError(size_t errorCode);
+ZDICTLIB_API const char* ZDICT_getErrorName(size_t errorCode);
+
+#endif   /* ZSTD_ZDICT_H */
+
+#if defined(ZDICT_STATIC_LINKING_ONLY) && !defined(ZSTD_ZDICT_H_STATIC)
+#define ZSTD_ZDICT_H_STATIC
+
+/* This can be overridden externally to hide static symbols. */
+#ifndef ZDICTLIB_STATIC_API
+#  if defined(ZSTD_DLL_EXPORT) && (ZSTD_DLL_EXPORT==1)
+#    define ZDICTLIB_STATIC_API __declspec(dllexport) ZDICTLIB_VISIBLE
+#  elif defined(ZSTD_DLL_IMPORT) && (ZSTD_DLL_IMPORT==1)
+#    define ZDICTLIB_STATIC_API __declspec(dllimport) ZDICTLIB_VISIBLE
+#  else
+#    define ZDICTLIB_STATIC_API ZDICTLIB_VISIBLE
+#  endif
+#endif
+
+/* ====================================================================================
+ * The definitions in this section are considered experimental.
+ * They should never be used with a dynamic library, as they may change in the future.
+ * They are provided for advanced usages.
+ * Use them only in association with static linking.
+ * ==================================================================================== */
+
+#define ZDICT_DICTSIZE_MIN    256
+/* Deprecated: Remove in v1.6.0 */
+#define ZDICT_CONTENTSIZE_MIN 128
+
+/*! ZDICT_cover_params_t:
+ *  k and d are the only required parameters.
+ *  For others, value 0 means default.
+ */
+typedef struct {
+    unsigned k;                  /* Segment size : constraint: 0 < k : Reasonable range [16, 2048+] */
+    unsigned d;                  /* dmer size : constraint: 0 < d <= k : Reasonable range [6, 16] */
+    unsigned steps;              /* Number of steps : Only used for optimization : 0 means default (40) : Higher means more parameters checked */
+    unsigned nbThreads;          /* Number of threads : constraint: 0 < nbThreads : 1 means single-threaded : Only used for optimization : Ignored if ZSTD_MULTITHREAD is not defined */
+    double splitPoint;           /* Percentage of samples used for training: Only used for optimization : the first nbSamples * splitPoint samples will be used to training, the last nbSamples * (1 - splitPoint) samples will be used for testing, 0 means default (1.0), 1.0 when all samples are used for both training and testing */
+    unsigned shrinkDict;         /* Train dictionaries to shrink in size starting from the minimum size and selects the smallest dictionary that is shrinkDictMaxRegression% worse than the largest dictionary. 0 means no shrinking and 1 means shrinking  */
+    unsigned shrinkDictMaxRegression; /* Sets shrinkDictMaxRegression so that a smaller dictionary can be at worse shrinkDictMaxRegression% worse than the max dict size dictionary. */
+    ZDICT_params_t zParams;
+} ZDICT_cover_params_t;
+
+typedef struct {
+    unsigned k;                  /* Segment size : constraint: 0 < k : Reasonable range [16, 2048+] */
+    unsigned d;                  /* dmer size : constraint: 0 < d <= k : Reasonable range [6, 16] */
+    unsigned f;                  /* log of size of frequency array : constraint: 0 < f <= 31 : 1 means default(20)*/
+    unsigned steps;              /* Number of steps : Only used for optimization : 0 means default (40) : Higher means more parameters checked */
+    unsigned nbThreads;          /* Number of threads : constraint: 0 < nbThreads : 1 means single-threaded : Only used for optimization : Ignored if ZSTD_MULTITHREAD is not defined */
+    double splitPoint;           /* Percentage of samples used for training: Only used for optimization : the first nbSamples * splitPoint samples will be used to training, the last nbSamples * (1 - splitPoint) samples will be used for testing, 0 means default (0.75), 1.0 when all samples are used for both training and testing */
+    unsigned accel;              /* Acceleration level: constraint: 0 < accel <= 10, higher means faster and less accurate, 0 means default(1) */
+    unsigned shrinkDict;         /* Train dictionaries to shrink in size starting from the minimum size and selects the smallest dictionary that is shrinkDictMaxRegression% worse than the largest dictionary. 0 means no shrinking and 1 means shrinking  */
+    unsigned shrinkDictMaxRegression; /* Sets shrinkDictMaxRegression so that a smaller dictionary can be at worse shrinkDictMaxRegression% worse than the max dict size dictionary. */
+
+    ZDICT_params_t zParams;
+} ZDICT_fastCover_params_t;
+
+/*! ZDICT_trainFromBuffer_cover():
+ *  Train a dictionary from an array of samples using the COVER algorithm.
+ *  Samples must be stored concatenated in a single flat buffer `samplesBuffer`,
+ *  supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order.
+ *  The resulting dictionary will be saved into `dictBuffer`.
+ * @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)
+ *          or an error code, which can be tested with ZDICT_isError().
+ *          See ZDICT_trainFromBuffer() for details on failure modes.
+ *  Note: ZDICT_trainFromBuffer_cover() requires about 9 bytes of memory for each input byte.
+ *  Tips: In general, a reasonable dictionary has a size of ~ 100 KB.
+ *        It's possible to select smaller or larger size, just by specifying `dictBufferCapacity`.
+ *        In general, it's recommended to provide a few thousands samples, though this can vary a lot.
+ *        It's recommended that total size of all samples be about ~x100 times the target size of dictionary.
+ */
+ZDICTLIB_STATIC_API size_t ZDICT_trainFromBuffer_cover(
+          void *dictBuffer, size_t dictBufferCapacity,
+    const void *samplesBuffer, const size_t *samplesSizes, unsigned nbSamples,
+          ZDICT_cover_params_t parameters);
+
+/*! ZDICT_optimizeTrainFromBuffer_cover():
+ * The same requirements as above hold for all the parameters except `parameters`.
+ * This function tries many parameter combinations and picks the best parameters.
+ * `*parameters` is filled with the best parameters found,
+ * dictionary constructed with those parameters is stored in `dictBuffer`.
+ *
+ * All of the parameters d, k, steps are optional.
+ * If d is non-zero then we don't check multiple values of d, otherwise we check d = {6, 8}.
+ * if steps is zero it defaults to its default value.
+ * If k is non-zero then we don't check multiple values of k, otherwise we check steps values in [50, 2000].
+ *
+ * @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)
+ *          or an error code, which can be tested with ZDICT_isError().
+ *          On success `*parameters` contains the parameters selected.
+ *          See ZDICT_trainFromBuffer() for details on failure modes.
+ * Note: ZDICT_optimizeTrainFromBuffer_cover() requires about 8 bytes of memory for each input byte and additionally another 5 bytes of memory for each byte of memory for each thread.
+ */
+ZDICTLIB_STATIC_API size_t ZDICT_optimizeTrainFromBuffer_cover(
+          void* dictBuffer, size_t dictBufferCapacity,
+    const void* samplesBuffer, const size_t* samplesSizes, unsigned nbSamples,
+          ZDICT_cover_params_t* parameters);
+
+/*! ZDICT_trainFromBuffer_fastCover():
+ *  Train a dictionary from an array of samples using a modified version of COVER algorithm.
+ *  Samples must be stored concatenated in a single flat buffer `samplesBuffer`,
+ *  supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order.
+ *  d and k are required.
+ *  All other parameters are optional, will use default values if not provided
+ *  The resulting dictionary will be saved into `dictBuffer`.
+ * @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)
+ *          or an error code, which can be tested with ZDICT_isError().
+ *          See ZDICT_trainFromBuffer() for details on failure modes.
+ *  Note: ZDICT_trainFromBuffer_fastCover() requires 6 * 2^f bytes of memory.
+ *  Tips: In general, a reasonable dictionary has a size of ~ 100 KB.
+ *        It's possible to select smaller or larger size, just by specifying `dictBufferCapacity`.
+ *        In general, it's recommended to provide a few thousands samples, though this can vary a lot.
+ *        It's recommended that total size of all samples be about ~x100 times the target size of dictionary.
+ */
+ZDICTLIB_STATIC_API size_t ZDICT_trainFromBuffer_fastCover(void *dictBuffer,
+                    size_t dictBufferCapacity, const void *samplesBuffer,
+                    const size_t *samplesSizes, unsigned nbSamples,
+                    ZDICT_fastCover_params_t parameters);
+
+/*! ZDICT_optimizeTrainFromBuffer_fastCover():
+ * The same requirements as above hold for all the parameters except `parameters`.
+ * This function tries many parameter combinations (specifically, k and d combinations)
+ * and picks the best parameters. `*parameters` is filled with the best parameters found,
+ * dictionary constructed with those parameters is stored in `dictBuffer`.
+ * All of the parameters d, k, steps, f, and accel are optional.
+ * If d is non-zero then we don't check multiple values of d, otherwise we check d = {6, 8}.
+ * if steps is zero it defaults to its default value.
+ * If k is non-zero then we don't check multiple values of k, otherwise we check steps values in [50, 2000].
+ * If f is zero, default value of 20 is used.
+ * If accel is zero, default value of 1 is used.
+ *
+ * @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)
+ *          or an error code, which can be tested with ZDICT_isError().
+ *          On success `*parameters` contains the parameters selected.
+ *          See ZDICT_trainFromBuffer() for details on failure modes.
+ * Note: ZDICT_optimizeTrainFromBuffer_fastCover() requires about 6 * 2^f bytes of memory for each thread.
+ */
+ZDICTLIB_STATIC_API size_t ZDICT_optimizeTrainFromBuffer_fastCover(void* dictBuffer,
+                    size_t dictBufferCapacity, const void* samplesBuffer,
+                    const size_t* samplesSizes, unsigned nbSamples,
+                    ZDICT_fastCover_params_t* parameters);
+
+typedef struct {
+    unsigned selectivityLevel;   /* 0 means default; larger => select more => larger dictionary */
+    ZDICT_params_t zParams;
+} ZDICT_legacy_params_t;
+
+/*! ZDICT_trainFromBuffer_legacy():
+ *  Train a dictionary from an array of samples.
+ *  Samples must be stored concatenated in a single flat buffer `samplesBuffer`,
+ *  supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order.
+ *  The resulting dictionary will be saved into `dictBuffer`.
+ * `parameters` is optional and can be provided with values set to 0 to mean "default".
+ * @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)
+ *          or an error code, which can be tested with ZDICT_isError().
+ *          See ZDICT_trainFromBuffer() for details on failure modes.
+ *  Tips: In general, a reasonable dictionary has a size of ~ 100 KB.
+ *        It's possible to select smaller or larger size, just by specifying `dictBufferCapacity`.
+ *        In general, it's recommended to provide a few thousands samples, though this can vary a lot.
+ *        It's recommended that total size of all samples be about ~x100 times the target size of dictionary.
+ *  Note: ZDICT_trainFromBuffer_legacy() will send notifications into stderr if instructed to, using notificationLevel>0.
+ */
+ZDICTLIB_STATIC_API size_t ZDICT_trainFromBuffer_legacy(
+    void* dictBuffer, size_t dictBufferCapacity,
+    const void* samplesBuffer, const size_t* samplesSizes, unsigned nbSamples,
+    ZDICT_legacy_params_t parameters);
+
+
+/* Deprecation warnings */
+/* It is generally possible to disable deprecation warnings from compiler,
+   for example with -Wno-deprecated-declarations for gcc
+   or _CRT_SECURE_NO_WARNINGS in Visual.
+   Otherwise, it's also possible to manually define ZDICT_DISABLE_DEPRECATE_WARNINGS */
+#ifdef ZDICT_DISABLE_DEPRECATE_WARNINGS
+#  define ZDICT_DEPRECATED(message) /* disable deprecation warnings */
+#else
+#  define ZDICT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
+#  if defined (__cplusplus) && (__cplusplus >= 201402) /* C++14 or greater */
+#    define ZDICT_DEPRECATED(message) [[deprecated(message)]]
+#  elif defined(__clang__) || (ZDICT_GCC_VERSION >= 405)
+#    define ZDICT_DEPRECATED(message) __attribute__((deprecated(message)))
+#  elif (ZDICT_GCC_VERSION >= 301)
+#    define ZDICT_DEPRECATED(message) __attribute__((deprecated))
+#  elif defined(_MSC_VER)
+#    define ZDICT_DEPRECATED(message) __declspec(deprecated(message))
+#  else
+#    pragma message("WARNING: You need to implement ZDICT_DEPRECATED for this compiler")
+#    define ZDICT_DEPRECATED(message)
+#  endif
+#endif /* ZDICT_DISABLE_DEPRECATE_WARNINGS */
+
+ZDICT_DEPRECATED("use ZDICT_finalizeDictionary() instead")
+ZDICTLIB_STATIC_API
+size_t ZDICT_addEntropyTablesFromBuffer(void* dictBuffer, size_t dictContentSize, size_t dictBufferCapacity,
+                                  const void* samplesBuffer, const size_t* samplesSizes, unsigned nbSamples);
+
+
+#endif   /* ZSTD_ZDICT_H_STATIC */
+
+#if defined (__cplusplus)
+}
+#endif
diff --git a/src/3rdparty/zstd/src/zstd.h b/src/3rdparty/zstd/src/zstd.h
new file mode 100644
index 0000000000..e5c3f8b68b
--- /dev/null
+++ b/src/3rdparty/zstd/src/zstd.h
@@ -0,0 +1,3020 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#ifndef ZSTD_H_235446
+#define ZSTD_H_235446
+
+/* ======   Dependencies   ======*/
+#include <limits.h>   /* INT_MAX */
+#include <stddef.h>   /* size_t */
+
+
+/* =====   ZSTDLIB_API : control library symbols visibility   ===== */
+#ifndef ZSTDLIB_VISIBLE
+   /* Backwards compatibility with old macro name */
+#  ifdef ZSTDLIB_VISIBILITY
+#    define ZSTDLIB_VISIBLE ZSTDLIB_VISIBILITY
+#  elif defined(__GNUC__) && (__GNUC__ >= 4) && !defined(__MINGW32__)
+#    define ZSTDLIB_VISIBLE __attribute__ ((visibility ("default")))
+#  else
+#    define ZSTDLIB_VISIBLE
+#  endif
+#endif
+
+#ifndef ZSTDLIB_HIDDEN
+#  if defined(__GNUC__) && (__GNUC__ >= 4) && !defined(__MINGW32__)
+#    define ZSTDLIB_HIDDEN __attribute__ ((visibility ("hidden")))
+#  else
+#    define ZSTDLIB_HIDDEN
+#  endif
+#endif
+
+#if defined(ZSTD_DLL_EXPORT) && (ZSTD_DLL_EXPORT==1)
+#  define ZSTDLIB_API __declspec(dllexport) ZSTDLIB_VISIBLE
+#elif defined(ZSTD_DLL_IMPORT) && (ZSTD_DLL_IMPORT==1)
+#  define ZSTDLIB_API __declspec(dllimport) ZSTDLIB_VISIBLE /* It isn't required but allows to generate better code, saving a function pointer load from the IAT and an indirect jump.*/
+#else
+#  define ZSTDLIB_API ZSTDLIB_VISIBLE
+#endif
+
+/* Deprecation warnings :
+ * Should these warnings be a problem, it is generally possible to disable them,
+ * typically with -Wno-deprecated-declarations for gcc or _CRT_SECURE_NO_WARNINGS in Visual.
+ * Otherwise, it's also possible to define ZSTD_DISABLE_DEPRECATE_WARNINGS.
+ */
+#ifdef ZSTD_DISABLE_DEPRECATE_WARNINGS
+#  define ZSTD_DEPRECATED(message) /* disable deprecation warnings */
+#else
+#  if defined (__cplusplus) && (__cplusplus >= 201402) /* C++14 or greater */
+#    define ZSTD_DEPRECATED(message) [[deprecated(message)]]
+#  elif (defined(GNUC) && (GNUC > 4 || (GNUC == 4 && GNUC_MINOR >= 5))) || defined(__clang__)
+#    define ZSTD_DEPRECATED(message) __attribute__((deprecated(message)))
+#  elif defined(__GNUC__) && (__GNUC__ >= 3)
+#    define ZSTD_DEPRECATED(message) __attribute__((deprecated))
+#  elif defined(_MSC_VER)
+#    define ZSTD_DEPRECATED(message) __declspec(deprecated(message))
+#  else
+#    pragma message("WARNING: You need to implement ZSTD_DEPRECATED for this compiler")
+#    define ZSTD_DEPRECATED(message)
+#  endif
+#endif /* ZSTD_DISABLE_DEPRECATE_WARNINGS */
+
+
+/*******************************************************************************
+  Introduction
+
+  zstd, short for Zstandard, is a fast lossless compression algorithm, targeting
+  real-time compression scenarios at zlib-level and better compression ratios.
+  The zstd compression library provides in-memory compression and decompression
+  functions.
+
+  The library supports regular compression levels from 1 up to ZSTD_maxCLevel(),
+  which is currently 22. Levels >= 20, labeled `--ultra`, should be used with
+  caution, as they require more memory. The library also offers negative
+  compression levels, which extend the range of speed vs. ratio preferences.
+  The lower the level, the faster the speed (at the cost of compression).
+
+  Compression can be done in:
+    - a single step (described as Simple API)
+    - a single step, reusing a context (described as Explicit context)
+    - unbounded multiple steps (described as Streaming compression)
+
+  The compression ratio achievable on small data can be highly improved using
+  a dictionary. Dictionary compression can be performed in:
+    - a single step (described as Simple dictionary API)
+    - a single step, reusing a dictionary (described as Bulk-processing
+      dictionary API)
+
+  Advanced experimental functions can be accessed using
+  `#define ZSTD_STATIC_LINKING_ONLY` before including zstd.h.
+
+  Advanced experimental APIs should never be used with a dynamically-linked
+  library. They are not "stable"; their definitions or signatures may change in
+  the future. Only static linking is allowed.
+*******************************************************************************/
+
+/*------   Version   ------*/
+#define ZSTD_VERSION_MAJOR    1
+#define ZSTD_VERSION_MINOR    5
+#define ZSTD_VERSION_RELEASE  5
+#define ZSTD_VERSION_NUMBER  (ZSTD_VERSION_MAJOR *100*100 + ZSTD_VERSION_MINOR *100 + ZSTD_VERSION_RELEASE)
+
+/*! ZSTD_versionNumber() :
+ *  Return runtime library version, the value is (MAJOR*100*100 + MINOR*100 + RELEASE). */
+ZSTDLIB_API unsigned ZSTD_versionNumber(void);
+
+#define ZSTD_LIB_VERSION ZSTD_VERSION_MAJOR.ZSTD_VERSION_MINOR.ZSTD_VERSION_RELEASE
+#define ZSTD_QUOTE(str) #str
+#define ZSTD_EXPAND_AND_QUOTE(str) ZSTD_QUOTE(str)
+#define ZSTD_VERSION_STRING ZSTD_EXPAND_AND_QUOTE(ZSTD_LIB_VERSION)
+
+/*! ZSTD_versionString() :
+ *  Return runtime library version, like "1.4.5". Requires v1.3.0+. */
+ZSTDLIB_API const char* ZSTD_versionString(void);
+
+/* *************************************
+ *  Default constant
+ ***************************************/
+#ifndef ZSTD_CLEVEL_DEFAULT
+#  define ZSTD_CLEVEL_DEFAULT 3
+#endif
+
+/* *************************************
+ *  Constants
+ ***************************************/
+
+/* All magic numbers are supposed read/written to/from files/memory using little-endian convention */
+#define ZSTD_MAGICNUMBER            0xFD2FB528    /* valid since v0.8.0 */
+#define ZSTD_MAGIC_DICTIONARY       0xEC30A437    /* valid since v0.7.0 */
+#define ZSTD_MAGIC_SKIPPABLE_START  0x184D2A50    /* all 16 values, from 0x184D2A50 to 0x184D2A5F, signal the beginning of a skippable frame */
+#define ZSTD_MAGIC_SKIPPABLE_MASK   0xFFFFFFF0
+
+#define ZSTD_BLOCKSIZELOG_MAX  17
+#define ZSTD_BLOCKSIZE_MAX     (1<<ZSTD_BLOCKSIZELOG_MAX)
+
+
+/***************************************
+*  Simple API
+***************************************/
+/*! ZSTD_compress() :
+ *  Compresses `src` content as a single zstd compressed frame into already allocated `dst`.
+ *  NOTE: Providing `dstCapacity >= ZSTD_compressBound(srcSize)` guarantees that zstd will have
+ *        enough space to successfully compress the data.
+ *  @return : compressed size written into `dst` (<= `dstCapacity),
+ *            or an error code if it fails (which can be tested using ZSTD_isError()). */
+ZSTDLIB_API size_t ZSTD_compress( void* dst, size_t dstCapacity,
+                            const void* src, size_t srcSize,
+                                  int compressionLevel);
+
+/*! ZSTD_decompress() :
+ *  `compressedSize` : must be the _exact_ size of some number of compressed and/or skippable frames.
+ *  `dstCapacity` is an upper bound of originalSize to regenerate.
+ *  If user cannot imply a maximum upper bound, it's better to use streaming mode to decompress data.
+ *  @return : the number of bytes decompressed into `dst` (<= `dstCapacity`),
+ *            or an errorCode if it fails (which can be tested using ZSTD_isError()). */
+ZSTDLIB_API size_t ZSTD_decompress( void* dst, size_t dstCapacity,
+                              const void* src, size_t compressedSize);
+
+/*! ZSTD_getFrameContentSize() : requires v1.3.0+
+ *  `src` should point to the start of a ZSTD encoded frame.
+ *  `srcSize` must be at least as large as the frame header.
+ *            hint : any size >= `ZSTD_frameHeaderSize_max` is large enough.
+ *  @return : - decompressed size of `src` frame content, if known
+ *            - ZSTD_CONTENTSIZE_UNKNOWN if the size cannot be determined
+ *            - ZSTD_CONTENTSIZE_ERROR if an error occurred (e.g. invalid magic number, srcSize too small)
+ *   note 1 : a 0 return value means the frame is valid but "empty".
+ *   note 2 : decompressed size is an optional field, it may not be present, typically in streaming mode.
+ *            When `return==ZSTD_CONTENTSIZE_UNKNOWN`, data to decompress could be any size.
+ *            In which case, it's necessary to use streaming mode to decompress data.
+ *            Optionally, application can rely on some implicit limit,
+ *            as ZSTD_decompress() only needs an upper bound of decompressed size.
+ *            (For example, data could be necessarily cut into blocks <= 16 KB).
+ *   note 3 : decompressed size is always present when compression is completed using single-pass functions,
+ *            such as ZSTD_compress(), ZSTD_compressCCtx() ZSTD_compress_usingDict() or ZSTD_compress_usingCDict().
+ *   note 4 : decompressed size can be very large (64-bits value),
+ *            potentially larger than what local system can handle as a single memory segment.
+ *            In which case, it's necessary to use streaming mode to decompress data.
+ *   note 5 : If source is untrusted, decompressed size could be wrong or intentionally modified.
+ *            Always ensure return value fits within application's authorized limits.
+ *            Each application can set its own limits.
+ *   note 6 : This function replaces ZSTD_getDecompressedSize() */
+#define ZSTD_CONTENTSIZE_UNKNOWN (0ULL - 1)
+#define ZSTD_CONTENTSIZE_ERROR   (0ULL - 2)
+ZSTDLIB_API unsigned long long ZSTD_getFrameContentSize(const void *src, size_t srcSize);
+
+/*! ZSTD_getDecompressedSize() :
+ *  NOTE: This function is now obsolete, in favor of ZSTD_getFrameContentSize().
+ *  Both functions work the same way, but ZSTD_getDecompressedSize() blends
+ *  "empty", "unknown" and "error" results to the same return value (0),
+ *  while ZSTD_getFrameContentSize() gives them separate return values.
+ * @return : decompressed size of `src` frame content _if known and not empty_, 0 otherwise. */
+ZSTD_DEPRECATED("Replaced by ZSTD_getFrameContentSize")
+ZSTDLIB_API
+unsigned long long ZSTD_getDecompressedSize(const void* src, size_t srcSize);
+
+/*! ZSTD_findFrameCompressedSize() : Requires v1.4.0+
+ * `src` should point to the start of a ZSTD frame or skippable frame.
+ * `srcSize` must be >= first frame size
+ * @return : the compressed size of the first frame starting at `src`,
+ *           suitable to pass as `srcSize` to `ZSTD_decompress` or similar,
+ *        or an error code if input is invalid */
+ZSTDLIB_API size_t ZSTD_findFrameCompressedSize(const void* src, size_t srcSize);
+
+
+/*======  Helper functions  ======*/
+/* ZSTD_compressBound() :
+ * maximum compressed size in worst case single-pass scenario.
+ * When invoking `ZSTD_compress()` or any other one-pass compression function,
+ * it's recommended to provide @dstCapacity >= ZSTD_compressBound(srcSize)
+ * as it eliminates one potential failure scenario,
+ * aka not enough room in dst buffer to write the compressed frame.
+ * Note : ZSTD_compressBound() itself can fail, if @srcSize > ZSTD_MAX_INPUT_SIZE .
+ *        In which case, ZSTD_compressBound() will return an error code
+ *        which can be tested using ZSTD_isError().
+ *
+ * ZSTD_COMPRESSBOUND() :
+ * same as ZSTD_compressBound(), but as a macro.
+ * It can be used to produce constants, which can be useful for static allocation,
+ * for example to size a static array on stack.
+ * Will produce constant value 0 if srcSize too large.
+ */
+#define ZSTD_MAX_INPUT_SIZE ((sizeof(size_t)==8) ? 0xFF00FF00FF00FF00LLU : 0xFF00FF00U)
+#define ZSTD_COMPRESSBOUND(srcSize)   (((size_t)(srcSize) >= ZSTD_MAX_INPUT_SIZE) ? 0 : (srcSize) + ((srcSize)>>8) + (((srcSize) < (128<<10)) ? (((128<<10) - (srcSize)) >> 11) /* margin, from 64 to 0 */ : 0))  /* this formula ensures that bound(A) + bound(B) <= bound(A+B) as long as A and B >= 128 KB */
+ZSTDLIB_API size_t ZSTD_compressBound(size_t srcSize); /*!< maximum compressed size in worst case single-pass scenario */
+/* ZSTD_isError() :
+ * Most ZSTD_* functions returning a size_t value can be tested for error,
+ * using ZSTD_isError().
+ * @return 1 if error, 0 otherwise
+ */
+ZSTDLIB_API unsigned    ZSTD_isError(size_t code);          /*!< tells if a `size_t` function result is an error code */
+ZSTDLIB_API const char* ZSTD_getErrorName(size_t code);     /*!< provides readable string from an error code */
+ZSTDLIB_API int         ZSTD_minCLevel(void);               /*!< minimum negative compression level allowed, requires v1.4.0+ */
+ZSTDLIB_API int         ZSTD_maxCLevel(void);               /*!< maximum compression level available */
+ZSTDLIB_API int         ZSTD_defaultCLevel(void);           /*!< default compression level, specified by ZSTD_CLEVEL_DEFAULT, requires v1.5.0+ */
+
+
+/***************************************
+*  Explicit context
+***************************************/
+/*= Compression context
+ *  When compressing many times,
+ *  it is recommended to allocate a context just once,
+ *  and re-use it for each successive compression operation.
+ *  This will make workload friendlier for system's memory.
+ *  Note : re-using context is just a speed / resource optimization.
+ *         It doesn't change the compression ratio, which remains identical.
+ *  Note 2 : In multi-threaded environments,
+ *         use one different context per thread for parallel execution.
+ */
+typedef struct ZSTD_CCtx_s ZSTD_CCtx;
+ZSTDLIB_API ZSTD_CCtx* ZSTD_createCCtx(void);
+ZSTDLIB_API size_t     ZSTD_freeCCtx(ZSTD_CCtx* cctx);  /* accept NULL pointer */
+
+/*! ZSTD_compressCCtx() :
+ *  Same as ZSTD_compress(), using an explicit ZSTD_CCtx.
+ *  Important : in order to behave similarly to `ZSTD_compress()`,
+ *  this function compresses at requested compression level,
+ *  __ignoring any other parameter__ .
+ *  If any advanced parameter was set using the advanced API,
+ *  they will all be reset. Only `compressionLevel` remains.
+ */
+ZSTDLIB_API size_t ZSTD_compressCCtx(ZSTD_CCtx* cctx,
+                                     void* dst, size_t dstCapacity,
+                               const void* src, size_t srcSize,
+                                     int compressionLevel);
+
+/*= Decompression context
+ *  When decompressing many times,
+ *  it is recommended to allocate a context only once,
+ *  and re-use it for each successive compression operation.
+ *  This will make workload friendlier for system's memory.
+ *  Use one context per thread for parallel execution. */
+typedef struct ZSTD_DCtx_s ZSTD_DCtx;
+ZSTDLIB_API ZSTD_DCtx* ZSTD_createDCtx(void);
+ZSTDLIB_API size_t     ZSTD_freeDCtx(ZSTD_DCtx* dctx);  /* accept NULL pointer */
+
+/*! ZSTD_decompressDCtx() :
+ *  Same as ZSTD_decompress(),
+ *  requires an allocated ZSTD_DCtx.
+ *  Compatible with sticky parameters.
+ */
+ZSTDLIB_API size_t ZSTD_decompressDCtx(ZSTD_DCtx* dctx,
+                                       void* dst, size_t dstCapacity,
+                                 const void* src, size_t srcSize);
+
+
+/*********************************************
+*  Advanced compression API (Requires v1.4.0+)
+**********************************************/
+
+/* API design :
+ *   Parameters are pushed one by one into an existing context,
+ *   using ZSTD_CCtx_set*() functions.
+ *   Pushed parameters are sticky : they are valid for next compressed frame, and any subsequent frame.
+ *   "sticky" parameters are applicable to `ZSTD_compress2()` and `ZSTD_compressStream*()` !
+ *   __They do not apply to "simple" one-shot variants such as ZSTD_compressCCtx()__ .
+ *
+ *   It's possible to reset all parameters to "default" using ZSTD_CCtx_reset().
+ *
+ *   This API supersedes all other "advanced" API entry points in the experimental section.
+ *   In the future, we expect to remove from experimental API entry points which are redundant with this API.
+ */
+
+
+/* Compression strategies, listed from fastest to strongest */
+typedef enum { ZSTD_fast=1,
+               ZSTD_dfast=2,
+               ZSTD_greedy=3,
+               ZSTD_lazy=4,
+               ZSTD_lazy2=5,
+               ZSTD_btlazy2=6,
+               ZSTD_btopt=7,
+               ZSTD_btultra=8,
+               ZSTD_btultra2=9
+               /* note : new strategies _might_ be added in the future.
+                         Only the order (from fast to strong) is guaranteed */
+} ZSTD_strategy;
+
+typedef enum {
+
+    /* compression parameters
+     * Note: When compressing with a ZSTD_CDict these parameters are superseded
+     * by the parameters used to construct the ZSTD_CDict.
+     * See ZSTD_CCtx_refCDict() for more info (superseded-by-cdict). */
+    ZSTD_c_compressionLevel=100, /* Set compression parameters according to pre-defined cLevel table.
+                              * Note that exact compression parameters are dynamically determined,
+                              * depending on both compression level and srcSize (when known).
+                              * Default level is ZSTD_CLEVEL_DEFAULT==3.
+                              * Special: value 0 means default, which is controlled by ZSTD_CLEVEL_DEFAULT.
+                              * Note 1 : it's possible to pass a negative compression level.
+                              * Note 2 : setting a level does not automatically set all other compression parameters
+                              *   to default. Setting this will however eventually dynamically impact the compression
+                              *   parameters which have not been manually set. The manually set
+                              *   ones will 'stick'. */
+    /* Advanced compression parameters :
+     * It's possible to pin down compression parameters to some specific values.
+     * In which case, these values are no longer dynamically selected by the compressor */
+    ZSTD_c_windowLog=101,    /* Maximum allowed back-reference distance, expressed as power of 2.
+                              * This will set a memory budget for streaming decompression,
+                              * with larger values requiring more memory
+                              * and typically compressing more.
+                              * Must be clamped between ZSTD_WINDOWLOG_MIN and ZSTD_WINDOWLOG_MAX.
+                              * Special: value 0 means "use default windowLog".
+                              * Note: Using a windowLog greater than ZSTD_WINDOWLOG_LIMIT_DEFAULT
+                              *       requires explicitly allowing such size at streaming decompression stage. */
+    ZSTD_c_hashLog=102,      /* Size of the initial probe table, as a power of 2.
+                              * Resulting memory usage is (1 << (hashLog+2)).
+                              * Must be clamped between ZSTD_HASHLOG_MIN and ZSTD_HASHLOG_MAX.
+                              * Larger tables improve compression ratio of strategies <= dFast,
+                              * and improve speed of strategies > dFast.
+                              * Special: value 0 means "use default hashLog". */
+    ZSTD_c_chainLog=103,     /* Size of the multi-probe search table, as a power of 2.
+                              * Resulting memory usage is (1 << (chainLog+2)).
+                              * Must be clamped between ZSTD_CHAINLOG_MIN and ZSTD_CHAINLOG_MAX.
+                              * Larger tables result in better and slower compression.
+                              * This parameter is useless for "fast" strategy.
+                              * It's still useful when using "dfast" strategy,
+                              * in which case it defines a secondary probe table.
+                              * Special: value 0 means "use default chainLog". */
+    ZSTD_c_searchLog=104,    /* Number of search attempts, as a power of 2.
+                              * More attempts result in better and slower compression.
+                              * This parameter is useless for "fast" and "dFast" strategies.
+                              * Special: value 0 means "use default searchLog". */
+    ZSTD_c_minMatch=105,     /* Minimum size of searched matches.
+                              * Note that Zstandard can still find matches of smaller size,
+                              * it just tweaks its search algorithm to look for this size and larger.
+                              * Larger values increase compression and decompression speed, but decrease ratio.
+                              * Must be clamped between ZSTD_MINMATCH_MIN and ZSTD_MINMATCH_MAX.
+                              * Note that currently, for all strategies < btopt, effective minimum is 4.
+                              *                    , for all strategies > fast, effective maximum is 6.
+                              * Special: value 0 means "use default minMatchLength". */
+    ZSTD_c_targetLength=106, /* Impact of this field depends on strategy.
+                              * For strategies btopt, btultra & btultra2:
+                              *     Length of Match considered "good enough" to stop search.
+                              *     Larger values make compression stronger, and slower.
+                              * For strategy fast:
+                              *     Distance between match sampling.
+                              *     Larger values make compression faster, and weaker.
+                              * Special: value 0 means "use default targetLength". */
+    ZSTD_c_strategy=107,     /* See ZSTD_strategy enum definition.
+                              * The higher the value of selected strategy, the more complex it is,
+                              * resulting in stronger and slower compression.
+                              * Special: value 0 means "use default strategy". */
+    /* LDM mode parameters */
+    ZSTD_c_enableLongDistanceMatching=160, /* Enable long distance matching.
+                                     * This parameter is designed to improve compression ratio
+                                     * for large inputs, by finding large matches at long distance.
+                                     * It increases memory usage and window size.
+                                     * Note: enabling this parameter increases default ZSTD_c_windowLog to 128 MB
+                                     * except when expressly set to a different value.
+                                     * Note: will be enabled by default if ZSTD_c_windowLog >= 128 MB and
+                                     * compression strategy >= ZSTD_btopt (== compression level 16+) */
+    ZSTD_c_ldmHashLog=161,   /* Size of the table for long distance matching, as a power of 2.
+                              * Larger values increase memory usage and compression ratio,
+                              * but decrease compression speed.
+                              * Must be clamped between ZSTD_HASHLOG_MIN and ZSTD_HASHLOG_MAX
+                              * default: windowlog - 7.
+                              * Special: value 0 means "automatically determine hashlog". */
+    ZSTD_c_ldmMinMatch=162,  /* Minimum match size for long distance matcher.
+                              * Larger/too small values usually decrease compression ratio.
+                              * Must be clamped between ZSTD_LDM_MINMATCH_MIN and ZSTD_LDM_MINMATCH_MAX.
+                              * Special: value 0 means "use default value" (default: 64). */
+    ZSTD_c_ldmBucketSizeLog=163, /* Log size of each bucket in the LDM hash table for collision resolution.
+                              * Larger values improve collision resolution but decrease compression speed.
+                              * The maximum value is ZSTD_LDM_BUCKETSIZELOG_MAX.
+                              * Special: value 0 means "use default value" (default: 3). */
+    ZSTD_c_ldmHashRateLog=164, /* Frequency of inserting/looking up entries into the LDM hash table.
+                              * Must be clamped between 0 and (ZSTD_WINDOWLOG_MAX - ZSTD_HASHLOG_MIN).
+                              * Default is MAX(0, (windowLog - ldmHashLog)), optimizing hash table usage.
+                              * Larger values improve compression speed.
+                              * Deviating far from default value will likely result in a compression ratio decrease.
+                              * Special: value 0 means "automatically determine hashRateLog". */
+
+    /* frame parameters */
+    ZSTD_c_contentSizeFlag=200, /* Content size will be written into frame header _whenever known_ (default:1)
+                              * Content size must be known at the beginning of compression.
+                              * This is automatically the case when using ZSTD_compress2(),
+                              * For streaming scenarios, content size must be provided with ZSTD_CCtx_setPledgedSrcSize() */
+    ZSTD_c_checksumFlag=201, /* A 32-bits checksum of content is written at end of frame (default:0) */
+    ZSTD_c_dictIDFlag=202,   /* When applicable, dictionary's ID is written into frame header (default:1) */
+
+    /* multi-threading parameters */
+    /* These parameters are only active if multi-threading is enabled (compiled with build macro ZSTD_MULTITHREAD).
+     * Otherwise, trying to set any other value than default (0) will be a no-op and return an error.
+     * In a situation where it's unknown if the linked library supports multi-threading or not,
+     * setting ZSTD_c_nbWorkers to any value >= 1 and consulting the return value provides a quick way to check this property.
+     */
+    ZSTD_c_nbWorkers=400,    /* Select how many threads will be spawned to compress in parallel.
+                              * When nbWorkers >= 1, triggers asynchronous mode when invoking ZSTD_compressStream*() :
+                              * ZSTD_compressStream*() consumes input and flush output if possible, but immediately gives back control to caller,
+                              * while compression is performed in parallel, within worker thread(s).
+                              * (note : a strong exception to this rule is when first invocation of ZSTD_compressStream2() sets ZSTD_e_end :
+                              *  in which case, ZSTD_compressStream2() delegates to ZSTD_compress2(), which is always a blocking call).
+                              * More workers improve speed, but also increase memory usage.
+                              * Default value is `0`, aka "single-threaded mode" : no worker is spawned,
+                              * compression is performed inside Caller's thread, and all invocations are blocking */
+    ZSTD_c_jobSize=401,      /* Size of a compression job. This value is enforced only when nbWorkers >= 1.
+                              * Each compression job is completed in parallel, so this value can indirectly impact the nb of active threads.
+                              * 0 means default, which is dynamically determined based on compression parameters.
+                              * Job size must be a minimum of overlap size, or ZSTDMT_JOBSIZE_MIN (= 512 KB), whichever is largest.
+                              * The minimum size is automatically and transparently enforced. */
+    ZSTD_c_overlapLog=402,   /* Control the overlap size, as a fraction of window size.
+                              * The overlap size is an amount of data reloaded from previous job at the beginning of a new job.
+                              * It helps preserve compression ratio, while each job is compressed in parallel.
+                              * This value is enforced only when nbWorkers >= 1.
+                              * Larger values increase compression ratio, but decrease speed.
+                              * Possible values range from 0 to 9 :
+                              * - 0 means "default" : value will be determined by the library, depending on strategy
+                              * - 1 means "no overlap"
+                              * - 9 means "full overlap", using a full window size.
+                              * Each intermediate rank increases/decreases load size by a factor 2 :
+                              * 9: full window;  8: w/2;  7: w/4;  6: w/8;  5:w/16;  4: w/32;  3:w/64;  2:w/128;  1:no overlap;  0:default
+                              * default value varies between 6 and 9, depending on strategy */
+
+    /* note : additional experimental parameters are also available
+     * within the experimental section of the API.
+     * At the time of this writing, they include :
+     * ZSTD_c_rsyncable
+     * ZSTD_c_format
+     * ZSTD_c_forceMaxWindow
+     * ZSTD_c_forceAttachDict
+     * ZSTD_c_literalCompressionMode
+     * ZSTD_c_targetCBlockSize
+     * ZSTD_c_srcSizeHint
+     * ZSTD_c_enableDedicatedDictSearch
+     * ZSTD_c_stableInBuffer
+     * ZSTD_c_stableOutBuffer
+     * ZSTD_c_blockDelimiters
+     * ZSTD_c_validateSequences
+     * ZSTD_c_useBlockSplitter
+     * ZSTD_c_useRowMatchFinder
+     * ZSTD_c_prefetchCDictTables
+     * ZSTD_c_enableSeqProducerFallback
+     * ZSTD_c_maxBlockSize
+     * Because they are not stable, it's necessary to define ZSTD_STATIC_LINKING_ONLY to access them.
+     * note : never ever use experimentalParam? names directly;
+     *        also, the enums values themselves are unstable and can still change.
+     */
+     ZSTD_c_experimentalParam1=500,
+     ZSTD_c_experimentalParam2=10,
+     ZSTD_c_experimentalParam3=1000,
+     ZSTD_c_experimentalParam4=1001,
+     ZSTD_c_experimentalParam5=1002,
+     ZSTD_c_experimentalParam6=1003,
+     ZSTD_c_experimentalParam7=1004,
+     ZSTD_c_experimentalParam8=1005,
+     ZSTD_c_experimentalParam9=1006,
+     ZSTD_c_experimentalParam10=1007,
+     ZSTD_c_experimentalParam11=1008,
+     ZSTD_c_experimentalParam12=1009,
+     ZSTD_c_experimentalParam13=1010,
+     ZSTD_c_experimentalParam14=1011,
+     ZSTD_c_experimentalParam15=1012,
+     ZSTD_c_experimentalParam16=1013,
+     ZSTD_c_experimentalParam17=1014,
+     ZSTD_c_experimentalParam18=1015,
+     ZSTD_c_experimentalParam19=1016
+} ZSTD_cParameter;
+
+typedef struct {
+    size_t error;
+    int lowerBound;
+    int upperBound;
+} ZSTD_bounds;
+
+/*! ZSTD_cParam_getBounds() :
+ *  All parameters must belong to an interval with lower and upper bounds,
+ *  otherwise they will either trigger an error or be automatically clamped.
+ * @return : a structure, ZSTD_bounds, which contains
+ *         - an error status field, which must be tested using ZSTD_isError()
+ *         - lower and upper bounds, both inclusive
+ */
+ZSTDLIB_API ZSTD_bounds ZSTD_cParam_getBounds(ZSTD_cParameter cParam);
+
+/*! ZSTD_CCtx_setParameter() :
+ *  Set one compression parameter, selected by enum ZSTD_cParameter.
+ *  All parameters have valid bounds. Bounds can be queried using ZSTD_cParam_getBounds().
+ *  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter).
+ *  Setting a parameter is generally only possible during frame initialization (before starting compression).
+ *  Exception : when using multi-threading mode (nbWorkers >= 1),
+ *              the following parameters can be updated _during_ compression (within same frame):
+ *              => compressionLevel, hashLog, chainLog, searchLog, minMatch, targetLength and strategy.
+ *              new parameters will be active for next job only (after a flush()).
+ * @return : an error code (which can be tested using ZSTD_isError()).
+ */
+ZSTDLIB_API size_t ZSTD_CCtx_setParameter(ZSTD_CCtx* cctx, ZSTD_cParameter param, int value);
+
+/*! ZSTD_CCtx_setPledgedSrcSize() :
+ *  Total input data size to be compressed as a single frame.
+ *  Value will be written in frame header, unless if explicitly forbidden using ZSTD_c_contentSizeFlag.
+ *  This value will also be controlled at end of frame, and trigger an error if not respected.
+ * @result : 0, or an error code (which can be tested with ZSTD_isError()).
+ *  Note 1 : pledgedSrcSize==0 actually means zero, aka an empty frame.
+ *           In order to mean "unknown content size", pass constant ZSTD_CONTENTSIZE_UNKNOWN.
+ *           ZSTD_CONTENTSIZE_UNKNOWN is default value for any new frame.
+ *  Note 2 : pledgedSrcSize is only valid once, for the next frame.
+ *           It's discarded at the end of the frame, and replaced by ZSTD_CONTENTSIZE_UNKNOWN.
+ *  Note 3 : Whenever all input data is provided and consumed in a single round,
+ *           for example with ZSTD_compress2(),
+ *           or invoking immediately ZSTD_compressStream2(,,,ZSTD_e_end),
+ *           this value is automatically overridden by srcSize instead.
+ */
+ZSTDLIB_API size_t ZSTD_CCtx_setPledgedSrcSize(ZSTD_CCtx* cctx, unsigned long long pledgedSrcSize);
+
+typedef enum {
+    ZSTD_reset_session_only = 1,
+    ZSTD_reset_parameters = 2,
+    ZSTD_reset_session_and_parameters = 3
+} ZSTD_ResetDirective;
+
+/*! ZSTD_CCtx_reset() :
+ *  There are 2 different things that can be reset, independently or jointly :
+ *  - The session : will stop compressing current frame, and make CCtx ready to start a new one.
+ *                  Useful after an error, or to interrupt any ongoing compression.
+ *                  Any internal data not yet flushed is cancelled.
+ *                  Compression parameters and dictionary remain unchanged.
+ *                  They will be used to compress next frame.
+ *                  Resetting session never fails.
+ *  - The parameters : changes all parameters back to "default".
+ *                  This also removes any reference to any dictionary or external sequence producer.
+ *                  Parameters can only be changed between 2 sessions (i.e. no compression is currently ongoing)
+ *                  otherwise the reset fails, and function returns an error value (which can be tested using ZSTD_isError())
+ *  - Both : similar to resetting the session, followed by resetting parameters.
+ */
+ZSTDLIB_API size_t ZSTD_CCtx_reset(ZSTD_CCtx* cctx, ZSTD_ResetDirective reset);
+
+/*! ZSTD_compress2() :
+ *  Behave the same as ZSTD_compressCCtx(), but compression parameters are set using the advanced API.
+ *  ZSTD_compress2() always starts a new frame.
+ *  Should cctx hold data from a previously unfinished frame, everything about it is forgotten.
+ *  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()
+ *  - The function is always blocking, returns when compression is completed.
+ *  NOTE: Providing `dstCapacity >= ZSTD_compressBound(srcSize)` guarantees that zstd will have
+ *        enough space to successfully compress the data, though it is possible it fails for other reasons.
+ * @return : compressed size written into `dst` (<= `dstCapacity),
+ *           or an error code if it fails (which can be tested using ZSTD_isError()).
+ */
+ZSTDLIB_API size_t ZSTD_compress2( ZSTD_CCtx* cctx,
+                                   void* dst, size_t dstCapacity,
+                             const void* src, size_t srcSize);
+
+
+/***********************************************
+*  Advanced decompression API (Requires v1.4.0+)
+************************************************/
+
+/* The advanced API pushes parameters one by one into an existing DCtx context.
+ * Parameters are sticky, and remain valid for all following frames
+ * using the same DCtx context.
+ * It's possible to reset parameters to default values using ZSTD_DCtx_reset().
+ * Note : This API is compatible with existing ZSTD_decompressDCtx() and ZSTD_decompressStream().
+ *        Therefore, no new decompression function is necessary.
+ */
+
+typedef enum {
+
+    ZSTD_d_windowLogMax=100, /* Select a size limit (in power of 2) beyond which
+                              * the streaming API will refuse to allocate memory buffer
+                              * in order to protect the host from unreasonable memory requirements.
+                              * This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode.
+                              * By default, a decompression context accepts window sizes <= (1 << ZSTD_WINDOWLOG_LIMIT_DEFAULT).
+                              * Special: value 0 means "use default maximum windowLog". */
+
+    /* note : additional experimental parameters are also available
+     * within the experimental section of the API.
+     * At the time of this writing, they include :
+     * ZSTD_d_format
+     * ZSTD_d_stableOutBuffer
+     * ZSTD_d_forceIgnoreChecksum
+     * ZSTD_d_refMultipleDDicts
+     * ZSTD_d_disableHuffmanAssembly
+     * Because they are not stable, it's necessary to define ZSTD_STATIC_LINKING_ONLY to access them.
+     * note : never ever use experimentalParam? names directly
+     */
+     ZSTD_d_experimentalParam1=1000,
+     ZSTD_d_experimentalParam2=1001,
+     ZSTD_d_experimentalParam3=1002,
+     ZSTD_d_experimentalParam4=1003,
+     ZSTD_d_experimentalParam5=1004
+
+} ZSTD_dParameter;
+
+/*! ZSTD_dParam_getBounds() :
+ *  All parameters must belong to an interval with lower and upper bounds,
+ *  otherwise they will either trigger an error or be automatically clamped.
+ * @return : a structure, ZSTD_bounds, which contains
+ *         - an error status field, which must be tested using ZSTD_isError()
+ *         - both lower and upper bounds, inclusive
+ */
+ZSTDLIB_API ZSTD_bounds ZSTD_dParam_getBounds(ZSTD_dParameter dParam);
+
+/*! ZSTD_DCtx_setParameter() :
+ *  Set one compression parameter, selected by enum ZSTD_dParameter.
+ *  All parameters have valid bounds. Bounds can be queried using ZSTD_dParam_getBounds().
+ *  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter).
+ *  Setting a parameter is only possible during frame initialization (before starting decompression).
+ * @return : 0, or an error code (which can be tested using ZSTD_isError()).
+ */
+ZSTDLIB_API size_t ZSTD_DCtx_setParameter(ZSTD_DCtx* dctx, ZSTD_dParameter param, int value);
+
+/*! ZSTD_DCtx_reset() :
+ *  Return a DCtx to clean state.
+ *  Session and parameters can be reset jointly or separately.
+ *  Parameters can only be reset when no active frame is being decompressed.
+ * @return : 0, or an error code, which can be tested with ZSTD_isError()
+ */
+ZSTDLIB_API size_t ZSTD_DCtx_reset(ZSTD_DCtx* dctx, ZSTD_ResetDirective reset);
+
+
+/****************************
+*  Streaming
+****************************/
+
+typedef struct ZSTD_inBuffer_s {
+  const void* src;    /**< start of input buffer */
+  size_t size;        /**< size of input buffer */
+  size_t pos;         /**< position where reading stopped. Will be updated. Necessarily 0 <= pos <= size */
+} ZSTD_inBuffer;
+
+typedef struct ZSTD_outBuffer_s {
+  void*  dst;         /**< start of output buffer */
+  size_t size;        /**< size of output buffer */
+  size_t pos;         /**< position where writing stopped. Will be updated. Necessarily 0 <= pos <= size */
+} ZSTD_outBuffer;
+
+
+
+/*-***********************************************************************
+*  Streaming compression - HowTo
+*
+*  A ZSTD_CStream object is required to track streaming operation.
+*  Use ZSTD_createCStream() and ZSTD_freeCStream() to create/release resources.
+*  ZSTD_CStream objects can be reused multiple times on consecutive compression operations.
+*  It is recommended to re-use ZSTD_CStream since it will play nicer with system's memory, by re-using already allocated memory.
+*
+*  For parallel execution, use one separate ZSTD_CStream per thread.
+*
+*  note : since v1.3.0, ZSTD_CStream and ZSTD_CCtx are the same thing.
+*
+*  Parameters are sticky : when starting a new compression on the same context,
+*  it will re-use the same sticky parameters as previous compression session.
+*  When in doubt, it's recommended to fully initialize the context before usage.
+*  Use ZSTD_CCtx_reset() to reset the context and ZSTD_CCtx_setParameter(),
+*  ZSTD_CCtx_setPledgedSrcSize(), or ZSTD_CCtx_loadDictionary() and friends to
+*  set more specific parameters, the pledged source size, or load a dictionary.
+*
+*  Use ZSTD_compressStream2() with ZSTD_e_continue as many times as necessary to
+*  consume input stream. The function will automatically update both `pos`
+*  fields within `input` and `output`.
+*  Note that the function may not consume the entire input, for example, because
+*  the output buffer is already full, in which case `input.pos < input.size`.
+*  The caller must check if input has been entirely consumed.
+*  If not, the caller must make some room to receive more compressed data,
+*  and then present again remaining input data.
+*  note: ZSTD_e_continue is guaranteed to make some forward progress when called,
+*        but doesn't guarantee maximal forward progress. This is especially relevant
+*        when compressing with multiple threads. The call won't block if it can
+*        consume some input, but if it can't it will wait for some, but not all,
+*        output to be flushed.
+* @return : provides a minimum amount of data remaining to be flushed from internal buffers
+*           or an error code, which can be tested using ZSTD_isError().
+*
+*  At any moment, it's possible to flush whatever data might remain stuck within internal buffer,
+*  using ZSTD_compressStream2() with ZSTD_e_flush. `output->pos` will be updated.
+*  Note that, if `output->size` is too small, a single invocation with ZSTD_e_flush might not be enough (return code > 0).
+*  In which case, make some room to receive more compressed data, and call again ZSTD_compressStream2() with ZSTD_e_flush.
+*  You must continue calling ZSTD_compressStream2() with ZSTD_e_flush until it returns 0, at which point you can change the
+*  operation.
+*  note: ZSTD_e_flush will flush as much output as possible, meaning when compressing with multiple threads, it will
+*        block until the flush is complete or the output buffer is full.
+*  @return : 0 if internal buffers are entirely flushed,
+*            >0 if some data still present within internal buffer (the value is minimal estimation of remaining size),
+*            or an error code, which can be tested using ZSTD_isError().
+*
+*  Calling ZSTD_compressStream2() with ZSTD_e_end instructs to finish a frame.
+*  It will perform a flush and write frame epilogue.
+*  The epilogue is required for decoders to consider a frame completed.
+*  flush operation is the same, and follows same rules as calling ZSTD_compressStream2() with ZSTD_e_flush.
+*  You must continue calling ZSTD_compressStream2() with ZSTD_e_end until it returns 0, at which point you are free to
+*  start a new frame.
+*  note: ZSTD_e_end will flush as much output as possible, meaning when compressing with multiple threads, it will
+*        block until the flush is complete or the output buffer is full.
+*  @return : 0 if frame fully completed and fully flushed,
+*            >0 if some data still present within internal buffer (the value is minimal estimation of remaining size),
+*            or an error code, which can be tested using ZSTD_isError().
+*
+* *******************************************************************/
+
+typedef ZSTD_CCtx ZSTD_CStream;  /**< CCtx and CStream are now effectively same object (>= v1.3.0) */
+                                 /* Continue to distinguish them for compatibility with older versions <= v1.2.0 */
+/*===== ZSTD_CStream management functions =====*/
+ZSTDLIB_API ZSTD_CStream* ZSTD_createCStream(void);
+ZSTDLIB_API size_t ZSTD_freeCStream(ZSTD_CStream* zcs);  /* accept NULL pointer */
+
+/*===== Streaming compression functions =====*/
+typedef enum {
+    ZSTD_e_continue=0, /* collect more data, encoder decides when to output compressed result, for optimal compression ratio */
+    ZSTD_e_flush=1,    /* flush any data provided so far,
+                        * it creates (at least) one new block, that can be decoded immediately on reception;
+                        * frame will continue: any future data can still reference previously compressed data, improving compression.
+                        * note : multithreaded compression will block to flush as much output as possible. */
+    ZSTD_e_end=2       /* flush any remaining data _and_ close current frame.
+                        * note that frame is only closed after compressed data is fully flushed (return value == 0).
+                        * After that point, any additional data starts a new frame.
+                        * note : each frame is independent (does not reference any content from previous frame).
+                        : note : multithreaded compression will block to flush as much output as possible. */
+} ZSTD_EndDirective;
+
+/*! ZSTD_compressStream2() : Requires v1.4.0+
+ *  Behaves about the same as ZSTD_compressStream, with additional control on end directive.
+ *  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()
+ *  - Compression parameters cannot be changed once compression is started (save a list of exceptions in multi-threading mode)
+ *  - output->pos must be <= dstCapacity, input->pos must be <= srcSize
+ *  - output->pos and input->pos will be updated. They are guaranteed to remain below their respective limit.
+ *  - endOp must be a valid directive
+ *  - When nbWorkers==0 (default), function is blocking : it completes its job before returning to caller.
+ *  - When nbWorkers>=1, function is non-blocking : it copies a portion of input, distributes jobs to internal worker threads, flush to output whatever is available,
+ *                                                  and then immediately returns, just indicating that there is some data remaining to be flushed.
+ *                                                  The function nonetheless guarantees forward progress : it will return only after it reads or write at least 1+ byte.
+ *  - Exception : if the first call requests a ZSTD_e_end directive and provides enough dstCapacity, the function delegates to ZSTD_compress2() which is always blocking.
+ *  - @return provides a minimum amount of data remaining to be flushed from internal buffers
+ *            or an error code, which can be tested using ZSTD_isError().
+ *            if @return != 0, flush is not fully completed, there is still some data left within internal buffers.
+ *            This is useful for ZSTD_e_flush, since in this case more flushes are necessary to empty all buffers.
+ *            For ZSTD_e_end, @return == 0 when internal buffers are fully flushed and frame is completed.
+ *  - after a ZSTD_e_end directive, if internal buffer is not fully flushed (@return != 0),
+ *            only ZSTD_e_end or ZSTD_e_flush operations are allowed.
+ *            Before starting a new compression job, or changing compression parameters,
+ *            it is required to fully flush internal buffers.
+ */
+ZSTDLIB_API size_t ZSTD_compressStream2( ZSTD_CCtx* cctx,
+                                         ZSTD_outBuffer* output,
+                                         ZSTD_inBuffer* input,
+                                         ZSTD_EndDirective endOp);
+
+
+/* These buffer sizes are softly recommended.
+ * They are not required : ZSTD_compressStream*() happily accepts any buffer size, for both input and output.
+ * Respecting the recommended size just makes it a bit easier for ZSTD_compressStream*(),
+ * reducing the amount of memory shuffling and buffering, resulting in minor performance savings.
+ *
+ * However, note that these recommendations are from the perspective of a C caller program.
+ * If the streaming interface is invoked from some other language,
+ * especially managed ones such as Java or Go, through a foreign function interface such as jni or cgo,
+ * a major performance rule is to reduce crossing such interface to an absolute minimum.
+ * It's not rare that performance ends being spent more into the interface, rather than compression itself.
+ * In which cases, prefer using large buffers, as large as practical,
+ * for both input and output, to reduce the nb of roundtrips.
+ */
+ZSTDLIB_API size_t ZSTD_CStreamInSize(void);    /**< recommended size for input buffer */
+ZSTDLIB_API size_t ZSTD_CStreamOutSize(void);   /**< recommended size for output buffer. Guarantee to successfully flush at least one complete compressed block. */
+
+
+/* *****************************************************************************
+ * This following is a legacy streaming API, available since v1.0+ .
+ * It can be replaced by ZSTD_CCtx_reset() and ZSTD_compressStream2().
+ * It is redundant, but remains fully supported.
+ ******************************************************************************/
+
+/*!
+ * Equivalent to:
+ *
+ *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
+ *     ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)
+ *     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
+ *
+ * Note that ZSTD_initCStream() clears any previously set dictionary. Use the new API
+ * to compress with a dictionary.
+ */
+ZSTDLIB_API size_t ZSTD_initCStream(ZSTD_CStream* zcs, int compressionLevel);
+/*!
+ * Alternative for ZSTD_compressStream2(zcs, output, input, ZSTD_e_continue).
+ * NOTE: The return value is different. ZSTD_compressStream() returns a hint for
+ * the next read size (if non-zero and not an error). ZSTD_compressStream2()
+ * returns the minimum nb of bytes left to flush (if non-zero and not an error).
+ */
+ZSTDLIB_API size_t ZSTD_compressStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output, ZSTD_inBuffer* input);
+/*! Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_flush). */
+ZSTDLIB_API size_t ZSTD_flushStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output);
+/*! Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_end). */
+ZSTDLIB_API size_t ZSTD_endStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output);
+
+
+/*-***************************************************************************
+*  Streaming decompression - HowTo
+*
+*  A ZSTD_DStream object is required to track streaming operations.
+*  Use ZSTD_createDStream() and ZSTD_freeDStream() to create/release resources.
+*  ZSTD_DStream objects can be re-used multiple times.
+*
+*  Use ZSTD_initDStream() to start a new decompression operation.
+* @return : recommended first input size
+*  Alternatively, use advanced API to set specific properties.
+*
+*  Use ZSTD_decompressStream() repetitively to consume your input.
+*  The function will update both `pos` fields.
+*  If `input.pos < input.size`, some input has not been consumed.
+*  It's up to the caller to present again remaining data.
+*  The function tries to flush all data decoded immediately, respecting output buffer size.
+*  If `output.pos < output.size`, decoder has flushed everything it could.
+*  But if `output.pos == output.size`, there might be some data left within internal buffers.,
+*  In which case, call ZSTD_decompressStream() again to flush whatever remains in the buffer.
+*  Note : with no additional input provided, amount of data flushed is necessarily <= ZSTD_BLOCKSIZE_MAX.
+* @return : 0 when a frame is completely decoded and fully flushed,
+*        or an error code, which can be tested using ZSTD_isError(),
+*        or any other value > 0, which means there is still some decoding or flushing to do to complete current frame :
+*                                the return value is a suggested next input size (just a hint for better latency)
+*                                that will never request more than the remaining frame size.
+* *******************************************************************************/
+
+typedef ZSTD_DCtx ZSTD_DStream;  /**< DCtx and DStream are now effectively same object (>= v1.3.0) */
+                                 /* For compatibility with versions <= v1.2.0, prefer differentiating them. */
+/*===== ZSTD_DStream management functions =====*/
+ZSTDLIB_API ZSTD_DStream* ZSTD_createDStream(void);
+ZSTDLIB_API size_t ZSTD_freeDStream(ZSTD_DStream* zds);  /* accept NULL pointer */
+
+/*===== Streaming decompression functions =====*/
+
+/*! ZSTD_initDStream() :
+ * Initialize/reset DStream state for new decompression operation.
+ * Call before new decompression operation using same DStream.
+ *
+ * Note : This function is redundant with the advanced API and equivalent to:
+ *     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
+ *     ZSTD_DCtx_refDDict(zds, NULL);
+ */
+ZSTDLIB_API size_t ZSTD_initDStream(ZSTD_DStream* zds);
+
+/*! ZSTD_decompressStream() :
+ * Streaming decompression function.
+ * Call repetitively to consume full input updating it as necessary.
+ * Function will update both input and output `pos` fields exposing current state via these fields:
+ * - `input.pos < input.size`, some input remaining and caller should provide remaining input
+ *   on the next call.
+ * - `output.pos < output.size`, decoder finished and flushed all remaining buffers.
+ * - `output.pos == output.size`, potentially uncflushed data present in the internal buffers,
+ *   call ZSTD_decompressStream() again to flush remaining data to output.
+ * Note : with no additional input, amount of data flushed <= ZSTD_BLOCKSIZE_MAX.
+ *
+ * @return : 0 when a frame is completely decoded and fully flushed,
+ *           or an error code, which can be tested using ZSTD_isError(),
+ *           or any other value > 0, which means there is some decoding or flushing to do to complete current frame.
+ */
+ZSTDLIB_API size_t ZSTD_decompressStream(ZSTD_DStream* zds, ZSTD_outBuffer* output, ZSTD_inBuffer* input);
+
+ZSTDLIB_API size_t ZSTD_DStreamInSize(void);    /*!< recommended size for input buffer */
+ZSTDLIB_API size_t ZSTD_DStreamOutSize(void);   /*!< recommended size for output buffer. Guarantee to successfully flush at least one complete block in all circumstances. */
+
+
+/**************************
+*  Simple dictionary API
+***************************/
+/*! ZSTD_compress_usingDict() :
+ *  Compression at an explicit compression level using a Dictionary.
+ *  A dictionary can be any arbitrary data segment (also called a prefix),
+ *  or a buffer with specified information (see zdict.h).
+ *  Note : This function loads the dictionary, resulting in significant startup delay.
+ *         It's intended for a dictionary used only once.
+ *  Note 2 : When `dict == NULL || dictSize < 8` no dictionary is used. */
+ZSTDLIB_API size_t ZSTD_compress_usingDict(ZSTD_CCtx* ctx,
+                                           void* dst, size_t dstCapacity,
+                                     const void* src, size_t srcSize,
+                                     const void* dict,size_t dictSize,
+                                           int compressionLevel);
+
+/*! ZSTD_decompress_usingDict() :
+ *  Decompression using a known Dictionary.
+ *  Dictionary must be identical to the one used during compression.
+ *  Note : This function loads the dictionary, resulting in significant startup delay.
+ *         It's intended for a dictionary used only once.
+ *  Note : When `dict == NULL || dictSize < 8` no dictionary is used. */
+ZSTDLIB_API size_t ZSTD_decompress_usingDict(ZSTD_DCtx* dctx,
+                                             void* dst, size_t dstCapacity,
+                                       const void* src, size_t srcSize,
+                                       const void* dict,size_t dictSize);
+
+
+/***********************************
+ *  Bulk processing dictionary API
+ **********************************/
+typedef struct ZSTD_CDict_s ZSTD_CDict;
+
+/*! ZSTD_createCDict() :
+ *  When compressing multiple messages or blocks using the same dictionary,
+ *  it's recommended to digest the dictionary only once, since it's a costly operation.
+ *  ZSTD_createCDict() will create a state from digesting a dictionary.
+ *  The resulting state can be used for future compression operations with very limited startup cost.
+ *  ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only.
+ * @dictBuffer can be released after ZSTD_CDict creation, because its content is copied within CDict.
+ *  Note 1 : Consider experimental function `ZSTD_createCDict_byReference()` if you prefer to not duplicate @dictBuffer content.
+ *  Note 2 : A ZSTD_CDict can be created from an empty @dictBuffer,
+ *      in which case the only thing that it transports is the @compressionLevel.
+ *      This can be useful in a pipeline featuring ZSTD_compress_usingCDict() exclusively,
+ *      expecting a ZSTD_CDict parameter with any data, including those without a known dictionary. */
+ZSTDLIB_API ZSTD_CDict* ZSTD_createCDict(const void* dictBuffer, size_t dictSize,
+                                         int compressionLevel);
+
+/*! ZSTD_freeCDict() :
+ *  Function frees memory allocated by ZSTD_createCDict().
+ *  If a NULL pointer is passed, no operation is performed. */
+ZSTDLIB_API size_t      ZSTD_freeCDict(ZSTD_CDict* CDict);
+
+/*! ZSTD_compress_usingCDict() :
+ *  Compression using a digested Dictionary.
+ *  Recommended when same dictionary is used multiple times.
+ *  Note : compression level is _decided at dictionary creation time_,
+ *     and frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no) */
+ZSTDLIB_API size_t ZSTD_compress_usingCDict(ZSTD_CCtx* cctx,
+                                            void* dst, size_t dstCapacity,
+                                      const void* src, size_t srcSize,
+                                      const ZSTD_CDict* cdict);
+
+
+typedef struct ZSTD_DDict_s ZSTD_DDict;
+
+/*! ZSTD_createDDict() :
+ *  Create a digested dictionary, ready to start decompression operation without startup delay.
+ *  dictBuffer can be released after DDict creation, as its content is copied inside DDict. */
+ZSTDLIB_API ZSTD_DDict* ZSTD_createDDict(const void* dictBuffer, size_t dictSize);
+
+/*! ZSTD_freeDDict() :
+ *  Function frees memory allocated with ZSTD_createDDict()
+ *  If a NULL pointer is passed, no operation is performed. */
+ZSTDLIB_API size_t      ZSTD_freeDDict(ZSTD_DDict* ddict);
+
+/*! ZSTD_decompress_usingDDict() :
+ *  Decompression using a digested Dictionary.
+ *  Recommended when same dictionary is used multiple times. */
+ZSTDLIB_API size_t ZSTD_decompress_usingDDict(ZSTD_DCtx* dctx,
+                                              void* dst, size_t dstCapacity,
+                                        const void* src, size_t srcSize,
+                                        const ZSTD_DDict* ddict);
+
+
+/********************************
+ *  Dictionary helper functions
+ *******************************/
+
+/*! ZSTD_getDictID_fromDict() : Requires v1.4.0+
+ *  Provides the dictID stored within dictionary.
+ *  if @return == 0, the dictionary is not conformant with Zstandard specification.
+ *  It can still be loaded, but as a content-only dictionary. */
+ZSTDLIB_API unsigned ZSTD_getDictID_fromDict(const void* dict, size_t dictSize);
+
+/*! ZSTD_getDictID_fromCDict() : Requires v1.5.0+
+ *  Provides the dictID of the dictionary loaded into `cdict`.
+ *  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
+ *  Non-conformant dictionaries can still be loaded, but as content-only dictionaries. */
+ZSTDLIB_API unsigned ZSTD_getDictID_fromCDict(const ZSTD_CDict* cdict);
+
+/*! ZSTD_getDictID_fromDDict() : Requires v1.4.0+
+ *  Provides the dictID of the dictionary loaded into `ddict`.
+ *  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
+ *  Non-conformant dictionaries can still be loaded, but as content-only dictionaries. */
+ZSTDLIB_API unsigned ZSTD_getDictID_fromDDict(const ZSTD_DDict* ddict);
+
+/*! ZSTD_getDictID_fromFrame() : Requires v1.4.0+
+ *  Provides the dictID required to decompressed the frame stored within `src`.
+ *  If @return == 0, the dictID could not be decoded.
+ *  This could for one of the following reasons :
+ *  - The frame does not require a dictionary to be decoded (most common case).
+ *  - The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden piece of information.
+ *    Note : this use case also happens when using a non-conformant dictionary.
+ *  - `srcSize` is too small, and as a result, the frame header could not be decoded (only possible if `srcSize < ZSTD_FRAMEHEADERSIZE_MAX`).
+ *  - This is not a Zstandard frame.
+ *  When identifying the exact failure cause, it's possible to use ZSTD_getFrameHeader(), which will provide a more precise error code. */
+ZSTDLIB_API unsigned ZSTD_getDictID_fromFrame(const void* src, size_t srcSize);
+
+
+/*******************************************************************************
+ * Advanced dictionary and prefix API (Requires v1.4.0+)
+ *
+ * This API allows dictionaries to be used with ZSTD_compress2(),
+ * ZSTD_compressStream2(), and ZSTD_decompressDCtx().
+ * Dictionaries are sticky, they remain valid when same context is re-used,
+ * they only reset when the context is reset
+ * with ZSTD_reset_parameters or ZSTD_reset_session_and_parameters.
+ * In contrast, Prefixes are single-use.
+ ******************************************************************************/
+
+
+/*! ZSTD_CCtx_loadDictionary() : Requires v1.4.0+
+ *  Create an internal CDict from `dict` buffer.
+ *  Decompression will have to use same dictionary.
+ * @result : 0, or an error code (which can be tested with ZSTD_isError()).
+ *  Special: Loading a NULL (or 0-size) dictionary invalidates previous dictionary,
+ *           meaning "return to no-dictionary mode".
+ *  Note 1 : Dictionary is sticky, it will be used for all future compressed frames,
+ *           until parameters are reset, a new dictionary is loaded, or the dictionary
+ *           is explicitly invalidated by loading a NULL dictionary.
+ *  Note 2 : Loading a dictionary involves building tables.
+ *           It's also a CPU consuming operation, with non-negligible impact on latency.
+ *           Tables are dependent on compression parameters, and for this reason,
+ *           compression parameters can no longer be changed after loading a dictionary.
+ *  Note 3 :`dict` content will be copied internally.
+ *           Use experimental ZSTD_CCtx_loadDictionary_byReference() to reference content instead.
+ *           In such a case, dictionary buffer must outlive its users.
+ *  Note 4 : Use ZSTD_CCtx_loadDictionary_advanced()
+ *           to precisely select how dictionary content must be interpreted.
+ *  Note 5 : This method does not benefit from LDM (long distance mode).
+ *           If you want to employ LDM on some large dictionary content,
+ *           prefer employing ZSTD_CCtx_refPrefix() described below.
+ */
+ZSTDLIB_API size_t ZSTD_CCtx_loadDictionary(ZSTD_CCtx* cctx, const void* dict, size_t dictSize);
+
+/*! ZSTD_CCtx_refCDict() : Requires v1.4.0+
+ *  Reference a prepared dictionary, to be used for all future compressed frames.
+ *  Note that compression parameters are enforced from within CDict,
+ *  and supersede any compression parameter previously set within CCtx.
+ *  The parameters ignored are labelled as "superseded-by-cdict" in the ZSTD_cParameter enum docs.
+ *  The ignored parameters will be used again if the CCtx is returned to no-dictionary mode.
+ *  The dictionary will remain valid for future compressed frames using same CCtx.
+ * @result : 0, or an error code (which can be tested with ZSTD_isError()).
+ *  Special : Referencing a NULL CDict means "return to no-dictionary mode".
+ *  Note 1 : Currently, only one dictionary can be managed.
+ *           Referencing a new dictionary effectively "discards" any previous one.
+ *  Note 2 : CDict is just referenced, its lifetime must outlive its usage within CCtx. */
+ZSTDLIB_API size_t ZSTD_CCtx_refCDict(ZSTD_CCtx* cctx, const ZSTD_CDict* cdict);
+
+/*! ZSTD_CCtx_refPrefix() : Requires v1.4.0+
+ *  Reference a prefix (single-usage dictionary) for next compressed frame.
+ *  A prefix is **only used once**. Tables are discarded at end of frame (ZSTD_e_end).
+ *  Decompression will need same prefix to properly regenerate data.
+ *  Compressing with a prefix is similar in outcome as performing a diff and compressing it,
+ *  but performs much faster, especially during decompression (compression speed is tunable with compression level).
+ *  This method is compatible with LDM (long distance mode).
+ * @result : 0, or an error code (which can be tested with ZSTD_isError()).
+ *  Special: Adding any prefix (including NULL) invalidates any previous prefix or dictionary
+ *  Note 1 : Prefix buffer is referenced. It **must** outlive compression.
+ *           Its content must remain unmodified during compression.
+ *  Note 2 : If the intention is to diff some large src data blob with some prior version of itself,
+ *           ensure that the window size is large enough to contain the entire source.
+ *           See ZSTD_c_windowLog.
+ *  Note 3 : Referencing a prefix involves building tables, which are dependent on compression parameters.
+ *           It's a CPU consuming operation, with non-negligible impact on latency.
+ *           If there is a need to use the same prefix multiple times, consider loadDictionary instead.
+ *  Note 4 : By default, the prefix is interpreted as raw content (ZSTD_dct_rawContent).
+ *           Use experimental ZSTD_CCtx_refPrefix_advanced() to alter dictionary interpretation. */
+ZSTDLIB_API size_t ZSTD_CCtx_refPrefix(ZSTD_CCtx* cctx,
+                                 const void* prefix, size_t prefixSize);
+
+/*! ZSTD_DCtx_loadDictionary() : Requires v1.4.0+
+ *  Create an internal DDict from dict buffer, to be used to decompress all future frames.
+ *  The dictionary remains valid for all future frames, until explicitly invalidated, or
+ *  a new dictionary is loaded.
+ * @result : 0, or an error code (which can be tested with ZSTD_isError()).
+ *  Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary,
+ *            meaning "return to no-dictionary mode".
+ *  Note 1 : Loading a dictionary involves building tables,
+ *           which has a non-negligible impact on CPU usage and latency.
+ *           It's recommended to "load once, use many times", to amortize the cost
+ *  Note 2 :`dict` content will be copied internally, so `dict` can be released after loading.
+ *           Use ZSTD_DCtx_loadDictionary_byReference() to reference dictionary content instead.
+ *  Note 3 : Use ZSTD_DCtx_loadDictionary_advanced() to take control of
+ *           how dictionary content is loaded and interpreted.
+ */
+ZSTDLIB_API size_t ZSTD_DCtx_loadDictionary(ZSTD_DCtx* dctx, const void* dict, size_t dictSize);
+
+/*! ZSTD_DCtx_refDDict() : Requires v1.4.0+
+ *  Reference a prepared dictionary, to be used to decompress next frames.
+ *  The dictionary remains active for decompression of future frames using same DCtx.
+ *
+ *  If called with ZSTD_d_refMultipleDDicts enabled, repeated calls of this function
+ *  will store the DDict references in a table, and the DDict used for decompression
+ *  will be determined at decompression time, as per the dict ID in the frame.
+ *  The memory for the table is allocated on the first call to refDDict, and can be
+ *  freed with ZSTD_freeDCtx().
+ *
+ *  If called with ZSTD_d_refMultipleDDicts disabled (the default), only one dictionary
+ *  will be managed, and referencing a dictionary effectively "discards" any previous one.
+ *
+ * @result : 0, or an error code (which can be tested with ZSTD_isError()).
+ *  Special: referencing a NULL DDict means "return to no-dictionary mode".
+ *  Note 2 : DDict is just referenced, its lifetime must outlive its usage from DCtx.
+ */
+ZSTDLIB_API size_t ZSTD_DCtx_refDDict(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict);
+
+/*! ZSTD_DCtx_refPrefix() : Requires v1.4.0+
+ *  Reference a prefix (single-usage dictionary) to decompress next frame.
+ *  This is the reverse operation of ZSTD_CCtx_refPrefix(),
+ *  and must use the same prefix as the one used during compression.
+ *  Prefix is **only used once**. Reference is discarded at end of frame.
+ *  End of frame is reached when ZSTD_decompressStream() returns 0.
+ * @result : 0, or an error code (which can be tested with ZSTD_isError()).
+ *  Note 1 : Adding any prefix (including NULL) invalidates any previously set prefix or dictionary
+ *  Note 2 : Prefix buffer is referenced. It **must** outlive decompression.
+ *           Prefix buffer must remain unmodified up to the end of frame,
+ *           reached when ZSTD_decompressStream() returns 0.
+ *  Note 3 : By default, the prefix is treated as raw content (ZSTD_dct_rawContent).
+ *           Use ZSTD_CCtx_refPrefix_advanced() to alter dictMode (Experimental section)
+ *  Note 4 : Referencing a raw content prefix has almost no cpu nor memory cost.
+ *           A full dictionary is more costly, as it requires building tables.
+ */
+ZSTDLIB_API size_t ZSTD_DCtx_refPrefix(ZSTD_DCtx* dctx,
+                                 const void* prefix, size_t prefixSize);
+
+/* ===   Memory management   === */
+
+/*! ZSTD_sizeof_*() : Requires v1.4.0+
+ *  These functions give the _current_ memory usage of selected object.
+ *  Note that object memory usage can evolve (increase or decrease) over time. */
+ZSTDLIB_API size_t ZSTD_sizeof_CCtx(const ZSTD_CCtx* cctx);
+ZSTDLIB_API size_t ZSTD_sizeof_DCtx(const ZSTD_DCtx* dctx);
+ZSTDLIB_API size_t ZSTD_sizeof_CStream(const ZSTD_CStream* zcs);
+ZSTDLIB_API size_t ZSTD_sizeof_DStream(const ZSTD_DStream* zds);
+ZSTDLIB_API size_t ZSTD_sizeof_CDict(const ZSTD_CDict* cdict);
+ZSTDLIB_API size_t ZSTD_sizeof_DDict(const ZSTD_DDict* ddict);
+
+#endif  /* ZSTD_H_235446 */
+
+
+/* **************************************************************************************
+ *   ADVANCED AND EXPERIMENTAL FUNCTIONS
+ ****************************************************************************************
+ * The definitions in the following section are considered experimental.
+ * They are provided for advanced scenarios.
+ * They should never be used with a dynamic library, as prototypes may change in the future.
+ * Use them only in association with static linking.
+ * ***************************************************************************************/
+
+#if defined(ZSTD_STATIC_LINKING_ONLY) && !defined(ZSTD_H_ZSTD_STATIC_LINKING_ONLY)
+#define ZSTD_H_ZSTD_STATIC_LINKING_ONLY
+
+/* This can be overridden externally to hide static symbols. */
+#ifndef ZSTDLIB_STATIC_API
+#  if defined(ZSTD_DLL_EXPORT) && (ZSTD_DLL_EXPORT==1)
+#    define ZSTDLIB_STATIC_API __declspec(dllexport) ZSTDLIB_VISIBLE
+#  elif defined(ZSTD_DLL_IMPORT) && (ZSTD_DLL_IMPORT==1)
+#    define ZSTDLIB_STATIC_API __declspec(dllimport) ZSTDLIB_VISIBLE
+#  else
+#    define ZSTDLIB_STATIC_API ZSTDLIB_VISIBLE
+#  endif
+#endif
+
+/****************************************************************************************
+ *   experimental API (static linking only)
+ ****************************************************************************************
+ * The following symbols and constants
+ * are not planned to join "stable API" status in the near future.
+ * They can still change in future versions.
+ * Some of them are planned to remain in the static_only section indefinitely.
+ * Some of them might be removed in the future (especially when redundant with existing stable functions)
+ * ***************************************************************************************/
+
+#define ZSTD_FRAMEHEADERSIZE_PREFIX(format) ((format) == ZSTD_f_zstd1 ? 5 : 1)   /* minimum input size required to query frame header size */
+#define ZSTD_FRAMEHEADERSIZE_MIN(format)    ((format) == ZSTD_f_zstd1 ? 6 : 2)
+#define ZSTD_FRAMEHEADERSIZE_MAX   18   /* can be useful for static allocation */
+#define ZSTD_SKIPPABLEHEADERSIZE    8
+
+/* compression parameter bounds */
+#define ZSTD_WINDOWLOG_MAX_32    30
+#define ZSTD_WINDOWLOG_MAX_64    31
+#define ZSTD_WINDOWLOG_MAX     ((int)(sizeof(size_t) == 4 ? ZSTD_WINDOWLOG_MAX_32 : ZSTD_WINDOWLOG_MAX_64))
+#define ZSTD_WINDOWLOG_MIN       10
+#define ZSTD_HASHLOG_MAX       ((ZSTD_WINDOWLOG_MAX < 30) ? ZSTD_WINDOWLOG_MAX : 30)
+#define ZSTD_HASHLOG_MIN          6
+#define ZSTD_CHAINLOG_MAX_32     29
+#define ZSTD_CHAINLOG_MAX_64     30
+#define ZSTD_CHAINLOG_MAX      ((int)(sizeof(size_t) == 4 ? ZSTD_CHAINLOG_MAX_32 : ZSTD_CHAINLOG_MAX_64))
+#define ZSTD_CHAINLOG_MIN        ZSTD_HASHLOG_MIN
+#define ZSTD_SEARCHLOG_MAX      (ZSTD_WINDOWLOG_MAX-1)
+#define ZSTD_SEARCHLOG_MIN        1
+#define ZSTD_MINMATCH_MAX         7   /* only for ZSTD_fast, other strategies are limited to 6 */
+#define ZSTD_MINMATCH_MIN         3   /* only for ZSTD_btopt+, faster strategies are limited to 4 */
+#define ZSTD_TARGETLENGTH_MAX    ZSTD_BLOCKSIZE_MAX
+#define ZSTD_TARGETLENGTH_MIN     0   /* note : comparing this constant to an unsigned results in a tautological test */
+#define ZSTD_STRATEGY_MIN        ZSTD_fast
+#define ZSTD_STRATEGY_MAX        ZSTD_btultra2
+#define ZSTD_BLOCKSIZE_MAX_MIN (1 << 10) /* The minimum valid max blocksize. Maximum blocksizes smaller than this make compressBound() inaccurate. */
+
+
+#define ZSTD_OVERLAPLOG_MIN       0
+#define ZSTD_OVERLAPLOG_MAX       9
+
+#define ZSTD_WINDOWLOG_LIMIT_DEFAULT 27   /* by default, the streaming decoder will refuse any frame
+                                           * requiring larger than (1<<ZSTD_WINDOWLOG_LIMIT_DEFAULT) window size,
+                                           * to preserve host's memory from unreasonable requirements.
+                                           * This limit can be overridden using ZSTD_DCtx_setParameter(,ZSTD_d_windowLogMax,).
+                                           * The limit does not apply for one-pass decoders (such as ZSTD_decompress()), since no additional memory is allocated */
+
+
+/* LDM parameter bounds */
+#define ZSTD_LDM_HASHLOG_MIN      ZSTD_HASHLOG_MIN
+#define ZSTD_LDM_HASHLOG_MAX      ZSTD_HASHLOG_MAX
+#define ZSTD_LDM_MINMATCH_MIN        4
+#define ZSTD_LDM_MINMATCH_MAX     4096
+#define ZSTD_LDM_BUCKETSIZELOG_MIN   1
+#define ZSTD_LDM_BUCKETSIZELOG_MAX   8
+#define ZSTD_LDM_HASHRATELOG_MIN     0
+#define ZSTD_LDM_HASHRATELOG_MAX (ZSTD_WINDOWLOG_MAX - ZSTD_HASHLOG_MIN)
+
+/* Advanced parameter bounds */
+#define ZSTD_TARGETCBLOCKSIZE_MIN   64
+#define ZSTD_TARGETCBLOCKSIZE_MAX   ZSTD_BLOCKSIZE_MAX
+#define ZSTD_SRCSIZEHINT_MIN        0
+#define ZSTD_SRCSIZEHINT_MAX        INT_MAX
+
+
+/* ---  Advanced types  --- */
+
+typedef struct ZSTD_CCtx_params_s ZSTD_CCtx_params;
+
+typedef struct {
+    unsigned int offset;      /* The offset of the match. (NOT the same as the offset code)
+                               * If offset == 0 and matchLength == 0, this sequence represents the last
+                               * literals in the block of litLength size.
+                               */
+
+    unsigned int litLength;   /* Literal length of the sequence. */
+    unsigned int matchLength; /* Match length of the sequence. */
+
+                              /* Note: Users of this API may provide a sequence with matchLength == litLength == offset == 0.
+                               * In this case, we will treat the sequence as a marker for a block boundary.
+                               */
+
+    unsigned int rep;         /* Represents which repeat offset is represented by the field 'offset'.
+                               * Ranges from [0, 3].
+                               *
+                               * Repeat offsets are essentially previous offsets from previous sequences sorted in
+                               * recency order. For more detail, see doc/zstd_compression_format.md
+                               *
+                               * If rep == 0, then 'offset' does not contain a repeat offset.
+                               * If rep > 0:
+                               *  If litLength != 0:
+                               *      rep == 1 --> offset == repeat_offset_1
+                               *      rep == 2 --> offset == repeat_offset_2
+                               *      rep == 3 --> offset == repeat_offset_3
+                               *  If litLength == 0:
+                               *      rep == 1 --> offset == repeat_offset_2
+                               *      rep == 2 --> offset == repeat_offset_3
+                               *      rep == 3 --> offset == repeat_offset_1 - 1
+                               *
+                               * Note: This field is optional. ZSTD_generateSequences() will calculate the value of
+                               * 'rep', but repeat offsets do not necessarily need to be calculated from an external
+                               * sequence provider's perspective. For example, ZSTD_compressSequences() does not
+                               * use this 'rep' field at all (as of now).
+                               */
+} ZSTD_Sequence;
+
+typedef struct {
+    unsigned windowLog;       /**< largest match distance : larger == more compression, more memory needed during decompression */
+    unsigned chainLog;        /**< fully searched segment : larger == more compression, slower, more memory (useless for fast) */
+    unsigned hashLog;         /**< dispatch table : larger == faster, more memory */
+    unsigned searchLog;       /**< nb of searches : larger == more compression, slower */
+    unsigned minMatch;        /**< match length searched : larger == faster decompression, sometimes less compression */
+    unsigned targetLength;    /**< acceptable match size for optimal parser (only) : larger == more compression, slower */
+    ZSTD_strategy strategy;   /**< see ZSTD_strategy definition above */
+} ZSTD_compressionParameters;
+
+typedef struct {
+    int contentSizeFlag; /**< 1: content size will be in frame header (when known) */
+    int checksumFlag;    /**< 1: generate a 32-bits checksum using XXH64 algorithm at end of frame, for error detection */
+    int noDictIDFlag;    /**< 1: no dictID will be saved into frame header (dictID is only useful for dictionary compression) */
+} ZSTD_frameParameters;
+
+typedef struct {
+    ZSTD_compressionParameters cParams;
+    ZSTD_frameParameters fParams;
+} ZSTD_parameters;
+
+typedef enum {
+    ZSTD_dct_auto = 0,       /* dictionary is "full" when starting with ZSTD_MAGIC_DICTIONARY, otherwise it is "rawContent" */
+    ZSTD_dct_rawContent = 1, /* ensures dictionary is always loaded as rawContent, even if it starts with ZSTD_MAGIC_DICTIONARY */
+    ZSTD_dct_fullDict = 2    /* refuses to load a dictionary if it does not respect Zstandard's specification, starting with ZSTD_MAGIC_DICTIONARY */
+} ZSTD_dictContentType_e;
+
+typedef enum {
+    ZSTD_dlm_byCopy = 0,  /**< Copy dictionary content internally */
+    ZSTD_dlm_byRef = 1    /**< Reference dictionary content -- the dictionary buffer must outlive its users. */
+} ZSTD_dictLoadMethod_e;
+
+typedef enum {
+    ZSTD_f_zstd1 = 0,           /* zstd frame format, specified in zstd_compression_format.md (default) */
+    ZSTD_f_zstd1_magicless = 1  /* Variant of zstd frame format, without initial 4-bytes magic number.
+                                 * Useful to save 4 bytes per generated frame.
+                                 * Decoder cannot recognise automatically this format, requiring this instruction. */
+} ZSTD_format_e;
+
+typedef enum {
+    /* Note: this enum controls ZSTD_d_forceIgnoreChecksum */
+    ZSTD_d_validateChecksum = 0,
+    ZSTD_d_ignoreChecksum = 1
+} ZSTD_forceIgnoreChecksum_e;
+
+typedef enum {
+    /* Note: this enum controls ZSTD_d_refMultipleDDicts */
+    ZSTD_rmd_refSingleDDict = 0,
+    ZSTD_rmd_refMultipleDDicts = 1
+} ZSTD_refMultipleDDicts_e;
+
+typedef enum {
+    /* Note: this enum and the behavior it controls are effectively internal
+     * implementation details of the compressor. They are expected to continue
+     * to evolve and should be considered only in the context of extremely
+     * advanced performance tuning.
+     *
+     * Zstd currently supports the use of a CDict in three ways:
+     *
+     * - The contents of the CDict can be copied into the working context. This
+     *   means that the compression can search both the dictionary and input
+     *   while operating on a single set of internal tables. This makes
+     *   the compression faster per-byte of input. However, the initial copy of
+     *   the CDict's tables incurs a fixed cost at the beginning of the
+     *   compression. For small compressions (< 8 KB), that copy can dominate
+     *   the cost of the compression.
+     *
+     * - The CDict's tables can be used in-place. In this model, compression is
+     *   slower per input byte, because the compressor has to search two sets of
+     *   tables. However, this model incurs no start-up cost (as long as the
+     *   working context's tables can be reused). For small inputs, this can be
+     *   faster than copying the CDict's tables.
+     *
+     * - The CDict's tables are not used at all, and instead we use the working
+     *   context alone to reload the dictionary and use params based on the source
+     *   size. See ZSTD_compress_insertDictionary() and ZSTD_compress_usingDict().
+     *   This method is effective when the dictionary sizes are very small relative
+     *   to the input size, and the input size is fairly large to begin with.
+     *
+     * Zstd has a simple internal heuristic that selects which strategy to use
+     * at the beginning of a compression. However, if experimentation shows that
+     * Zstd is making poor choices, it is possible to override that choice with
+     * this enum.
+     */
+    ZSTD_dictDefaultAttach = 0, /* Use the default heuristic. */
+    ZSTD_dictForceAttach   = 1, /* Never copy the dictionary. */
+    ZSTD_dictForceCopy     = 2, /* Always copy the dictionary. */
+    ZSTD_dictForceLoad     = 3  /* Always reload the dictionary */
+} ZSTD_dictAttachPref_e;
+
+typedef enum {
+  ZSTD_lcm_auto = 0,          /**< Automatically determine the compression mode based on the compression level.
+                               *   Negative compression levels will be uncompressed, and positive compression
+                               *   levels will be compressed. */
+  ZSTD_lcm_huffman = 1,       /**< Always attempt Huffman compression. Uncompressed literals will still be
+                               *   emitted if Huffman compression is not profitable. */
+  ZSTD_lcm_uncompressed = 2   /**< Always emit uncompressed literals. */
+} ZSTD_literalCompressionMode_e;
+
+typedef enum {
+  /* Note: This enum controls features which are conditionally beneficial. Zstd typically will make a final
+   * decision on whether or not to enable the feature (ZSTD_ps_auto), but setting the switch to ZSTD_ps_enable
+   * or ZSTD_ps_disable allow for a force enable/disable the feature.
+   */
+  ZSTD_ps_auto = 0,         /* Let the library automatically determine whether the feature shall be enabled */
+  ZSTD_ps_enable = 1,       /* Force-enable the feature */
+  ZSTD_ps_disable = 2       /* Do not use the feature */
+} ZSTD_paramSwitch_e;
+
+/***************************************
+*  Frame header and size functions
+***************************************/
+
+/*! ZSTD_findDecompressedSize() :
+ *  `src` should point to the start of a series of ZSTD encoded and/or skippable frames
+ *  `srcSize` must be the _exact_ size of this series
+ *       (i.e. there should be a frame boundary at `src + srcSize`)
+ *  @return : - decompressed size of all data in all successive frames
+ *            - if the decompressed size cannot be determined: ZSTD_CONTENTSIZE_UNKNOWN
+ *            - if an error occurred: ZSTD_CONTENTSIZE_ERROR
+ *
+ *   note 1 : decompressed size is an optional field, that may not be present, especially in streaming mode.
+ *            When `return==ZSTD_CONTENTSIZE_UNKNOWN`, data to decompress could be any size.
+ *            In which case, it's necessary to use streaming mode to decompress data.
+ *   note 2 : decompressed size is always present when compression is done with ZSTD_compress()
+ *   note 3 : decompressed size can be very large (64-bits value),
+ *            potentially larger than what local system can handle as a single memory segment.
+ *            In which case, it's necessary to use streaming mode to decompress data.
+ *   note 4 : If source is untrusted, decompressed size could be wrong or intentionally modified.
+ *            Always ensure result fits within application's authorized limits.
+ *            Each application can set its own limits.
+ *   note 5 : ZSTD_findDecompressedSize handles multiple frames, and so it must traverse the input to
+ *            read each contained frame header.  This is fast as most of the data is skipped,
+ *            however it does mean that all frame data must be present and valid. */
+ZSTDLIB_STATIC_API unsigned long long ZSTD_findDecompressedSize(const void* src, size_t srcSize);
+
+/*! ZSTD_decompressBound() :
+ *  `src` should point to the start of a series of ZSTD encoded and/or skippable frames
+ *  `srcSize` must be the _exact_ size of this series
+ *       (i.e. there should be a frame boundary at `src + srcSize`)
+ *  @return : - upper-bound for the decompressed size of all data in all successive frames
+ *            - if an error occurred: ZSTD_CONTENTSIZE_ERROR
+ *
+ *  note 1  : an error can occur if `src` contains an invalid or incorrectly formatted frame.
+ *  note 2  : the upper-bound is exact when the decompressed size field is available in every ZSTD encoded frame of `src`.
+ *            in this case, `ZSTD_findDecompressedSize` and `ZSTD_decompressBound` return the same value.
+ *  note 3  : when the decompressed size field isn't available, the upper-bound for that frame is calculated by:
+ *              upper-bound = # blocks * min(128 KB, Window_Size)
+ */
+ZSTDLIB_STATIC_API unsigned long long ZSTD_decompressBound(const void* src, size_t srcSize);
+
+/*! ZSTD_frameHeaderSize() :
+ *  srcSize must be >= ZSTD_FRAMEHEADERSIZE_PREFIX.
+ * @return : size of the Frame Header,
+ *           or an error code (if srcSize is too small) */
+ZSTDLIB_STATIC_API size_t ZSTD_frameHeaderSize(const void* src, size_t srcSize);
+
+typedef enum { ZSTD_frame, ZSTD_skippableFrame } ZSTD_frameType_e;
+typedef struct {
+    unsigned long long frameContentSize; /* if == ZSTD_CONTENTSIZE_UNKNOWN, it means this field is not available. 0 means "empty" */
+    unsigned long long windowSize;       /* can be very large, up to <= frameContentSize */
+    unsigned blockSizeMax;
+    ZSTD_frameType_e frameType;          /* if == ZSTD_skippableFrame, frameContentSize is the size of skippable content */
+    unsigned headerSize;
+    unsigned dictID;
+    unsigned checksumFlag;
+    unsigned _reserved1;
+    unsigned _reserved2;
+} ZSTD_frameHeader;
+
+/*! ZSTD_getFrameHeader() :
+ *  decode Frame Header, or requires larger `srcSize`.
+ * @return : 0, `zfhPtr` is correctly filled,
+ *          >0, `srcSize` is too small, value is wanted `srcSize` amount,
+ *           or an error code, which can be tested using ZSTD_isError() */
+ZSTDLIB_STATIC_API size_t ZSTD_getFrameHeader(ZSTD_frameHeader* zfhPtr, const void* src, size_t srcSize);   /**< doesn't consume input */
+/*! ZSTD_getFrameHeader_advanced() :
+ *  same as ZSTD_getFrameHeader(),
+ *  with added capability to select a format (like ZSTD_f_zstd1_magicless) */
+ZSTDLIB_STATIC_API size_t ZSTD_getFrameHeader_advanced(ZSTD_frameHeader* zfhPtr, const void* src, size_t srcSize, ZSTD_format_e format);
+
+/*! ZSTD_decompressionMargin() :
+ * Zstd supports in-place decompression, where the input and output buffers overlap.
+ * In this case, the output buffer must be at least (Margin + Output_Size) bytes large,
+ * and the input buffer must be at the end of the output buffer.
+ *
+ *  _______________________ Output Buffer ________________________
+ * |                                                              |
+ * |                                        ____ Input Buffer ____|
+ * |                                       |                      |
+ * v                                       v                      v
+ * |---------------------------------------|-----------|----------|
+ * ^                                                   ^          ^
+ * |___________________ Output_Size ___________________|_ Margin _|
+ *
+ * NOTE: See also ZSTD_DECOMPRESSION_MARGIN().
+ * NOTE: This applies only to single-pass decompression through ZSTD_decompress() or
+ * ZSTD_decompressDCtx().
+ * NOTE: This function supports multi-frame input.
+ *
+ * @param src The compressed frame(s)
+ * @param srcSize The size of the compressed frame(s)
+ * @returns The decompression margin or an error that can be checked with ZSTD_isError().
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_decompressionMargin(const void* src, size_t srcSize);
+
+/*! ZSTD_DECOMPRESS_MARGIN() :
+ * Similar to ZSTD_decompressionMargin(), but instead of computing the margin from
+ * the compressed frame, compute it from the original size and the blockSizeLog.
+ * See ZSTD_decompressionMargin() for details.
+ *
+ * WARNING: This macro does not support multi-frame input, the input must be a single
+ * zstd frame. If you need that support use the function, or implement it yourself.
+ *
+ * @param originalSize The original uncompressed size of the data.
+ * @param blockSize    The block size == MIN(windowSize, ZSTD_BLOCKSIZE_MAX).
+ *                     Unless you explicitly set the windowLog smaller than
+ *                     ZSTD_BLOCKSIZELOG_MAX you can just use ZSTD_BLOCKSIZE_MAX.
+ */
+#define ZSTD_DECOMPRESSION_MARGIN(originalSize, blockSize) ((size_t)(                                              \
+        ZSTD_FRAMEHEADERSIZE_MAX                                                              /* Frame header */ + \
+        4                                                                                         /* checksum */ + \
+        ((originalSize) == 0 ? 0 : 3 * (((originalSize) + (blockSize) - 1) / blockSize)) /* 3 bytes per block */ + \
+        (blockSize)                                                                    /* One block of margin */   \
+    ))
+
+typedef enum {
+  ZSTD_sf_noBlockDelimiters = 0,         /* Representation of ZSTD_Sequence has no block delimiters, sequences only */
+  ZSTD_sf_explicitBlockDelimiters = 1    /* Representation of ZSTD_Sequence contains explicit block delimiters */
+} ZSTD_sequenceFormat_e;
+
+/*! ZSTD_sequenceBound() :
+ * `srcSize` : size of the input buffer
+ *  @return : upper-bound for the number of sequences that can be generated
+ *            from a buffer of srcSize bytes
+ *
+ *  note : returns number of sequences - to get bytes, multiply by sizeof(ZSTD_Sequence).
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_sequenceBound(size_t srcSize);
+
+/*! ZSTD_generateSequences() :
+ * Generate sequences using ZSTD_compress2(), given a source buffer.
+ *
+ * Each block will end with a dummy sequence
+ * with offset == 0, matchLength == 0, and litLength == length of last literals.
+ * litLength may be == 0, and if so, then the sequence of (of: 0 ml: 0 ll: 0)
+ * simply acts as a block delimiter.
+ *
+ * @zc can be used to insert custom compression params.
+ * This function invokes ZSTD_compress2().
+ *
+ * The output of this function can be fed into ZSTD_compressSequences() with CCtx
+ * setting of ZSTD_c_blockDelimiters as ZSTD_sf_explicitBlockDelimiters
+ * @return : number of sequences generated
+ */
+
+ZSTDLIB_STATIC_API size_t
+ZSTD_generateSequences( ZSTD_CCtx* zc,
+                        ZSTD_Sequence* outSeqs, size_t outSeqsSize,
+                        const void* src, size_t srcSize);
+
+/*! ZSTD_mergeBlockDelimiters() :
+ * Given an array of ZSTD_Sequence, remove all sequences that represent block delimiters/last literals
+ * by merging them into the literals of the next sequence.
+ *
+ * As such, the final generated result has no explicit representation of block boundaries,
+ * and the final last literals segment is not represented in the sequences.
+ *
+ * The output of this function can be fed into ZSTD_compressSequences() with CCtx
+ * setting of ZSTD_c_blockDelimiters as ZSTD_sf_noBlockDelimiters
+ * @return : number of sequences left after merging
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_mergeBlockDelimiters(ZSTD_Sequence* sequences, size_t seqsSize);
+
+/*! ZSTD_compressSequences() :
+ * Compress an array of ZSTD_Sequence, associated with @src buffer, into dst.
+ * @src contains the entire input (not just the literals).
+ * If @srcSize > sum(sequence.length), the remaining bytes are considered all literals
+ * If a dictionary is included, then the cctx should reference the dict. (see: ZSTD_CCtx_refCDict(), ZSTD_CCtx_loadDictionary(), etc.)
+ * The entire source is compressed into a single frame.
+ *
+ * The compression behavior changes based on cctx params. In particular:
+ *    If ZSTD_c_blockDelimiters == ZSTD_sf_noBlockDelimiters, the array of ZSTD_Sequence is expected to contain
+ *    no block delimiters (defined in ZSTD_Sequence). Block boundaries are roughly determined based on
+ *    the block size derived from the cctx, and sequences may be split. This is the default setting.
+ *
+ *    If ZSTD_c_blockDelimiters == ZSTD_sf_explicitBlockDelimiters, the array of ZSTD_Sequence is expected to contain
+ *    block delimiters (defined in ZSTD_Sequence). Behavior is undefined if no block delimiters are provided.
+ *
+ *    If ZSTD_c_validateSequences == 0, this function will blindly accept the sequences provided. Invalid sequences cause undefined
+ *    behavior. If ZSTD_c_validateSequences == 1, then if sequence is invalid (see doc/zstd_compression_format.md for
+ *    specifics regarding offset/matchlength requirements) then the function will bail out and return an error.
+ *
+ *    In addition to the two adjustable experimental params, there are other important cctx params.
+ *    - ZSTD_c_minMatch MUST be set as less than or equal to the smallest match generated by the match finder. It has a minimum value of ZSTD_MINMATCH_MIN.
+ *    - ZSTD_c_compressionLevel accordingly adjusts the strength of the entropy coder, as it would in typical compression.
+ *    - ZSTD_c_windowLog affects offset validation: this function will return an error at higher debug levels if a provided offset
+ *      is larger than what the spec allows for a given window log and dictionary (if present). See: doc/zstd_compression_format.md
+ *
+ * Note: Repcodes are, as of now, always re-calculated within this function, so ZSTD_Sequence::rep is unused.
+ * Note 2: Once we integrate ability to ingest repcodes, the explicit block delims mode must respect those repcodes exactly,
+ *         and cannot emit an RLE block that disagrees with the repcode history
+ * @return : final compressed size, or a ZSTD error code.
+ */
+ZSTDLIB_STATIC_API size_t
+ZSTD_compressSequences( ZSTD_CCtx* cctx, void* dst, size_t dstSize,
+                        const ZSTD_Sequence* inSeqs, size_t inSeqsSize,
+                        const void* src, size_t srcSize);
+
+
+/*! ZSTD_writeSkippableFrame() :
+ * Generates a zstd skippable frame containing data given by src, and writes it to dst buffer.
+ *
+ * Skippable frames begin with a 4-byte magic number. There are 16 possible choices of magic number,
+ * ranging from ZSTD_MAGIC_SKIPPABLE_START to ZSTD_MAGIC_SKIPPABLE_START+15.
+ * As such, the parameter magicVariant controls the exact skippable frame magic number variant used, so
+ * the magic number used will be ZSTD_MAGIC_SKIPPABLE_START + magicVariant.
+ *
+ * Returns an error if destination buffer is not large enough, if the source size is not representable
+ * with a 4-byte unsigned int, or if the parameter magicVariant is greater than 15 (and therefore invalid).
+ *
+ * @return : number of bytes written or a ZSTD error.
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_writeSkippableFrame(void* dst, size_t dstCapacity,
+                                            const void* src, size_t srcSize, unsigned magicVariant);
+
+/*! ZSTD_readSkippableFrame() :
+ * Retrieves a zstd skippable frame containing data given by src, and writes it to dst buffer.
+ *
+ * The parameter magicVariant will receive the magicVariant that was supplied when the frame was written,
+ * i.e. magicNumber - ZSTD_MAGIC_SKIPPABLE_START.  This can be NULL if the caller is not interested
+ * in the magicVariant.
+ *
+ * Returns an error if destination buffer is not large enough, or if the frame is not skippable.
+ *
+ * @return : number of bytes written or a ZSTD error.
+ */
+ZSTDLIB_API size_t ZSTD_readSkippableFrame(void* dst, size_t dstCapacity, unsigned* magicVariant,
+                                            const void* src, size_t srcSize);
+
+/*! ZSTD_isSkippableFrame() :
+ *  Tells if the content of `buffer` starts with a valid Frame Identifier for a skippable frame.
+ */
+ZSTDLIB_API unsigned ZSTD_isSkippableFrame(const void* buffer, size_t size);
+
+
+
+/***************************************
+*  Memory management
+***************************************/
+
+/*! ZSTD_estimate*() :
+ *  These functions make it possible to estimate memory usage
+ *  of a future {D,C}Ctx, before its creation.
+ *
+ *  ZSTD_estimateCCtxSize() will provide a memory budget large enough
+ *  for any compression level up to selected one.
+ *  Note : Unlike ZSTD_estimateCStreamSize*(), this estimate
+ *         does not include space for a window buffer.
+ *         Therefore, the estimation is only guaranteed for single-shot compressions, not streaming.
+ *  The estimate will assume the input may be arbitrarily large,
+ *  which is the worst case.
+ *
+ *  When srcSize can be bound by a known and rather "small" value,
+ *  this fact can be used to provide a tighter estimation
+ *  because the CCtx compression context will need less memory.
+ *  This tighter estimation can be provided by more advanced functions
+ *  ZSTD_estimateCCtxSize_usingCParams(), which can be used in tandem with ZSTD_getCParams(),
+ *  and ZSTD_estimateCCtxSize_usingCCtxParams(), which can be used in tandem with ZSTD_CCtxParams_setParameter().
+ *  Both can be used to estimate memory using custom compression parameters and arbitrary srcSize limits.
+ *
+ *  Note : only single-threaded compression is supported.
+ *  ZSTD_estimateCCtxSize_usingCCtxParams() will return an error code if ZSTD_c_nbWorkers is >= 1.
+ *
+ *  Note 2 : ZSTD_estimateCCtxSize* functions are not compatible with the Block-Level Sequence Producer API at this time.
+ *  Size estimates assume that no external sequence producer is registered.
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_estimateCCtxSize(int compressionLevel);
+ZSTDLIB_STATIC_API size_t ZSTD_estimateCCtxSize_usingCParams(ZSTD_compressionParameters cParams);
+ZSTDLIB_STATIC_API size_t ZSTD_estimateCCtxSize_usingCCtxParams(const ZSTD_CCtx_params* params);
+ZSTDLIB_STATIC_API size_t ZSTD_estimateDCtxSize(void);
+
+/*! ZSTD_estimateCStreamSize() :
+ *  ZSTD_estimateCStreamSize() will provide a budget large enough for any compression level up to selected one.
+ *  It will also consider src size to be arbitrarily "large", which is worst case.
+ *  If srcSize is known to always be small, ZSTD_estimateCStreamSize_usingCParams() can provide a tighter estimation.
+ *  ZSTD_estimateCStreamSize_usingCParams() can be used in tandem with ZSTD_getCParams() to create cParams from compressionLevel.
+ *  ZSTD_estimateCStreamSize_usingCCtxParams() can be used in tandem with ZSTD_CCtxParams_setParameter(). Only single-threaded compression is supported. This function will return an error code if ZSTD_c_nbWorkers is >= 1.
+ *  Note : CStream size estimation is only correct for single-threaded compression.
+ *  ZSTD_DStream memory budget depends on window Size.
+ *  This information can be passed manually, using ZSTD_estimateDStreamSize,
+ *  or deducted from a valid frame Header, using ZSTD_estimateDStreamSize_fromFrame();
+ *  Note : if streaming is init with function ZSTD_init?Stream_usingDict(),
+ *         an internal ?Dict will be created, which additional size is not estimated here.
+ *         In this case, get total size by adding ZSTD_estimate?DictSize
+ *  Note 2 : only single-threaded compression is supported.
+ *  ZSTD_estimateCStreamSize_usingCCtxParams() will return an error code if ZSTD_c_nbWorkers is >= 1.
+ *  Note 3 : ZSTD_estimateCStreamSize* functions are not compatible with the Block-Level Sequence Producer API at this time.
+ *  Size estimates assume that no external sequence producer is registered.
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_estimateCStreamSize(int compressionLevel);
+ZSTDLIB_STATIC_API size_t ZSTD_estimateCStreamSize_usingCParams(ZSTD_compressionParameters cParams);
+ZSTDLIB_STATIC_API size_t ZSTD_estimateCStreamSize_usingCCtxParams(const ZSTD_CCtx_params* params);
+ZSTDLIB_STATIC_API size_t ZSTD_estimateDStreamSize(size_t windowSize);
+ZSTDLIB_STATIC_API size_t ZSTD_estimateDStreamSize_fromFrame(const void* src, size_t srcSize);
+
+/*! ZSTD_estimate?DictSize() :
+ *  ZSTD_estimateCDictSize() will bet that src size is relatively "small", and content is copied, like ZSTD_createCDict().
+ *  ZSTD_estimateCDictSize_advanced() makes it possible to control compression parameters precisely, like ZSTD_createCDict_advanced().
+ *  Note : dictionaries created by reference (`ZSTD_dlm_byRef`) are logically smaller.
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_estimateCDictSize(size_t dictSize, int compressionLevel);
+ZSTDLIB_STATIC_API size_t ZSTD_estimateCDictSize_advanced(size_t dictSize, ZSTD_compressionParameters cParams, ZSTD_dictLoadMethod_e dictLoadMethod);
+ZSTDLIB_STATIC_API size_t ZSTD_estimateDDictSize(size_t dictSize, ZSTD_dictLoadMethod_e dictLoadMethod);
+
+/*! ZSTD_initStatic*() :
+ *  Initialize an object using a pre-allocated fixed-size buffer.
+ *  workspace: The memory area to emplace the object into.
+ *             Provided pointer *must be 8-bytes aligned*.
+ *             Buffer must outlive object.
+ *  workspaceSize: Use ZSTD_estimate*Size() to determine
+ *                 how large workspace must be to support target scenario.
+ * @return : pointer to object (same address as workspace, just different type),
+ *           or NULL if error (size too small, incorrect alignment, etc.)
+ *  Note : zstd will never resize nor malloc() when using a static buffer.
+ *         If the object requires more memory than available,
+ *         zstd will just error out (typically ZSTD_error_memory_allocation).
+ *  Note 2 : there is no corresponding "free" function.
+ *           Since workspace is allocated externally, it must be freed externally too.
+ *  Note 3 : cParams : use ZSTD_getCParams() to convert a compression level
+ *           into its associated cParams.
+ *  Limitation 1 : currently not compatible with internal dictionary creation, triggered by
+ *                 ZSTD_CCtx_loadDictionary(), ZSTD_initCStream_usingDict() or ZSTD_initDStream_usingDict().
+ *  Limitation 2 : static cctx currently not compatible with multi-threading.
+ *  Limitation 3 : static dctx is incompatible with legacy support.
+ */
+ZSTDLIB_STATIC_API ZSTD_CCtx*    ZSTD_initStaticCCtx(void* workspace, size_t workspaceSize);
+ZSTDLIB_STATIC_API ZSTD_CStream* ZSTD_initStaticCStream(void* workspace, size_t workspaceSize);    /**< same as ZSTD_initStaticCCtx() */
+
+ZSTDLIB_STATIC_API ZSTD_DCtx*    ZSTD_initStaticDCtx(void* workspace, size_t workspaceSize);
+ZSTDLIB_STATIC_API ZSTD_DStream* ZSTD_initStaticDStream(void* workspace, size_t workspaceSize);    /**< same as ZSTD_initStaticDCtx() */
+
+ZSTDLIB_STATIC_API const ZSTD_CDict* ZSTD_initStaticCDict(
+                                        void* workspace, size_t workspaceSize,
+                                        const void* dict, size_t dictSize,
+                                        ZSTD_dictLoadMethod_e dictLoadMethod,
+                                        ZSTD_dictContentType_e dictContentType,
+                                        ZSTD_compressionParameters cParams);
+
+ZSTDLIB_STATIC_API const ZSTD_DDict* ZSTD_initStaticDDict(
+                                        void* workspace, size_t workspaceSize,
+                                        const void* dict, size_t dictSize,
+                                        ZSTD_dictLoadMethod_e dictLoadMethod,
+                                        ZSTD_dictContentType_e dictContentType);
+
+
+/*! Custom memory allocation :
+ *  These prototypes make it possible to pass your own allocation/free functions.
+ *  ZSTD_customMem is provided at creation time, using ZSTD_create*_advanced() variants listed below.
+ *  All allocation/free operations will be completed using these custom variants instead of regular <stdlib.h> ones.
+ */
+typedef void* (*ZSTD_allocFunction) (void* opaque, size_t size);
+typedef void  (*ZSTD_freeFunction) (void* opaque, void* address);
+typedef struct { ZSTD_allocFunction customAlloc; ZSTD_freeFunction customFree; void* opaque; } ZSTD_customMem;
+static
+#ifdef __GNUC__
+__attribute__((__unused__))
+#endif
+ZSTD_customMem const ZSTD_defaultCMem = { NULL, NULL, NULL };  /**< this constant defers to stdlib's functions */
+
+ZSTDLIB_STATIC_API ZSTD_CCtx*    ZSTD_createCCtx_advanced(ZSTD_customMem customMem);
+ZSTDLIB_STATIC_API ZSTD_CStream* ZSTD_createCStream_advanced(ZSTD_customMem customMem);
+ZSTDLIB_STATIC_API ZSTD_DCtx*    ZSTD_createDCtx_advanced(ZSTD_customMem customMem);
+ZSTDLIB_STATIC_API ZSTD_DStream* ZSTD_createDStream_advanced(ZSTD_customMem customMem);
+
+ZSTDLIB_STATIC_API ZSTD_CDict* ZSTD_createCDict_advanced(const void* dict, size_t dictSize,
+                                                  ZSTD_dictLoadMethod_e dictLoadMethod,
+                                                  ZSTD_dictContentType_e dictContentType,
+                                                  ZSTD_compressionParameters cParams,
+                                                  ZSTD_customMem customMem);
+
+/*! Thread pool :
+ *  These prototypes make it possible to share a thread pool among multiple compression contexts.
+ *  This can limit resources for applications with multiple threads where each one uses
+ *  a threaded compression mode (via ZSTD_c_nbWorkers parameter).
+ *  ZSTD_createThreadPool creates a new thread pool with a given number of threads.
+ *  Note that the lifetime of such pool must exist while being used.
+ *  ZSTD_CCtx_refThreadPool assigns a thread pool to a context (use NULL argument value
+ *  to use an internal thread pool).
+ *  ZSTD_freeThreadPool frees a thread pool, accepts NULL pointer.
+ */
+typedef struct POOL_ctx_s ZSTD_threadPool;
+ZSTDLIB_STATIC_API ZSTD_threadPool* ZSTD_createThreadPool(size_t numThreads);
+ZSTDLIB_STATIC_API void ZSTD_freeThreadPool (ZSTD_threadPool* pool);  /* accept NULL pointer */
+ZSTDLIB_STATIC_API size_t ZSTD_CCtx_refThreadPool(ZSTD_CCtx* cctx, ZSTD_threadPool* pool);
+
+
+/*
+ * This API is temporary and is expected to change or disappear in the future!
+ */
+ZSTDLIB_STATIC_API ZSTD_CDict* ZSTD_createCDict_advanced2(
+    const void* dict, size_t dictSize,
+    ZSTD_dictLoadMethod_e dictLoadMethod,
+    ZSTD_dictContentType_e dictContentType,
+    const ZSTD_CCtx_params* cctxParams,
+    ZSTD_customMem customMem);
+
+ZSTDLIB_STATIC_API ZSTD_DDict* ZSTD_createDDict_advanced(
+    const void* dict, size_t dictSize,
+    ZSTD_dictLoadMethod_e dictLoadMethod,
+    ZSTD_dictContentType_e dictContentType,
+    ZSTD_customMem customMem);
+
+
+/***************************************
+*  Advanced compression functions
+***************************************/
+
+/*! ZSTD_createCDict_byReference() :
+ *  Create a digested dictionary for compression
+ *  Dictionary content is just referenced, not duplicated.
+ *  As a consequence, `dictBuffer` **must** outlive CDict,
+ *  and its content must remain unmodified throughout the lifetime of CDict.
+ *  note: equivalent to ZSTD_createCDict_advanced(), with dictLoadMethod==ZSTD_dlm_byRef */
+ZSTDLIB_STATIC_API ZSTD_CDict* ZSTD_createCDict_byReference(const void* dictBuffer, size_t dictSize, int compressionLevel);
+
+/*! ZSTD_getCParams() :
+ * @return ZSTD_compressionParameters structure for a selected compression level and estimated srcSize.
+ * `estimatedSrcSize` value is optional, select 0 if not known */
+ZSTDLIB_STATIC_API ZSTD_compressionParameters ZSTD_getCParams(int compressionLevel, unsigned long long estimatedSrcSize, size_t dictSize);
+
+/*! ZSTD_getParams() :
+ *  same as ZSTD_getCParams(), but @return a full `ZSTD_parameters` object instead of sub-component `ZSTD_compressionParameters`.
+ *  All fields of `ZSTD_frameParameters` are set to default : contentSize=1, checksum=0, noDictID=0 */
+ZSTDLIB_STATIC_API ZSTD_parameters ZSTD_getParams(int compressionLevel, unsigned long long estimatedSrcSize, size_t dictSize);
+
+/*! ZSTD_checkCParams() :
+ *  Ensure param values remain within authorized range.
+ * @return 0 on success, or an error code (can be checked with ZSTD_isError()) */
+ZSTDLIB_STATIC_API size_t ZSTD_checkCParams(ZSTD_compressionParameters params);
+
+/*! ZSTD_adjustCParams() :
+ *  optimize params for a given `srcSize` and `dictSize`.
+ * `srcSize` can be unknown, in which case use ZSTD_CONTENTSIZE_UNKNOWN.
+ * `dictSize` must be `0` when there is no dictionary.
+ *  cPar can be invalid : all parameters will be clamped within valid range in the @return struct.
+ *  This function never fails (wide contract) */
+ZSTDLIB_STATIC_API ZSTD_compressionParameters ZSTD_adjustCParams(ZSTD_compressionParameters cPar, unsigned long long srcSize, size_t dictSize);
+
+/*! ZSTD_CCtx_setCParams() :
+ *  Set all parameters provided within @p cparams into the working @p cctx.
+ *  Note : if modifying parameters during compression (MT mode only),
+ *         note that changes to the .windowLog parameter will be ignored.
+ * @return 0 on success, or an error code (can be checked with ZSTD_isError()).
+ *         On failure, no parameters are updated.
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_CCtx_setCParams(ZSTD_CCtx* cctx, ZSTD_compressionParameters cparams);
+
+/*! ZSTD_CCtx_setFParams() :
+ *  Set all parameters provided within @p fparams into the working @p cctx.
+ * @return 0 on success, or an error code (can be checked with ZSTD_isError()).
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_CCtx_setFParams(ZSTD_CCtx* cctx, ZSTD_frameParameters fparams);
+
+/*! ZSTD_CCtx_setParams() :
+ *  Set all parameters provided within @p params into the working @p cctx.
+ * @return 0 on success, or an error code (can be checked with ZSTD_isError()).
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_CCtx_setParams(ZSTD_CCtx* cctx, ZSTD_parameters params);
+
+/*! ZSTD_compress_advanced() :
+ *  Note : this function is now DEPRECATED.
+ *         It can be replaced by ZSTD_compress2(), in combination with ZSTD_CCtx_setParameter() and other parameter setters.
+ *  This prototype will generate compilation warnings. */
+ZSTD_DEPRECATED("use ZSTD_compress2")
+ZSTDLIB_STATIC_API
+size_t ZSTD_compress_advanced(ZSTD_CCtx* cctx,
+                              void* dst, size_t dstCapacity,
+                        const void* src, size_t srcSize,
+                        const void* dict,size_t dictSize,
+                              ZSTD_parameters params);
+
+/*! ZSTD_compress_usingCDict_advanced() :
+ *  Note : this function is now DEPRECATED.
+ *         It can be replaced by ZSTD_compress2(), in combination with ZSTD_CCtx_loadDictionary() and other parameter setters.
+ *  This prototype will generate compilation warnings. */
+ZSTD_DEPRECATED("use ZSTD_compress2 with ZSTD_CCtx_loadDictionary")
+ZSTDLIB_STATIC_API
+size_t ZSTD_compress_usingCDict_advanced(ZSTD_CCtx* cctx,
+                                              void* dst, size_t dstCapacity,
+                                        const void* src, size_t srcSize,
+                                        const ZSTD_CDict* cdict,
+                                              ZSTD_frameParameters fParams);
+
+
+/*! ZSTD_CCtx_loadDictionary_byReference() :
+ *  Same as ZSTD_CCtx_loadDictionary(), but dictionary content is referenced, instead of being copied into CCtx.
+ *  It saves some memory, but also requires that `dict` outlives its usage within `cctx` */
+ZSTDLIB_STATIC_API size_t ZSTD_CCtx_loadDictionary_byReference(ZSTD_CCtx* cctx, const void* dict, size_t dictSize);
+
+/*! ZSTD_CCtx_loadDictionary_advanced() :
+ *  Same as ZSTD_CCtx_loadDictionary(), but gives finer control over
+ *  how to load the dictionary (by copy ? by reference ?)
+ *  and how to interpret it (automatic ? force raw mode ? full mode only ?) */
+ZSTDLIB_STATIC_API size_t ZSTD_CCtx_loadDictionary_advanced(ZSTD_CCtx* cctx, const void* dict, size_t dictSize, ZSTD_dictLoadMethod_e dictLoadMethod, ZSTD_dictContentType_e dictContentType);
+
+/*! ZSTD_CCtx_refPrefix_advanced() :
+ *  Same as ZSTD_CCtx_refPrefix(), but gives finer control over
+ *  how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?) */
+ZSTDLIB_STATIC_API size_t ZSTD_CCtx_refPrefix_advanced(ZSTD_CCtx* cctx, const void* prefix, size_t prefixSize, ZSTD_dictContentType_e dictContentType);
+
+/* ===   experimental parameters   === */
+/* these parameters can be used with ZSTD_setParameter()
+ * they are not guaranteed to remain supported in the future */
+
+ /* Enables rsyncable mode,
+  * which makes compressed files more rsync friendly
+  * by adding periodic synchronization points to the compressed data.
+  * The target average block size is ZSTD_c_jobSize / 2.
+  * It's possible to modify the job size to increase or decrease
+  * the granularity of the synchronization point.
+  * Once the jobSize is smaller than the window size,
+  * it will result in compression ratio degradation.
+  * NOTE 1: rsyncable mode only works when multithreading is enabled.
+  * NOTE 2: rsyncable performs poorly in combination with long range mode,
+  * since it will decrease the effectiveness of synchronization points,
+  * though mileage may vary.
+  * NOTE 3: Rsyncable mode limits maximum compression speed to ~400 MB/s.
+  * If the selected compression level is already running significantly slower,
+  * the overall speed won't be significantly impacted.
+  */
+ #define ZSTD_c_rsyncable ZSTD_c_experimentalParam1
+
+/* Select a compression format.
+ * The value must be of type ZSTD_format_e.
+ * See ZSTD_format_e enum definition for details */
+#define ZSTD_c_format ZSTD_c_experimentalParam2
+
+/* Force back-reference distances to remain < windowSize,
+ * even when referencing into Dictionary content (default:0) */
+#define ZSTD_c_forceMaxWindow ZSTD_c_experimentalParam3
+
+/* Controls whether the contents of a CDict
+ * are used in place, or copied into the working context.
+ * Accepts values from the ZSTD_dictAttachPref_e enum.
+ * See the comments on that enum for an explanation of the feature. */
+#define ZSTD_c_forceAttachDict ZSTD_c_experimentalParam4
+
+/* Controlled with ZSTD_paramSwitch_e enum.
+ * Default is ZSTD_ps_auto.
+ * Set to ZSTD_ps_disable to never compress literals.
+ * Set to ZSTD_ps_enable to always compress literals. (Note: uncompressed literals
+ * may still be emitted if huffman is not beneficial to use.)
+ *
+ * By default, in ZSTD_ps_auto, the library will decide at runtime whether to use
+ * literals compression based on the compression parameters - specifically,
+ * negative compression levels do not use literal compression.
+ */
+#define ZSTD_c_literalCompressionMode ZSTD_c_experimentalParam5
+
+/* Tries to fit compressed block size to be around targetCBlockSize.
+ * No target when targetCBlockSize == 0.
+ * There is no guarantee on compressed block size (default:0) */
+#define ZSTD_c_targetCBlockSize ZSTD_c_experimentalParam6
+
+/* User's best guess of source size.
+ * Hint is not valid when srcSizeHint == 0.
+ * There is no guarantee that hint is close to actual source size,
+ * but compression ratio may regress significantly if guess considerably underestimates */
+#define ZSTD_c_srcSizeHint ZSTD_c_experimentalParam7
+
+/* Controls whether the new and experimental "dedicated dictionary search
+ * structure" can be used. This feature is still rough around the edges, be
+ * prepared for surprising behavior!
+ *
+ * How to use it:
+ *
+ * When using a CDict, whether to use this feature or not is controlled at
+ * CDict creation, and it must be set in a CCtxParams set passed into that
+ * construction (via ZSTD_createCDict_advanced2()). A compression will then
+ * use the feature or not based on how the CDict was constructed; the value of
+ * this param, set in the CCtx, will have no effect.
+ *
+ * However, when a dictionary buffer is passed into a CCtx, such as via
+ * ZSTD_CCtx_loadDictionary(), this param can be set on the CCtx to control
+ * whether the CDict that is created internally can use the feature or not.
+ *
+ * What it does:
+ *
+ * Normally, the internal data structures of the CDict are analogous to what
+ * would be stored in a CCtx after compressing the contents of a dictionary.
+ * To an approximation, a compression using a dictionary can then use those
+ * data structures to simply continue what is effectively a streaming
+ * compression where the simulated compression of the dictionary left off.
+ * Which is to say, the search structures in the CDict are normally the same
+ * format as in the CCtx.
+ *
+ * It is possible to do better, since the CDict is not like a CCtx: the search
+ * structures are written once during CDict creation, and then are only read
+ * after that, while the search structures in the CCtx are both read and
+ * written as the compression goes along. This means we can choose a search
+ * structure for the dictionary that is read-optimized.
+ *
+ * This feature enables the use of that different structure.
+ *
+ * Note that some of the members of the ZSTD_compressionParameters struct have
+ * different semantics and constraints in the dedicated search structure. It is
+ * highly recommended that you simply set a compression level in the CCtxParams
+ * you pass into the CDict creation call, and avoid messing with the cParams
+ * directly.
+ *
+ * Effects:
+ *
+ * This will only have any effect when the selected ZSTD_strategy
+ * implementation supports this feature. Currently, that's limited to
+ * ZSTD_greedy, ZSTD_lazy, and ZSTD_lazy2.
+ *
+ * Note that this means that the CDict tables can no longer be copied into the
+ * CCtx, so the dict attachment mode ZSTD_dictForceCopy will no longer be
+ * usable. The dictionary can only be attached or reloaded.
+ *
+ * In general, you should expect compression to be faster--sometimes very much
+ * so--and CDict creation to be slightly slower. Eventually, we will probably
+ * make this mode the default.
+ */
+#define ZSTD_c_enableDedicatedDictSearch ZSTD_c_experimentalParam8
+
+/* ZSTD_c_stableInBuffer
+ * Experimental parameter.
+ * Default is 0 == disabled. Set to 1 to enable.
+ *
+ * Tells the compressor that input data presented with ZSTD_inBuffer
+ * will ALWAYS be the same between calls.
+ * Technically, the @src pointer must never be changed,
+ * and the @pos field can only be updated by zstd.
+ * However, it's possible to increase the @size field,
+ * allowing scenarios where more data can be appended after compressions starts.
+ * These conditions are checked by the compressor,
+ * and compression will fail if they are not respected.
+ * Also, data in the ZSTD_inBuffer within the range [src, src + pos)
+ * MUST not be modified during compression or it will result in data corruption.
+ *
+ * When this flag is enabled zstd won't allocate an input window buffer,
+ * because the user guarantees it can reference the ZSTD_inBuffer until
+ * the frame is complete. But, it will still allocate an output buffer
+ * large enough to fit a block (see ZSTD_c_stableOutBuffer). This will also
+ * avoid the memcpy() from the input buffer to the input window buffer.
+ *
+ * NOTE: So long as the ZSTD_inBuffer always points to valid memory, using
+ * this flag is ALWAYS memory safe, and will never access out-of-bounds
+ * memory. However, compression WILL fail if conditions are not respected.
+ *
+ * WARNING: The data in the ZSTD_inBuffer in the range [src, src + pos) MUST
+ * not be modified during compression or it will result in data corruption.
+ * This is because zstd needs to reference data in the ZSTD_inBuffer to find
+ * matches. Normally zstd maintains its own window buffer for this purpose,
+ * but passing this flag tells zstd to rely on user provided buffer instead.
+ */
+#define ZSTD_c_stableInBuffer ZSTD_c_experimentalParam9
+
+/* ZSTD_c_stableOutBuffer
+ * Experimental parameter.
+ * Default is 0 == disabled. Set to 1 to enable.
+ *
+ * Tells he compressor that the ZSTD_outBuffer will not be resized between
+ * calls. Specifically: (out.size - out.pos) will never grow. This gives the
+ * compressor the freedom to say: If the compressed data doesn't fit in the
+ * output buffer then return ZSTD_error_dstSizeTooSmall. This allows us to
+ * always decompress directly into the output buffer, instead of decompressing
+ * into an internal buffer and copying to the output buffer.
+ *
+ * When this flag is enabled zstd won't allocate an output buffer, because
+ * it can write directly to the ZSTD_outBuffer. It will still allocate the
+ * input window buffer (see ZSTD_c_stableInBuffer).
+ *
+ * Zstd will check that (out.size - out.pos) never grows and return an error
+ * if it does. While not strictly necessary, this should prevent surprises.
+ */
+#define ZSTD_c_stableOutBuffer ZSTD_c_experimentalParam10
+
+/* ZSTD_c_blockDelimiters
+ * Default is 0 == ZSTD_sf_noBlockDelimiters.
+ *
+ * For use with sequence compression API: ZSTD_compressSequences().
+ *
+ * Designates whether or not the given array of ZSTD_Sequence contains block delimiters
+ * and last literals, which are defined as sequences with offset == 0 and matchLength == 0.
+ * See the definition of ZSTD_Sequence for more specifics.
+ */
+#define ZSTD_c_blockDelimiters ZSTD_c_experimentalParam11
+
+/* ZSTD_c_validateSequences
+ * Default is 0 == disabled. Set to 1 to enable sequence validation.
+ *
+ * For use with sequence compression API: ZSTD_compressSequences().
+ * Designates whether or not we validate sequences provided to ZSTD_compressSequences()
+ * during function execution.
+ *
+ * Without validation, providing a sequence that does not conform to the zstd spec will cause
+ * undefined behavior, and may produce a corrupted block.
+ *
+ * With validation enabled, if sequence is invalid (see doc/zstd_compression_format.md for
+ * specifics regarding offset/matchlength requirements) then the function will bail out and
+ * return an error.
+ *
+ */
+#define ZSTD_c_validateSequences ZSTD_c_experimentalParam12
+
+/* ZSTD_c_useBlockSplitter
+ * Controlled with ZSTD_paramSwitch_e enum.
+ * Default is ZSTD_ps_auto.
+ * Set to ZSTD_ps_disable to never use block splitter.
+ * Set to ZSTD_ps_enable to always use block splitter.
+ *
+ * By default, in ZSTD_ps_auto, the library will decide at runtime whether to use
+ * block splitting based on the compression parameters.
+ */
+#define ZSTD_c_useBlockSplitter ZSTD_c_experimentalParam13
+
+/* ZSTD_c_useRowMatchFinder
+ * Controlled with ZSTD_paramSwitch_e enum.
+ * Default is ZSTD_ps_auto.
+ * Set to ZSTD_ps_disable to never use row-based matchfinder.
+ * Set to ZSTD_ps_enable to force usage of row-based matchfinder.
+ *
+ * By default, in ZSTD_ps_auto, the library will decide at runtime whether to use
+ * the row-based matchfinder based on support for SIMD instructions and the window log.
+ * Note that this only pertains to compression strategies: greedy, lazy, and lazy2
+ */
+#define ZSTD_c_useRowMatchFinder ZSTD_c_experimentalParam14
+
+/* ZSTD_c_deterministicRefPrefix
+ * Default is 0 == disabled. Set to 1 to enable.
+ *
+ * Zstd produces different results for prefix compression when the prefix is
+ * directly adjacent to the data about to be compressed vs. when it isn't.
+ * This is because zstd detects that the two buffers are contiguous and it can
+ * use a more efficient match finding algorithm. However, this produces different
+ * results than when the two buffers are non-contiguous. This flag forces zstd
+ * to always load the prefix in non-contiguous mode, even if it happens to be
+ * adjacent to the data, to guarantee determinism.
+ *
+ * If you really care about determinism when using a dictionary or prefix,
+ * like when doing delta compression, you should select this option. It comes
+ * at a speed penalty of about ~2.5% if the dictionary and data happened to be
+ * contiguous, and is free if they weren't contiguous. We don't expect that
+ * intentionally making the dictionary and data contiguous will be worth the
+ * cost to memcpy() the data.
+ */
+#define ZSTD_c_deterministicRefPrefix ZSTD_c_experimentalParam15
+
+/* ZSTD_c_prefetchCDictTables
+ * Controlled with ZSTD_paramSwitch_e enum. Default is ZSTD_ps_auto.
+ *
+ * In some situations, zstd uses CDict tables in-place rather than copying them
+ * into the working context. (See docs on ZSTD_dictAttachPref_e above for details).
+ * In such situations, compression speed is seriously impacted when CDict tables are
+ * "cold" (outside CPU cache). This parameter instructs zstd to prefetch CDict tables
+ * when they are used in-place.
+ *
+ * For sufficiently small inputs, the cost of the prefetch will outweigh the benefit.
+ * For sufficiently large inputs, zstd will by default memcpy() CDict tables
+ * into the working context, so there is no need to prefetch. This parameter is
+ * targeted at a middle range of input sizes, where a prefetch is cheap enough to be
+ * useful but memcpy() is too expensive. The exact range of input sizes where this
+ * makes sense is best determined by careful experimentation.
+ *
+ * Note: for this parameter, ZSTD_ps_auto is currently equivalent to ZSTD_ps_disable,
+ * but in the future zstd may conditionally enable this feature via an auto-detection
+ * heuristic for cold CDicts.
+ * Use ZSTD_ps_disable to opt out of prefetching under any circumstances.
+ */
+#define ZSTD_c_prefetchCDictTables ZSTD_c_experimentalParam16
+
+/* ZSTD_c_enableSeqProducerFallback
+ * Allowed values are 0 (disable) and 1 (enable). The default setting is 0.
+ *
+ * Controls whether zstd will fall back to an internal sequence producer if an
+ * external sequence producer is registered and returns an error code. This fallback
+ * is block-by-block: the internal sequence producer will only be called for blocks
+ * where the external sequence producer returns an error code. Fallback parsing will
+ * follow any other cParam settings, such as compression level, the same as in a
+ * normal (fully-internal) compression operation.
+ *
+ * The user is strongly encouraged to read the full Block-Level Sequence Producer API
+ * documentation (below) before setting this parameter. */
+#define ZSTD_c_enableSeqProducerFallback ZSTD_c_experimentalParam17
+
+/* ZSTD_c_maxBlockSize
+ * Allowed values are between 1KB and ZSTD_BLOCKSIZE_MAX (128KB).
+ * The default is ZSTD_BLOCKSIZE_MAX, and setting to 0 will set to the default.
+ *
+ * This parameter can be used to set an upper bound on the blocksize
+ * that overrides the default ZSTD_BLOCKSIZE_MAX. It cannot be used to set upper
+ * bounds greater than ZSTD_BLOCKSIZE_MAX or bounds lower than 1KB (will make
+ * compressBound() inaccurate). Only currently meant to be used for testing.
+ *
+ */
+#define ZSTD_c_maxBlockSize ZSTD_c_experimentalParam18
+
+/* ZSTD_c_searchForExternalRepcodes
+ * This parameter affects how zstd parses external sequences, such as sequences
+ * provided through the compressSequences() API or from an external block-level
+ * sequence producer.
+ *
+ * If set to ZSTD_ps_enable, the library will check for repeated offsets in
+ * external sequences, even if those repcodes are not explicitly indicated in
+ * the "rep" field. Note that this is the only way to exploit repcode matches
+ * while using compressSequences() or an external sequence producer, since zstd
+ * currently ignores the "rep" field of external sequences.
+ *
+ * If set to ZSTD_ps_disable, the library will not exploit repeated offsets in
+ * external sequences, regardless of whether the "rep" field has been set. This
+ * reduces sequence compression overhead by about 25% while sacrificing some
+ * compression ratio.
+ *
+ * The default value is ZSTD_ps_auto, for which the library will enable/disable
+ * based on compression level.
+ *
+ * Note: for now, this param only has an effect if ZSTD_c_blockDelimiters is
+ * set to ZSTD_sf_explicitBlockDelimiters. That may change in the future.
+ */
+#define ZSTD_c_searchForExternalRepcodes ZSTD_c_experimentalParam19
+
+/*! ZSTD_CCtx_getParameter() :
+ *  Get the requested compression parameter value, selected by enum ZSTD_cParameter,
+ *  and store it into int* value.
+ * @return : 0, or an error code (which can be tested with ZSTD_isError()).
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_CCtx_getParameter(const ZSTD_CCtx* cctx, ZSTD_cParameter param, int* value);
+
+
+/*! ZSTD_CCtx_params :
+ *  Quick howto :
+ *  - ZSTD_createCCtxParams() : Create a ZSTD_CCtx_params structure
+ *  - ZSTD_CCtxParams_setParameter() : Push parameters one by one into
+ *                                     an existing ZSTD_CCtx_params structure.
+ *                                     This is similar to
+ *                                     ZSTD_CCtx_setParameter().
+ *  - ZSTD_CCtx_setParametersUsingCCtxParams() : Apply parameters to
+ *                                    an existing CCtx.
+ *                                    These parameters will be applied to
+ *                                    all subsequent frames.
+ *  - ZSTD_compressStream2() : Do compression using the CCtx.
+ *  - ZSTD_freeCCtxParams() : Free the memory, accept NULL pointer.
+ *
+ *  This can be used with ZSTD_estimateCCtxSize_advanced_usingCCtxParams()
+ *  for static allocation of CCtx for single-threaded compression.
+ */
+ZSTDLIB_STATIC_API ZSTD_CCtx_params* ZSTD_createCCtxParams(void);
+ZSTDLIB_STATIC_API size_t ZSTD_freeCCtxParams(ZSTD_CCtx_params* params);  /* accept NULL pointer */
+
+/*! ZSTD_CCtxParams_reset() :
+ *  Reset params to default values.
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_CCtxParams_reset(ZSTD_CCtx_params* params);
+
+/*! ZSTD_CCtxParams_init() :
+ *  Initializes the compression parameters of cctxParams according to
+ *  compression level. All other parameters are reset to their default values.
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_CCtxParams_init(ZSTD_CCtx_params* cctxParams, int compressionLevel);
+
+/*! ZSTD_CCtxParams_init_advanced() :
+ *  Initializes the compression and frame parameters of cctxParams according to
+ *  params. All other parameters are reset to their default values.
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_CCtxParams_init_advanced(ZSTD_CCtx_params* cctxParams, ZSTD_parameters params);
+
+/*! ZSTD_CCtxParams_setParameter() : Requires v1.4.0+
+ *  Similar to ZSTD_CCtx_setParameter.
+ *  Set one compression parameter, selected by enum ZSTD_cParameter.
+ *  Parameters must be applied to a ZSTD_CCtx using
+ *  ZSTD_CCtx_setParametersUsingCCtxParams().
+ * @result : a code representing success or failure (which can be tested with
+ *           ZSTD_isError()).
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_CCtxParams_setParameter(ZSTD_CCtx_params* params, ZSTD_cParameter param, int value);
+
+/*! ZSTD_CCtxParams_getParameter() :
+ * Similar to ZSTD_CCtx_getParameter.
+ * Get the requested value of one compression parameter, selected by enum ZSTD_cParameter.
+ * @result : 0, or an error code (which can be tested with ZSTD_isError()).
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_CCtxParams_getParameter(const ZSTD_CCtx_params* params, ZSTD_cParameter param, int* value);
+
+/*! ZSTD_CCtx_setParametersUsingCCtxParams() :
+ *  Apply a set of ZSTD_CCtx_params to the compression context.
+ *  This can be done even after compression is started,
+ *    if nbWorkers==0, this will have no impact until a new compression is started.
+ *    if nbWorkers>=1, new parameters will be picked up at next job,
+ *       with a few restrictions (windowLog, pledgedSrcSize, nbWorkers, jobSize, and overlapLog are not updated).
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_CCtx_setParametersUsingCCtxParams(
+        ZSTD_CCtx* cctx, const ZSTD_CCtx_params* params);
+
+/*! ZSTD_compressStream2_simpleArgs() :
+ *  Same as ZSTD_compressStream2(),
+ *  but using only integral types as arguments.
+ *  This variant might be helpful for binders from dynamic languages
+ *  which have troubles handling structures containing memory pointers.
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_compressStream2_simpleArgs (
+                            ZSTD_CCtx* cctx,
+                            void* dst, size_t dstCapacity, size_t* dstPos,
+                      const void* src, size_t srcSize, size_t* srcPos,
+                            ZSTD_EndDirective endOp);
+
+
+/***************************************
+*  Advanced decompression functions
+***************************************/
+
+/*! ZSTD_isFrame() :
+ *  Tells if the content of `buffer` starts with a valid Frame Identifier.
+ *  Note : Frame Identifier is 4 bytes. If `size < 4`, @return will always be 0.
+ *  Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled.
+ *  Note 3 : Skippable Frame Identifiers are considered valid. */
+ZSTDLIB_STATIC_API unsigned ZSTD_isFrame(const void* buffer, size_t size);
+
+/*! ZSTD_createDDict_byReference() :
+ *  Create a digested dictionary, ready to start decompression operation without startup delay.
+ *  Dictionary content is referenced, and therefore stays in dictBuffer.
+ *  It is important that dictBuffer outlives DDict,
+ *  it must remain read accessible throughout the lifetime of DDict */
+ZSTDLIB_STATIC_API ZSTD_DDict* ZSTD_createDDict_byReference(const void* dictBuffer, size_t dictSize);
+
+/*! ZSTD_DCtx_loadDictionary_byReference() :
+ *  Same as ZSTD_DCtx_loadDictionary(),
+ *  but references `dict` content instead of copying it into `dctx`.
+ *  This saves memory if `dict` remains around.,
+ *  However, it's imperative that `dict` remains accessible (and unmodified) while being used, so it must outlive decompression. */
+ZSTDLIB_STATIC_API size_t ZSTD_DCtx_loadDictionary_byReference(ZSTD_DCtx* dctx, const void* dict, size_t dictSize);
+
+/*! ZSTD_DCtx_loadDictionary_advanced() :
+ *  Same as ZSTD_DCtx_loadDictionary(),
+ *  but gives direct control over
+ *  how to load the dictionary (by copy ? by reference ?)
+ *  and how to interpret it (automatic ? force raw mode ? full mode only ?). */
+ZSTDLIB_STATIC_API size_t ZSTD_DCtx_loadDictionary_advanced(ZSTD_DCtx* dctx, const void* dict, size_t dictSize, ZSTD_dictLoadMethod_e dictLoadMethod, ZSTD_dictContentType_e dictContentType);
+
+/*! ZSTD_DCtx_refPrefix_advanced() :
+ *  Same as ZSTD_DCtx_refPrefix(), but gives finer control over
+ *  how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?) */
+ZSTDLIB_STATIC_API size_t ZSTD_DCtx_refPrefix_advanced(ZSTD_DCtx* dctx, const void* prefix, size_t prefixSize, ZSTD_dictContentType_e dictContentType);
+
+/*! ZSTD_DCtx_setMaxWindowSize() :
+ *  Refuses allocating internal buffers for frames requiring a window size larger than provided limit.
+ *  This protects a decoder context from reserving too much memory for itself (potential attack scenario).
+ *  This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode.
+ *  By default, a decompression context accepts all window sizes <= (1 << ZSTD_WINDOWLOG_LIMIT_DEFAULT)
+ * @return : 0, or an error code (which can be tested using ZSTD_isError()).
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_DCtx_setMaxWindowSize(ZSTD_DCtx* dctx, size_t maxWindowSize);
+
+/*! ZSTD_DCtx_getParameter() :
+ *  Get the requested decompression parameter value, selected by enum ZSTD_dParameter,
+ *  and store it into int* value.
+ * @return : 0, or an error code (which can be tested with ZSTD_isError()).
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_DCtx_getParameter(ZSTD_DCtx* dctx, ZSTD_dParameter param, int* value);
+
+/* ZSTD_d_format
+ * experimental parameter,
+ * allowing selection between ZSTD_format_e input compression formats
+ */
+#define ZSTD_d_format ZSTD_d_experimentalParam1
+/* ZSTD_d_stableOutBuffer
+ * Experimental parameter.
+ * Default is 0 == disabled. Set to 1 to enable.
+ *
+ * Tells the decompressor that the ZSTD_outBuffer will ALWAYS be the same
+ * between calls, except for the modifications that zstd makes to pos (the
+ * caller must not modify pos). This is checked by the decompressor, and
+ * decompression will fail if it ever changes. Therefore the ZSTD_outBuffer
+ * MUST be large enough to fit the entire decompressed frame. This will be
+ * checked when the frame content size is known. The data in the ZSTD_outBuffer
+ * in the range [dst, dst + pos) MUST not be modified during decompression
+ * or you will get data corruption.
+ *
+ * When this flag is enabled zstd won't allocate an output buffer, because
+ * it can write directly to the ZSTD_outBuffer, but it will still allocate
+ * an input buffer large enough to fit any compressed block. This will also
+ * avoid the memcpy() from the internal output buffer to the ZSTD_outBuffer.
+ * If you need to avoid the input buffer allocation use the buffer-less
+ * streaming API.
+ *
+ * NOTE: So long as the ZSTD_outBuffer always points to valid memory, using
+ * this flag is ALWAYS memory safe, and will never access out-of-bounds
+ * memory. However, decompression WILL fail if you violate the preconditions.
+ *
+ * WARNING: The data in the ZSTD_outBuffer in the range [dst, dst + pos) MUST
+ * not be modified during decompression or you will get data corruption. This
+ * is because zstd needs to reference data in the ZSTD_outBuffer to regenerate
+ * matches. Normally zstd maintains its own buffer for this purpose, but passing
+ * this flag tells zstd to use the user provided buffer.
+ */
+#define ZSTD_d_stableOutBuffer ZSTD_d_experimentalParam2
+
+/* ZSTD_d_forceIgnoreChecksum
+ * Experimental parameter.
+ * Default is 0 == disabled. Set to 1 to enable
+ *
+ * Tells the decompressor to skip checksum validation during decompression, regardless
+ * of whether checksumming was specified during compression. This offers some
+ * slight performance benefits, and may be useful for debugging.
+ * Param has values of type ZSTD_forceIgnoreChecksum_e
+ */
+#define ZSTD_d_forceIgnoreChecksum ZSTD_d_experimentalParam3
+
+/* ZSTD_d_refMultipleDDicts
+ * Experimental parameter.
+ * Default is 0 == disabled. Set to 1 to enable
+ *
+ * If enabled and dctx is allocated on the heap, then additional memory will be allocated
+ * to store references to multiple ZSTD_DDict. That is, multiple calls of ZSTD_refDDict()
+ * using a given ZSTD_DCtx, rather than overwriting the previous DDict reference, will instead
+ * store all references. At decompression time, the appropriate dictID is selected
+ * from the set of DDicts based on the dictID in the frame.
+ *
+ * Usage is simply calling ZSTD_refDDict() on multiple dict buffers.
+ *
+ * Param has values of byte ZSTD_refMultipleDDicts_e
+ *
+ * WARNING: Enabling this parameter and calling ZSTD_DCtx_refDDict(), will trigger memory
+ * allocation for the hash table. ZSTD_freeDCtx() also frees this memory.
+ * Memory is allocated as per ZSTD_DCtx::customMem.
+ *
+ * Although this function allocates memory for the table, the user is still responsible for
+ * memory management of the underlying ZSTD_DDict* themselves.
+ */
+#define ZSTD_d_refMultipleDDicts ZSTD_d_experimentalParam4
+
+/* ZSTD_d_disableHuffmanAssembly
+ * Set to 1 to disable the Huffman assembly implementation.
+ * The default value is 0, which allows zstd to use the Huffman assembly
+ * implementation if available.
+ *
+ * This parameter can be used to disable Huffman assembly at runtime.
+ * If you want to disable it at compile time you can define the macro
+ * ZSTD_DISABLE_ASM.
+ */
+#define ZSTD_d_disableHuffmanAssembly ZSTD_d_experimentalParam5
+
+
+/*! ZSTD_DCtx_setFormat() :
+ *  This function is REDUNDANT. Prefer ZSTD_DCtx_setParameter().
+ *  Instruct the decoder context about what kind of data to decode next.
+ *  This instruction is mandatory to decode data without a fully-formed header,
+ *  such ZSTD_f_zstd1_magicless for example.
+ * @return : 0, or an error code (which can be tested using ZSTD_isError()). */
+ZSTD_DEPRECATED("use ZSTD_DCtx_setParameter() instead")
+ZSTDLIB_STATIC_API
+size_t ZSTD_DCtx_setFormat(ZSTD_DCtx* dctx, ZSTD_format_e format);
+
+/*! ZSTD_decompressStream_simpleArgs() :
+ *  Same as ZSTD_decompressStream(),
+ *  but using only integral types as arguments.
+ *  This can be helpful for binders from dynamic languages
+ *  which have troubles handling structures containing memory pointers.
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_decompressStream_simpleArgs (
+                            ZSTD_DCtx* dctx,
+                            void* dst, size_t dstCapacity, size_t* dstPos,
+                      const void* src, size_t srcSize, size_t* srcPos);
+
+
+/********************************************************************
+*  Advanced streaming functions
+*  Warning : most of these functions are now redundant with the Advanced API.
+*  Once Advanced API reaches "stable" status,
+*  redundant functions will be deprecated, and then at some point removed.
+********************************************************************/
+
+/*=====   Advanced Streaming compression functions  =====*/
+
+/*! ZSTD_initCStream_srcSize() :
+ * This function is DEPRECATED, and equivalent to:
+ *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
+ *     ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)
+ *     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
+ *     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
+ *
+ * pledgedSrcSize must be correct. If it is not known at init time, use
+ * ZSTD_CONTENTSIZE_UNKNOWN. Note that, for compatibility with older programs,
+ * "0" also disables frame content size field. It may be enabled in the future.
+ * This prototype will generate compilation warnings.
+ */
+ZSTD_DEPRECATED("use ZSTD_CCtx_reset, see zstd.h for detailed instructions")
+ZSTDLIB_STATIC_API
+size_t ZSTD_initCStream_srcSize(ZSTD_CStream* zcs,
+                         int compressionLevel,
+                         unsigned long long pledgedSrcSize);
+
+/*! ZSTD_initCStream_usingDict() :
+ * This function is DEPRECATED, and is equivalent to:
+ *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
+ *     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
+ *     ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);
+ *
+ * Creates of an internal CDict (incompatible with static CCtx), except if
+ * dict == NULL or dictSize < 8, in which case no dict is used.
+ * Note: dict is loaded with ZSTD_dct_auto (treated as a full zstd dictionary if
+ * it begins with ZSTD_MAGIC_DICTIONARY, else as raw content) and ZSTD_dlm_byCopy.
+ * This prototype will generate compilation warnings.
+ */
+ZSTD_DEPRECATED("use ZSTD_CCtx_reset, see zstd.h for detailed instructions")
+ZSTDLIB_STATIC_API
+size_t ZSTD_initCStream_usingDict(ZSTD_CStream* zcs,
+                     const void* dict, size_t dictSize,
+                           int compressionLevel);
+
+/*! ZSTD_initCStream_advanced() :
+ * This function is DEPRECATED, and is equivalent to:
+ *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
+ *     ZSTD_CCtx_setParams(zcs, params);
+ *     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
+ *     ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);
+ *
+ * dict is loaded with ZSTD_dct_auto and ZSTD_dlm_byCopy.
+ * pledgedSrcSize must be correct.
+ * If srcSize is not known at init time, use value ZSTD_CONTENTSIZE_UNKNOWN.
+ * This prototype will generate compilation warnings.
+ */
+ZSTD_DEPRECATED("use ZSTD_CCtx_reset, see zstd.h for detailed instructions")
+ZSTDLIB_STATIC_API
+size_t ZSTD_initCStream_advanced(ZSTD_CStream* zcs,
+                    const void* dict, size_t dictSize,
+                          ZSTD_parameters params,
+                          unsigned long long pledgedSrcSize);
+
+/*! ZSTD_initCStream_usingCDict() :
+ * This function is DEPRECATED, and equivalent to:
+ *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
+ *     ZSTD_CCtx_refCDict(zcs, cdict);
+ *
+ * note : cdict will just be referenced, and must outlive compression session
+ * This prototype will generate compilation warnings.
+ */
+ZSTD_DEPRECATED("use ZSTD_CCtx_reset and ZSTD_CCtx_refCDict, see zstd.h for detailed instructions")
+ZSTDLIB_STATIC_API
+size_t ZSTD_initCStream_usingCDict(ZSTD_CStream* zcs, const ZSTD_CDict* cdict);
+
+/*! ZSTD_initCStream_usingCDict_advanced() :
+ *   This function is DEPRECATED, and is equivalent to:
+ *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
+ *     ZSTD_CCtx_setFParams(zcs, fParams);
+ *     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
+ *     ZSTD_CCtx_refCDict(zcs, cdict);
+ *
+ * same as ZSTD_initCStream_usingCDict(), with control over frame parameters.
+ * pledgedSrcSize must be correct. If srcSize is not known at init time, use
+ * value ZSTD_CONTENTSIZE_UNKNOWN.
+ * This prototype will generate compilation warnings.
+ */
+ZSTD_DEPRECATED("use ZSTD_CCtx_reset and ZSTD_CCtx_refCDict, see zstd.h for detailed instructions")
+ZSTDLIB_STATIC_API
+size_t ZSTD_initCStream_usingCDict_advanced(ZSTD_CStream* zcs,
+                               const ZSTD_CDict* cdict,
+                                     ZSTD_frameParameters fParams,
+                                     unsigned long long pledgedSrcSize);
+
+/*! ZSTD_resetCStream() :
+ * This function is DEPRECATED, and is equivalent to:
+ *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
+ *     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
+ * Note: ZSTD_resetCStream() interprets pledgedSrcSize == 0 as ZSTD_CONTENTSIZE_UNKNOWN, but
+ *       ZSTD_CCtx_setPledgedSrcSize() does not do the same, so ZSTD_CONTENTSIZE_UNKNOWN must be
+ *       explicitly specified.
+ *
+ *  start a new frame, using same parameters from previous frame.
+ *  This is typically useful to skip dictionary loading stage, since it will re-use it in-place.
+ *  Note that zcs must be init at least once before using ZSTD_resetCStream().
+ *  If pledgedSrcSize is not known at reset time, use macro ZSTD_CONTENTSIZE_UNKNOWN.
+ *  If pledgedSrcSize > 0, its value must be correct, as it will be written in header, and controlled at the end.
+ *  For the time being, pledgedSrcSize==0 is interpreted as "srcSize unknown" for compatibility with older programs,
+ *  but it will change to mean "empty" in future version, so use macro ZSTD_CONTENTSIZE_UNKNOWN instead.
+ * @return : 0, or an error code (which can be tested using ZSTD_isError())
+ *  This prototype will generate compilation warnings.
+ */
+ZSTD_DEPRECATED("use ZSTD_CCtx_reset, see zstd.h for detailed instructions")
+ZSTDLIB_STATIC_API
+size_t ZSTD_resetCStream(ZSTD_CStream* zcs, unsigned long long pledgedSrcSize);
+
+
+typedef struct {
+    unsigned long long ingested;   /* nb input bytes read and buffered */
+    unsigned long long consumed;   /* nb input bytes actually compressed */
+    unsigned long long produced;   /* nb of compressed bytes generated and buffered */
+    unsigned long long flushed;    /* nb of compressed bytes flushed : not provided; can be tracked from caller side */
+    unsigned currentJobID;         /* MT only : latest started job nb */
+    unsigned nbActiveWorkers;      /* MT only : nb of workers actively compressing at probe time */
+} ZSTD_frameProgression;
+
+/* ZSTD_getFrameProgression() :
+ * tells how much data has been ingested (read from input)
+ * consumed (input actually compressed) and produced (output) for current frame.
+ * Note : (ingested - consumed) is amount of input data buffered internally, not yet compressed.
+ * Aggregates progression inside active worker threads.
+ */
+ZSTDLIB_STATIC_API ZSTD_frameProgression ZSTD_getFrameProgression(const ZSTD_CCtx* cctx);
+
+/*! ZSTD_toFlushNow() :
+ *  Tell how many bytes are ready to be flushed immediately.
+ *  Useful for multithreading scenarios (nbWorkers >= 1).
+ *  Probe the oldest active job, defined as oldest job not yet entirely flushed,
+ *  and check its output buffer.
+ * @return : amount of data stored in oldest job and ready to be flushed immediately.
+ *  if @return == 0, it means either :
+ *  + there is no active job (could be checked with ZSTD_frameProgression()), or
+ *  + oldest job is still actively compressing data,
+ *    but everything it has produced has also been flushed so far,
+ *    therefore flush speed is limited by production speed of oldest job
+ *    irrespective of the speed of concurrent (and newer) jobs.
+ */
+ZSTDLIB_STATIC_API size_t ZSTD_toFlushNow(ZSTD_CCtx* cctx);
+
+
+/*=====   Advanced Streaming decompression functions  =====*/
+
+/*!
+ * This function is deprecated, and is equivalent to:
+ *
+ *     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
+ *     ZSTD_DCtx_loadDictionary(zds, dict, dictSize);
+ *
+ * note: no dictionary will be used if dict == NULL or dictSize < 8
+ */
+ZSTD_DEPRECATED("use ZSTD_DCtx_reset + ZSTD_DCtx_loadDictionary, see zstd.h for detailed instructions")
+ZSTDLIB_STATIC_API size_t ZSTD_initDStream_usingDict(ZSTD_DStream* zds, const void* dict, size_t dictSize);
+
+/*!
+ * This function is deprecated, and is equivalent to:
+ *
+ *     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
+ *     ZSTD_DCtx_refDDict(zds, ddict);
+ *
+ * note : ddict is referenced, it must outlive decompression session
+ */
+ZSTD_DEPRECATED("use ZSTD_DCtx_reset + ZSTD_DCtx_refDDict, see zstd.h for detailed instructions")
+ZSTDLIB_STATIC_API size_t ZSTD_initDStream_usingDDict(ZSTD_DStream* zds, const ZSTD_DDict* ddict);
+
+/*!
+ * This function is deprecated, and is equivalent to:
+ *
+ *     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
+ *
+ * re-use decompression parameters from previous init; saves dictionary loading
+ */
+ZSTD_DEPRECATED("use ZSTD_DCtx_reset, see zstd.h for detailed instructions")
+ZSTDLIB_STATIC_API size_t ZSTD_resetDStream(ZSTD_DStream* zds);
+
+
+/* ********************* BLOCK-LEVEL SEQUENCE PRODUCER API *********************
+ *
+ * *** OVERVIEW ***
+ * The Block-Level Sequence Producer API allows users to provide their own custom
+ * sequence producer which libzstd invokes to process each block. The produced list
+ * of sequences (literals and matches) is then post-processed by libzstd to produce
+ * valid compressed blocks.
+ *
+ * This block-level offload API is a more granular complement of the existing
+ * frame-level offload API compressSequences() (introduced in v1.5.1). It offers
+ * an easier migration story for applications already integrated with libzstd: the
+ * user application continues to invoke the same compression functions
+ * ZSTD_compress2() or ZSTD_compressStream2() as usual, and transparently benefits
+ * from the specific advantages of the external sequence producer. For example,
+ * the sequence producer could be tuned to take advantage of known characteristics
+ * of the input, to offer better speed / ratio, or could leverage hardware
+ * acceleration not available within libzstd itself.
+ *
+ * See contrib/externalSequenceProducer for an example program employing the
+ * Block-Level Sequence Producer API.
+ *
+ * *** USAGE ***
+ * The user is responsible for implementing a function of type
+ * ZSTD_sequenceProducer_F. For each block, zstd will pass the following
+ * arguments to the user-provided function:
+ *
+ *   - sequenceProducerState: a pointer to a user-managed state for the sequence
+ *     producer.
+ *
+ *   - outSeqs, outSeqsCapacity: an output buffer for the sequence producer.
+ *     outSeqsCapacity is guaranteed >= ZSTD_sequenceBound(srcSize). The memory
+ *     backing outSeqs is managed by the CCtx.
+ *
+ *   - src, srcSize: an input buffer for the sequence producer to parse.
+ *     srcSize is guaranteed to be <= ZSTD_BLOCKSIZE_MAX.
+ *
+ *   - dict, dictSize: a history buffer, which may be empty, which the sequence
+ *     producer may reference as it parses the src buffer. Currently, zstd will
+ *     always pass dictSize == 0 into external sequence producers, but this will
+ *     change in the future.
+ *
+ *   - compressionLevel: a signed integer representing the zstd compression level
+ *     set by the user for the current operation. The sequence producer may choose
+ *     to use this information to change its compression strategy and speed/ratio
+ *     tradeoff. Note: the compression level does not reflect zstd parameters set
+ *     through the advanced API.
+ *
+ *   - windowSize: a size_t representing the maximum allowed offset for external
+ *     sequences. Note that sequence offsets are sometimes allowed to exceed the
+ *     windowSize if a dictionary is present, see doc/zstd_compression_format.md
+ *     for details.
+ *
+ * The user-provided function shall return a size_t representing the number of
+ * sequences written to outSeqs. This return value will be treated as an error
+ * code if it is greater than outSeqsCapacity. The return value must be non-zero
+ * if srcSize is non-zero. The ZSTD_SEQUENCE_PRODUCER_ERROR macro is provided
+ * for convenience, but any value greater than outSeqsCapacity will be treated as
+ * an error code.
+ *
+ * If the user-provided function does not return an error code, the sequences
+ * written to outSeqs must be a valid parse of the src buffer. Data corruption may
+ * occur if the parse is not valid. A parse is defined to be valid if the
+ * following conditions hold:
+ *   - The sum of matchLengths and literalLengths must equal srcSize.
+ *   - All sequences in the parse, except for the final sequence, must have
+ *     matchLength >= ZSTD_MINMATCH_MIN. The final sequence must have
+ *     matchLength >= ZSTD_MINMATCH_MIN or matchLength == 0.
+ *   - All offsets must respect the windowSize parameter as specified in
+ *     doc/zstd_compression_format.md.
+ *   - If the final sequence has matchLength == 0, it must also have offset == 0.
+ *
+ * zstd will only validate these conditions (and fail compression if they do not
+ * hold) if the ZSTD_c_validateSequences cParam is enabled. Note that sequence
+ * validation has a performance cost.
+ *
+ * If the user-provided function returns an error, zstd will either fall back
+ * to an internal sequence producer or fail the compression operation. The user can
+ * choose between the two behaviors by setting the ZSTD_c_enableSeqProducerFallback
+ * cParam. Fallback compression will follow any other cParam settings, such as
+ * compression level, the same as in a normal compression operation.
+ *
+ * The user shall instruct zstd to use a particular ZSTD_sequenceProducer_F
+ * function by calling
+ *         ZSTD_registerSequenceProducer(cctx,
+ *                                       sequenceProducerState,
+ *                                       sequenceProducer)
+ * This setting will persist until the next parameter reset of the CCtx.
+ *
+ * The sequenceProducerState must be initialized by the user before calling
+ * ZSTD_registerSequenceProducer(). The user is responsible for destroying the
+ * sequenceProducerState.
+ *
+ * *** LIMITATIONS ***
+ * This API is compatible with all zstd compression APIs which respect advanced parameters.
+ * However, there are three limitations:
+ *
+ * First, the ZSTD_c_enableLongDistanceMatching cParam is not currently supported.
+ * COMPRESSION WILL FAIL if it is enabled and the user tries to compress with a block-level
+ * external sequence producer.
+ *   - Note that ZSTD_c_enableLongDistanceMatching is auto-enabled by default in some
+ *     cases (see its documentation for details). Users must explicitly set
+ *     ZSTD_c_enableLongDistanceMatching to ZSTD_ps_disable in such cases if an external
+ *     sequence producer is registered.
+ *   - As of this writing, ZSTD_c_enableLongDistanceMatching is disabled by default
+ *     whenever ZSTD_c_windowLog < 128MB, but that's subject to change. Users should
+ *     check the docs on ZSTD_c_enableLongDistanceMatching whenever the Block-Level Sequence
+ *     Producer API is used in conjunction with advanced settings (like ZSTD_c_windowLog).
+ *
+ * Second, history buffers are not currently supported. Concretely, zstd will always pass
+ * dictSize == 0 to the external sequence producer (for now). This has two implications:
+ *   - Dictionaries are not currently supported. Compression will *not* fail if the user
+ *     references a dictionary, but the dictionary won't have any effect.
+ *   - Stream history is not currently supported. All advanced compression APIs, including
+ *     streaming APIs, work with external sequence producers, but each block is treated as
+ *     an independent chunk without history from previous blocks.
+ *
+ * Third, multi-threading within a single compression is not currently supported. In other words,
+ * COMPRESSION WILL FAIL if ZSTD_c_nbWorkers > 0 and an external sequence producer is registered.
+ * Multi-threading across compressions is fine: simply create one CCtx per thread.
+ *
+ * Long-term, we plan to overcome all three limitations. There is no technical blocker to
+ * overcoming them. It is purely a question of engineering effort.
+ */
+
+#define ZSTD_SEQUENCE_PRODUCER_ERROR ((size_t)(-1))
+
+typedef size_t ZSTD_sequenceProducer_F (
+  void* sequenceProducerState,
+  ZSTD_Sequence* outSeqs, size_t outSeqsCapacity,
+  const void* src, size_t srcSize,
+  const void* dict, size_t dictSize,
+  int compressionLevel,
+  size_t windowSize
+);
+
+/*! ZSTD_registerSequenceProducer() :
+ * Instruct zstd to use a block-level external sequence producer function.
+ *
+ * The sequenceProducerState must be initialized by the caller, and the caller is
+ * responsible for managing its lifetime. This parameter is sticky across
+ * compressions. It will remain set until the user explicitly resets compression
+ * parameters.
+ *
+ * Sequence producer registration is considered to be an "advanced parameter",
+ * part of the "advanced API". This means it will only have an effect on compression
+ * APIs which respect advanced parameters, such as compress2() and compressStream2().
+ * Older compression APIs such as compressCCtx(), which predate the introduction of
+ * "advanced parameters", will ignore any external sequence producer setting.
+ *
+ * The sequence producer can be "cleared" by registering a NULL function pointer. This
+ * removes all limitations described above in the "LIMITATIONS" section of the API docs.
+ *
+ * The user is strongly encouraged to read the full API documentation (above) before
+ * calling this function. */
+ZSTDLIB_STATIC_API void
+ZSTD_registerSequenceProducer(
+  ZSTD_CCtx* cctx,
+  void* sequenceProducerState,
+  ZSTD_sequenceProducer_F* sequenceProducer
+);
+
+
+/*********************************************************************
+*  Buffer-less and synchronous inner streaming functions (DEPRECATED)
+*
+*  This API is deprecated, and will be removed in a future version.
+*  It allows streaming (de)compression with user allocated buffers.
+*  However, it is hard to use, and not as well tested as the rest of
+*  our API.
+*
+*  Please use the normal streaming API instead: ZSTD_compressStream2,
+*  and ZSTD_decompressStream.
+*  If there is functionality that you need, but it doesn't provide,
+*  please open an issue on our GitHub.
+********************************************************************* */
+
+/**
+  Buffer-less streaming compression (synchronous mode)
+
+  A ZSTD_CCtx object is required to track streaming operations.
+  Use ZSTD_createCCtx() / ZSTD_freeCCtx() to manage resource.
+  ZSTD_CCtx object can be re-used multiple times within successive compression operations.
+
+  Start by initializing a context.
+  Use ZSTD_compressBegin(), or ZSTD_compressBegin_usingDict() for dictionary compression.
+
+  Then, consume your input using ZSTD_compressContinue().
+  There are some important considerations to keep in mind when using this advanced function :
+  - ZSTD_compressContinue() has no internal buffer. It uses externally provided buffers only.
+  - Interface is synchronous : input is consumed entirely and produces 1+ compressed blocks.
+  - Caller must ensure there is enough space in `dst` to store compressed data under worst case scenario.
+    Worst case evaluation is provided by ZSTD_compressBound().
+    ZSTD_compressContinue() doesn't guarantee recover after a failed compression.
+  - ZSTD_compressContinue() presumes prior input ***is still accessible and unmodified*** (up to maximum distance size, see WindowLog).
+    It remembers all previous contiguous blocks, plus one separated memory segment (which can itself consists of multiple contiguous blocks)
+  - ZSTD_compressContinue() detects that prior input has been overwritten when `src` buffer overlaps.
+    In which case, it will "discard" the relevant memory section from its history.
+
+  Finish a frame with ZSTD_compressEnd(), which will write the last block(s) and optional checksum.
+  It's possible to use srcSize==0, in which case, it will write a final empty block to end the frame.
+  Without last block mark, frames are considered unfinished (hence corrupted) by compliant decoders.
+
+  `ZSTD_CCtx` object can be re-used (ZSTD_compressBegin()) to compress again.
+*/
+
+/*=====   Buffer-less streaming compression functions  =====*/
+ZSTD_DEPRECATED("The buffer-less API is deprecated in favor of the normal streaming API. See docs.")
+ZSTDLIB_STATIC_API size_t ZSTD_compressBegin(ZSTD_CCtx* cctx, int compressionLevel);
+ZSTD_DEPRECATED("The buffer-less API is deprecated in favor of the normal streaming API. See docs.")
+ZSTDLIB_STATIC_API size_t ZSTD_compressBegin_usingDict(ZSTD_CCtx* cctx, const void* dict, size_t dictSize, int compressionLevel);
+ZSTD_DEPRECATED("The buffer-less API is deprecated in favor of the normal streaming API. See docs.")
+ZSTDLIB_STATIC_API size_t ZSTD_compressBegin_usingCDict(ZSTD_CCtx* cctx, const ZSTD_CDict* cdict); /**< note: fails if cdict==NULL */
+
+ZSTD_DEPRECATED("This function will likely be removed in a future release. It is misleading and has very limited utility.")
+ZSTDLIB_STATIC_API
+size_t ZSTD_copyCCtx(ZSTD_CCtx* cctx, const ZSTD_CCtx* preparedCCtx, unsigned long long pledgedSrcSize); /**<  note: if pledgedSrcSize is not known, use ZSTD_CONTENTSIZE_UNKNOWN */
+
+ZSTD_DEPRECATED("The buffer-less API is deprecated in favor of the normal streaming API. See docs.")
+ZSTDLIB_STATIC_API size_t ZSTD_compressContinue(ZSTD_CCtx* cctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize);
+ZSTD_DEPRECATED("The buffer-less API is deprecated in favor of the normal streaming API. See docs.")
+ZSTDLIB_STATIC_API size_t ZSTD_compressEnd(ZSTD_CCtx* cctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize);
+
+/* The ZSTD_compressBegin_advanced() and ZSTD_compressBegin_usingCDict_advanced() are now DEPRECATED and will generate a compiler warning */
+ZSTD_DEPRECATED("use advanced API to access custom parameters")
+ZSTDLIB_STATIC_API
+size_t ZSTD_compressBegin_advanced(ZSTD_CCtx* cctx, const void* dict, size_t dictSize, ZSTD_parameters params, unsigned long long pledgedSrcSize); /**< pledgedSrcSize : If srcSize is not known at init time, use ZSTD_CONTENTSIZE_UNKNOWN */
+ZSTD_DEPRECATED("use advanced API to access custom parameters")
+ZSTDLIB_STATIC_API
+size_t ZSTD_compressBegin_usingCDict_advanced(ZSTD_CCtx* const cctx, const ZSTD_CDict* const cdict, ZSTD_frameParameters const fParams, unsigned long long const pledgedSrcSize);   /* compression parameters are already set within cdict. pledgedSrcSize must be correct. If srcSize is not known, use macro ZSTD_CONTENTSIZE_UNKNOWN */
+/**
+  Buffer-less streaming decompression (synchronous mode)
+
+  A ZSTD_DCtx object is required to track streaming operations.
+  Use ZSTD_createDCtx() / ZSTD_freeDCtx() to manage it.
+  A ZSTD_DCtx object can be re-used multiple times.
+
+  First typical operation is to retrieve frame parameters, using ZSTD_getFrameHeader().
+  Frame header is extracted from the beginning of compressed frame, so providing only the frame's beginning is enough.
+  Data fragment must be large enough to ensure successful decoding.
+ `ZSTD_frameHeaderSize_max` bytes is guaranteed to always be large enough.
+  result  : 0 : successful decoding, the `ZSTD_frameHeader` structure is correctly filled.
+           >0 : `srcSize` is too small, please provide at least result bytes on next attempt.
+           errorCode, which can be tested using ZSTD_isError().
+
+  It fills a ZSTD_frameHeader structure with important information to correctly decode the frame,
+  such as the dictionary ID, content size, or maximum back-reference distance (`windowSize`).
+  Note that these values could be wrong, either because of data corruption, or because a 3rd party deliberately spoofs false information.
+  As a consequence, check that values remain within valid application range.
+  For example, do not allocate memory blindly, check that `windowSize` is within expectation.
+  Each application can set its own limits, depending on local restrictions.
+  For extended interoperability, it is recommended to support `windowSize` of at least 8 MB.
+
+  ZSTD_decompressContinue() needs previous data blocks during decompression, up to `windowSize` bytes.
+  ZSTD_decompressContinue() is very sensitive to contiguity,
+  if 2 blocks don't follow each other, make sure that either the compressor breaks contiguity at the same place,
+  or that previous contiguous segment is large enough to properly handle maximum back-reference distance.
+  There are multiple ways to guarantee this condition.
+
+  The most memory efficient way is to use a round buffer of sufficient size.
+  Sufficient size is determined by invoking ZSTD_decodingBufferSize_min(),
+  which can return an error code if required value is too large for current system (in 32-bits mode).
+  In a round buffer methodology, ZSTD_decompressContinue() decompresses each block next to previous one,
+  up to the moment there is not enough room left in the buffer to guarantee decoding another full block,
+  which maximum size is provided in `ZSTD_frameHeader` structure, field `blockSizeMax`.
+  At which point, decoding can resume from the beginning of the buffer.
+  Note that already decoded data stored in the buffer should be flushed before being overwritten.
+
+  There are alternatives possible, for example using two or more buffers of size `windowSize` each, though they consume more memory.
+
+  Finally, if you control the compression process, you can also ignore all buffer size rules,
+  as long as the encoder and decoder progress in "lock-step",
+  aka use exactly the same buffer sizes, break contiguity at the same place, etc.
+
+  Once buffers are setup, start decompression, with ZSTD_decompressBegin().
+  If decompression requires a dictionary, use ZSTD_decompressBegin_usingDict() or ZSTD_decompressBegin_usingDDict().
+
+  Then use ZSTD_nextSrcSizeToDecompress() and ZSTD_decompressContinue() alternatively.
+  ZSTD_nextSrcSizeToDecompress() tells how many bytes to provide as 'srcSize' to ZSTD_decompressContinue().
+  ZSTD_decompressContinue() requires this _exact_ amount of bytes, or it will fail.
+
+  result of ZSTD_decompressContinue() is the number of bytes regenerated within 'dst' (necessarily <= dstCapacity).
+  It can be zero : it just means ZSTD_decompressContinue() has decoded some metadata item.
+  It can also be an error code, which can be tested with ZSTD_isError().
+
+  A frame is fully decoded when ZSTD_nextSrcSizeToDecompress() returns zero.
+  Context can then be reset to start a new decompression.
+
+  Note : it's possible to know if next input to present is a header or a block, using ZSTD_nextInputType().
+  This information is not required to properly decode a frame.
+
+  == Special case : skippable frames ==
+
+  Skippable frames allow integration of user-defined data into a flow of concatenated frames.
+  Skippable frames will be ignored (skipped) by decompressor.
+  The format of skippable frames is as follows :
+  a) Skippable frame ID - 4 Bytes, Little endian format, any value from 0x184D2A50 to 0x184D2A5F
+  b) Frame Size - 4 Bytes, Little endian format, unsigned 32-bits
+  c) Frame Content - any content (User Data) of length equal to Frame Size
+  For skippable frames ZSTD_getFrameHeader() returns zfhPtr->frameType==ZSTD_skippableFrame.
+  For skippable frames ZSTD_decompressContinue() always returns 0 : it only skips the content.
+*/
+
+/*=====   Buffer-less streaming decompression functions  =====*/
+
+ZSTDLIB_STATIC_API size_t ZSTD_decodingBufferSize_min(unsigned long long windowSize, unsigned long long frameContentSize);  /**< when frame content size is not known, pass in frameContentSize == ZSTD_CONTENTSIZE_UNKNOWN */
+
+ZSTDLIB_STATIC_API size_t ZSTD_decompressBegin(ZSTD_DCtx* dctx);
+ZSTDLIB_STATIC_API size_t ZSTD_decompressBegin_usingDict(ZSTD_DCtx* dctx, const void* dict, size_t dictSize);
+ZSTDLIB_STATIC_API size_t ZSTD_decompressBegin_usingDDict(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict);
+
+ZSTDLIB_STATIC_API size_t ZSTD_nextSrcSizeToDecompress(ZSTD_DCtx* dctx);
+ZSTDLIB_STATIC_API size_t ZSTD_decompressContinue(ZSTD_DCtx* dctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize);
+
+/* misc */
+ZSTD_DEPRECATED("This function will likely be removed in the next minor release. It is misleading and has very limited utility.")
+ZSTDLIB_STATIC_API void   ZSTD_copyDCtx(ZSTD_DCtx* dctx, const ZSTD_DCtx* preparedDCtx);
+typedef enum { ZSTDnit_frameHeader, ZSTDnit_blockHeader, ZSTDnit_block, ZSTDnit_lastBlock, ZSTDnit_checksum, ZSTDnit_skippableFrame } ZSTD_nextInputType_e;
+ZSTDLIB_STATIC_API ZSTD_nextInputType_e ZSTD_nextInputType(ZSTD_DCtx* dctx);
+
+
+
+
+/* ========================================= */
+/**       Block level API (DEPRECATED)       */
+/* ========================================= */
+
+/*!
+
+    This API is deprecated in favor of the regular compression API.
+    You can get the frame header down to 2 bytes by setting:
+      - ZSTD_c_format = ZSTD_f_zstd1_magicless
+      - ZSTD_c_contentSizeFlag = 0
+      - ZSTD_c_checksumFlag = 0
+      - ZSTD_c_dictIDFlag = 0
+
+    This API is not as well tested as our normal API, so we recommend not using it.
+    We will be removing it in a future version. If the normal API doesn't provide
+    the functionality you need, please open a GitHub issue.
+
+    Block functions produce and decode raw zstd blocks, without frame metadata.
+    Frame metadata cost is typically ~12 bytes, which can be non-negligible for very small blocks (< 100 bytes).
+    But users will have to take in charge needed metadata to regenerate data, such as compressed and content sizes.
+
+    A few rules to respect :
+    - Compressing and decompressing require a context structure
+      + Use ZSTD_createCCtx() and ZSTD_createDCtx()
+    - It is necessary to init context before starting
+      + compression : any ZSTD_compressBegin*() variant, including with dictionary
+      + decompression : any ZSTD_decompressBegin*() variant, including with dictionary
+    - Block size is limited, it must be <= ZSTD_getBlockSize() <= ZSTD_BLOCKSIZE_MAX == 128 KB
+      + If input is larger than a block size, it's necessary to split input data into multiple blocks
+      + For inputs larger than a single block, consider using regular ZSTD_compress() instead.
+        Frame metadata is not that costly, and quickly becomes negligible as source size grows larger than a block.
+    - When a block is considered not compressible enough, ZSTD_compressBlock() result will be 0 (zero) !
+      ===> In which case, nothing is produced into `dst` !
+      + User __must__ test for such outcome and deal directly with uncompressed data
+      + A block cannot be declared incompressible if ZSTD_compressBlock() return value was != 0.
+        Doing so would mess up with statistics history, leading to potential data corruption.
+      + ZSTD_decompressBlock() _doesn't accept uncompressed data as input_ !!
+      + In case of multiple successive blocks, should some of them be uncompressed,
+        decoder must be informed of their existence in order to follow proper history.
+        Use ZSTD_insertBlock() for such a case.
+*/
+
+/*=====   Raw zstd block functions  =====*/
+ZSTD_DEPRECATED("The block API is deprecated in favor of the normal compression API. See docs.")
+ZSTDLIB_STATIC_API size_t ZSTD_getBlockSize   (const ZSTD_CCtx* cctx);
+ZSTD_DEPRECATED("The block API is deprecated in favor of the normal compression API. See docs.")
+ZSTDLIB_STATIC_API size_t ZSTD_compressBlock  (ZSTD_CCtx* cctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize);
+ZSTD_DEPRECATED("The block API is deprecated in favor of the normal compression API. See docs.")
+ZSTDLIB_STATIC_API size_t ZSTD_decompressBlock(ZSTD_DCtx* dctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize);
+ZSTD_DEPRECATED("The block API is deprecated in favor of the normal compression API. See docs.")
+ZSTDLIB_STATIC_API size_t ZSTD_insertBlock    (ZSTD_DCtx* dctx, const void* blockStart, size_t blockSize);  /**< insert uncompressed block into `dctx` history. Useful for multi-blocks decompression. */
+
+#endif   /* ZSTD_H_ZSTD_STATIC_LINKING_ONLY */
+
+#if defined (__cplusplus)
+}
+#endif
diff --git a/src/3rdparty/zstd/src/zstd_errors.h b/src/3rdparty/zstd/src/zstd_errors.h
new file mode 100644
index 0000000000..dc75eeebad
--- /dev/null
+++ b/src/3rdparty/zstd/src/zstd_errors.h
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * All rights reserved.
+ *
+ * This source code is licensed under both the BSD-style license (found in the
+ * LICENSE file in the root directory of this source tree) and the GPLv2 (found
+ * in the COPYING file in the root directory of this source tree).
+ * You may select, at your option, one of the above-listed licenses.
+ */
+
+#ifndef ZSTD_ERRORS_H_398273423
+#define ZSTD_ERRORS_H_398273423
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+/*===== dependency =====*/
+#include <stddef.h>   /* size_t */
+
+
+/* =====   ZSTDERRORLIB_API : control library symbols visibility   ===== */
+#ifndef ZSTDERRORLIB_VISIBLE
+   /* Backwards compatibility with old macro name */
+#  ifdef ZSTDERRORLIB_VISIBILITY
+#    define ZSTDERRORLIB_VISIBLE ZSTDERRORLIB_VISIBILITY
+#  elif defined(__GNUC__) && (__GNUC__ >= 4) && !defined(__MINGW32__)
+#    define ZSTDERRORLIB_VISIBLE __attribute__ ((visibility ("default")))
+#  else
+#    define ZSTDERRORLIB_VISIBLE
+#  endif
+#endif
+
+#ifndef ZSTDERRORLIB_HIDDEN
+#  if defined(__GNUC__) && (__GNUC__ >= 4) && !defined(__MINGW32__)
+#    define ZSTDERRORLIB_HIDDEN __attribute__ ((visibility ("hidden")))
+#  else
+#    define ZSTDERRORLIB_HIDDEN
+#  endif
+#endif
+
+#if defined(ZSTD_DLL_EXPORT) && (ZSTD_DLL_EXPORT==1)
+#  define ZSTDERRORLIB_API __declspec(dllexport) ZSTDERRORLIB_VISIBLE
+#elif defined(ZSTD_DLL_IMPORT) && (ZSTD_DLL_IMPORT==1)
+#  define ZSTDERRORLIB_API __declspec(dllimport) ZSTDERRORLIB_VISIBLE /* It isn't required but allows to generate better code, saving a function pointer load from the IAT and an indirect jump.*/
+#else
+#  define ZSTDERRORLIB_API ZSTDERRORLIB_VISIBLE
+#endif
+
+/*-*********************************************
+ *  Error codes list
+ *-*********************************************
+ *  Error codes _values_ are pinned down since v1.3.1 only.
+ *  Therefore, don't rely on values if you may link to any version < v1.3.1.
+ *
+ *  Only values < 100 are considered stable.
+ *
+ *  note 1 : this API shall be used with static linking only.
+ *           dynamic linking is not yet officially supported.
+ *  note 2 : Prefer relying on the enum than on its value whenever possible
+ *           This is the only supported way to use the error list < v1.3.1
+ *  note 3 : ZSTD_isError() is always correct, whatever the library version.
+ **********************************************/
+typedef enum {
+  ZSTD_error_no_error = 0,
+  ZSTD_error_GENERIC  = 1,
+  ZSTD_error_prefix_unknown                = 10,
+  ZSTD_error_version_unsupported           = 12,
+  ZSTD_error_frameParameter_unsupported    = 14,
+  ZSTD_error_frameParameter_windowTooLarge = 16,
+  ZSTD_error_corruption_detected = 20,
+  ZSTD_error_checksum_wrong      = 22,
+  ZSTD_error_literals_headerWrong = 24,
+  ZSTD_error_dictionary_corrupted      = 30,
+  ZSTD_error_dictionary_wrong          = 32,
+  ZSTD_error_dictionaryCreation_failed = 34,
+  ZSTD_error_parameter_unsupported   = 40,
+  ZSTD_error_parameter_combination_unsupported = 41,
+  ZSTD_error_parameter_outOfBound    = 42,
+  ZSTD_error_tableLog_tooLarge       = 44,
+  ZSTD_error_maxSymbolValue_tooLarge = 46,
+  ZSTD_error_maxSymbolValue_tooSmall = 48,
+  ZSTD_error_stabilityCondition_notRespected = 50,
+  ZSTD_error_stage_wrong       = 60,
+  ZSTD_error_init_missing      = 62,
+  ZSTD_error_memory_allocation = 64,
+  ZSTD_error_workSpace_tooSmall= 66,
+  ZSTD_error_dstSize_tooSmall = 70,
+  ZSTD_error_srcSize_wrong    = 72,
+  ZSTD_error_dstBuffer_null   = 74,
+  ZSTD_error_noForwardProgress_destFull = 80,
+  ZSTD_error_noForwardProgress_inputEmpty = 82,
+  /* following error codes are __NOT STABLE__, they can be removed or changed in future versions */
+  ZSTD_error_frameIndex_tooLarge = 100,
+  ZSTD_error_seekableIO          = 102,
+  ZSTD_error_dstBuffer_wrong     = 104,
+  ZSTD_error_srcBuffer_wrong     = 105,
+  ZSTD_error_sequenceProducer_failed = 106,
+  ZSTD_error_externalSequences_invalid = 107,
+  ZSTD_error_maxCode = 120  /* never EVER use this value directly, it can change in future versions! Use ZSTD_isError() instead */
+} ZSTD_ErrorCode;
+
+/*! ZSTD_getErrorCode() :
+    convert a `size_t` function result into a `ZSTD_ErrorCode` enum type,
+    which can be used to compare with enum list published above */
+ZSTDERRORLIB_API ZSTD_ErrorCode ZSTD_getErrorCode(size_t functionResult);
+ZSTDERRORLIB_API const char* ZSTD_getErrorString(ZSTD_ErrorCode code);   /**< Same as ZSTD_getErrorName, but using a `ZSTD_ErrorCode` enum argument */
+
+
+#if defined (__cplusplus)
+}
+#endif
+
+#endif /* ZSTD_ERRORS_H_398273423 */
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index afcdd1f463..f3f6f514cf 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -1,6 +1,8 @@
 # Copyright (C) 2022 The Qt Company Ltd.
 # SPDX-License-Identifier: BSD-3-Clause
 
+add_subdirectory(tools/syncqt)
+
 # We need to include the features of a few modules before they are actually declared.
 # The feature values are used as conditions for deciding whether bundled 3rd party libraries
 # should be built.
@@ -13,7 +15,22 @@ if(QT_FEATURE_gui)
     qt_feature_evaluate_features("${CMAKE_CURRENT_SOURCE_DIR}/gui/configure.cmake")
 endif()
 
-add_subdirectory(tools/syncqt)
+# These 3rd party libraries need to be built before corelib and tools, because they
+# does qt_find_package for them.
+if(QT_FEATURE_regularexpression AND NOT QT_FEATURE_system_pcre2)
+    add_subdirectory(3rdparty/pcre2)
+endif()
+qt_install_3rdparty_library_wrap_config_extra_file(BundledPcre2)
+
+if(NOT QT_FEATURE_system_zlib)
+    add_subdirectory(3rdparty/zlib)
+endif()
+qt_install_3rdparty_library_wrap_config_extra_file(BundledZLIB)
+
+if(NOT QT_FEATURE_system_zstd)
+    add_subdirectory(3rdparty/zstd)
+endif()
+qt_install_3rdparty_library_wrap_config_extra_file(BundledZSTD)
 
 function(find_or_build_bootstrap_names)
     if (QT_WILL_BUILD_TOOLS)
@@ -30,18 +47,6 @@ find_or_build_bootstrap_names()
 
 add_subdirectory(entrypoint)
 
-# These 3rd party libraries need to be built before corelib, because corelib
-# does qt_find_package for them.
-if(QT_FEATURE_regularexpression AND NOT QT_FEATURE_system_pcre2)
-    add_subdirectory(3rdparty/pcre2)
-endif()
-qt_install_3rdparty_library_wrap_config_extra_file(BundledPcre2)
-
-if(NOT QT_FEATURE_system_zlib)
-    add_subdirectory(3rdparty/zlib)
-endif()
-qt_install_3rdparty_library_wrap_config_extra_file(BundledZLIB)
-
 add_subdirectory(corelib)
 
 # Needs to be after corelib, because some of them reference Core.
diff --git a/src/corelib/CMakeLists.txt b/src/corelib/CMakeLists.txt
index d3f137847d..79c57138b3 100644
--- a/src/corelib/CMakeLists.txt
+++ b/src/corelib/CMakeLists.txt
@@ -4,7 +4,7 @@
 qt_find_package(Threads PROVIDED_TARGETS Threads::Threads)
 qt_find_package(WrapPCRE2 PROVIDED_TARGETS WrapPCRE2::WrapPCRE2)
 qt_find_package(WrapZLIB PROVIDED_TARGETS WrapZLIB::WrapZLIB)
-
+qt_find_package(WrapZSTD PROVIDED_TARGETS WrapZSTD::WrapZSTD)
 
 # compute the reverse relative path from QtCoreConfigExtras to the install prefix
 # this is used in QtCoreConfigExtras to make its install paths relocatable
@@ -327,6 +327,7 @@ qt_internal_add_module(Core
     LIBRARIES
         Qt::GlobalConfigPrivate
         WrapZLIB::WrapZLIB
+        WrapZSTD::WrapZSTD
     PRECOMPILED_HEADER
         "global/qt_pch.h"
     GENERATE_CPP_EXPORTS
@@ -489,9 +490,8 @@ qt_internal_extend_target(Core CONDITION QT_FEATURE_animation
 # from the wrong DLL at runtime and crash!
 qt_internal_extend_target(Core CONDITION QT_FEATURE_thread AND WIN32
     SOURCES
+        thread/qmutex_win.cpp
         thread/qwaitcondition_win.cpp
-    LIBRARIES
-        synchronization
 )
 
 qt_internal_extend_target(Core CONDITION WIN32
@@ -702,6 +702,11 @@ qt_internal_extend_target(Core CONDITION NOT QT_FEATURE_system_zlib
         Qt::ZlibPrivate
 )
 
+qt_internal_extend_target(Core CONDITION NOT QT_FEATURE_system_zstd
+    LIBRARIES
+        Qt::ZstdPrivate
+)
+
 qt_internal_extend_target(Core CONDITION QT_FEATURE_commandlineparser
     SOURCES
         tools/qcommandlineoption.cpp tools/qcommandlineoption.h
@@ -778,12 +783,6 @@ qt_internal_extend_target(Core CONDITION WIN32
         text/qlocale_win.cpp
 )
 
-# On MS-Win, clang has two flavors, one of which immitates MSVC (so claims to be it)
-qt_internal_extend_target(Core CONDITION WIN32 AND MSVC AND NOT CLANG
-    LIBRARIES
-        runtimeobject
-)
-
 qt_internal_extend_target(Core CONDITION QT_FEATURE_icu
     SOURCES
         text/qcollator_icu.cpp
@@ -877,11 +876,6 @@ qt_internal_extend_target(Core CONDITION QT_FEATURE_datetimeparser
         time/qdatetimeparser.cpp time/qdatetimeparser_p.h
 )
 
-qt_internal_extend_target(Core CONDITION QT_FEATURE_zstd
-    LIBRARIES
-        WrapZSTD::WrapZSTD
-)
-
 qt_internal_extend_target(Core CONDITION QT_FEATURE_filesystemwatcher
     SOURCES
         io/qfilesystemwatcher.cpp io/qfilesystemwatcher.h io/qfilesystemwatcher_p.h
@@ -991,7 +985,7 @@ qt_internal_extend_target(Core CONDITION ANDROID
         # place to put them.
 )
 
-qt_internal_extend_target(Core CONDITION WIN32
+qt_internal_extend_target(Core CONDITION QT_FEATURE_cpp_winrt
     SOURCES
         platform/windows/qfactorycacheregistration_p.h
         platform/windows/qfactorycacheregistration.cpp
@@ -1228,7 +1222,7 @@ if(QT_FEATURE_mimetype AND QT_FEATURE_mimetype_database)
         set(archiving_api "External")
     else()
         set(archiving_api "CMake")
-        if(QT_FEATURE_zstd AND NOT QT_CMAKE_ZSTD_SUPPORT)
+        if(NOT QT_CMAKE_ZSTD_SUPPORT)
             message(FATAL_ERROR
                 "CMake was not built with zstd support. "
                 "Rebuild CMake or set QT_AVOID_CMAKE_ARCHIVING_API=ON.")
@@ -1244,15 +1238,8 @@ if(QT_FEATURE_mimetype AND QT_FEATURE_mimetype_database)
             " ${INPUT_mimetype_database_compression}\nSupported compression types:\n"
             "    ${supported_compression_types}")
         endif()
-        if(compression_type STREQUAL "zstd" AND NOT QT_FEATURE_zstd)
-            message(FATAL_ERROR
-                "zstd compression is selected for mime type database, but the 'zstd'"
-                " feature is disabled.")
-        endif()
-    elseif(QT_FEATURE_zstd)
-        set(compression_type "zstd")
     else()
-        set(compression_type "gzip")
+        set(compression_type "zstd")
     endif()
 
     if(QT_INTERNAL_ENABLE_VERBOSE_MIME_DATABASE_COMPRESSION)
@@ -1303,6 +1290,7 @@ qt_internal_extend_target(Core CONDITION QT_FEATURE_ctf AND QT_FEATURE_library
 set_source_files_properties(
     thread/qmutex_mac.cpp
     thread/qmutex_unix.cpp
+    thread/qmutex_win.cpp
     PROPERTIES HEADER_FILE_ONLY ON)  # special case: These files are included by qmutex.cpp!
 
 # Remove QT_NO_CAST_TO_ASCII to ensure that the symbols are included in the library.
diff --git a/src/corelib/Qt6CoreMacros.cmake b/src/corelib/Qt6CoreMacros.cmake
index d50ec5257a..31171c758f 100644
--- a/src/corelib/Qt6CoreMacros.cmake
+++ b/src/corelib/Qt6CoreMacros.cmake
@@ -261,10 +261,6 @@ function(qt6_add_binary_resources target )
     set(rcc_options ${_RCC_OPTIONS})
     set(rcc_destination ${_RCC_DESTINATION})
 
-    if(NOT QT_FEATURE_zstd)
-        list(APPEND rcc_options "--no-zstd")
-    endif()
-
     if(NOT rcc_destination)
         set(rcc_destination ${CMAKE_CURRENT_BINARY_DIR}/${target}.rcc)
     endif()
@@ -329,10 +325,6 @@ function(qt6_add_resources outfiles )
             message(WARNING "Use qt6_add_binary_resources for binary option")
         endif()
 
-        if(NOT QT_FEATURE_zstd)
-            list(APPEND rcc_options "--no-zstd")
-        endif()
-
         foreach(it ${rcc_files})
             get_filename_component(outfilename ${it} NAME_WE)
             get_filename_component(infile ${it} ABSOLUTE)
@@ -409,10 +401,6 @@ function(qt6_add_big_resources outfiles )
         message(WARNING "Use qt6_add_binary_resources for binary option")
     endif()
 
-    if(NOT QT_FEATURE_zstd)
-        list(APPEND rcc_options "--no-zstd")
-    endif()
-
     foreach(it ${rcc_files})
         get_filename_component(outfilename ${it} NAME_WE)
 
@@ -1951,16 +1939,6 @@ function(_qt_internal_process_resource target resourceName)
         list(APPEND rccArgsAllPasses ${rcc_OPTIONS})
     endif()
 
-    # When cross-building, we use host tools to generate target code. If the host rcc was compiled
-    # with zstd support, it expects the target QtCore to be able to decompress zstd compressed
-    # content. This might be true with qmake where host tools are built as part of the
-    # cross-compiled Qt, but with CMake we build tools separate from the cross-compiled Qt.
-    # If the target does not support zstd (feature is disabled), tell rcc not to generate
-    # zstd related code.
-    if(NOT QT_FEATURE_zstd)
-        list(APPEND rccArgsAllPasses "--no-zstd")
-    endif()
-
     set_property(SOURCE "${generatedResourceFile}" PROPERTY SKIP_AUTOGEN ON)
 
     # Set output file name for rcc command
diff --git a/src/corelib/configure.cmake b/src/corelib/configure.cmake
index 7d52f48f57..a39f784a6d 100644
--- a/src/corelib/configure.cmake
+++ b/src/corelib/configure.cmake
@@ -474,8 +474,6 @@ closelog();
 # cpp_winrt
 qt_config_compile_test(cpp_winrt
     LABEL "cpp/winrt"
-    LIBRARIES
-        runtimeobject
     CODE
 "// Including winrt/base.h causes an error in some configurations (Windows 10 SDK + c++20)
 #   include <winrt/base.h>
diff --git a/src/corelib/global/qlibraryinfo.cpp b/src/corelib/global/qlibraryinfo.cpp
index 715bda488c..f4f20b579d 100644
--- a/src/corelib/global/qlibraryinfo.cpp
+++ b/src/corelib/global/qlibraryinfo.cpp
@@ -296,8 +296,13 @@ static QString prefixFromQtCoreLibraryHelper(const QString &qtCoreLibraryPath)
 {
     const QString qtCoreLibrary = QDir::fromNativeSeparators(qtCoreLibraryPath);
     const QString libDir = QFileInfo(qtCoreLibrary).absolutePath();
-    const QString prefixDir = libDir + "/" QT_CONFIGURE_LIBLOCATION_TO_PREFIX_PATH;
-    return QDir::cleanPath(prefixDir);
+    return QDir::cleanPath([&libDir]() -> QString {
+        static const bool hack = qEnvironmentVariableIntValue("QT_FORCE_LOAD_PLUGINS_FROM_CORE_DIR");
+        if (hack) {
+            return libDir;
+        }
+        return libDir + "/"_L1 + QT_CONFIGURE_LIBLOCATION_TO_PREFIX_PATH;
+    }());
 }
 #endif
 
@@ -686,6 +691,17 @@ const char *qVersion() noexcept
     return QT_VERSION_STR;
 }
 
+/*!
+    A special function to identify this custom Qt build.
+    It will always return the magic number "2546789017"
+    as the result. It's my QQ number and you can contact
+    me by sending me an e-mail to "2546789017@qq.com".
+*/
+quint64 __wangwenx190__() noexcept
+{
+    return 2546789017;
+}
+
 #if QT_DEPRECATED_SINCE(6, 9)
 
 bool qSharedBuild() noexcept
diff --git a/src/corelib/global/qlibraryinfo.h b/src/corelib/global/qlibraryinfo.h
index d4e8f8b050..6cd0b448cf 100644
--- a/src/corelib/global/qlibraryinfo.h
+++ b/src/corelib/global/qlibraryinfo.h
@@ -61,6 +61,11 @@ Q_CORE_EXPORT Q_DECL_CONST_FUNCTION bool qSharedBuild() noexcept;
 
 #endif
 
+#if (!defined(QT_NAMESPACE) && defined(__cplusplus))
+extern "C"
+#endif
+Q_CORE_EXPORT Q_DECL_CONST_FUNCTION quint64 __wangwenx190__(void) noexcept;
+
 QT_END_NAMESPACE
 
 #endif // QLIBRARYINFO_H
diff --git a/src/corelib/global/qoperatingsystemversion.cpp b/src/corelib/global/qoperatingsystemversion.cpp
index 044b1452f2..a4a717ffd0 100644
--- a/src/corelib/global/qoperatingsystemversion.cpp
+++ b/src/corelib/global/qoperatingsystemversion.cpp
@@ -361,6 +361,9 @@ bool QOperatingSystemVersionBase::isAnyOfType(std::initializer_list<OSType> type
 
 #ifndef QT_BOOTSTRAPPED
 
+const QOperatingSystemVersion QOperatingSystemVersion::WindowsVista =
+    QOperatingSystemVersion(QOperatingSystemVersion::Windows, 6, 0);
+
 /*!
     \variable QOperatingSystemVersion::Windows7
     \brief a version corresponding to Windows 7 (version 6.1).
@@ -393,6 +396,13 @@ const QOperatingSystemVersion QOperatingSystemVersion::Windows8_1 =
 const QOperatingSystemVersion QOperatingSystemVersion::Windows10 =
     QOperatingSystemVersion(QOperatingSystemVersion::Windows, 10);
 
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1507;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1511;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1607;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1703;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1709;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1803;
+
 /*!
     \variable QOperatingSystemVersion::Windows10_1809
     \brief a version corresponding to Windows 10 October 2018 Update
diff --git a/src/corelib/global/qoperatingsystemversion.h b/src/corelib/global/qoperatingsystemversion.h
index dc830f9736..adcd9fc6e9 100644
--- a/src/corelib/global/qoperatingsystemversion.h
+++ b/src/corelib/global/qoperatingsystemversion.h
@@ -123,6 +123,7 @@ public:
     // until Qt7
     // @note: New entries should be added after the if-def-ery until Qt 7!!
 #if QT_VERSION < QT_VERSION_CHECK(7, 0, 0) && !defined(QT_BOOTSTRAPPED)
+    static const QOperatingSystemVersion WindowsVista;
     static const QOperatingSystemVersion Windows7;
     static const QOperatingSystemVersion Windows8;
     static const QOperatingSystemVersion Windows8_1;
@@ -153,6 +154,7 @@ public:
     static const QOperatingSystemVersion Android10;
     static const QOperatingSystemVersion Android11;
 #else
+    static constexpr QOperatingSystemVersionBase WindowsVista { QOperatingSystemVersionBase::Windows, 6, 0 };
     static constexpr QOperatingSystemVersionBase Windows7 { QOperatingSystemVersionBase::Windows, 6, 1 };
     static constexpr QOperatingSystemVersionBase Windows8 { QOperatingSystemVersionBase::Windows, 6, 2 };
     static constexpr QOperatingSystemVersionBase Windows8_1 { QOperatingSystemVersionBase::Windows, 6, 3 };
@@ -184,6 +186,12 @@ public:
     static constexpr QOperatingSystemVersionBase Android11 { QOperatingSystemVersionBase::Android, 11, 0 };
 #endif // New (static constexpr) entries go here, only cherry-pick as far back as 6.3 (QTBUG-97808):
 
+    static constexpr QOperatingSystemVersionBase Windows10_1507 { QOperatingSystemVersionBase::Windows, 10, 0, 10240 }; // TH1
+    static constexpr QOperatingSystemVersionBase Windows10_1511 { QOperatingSystemVersionBase::Windows, 10, 0, 10586 }; // TH2
+    static constexpr QOperatingSystemVersionBase Windows10_1607 { QOperatingSystemVersionBase::Windows, 10, 0, 14393 }; // RS1
+    static constexpr QOperatingSystemVersionBase Windows10_1703 { QOperatingSystemVersionBase::Windows, 10, 0, 15063 }; // RS2
+    static constexpr QOperatingSystemVersionBase Windows10_1709 { QOperatingSystemVersionBase::Windows, 10, 0, 16299 }; // RS3
+    static constexpr QOperatingSystemVersionBase Windows10_1803 { QOperatingSystemVersionBase::Windows, 10, 0, 17134 }; // RS4
     static constexpr QOperatingSystemVersionBase Windows10_1809 { QOperatingSystemVersionBase::Windows, 10, 0, 17763 }; // RS5
     static constexpr QOperatingSystemVersionBase Windows10_1903 { QOperatingSystemVersionBase::Windows, 10, 0, 18362 }; // 19H1
     static constexpr QOperatingSystemVersionBase Windows10_1909 { QOperatingSystemVersionBase::Windows, 10, 0, 18363 }; // 19H2
@@ -203,6 +211,38 @@ public:
     static constexpr QOperatingSystemVersionBase MacOSVentura { QOperatingSystemVersionBase::MacOS, 13, 0 };
     static constexpr QOperatingSystemVersionBase MacOSSonoma { QOperatingSystemVersionBase::MacOS, 14, 0 };
 
+#ifdef Q_OS_WINDOWS
+#  define MAKE_VERSION_FUNCTION(Name, Version) \
+    [[nodiscard]] static inline bool isWin##Name##OrGreater() \
+    { \
+        static const bool result = QOperatingSystemVersion::current() >= QOperatingSystemVersion::Windows##Version; \
+        return result; \
+    }
+    MAKE_VERSION_FUNCTION(Vista, Vista)
+    MAKE_VERSION_FUNCTION(7, 7)
+    MAKE_VERSION_FUNCTION(8, 8)
+    MAKE_VERSION_FUNCTION(8Point1, 8_1)
+    MAKE_VERSION_FUNCTION(10, 10)
+    MAKE_VERSION_FUNCTION(10TH1, 10_1507)
+    MAKE_VERSION_FUNCTION(10TH2, 10_1511)
+    MAKE_VERSION_FUNCTION(10RS1, 10_1607)
+    MAKE_VERSION_FUNCTION(10RS2, 10_1703)
+    MAKE_VERSION_FUNCTION(10RS3, 10_1709)
+    MAKE_VERSION_FUNCTION(10RS4, 10_1803)
+    MAKE_VERSION_FUNCTION(10RS5, 10_1809)
+    MAKE_VERSION_FUNCTION(1019H1, 10_1903)
+    MAKE_VERSION_FUNCTION(1019H2, 10_1909)
+    MAKE_VERSION_FUNCTION(1020H1, 10_2004)
+    MAKE_VERSION_FUNCTION(1020H2, 10_20H2)
+    MAKE_VERSION_FUNCTION(1021H1, 10_21H1)
+    MAKE_VERSION_FUNCTION(1021H2, 10_21H2)
+    MAKE_VERSION_FUNCTION(1022H2, 10_22H2)
+    MAKE_VERSION_FUNCTION(11, 11)
+    MAKE_VERSION_FUNCTION(1121H2, 11_21H2)
+    MAKE_VERSION_FUNCTION(1122H2, 11_22H2)
+#  undef MAKE_VERSION_FUNCTION
+#endif // Q_OS_WINDOWS
+
     constexpr QOperatingSystemVersion(const QOperatingSystemVersionBase &osversion)
         : QOperatingSystemVersionBase(osversion) {}
 
diff --git a/src/corelib/global/qoperatingsystemversion_win.cpp b/src/corelib/global/qoperatingsystemversion_win.cpp
index a209fb17b6..50edb719fd 100644
--- a/src/corelib/global/qoperatingsystemversion_win.cpp
+++ b/src/corelib/global/qoperatingsystemversion_win.cpp
@@ -51,7 +51,18 @@ OSVERSIONINFOEX qWindowsVersionInfo()
             result.wServicePackMinor = 0;
 
             const QByteArray winVerOverride = qgetenv("QT_WINVER_OVERRIDE");
-            if (winVerOverride == "WINDOWS10" || winVerOverride == "2016"
+            if (winVerOverride == "WINDOWSVISTA" || winVerOverride == "2008") {
+                result.dwMajorVersion = 6;
+            } else if (winVerOverride == "WINDOWS7" || winVerOverride == "2008_R2") {
+                result.dwMajorVersion = 6;
+                result.dwMinorVersion = 1;
+            } else if (winVerOverride == "WINDOWS8" || winVerOverride == "2012") {
+                result.dwMajorVersion = 6;
+                result.dwMinorVersion = 2;
+            } else if (winVerOverride == "WINDOWS8_1" || winVerOverride == "2012_R2") {
+                result.dwMajorVersion = 6;
+                result.dwMinorVersion = 3;
+            } else if (winVerOverride == "WINDOWS10" || winVerOverride == "2016"
                 || winVerOverride == "2019" || winVerOverride == "2022") {
                 result.dwMajorVersion = 10;
             } else if (winVerOverride == "WINDOWS11") {
@@ -61,7 +72,12 @@ OSVERSIONINFOEX qWindowsVersionInfo()
                 return realResult;
             }
 
-            if (winVerOverride == "2016" || winVerOverride == "2019"
+            if (winVerOverride == "2008"
+                || winVerOverride == "2008_R2"
+                || winVerOverride == "2012"
+                || winVerOverride == "2012_R2"
+                || winVerOverride == "2016"
+                || winVerOverride == "2019"
                 || winVerOverride == "2022") {
                 // If the current host OS is a domain controller and the override OS
                 // is also a server type OS, preserve that information
diff --git a/src/corelib/global/qsysinfo.cpp b/src/corelib/global/qsysinfo.cpp
index 3654b70984..00462cc1cf 100644
--- a/src/corelib/global/qsysinfo.cpp
+++ b/src/corelib/global/qsysinfo.cpp
@@ -165,12 +165,17 @@ static inline QString windowsDisplayVersion()
 {
     // https://tickets.puppetlabs.com/browse/FACT-3058
     // The "ReleaseId" key stopped updating since Windows 10 20H2.
-    if (QOperatingSystemVersion::current() >= QOperatingSystemVersion::Windows10_20H2)
+    if (QOperatingSystemVersion::isWin1020H2OrGreater())
         return readVersionRegistryString(L"DisplayVersion");
     else
         return readVersionRegistryString(L"ReleaseId");
 }
 
+static QString windows7Build()
+{
+    return readVersionRegistryString(L"CurrentBuild");
+}
+
 static QString winSp_helper()
 {
     const auto osv = qWindowsVersionInfo();
@@ -194,6 +199,14 @@ static const char *osVer_helper(QOperatingSystemVersion version = QOperatingSyst
 
 #define Q_WINVER(major, minor) (major << 8 | minor)
     switch (Q_WINVER(osver.dwMajorVersion, osver.dwMinorVersion)) {
+    case Q_WINVER(6, 0):
+        return workstation ? "Vista" : "Server 2008";
+    case Q_WINVER(6, 1):
+        return workstation ? "7" : "Server 2008 R2";
+    case Q_WINVER(6, 2):
+        return workstation ? "8" : "Server 2012";
+    case Q_WINVER(6, 3):
+        return workstation ? "8.1" : "Server 2012 R2";
     case Q_WINVER(10, 0):
         if (workstation) {
             if (osver.dwBuildNumber >= 22000)
@@ -885,10 +898,21 @@ QString QSysInfo::prettyProductName()
     return result + " ("_L1 + versionString + u')';
 #  else
     // (resembling winver.exe): Windows 10 "Windows 10 Version 1809"
-    const auto displayVersion = windowsDisplayVersion();
-    if (!displayVersion.isEmpty())
-        result += " Version "_L1 + displayVersion;
-    return result;
+    if (majorVersion >= 10) {
+        const auto displayVersion = windowsDisplayVersion();
+        if (!displayVersion.isEmpty())
+            result += " Version "_L1 + displayVersion;
+        return result;
+    }
+    // Windows 7: "Windows 7 Version 6.1 (Build 7601: Service Pack 1)"
+    result += " Version "_L1 + versionString + " ("_L1;
+    const auto build = windows7Build();
+    if (!build.isEmpty())
+        result += "Build "_L1 + build;
+    const auto servicePack = winSp_helper();
+    if (!servicePack.isEmpty())
+        result += ": "_L1 + servicePack;
+    return result + u')';
 #  endif // Windows
 #elif defined(Q_OS_HAIKU)
     return "Haiku "_L1 + productVersion();
diff --git a/src/corelib/io/qfilesystemengine_win.cpp b/src/corelib/io/qfilesystemengine_win.cpp
index 6d085d98c9..f39ac6af09 100644
--- a/src/corelib/io/qfilesystemengine_win.cpp
+++ b/src/corelib/io/qfilesystemengine_win.cpp
@@ -1027,7 +1027,10 @@ QByteArray QFileSystemEngine::id(const QFileSystemEntry &entry)
 //static
 QByteArray QFileSystemEngine::id(HANDLE fHandle)
 {
-    return fileIdWin8(HANDLE(fHandle));
+    if (QOperatingSystemVersion::isWin8OrGreater())
+        return fileIdWin8(HANDLE(fHandle));
+    else
+        return fileId(HANDLE(fHandle));
 }
 
 //static
@@ -1747,41 +1750,76 @@ bool QFileSystemEngine::moveFileToTrash(const QFileSystemEntry &source,
     // we need the "display name" of the file, so can't use nativeAbsoluteFilePath
     const QString sourcePath = QDir::toNativeSeparators(absoluteName(source).filePath());
 
-    QComHelper comHelper;
-
-    IFileOperation *pfo = nullptr;
-    IShellItem *deleteItem = nullptr;
-    FileOperationProgressSink *sink = nullptr;
-    HRESULT hres = E_FAIL;
-
-    auto coUninitialize = qScopeGuard([&](){
-        if (sink)
-            sink->Release();
-        if (deleteItem)
-            deleteItem->Release();
-        if (pfo)
-            pfo->Release();
+    /*
+        Windows 7 insists on showing confirmation dialogs and ignores the respective
+        flags set on IFileOperation. Fall back to SHFileOperation, even if it doesn't
+        give us the new location of the file.
+    */
+    if (QOperatingSystemVersion::isWin8OrGreater()) {
+        QComHelper comHelper;
+
+        IFileOperation *pfo = nullptr;
+        IShellItem *deleteItem = nullptr;
+        FileOperationProgressSink *sink = nullptr;
+        HRESULT hres = E_FAIL;
+
+        auto coUninitialize = qScopeGuard([&](){
+            if (sink)
+                sink->Release();
+            if (deleteItem)
+                deleteItem->Release();
+            if (pfo)
+                pfo->Release();
+            if (!SUCCEEDED(hres))
+                error = QSystemError(hres, QSystemError::NativeError);
+        });
+
+        hres = CoCreateInstance(CLSID_FileOperation, nullptr, CLSCTX_ALL, IID_PPV_ARGS(&pfo));
+        if (!pfo)
+            return false;
+        pfo->SetOperationFlags(FOF_ALLOWUNDO | FOFX_RECYCLEONDELETE | FOF_NOCONFIRMATION
+                            | FOF_SILENT | FOF_NOERRORUI);
+        hres = SHCreateItemFromParsingName(reinterpret_cast<const wchar_t*>(sourcePath.utf16()),
+                                        nullptr, IID_PPV_ARGS(&deleteItem));
+        if (!deleteItem)
+            return false;
+        sink = new FileOperationProgressSink;
+        hres = pfo->DeleteItem(deleteItem, static_cast<IFileOperationProgressSink*>(sink));
         if (!SUCCEEDED(hres))
-            error = QSystemError(hres, QSystemError::NativeError);
-    });
-
-    hres = CoCreateInstance(CLSID_FileOperation, nullptr, CLSCTX_ALL, IID_PPV_ARGS(&pfo));
-    if (!pfo)
-        return false;
-    pfo->SetOperationFlags(FOF_ALLOWUNDO | FOFX_RECYCLEONDELETE | FOF_NOCONFIRMATION
-                        | FOF_SILENT | FOF_NOERRORUI);
-    hres = SHCreateItemFromParsingName(reinterpret_cast<const wchar_t*>(sourcePath.utf16()),
-                                    nullptr, IID_PPV_ARGS(&deleteItem));
-    if (!deleteItem)
-        return false;
-    sink = new FileOperationProgressSink;
-    hres = pfo->DeleteItem(deleteItem, static_cast<IFileOperationProgressSink*>(sink));
-    if (!SUCCEEDED(hres))
-        return false;
-    hres = pfo->PerformOperations();
-    if (!SUCCEEDED(hres))
-        return false;
-    newLocation = QFileSystemEntry(sink->targetPath);
+            return false;
+        hres = pfo->PerformOperations();
+        if (!SUCCEEDED(hres))
+            return false;
+        newLocation = QFileSystemEntry(sink->targetPath);
+    } else {
+        // double null termination needed, so can't use QString::utf16
+        QVarLengthArray<wchar_t, MAX_PATH + 1> winFile(sourcePath.length() + 2);
+        sourcePath.toWCharArray(winFile.data());
+        winFile[sourcePath.length()] = wchar_t{};
+        winFile[sourcePath.length() + 1] = wchar_t{};
+
+        SHFILEOPSTRUCTW operation;
+        operation.hwnd = nullptr;
+        operation.wFunc = FO_DELETE;
+        operation.pFrom = winFile.constData();
+        operation.pTo = nullptr;
+        operation.fFlags = FOF_ALLOWUNDO | FOF_NO_UI;
+        operation.fAnyOperationsAborted = FALSE;
+        operation.hNameMappings = nullptr;
+        operation.lpszProgressTitle = nullptr;
+
+        int result = SHFileOperation(&operation);
+        if (result != 0) {
+            error = QSystemError(result, QSystemError::NativeError);
+            return false;
+        }
+        /*
+            This implementation doesn't let us know where the file ended up, even if
+            we would specify FOF_WANTMAPPINGHANDLE | FOF_RENAMEONCOLLISION, as
+            FOF_RENAMEONCOLLISION has no effect unless files are moved, copied, or renamed.
+        */
+        Q_UNUSED(newLocation);
+    }
 
     return true;
 }
diff --git a/src/corelib/io/qfilesystemiterator_win.cpp b/src/corelib/io/qfilesystemiterator_win.cpp
index 2c16cc7f6b..5be794920c 100644
--- a/src/corelib/io/qfilesystemiterator_win.cpp
+++ b/src/corelib/io/qfilesystemiterator_win.cpp
@@ -55,8 +55,10 @@ bool QFileSystemIterator::advance(QFileSystemEntry &fileEntry, QFileSystemMetaDa
         haveData = true;
         int infoLevel = 0 ;         // FindExInfoStandard;
         DWORD dwAdditionalFlags  = 0;
-        dwAdditionalFlags = 2;  // FIND_FIRST_EX_LARGE_FETCH
-        infoLevel = 1 ;         // FindExInfoBasic;
+        if (QOperatingSystemVersion::isWin7OrGreater()) {
+            dwAdditionalFlags = 2;  // FIND_FIRST_EX_LARGE_FETCH
+            infoLevel = 1 ;         // FindExInfoBasic;
+        }
         int searchOps =  0;         // FindExSearchNameMatch
         if (onlyDirs)
             searchOps = 1 ;         // FindExSearchLimitToDirectories
diff --git a/src/corelib/io/qlockfile_win.cpp b/src/corelib/io/qlockfile_win.cpp
index b9d7721517..33a4291035 100644
--- a/src/corelib/io/qlockfile_win.cpp
+++ b/src/corelib/io/qlockfile_win.cpp
@@ -13,8 +13,12 @@
 #include "QtCore/qdebug.h"
 #include "QtCore/qthread.h"
 
+#include <QtCore/private/qsystemlibrary_p.h>
+
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 static inline bool fileExists(const wchar_t *fileName)
 {
     WIN32_FILE_ATTRIBUTE_DATA  data;
@@ -96,12 +100,16 @@ bool QLockFilePrivate::isProcessRunning(qint64 pid, const QString &appname)
 
 QString QLockFilePrivate::processNameByPid(qint64 pid)
 {
+    static const auto pGetModuleFileNameExW =
+        reinterpret_cast<decltype(&::GetModuleFileNameExW)>(
+            QSystemLibrary::resolve(u"psapi"_s, "GetModuleFileNameExW"));
+    if (!pGetModuleFileNameExW)
+        return QString();
     HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, DWORD(pid));
-    if (!hProcess) {
+    if (!hProcess)
         return QString();
-    }
     wchar_t buf[MAX_PATH];
-    const DWORD length = GetModuleFileNameExW(hProcess, NULL, buf, sizeof(buf) / sizeof(wchar_t));
+    const DWORD length = pGetModuleFileNameExW(hProcess, NULL, buf, sizeof(buf) / sizeof(wchar_t));
     CloseHandle(hProcess);
     if (!length)
         return QString();
diff --git a/src/corelib/io/qresource.cpp b/src/corelib/io/qresource.cpp
index c8dc09dbed..9dd976e8ce 100644
--- a/src/corelib/io/qresource.cpp
+++ b/src/corelib/io/qresource.cpp
@@ -28,8 +28,6 @@
 #ifndef QT_NO_COMPRESS
 #  include <zconf.h>
 #  include <zlib.h>
-#endif
-#if QT_CONFIG(zstd)
 #  include <zstd.h>
 #endif
 
@@ -58,8 +56,6 @@ using namespace Qt::StringLiterals;
 
 #ifndef QT_NO_COMPRESS
 RCC_FEATURE_SYMBOL(Zlib)
-#endif
-#if QT_CONFIG(zstd)
 RCC_FEATURE_SYMBOL(Zstd)
 #endif
 
@@ -398,27 +394,22 @@ qint64 QResourcePrivate::uncompressedSize() const
     switch (compressionAlgo) {
     case QResource::NoCompression:
         return size;
-
-    case QResource::ZlibCompression:
 #ifndef QT_NO_COMPRESS
+    case QResource::ZlibCompression:
         if (size_t(size) >= sizeof(quint32))
             return qFromBigEndian<quint32>(data);
-#else
-        Q_ASSERT(!"QResource: Qt built without support for Zlib compression");
-        Q_UNREACHABLE();
-#endif
         break;
-
     case QResource::ZstdCompression: {
-#if QT_CONFIG(zstd)
-        size_t n = ZSTD_getFrameContentSize(data, size);
+        const size_t n = ZSTD_getFrameContentSize(data, size);
         return ZSTD_isError(n) ? -1 : qint64(n);
+    }
 #else
-        // This should not happen because we've refused to load such resource
-        Q_ASSERT(!"QResource: Qt built without support for Zstd compression");
+    case QResource::ZlibCompression:
+    case QResource::ZstdCompression: {
+        Q_ASSERT(!"QResource: Qt built without support for decompression");
         Q_UNREACHABLE();
-#endif
     }
+#endif
     }
     return -1;
 }
@@ -426,7 +417,7 @@ qint64 QResourcePrivate::uncompressedSize() const
 qsizetype QResourcePrivate::decompress(char *buffer, qsizetype bufferSize) const
 {
     Q_ASSERT(data);
-#if defined(QT_NO_COMPRESS) && !QT_CONFIG(zstd)
+#if defined(QT_NO_COMPRESS)
     Q_UNUSED(buffer);
     Q_UNUSED(bufferSize);
 #endif
@@ -435,9 +426,8 @@ qsizetype QResourcePrivate::decompress(char *buffer, qsizetype bufferSize) const
     case QResource::NoCompression:
         Q_UNREACHABLE();
         break;
-
-    case QResource::ZlibCompression: {
 #ifndef QT_NO_COMPRESS
+    case QResource::ZlibCompression: {
         uLong len = uLong(bufferSize);
         int res = ::uncompress(reinterpret_cast<Bytef *>(buffer), &len, data + sizeof(quint32),
                                uLong(size - sizeof(quint32)));
@@ -446,23 +436,22 @@ qsizetype QResourcePrivate::decompress(char *buffer, qsizetype bufferSize) const
             return -1;
         }
         return len;
-#else
-        Q_UNREACHABLE();
-#endif
     }
-
     case QResource::ZstdCompression: {
-#if QT_CONFIG(zstd)
-        size_t usize = ZSTD_decompress(buffer, bufferSize, data, size);
+        const size_t usize = ZSTD_decompress(buffer, bufferSize, data, size);
         if (ZSTD_isError(usize)) {
             qWarning("QResource: error decompressing zstd content: %s", ZSTD_getErrorName(usize));
             return -1;
         }
         return usize;
+    }
 #else
+    case QResource::ZlibCompression:
+    case QResource::ZstdCompression: {
+        Q_ASSERT(!"QResource: Qt built without support for decompression");
         Q_UNREACHABLE();
-#endif
     }
+#endif
     }
 
     return -1;
@@ -1074,10 +1063,8 @@ public:
         // And some sanity checking for features
         quint32 acceptableFlags = 0;
 #ifndef QT_NO_COMPRESS
-        acceptableFlags |= Compressed;
+        acceptableFlags |= (Compressed | CompressedZstd);
 #endif
-        if (QT_CONFIG(zstd))
-            acceptableFlags |= CompressedZstd;
         if (file_flags & ~acceptableFlags)
             return false;
 
diff --git a/src/corelib/io/qstandardpaths_win.cpp b/src/corelib/io/qstandardpaths_win.cpp
index 13b8fe224a..581e2695fe 100644
--- a/src/corelib/io/qstandardpaths_win.cpp
+++ b/src/corelib/io/qstandardpaths_win.cpp
@@ -10,6 +10,7 @@
 #include <qcoreapplication.h>
 #endif
 
+#include <qoperatingsystemversion.h>
 #include <qt_windows.h>
 #include <shlobj.h>
 #include <intshcut.h>
@@ -60,6 +61,9 @@ static inline void appendTestMode(QString &path)
 
 static bool isProcessLowIntegrity()
 {
+    if (!QOperatingSystemVersion::isWin8OrGreater())
+        return false;
+
     // same as GetCurrentProcessToken()
     const auto process_token = HANDLE(quintptr(-4));
 
diff --git a/src/corelib/kernel/qcoreapplication.cpp b/src/corelib/kernel/qcoreapplication.cpp
index b0e0dc03ff..10006be542 100644
--- a/src/corelib/kernel/qcoreapplication.cpp
+++ b/src/corelib/kernel/qcoreapplication.cpp
@@ -37,6 +37,7 @@
 #include <qelapsedtimer.h>
 #include <qlibraryinfo.h>
 #include <qvarlengtharray.h>
+#include <qoperatingsystemversion.h>
 #include <private/qfactoryloader_p.h>
 #include <private/qfunctions_p.h>
 #include <private/qlocale_p.h>
@@ -123,6 +124,10 @@ Q_TRACE_POINT(qtcore, QCoreApplication_sendSpontaneousEvent, QObject *receiver,
 Q_TRACE_POINT(qtcore, QCoreApplication_notify_entry, QObject *receiver, QEvent *event, QEvent::Type type);
 Q_TRACE_POINT(qtcore, QCoreApplication_notify_exit, bool consumed, bool filtered);
 
+#ifndef QT_BOOTSTRAPPED
+static constexpr const char kWwx190EnvVar[] = "__wangwenx190__";
+#endif
+
 #if defined(Q_OS_WIN) || defined(Q_OS_MAC)
 extern QString qAppFileName();
 #endif
@@ -461,6 +466,9 @@ QCoreApplicationPrivate::QCoreApplicationPrivate(int &aargc, char **aargv)
 
 QCoreApplicationPrivate::~QCoreApplicationPrivate()
 {
+#ifndef QT_BOOTSTRAPPED
+    qunsetenv(kWwx190EnvVar);
+#endif
 #ifndef QT_NO_QOBJECT
     cleanupThreadData();
 #endif
@@ -583,6 +591,33 @@ void QCoreApplicationPrivate::initConsole()
         // Unknown input, don't make any decision for the user.
         return;
     }
+    if (qEnvironmentVariableIntValue("QT_WIN_DEBUG_CONSOLE_USE_UTF8")) {
+        SetConsoleCP(CP_UTF8);
+        SetConsoleOutputCP(CP_UTF8);
+    }
+    if (consoleAllocated) {
+        SetConsoleTitleW([]() -> const wchar_t * {
+            const QString appName = QCoreApplication::applicationName();
+            if (appName.isEmpty())
+                return L"Qt debug window";
+            return reinterpret_cast<const wchar_t *>(
+                        (u"%1 debug window"_s.arg(appName)).utf16());
+        }());
+    }
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        const auto enableVirtualTerminalProcessingForHandle =
+            [](const HANDLE handle) -> void {
+                if (!handle || handle == INVALID_HANDLE_VALUE)
+                    return;
+                DWORD mode = 0;
+                if (GetConsoleMode(handle, &mode) == FALSE)
+                    return;
+                mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
+                SetConsoleMode(handle, mode);
+            };
+        enableVirtualTerminalProcessingForHandle(GetStdHandle(STD_OUTPUT_HANDLE));
+        enableVirtualTerminalProcessingForHandle(GetStdHandle(STD_ERROR_HANDLE));
+    }
     // The std{in,out,err} handles are read-only, so we need to pass in dummies.
     FILE *in = nullptr;
     FILE *out = nullptr;
@@ -831,6 +866,10 @@ void Q_TRACE_INSTRUMENT(qtcore) QCoreApplicationPrivate::init()
     Q_ASSERT_X(!QCoreApplication::self, "QCoreApplication", "there should be only one application object");
     QCoreApplication::self = q;
 
+#ifndef QT_BOOTSTRAPPED
+    qputenv(kWwx190EnvVar, QByteArray::number(__wangwenx190__()));
+#endif
+
 #if QT_CONFIG(thread)
 #ifdef Q_OS_WASM
     emscripten::val hardwareConcurrency = emscripten::val::global("navigator")["hardwareConcurrency"];
diff --git a/src/corelib/kernel/qeventdispatcher_win.cpp b/src/corelib/kernel/qeventdispatcher_win.cpp
index 1c54c97514..0da2185811 100644
--- a/src/corelib/kernel/qeventdispatcher_win.cpp
+++ b/src/corelib/kernel/qeventdispatcher_win.cpp
@@ -6,7 +6,6 @@
 
 #include "qcoreapplication.h"
 #include <private/qsystemlibrary_p.h>
-#include "qoperatingsystemversion.h"
 #include "qpair.h"
 #include "qset.h"
 #include "qsocketnotifier.h"
@@ -18,6 +17,8 @@
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 #ifndef TIME_KILL_SYNCHRONOUS
 #  define TIME_KILL_SYNCHRONOUS 0x0100
 #endif
@@ -355,8 +356,13 @@ void QEventDispatcherWin32Private::registerTimer(WinTimerInfo *t)
     }
 
     if (!ok) {
-        // user normal timers for (Very)CoarseTimers, or if no more multimedia timers available
-        ok = SetCoalescableTimer(internalHwnd, t->timerId, interval, nullptr, tolerance);
+        static const auto pSetCoalescableTimer =
+            reinterpret_cast<decltype(&::SetCoalescableTimer)>(
+                QSystemLibrary::resolve(u"user32"_s, "SetCoalescableTimer"));
+        if (pSetCoalescableTimer) {
+            // user normal timers for (Very)CoarseTimers, or if no more multimedia timers available
+            ok = pSetCoalescableTimer(internalHwnd, t->timerId, interval, nullptr, tolerance);
+        }
     }
     if (!ok)
         ok = SetTimer(internalHwnd, t->timerId, interval, nullptr);
diff --git a/src/corelib/kernel/qfunctions_win.cpp b/src/corelib/kernel/qfunctions_win.cpp
index d5ce3e5894..fa77a6882f 100644
--- a/src/corelib/kernel/qfunctions_win.cpp
+++ b/src/corelib/kernel/qfunctions_win.cpp
@@ -4,6 +4,7 @@
 #include "qfunctions_win_p.h"
 
 #include <QtCore/qdebug.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 
 #include <combaseapi.h>
 #include <objbase.h>
@@ -15,6 +16,8 @@
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 QComHelper::QComHelper(COINIT concurrencyModel)
 {
     // Avoid overhead of initializing and using obsolete technology
@@ -45,8 +48,13 @@ bool qt_win_hasPackageIdentity()
 {
 #if defined(HAS_APPMODEL)
     static const bool hasPackageIdentity = []() {
+        static const auto pGetCurrentPackageFullName =
+            reinterpret_cast<decltype(&::GetCurrentPackageFullName)>(
+                QSystemLibrary::resolve(u"kernel32"_s, "GetCurrentPackageFullName"));
+        if (!pGetCurrentPackageFullName)
+            return false;
         UINT32 length = 0;
-        switch (const auto result = GetCurrentPackageFullName(&length, nullptr)) {
+        switch (const auto result = pGetCurrentPackageFullName(&length, nullptr)) {
         case ERROR_INSUFFICIENT_BUFFER:
             return true;
         case APPMODEL_ERROR_NO_PACKAGE:
diff --git a/src/corelib/mimetypes/qmimeprovider.cpp b/src/corelib/mimetypes/qmimeprovider.cpp
index 8a88a2674f..0c13e0ea74 100644
--- a/src/corelib/mimetypes/qmimeprovider.cpp
+++ b/src/corelib/mimetypes/qmimeprovider.cpp
@@ -32,7 +32,7 @@ __attribute__((section(".qtmimedatabase"), aligned(4096)))
 #  include "qmimeprovider_database.cpp"
 
 #  ifdef MIME_DATABASE_IS_ZSTD
-#    if !QT_CONFIG(zstd)
+#    ifdef QT_NO_COMPRESS
 #      error "MIME database is zstd but no support compiled in!"
 #    endif
 #    include <zstd.h>
diff --git a/src/corelib/plugin/qsystemlibrary.cpp b/src/corelib/plugin/qsystemlibrary.cpp
index d3dff226d9..bb38a7dec5 100644
--- a/src/corelib/plugin/qsystemlibrary.cpp
+++ b/src/corelib/plugin/qsystemlibrary.cpp
@@ -42,9 +42,9 @@ using namespace Qt::StringLiterals;
 extern QString qAppFileName();
 #endif
 
-static QString qSystemDirectory()
+[[nodiscard]] static inline QString qSystemDirectory()
 {
-    static const QString result = []() -> QString {
+    static const auto result = []() -> QString {
         QVarLengthArray<wchar_t, MAX_PATH> fullPath = {};
         UINT retLen = ::GetSystemDirectoryW(fullPath.data(), MAX_PATH);
         if (retLen > MAX_PATH) {
@@ -52,15 +52,23 @@ static QString qSystemDirectory()
             retLen = ::GetSystemDirectoryW(fullPath.data(), retLen);
         }
         // in some rare cases retLen might be 0
-        return QString::fromWCharArray(fullPath.constData(), int(retLen));
+        QString path = QString::fromWCharArray(fullPath.constData(), int(retLen));
+        // Remove any trailing line separators.
+        while (path.endsWith(u'\\') || path.endsWith(u'/'))
+            path.chop(1);
+        return path;
     }();
     return result;
 }
 
 HINSTANCE QSystemLibrary::load(const wchar_t *libraryName, bool onlySystemDirectory /* = true */)
 {
-    if (onlySystemDirectory)
-        return ::LoadLibraryExW(libraryName, nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+    const QString fileName = QString::fromWCharArray(libraryName);
+
+    if (onlySystemDirectory) {
+        const QString path = qSystemDirectory() + u'\\' + fileName;
+        return ::LoadLibraryW(reinterpret_cast<const wchar_t *>(path.utf16()));
+    }
 
     QStringList searchOrder;
 
@@ -72,17 +80,11 @@ HINSTANCE QSystemLibrary::load(const wchar_t *libraryName, bool onlySystemDirect
     const QString PATH(QLatin1StringView(qgetenv("PATH")));
     searchOrder << PATH.split(u';', Qt::SkipEmptyParts);
 
-    const QString fileName = QString::fromWCharArray(libraryName);
-
     // Start looking in the order specified
-    for (int i = 0; i < searchOrder.count(); ++i) {
+    for (int i = 0; i != searchOrder.count(); ++i) {
         QString fullPathAttempt = searchOrder.at(i);
-        if (!fullPathAttempt.endsWith(u'\\')) {
-            fullPathAttempt.append(u'\\');
-        }
-        fullPathAttempt.append(fileName);
-        HINSTANCE inst = ::LoadLibrary(reinterpret_cast<const wchar_t *>(fullPathAttempt.utf16()));
-        if (inst != nullptr)
+        fullPathAttempt += u'\\' + fileName;
+        if (const HINSTANCE inst = ::LoadLibraryW(reinterpret_cast<const wchar_t *>(fullPathAttempt.utf16())))
             return inst;
     }
     return nullptr;
diff --git a/src/corelib/text/qlocale_win.cpp b/src/corelib/text/qlocale_win.cpp
index 43324fbfb6..0162e74ab2 100644
--- a/src/corelib/text/qlocale_win.cpp
+++ b/src/corelib/text/qlocale_win.cpp
@@ -15,6 +15,7 @@
 #include <q20algorithm.h>
 
 #ifdef Q_OS_WIN
+#   include <qoperatingsystemversion.h>
 #   include <qt_windows.h>
 #   include <time.h>
 #endif
@@ -659,17 +660,19 @@ QVariant QSystemLocalePrivate::uiLanguages()
 {
     QStringList result;
 #if QT_CONFIG(cpp_winrt)
-    using namespace winrt;
-    using namespace Windows::System::UserProfile;
-    QT_TRY {
-        auto languages = GlobalizationPreferences::Languages();
-        for (const auto &lang : languages)
-            result << QString::fromStdString(winrt::to_string(lang));
-    } QT_CATCH(...) {
-        // pass, just fall back to WIN32 API implementation
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        using namespace winrt;
+        using namespace Windows::System::UserProfile;
+        QT_TRY {
+            const auto languages = GlobalizationPreferences::Languages();
+            for (auto &&lang : languages)
+                result << QString::fromStdString(winrt::to_string(lang));
+        } QT_CATCH(...) {
+            // pass, just fall back to WIN32 API implementation
+        }
+        if (!result.isEmpty())
+            return result; // else just fall back to WIN32 API implementation
     }
-    if (!result.isEmpty())
-        return result; // else just fall back to WIN32 API implementation
 #endif // QT_CONFIG(cpp_winrt)
     // mingw and clang still have to use Win32 API
     unsigned long cnt = 0;
diff --git a/src/corelib/thread/qfutex_p.h b/src/corelib/thread/qfutex_p.h
index 48f03f5ed0..fe799c68ca 100644
--- a/src/corelib/thread/qfutex_p.h
+++ b/src/corelib/thread/qfutex_p.h
@@ -17,9 +17,12 @@
 
 #include <private/qglobal_p.h>
 #include <QtCore/qtsan_impl.h>
+#include <QtCore/qstring.h>
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 namespace QtDummyFutex {
     constexpr inline bool futexAvailable() { return false; }
     template <typename Atomic>
@@ -109,35 +112,86 @@ namespace QtFutex = QtLinuxFutex;
 QT_END_NAMESPACE
 
 #elif defined(Q_OS_WIN)
-#  include <qt_windows.h>
+#  include <QtCore/qoperatingsystemversion.h>
+#  include <QtCore/private/qsystemlibrary_p.h>
+#  include <QtCore/qt_windows.h>
 
 QT_BEGIN_NAMESPACE
-namespace QtWindowsFutex {
-#define QT_ALWAYS_USE_FUTEX
-constexpr inline bool futexAvailable() { return true; }
+namespace QtWindowsFutex
+{
+#ifdef QT_ALWAYS_USE_FUTEX
+#  undef QT_ALWAYS_USE_FUTEX
+#endif
+
+inline bool futexAvailable()
+{
+    return QOperatingSystemVersion::isWin8OrGreater();
+}
+
+struct QFutexApi
+{
+    decltype(&::WaitOnAddress) pWaitOnAddress = nullptr;
+    decltype(&::WakeByAddressAll) pWakeByAddressAll = nullptr;
+    decltype(&::WakeByAddressSingle) pWakeByAddressSingle = nullptr;
+
+    static QFutexApi *instance()
+    {
+        static QFutexApi api;
+        return &api;
+    }
+
+private:
+    Q_DISABLE_COPY_MOVE(QFutexApi)
+
+    explicit QFutexApi()
+    {
+        if (!futexAvailable())
+            return;
+        QSystemLibrary library(u"kernelbase"_s);
+        pWaitOnAddress = reinterpret_cast<decltype(pWaitOnAddress)>(library.resolve("WaitOnAddress"));
+        pWakeByAddressAll = reinterpret_cast<decltype(pWakeByAddressAll)>(library.resolve("WakeByAddressAll"));
+        pWakeByAddressSingle = reinterpret_cast<decltype(pWakeByAddressSingle)>(library.resolve("WakeByAddressSingle"));
+    }
+
+    ~QFutexApi() = default;
+};
 
 template <typename Atomic>
 inline void futexWait(Atomic &futex, typename Atomic::Type expectedValue)
 {
+    if (!QFutexApi::instance()->pWaitOnAddress)
+        return;
     QtTsan::futexRelease(&futex);
-    WaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), INFINITE);
+    QFutexApi::instance()->pWaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), INFINITE);
     QtTsan::futexAcquire(&futex);
 }
+
 template <typename Atomic>
 inline bool futexWait(Atomic &futex, typename Atomic::Type expectedValue, qint64 nstimeout)
 {
-    BOOL r = WaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), DWORD(nstimeout / 1000 / 1000));
+    if (!QFutexApi::instance()->pWaitOnAddress)
+        return false;
+    const BOOL r = QFutexApi::instance()->pWaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), DWORD(nstimeout / 1000 / 1000));
     return r || GetLastError() != ERROR_TIMEOUT;
 }
-template <typename Atomic> inline void futexWakeAll(Atomic &futex)
+
+template <typename Atomic>
+inline void futexWakeAll(Atomic &futex)
 {
-    WakeByAddressAll(&futex);
+    if (!QFutexApi::instance()->pWakeByAddressAll)
+        return;
+    QFutexApi::instance()->pWakeByAddressAll(&futex);
 }
-template <typename Atomic> inline void futexWakeOne(Atomic &futex)
+
+template <typename Atomic>
+inline void futexWakeOne(Atomic &futex)
 {
-    WakeByAddressSingle(&futex);
-}
+    if (!QFutexApi::instance()->pWakeByAddressSingle)
+        return;
+    QFutexApi::instance()->pWakeByAddressSingle(&futex);
 }
+} // namespace QtWindowsFutex
+
 namespace QtFutex = QtWindowsFutex;
 QT_END_NAMESPACE
 #else
diff --git a/src/corelib/thread/qlocking_p.h b/src/corelib/thread/qlocking_p.h
index 9fa7e70da9..0c205fff66 100644
--- a/src/corelib/thread/qlocking_p.h
+++ b/src/corelib/thread/qlocking_p.h
@@ -8,9 +8,10 @@
 //  W A R N I N G
 //  -------------
 //
-// This file is not part of the Qt API. It exists for the convenience of
-// qmutex.cpp and qmutex_unix.cpp. This header file may change from version to
-// version without notice, or even be removed.
+// This file is not part of the Qt API.  It exists for the convenience
+// of qmutex.cpp, qmutex_unix.cpp, and qmutex_win.cpp.  This header
+// file may change from version to version without notice, or even be
+// removed.
 //
 // We mean it.
 //
diff --git a/src/corelib/thread/qmutex.cpp b/src/corelib/thread/qmutex.cpp
index 7b4aac9532..ae1a3a7313 100644
--- a/src/corelib/thread/qmutex.cpp
+++ b/src/corelib/thread/qmutex.cpp
@@ -869,6 +869,8 @@ QT_END_NAMESPACE
 // nothing
 #elif defined(Q_OS_MAC)
 #  include "qmutex_mac.cpp"
+#elif defined(Q_OS_WIN)
+#  include "qmutex_win.cpp"
 #else
 #  include "qmutex_unix.cpp"
 #endif
diff --git a/src/corelib/thread/qmutex_p.h b/src/corelib/thread/qmutex_p.h
index 565de31ca0..7c9977599f 100644
--- a/src/corelib/thread/qmutex_p.h
+++ b/src/corelib/thread/qmutex_p.h
@@ -10,9 +10,10 @@
 //  W A R N I N G
 //  -------------
 //
-// This file is not part of the Qt API. It exists for the convenience of
-// qmutex.cpp and qmutex_unix.cpp. This header file may change from version to
-// version without notice, or even be removed.
+// This file is not part of the Qt API.  It exists for the convenience
+// of qmutex.cpp, qmutex_unix.cpp, and qmutex_win.cpp.  This header
+// file may change from version to version without notice, or even be
+// removed.
 //
 // We mean it.
 //
@@ -91,6 +92,8 @@ public:
     bool wakeup;
     pthread_mutex_t mutex;
     pthread_cond_t cond;
+#elif defined(Q_OS_WIN)
+    Qt::HANDLE event;
 #endif
 };
 
diff --git a/src/corelib/thread/qmutex_win.cpp b/src/corelib/thread/qmutex_win.cpp
new file mode 100644
index 0000000000..8c7741c113
--- /dev/null
+++ b/src/corelib/thread/qmutex_win.cpp
@@ -0,0 +1,30 @@
+// Copyright (C) 2016 The Qt Company Ltd.
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
+
+#include "qmutex.h"
+#include <qatomic.h>
+#include "qmutex_p.h"
+#include <qt_windows.h>
+
+QT_BEGIN_NAMESPACE
+
+QMutexPrivate::QMutexPrivate()
+{
+    event = CreateEvent(0, FALSE, FALSE, 0);
+
+    if (!event)
+        qWarning("QMutexPrivate::QMutexPrivate: Cannot create event");
+}
+
+QMutexPrivate::~QMutexPrivate()
+{ CloseHandle(event); }
+
+bool QMutexPrivate::wait(int timeout)
+{
+    return (WaitForSingleObjectEx(event, timeout < 0 ? INFINITE : timeout, FALSE) == WAIT_OBJECT_0);
+}
+
+void QMutexPrivate::wakeUp() noexcept
+{ SetEvent(event); }
+
+QT_END_NAMESPACE
diff --git a/src/corelib/thread/qwaitcondition_p.h b/src/corelib/thread/qwaitcondition_p.h
index cfb36ca30b..01bb000366 100644
--- a/src/corelib/thread/qwaitcondition_p.h
+++ b/src/corelib/thread/qwaitcondition_p.h
@@ -7,9 +7,10 @@
 //  W A R N I N G
 //  -------------
 //
-// This file is not part of the Qt API. It exists for the convenience of
-// qmutex.cpp and qmutex_unix.cpp. This header file may change from version to
-// version without notice, or even be removed.
+// This file is not part of the Qt API.  It exists for the convenience
+// of qmutex.cpp, qmutex_unix.cpp, and qmutex_win.cpp.  This header
+// file may change from version to version without notice, or even be
+// removed.
 //
 // We mean it.
 //
diff --git a/src/gui/CMakeLists.txt b/src/gui/CMakeLists.txt
index 0e04b722b4..e4ed330703 100644
--- a/src/gui/CMakeLists.txt
+++ b/src/gui/CMakeLists.txt
@@ -5,6 +5,8 @@ qt_find_package(X11_XCB)
 qt_find_package(WrapHarfbuzz PROVIDED_TARGETS WrapHarfbuzz::WrapHarfbuzz)
 qt_find_package(WrapPNG PROVIDED_TARGETS WrapPNG::WrapPNG)
 qt_find_package(WrapFreetype PROVIDED_TARGETS WrapFreetype::WrapFreetype)
+qt_find_package(WrapZLIB PROVIDED_TARGETS WrapZLIB::WrapZLIB)
+qt_find_package(WrapZSTD PROVIDED_TARGETS WrapZSTD::WrapZSTD)
 
 if (QT_FEATURE_gui)
     if(WIN32)
@@ -271,6 +273,8 @@ qt_internal_add_module(Gui
         ../3rdparty/VulkanMemoryAllocator
     LIBRARIES
         Qt::CorePrivate
+        WrapZLIB::WrapZLIB
+        WrapZSTD::WrapZSTD
     PUBLIC_LIBRARIES
         Qt::Core
     PRIVATE_MODULE_INTERFACE
@@ -416,11 +420,6 @@ qt_internal_extend_target(Gui CONDITION WIN32
         ole32
         shell32
         user32
-    PUBLIC_LIBRARIES
-        d3d11
-        dxgi
-        dxguid
-        dcomp
 )
 
 if(QT_FEATURE_egl)
@@ -469,6 +468,11 @@ qt_internal_extend_target(Gui CONDITION QT_FEATURE_accessibility AND WIN32
         accessible/windows/apisupport/uiatypes_p.h
 )
 
+qt_internal_extend_target(Gui CONDITION QT_FEATURE_accessibility AND WIN32 AND NOT MINGW
+    LIBRARIES
+        uiautomationcore
+)
+
 if(QT_FEATURE_accessibility AND QT_FEATURE_accessibility_atspi_bridge)
     set(atspi_accessibility ON)
 else()
@@ -714,20 +718,11 @@ qt_internal_extend_target(Gui CONDITION QT_FEATURE_freetype AND WIN32
 qt_internal_extend_target(Gui CONDITION QT_FEATURE_direct2d AND QT_FEATURE_directwrite AND WIN32
     SOURCES
         text/windows/qwindowsfontenginedirectwrite.cpp text/windows/qwindowsfontenginedirectwrite_p.h
-    LIBRARIES
-        d2d1
 )
 
 qt_internal_extend_target(Gui CONDITION QT_FEATURE_direct2d AND QT_FEATURE_directwrite AND QT_FEATURE_directwrite3 AND WIN32
     SOURCES
         text/windows/qwindowsdirectwritefontdatabase.cpp text/windows/qwindowsdirectwritefontdatabase_p.h
-    LIBRARIES
-        dwrite
-)
-
-qt_internal_extend_target(Gui CONDITION QT_FEATURE_direct2d AND QT_FEATURE_directwrite AND WIN32 AND NOT QT_FEATURE_directwrite3
-    LIBRARIES
-        dwrite
 )
 
 qt_internal_extend_target(Gui CONDITION MINGW AND WIN32
@@ -756,19 +751,14 @@ qt_internal_extend_target(Gui CONDITION ANDROID AND TEST_architecture_arch STREQ
         QT_COMPILER_SUPPORTS_SSE4_2
 )
 
-qt_internal_extend_target(Gui CONDITION QT_FEATURE_system_zlib
-    LIBRARIES
-        WrapZLIB::WrapZLIB
-)
-
 qt_internal_extend_target(Gui CONDITION NOT QT_FEATURE_system_zlib
-    INCLUDE_DIRECTORIES
-        ../3rdparty/zlib/src
+    LIBRARIES
+        Qt::ZlibPrivate
 )
 
-qt_internal_extend_target(Gui CONDITION NOT QT_FEATURE_system_zlib AND NOT no_core_dep
+qt_internal_extend_target(Gui CONDITION NOT QT_FEATURE_system_zstd
     LIBRARIES
-        Qt::Core
+        Qt::ZstdPrivate
 )
 
 qt_internal_extend_target(Gui CONDITION QT_FEATURE_undocommand
diff --git a/src/gui/accessible/windows/apisupport/qwindowsuiawrapper.cpp b/src/gui/accessible/windows/apisupport/qwindowsuiawrapper.cpp
index d9ff723a61..cc3e6c90e4 100644
--- a/src/gui/accessible/windows/apisupport/qwindowsuiawrapper.cpp
+++ b/src/gui/accessible/windows/apisupport/qwindowsuiawrapper.cpp
@@ -8,39 +8,41 @@
 
 QT_BEGIN_NAMESPACE
 
-// private constructor
-QWindowsUiaWrapper::QWindowsUiaWrapper()
-{
-    QSystemLibrary uiaLib(QStringLiteral("UIAutomationCore"));
-    if (uiaLib.load()) {
-        m_pUiaReturnRawElementProvider = reinterpret_cast<PtrUiaReturnRawElementProvider>(uiaLib.resolve("UiaReturnRawElementProvider"));
-        m_pUiaHostProviderFromHwnd = reinterpret_cast<PtrUiaHostProviderFromHwnd>(uiaLib.resolve("UiaHostProviderFromHwnd"));
-        m_pUiaRaiseAutomationPropertyChangedEvent = reinterpret_cast<PtrUiaRaiseAutomationPropertyChangedEvent>(uiaLib.resolve("UiaRaiseAutomationPropertyChangedEvent"));
-        m_pUiaRaiseAutomationEvent = reinterpret_cast<PtrUiaRaiseAutomationEvent>(uiaLib.resolve("UiaRaiseAutomationEvent"));
-        m_pUiaRaiseNotificationEvent = reinterpret_cast<PtrUiaRaiseNotificationEvent>(uiaLib.resolve("UiaRaiseNotificationEvent"));
-        m_pUiaClientsAreListening = reinterpret_cast<PtrUiaClientsAreListening>(uiaLib.resolve("UiaClientsAreListening"));
-    }
-}
+using namespace Qt::StringLiterals;
 
-QWindowsUiaWrapper::~QWindowsUiaWrapper()
-{
-}
+QWindowsUiaWrapper::~QWindowsUiaWrapper() = default;
 
-// shared instance
 QWindowsUiaWrapper *QWindowsUiaWrapper::instance()
 {
     static QWindowsUiaWrapper wrapper;
     return &wrapper;
 }
 
-// True if most symbols resolved (UiaRaiseNotificationEvent is optional).
 BOOL QWindowsUiaWrapper::ready()
 {
-    return m_pUiaReturnRawElementProvider
-        && m_pUiaHostProviderFromHwnd
-        && m_pUiaRaiseAutomationPropertyChangedEvent
-        && m_pUiaRaiseAutomationEvent
-        && m_pUiaClientsAreListening;
+    // The UIA interfaces were introduced in Windows XP, so we
+    // assume it's always available.
+    return TRUE;
+}
+
+HRESULT QWindowsUiaWrapper::raiseNotificationEvent(IRawElementProviderSimple *provider, NotificationKind notificationKind, NotificationProcessing notificationProcessing, BSTR displayString, BSTR activityId)
+{
+    using PtrUiaRaiseNotificationEvent = decltype(&::UiaRaiseNotificationEvent);
+    static const auto pUiaRaiseNotificationEvent = reinterpret_cast<PtrUiaRaiseNotificationEvent>(QSystemLibrary::resolve("UIAutomationCore"_L1, "UiaRaiseNotificationEvent"));
+    if (!pUiaRaiseNotificationEvent)
+        return UIA_E_NOTSUPPORTED;
+    return pUiaRaiseNotificationEvent(provider, notificationKind, notificationProcessing, displayString, activityId);
+}
+
+#ifdef Q_CC_MINGW
+QWindowsUiaWrapper::QWindowsUiaWrapper()
+{
+    QSystemLibrary uiaLib(u"UIAutomationCore"_s);
+    m_pUiaReturnRawElementProvider = reinterpret_cast<decltype(m_pUiaReturnRawElementProvider)>(uiaLib.resolve("UiaReturnRawElementProvider"));
+    m_pUiaHostProviderFromHwnd = reinterpret_cast<decltype(m_pUiaHostProviderFromHwnd)>(uiaLib.resolve("UiaHostProviderFromHwnd"));
+    m_pUiaRaiseAutomationPropertyChangedEvent = reinterpret_cast<decltype(m_pUiaRaiseAutomationPropertyChangedEvent)>(uiaLib.resolve("UiaRaiseAutomationPropertyChangedEvent"));
+    m_pUiaRaiseAutomationEvent = reinterpret_cast<decltype(m_pUiaRaiseAutomationEvent)>(uiaLib.resolve("UiaRaiseAutomationEvent"));
+    m_pUiaClientsAreListening = reinterpret_cast<decltype(m_pUiaClientsAreListening)>(uiaLib.resolve("UiaClientsAreListening"));
 }
 
 BOOL QWindowsUiaWrapper::clientsAreListening()
@@ -77,13 +79,33 @@ HRESULT QWindowsUiaWrapper::raiseAutomationEvent(IRawElementProviderSimple *pPro
         return UIA_E_NOTSUPPORTED;
     return m_pUiaRaiseAutomationEvent(pProvider, id);
 }
+#else
+QWindowsUiaWrapper::QWindowsUiaWrapper() = default;
 
-HRESULT QWindowsUiaWrapper::raiseNotificationEvent(IRawElementProviderSimple *provider, NotificationKind notificationKind, NotificationProcessing notificationProcessing, BSTR displayString, BSTR activityId)
+BOOL QWindowsUiaWrapper::clientsAreListening()
 {
-    if (!m_pUiaRaiseNotificationEvent)
-        return UIA_E_NOTSUPPORTED;
-    return m_pUiaRaiseNotificationEvent(provider, notificationKind, notificationProcessing, displayString, activityId);
+    return UiaClientsAreListening();
 }
 
-QT_END_NAMESPACE
+LRESULT QWindowsUiaWrapper::returnRawElementProvider(HWND hwnd, WPARAM wParam, LPARAM lParam, IRawElementProviderSimple *el)
+{
+    return UiaReturnRawElementProvider(hwnd, wParam, lParam, el);
+}
 
+HRESULT QWindowsUiaWrapper::hostProviderFromHwnd(HWND hwnd, IRawElementProviderSimple **ppProvider)
+{
+    return UiaHostProviderFromHwnd(hwnd, ppProvider);
+}
+
+HRESULT QWindowsUiaWrapper::raiseAutomationPropertyChangedEvent(IRawElementProviderSimple *pProvider, PROPERTYID id, VARIANT oldValue, VARIANT newValue)
+{
+    return UiaRaiseAutomationPropertyChangedEvent(pProvider, id, oldValue, newValue);
+}
+
+HRESULT QWindowsUiaWrapper::raiseAutomationEvent(IRawElementProviderSimple *pProvider, EVENTID id)
+{
+    return UiaRaiseAutomationEvent(pProvider, id);
+}
+#endif
+
+QT_END_NAMESPACE
diff --git a/src/gui/accessible/windows/apisupport/qwindowsuiawrapper_p.h b/src/gui/accessible/windows/apisupport/qwindowsuiawrapper_p.h
index 05b93f8393..14da14f088 100644
--- a/src/gui/accessible/windows/apisupport/qwindowsuiawrapper_p.h
+++ b/src/gui/accessible/windows/apisupport/qwindowsuiawrapper_p.h
@@ -28,6 +28,13 @@
 #include "uiaserverinterfaces_p.h"
 #include "uiaclientinterfaces_p.h"
 
+EXTERN_C LRESULT WINAPI UiaReturnRawElementProvider(HWND, WPARAM, LPARAM, IRawElementProviderSimple *);
+EXTERN_C HRESULT WINAPI UiaHostProviderFromHwnd(HWND, IRawElementProviderSimple **);
+EXTERN_C HRESULT WINAPI UiaRaiseAutomationPropertyChangedEvent(IRawElementProviderSimple *, PROPERTYID, VARIANT, VARIANT);
+EXTERN_C HRESULT WINAPI UiaRaiseAutomationEvent(IRawElementProviderSimple *, EVENTID);
+EXTERN_C HRESULT WINAPI UiaRaiseNotificationEvent(IRawElementProviderSimple *, NotificationKind, NotificationProcessing, BSTR, BSTR);
+EXTERN_C BOOL    WINAPI UiaClientsAreListening();
+
 QT_REQUIRE_CONFIG(accessibility);
 
 QT_BEGIN_NAMESPACE
@@ -47,18 +54,13 @@ public:
     HRESULT raiseNotificationEvent(IRawElementProviderSimple *provider, NotificationKind notificationKind, NotificationProcessing notificationProcessing, BSTR displayString, BSTR activityId);
 
 private:
-    typedef LRESULT (WINAPI *PtrUiaReturnRawElementProvider)(HWND, WPARAM, LPARAM, IRawElementProviderSimple *);
-    typedef HRESULT (WINAPI *PtrUiaHostProviderFromHwnd)(HWND, IRawElementProviderSimple **);
-    typedef HRESULT (WINAPI *PtrUiaRaiseAutomationPropertyChangedEvent)(IRawElementProviderSimple *, PROPERTYID, VARIANT, VARIANT);
-    typedef HRESULT (WINAPI *PtrUiaRaiseAutomationEvent)(IRawElementProviderSimple *, EVENTID);
-    typedef HRESULT (WINAPI *PtrUiaRaiseNotificationEvent)(IRawElementProviderSimple *, NotificationKind, NotificationProcessing, BSTR, BSTR);
-    typedef BOOL (WINAPI *PtrUiaClientsAreListening)();
-    PtrUiaReturnRawElementProvider             m_pUiaReturnRawElementProvider = nullptr;
-    PtrUiaHostProviderFromHwnd                 m_pUiaHostProviderFromHwnd = nullptr;
-    PtrUiaRaiseAutomationPropertyChangedEvent  m_pUiaRaiseAutomationPropertyChangedEvent = nullptr;
-    PtrUiaRaiseAutomationEvent                 m_pUiaRaiseAutomationEvent = nullptr;
-    PtrUiaRaiseNotificationEvent               m_pUiaRaiseNotificationEvent = nullptr;
-    PtrUiaClientsAreListening                  m_pUiaClientsAreListening = nullptr;
+#ifdef Q_CC_MINGW
+    decltype(&::UiaReturnRawElementProvider)             m_pUiaReturnRawElementProvider = nullptr;
+    decltype(&::UiaHostProviderFromHwnd)                 m_pUiaHostProviderFromHwnd = nullptr;
+    decltype(&::UiaRaiseAutomationPropertyChangedEvent)  m_pUiaRaiseAutomationPropertyChangedEvent = nullptr;
+    decltype(&::UiaRaiseAutomationEvent)                 m_pUiaRaiseAutomationEvent = nullptr;
+    decltype(&::UiaClientsAreListening)                  m_pUiaClientsAreListening = nullptr;
+#endif
 };
 
 QT_END_NAMESPACE
diff --git a/src/gui/image/qimage.cpp b/src/gui/image/qimage.cpp
index 71367f6d7b..a69c30468f 100644
--- a/src/gui/image/qimage.cpp
+++ b/src/gui/image/qimage.cpp
@@ -4863,13 +4863,13 @@ QImage Q_TRACE_INSTRUMENT(qtgui) QImage::transformed(const QTransform &matrix, Q
 #endif
             ) {
             if (mat.m11() < 0.0F && mat.m22() < 0.0F) { // horizontal/vertical flip
-                return smoothScaled(wd, hd).mirrored(true, true).convertToFormat(format());
+                return smoothScaled(wd, hd).mirrored(true, true);
             } else if (mat.m11() < 0.0F) { // horizontal flip
-                return smoothScaled(wd, hd).mirrored(true, false).convertToFormat(format());
+                return smoothScaled(wd, hd).mirrored(true, false);
             } else if (mat.m22() < 0.0F) { // vertical flip
-                return smoothScaled(wd, hd).mirrored(false, true).convertToFormat(format());
+                return smoothScaled(wd, hd).mirrored(false, true);
             } else { // no flipping
-                return smoothScaled(wd, hd).convertToFormat(format());
+                return smoothScaled(wd, hd);
             }
         }
     }
diff --git a/src/gui/image/qimagereader.cpp b/src/gui/image/qimagereader.cpp
index b2a95d70e4..ccbc43f4b3 100644
--- a/src/gui/image/qimagereader.cpp
+++ b/src/gui/image/qimagereader.cpp
@@ -1289,6 +1289,7 @@ bool QImageReader::read(QImage *image)
     if (autoTransform())
         qt_imageTransform(*image, transformation());
 
+    image->convertToColorSpace(QColorSpace::SRgb);
     return true;
 }
 
diff --git a/src/gui/kernel/qhighdpiscaling.cpp b/src/gui/kernel/qhighdpiscaling.cpp
index bbd8f8a804..4367ee0333 100644
--- a/src/gui/kernel/qhighdpiscaling.cpp
+++ b/src/gui/kernel/qhighdpiscaling.cpp
@@ -614,13 +614,13 @@ qreal QHighDpiScaling::screenSubfactor(const QPlatformScreen *screen)
         if (auto qScreen = screen->screen()) {
             auto screenFactor = qScreen->property(scaleFactorProperty).toReal(&screenPropertyUsed);
             if (screenPropertyUsed)
-                factor = screenFactor;
+                factor = roundScaleFactor(screenFactor);
         }
 
         if (!screenPropertyUsed) {
             auto byNameIt = QHighDpiScaling::m_namedScreenScaleFactors.constFind(screen->name());
             if ((screenPropertyUsed = byNameIt != QHighDpiScaling::m_namedScreenScaleFactors.cend()))
-                factor = *byNameIt;
+                factor = roundScaleFactor(*byNameIt);
         }
     }
 
diff --git a/src/gui/opengl/qopengl.cpp b/src/gui/opengl/qopengl.cpp
index 587975085a..185bfbd587 100644
--- a/src/gui/opengl/qopengl.cpp
+++ b/src/gui/opengl/qopengl.cpp
@@ -195,13 +195,35 @@ struct OsTypeTerm
     static QString hostOs();
     static QVersionNumber hostKernelVersion() { return QVersionNumber::fromString(QSysInfo::kernelVersion()); }
     static QString hostOsRelease() {
+        QString ver = {};
 #ifdef Q_OS_WIN
-        if (QOperatingSystemVersion::current() >= QOperatingSystemVersion::Windows11)
-            return u"11"_s;
-        return u"10"_s;
-#else
-        return {};
+        const auto osver = QOperatingSystemVersion::current();
+#define Q_WINVER(major, minor) (major << 8 | minor)
+        switch (Q_WINVER(osver.majorVersion(), osver.minorVersion())) {
+        case Q_WINVER(6, 0):
+            ver = QStringLiteral("Vista");
+            break;
+        case Q_WINVER(6, 1):
+            ver = QStringLiteral("7");
+            break;
+        case Q_WINVER(6, 2):
+            ver = QStringLiteral("8");
+            break;
+        case Q_WINVER(6, 3):
+            ver = QStringLiteral("8.1");
+            break;
+        case Q_WINVER(10, 0):
+            if (osver.microVersion() >= 22000)
+                ver = QStringLiteral("11");
+            else
+                ver = QStringLiteral("10");
+            break;
+        default:
+            break;
+        }
+#undef Q_WINVER
 #endif
+        return ver;
     }
 
     bool isNull() const { return type.isEmpty(); }
diff --git a/src/gui/rhi/qrhid3d11.cpp b/src/gui/rhi/qrhid3d11.cpp
index aa2ebc60be..9803268cfc 100644
--- a/src/gui/rhi/qrhid3d11.cpp
+++ b/src/gui/rhi/qrhid3d11.cpp
@@ -9,6 +9,8 @@
 #include <qmath.h>
 #include <private/qsystemlibrary_p.h>
 #include <QtCore/qcryptographichash.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 #include <QtCore/private/qsystemerror_p.h>
 
 #include <d3dcompiler.h>
@@ -96,6 +98,9 @@ using namespace Qt::StringLiterals;
 #define D3D11_VS_INPUT_REGISTER_COUNT 32
 #endif
 
+static constexpr const auto qWKPDID_D3DDebugObjectNameA = GUID{0x429b8c22,0x9188,0x4b0c,{0x87,0x42,0xac,0xb0,0xbf,0x85,0xc2,0x00}};
+static constexpr const auto qWKPDID_D3DDebugObjectNameW = GUID{0x4cca5fd8,0x921f,0x42c8,{0x85,0x66,0x70,0xca,0xf2,0xa9,0xb7,0x41}};
+
 QRhiD3D11::QRhiD3D11(QRhiD3D11InitParams *params, QRhiD3D11NativeHandles *importParams)
     : ofr(this),
       deviceCurse(this)
@@ -109,7 +114,7 @@ QRhiD3D11::QRhiD3D11(QRhiD3D11InitParams *params, QRhiD3D11NativeHandles *import
         if (importParams->dev && importParams->context) {
             dev = reinterpret_cast<ID3D11Device *>(importParams->dev);
             ID3D11DeviceContext *ctx = reinterpret_cast<ID3D11DeviceContext *>(importParams->context);
-            if (SUCCEEDED(ctx->QueryInterface(__uuidof(ID3D11DeviceContext1), reinterpret_cast<void **>(&context)))) {
+            if (SUCCEEDED(ctx->QueryInterface(IID_PPV_ARGS(&context)))) {
                 // get rid of the ref added by QueryInterface
                 ctx->Release();
                 importedDeviceAndContext = true;
@@ -129,112 +134,174 @@ inline Int aligned(Int v, Int byteAlign)
     return (v + byteAlign - 1) & ~(byteAlign - 1);
 }
 
-static IDXGIFactory1 *createDXGIFactory2()
+static bool g_using_dxgi_1_0 = false;
+
+static IDXGIFactory *createDXGIFactory()
+{
+    static const auto pCreateDXGIFactory =
+        reinterpret_cast<decltype(&::CreateDXGIFactory)>(
+            QSystemLibrary::resolve(u"dxgi"_s, "CreateDXGIFactory"));
+    if (!pCreateDXGIFactory)
+        return nullptr;
+    IDXGIFactory *result = nullptr;
+    const HRESULT hr = pCreateDXGIFactory(IID_PPV_ARGS(&result));
+    if (SUCCEEDED(hr))
+        return result;
+    qWarning("CreateDXGIFactory() failed to create DXGI factory: %s",
+        qPrintable(QSystemError::windowsComString(hr)));
+    return nullptr;
+}
+
+static IDXGIFactory1 *createDXGIFactory1()
 {
+    static const auto pCreateDXGIFactory1 =
+        reinterpret_cast<decltype(&::CreateDXGIFactory1)>(
+            QSystemLibrary::resolve(u"dxgi"_s, "CreateDXGIFactory1"));
+    if (!pCreateDXGIFactory1)
+        return nullptr;
     IDXGIFactory1 *result = nullptr;
-    const HRESULT hr = CreateDXGIFactory2(0, __uuidof(IDXGIFactory2), reinterpret_cast<void **>(&result));
-    if (FAILED(hr)) {
-        qWarning("CreateDXGIFactory2() failed to create DXGI factory: %s",
-            qPrintable(QSystemError::windowsComString(hr)));
-        result = nullptr;
-    }
-    return result;
+    const HRESULT hr = pCreateDXGIFactory1(IID_PPV_ARGS(&result));
+    if (SUCCEEDED(hr))
+        return result;
+    qWarning("CreateDXGIFactory1() failed to create DXGI factory: %s",
+        qPrintable(QSystemError::windowsComString(hr)));
+    return nullptr;
 }
 
-bool QRhiD3D11::create(QRhi::Flags flags)
+static IDXGIFactory2 *createDXGIFactory2()
 {
-    rhiFlags = flags;
+    static const auto pCreateDXGIFactory2 =
+        reinterpret_cast<decltype(&::CreateDXGIFactory2)>(
+            QSystemLibrary::resolve(u"dxgi"_s, "CreateDXGIFactory2"));
+    if (!pCreateDXGIFactory2)
+        return nullptr;
+    IDXGIFactory2 *result = nullptr;
+    const HRESULT hr = pCreateDXGIFactory2(0, IID_PPV_ARGS(&result));
+    if (SUCCEEDED(hr))
+        return result;
+    qWarning("CreateDXGIFactory2() failed to create DXGI factory: %s",
+        qPrintable(QSystemError::windowsComString(hr)));
+    return nullptr;
+}
 
-    uint devFlags = 0;
-    if (debugLayer)
-        devFlags |= D3D11_CREATE_DEVICE_DEBUG;
+bool QRhiD3D11::create(QRhi::Flags flags)
+{
+    static const auto pD3D11CreateDevice =
+        reinterpret_cast<decltype(&::D3D11CreateDevice)>(
+            QSystemLibrary::resolve(u"d3d11"_s, "D3D11CreateDevice"));
+    if (!pD3D11CreateDevice) {
+        qWarning() << "D3D11 is not available on this platform.";
+        return false;
+    }
 
     dxgiFactory = createDXGIFactory2();
-    if (!dxgiFactory)
-        return false;
+    if (dxgiFactory) {
+        supportsFlipSwapchain = QOperatingSystemVersion::isWin10OrGreater()
+            && !qEnvironmentVariableIntValue("QT_D3D_NO_FLIP");
+    } else {
+        supportsFlipSwapchain = false;
+        dxgiFactory = createDXGIFactory1();
+        if (!dxgiFactory) {
+            dxgiFactory = createDXGIFactory();
+            if (!dxgiFactory) {
+                qWarning() << "DXGI is not available on this platform.";
+                return false;
+            }
+            g_using_dxgi_1_0 = true;
+        }
+    }
 
-    // For a FLIP_* swapchain Present(0, 0) is not necessarily
-    // sufficient to get non-blocking behavior, try using ALLOW_TEARING
-    // when available.
     supportsAllowTearing = false;
-    IDXGIFactory5 *factory5 = nullptr;
-    if (SUCCEEDED(dxgiFactory->QueryInterface(__uuidof(IDXGIFactory5), reinterpret_cast<void **>(&factory5)))) {
-        BOOL allowTearing = false;
-        if (SUCCEEDED(factory5->CheckFeatureSupport(DXGI_FEATURE_PRESENT_ALLOW_TEARING, &allowTearing, sizeof(allowTearing))))
-            supportsAllowTearing = allowTearing;
-        factory5->Release();
+    if (supportsFlipSwapchain) {
+        // For a FLIP_* swapchain Present(0, 0) is not necessarily
+        // sufficient to get non-blocking behavior, try using ALLOW_TEARING
+        // when available.
+        IDXGIFactory5 *factory5 = nullptr;
+        if (SUCCEEDED(dxgiFactory->QueryInterface(IID_PPV_ARGS(&factory5)))) {
+            BOOL allowTearing = false;
+            if (SUCCEEDED(factory5->CheckFeatureSupport(DXGI_FEATURE_PRESENT_ALLOW_TEARING, &allowTearing, sizeof(allowTearing))))
+                supportsAllowTearing = allowTearing;
+            factory5->Release();
+        }
     }
 
-    if (qEnvironmentVariableIntValue("QT_D3D_FLIP_DISCARD"))
-        qWarning("The default swap effect is FLIP_DISCARD, QT_D3D_FLIP_DISCARD is now ignored");
+    qCDebug(QRHI_LOG_INFO, "FLIP_* swapchain supported = %s, ALLOW_TEARING supported = %s",
+            supportsFlipSwapchain ? "true" : "false",
+            supportsAllowTearing ? "true" : "false");
 
-    if (qEnvironmentVariableIntValue("QT_D3D_NO_FLIP"))
-        qWarning("Non-FLIP swapchains are no longer supported, QT_D3D_NO_FLIP is now ignored");
+    qCDebug(QRHI_LOG_INFO, "Default swap effect: %s",
+            supportsFlipSwapchain ? "FLIP_DISCARD" : "DISCARD");
 
-    qCDebug(QRHI_LOG_INFO, "FLIP_* swapchain supported = true, ALLOW_TEARING supported = %s",
-            supportsAllowTearing ? "true" : "false");
+    rhiFlags = flags;
 
-    qCDebug(QRHI_LOG_INFO, "Default swap effect: FLIP_DISCARD");
+    uint devFlags = 0;
+    if (debugLayer)
+        devFlags |= D3D11_CREATE_DEVICE_DEBUG;
 
     if (!importedDeviceAndContext) {
-        IDXGIAdapter1 *adapter;
-        int requestedAdapterIndex = -1;
-        if (qEnvironmentVariableIsSet("QT_D3D_ADAPTER_INDEX"))
-            requestedAdapterIndex = qEnvironmentVariableIntValue("QT_D3D_ADAPTER_INDEX");
-
-        // The importParams may specify an adapter by the luid, take that into account.
-        if (requestedAdapterIndex < 0 && (adapterLuid.LowPart || adapterLuid.HighPart)) {
-            for (int adapterIndex = 0; dxgiFactory->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
-                DXGI_ADAPTER_DESC1 desc;
-                adapter->GetDesc1(&desc);
-                adapter->Release();
-                if (desc.AdapterLuid.LowPart == adapterLuid.LowPart
-                        && desc.AdapterLuid.HighPart == adapterLuid.HighPart)
-                {
-                    requestedAdapterIndex = adapterIndex;
-                    break;
+        activeAdapter = nullptr;
+
+        if (!g_using_dxgi_1_0) {
+            IDXGIAdapter1 *adapter;
+            int requestedAdapterIndex = -1;
+            if (qEnvironmentVariableIsSet("QT_D3D_ADAPTER_INDEX"))
+                requestedAdapterIndex = qEnvironmentVariableIntValue("QT_D3D_ADAPTER_INDEX");
+
+            const auto dxgiFactory1 = static_cast<IDXGIFactory1 *>(dxgiFactory);
+
+            // The importParams may specify an adapter by the luid, take that into account.
+            if (requestedAdapterIndex < 0 && (adapterLuid.LowPart || adapterLuid.HighPart)) {
+                for (int adapterIndex = 0; dxgiFactory1->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
+                    DXGI_ADAPTER_DESC1 desc;
+                    adapter->GetDesc1(&desc);
+                    adapter->Release();
+                    if (desc.AdapterLuid.LowPart == adapterLuid.LowPart
+                            && desc.AdapterLuid.HighPart == adapterLuid.HighPart)
+                    {
+                        requestedAdapterIndex = adapterIndex;
+                        break;
+                    }
+                }
+            }
+
+            if (requestedAdapterIndex < 0 && rhiFlags.testFlag(QRhi::PreferSoftwareRenderer)) {
+                for (int adapterIndex = 0; dxgiFactory1->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
+                    DXGI_ADAPTER_DESC1 desc;
+                    adapter->GetDesc1(&desc);
+                    adapter->Release();
+                    if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) {
+                        requestedAdapterIndex = adapterIndex;
+                        break;
+                    }
                 }
             }
-        }
 
-        if (requestedAdapterIndex < 0 && flags.testFlag(QRhi::PreferSoftwareRenderer)) {
-            for (int adapterIndex = 0; dxgiFactory->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
+            for (int adapterIndex = 0; dxgiFactory1->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
                 DXGI_ADAPTER_DESC1 desc;
                 adapter->GetDesc1(&desc);
-                adapter->Release();
-                if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) {
-                    requestedAdapterIndex = adapterIndex;
-                    break;
+                const QString name = QString::fromUtf16(reinterpret_cast<char16_t *>(desc.Description));
+                qCDebug(QRHI_LOG_INFO, "Adapter %d: '%s' (vendor 0x%X device 0x%X flags 0x%X)",
+                        adapterIndex,
+                        qPrintable(name),
+                        desc.VendorId,
+                        desc.DeviceId,
+                        desc.Flags);
+                if (!activeAdapter && (requestedAdapterIndex < 0 || requestedAdapterIndex == adapterIndex)) {
+                    activeAdapter = adapter;
+                    adapterLuid = desc.AdapterLuid;
+                    driverInfoStruct.deviceName = name.toUtf8();
+                    driverInfoStruct.deviceId = desc.DeviceId;
+                    driverInfoStruct.vendorId = desc.VendorId;
+                    qCDebug(QRHI_LOG_INFO, "  using this adapter");
+                } else {
+                    adapter->Release();
                 }
             }
-        }
-
-        activeAdapter = nullptr;
-        for (int adapterIndex = 0; dxgiFactory->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
-            DXGI_ADAPTER_DESC1 desc;
-            adapter->GetDesc1(&desc);
-            const QString name = QString::fromUtf16(reinterpret_cast<char16_t *>(desc.Description));
-            qCDebug(QRHI_LOG_INFO, "Adapter %d: '%s' (vendor 0x%X device 0x%X flags 0x%X)",
-                    adapterIndex,
-                    qPrintable(name),
-                    desc.VendorId,
-                    desc.DeviceId,
-                    desc.Flags);
-            if (!activeAdapter && (requestedAdapterIndex < 0 || requestedAdapterIndex == adapterIndex)) {
-                activeAdapter = adapter;
-                adapterLuid = desc.AdapterLuid;
-                driverInfoStruct.deviceName = name.toUtf8();
-                driverInfoStruct.deviceId = desc.DeviceId;
-                driverInfoStruct.vendorId = desc.VendorId;
-                qCDebug(QRHI_LOG_INFO, "  using this adapter");
-            } else {
-                adapter->Release();
+            if (!activeAdapter) {
+                qWarning("No adapter");
+                return false;
             }
         }
-        if (!activeAdapter) {
-            qWarning("No adapter");
-            return false;
-        }
 
         // Normally we won't specify a requested feature level list,
         // except when a level was specified in importParams.
@@ -245,27 +312,55 @@ bool QRhiD3D11::create(QRhi::Flags flags)
             requestedFeatureLevels.append(featureLevel);
         }
 
+        const D3D_DRIVER_TYPE driverType =
+                activeAdapter ? D3D_DRIVER_TYPE_UNKNOWN : D3D_DRIVER_TYPE_HARDWARE;
         ID3D11DeviceContext *ctx = nullptr;
-        HRESULT hr = D3D11CreateDevice(activeAdapter, D3D_DRIVER_TYPE_UNKNOWN, nullptr, devFlags,
-                                       requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
-                                       requestFeatureLevels ? requestedFeatureLevels.count() : 0,
-                                       D3D11_SDK_VERSION,
-                                       &dev, &featureLevel, &ctx);
+        HRESULT hr = pD3D11CreateDevice(activeAdapter, driverType, nullptr, devFlags,
+                                        requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
+                                        requestFeatureLevels ? requestedFeatureLevels.count() : 0,
+                                        D3D11_SDK_VERSION,
+                                        &dev, &featureLevel, &ctx);
         // We cannot assume that D3D11_CREATE_DEVICE_DEBUG is always available. Retry without it, if needed.
         if (hr == DXGI_ERROR_SDK_COMPONENT_MISSING && debugLayer) {
             qCDebug(QRHI_LOG_INFO, "Debug layer was requested but is not available. "
                                    "Attempting to create D3D11 device without it.");
             devFlags &= ~D3D11_CREATE_DEVICE_DEBUG;
-            hr = D3D11CreateDevice(activeAdapter, D3D_DRIVER_TYPE_UNKNOWN, nullptr, devFlags,
-                                   requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
-                                   requestFeatureLevels ? requestedFeatureLevels.count() : 0,
-                                   D3D11_SDK_VERSION,
-                                   &dev, &featureLevel, &ctx);
+            hr = pD3D11CreateDevice(activeAdapter, driverType, nullptr, devFlags,
+                                    requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
+                                    requestFeatureLevels ? requestedFeatureLevels.count() : 0,
+                                    D3D11_SDK_VERSION,
+                                    &dev, &featureLevel, &ctx);
         }
         if (FAILED(hr)) {
-            qWarning("Failed to create D3D11 device and context: %s",
-                qPrintable(QSystemError::windowsComString(hr)));
-            return false;
+            qWarning().noquote() << "Failed to create D3D11 device:"
+                                 << QSystemError::windowsComString(hr)
+                                 << "\nTry again using WARP instead ...";
+            hr = pD3D11CreateDevice(nullptr, D3D_DRIVER_TYPE_WARP, nullptr, devFlags,
+                                    requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
+                                    requestFeatureLevels ? requestedFeatureLevels.count() : 0,
+                                    D3D11_SDK_VERSION,
+                                    &dev, &featureLevel, &ctx);
+            if (FAILED(hr)) {
+                qWarning() << "Failed to create D3D11 device with WARP:"
+                           << QSystemError::windowsComString(hr)
+                           << "\nTry again using Mesa instead ...";
+            }
+            const HMODULE soft = QSystemLibrary::load(L"d3d10sw", false);
+            if (!soft) {
+                qWarning() << "Failed to load d3d10sw.dll. D3D11 is not available.";
+                return false;
+            }
+            hr = pD3D11CreateDevice(nullptr, D3D_DRIVER_TYPE_SOFTWARE, soft, devFlags,
+                                    requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
+                                    requestFeatureLevels ? requestedFeatureLevels.count() : 0,
+                                    D3D11_SDK_VERSION,
+                                    &dev, &featureLevel, &ctx);
+            if (FAILED(hr)) {
+                qWarning().noquote() << "Failed to create D3D11 device with Mesa:"
+                                     << QSystemError::windowsComString(hr)
+                                     << "\nD3D11 is not available.";
+                return false;
+            }
         }
 
         // Test if creating a Shader Model 5.0 vertex shader works; we want to
@@ -279,7 +374,7 @@ bool QRhiD3D11::create(QRhi::Flags flags)
             return false;
         }
 
-        const bool supports11_1 = SUCCEEDED(ctx->QueryInterface(__uuidof(ID3D11DeviceContext1), reinterpret_cast<void **>(&context)));
+        const bool supports11_1 = SUCCEEDED(ctx->QueryInterface(IID_PPV_ARGS(&context)));
         ctx->Release();
         if (!supports11_1) {
             qWarning("ID3D11DeviceContext1 not supported");
@@ -303,7 +398,7 @@ bool QRhiD3D11::create(QRhi::Flags flags)
         Q_ASSERT(dev && context);
         featureLevel = dev->GetFeatureLevel();
         IDXGIDevice *dxgiDev = nullptr;
-        if (SUCCEEDED(dev->QueryInterface(__uuidof(IDXGIDevice), reinterpret_cast<void **>(&dxgiDev)))) {
+        if (SUCCEEDED(dev->QueryInterface(IID_PPV_ARGS(&dxgiDev)))) {
             IDXGIAdapter *adapter = nullptr;
             if (SUCCEEDED(dxgiDev->GetAdapter(&adapter))) {
                 DXGI_ADAPTER_DESC desc;
@@ -319,7 +414,7 @@ bool QRhiD3D11::create(QRhi::Flags flags)
         qCDebug(QRHI_LOG_INFO, "Using imported device %p", dev);
     }
 
-    if (FAILED(context->QueryInterface(__uuidof(ID3DUserDefinedAnnotation), reinterpret_cast<void **>(&annotations))))
+    if (FAILED(context->QueryInterface(IID_PPV_ARGS(&annotations))))
         annotations = nullptr;
 
     deviceLost = false;
@@ -388,7 +483,7 @@ void QRhiD3D11::reportLiveObjects(ID3D11Device *device)
 {
     // this works only when params.enableDebugLayer was true
     ID3D11Debug *debug;
-    if (SUCCEEDED(device->QueryInterface(__uuidof(ID3D11Debug), reinterpret_cast<void **>(&debug)))) {
+    if (SUCCEEDED(device->QueryInterface(IID_PPV_ARGS(&debug)))) {
         debug->ReportLiveDeviceObjects(D3D11_RLDO_DETAIL);
         debug->Release();
     }
@@ -2884,7 +2979,7 @@ bool QD3D11Buffer::create()
     }
 
     if (!m_objectName.isEmpty())
-        buffer->SetPrivateData(WKPDID_D3DDebugObjectName, UINT(m_objectName.size()), m_objectName.constData());
+        buffer->SetPrivateData(qWKPDID_D3DDebugObjectNameA, UINT(m_objectName.size()), m_objectName.constData());
 
     generation += 1;
     rhiD->registerResource(this);
@@ -3053,7 +3148,7 @@ bool QD3D11RenderBuffer::create()
     }
 
     if (!m_objectName.isEmpty())
-        tex->SetPrivateData(WKPDID_D3DDebugObjectName, UINT(m_objectName.size()), m_objectName.constData());
+        tex->SetPrivateData(qWKPDID_D3DDebugObjectNameA, UINT(m_objectName.size()), m_objectName.constData());
 
     generation += 1;
     rhiD->registerResource(this);
@@ -3348,7 +3443,7 @@ bool QD3D11Texture::create()
             return false;
         }
         if (!m_objectName.isEmpty())
-            tex->SetPrivateData(WKPDID_D3DDebugObjectName, UINT(m_objectName.size()),
+            tex->SetPrivateData(qWKPDID_D3DDebugObjectNameA, UINT(m_objectName.size()),
                                 m_objectName.constData());
     } else if (!is3D) {
         D3D11_TEXTURE2D_DESC desc = {};
@@ -3369,7 +3464,7 @@ bool QD3D11Texture::create()
             return false;
         }
         if (!m_objectName.isEmpty())
-            tex->SetPrivateData(WKPDID_D3DDebugObjectName, UINT(m_objectName.size()), m_objectName.constData());
+            tex->SetPrivateData(qWKPDID_D3DDebugObjectNameA, UINT(m_objectName.size()), m_objectName.constData());
     } else {
         D3D11_TEXTURE3D_DESC desc = {};
         desc.Width = UINT(size.width());
@@ -3388,7 +3483,7 @@ bool QD3D11Texture::create()
             return false;
         }
         if (!m_objectName.isEmpty())
-            tex3D->SetPrivateData(WKPDID_D3DDebugObjectName, UINT(m_objectName.size()), m_objectName.constData());
+            tex3D->SetPrivateData(qWKPDID_D3DDebugObjectNameA, UINT(m_objectName.size()), m_objectName.constData());
     }
 
     if (!finishCreate())
@@ -4764,7 +4859,7 @@ static bool output6ForWindow(QWindow *w, IDXGIAdapter1 *adapter, IDXGIOutput6 **
         }
     }
     if (currentOutput) {
-        ok = SUCCEEDED(currentOutput->QueryInterface(__uuidof(IDXGIOutput6), reinterpret_cast<void **>(result)));
+        ok = SUCCEEDED(currentOutput->QueryInterface(IID_PPV_ARGS(result)));
         currentOutput->Release();
     }
     return ok;
@@ -4792,6 +4887,8 @@ bool QD3D11SwapChain::isFormatSupported(Format f)
     }
 
     QRHI_RES_RHI(QRhiD3D11);
+    if (!rhiD->activeAdapter)
+        return false;
     DXGI_OUTPUT_DESC1 desc1;
     if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &desc1)) {
         if (desc1.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020)
@@ -4806,6 +4903,8 @@ QRhiSwapChainHdrInfo QD3D11SwapChain::hdrInfo()
     QRhiSwapChainHdrInfo info = QRhiSwapChain::hdrInfo();
     if (m_format != QRhiSwapChain::SDR && m_window) {
         QRHI_RES_RHI(QRhiD3D11);
+        if (!rhiD->activeAdapter)
+            return info;
         DXGI_OUTPUT_DESC1 hdrOutputDesc;
         if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &hdrOutputDesc)) {
             info.isHardCodedDefaults = false;
@@ -4863,12 +4962,18 @@ static const DXGI_FORMAT DEFAULT_SRGB_FORMAT = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
 
 bool QRhiD3D11::ensureDirectCompositionDevice()
 {
+    static const auto pDCompositionCreateDevice =
+        reinterpret_cast<decltype(&::DCompositionCreateDevice)>(
+            QSystemLibrary::resolve(u"dcomp"_s, "DCompositionCreateDevice"));
+    if (!pDCompositionCreateDevice)
+        return false;
+
     if (dcompDevice)
         return true;
 
     qCDebug(QRHI_LOG_INFO, "Creating Direct Composition device (needed for semi-transparent windows)");
 
-    HRESULT hr = DCompositionCreateDevice(nullptr, __uuidof(IDCompositionDevice), reinterpret_cast<void **>(&dcompDevice));
+    HRESULT hr = pDCompositionCreateDevice(nullptr, IID_PPV_ARGS(&dcompDevice));
     if (FAILED(hr)) {
         qWarning("Failed to Direct Composition device: %s",
             qPrintable(QSystemError::windowsComString(hr)));
@@ -4901,12 +5006,18 @@ bool QD3D11SwapChain::createOrResize()
     HRESULT hr;
 
     QRHI_RES_RHI(QRhiD3D11);
+    bool useFlipModel = rhiD->supportsFlipSwapchain;
 
+    // Take a shortcut for alpha: whatever the platform plugin does to enable
+    // transparency for our QWindow will be sufficient on the legacy (DISCARD)
+    // path. For FLIP_* we'd need to use DirectComposition (create a
+    // IDCompositionDevice/Target/Visual).
     if (m_flags.testFlag(SurfaceHasPreMulAlpha) || m_flags.testFlag(SurfaceHasNonPreMulAlpha)) {
         if (rhiD->ensureDirectCompositionDevice()) {
             if (!dcompTarget) {
                 hr = rhiD->dcompDevice->CreateTargetForHwnd(hwnd, true, &dcompTarget);
                 if (FAILED(hr)) {
+                    useFlipModel = false;
                     qWarning("Failed to create Direct Compsition target for the window: %s",
                              qPrintable(QSystemError::windowsComString(hr)));
                 }
@@ -4914,10 +5025,15 @@ bool QD3D11SwapChain::createOrResize()
             if (dcompTarget && !dcompVisual) {
                 hr = rhiD->dcompDevice->CreateVisual(&dcompVisual);
                 if (FAILED(hr)) {
+                    useFlipModel = false;
                     qWarning("Failed to create DirectComposition visual: %s",
                              qPrintable(QSystemError::windowsComString(hr)));
                 }
             }
+        } else {
+            // Direct Composition is not available, most likely due to we are running
+            // on Windows 7. Fallback to the legacy non-flip model instead.
+            useFlipModel = false;
         }
         // simple consistency check
         if (window->requestedFormat().alphaBufferSize() <= 0)
@@ -4932,7 +5048,7 @@ bool QD3D11SwapChain::createOrResize()
     // ALLOW_TEARING, and ALLOW_TEARING is not compatible with it at all so the
     // flag must not be set then. Whereas for flip we should use it, if
     // supported, to get better results for 'unthrottled' presentation.
-    if (swapInterval == 0 && rhiD->supportsAllowTearing)
+    if (swapInterval == 0 && useFlipModel && rhiD->supportsAllowTearing)
         swapChainFlags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING;
 
     if (!swapChain) {
@@ -4940,121 +5056,145 @@ bool QD3D11SwapChain::createOrResize()
         colorFormat = DEFAULT_FORMAT;
         srgbAdjustedColorFormat = m_flags.testFlag(sRGB) ? DEFAULT_SRGB_FORMAT : DEFAULT_FORMAT;
 
-        DXGI_COLOR_SPACE_TYPE hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709; // SDR
-        DXGI_OUTPUT_DESC1 hdrOutputDesc;
-        if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &hdrOutputDesc) && m_format != SDR) {
-            // https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range
-            if (hdrOutputDesc.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020) {
-                switch (m_format) {
-                case HDRExtendedSrgbLinear:
-                    colorFormat = DXGI_FORMAT_R16G16B16A16_FLOAT;
-                    hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709;
-                    srgbAdjustedColorFormat = colorFormat;
-                    break;
-                case HDR10:
-                    colorFormat = DXGI_FORMAT_R10G10B10A2_UNORM;
-                    hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
-                    srgbAdjustedColorFormat = colorFormat;
-                    break;
-                default:
-                    break;
+        if (useFlipModel) {
+            DXGI_COLOR_SPACE_TYPE hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709; // SDR
+            DXGI_OUTPUT_DESC1 hdrOutputDesc;
+            if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &hdrOutputDesc) && m_format != SDR) {
+                // https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range
+                if (hdrOutputDesc.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020) {
+                    switch (m_format) {
+                    case HDRExtendedSrgbLinear:
+                        colorFormat = DXGI_FORMAT_R16G16B16A16_FLOAT;
+                        hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709;
+                        srgbAdjustedColorFormat = colorFormat;
+                        break;
+                    case HDR10:
+                        colorFormat = DXGI_FORMAT_R10G10B10A2_UNORM;
+                        hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
+                        srgbAdjustedColorFormat = colorFormat;
+                        break;
+                    default:
+                        break;
+                    }
+                } else {
+                    // This happens also when Use HDR is set to Off in the Windows
+                    // Display settings. Show a helpful warning, but continue with the
+                    // default non-HDR format.
+                    qWarning("The output associated with the window is not HDR capable "
+                             "(or Use HDR is Off in the Display Settings), ignoring HDR format request");
                 }
-            } else {
-                // This happens also when Use HDR is set to Off in the Windows
-                // Display settings. Show a helpful warning, but continue with the
-                // default non-HDR format.
-                qWarning("The output associated with the window is not HDR capable "
-                         "(or Use HDR is Off in the Display Settings), ignoring HDR format request");
             }
-        }
 
-        // We use a FLIP model swapchain which implies a buffer count of 2
-        // (as opposed to the old DISCARD with back buffer count == 1).
-        // This makes no difference for the rest of the stuff except that
-        // automatic MSAA is unsupported and needs to be implemented via a
-        // custom multisample render target and an explicit resolve.
-
-        DXGI_SWAP_CHAIN_DESC1 desc = {};
-        desc.Width = UINT(pixelSize.width());
-        desc.Height = UINT(pixelSize.height());
-        desc.Format = colorFormat;
-        desc.SampleDesc.Count = 1;
-        desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
-        desc.BufferCount = BUFFER_COUNT;
-        desc.Flags = swapChainFlags;
-        desc.Scaling = DXGI_SCALING_NONE;
-        desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
-
-        if (dcompVisual) {
-            // With DirectComposition setting AlphaMode to STRAIGHT fails the
-            // swapchain creation, whereas the result seems to be identical
-            // with any of the other values, including IGNORE. (?)
-            desc.AlphaMode = DXGI_ALPHA_MODE_PREMULTIPLIED;
-
-            // DirectComposition has its own limitations, cannot use
-            // SCALING_NONE. So with semi-transparency requested we are forced
-            // to SCALING_STRETCH.
-            desc.Scaling = DXGI_SCALING_STRETCH;
-        }
+            // We use a FLIP model swapchain which implies a buffer count of 2
+            // (as opposed to the old DISCARD with back buffer count == 1).
+            // This makes no difference for the rest of the stuff except that
+            // automatic MSAA is unsupported and needs to be implemented via a
+            // custom multisample render target and an explicit resolve.
 
-        IDXGIFactory2 *fac = static_cast<IDXGIFactory2 *>(rhiD->dxgiFactory);
-        IDXGISwapChain1 *sc1;
+            DXGI_SWAP_CHAIN_DESC1 desc = {};
+            desc.Width = UINT(pixelSize.width());
+            desc.Height = UINT(pixelSize.height());
+            desc.Format = colorFormat;
+            desc.SampleDesc.Count = 1;
+            desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
+            desc.BufferCount = BUFFER_COUNT;
+            desc.Flags = swapChainFlags;
+            desc.Scaling = DXGI_SCALING_NONE;
+            desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
+
+            if (dcompVisual) {
+                // With DirectComposition setting AlphaMode to STRAIGHT fails the
+                // swapchain creation, whereas the result seems to be identical
+                // with any of the other values, including IGNORE. (?)
+                desc.AlphaMode = DXGI_ALPHA_MODE_PREMULTIPLIED;
+
+                // DirectComposition has its own limitations, cannot use
+                // SCALING_NONE. So with semi-transparency requested we are forced
+                // to SCALING_STRETCH.
+                desc.Scaling = DXGI_SCALING_STRETCH;
+            }
+
+            IDXGIFactory2 *fac = static_cast<IDXGIFactory2 *>(rhiD->dxgiFactory);
+            IDXGISwapChain1 *sc1;
 
-        if (dcompVisual)
-            hr = fac->CreateSwapChainForComposition(rhiD->dev, &desc, nullptr, &sc1);
-        else
-            hr = fac->CreateSwapChainForHwnd(rhiD->dev, hwnd, &desc, nullptr, nullptr, &sc1);
-
-        // If failed and we tried a HDR format, then try with SDR. This
-        // matches other backends, such as Vulkan where if the format is
-        // not supported, the default one is used instead.
-        if (FAILED(hr) && m_format != SDR) {
-            colorFormat = DEFAULT_FORMAT;
-            desc.Format = DEFAULT_FORMAT;
             if (dcompVisual)
                 hr = fac->CreateSwapChainForComposition(rhiD->dev, &desc, nullptr, &sc1);
             else
                 hr = fac->CreateSwapChainForHwnd(rhiD->dev, hwnd, &desc, nullptr, nullptr, &sc1);
-        }
 
-        if (SUCCEEDED(hr)) {
-            swapChain = sc1;
-            if (m_format != SDR) {
-                IDXGISwapChain3 *sc3 = nullptr;
-                if (SUCCEEDED(sc1->QueryInterface(__uuidof(IDXGISwapChain3), reinterpret_cast<void **>(&sc3)))) {
-                    hr = sc3->SetColorSpace1(hdrColorSpace);
-                    if (FAILED(hr))
-                        qWarning("Failed to set color space on swapchain: %s",
-                            qPrintable(QSystemError::windowsComString(hr)));
-                    sc3->Release();
-                } else {
-                    qWarning("IDXGISwapChain3 not available, HDR swapchain will not work as expected");
-                }
+            // If failed and we tried a HDR format, then try with SDR. This
+            // matches other backends, such as Vulkan where if the format is
+            // not supported, the default one is used instead.
+            if (FAILED(hr) && m_format != SDR) {
+                colorFormat = DEFAULT_FORMAT;
+                desc.Format = DEFAULT_FORMAT;
+                if (dcompVisual)
+                    hr = fac->CreateSwapChainForComposition(rhiD->dev, &desc, nullptr, &sc1);
+                else
+                    hr = fac->CreateSwapChainForHwnd(rhiD->dev, hwnd, &desc, nullptr, nullptr, &sc1);
             }
-            if (dcompVisual) {
-                hr = dcompVisual->SetContent(sc1);
-                if (SUCCEEDED(hr)) {
-                    hr = dcompTarget->SetRoot(dcompVisual);
-                    if (FAILED(hr)) {
-                        qWarning("Failed to associate Direct Composition visual with the target: %s",
+
+            if (SUCCEEDED(hr)) {
+                swapChain = sc1;
+                if (m_format != SDR) {
+                    IDXGISwapChain3 *sc3 = nullptr;
+                    if (SUCCEEDED(sc1->QueryInterface(IID_PPV_ARGS(&sc3)))) {
+                        hr = sc3->SetColorSpace1(hdrColorSpace);
+                        if (FAILED(hr)) {
+                            qWarning("Failed to set color space on swapchain: %s",
+                                qPrintable(QSystemError::windowsComString(hr)));
+                        }
+                        sc3->Release();
+                    } else {
+                        qWarning("IDXGISwapChain3 not available, HDR swapchain will not work as expected");
+                    }
+                }
+                if (dcompVisual) {
+                    hr = dcompVisual->SetContent(sc1);
+                    if (SUCCEEDED(hr)) {
+                        hr = dcompTarget->SetRoot(dcompVisual);
+                        if (FAILED(hr)) {
+                            qWarning("Failed to associate Direct Composition visual with the target: %s",
+                                     qPrintable(QSystemError::windowsComString(hr)));
+                        }
+                    } else {
+                        qWarning("Failed to set content for Direct Composition visual: %s",
                                  qPrintable(QSystemError::windowsComString(hr)));
                     }
-                } else {
-                    qWarning("Failed to set content for Direct Composition visual: %s",
-                             qPrintable(QSystemError::windowsComString(hr)));
                 }
             }
+        } else {
+            // Fallback: use DISCARD model. Regardless, keep on using our manual
+            // resolve for symmetry with the FLIP_* code path when MSAA is
+            // requested. This has no HDR support.
+
+            DXGI_SWAP_CHAIN_DESC desc = {};
+            desc.BufferDesc.Width = UINT(pixelSize.width());
+            desc.BufferDesc.Height = UINT(pixelSize.height());
+            desc.BufferDesc.RefreshRate.Numerator = 60;
+            desc.BufferDesc.RefreshRate.Denominator = 1;
+            desc.BufferDesc.Format = colorFormat;
+            desc.SampleDesc.Count = 1;
+            desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
+            desc.BufferCount = 1;
+            desc.OutputWindow = hwnd;
+            desc.Windowed = TRUE;
+            desc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
+            desc.Flags = swapChainFlags;
+
+            hr = rhiD->dxgiFactory->CreateSwapChain(rhiD->dev, &desc, &swapChain);
         }
         if (FAILED(hr)) {
             qWarning("Failed to create D3D11 swapchain: %s",
                 qPrintable(QSystemError::windowsComString(hr)));
             return false;
         }
-        rhiD->dxgiFactory->MakeWindowAssociation(hwnd, DXGI_MWA_NO_WINDOW_CHANGES);
+        rhiD->dxgiFactory->MakeWindowAssociation(hwnd,
+            DXGI_MWA_NO_WINDOW_CHANGES | DXGI_MWA_NO_ALT_ENTER | DXGI_MWA_NO_PRINT_SCREEN);
     } else {
         releaseBuffers();
-        // flip model -> buffer count is the real buffer count, not 1 like with the legacy modes
-        hr = swapChain->ResizeBuffers(UINT(BUFFER_COUNT), UINT(pixelSize.width()), UINT(pixelSize.height()),
+        const UINT count = useFlipModel ? BUFFER_COUNT : 1;
+        hr = swapChain->ResizeBuffers(count, UINT(pixelSize.width()), UINT(pixelSize.height()),
                                       colorFormat, swapChainFlags);
         if (hr == DXGI_ERROR_DEVICE_REMOVED || hr == DXGI_ERROR_DEVICE_RESET) {
             qWarning("Device loss detected in ResizeBuffers()");
@@ -5081,7 +5221,7 @@ bool QD3D11SwapChain::createOrResize()
     // swapchain."
 
     // So just query index 0 once (per resize) and be done with it.
-    hr = swapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<void **>(&backBufferTex));
+    hr = swapChain->GetBuffer(0, IID_PPV_ARGS(&backBufferTex));
     if (FAILED(hr)) {
         qWarning("Failed to query swapchain backbuffer: %s",
             qPrintable(QSystemError::windowsComString(hr)));
diff --git a/src/gui/rhi/qrhid3d11_p_p.h b/src/gui/rhi/qrhid3d11_p_p.h
index d53f7f80a9..f984786181 100644
--- a/src/gui/rhi/qrhid3d11_p_p.h
+++ b/src/gui/rhi/qrhid3d11_p_p.h
@@ -737,8 +737,9 @@ public:
     LUID adapterLuid = {};
     ID3DUserDefinedAnnotation *annotations = nullptr;
     IDXGIAdapter1 *activeAdapter = nullptr;
-    IDXGIFactory1 *dxgiFactory = nullptr;
+    IDXGIFactory *dxgiFactory = nullptr;
     IDCompositionDevice *dcompDevice = nullptr;
+    bool supportsFlipSwapchain = false;
     bool supportsAllowTearing = false;
     bool deviceLost = false;
     QRhiD3D11NativeHandles nativeHandlesStruct;
diff --git a/src/gui/text/windows/qwindowsdirectwritefontdatabase.cpp b/src/gui/text/windows/qwindowsdirectwritefontdatabase.cpp
index 6b4933cca7..eed71b6e94 100644
--- a/src/gui/text/windows/qwindowsdirectwritefontdatabase.cpp
+++ b/src/gui/text/windows/qwindowsdirectwritefontdatabase.cpp
@@ -107,8 +107,7 @@ void QWindowsDirectWriteFontDatabase::populateFamily(const QString &familyName)
             IDWriteFont *font;
             if (SUCCEEDED(matchingFonts->GetFont(j, &font))) {
                 IDWriteFont1 *font1 = nullptr;
-                if (!SUCCEEDED(font->QueryInterface(__uuidof(IDWriteFont1),
-                                                   reinterpret_cast<void **>(&font1)))) {
+                if (!SUCCEEDED(font->QueryInterface(IID_PPV_ARGS(&font1)))) {
                     qCWarning(lcQpaFonts) << "COM object does not support IDWriteFont1";
                     continue;
                 }
@@ -271,8 +270,7 @@ QStringList QWindowsDirectWriteFontDatabase::addApplicationFont(const QByteArray
 
     QStringList ret;
     IDWriteFontFace3 *face3 = nullptr;
-    if (SUCCEEDED(face->QueryInterface(__uuidof(IDWriteFontFace3),
-                                      reinterpret_cast<void **>(&face3)))) {
+    if (SUCCEEDED(face->QueryInterface(IID_PPV_ARGS(&face3)))) {
         QString defaultLocaleFamilyName;
         QString englishLocaleFamilyName;
 
diff --git a/src/gui/text/windows/qwindowsfontdatabase.cpp b/src/gui/text/windows/qwindowsfontdatabase.cpp
index 2de53be6a8..4e6ffa14f7 100644
--- a/src/gui/text/windows/qwindowsfontdatabase.cpp
+++ b/src/gui/text/windows/qwindowsfontdatabase.cpp
@@ -1188,8 +1188,7 @@ QFontEngine *QWindowsFontDatabase::createEngine(const QFontDef &request, const Q
                 bool isColorFont = false;
 #if QT_CONFIG(direct2d)
                 IDWriteFontFace2 *directWriteFontFace2 = nullptr;
-                if (SUCCEEDED(directWriteFontFace->QueryInterface(__uuidof(IDWriteFontFace2),
-                                                                  reinterpret_cast<void **>(&directWriteFontFace2)))) {
+                if (SUCCEEDED(directWriteFontFace->QueryInterface(IID_PPV_ARGS(&directWriteFontFace2)))) {
                     if (directWriteFontFace2->IsColorFont())
                         isColorFont = directWriteFontFace2->GetPaletteEntryCount() > 0;
 
diff --git a/src/gui/text/windows/qwindowsfontdatabasebase.cpp b/src/gui/text/windows/qwindowsfontdatabasebase.cpp
index f9b36b4852..f09123f327 100644
--- a/src/gui/text/windows/qwindowsfontdatabasebase.cpp
+++ b/src/gui/text/windows/qwindowsfontdatabasebase.cpp
@@ -6,6 +6,7 @@
 
 #include <QtCore/QThreadStorage>
 #include <QtCore/QtEndian>
+#include <QtCore/private/qsystemlibrary_p.h>
 
 #if QT_CONFIG(directwrite)
 #  if QT_CONFIG(directwrite3)
@@ -546,17 +547,23 @@ bool QWindowsFontDatabaseBase::init(QSharedPointer<QWindowsFontEngineData> d)
 #if QT_CONFIG(directwrite) && QT_CONFIG(direct2d)
 void QWindowsFontDatabaseBase::createDirectWriteFactory(IDWriteFactory **factory)
 {
+    static const auto pDWriteCreateFactory =
+        reinterpret_cast<decltype(&::DWriteCreateFactory)>(
+            QSystemLibrary::resolve(u"dwrite"_s, "DWriteCreateFactory"));
+    if (!pDWriteCreateFactory)
+        return;
+
     *factory = nullptr;
     IUnknown *result = nullptr;
 
 #  if QT_CONFIG(directwrite3)
-    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory3), &result);
+    pDWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory3), &result);
 #  endif
     if (result == nullptr)
-        DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory2), &result);
+        pDWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory2), &result);
 
     if (result == nullptr) {
-        if (FAILED(DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory), &result))) {
+        if (FAILED(pDWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory), &result))) {
             qErrnoWarning("DWriteCreateFactory failed");
             return;
         }
@@ -685,7 +692,13 @@ QFont QWindowsFontDatabaseBase::systemDefaultFont()
     // Qt 6: Obtain default GUI font (typically "Segoe UI, 9pt", see QTBUG-58610)
     NONCLIENTMETRICS ncm = {};
     ncm.cbSize = sizeof(ncm);
-    SystemParametersInfoForDpi(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0, defaultVerticalDPI());
+    static const auto pSystemParametersInfoForDpi =
+        reinterpret_cast<decltype(&::SystemParametersInfoForDpi)>(
+            QSystemLibrary::resolve(u"user32"_s, "SystemParametersInfoForDpi"));
+    if (pSystemParametersInfoForDpi)
+        pSystemParametersInfoForDpi(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0, defaultVerticalDPI());
+    else
+        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0);
     const QFont systemFont = QWindowsFontDatabase::LOGFONT_to_QFont(ncm.lfMessageFont);
     qCDebug(lcQpaFonts) << __FUNCTION__ << systemFont;
     return systemFont;
diff --git a/src/gui/text/windows/qwindowsfontenginedirectwrite.cpp b/src/gui/text/windows/qwindowsfontenginedirectwrite.cpp
index 14dd064c33..026211c0a3 100644
--- a/src/gui/text/windows/qwindowsfontenginedirectwrite.cpp
+++ b/src/gui/text/windows/qwindowsfontenginedirectwrite.cpp
@@ -671,8 +671,7 @@ bool QWindowsFontEngineDirectWrite::supportsHorizontalSubPixelPositions() const
 QFontEngine::Properties QWindowsFontEngineDirectWrite::properties() const
 {
     IDWriteFontFace2 *directWriteFontFace2;
-    if (SUCCEEDED(m_directWriteFontFace->QueryInterface(__uuidof(IDWriteFontFace2),
-                                                        reinterpret_cast<void **>(&directWriteFontFace2)))) {
+    if (SUCCEEDED(m_directWriteFontFace->QueryInterface(IID_PPV_ARGS(&directWriteFontFace2)))) {
         DWRITE_FONT_METRICS1 metrics;
         directWriteFontFace2->GetMetrics(&metrics);
 
@@ -739,8 +738,7 @@ QImage QWindowsFontEngineDirectWrite::imageForGlyph(glyph_t t,
             : DWRITE_GRID_FIT_MODE_DEFAULT;
 
     IDWriteFactory2 *factory2 = nullptr;
-    HRESULT hr = m_fontEngineData->directWriteFactory->QueryInterface(__uuidof(IDWriteFactory2),
-                                                                      reinterpret_cast<void **>(&factory2));
+    HRESULT hr = m_fontEngineData->directWriteFactory->QueryInterface(IID_PPV_ARGS(&factory2));
     IDWriteGlyphRunAnalysis *glyphAnalysis = NULL;
     if (!SUCCEEDED(hr)) {
         qErrnoWarning(hr, "%s: Failed to query IDWriteFactory2 interface.", __FUNCTION__);
@@ -1063,8 +1061,7 @@ glyph_metrics_t QWindowsFontEngineDirectWrite::alphaMapBoundingBox(glyph_t glyph
             : DWRITE_GRID_FIT_MODE_DEFAULT;
 
     IDWriteFactory2 *factory2 = nullptr;
-    HRESULT hr = m_fontEngineData->directWriteFactory->QueryInterface(__uuidof(IDWriteFactory2),
-                                                                      reinterpret_cast<void **>(&factory2));
+    HRESULT hr = m_fontEngineData->directWriteFactory->QueryInterface(IID_PPV_ARGS(&factory2));
 
     IDWriteGlyphRunAnalysis *glyphAnalysis = NULL;
     if (SUCCEEDED(hr)) {
diff --git a/src/network/CMakeLists.txt b/src/network/CMakeLists.txt
index 3283260c66..f52a27da5d 100644
--- a/src/network/CMakeLists.txt
+++ b/src/network/CMakeLists.txt
@@ -5,6 +5,9 @@
 ## Network Module:
 #####################################################################
 
+qt_find_package(WrapZLIB PROVIDED_TARGETS WrapZLIB::WrapZLIB)
+qt_find_package(WrapZSTD PROVIDED_TARGETS WrapZSTD::WrapZSTD)
+
 qt_internal_add_module(Network
     PLUGIN_TYPES networkaccess networkinformation tls
     SOURCES
@@ -59,6 +62,8 @@ qt_internal_add_module(Network
         kernel
     LIBRARIES
         Qt::CorePrivate
+        WrapZLIB::WrapZLIB
+        WrapZSTD::WrapZSTD
     PUBLIC_LIBRARIES
         Qt::Core
     PRIVATE_MODULE_INTERFACE
@@ -136,24 +141,14 @@ qt_internal_extend_target(Network CONDITION QT_FEATURE_brotli AND QT_FEATURE_htt
         WrapBrotli::WrapBrotliDec
 )
 
-qt_internal_extend_target(Network CONDITION QT_FEATURE_http AND QT_FEATURE_zstd
-    LIBRARIES
-        WrapZSTD::WrapZSTD
-)
-
-qt_internal_extend_target(Network CONDITION QT_FEATURE_system_zlib
-    LIBRARIES
-        WrapZLIB::WrapZLIB
-)
-
 qt_internal_extend_target(Network CONDITION NOT QT_FEATURE_system_zlib
-    INCLUDE_DIRECTORIES
-        ../3rdparty/zlib/src
+    LIBRARIES
+        Qt::ZlibPrivate
 )
 
-qt_internal_extend_target(Network CONDITION NOT QT_FEATURE_system_zlib AND NOT no_core_dep
+qt_internal_extend_target(Network CONDITION NOT QT_FEATURE_system_zstd
     LIBRARIES
-        Qt::Core
+        Qt::ZstdPrivate
 )
 
 qt_internal_extend_target(Network CONDITION QT_FEATURE_topleveldomain
diff --git a/src/network/access/qdecompresshelper.cpp b/src/network/access/qdecompresshelper.cpp
index 98c9860450..9b6cb2d45f 100644
--- a/src/network/access/qdecompresshelper.cpp
+++ b/src/network/access/qdecompresshelper.cpp
@@ -9,15 +9,12 @@
 
 #include <limits>
 #include <zlib.h>
+#include <zstd.h>
 
 #if QT_CONFIG(brotli)
 #    include <brotli/decode.h>
 #endif
 
-#if QT_CONFIG(zstd)
-#    include <zstd.h>
-#endif
-
 #include <array>
 
 QT_BEGIN_NAMESPACE
@@ -29,9 +26,7 @@ struct ContentEncodingMapping
 };
 
 constexpr ContentEncodingMapping contentEncodingMapping[] {
-#if QT_CONFIG(zstd)
     { "zstd", QDecompressHelper::Zstandard },
-#endif
 #if QT_CONFIG(brotli)
     { "br", QDecompressHelper::Brotli },
 #endif
@@ -60,12 +55,10 @@ BrotliDecoderState *toBrotliPointer(void *ptr)
 }
 #endif
 
-#if QT_CONFIG(zstd)
 ZSTD_DStream *toZstandardPointer(void *ptr)
 {
     return static_cast<ZSTD_DStream *>(ptr);
 }
-#endif
 }
 
 bool QDecompressHelper::isSupportedEncoding(const QByteArray &encoding)
@@ -139,11 +132,7 @@ bool QDecompressHelper::setEncoding(ContentEncoding ce)
 #endif
         break;
     case Zstandard:
-#if QT_CONFIG(zstd)
         decoderPointer = ZSTD_createDStream();
-#else
-        Q_UNREACHABLE();
-#endif
         break;
     }
     if (!decoderPointer) {
@@ -536,11 +525,9 @@ void QDecompressHelper::clear()
         break;
     }
     case Zstandard: {
-#if QT_CONFIG(zstd)
         ZSTD_DStream *zstdStream = toZstandardPointer(decoderPointer);
         if (zstdStream)
             ZSTD_freeDStream(zstdStream);
-#endif
         break;
     }
     }
@@ -745,11 +732,6 @@ qsizetype QDecompressHelper::readBrotli(char *data, const qsizetype maxSize)
 
 qsizetype QDecompressHelper::readZstandard(char *data, const qsizetype maxSize)
 {
-#if !QT_CONFIG(zstd)
-    Q_UNUSED(data);
-    Q_UNUSED(maxSize);
-    Q_UNREACHABLE();
-#else
     ZSTD_DStream *zstdStream = toZstandardPointer(decoderPointer);
 
     QByteArrayView input = compressedDataBuffer.readPointer();
@@ -779,7 +761,6 @@ qsizetype QDecompressHelper::readZstandard(char *data, const qsizetype maxSize)
     }
     compressedDataBuffer.advanceReadPointer(inBuf.pos);
     return bytesDecoded;
-#endif
 }
 
 QT_END_NAMESPACE
diff --git a/src/network/socket/qnativesocketengine_win.cpp b/src/network/socket/qnativesocketengine_win.cpp
index 16d974a68b..613e24d49f 100644
--- a/src/network/socket/qnativesocketengine_win.cpp
+++ b/src/network/socket/qnativesocketengine_win.cpp
@@ -271,12 +271,31 @@ bool QNativeSocketEnginePrivate::createNewSocket(QAbstractSocket::SocketType soc
     // MSDN KB179942 states that on winnt 4 WSA_FLAG_OVERLAPPED is needed if socket is to be non
     // blocking and recommends always doing it for cross-windows-version compatibility.
 
-    // WSA_FLAG_NO_HANDLE_INHERIT is atomic (like linux O_CLOEXEC)
+    // WSA_FLAG_NO_HANDLE_INHERIT is atomic (like linux O_CLOEXEC), but requires windows 7 SP 1 or later
+    // SetHandleInformation is supported since W2K but isn't atomic
 #ifndef WSA_FLAG_NO_HANDLE_INHERIT
 #define WSA_FLAG_NO_HANDLE_INHERIT 0x80
 #endif
 
     SOCKET socket = ::WSASocket(protocol, type, 0, NULL, 0, WSA_FLAG_NO_HANDLE_INHERIT | WSA_FLAG_OVERLAPPED);
+    // previous call fails if the windows 7 service pack 1 or hot fix isn't installed.
+
+    // Try the old API if the new one failed on Windows 7
+    if (socket == INVALID_SOCKET && !QOperatingSystemVersion::isWin8OrGreater()) {
+        socket = ::WSASocket(protocol, type, 0, NULL, 0, WSA_FLAG_OVERLAPPED);
+#ifdef HANDLE_FLAG_INHERIT
+        if (socket != INVALID_SOCKET) {
+            // make non inheritable the old way
+            BOOL handleFlags = SetHandleInformation(reinterpret_cast<HANDLE>(socket), HANDLE_FLAG_INHERIT, 0);
+#  ifdef QNATIVESOCKETENGINE_DEBUG
+            qDebug() << "QNativeSocketEnginePrivate::createNewSocket - set inheritable" << handleFlags;
+#  else // !QNATIVESOCKETENGINE_DEBUG
+            Q_UNUSED(handleFlags);
+#  endif // QNATIVESOCKETENGINE_DEBUG
+        }
+#endif // HANDLE_FLAG_INHERIT
+    }
+
     if (socket == INVALID_SOCKET) {
         int err = WSAGetLastError();
         WS_ERROR_DEBUG(err);
diff --git a/src/plugins/imageformats/jpeg/qjpeghandler.cpp b/src/plugins/imageformats/jpeg/qjpeghandler.cpp
index 0d72ba01d0..1ac875666a 100644
--- a/src/plugins/imageformats/jpeg/qjpeghandler.cpp
+++ b/src/plugins/imageformats/jpeg/qjpeghandler.cpp
@@ -545,6 +545,9 @@ static bool do_write_jpeg_image(struct jpeg_compress_struct &cinfo,
 
         jpeg_set_defaults(&cinfo);
 
+        cinfo.comp_info[0].v_samp_factor = 1;
+        cinfo.comp_info[0].h_samp_factor = 1;
+
         qreal diffInch = qAbs(image.dotsPerMeterX()*2.54/100. - qRound(image.dotsPerMeterX()*2.54/100.))
                          + qAbs(image.dotsPerMeterY()*2.54/100. - qRound(image.dotsPerMeterY()*2.54/100.));
         qreal diffCm = (qAbs(image.dotsPerMeterX()/100. - qRound(image.dotsPerMeterX()/100.))
diff --git a/src/plugins/networkinformation/networklistmanager/CMakeLists.txt b/src/plugins/networkinformation/networklistmanager/CMakeLists.txt
index 77501d0e5c..dad5346c15 100644
--- a/src/plugins/networkinformation/networklistmanager/CMakeLists.txt
+++ b/src/plugins/networkinformation/networklistmanager/CMakeLists.txt
@@ -14,11 +14,6 @@ qt_internal_add_plugin(QNLMNIPlugin
         Qt::NetworkPrivate
 )
 
-qt_internal_extend_target(QNLMNIPlugin CONDITION WIN32 AND MSVC AND NOT CLANG
-    LIBRARIES
-        runtimeobject
-)
-
 # Don't repeat the target name in AUTOGEN_BUILD_DIR to work around issues with overlong paths.
 set_property(TARGET QNLMNIPlugin PROPERTY
     AUTOGEN_BUILD_DIR "${CMAKE_CURRENT_BINARY_DIR}/autogen")
diff --git a/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp b/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp
index 7d6fd6d5c1..5a633e258b 100644
--- a/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp
+++ b/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp
@@ -5,6 +5,7 @@
 #include <QtCore/private/qsystemerror_p.h>
 
 #include <QtCore/qpointer.h>
+#include <QtCore/qoperatingsystemversion.h>
 
 #include <mutex>
 
@@ -100,26 +101,28 @@ bool QNetworkListManagerEvents::start()
     }
 
 #if QT_CONFIG(cpp_winrt)
-    using namespace winrt::Windows::Networking::Connectivity;
-    using winrt::Windows::Foundation::IInspectable;
-    try {
-        // Register for changes in the network and store a token to unregister later:
-        token = NetworkInformation::NetworkStatusChanged(
-                [owner = QPointer(this)](const IInspectable sender) {
-                    Q_UNUSED(sender);
-                    if (owner) {
-                        std::scoped_lock locker(owner->winrtLock);
-                        if (owner->token)
-                            owner->emitWinRTUpdates();
-                    }
-                });
-    } catch (const winrt::hresult_error &ex) {
-        qCWarning(lcNetInfoNLM) << "Failed to register network status changed callback:"
-                                << QSystemError::windowsComString(ex.code());
-    }
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        using namespace winrt::Windows::Networking::Connectivity;
+        using winrt::Windows::Foundation::IInspectable;
+        try {
+            // Register for changes in the network and store a token to unregister later:
+            token = NetworkInformation::NetworkStatusChanged(
+                    [owner = QPointer(this)](const IInspectable sender) {
+                        Q_UNUSED(sender);
+                        if (owner) {
+                            std::scoped_lock locker(owner->winrtLock);
+                            if (owner->token)
+                                owner->emitWinRTUpdates();
+                        }
+                    });
+        } catch (const winrt::hresult_error &ex) {
+            qCWarning(lcNetInfoNLM) << "Failed to register network status changed callback:"
+                                    << QSystemError::windowsComString(ex.code());
+        }
 
-    // Emit initial state
-    emitWinRTUpdates();
+        // Emit initial state
+        emitWinRTUpdates();
+    }
 #endif
 
     return true;
@@ -138,13 +141,15 @@ void QNetworkListManagerEvents::stop()
     // Even if we fail we should still try to unregister from winrt events:
 
 #if QT_CONFIG(cpp_winrt)
-    // Try to synchronize unregistering with potentially in-progress callbacks
-    std::scoped_lock locker(winrtLock);
-    if (token) {
-        using namespace winrt::Windows::Networking::Connectivity;
-        // Pass the token we stored earlier to unregister:
-        NetworkInformation::NetworkStatusChanged(token);
-        token = {};
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        // Try to synchronize unregistering with potentially in-progress callbacks
+        std::scoped_lock locker(winrtLock);
+        if (token) {
+            using namespace winrt::Windows::Networking::Connectivity;
+            // Pass the token we stored earlier to unregister:
+            NetworkInformation::NetworkStatusChanged(token);
+            token = {};
+        }
     }
 #endif
 }
@@ -195,6 +200,9 @@ using namespace winrt::Windows::Networking::Connectivity;
 [[nodiscard]]
 QNetworkInformation::TransportMedium getTransportMedium(const ConnectionProfile &profile)
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return QNetworkInformation::TransportMedium::Unknown;
+
     if (profile.IsWwanConnectionProfile())
         return QNetworkInformation::TransportMedium::Cellular;
     if (profile.IsWlanConnectionProfile())
@@ -230,6 +238,8 @@ QNetworkInformation::TransportMedium getTransportMedium(const ConnectionProfile
 
 [[nodiscard]] bool getMetered(const ConnectionProfile &profile)
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return false;
     ConnectionCost cost(nullptr);
     try {
         cost = profile.GetConnectionCost();
@@ -247,6 +257,8 @@ QNetworkInformation::TransportMedium getTransportMedium(const ConnectionProfile
 
 void QNetworkListManagerEvents::emitWinRTUpdates()
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return;
     using namespace winrt::Windows::Networking::Connectivity;
     ConnectionProfile profile = nullptr;
     try {
diff --git a/src/plugins/platforms/CMakeLists.txt b/src/plugins/platforms/CMakeLists.txt
index bcf29dedd1..4095e3f023 100644
--- a/src/plugins/platforms/CMakeLists.txt
+++ b/src/plugins/platforms/CMakeLists.txt
@@ -4,12 +4,6 @@
 if(ANDROID)
     add_subdirectory(android)
 endif()
-if(NOT ANDROID AND NOT WASM)
-    add_subdirectory(minimal)
-endif()
-if(QT_FEATURE_freetype AND NOT ANDROID AND NOT WASM)
-    add_subdirectory(offscreen)
-endif()
 if(QT_FEATURE_xcb)
     add_subdirectory(xcb)
 endif()
@@ -22,9 +16,6 @@ endif()
 if(WIN32)
     add_subdirectory(windows)
 endif()
-if(QT_FEATURE_direct2d1_1 AND QT_FEATURE_directwrite)
-    add_subdirectory(direct2d)
-endif()
 if(QNX)
     add_subdirectory(qnx)
 endif()
diff --git a/src/plugins/platforms/direct2d/CMakeLists.txt b/src/plugins/platforms/direct2d/CMakeLists.txt
index e21b230cd7..4dddb21238 100644
--- a/src/plugins/platforms/direct2d/CMakeLists.txt
+++ b/src/plugins/platforms/direct2d/CMakeLists.txt
@@ -58,12 +58,6 @@ qt_internal_add_plugin(QWindowsDirect2DIntegrationPlugin
         Qt::Gui
         Qt::GuiPrivate
         advapi32
-        d2d1
-        d3d11
-        dwmapi
-        dwrite
-        dxgi
-        dxguid
         gdi32
         imm32
         ole32
@@ -76,10 +70,7 @@ qt_internal_add_plugin(QWindowsDirect2DIntegrationPlugin
         winmm
         winspool
         wtsapi32
-        shcore
         comdlg32
-        d3d9
-        runtimeobject
 )
 
 # Resources:
diff --git a/src/plugins/platforms/windows/CMakeLists.txt b/src/plugins/platforms/windows/CMakeLists.txt
index ca1bbcb758..b157e1cf2d 100644
--- a/src/plugins/platforms/windows/CMakeLists.txt
+++ b/src/plugins/platforms/windows/CMakeLists.txt
@@ -51,7 +51,6 @@ qt_internal_add_plugin(QWindowsIntegrationPlugin
         Qt::Gui
         Qt::GuiPrivate
         advapi32
-        dwmapi
         gdi32
         imm32
         ole32
@@ -63,10 +62,7 @@ qt_internal_add_plugin(QWindowsIntegrationPlugin
         winmm
         winspool
         wtsapi32
-        shcore
         comdlg32
-        d3d9
-        runtimeobject
 )
 
 # Resources:
diff --git a/src/plugins/platforms/windows/qtwindowsglobal.h b/src/plugins/platforms/windows/qtwindowsglobal.h
index d39e923644..22787bd63e 100644
--- a/src/plugins/platforms/windows/qtwindowsglobal.h
+++ b/src/plugins/platforms/windows/qtwindowsglobal.h
@@ -150,13 +150,14 @@ enum WindowsEventType // Simplify event types
 Q_DECLARE_MIXED_ENUM_OPERATORS(bool, WindowsEventTypeFlags, WindowsEventType);
 Q_DECLARE_MIXED_ENUM_OPERATORS(bool, WindowsEventType, WindowsEventTypeFlags);
 
-// Matches Process_DPI_Awareness (Windows 8.1 onwards), used for SetProcessDpiAwareness()
-enum ProcessDpiAwareness
+enum class DpiAwareness
 {
-    ProcessDpiUnaware,
-    ProcessSystemDpiAware,
-    ProcessPerMonitorDpiAware,
-    ProcessPerMonitorV2DpiAware // Qt extension (not in Process_DPI_Awareness)
+    Invalid = -1,
+    Unaware,
+    System,
+    PerMonitor,
+    PerMonitorVersion2,
+    Unaware_GdiScaled
 };
 
 } // namespace QtWindows
@@ -326,6 +327,10 @@ inline QtWindows::WindowsEventType windowsEventType(UINT message, WPARAM wParamI
     return QtWindows::UnknownEvent;
 }
 
+#ifndef QT_NO_DEBUG_STREAM
+extern QDebug operator<<(QDebug, QtWindows::DpiAwareness);
+#endif
+
 QT_END_NAMESPACE
 
 #endif // QTWINDOWSGLOBAL_H
diff --git a/src/plugins/platforms/windows/qwin10helpers.cpp b/src/plugins/platforms/windows/qwin10helpers.cpp
index 026e81cb0c..e17d2bc20d 100644
--- a/src/plugins/platforms/windows/qwin10helpers.cpp
+++ b/src/plugins/platforms/windows/qwin10helpers.cpp
@@ -4,6 +4,8 @@
 #include "qwin10helpers.h"
 
 #include <QtCore/qdebug.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 #include <winstring.h>
 #include <roapi.h>
 
@@ -60,29 +62,62 @@ public:
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
+struct QComBaseApi
+{
+    decltype(&::RoGetActivationFactory) pRoGetActivationFactory = nullptr;
+    decltype(&::WindowsCreateStringReference) pWindowsCreateStringReference = nullptr;
+
+    static QComBaseApi *instance()
+    {
+        static QComBaseApi api;
+        return &api;
+    }
+
+private:
+    Q_DISABLE_COPY_MOVE(QComBaseApi)
+
+    explicit QComBaseApi()
+    {
+        QSystemLibrary comBase(u"combase"_s);
+        pRoGetActivationFactory = reinterpret_cast<decltype(pRoGetActivationFactory)>(comBase.resolve("RoGetActivationFactory"));
+        pWindowsCreateStringReference = reinterpret_cast<decltype(pWindowsCreateStringReference)>(comBase.resolve("WindowsCreateStringReference"));
+    }
+
+    ~QComBaseApi() = default;
+};
+
 // Return tablet mode, note: Does not work for GetDesktopWindow().
 bool qt_windowsIsTabletMode(HWND hwnd)
 {
+    if (!QComBaseApi::instance()->pRoGetActivationFactory ||
+        !QComBaseApi::instance()->pWindowsCreateStringReference) {
+        return false;
+    }
+
     bool result = false;
 
     const wchar_t uiViewSettingsId[] = L"Windows.UI.ViewManagement.UIViewSettings";
     HSTRING_HEADER uiViewSettingsIdRefHeader;
     HSTRING uiViewSettingsIdHs = nullptr;
     const auto uiViewSettingsIdLen = UINT32(sizeof(uiViewSettingsId) / sizeof(uiViewSettingsId[0]) - 1);
-    if (FAILED(WindowsCreateStringReference(uiViewSettingsId, uiViewSettingsIdLen, &uiViewSettingsIdRefHeader, &uiViewSettingsIdHs)))
+    if (FAILED(QComBaseApi::instance()->pWindowsCreateStringReference(uiViewSettingsId, uiViewSettingsIdLen, &uiViewSettingsIdRefHeader, &uiViewSettingsIdHs)))
         return false;
 
     IUIViewSettingsInterop *uiViewSettingsInterop = nullptr;
     // __uuidof(IUIViewSettingsInterop);
-    const GUID uiViewSettingsInteropRefId = {0x3694dbf9, 0x8f68, 0x44be,{0x8f, 0xf5, 0x19, 0x5c, 0x98, 0xed, 0xe8, 0xa6}};
+    static constexpr const GUID uiViewSettingsInteropRefId =
+        {0x3694dbf9, 0x8f68, 0x44be,{0x8f, 0xf5, 0x19, 0x5c, 0x98, 0xed, 0xe8, 0xa6}};
 
-    HRESULT hr = RoGetActivationFactory(uiViewSettingsIdHs, uiViewSettingsInteropRefId,
+    HRESULT hr = QComBaseApi::instance()->pRoGetActivationFactory(uiViewSettingsIdHs, uiViewSettingsInteropRefId,
                                                    reinterpret_cast<void **>(&uiViewSettingsInterop));
     if (FAILED(hr))
         return false;
 
     //  __uuidof(ABI::Windows::UI::ViewManagement::IUIViewSettings);
-    const GUID uiViewSettingsRefId = {0xc63657f6, 0x8850, 0x470d,{0x88, 0xf8, 0x45, 0x5e, 0x16, 0xea, 0x2c, 0x26}};
+    static constexpr const GUID uiViewSettingsRefId =
+        {0xc63657f6, 0x8850, 0x470d,{0x88, 0xf8, 0x45, 0x5e, 0x16, 0xea, 0x2c, 0x26}};
     ABI::Windows::UI::ViewManagement::IUIViewSettings *viewSettings = nullptr;
     hr = uiViewSettingsInterop->GetForWindow(hwnd, uiViewSettingsRefId,
                                              reinterpret_cast<void **>(&viewSettings));
diff --git a/src/plugins/platforms/windows/qwindowscontext.cpp b/src/plugins/platforms/windows/qwindowscontext.cpp
index 9b72efaea9..a30ba5fd2b 100644
--- a/src/plugins/platforms/windows/qwindowscontext.cpp
+++ b/src/plugins/platforms/windows/qwindowscontext.cpp
@@ -118,26 +118,6 @@ static inline bool sessionManagerInteractionBlocked()
 static inline bool sessionManagerInteractionBlocked() { return false; }
 #endif
 
-static inline int windowDpiAwareness(HWND hwnd)
-{
-    return static_cast<int>(GetAwarenessFromDpiAwarenessContext(GetWindowDpiAwarenessContext(hwnd)));
-}
-
-// Note: This only works within WM_NCCREATE
-static bool enableNonClientDpiScaling(HWND hwnd)
-{
-    bool result = false;
-    if (windowDpiAwareness(hwnd) == 2) {
-        result = EnableNonClientDpiScaling(hwnd) != FALSE;
-        if (!result) {
-            const DWORD errorCode = GetLastError();
-            qErrnoWarning(int(errorCode), "EnableNonClientDpiScaling() failed for HWND %p (%lu)",
-                          hwnd, errorCode);
-        }
-    }
-    return result;
-}
-
 QWindowsContext *QWindowsContext::m_instance = nullptr;
 
 /*!
@@ -224,7 +204,8 @@ QWindowsContext::~QWindowsContext()
     unregisterWindowClasses();
     if (d->m_oleInitializeResult == S_OK || d->m_oleInitializeResult == S_FALSE) {
 #ifdef QT_USE_FACTORY_CACHE_REGISTRATION
-        detail::QWinRTFactoryCacheRegistration::clearAllCaches();
+        if (QOperatingSystemVersion::isWin10OrGreater())
+            detail::QWinRTFactoryCacheRegistration::clearAllCaches();
 #endif
         OleUninitialize();
     }
@@ -299,6 +280,9 @@ bool QWindowsContext::initPointer(unsigned integrationOptions)
     if (integrationOptions & QWindowsIntegration::DontUseWMPointer)
         return false;
 
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     d->m_systemInfo |= QWindowsContext::SI_SupportsPointer;
     return true;
 }
@@ -366,49 +350,207 @@ void QWindowsContext::setDetectAltGrModifier(bool a)
     d->m_keyMapper.setDetectAltGrModifier(a);
 }
 
-int QWindowsContext::processDpiAwareness()
+[[nodiscard]] static inline QtWindows::DpiAwareness
+    dpiAwarenessContextToQtDpiAwareness(DPI_AWARENESS_CONTEXT context)
 {
-    PROCESS_DPI_AWARENESS result;
-    if (SUCCEEDED(GetProcessDpiAwareness(nullptr, &result))) {
-        return static_cast<int>(result);
+    if (!QWindowsApi::instance()->pIsValidDpiAwarenessContext
+            || !QWindowsApi::instance()->pAreDpiAwarenessContextsEqual) {
+        return QtWindows::DpiAwareness::Invalid;
     }
-    return -1;
+    // IsValidDpiAwarenessContext() will handle the NULL pointer case.
+    if (!QWindowsApi::instance()->pIsValidDpiAwarenessContext(context))
+        return QtWindows::DpiAwareness::Invalid;
+    if (QWindowsApi::instance()->pAreDpiAwarenessContextsEqual(
+                context, DPI_AWARENESS_CONTEXT_UNAWARE_GDISCALED))
+        return QtWindows::DpiAwareness::Unaware_GdiScaled;
+    if (QWindowsApi::instance()->pAreDpiAwarenessContextsEqual(
+                context, DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2))
+        return QtWindows::DpiAwareness::PerMonitorVersion2;
+    if (QWindowsApi::instance()->pAreDpiAwarenessContextsEqual(
+                context, DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE))
+        return QtWindows::DpiAwareness::PerMonitor;
+    if (QWindowsApi::instance()->pAreDpiAwarenessContextsEqual(
+                context, DPI_AWARENESS_CONTEXT_SYSTEM_AWARE))
+        return QtWindows::DpiAwareness::System;
+    if (QWindowsApi::instance()->pAreDpiAwarenessContextsEqual(
+                context, DPI_AWARENESS_CONTEXT_UNAWARE))
+        return QtWindows::DpiAwareness::Unaware;
+    return QtWindows::DpiAwareness::Invalid;
+}
+
+QtWindows::DpiAwareness QWindowsContext::windowDpiAwareness(HWND hwnd)
+{
+    if (!hwnd)
+        return QtWindows::DpiAwareness::Invalid;
+    if (QWindowsApi::instance()->pGetWindowDpiAwarenessContext) {
+        const auto context = QWindowsApi::instance()->pGetWindowDpiAwarenessContext(hwnd);
+        return dpiAwarenessContextToQtDpiAwareness(context);
+    }
+    qCWarning(lcQpaWindow) << "Current platform doesn't support querying DPI awareness "
+                              "mode for a specific window, using current process's DPI "
+                              "awareness mode instead.";
+    return processDpiAwareness();
+}
+
+[[nodiscard]] static inline QtWindows::DpiAwareness
+    processDpiAwarenessToQtDpiAwareness(PROCESS_DPI_AWARENESS pda)
+{
+    switch (pda) {
+    case PROCESS_DPI_UNAWARE:
+        return QtWindows::DpiAwareness::Unaware;
+    case PROCESS_SYSTEM_DPI_AWARE:
+        return QtWindows::DpiAwareness::System;
+    case PROCESS_PER_MONITOR_DPI_AWARE:
+        return QtWindows::DpiAwareness::PerMonitor;
+    }
+    return QtWindows::DpiAwareness::Invalid;
 }
 
-void QWindowsContext::setProcessDpiAwareness(QtWindows::ProcessDpiAwareness dpiAwareness)
+QtWindows::DpiAwareness QWindowsContext::processDpiAwareness()
 {
-    qCDebug(lcQpaWindow) << __FUNCTION__ << dpiAwareness;
-    if (processDpiAwareness() == int(dpiAwareness))
-        return;
+    // Although we have GetDpiAwarenessContextForProcess(), however,
+    // it's only available on Win10 1903+, which is a little higher
+    // than Qt's minimum supported version (1809), so we can't use it.
+    // Luckily, MS docs said GetThreadDpiAwarenessContext() will also
+    // return the default DPI_AWARENESS_CONTEXT for the process if
+    // SetThreadDpiAwarenessContext() was never called. So we can use
+    // it as an equivalent.
+    if (QWindowsApi::instance()->pGetThreadDpiAwarenessContext) {
+        const auto context = QWindowsApi::instance()->pGetThreadDpiAwarenessContext();
+        return dpiAwarenessContextToQtDpiAwareness(context);
+    }
+    if (QWindowsApi::instance()->pGetProcessDpiAwareness) {
+        PROCESS_DPI_AWARENESS pda = PROCESS_DPI_UNAWARE;
+        const HRESULT hr = QWindowsApi::instance()->pGetProcessDpiAwareness(nullptr, &pda);
+        if (SUCCEEDED(hr)) {
+            return processDpiAwarenessToQtDpiAwareness(pda);
+        } else {
+            qCWarning(lcQpaWindow).nospace().noquote()
+                    << "GetProcessDpiAwareness() failed: "
+                    << QSystemError::windowsComString(hr);
+        }
+    }
+    if (IsProcessDPIAware()) {
+        return QtWindows::DpiAwareness::System;
+    }
+    return QtWindows::DpiAwareness::Unaware;
+}
+
+[[nodiscard]] static inline DPI_AWARENESS_CONTEXT
+    qtDpiAwarenessToDpiAwarenessContext(QtWindows::DpiAwareness dpiAwareness)
+{
+    switch (dpiAwareness) {
+    case QtWindows::DpiAwareness::Invalid:
+        return nullptr;
+    case QtWindows::DpiAwareness::Unaware:
+        return DPI_AWARENESS_CONTEXT_UNAWARE;
+    case QtWindows::DpiAwareness::System:
+        return DPI_AWARENESS_CONTEXT_SYSTEM_AWARE;
+    case QtWindows::DpiAwareness::PerMonitor:
+        return DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE;
+    case QtWindows::DpiAwareness::PerMonitorVersion2:
+        return DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2;
+    case QtWindows::DpiAwareness::Unaware_GdiScaled:
+        return DPI_AWARENESS_CONTEXT_UNAWARE_GDISCALED;
+    }
+    return nullptr;
+}
+
+#ifndef QT_NO_DEBUG_STREAM
+QDebug operator<<(QDebug d, QtWindows::DpiAwareness dpiAwareness)
+{
+    const QDebugStateSaver saver(d);
+    QString message = u"QtWindows::DpiAwareness::"_s;
+    switch (dpiAwareness) {
+    case QtWindows::DpiAwareness::Invalid:
+        message += u"Invalid"_s;
+        break;
+    case QtWindows::DpiAwareness::Unaware:
+        message += u"Unaware"_s;
+        break;
+    case QtWindows::DpiAwareness::System:
+        message += u"System"_s;
+        break;
+    case QtWindows::DpiAwareness::PerMonitor:
+        message += u"PerMonitor"_s;
+        break;
+    case QtWindows::DpiAwareness::PerMonitorVersion2:
+        message += u"PerMonitorVersion2"_s;
+        break;
+    case QtWindows::DpiAwareness::Unaware_GdiScaled:
+        message += u"Unaware_GdiScaled"_s;
+        break;
+    }
+    d.nospace().noquote() << message;
+    return d;
+}
+#endif
 
-    const HRESULT hr = SetProcessDpiAwareness(static_cast<PROCESS_DPI_AWARENESS>(dpiAwareness));
-    if (FAILED(hr)) {
-        qCWarning(lcQpaWindow).noquote().nospace() << "SetProcessDpiAwareness("
-            << dpiAwareness << ") failed: " << QSystemError::windowsComString(hr) << ", using "
-            << QWindowsContext::processDpiAwareness() << "\nQt's fallback DPI awareness is "
-            << "PROCESS_DPI_AWARENESS. If you know what you are doing consider an override in qt.conf";
+[[nodiscard]] static inline PROCESS_DPI_AWARENESS
+    qtDpiAwarenessToProcessDpiAwareness(QtWindows::DpiAwareness awareness)
+{
+    switch (awareness) {
+    case QtWindows::DpiAwareness::Invalid:
+        return PROCESS_DPI_AWARENESS(-1);
+    case QtWindows::DpiAwareness::Unaware:
+    case QtWindows::DpiAwareness::Unaware_GdiScaled:
+        return PROCESS_DPI_UNAWARE;
+    case QtWindows::DpiAwareness::System:
+        return PROCESS_SYSTEM_DPI_AWARE;
+    case QtWindows::DpiAwareness::PerMonitor:
+    case QtWindows::DpiAwareness::PerMonitorVersion2:
+        return PROCESS_PER_MONITOR_DPI_AWARE;
     }
+    return PROCESS_DPI_AWARENESS(-1);
 }
 
-bool QWindowsContext::setProcessDpiV2Awareness()
+bool QWindowsContext::setProcessDpiAwareness(QtWindows::DpiAwareness dpiAwareness)
 {
-    qCDebug(lcQpaWindow) << __FUNCTION__;
-    auto dpiContext = GetThreadDpiAwarenessContext();
-    if (AreDpiAwarenessContextsEqual(dpiContext, DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2))
+    qCDebug(lcQpaWindow) << __FUNCTION__ << dpiAwareness;
+    if (processDpiAwareness() == dpiAwareness)
         return true;
-
-    const BOOL ok = SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);
-    if (!ok) {
-        const DWORD dwError = GetLastError();
-        qCWarning(lcQpaWindow).noquote().nospace()
-            << "SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2) failed: "
-            << QSystemError::windowsComString(HRESULT(dwError)) << "\nQt's default DPI awareness "
-            << "context is DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2. If you know what you "
-            << "are doing you can overwrite this default using qt.conf "
-            << "(https://doc.qt.io/qt-6/highdpi.html#configuring-windows)";
+    if (QWindowsApi::instance()->pIsValidDpiAwarenessContext
+            && QWindowsApi::instance()->pSetProcessDpiAwarenessContext) {
+        const auto context = qtDpiAwarenessToDpiAwarenessContext(dpiAwareness);
+        if (!QWindowsApi::instance()->pIsValidDpiAwarenessContext(context)) {
+            qCWarning(lcQpaWindow) << dpiAwareness << "is not supported by current system.";
+            return false;
+        }
+        if (!QWindowsApi::instance()->pSetProcessDpiAwarenessContext(context)) {
+            qCWarning(lcQpaWindow).noquote().nospace()
+                << "SetProcessDpiAwarenessContext() failed: "
+                << QSystemError::windowsString()
+                << "\nQt's default DPI awareness context is "
+                << "DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2. If you know what you "
+                << "are doing, you can overwrite this default using qt.conf "
+                << "(https://doc.qt.io/qt-6/highdpi.html#configuring-windows).";
+            return false;
+        }
+        return true;
+    }
+    if (QWindowsApi::instance()->pSetProcessDpiAwareness) {
+        const PROCESS_DPI_AWARENESS pda = qtDpiAwarenessToProcessDpiAwareness(dpiAwareness);
+        if (int(pda) == -1) {
+            qCWarning(lcQpaWindow).nospace().noquote()
+                    << "Failed to retrieve the current process's DPI awareness mode.";
+            return false;
+        }
+        const HRESULT hr = QWindowsApi::instance()->pSetProcessDpiAwareness(pda);
+        if (FAILED(hr)) {
+            qCWarning(lcQpaWindow).nospace().noquote()
+                    << "SetProcessDpiAwareness() failed: "
+                    << QSystemError::windowsComString(hr);
+            return false;
+        }
+        return true;
+    }
+    if (!SetProcessDPIAware()) {
+        qCWarning(lcQpaWindow).nospace().noquote()
+                << "SetProcessDPIAware() failed: " << QSystemError::windowsString();
         return false;
     }
-    QWindowsContextPrivate::m_v2DpiAware = true;
+    QWindowsContextPrivate::m_v2DpiAware
+        = processDpiAwareness() == QtWindows::DpiAwareness::PerMonitorVersion2;
     return true;
 }
 
@@ -837,8 +979,8 @@ void QWindowsContext::forceNcCalcSize(HWND hwnd)
 bool QWindowsContext::systemParametersInfo(unsigned action, unsigned param, void *out,
                                            unsigned dpi)
 {
-    const BOOL result = dpi != 0
-        ? SystemParametersInfoForDpi(action, param, out, 0, dpi)
+    const BOOL result = (dpi != 0) && (QWindowsApi::instance()->pSystemParametersInfoForDpi != nullptr)
+        ? QWindowsApi::instance()->pSystemParametersInfoForDpi(action, param, out, 0, dpi)
         : SystemParametersInfo(action, param, out, 0);
     return result == TRUE;
 }
@@ -885,7 +1027,8 @@ bool QWindowsContext::shouldHaveNonClientDpiScaling(const QWindow *window)
     if (QWindowsContextPrivate::m_v2DpiAware)
         return true;
 
-    return window->isTopLevel()
+    return QOperatingSystemVersion::isWin10OrGreater()
+        && window->isTopLevel()
         && !window->property(QWindowsWindow::embeddedNativeParentHandleProperty).isValid()
 #if QT_CONFIG(opengl) // /QTBUG-62901, EnableNonClientDpiScaling has problems with GL
         && (window->surfaceType() != QSurface::OpenGLSurface
@@ -921,6 +1064,23 @@ static inline bool isInputMessage(UINT m)
         || (m >= WM_KEYFIRST && m <= WM_KEYLAST);
 }
 
+// Note: This only works within WM_NCCREATE
+static bool enableNonClientDpiScaling(HWND hwnd)
+{
+    if (!QWindowsApi::instance()->pEnableNonClientDpiScaling)
+        return false;
+    bool result = false;
+    if (QWindowsContext::windowDpiAwareness(hwnd) == QtWindows::DpiAwareness::PerMonitor) {
+        result = QWindowsApi::instance()->pEnableNonClientDpiScaling(hwnd) != FALSE;
+        if (!result) {
+            const DWORD errorCode = GetLastError();
+            qErrnoWarning(int(errorCode), "EnableNonClientDpiScaling() failed for HWND %p (%lu)",
+                          hwnd, errorCode);
+        }
+    }
+    return result;
+}
+
 /*!
      \brief Main windows procedure registered for windows.
 
@@ -1544,4 +1704,137 @@ bool QWindowsContext::filterNativeEvent(QWindow *window, MSG *msg, LRESULT *resu
     return false;
 }
 
+UINT QWindowsContext::getDpiForWindow(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    if (QWindowsApi::instance()->pGetDpiForWindow)
+        return QWindowsApi::instance()->pGetDpiForWindow(hWnd);
+    if (const HDC hdc = GetDC(hWnd)) {
+        const int dpiX = GetDeviceCaps(hdc, LOGPIXELSX);
+        ReleaseDC(hWnd, hdc);
+        if (dpiX > 0)
+            return dpiX;
+    }
+    return 0;
+}
+
+UINT QWindowsContext::getDpiForMonitor(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    if (QWindowsApi::instance()->pGetDpiForMonitor) {
+        UINT dpiX = 0;
+        UINT dpiY = 0;
+        const HRESULT hr = QWindowsApi::instance()->pGetDpiForMonitor(hMonitor, MDT_EFFECTIVE_DPI, &dpiX, &dpiY);
+        if (SUCCEEDED(hr) && (dpiX > 0))
+            return dpiX;
+    }
+    MONITORINFOEXW monitorInfo;
+    SecureZeroMemory(&monitorInfo, sizeof(monitorInfo));
+    monitorInfo.cbSize = sizeof(monitorInfo);
+    GetMonitorInfoW(hMonitor, &monitorInfo);
+    if (const HDC hdc = CreateDCW(monitorInfo.szDevice, monitorInfo.szDevice, nullptr, nullptr)) {
+        const int dpiX = GetDeviceCaps(hdc, LOGPIXELSX);
+        DeleteDC(hdc);
+        if (dpiX > 0)
+            return dpiX;
+    }
+    return 0;
+}
+
+UINT QWindowsContext::getDpiForPrimaryMonitor()
+{
+    if (const HMONITOR hMonitor = MonitorFromWindow(GetDesktopWindow(), MONITOR_DEFAULTTOPRIMARY))
+        return getDpiForMonitor(hMonitor);
+    return 0;
+}
+
+UINT QWindowsContext::getMostPossibleDpiForWindow(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    UINT dpi = getDpiForWindow(hWnd);
+    if (dpi > 0)
+        return dpi;
+    if (const HMONITOR hMonitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTONEAREST)) {
+        dpi = getDpiForMonitor(hMonitor);
+        if (dpi > 0)
+            return dpi;
+    }
+    dpi = getDpiForPrimaryMonitor();
+    if (dpi > 0)
+        return dpi;
+    return USER_DEFAULT_SCREEN_DPI;
+}
+
+UINT QWindowsContext::getMostPossibleDpiForMonitor(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    UINT dpi = getDpiForMonitor(hMonitor);
+    if (dpi > 0)
+        return dpi;
+    dpi = getDpiForPrimaryMonitor();
+    if (dpi > 0)
+        return dpi;
+    return USER_DEFAULT_SCREEN_DPI;
+}
+
+int QWindowsContext::getResizeBorderThicknessForDpi(const UINT dpi)
+{
+    // The thickness of the padded border will always be 0 if DWM composition is disabled.
+    if (QWindowsApi::instance()->pGetSystemMetricsForDpi) {
+        return QWindowsApi::instance()->pGetSystemMetricsForDpi(SM_CXSIZEFRAME, dpi)
+            + QWindowsApi::instance()->pGetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi);
+    }
+    return GetSystemMetrics(SM_CXSIZEFRAME) + GetSystemMetrics(SM_CXPADDEDBORDER);
+}
+
+int QWindowsContext::getResizeBorderThickness(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    return getResizeBorderThicknessForDpi(getMostPossibleDpiForWindow(hWnd));
+}
+
+int QWindowsContext::getResizeBorderThickness(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    return getResizeBorderThicknessForDpi(getMostPossibleDpiForMonitor(hMonitor));
+}
+
+int QWindowsContext::getTitleBarHeightForDpi(const UINT dpi)
+{
+    const int border = getResizeBorderThicknessForDpi(dpi);
+    if (QWindowsApi::instance()->pGetSystemMetricsForDpi) {
+        return border +
+            QWindowsApi::instance()->pGetSystemMetricsForDpi(SM_CYCAPTION, dpi);
+    }
+    return border + GetSystemMetrics(SM_CYCAPTION);
+}
+
+int QWindowsContext::getTitleBarHeight(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    return getTitleBarHeightForDpi(getMostPossibleDpiForWindow(hWnd));
+}
+
+int QWindowsContext::getTitleBarHeight(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    return getTitleBarHeightForDpi(getMostPossibleDpiForMonitor(hMonitor));
+}
+
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/windows/qwindowscontext.h b/src/plugins/platforms/windows/qwindowscontext.h
index 6b3010f33c..408ac39529 100644
--- a/src/plugins/platforms/windows/qwindowscontext.h
+++ b/src/plugins/platforms/windows/qwindowscontext.h
@@ -10,13 +10,18 @@
 #include <QtCore/qscopedpointer.h>
 #include <QtCore/qsharedpointer.h>
 #include <QtCore/qloggingcategory.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 
 #define STRICT_TYPED_ITEMIDS
 #include <shlobj.h>
 #include <shlwapi.h>
+#include <shellscalingapi.h>
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 Q_DECLARE_LOGGING_CATEGORY(lcQpaWindow)
 Q_DECLARE_LOGGING_CATEGORY(lcQpaEvents)
 Q_DECLARE_LOGGING_CATEGORY(lcQpaGl)
@@ -44,6 +49,119 @@ class QPoint;
 class QKeyEvent;
 class QPointingDevice;
 
+struct QWindowsApi
+{
+    decltype(&::GetDpiForWindow) pGetDpiForWindow = nullptr;
+    decltype(&::GetDpiForMonitor) pGetDpiForMonitor = nullptr;
+    decltype(&::SystemParametersInfoForDpi) pSystemParametersInfoForDpi = nullptr;
+    decltype(&::GetSystemMetricsForDpi) pGetSystemMetricsForDpi = nullptr;
+    decltype(&::AdjustWindowRectExForDpi) pAdjustWindowRectExForDpi = nullptr;
+    decltype(&::GetProcessDpiAwareness) pGetProcessDpiAwareness = nullptr;
+    decltype(&::SetProcessDpiAwareness) pSetProcessDpiAwareness = nullptr;
+    decltype(&::SetProcessDpiAwarenessContext) pSetProcessDpiAwarenessContext = nullptr;
+    decltype(&::EnableNonClientDpiScaling) pEnableNonClientDpiScaling = nullptr;
+    decltype(&::GetAwarenessFromDpiAwarenessContext) pGetAwarenessFromDpiAwarenessContext = nullptr;
+    decltype(&::GetWindowDpiAwarenessContext) pGetWindowDpiAwarenessContext = nullptr;
+    decltype(&::GetThreadDpiAwarenessContext) pGetThreadDpiAwarenessContext = nullptr;
+    decltype(&::AreDpiAwarenessContextsEqual) pAreDpiAwarenessContextsEqual = nullptr;
+    decltype(&::GetPointerType) pGetPointerType = nullptr;
+    decltype(&::GetPointerInfo) pGetPointerInfo = nullptr;
+    decltype(&::GetPointerFrameTouchInfo) pGetPointerFrameTouchInfo = nullptr;
+    decltype(&::GetPointerFrameTouchInfoHistory) pGetPointerFrameTouchInfoHistory = nullptr;
+    decltype(&::GetPointerPenInfo) pGetPointerPenInfo = nullptr;
+    decltype(&::GetPointerPenInfoHistory) pGetPointerPenInfoHistory = nullptr;
+    decltype(&::SkipPointerFrameMessages) pSkipPointerFrameMessages = nullptr;
+    decltype(&::GetPointerDeviceRects) pGetPointerDeviceRects = nullptr;
+    decltype(&::SetDisplayAutoRotationPreferences) pSetDisplayAutoRotationPreferences = nullptr;
+    decltype(&::GetDisplayAutoRotationPreferences) pGetDisplayAutoRotationPreferences = nullptr;
+    decltype(&::RegisterTouchWindow) pRegisterTouchWindow = nullptr;
+    decltype(&::UnregisterTouchWindow) pUnregisterTouchWindow = nullptr;
+    decltype(&::IsTouchWindow) pIsTouchWindow = nullptr;
+    decltype(&::GetDisplayConfigBufferSizes) pGetDisplayConfigBufferSizes = nullptr;
+    decltype(&::QueryDisplayConfig) pQueryDisplayConfig = nullptr;
+    decltype(&::DisplayConfigGetDeviceInfo) pDisplayConfigGetDeviceInfo = nullptr;
+    decltype(&::GetTouchInputInfo) pGetTouchInputInfo = nullptr;
+    decltype(&::CloseTouchInputHandle) pCloseTouchInputHandle = nullptr;
+    decltype(&::ChangeWindowMessageFilterEx) pChangeWindowMessageFilterEx = nullptr;
+    decltype(&::Shell_NotifyIconGetRect) pShell_NotifyIconGetRect = nullptr;
+    decltype(&::IsValidDpiAwarenessContext) pIsValidDpiAwarenessContext = nullptr;
+
+    static QWindowsApi *instance()
+    {
+        static QWindowsApi api;
+        return &api;
+    }
+
+    bool supportsPointerApi() const
+    {
+        return pGetPointerType && pGetPointerInfo && pGetPointerFrameTouchInfo
+            && pGetPointerFrameTouchInfoHistory && pGetPointerPenInfo
+            && pGetPointerPenInfoHistory && pSkipPointerFrameMessages
+            && pGetPointerDeviceRects;
+    }
+
+private:
+    Q_DISABLE_COPY_MOVE(QWindowsApi)
+
+    explicit QWindowsApi()
+    {
+        if (QOperatingSystemVersion::isWin7OrGreater()) {
+            QSystemLibrary shell32(u"shell32"_s);
+            pShell_NotifyIconGetRect = reinterpret_cast<decltype(pShell_NotifyIconGetRect)>(shell32.resolve("Shell_NotifyIconGetRect"));
+
+            QSystemLibrary user32(u"user32"_s);
+            pRegisterTouchWindow = reinterpret_cast<decltype(pRegisterTouchWindow)>(user32.resolve("RegisterTouchWindow"));
+            pUnregisterTouchWindow = reinterpret_cast<decltype(pUnregisterTouchWindow)>(user32.resolve("UnregisterTouchWindow"));
+            pIsTouchWindow = reinterpret_cast<decltype(pIsTouchWindow)>(user32.resolve("IsTouchWindow"));
+            pGetDisplayConfigBufferSizes = reinterpret_cast<decltype(pGetDisplayConfigBufferSizes)>(user32.resolve("GetDisplayConfigBufferSizes"));
+            pQueryDisplayConfig = reinterpret_cast<decltype(pQueryDisplayConfig)>(user32.resolve("QueryDisplayConfig"));
+            pDisplayConfigGetDeviceInfo = reinterpret_cast<decltype(pDisplayConfigGetDeviceInfo)>(user32.resolve("DisplayConfigGetDeviceInfo"));
+            pGetTouchInputInfo = reinterpret_cast<decltype(pGetTouchInputInfo)>(user32.resolve("GetTouchInputInfo"));
+            pCloseTouchInputHandle = reinterpret_cast<decltype(pCloseTouchInputHandle)>(user32.resolve("CloseTouchInputHandle"));
+            pChangeWindowMessageFilterEx = reinterpret_cast<decltype(pChangeWindowMessageFilterEx)>(user32.resolve("ChangeWindowMessageFilterEx"));
+
+            if (QOperatingSystemVersion::isWin8OrGreater()) {
+                pGetPointerType = reinterpret_cast<decltype(pGetPointerType)>(user32.resolve("GetPointerType"));
+                pGetPointerInfo = reinterpret_cast<decltype(pGetPointerInfo)>(user32.resolve("GetPointerInfo"));
+                pGetPointerFrameTouchInfo = reinterpret_cast<decltype(pGetPointerFrameTouchInfo)>(user32.resolve("GetPointerFrameTouchInfo"));
+                pGetPointerFrameTouchInfoHistory = reinterpret_cast<decltype(pGetPointerFrameTouchInfoHistory)>(user32.resolve("GetPointerFrameTouchInfoHistory"));
+                pGetPointerPenInfo = reinterpret_cast<decltype(pGetPointerPenInfo)>(user32.resolve("GetPointerPenInfo"));
+                pGetPointerPenInfoHistory = reinterpret_cast<decltype(pGetPointerPenInfoHistory)>(user32.resolve("GetPointerPenInfoHistory"));
+                pSkipPointerFrameMessages = reinterpret_cast<decltype(pSkipPointerFrameMessages)>(user32.resolve("SkipPointerFrameMessages"));
+                pGetPointerDeviceRects = reinterpret_cast<decltype(pGetPointerDeviceRects)>(user32.resolve("GetPointerDeviceRects"));
+                pSetDisplayAutoRotationPreferences = reinterpret_cast<decltype(pSetDisplayAutoRotationPreferences)>(user32.resolve("SetDisplayAutoRotationPreferences"));
+                pGetDisplayAutoRotationPreferences = reinterpret_cast<decltype(pGetDisplayAutoRotationPreferences)>(user32.resolve("GetDisplayAutoRotationPreferences"));
+
+                if (QOperatingSystemVersion::isWin8Point1OrGreater()) {
+                    QSystemLibrary shcore(u"shcore"_s);
+                    pGetDpiForMonitor = reinterpret_cast<decltype(pGetDpiForMonitor)>(shcore.resolve("GetDpiForMonitor"));
+                    pGetProcessDpiAwareness = reinterpret_cast<decltype(pGetProcessDpiAwareness)>(shcore.resolve("GetProcessDpiAwareness"));
+                    pSetProcessDpiAwareness = reinterpret_cast<decltype(pSetProcessDpiAwareness)>(shcore.resolve("SetProcessDpiAwareness"));
+
+                    if (QOperatingSystemVersion::isWin10RS1OrGreater()) {
+                        pGetDpiForWindow = reinterpret_cast<decltype(pGetDpiForWindow)>(user32.resolve("GetDpiForWindow"));
+                        pSystemParametersInfoForDpi = reinterpret_cast<decltype(pSystemParametersInfoForDpi)>(user32.resolve("SystemParametersInfoForDpi"));
+                        pGetSystemMetricsForDpi = reinterpret_cast<decltype(pGetSystemMetricsForDpi)>(user32.resolve("GetSystemMetricsForDpi"));
+                        pAdjustWindowRectExForDpi = reinterpret_cast<decltype(pAdjustWindowRectExForDpi)>(user32.resolve("AdjustWindowRectExForDpi"));
+                        pEnableNonClientDpiScaling = reinterpret_cast<decltype(pEnableNonClientDpiScaling)>(user32.resolve("EnableNonClientDpiScaling"));
+                        pGetAwarenessFromDpiAwarenessContext = reinterpret_cast<decltype(pGetAwarenessFromDpiAwarenessContext)>(user32.resolve("GetAwarenessFromDpiAwarenessContext"));
+                        pGetWindowDpiAwarenessContext = reinterpret_cast<decltype(pGetWindowDpiAwarenessContext)>(user32.resolve("GetWindowDpiAwarenessContext"));
+                        pGetThreadDpiAwarenessContext = reinterpret_cast<decltype(pGetThreadDpiAwarenessContext)>(user32.resolve("GetThreadDpiAwarenessContext"));
+                        pAreDpiAwarenessContextsEqual = reinterpret_cast<decltype(pAreDpiAwarenessContextsEqual)>(user32.resolve("AreDpiAwarenessContextsEqual"));
+                        pIsValidDpiAwarenessContext = reinterpret_cast<decltype(pIsValidDpiAwarenessContext)>(user32.resolve("IsValidDpiAwarenessContext"));
+
+                        if (QOperatingSystemVersion::isWin10RS2OrGreater()) {
+                            pSetProcessDpiAwarenessContext = reinterpret_cast<decltype(pSetProcessDpiAwarenessContext)>(user32.resolve("SetProcessDpiAwarenessContext"));
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    ~QWindowsApi() = default;
+};
+
 class QWindowsContext
 {
     Q_DISABLE_COPY_MOVE(QWindowsContext)
@@ -115,9 +233,10 @@ public:
     QSharedPointer<QWindowCreationContext> windowCreationContext() const;
 
     static void setTabletAbsoluteRange(int a);
-    void setProcessDpiAwareness(QtWindows::ProcessDpiAwareness dpiAwareness);
-    static int processDpiAwareness();
-    bool setProcessDpiV2Awareness();
+
+    static bool setProcessDpiAwareness(QtWindows::DpiAwareness dpiAwareness);
+    static QtWindows::DpiAwareness processDpiAwareness();
+    static QtWindows::DpiAwareness windowDpiAwareness(HWND hwnd);
 
     static bool isDarkMode();
 
@@ -158,6 +277,18 @@ public:
     static bool filterNativeEvent(MSG *msg, LRESULT *result);
     static bool filterNativeEvent(QWindow *window, MSG *msg, LRESULT *result);
 
+    [[nodiscard]] static UINT getDpiForWindow(const HWND hWnd);
+    [[nodiscard]] static UINT getDpiForMonitor(const HMONITOR hMonitor);
+    [[nodiscard]] static UINT getDpiForPrimaryMonitor();
+    [[nodiscard]] static UINT getMostPossibleDpiForWindow(const HWND hWnd);
+    [[nodiscard]] static UINT getMostPossibleDpiForMonitor(const HMONITOR hMonitor);
+    [[nodiscard]] static int getResizeBorderThicknessForDpi(const UINT dpi);
+    [[nodiscard]] static int getResizeBorderThickness(const HWND hWnd);
+    [[nodiscard]] static int getResizeBorderThickness(const HMONITOR hMonitor);
+    [[nodiscard]] static int getTitleBarHeightForDpi(const UINT dpi);
+    [[nodiscard]] static int getTitleBarHeight(const HWND hWnd);
+    [[nodiscard]] static int getTitleBarHeight(const HMONITOR hMonitor);
+
 private:
     void handleFocusEvent(QtWindows::WindowsEventType et, QWindowsWindow *w);
 #ifndef QT_NO_CONTEXTMENU
diff --git a/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp b/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp
index 51bd9f0c38..07309ed3e7 100644
--- a/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp
+++ b/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp
@@ -1416,7 +1416,8 @@ static QString createTemporaryItemCopy(QWindowsShellItem &qItem, QString *errorM
 static QUrl itemToDialogUrl(QWindowsShellItem &qItem, QString *errorMessage)
 {
     QUrl url = qItem.url();
-    if (url.isLocalFile() || url.scheme().startsWith(u"http"))
+    // Patch: Make loaded 'http' resources copy.
+    if (url.isLocalFile()/*|| url.scheme().startsWith(u"http")*/)
         return url;
     const QString path = qItem.path();
     if (path.isEmpty() && !qItem.isDir() && qItem.canStream()) {
diff --git a/src/plugins/platforms/windows/qwindowsdrag.cpp b/src/plugins/platforms/windows/qwindowsdrag.cpp
index 48e0bba41f..fe36b00cf4 100644
--- a/src/plugins/platforms/windows/qwindowsdrag.cpp
+++ b/src/plugins/platforms/windows/qwindowsdrag.cpp
@@ -665,12 +665,13 @@ static HRESULT startDoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
                 return ::DoDragDrop(pDataObj, pDropSource, dwOKEffects, pdwEffect);
             }
 
-            if (msg.message == WM_POINTERUPDATE) {
+            static const bool pointerApiSupported = QWindowsApi::instance()->supportsPointerApi();
+            if (msg.message == WM_POINTERUPDATE && pointerApiSupported) {
 
                 const quint32 pointerId = GET_POINTERID_WPARAM(msg.wParam);
 
                 POINTER_INFO pointerInfo{};
-                if (!GetPointerInfo(pointerId, &pointerInfo))
+                if (!QWindowsApi::instance()->pGetPointerInfo(pointerId, &pointerInfo))
                     return E_FAIL;
 
                 if (pointerInfo.pointerFlags & POINTER_FLAG_PRIMARY) {
@@ -714,7 +715,7 @@ static HRESULT startDoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
                 // Handle other messages.
                 qWindowsWndProc(msg.hwnd, msg.message, msg.wParam, msg.lParam);
 
-                if (msg.message == WM_POINTERLEAVE)
+                if (msg.message == WM_POINTERLEAVE && pointerApiSupported)
                     return E_FAIL;
             }
         } else {
diff --git a/src/plugins/platforms/windows/qwindowsintegration.cpp b/src/plugins/platforms/windows/qwindowsintegration.cpp
index 923e515b4f..24a7f0a60e 100644
--- a/src/plugins/platforms/windows/qwindowsintegration.cpp
+++ b/src/plugins/platforms/windows/qwindowsintegration.cpp
@@ -144,7 +144,7 @@ bool parseIntOption(const QString &parameter,const QLatin1StringView &option,
     const auto valueRef = QStringView{parameter}.right(valueLength);
     const int value = valueRef.toInt(&ok);
     if (ok) {
-        if (value >= minimumValue && value <= maximumValue)
+        if (value >= int(minimumValue) && value <= int(maximumValue))
             *target = static_cast<IntType>(value);
         else {
             qWarning() << "Value" << value << "for option" << option << "out of range"
@@ -161,7 +161,7 @@ using DarkModeHandling = QNativeInterface::Private::QWindowsApplication::DarkMod
 
 static inline unsigned parseOptions(const QStringList &paramList,
                                     int *tabletAbsoluteRange,
-                                    QtWindows::ProcessDpiAwareness *dpiAwareness,
+                                    QtWindows::DpiAwareness *dpiAwareness,
                                     DarkModeHandling *darkModeHandling)
 {
     unsigned options = 0;
@@ -192,7 +192,8 @@ static inline unsigned parseOptions(const QStringList &paramList,
             options |= QWindowsIntegration::DontPassOsMouseEventsSynthesizedFromTouch;
         } else if (parseIntOption(param, "verbose"_L1, 0, INT_MAX, &QWindowsContext::verbose)
             || parseIntOption(param, "tabletabsoluterange"_L1, 0, INT_MAX, tabletAbsoluteRange)
-            || parseIntOption(param, "dpiawareness"_L1, QtWindows::ProcessDpiUnaware, QtWindows::ProcessPerMonitorV2DpiAware, dpiAwareness)) {
+            || parseIntOption(param, "dpiawareness"_L1, QtWindows::DpiAwareness::Invalid,
+                    QtWindows::DpiAwareness::PerMonitorVersion2, dpiAwareness)) {
         } else if (param == u"menus=native") {
             options |= QWindowsIntegration::AlwaysUseNativeMenus;
         } else if (param == u"menus=none") {
@@ -221,8 +222,12 @@ void QWindowsIntegrationPrivate::parseOptions(QWindowsIntegration *q, const QStr
     initOpenGlBlacklistResources();
 
     static bool dpiAwarenessSet = false;
+    static const bool hasDpiAwarenessContext =
+            QWindowsApi::instance()->pSetProcessDpiAwarenessContext != nullptr;
     // Default to per-monitor-v2 awareness (if available)
-    QtWindows::ProcessDpiAwareness dpiAwareness = QtWindows::ProcessPerMonitorV2DpiAware;
+    QtWindows::DpiAwareness dpiAwareness = hasDpiAwarenessContext
+            ? QtWindows::DpiAwareness::PerMonitorVersion2
+            : QtWindows::DpiAwareness::PerMonitor;
 
     int tabletAbsoluteRange = -1;
     DarkModeHandling darkModeHandling = DarkModeHandlingFlag::DarkModeWindowFrames
@@ -241,22 +246,13 @@ void QWindowsIntegrationPrivate::parseOptions(QWindowsIntegration *q, const QStr
 
     if (!dpiAwarenessSet) { // Set only once in case of repeated instantiations of QGuiApplication.
         if (!QCoreApplication::testAttribute(Qt::AA_PluginApplication)) {
-            if (dpiAwareness == QtWindows::ProcessPerMonitorV2DpiAware) {
-                // DpiAwareV2 requires using new API
-                if (m_context.setProcessDpiV2Awareness()) {
-                    qCDebug(lcQpaWindow, "DpiAwareness: DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2");
-                    dpiAwarenessSet = true;
-                } else {
-                    // fallback to old API
-                    dpiAwareness = QtWindows::ProcessPerMonitorDpiAware;
+            for (auto i = int(dpiAwareness); i != int(QtWindows::DpiAwareness::Invalid); --i) {
+                if (m_context.setProcessDpiAwareness(QtWindows::DpiAwareness(i))) {
+                    break;
                 }
             }
-
-            if (!dpiAwarenessSet) {
-                m_context.setProcessDpiAwareness(dpiAwareness);
-                qCDebug(lcQpaWindow) << "DpiAwareness=" << dpiAwareness
-                    << "effective process DPI awareness=" << QWindowsContext::processDpiAwareness();
-            }
+            qCDebug(lcQpaWindow) << "DpiAwareness=" << dpiAwareness
+                << "effective process DPI awareness=" << QWindowsContext::processDpiAwareness();
         }
         dpiAwarenessSet = true;
     }
diff --git a/src/plugins/platforms/windows/qwindowskeymapper.cpp b/src/plugins/platforms/windows/qwindowskeymapper.cpp
index 3089e745d4..fa961110d7 100644
--- a/src/plugins/platforms/windows/qwindowskeymapper.cpp
+++ b/src/plugins/platforms/windows/qwindowskeymapper.cpp
@@ -749,21 +749,10 @@ static inline QString messageKeyText(const MSG &msg)
     return ch.isNull() ? QString() : QString(ch);
 }
 
-[[nodiscard]] static inline int getTitleBarHeight(const HWND hwnd)
-{
-    const UINT dpi = GetDpiForWindow(hwnd);
-    const int captionHeight = GetSystemMetricsForDpi(SM_CYCAPTION, dpi);
-    if (IsZoomed(hwnd))
-        return captionHeight;
-    // The frame height should also be taken into account if the window
-    // is not maximized.
-    const int frameHeight = GetSystemMetricsForDpi(SM_CYSIZEFRAME, dpi)
-                            + GetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi);
-    return captionHeight + frameHeight;
-}
-
 [[nodiscard]] static inline bool isSystemMenuOffsetNeeded(const Qt::WindowFlags flags)
 {
+    if (qEnvironmentVariableIntValue("QT_WINDOWS_SYSTEM_MENU_NEED_OFFSET"))
+        return true;
     static constexpr const Qt::WindowFlags titleBarHints =
         Qt::WindowMinMaxButtonsHint | Qt::WindowCloseButtonHint | Qt::WindowContextHelpButtonHint;
     return (flags & Qt::WindowSystemMenuHint) && (flags & Qt::WindowTitleHint) && !(flags & titleBarHints)
@@ -804,7 +793,8 @@ static void showSystemMenu(QWindow* w)
 #undef disabled
 
     const QPoint pos = QHighDpi::toNativePixels(topLevel->geometry().topLeft(), topLevel);
-    const int titleBarOffset = isSystemMenuOffsetNeeded(topLevel->flags()) ? getTitleBarHeight(topLevelHwnd) : 0;
+    const int titleBarOffset = isSystemMenuOffsetNeeded(topLevel->flags())
+        ? QWindowsContext::getTitleBarHeight(topLevelHwnd) : 0;
     const int ret = TrackPopupMenuEx(menu,
                                TPM_LEFTALIGN | TPM_TOPALIGN | TPM_NONOTIFY | TPM_RETURNCMD,
                                pos.x(), pos.y() + titleBarOffset,
diff --git a/src/plugins/platforms/windows/qwindowsmousehandler.cpp b/src/plugins/platforms/windows/qwindowsmousehandler.cpp
index 28c88ab716..dc51ce4293 100644
--- a/src/plugins/platforms/windows/qwindowsmousehandler.cpp
+++ b/src/plugins/platforms/windows/qwindowsmousehandler.cpp
@@ -564,6 +564,11 @@ bool QWindowsMouseHandler::translateTouchEvent(QWindow *window, HWND,
     using QTouchPoint = QWindowSystemInterface::TouchPoint;
     using QTouchPointList = QList<QWindowSystemInterface::TouchPoint>;
 
+    if (!QWindowsApi::instance()->pGetTouchInputInfo
+            || !QWindowsApi::instance()->pCloseTouchInputHandle) {
+        return true;
+    }
+
     if (!QWindowsContext::instance()->initTouch()) {
         qWarning("Unable to initialize touch handling.");
         return true;
@@ -584,8 +589,8 @@ bool QWindowsMouseHandler::translateTouchEvent(QWindow *window, HWND,
     touchPoints.reserve(winTouchPointCount);
     QEventPoint::States allStates;
 
-    GetTouchInputInfo(reinterpret_cast<HTOUCHINPUT>(msg.lParam),
-                      UINT(msg.wParam), winTouchInputs.data(), sizeof(TOUCHINPUT));
+    QWindowsApi::instance()->pGetTouchInputInfo(reinterpret_cast<HTOUCHINPUT>(msg.lParam),
+                      UINT(msg.wParam), winTouchInputs.get(), sizeof(TOUCHINPUT));
     for (int i = 0; i < winTouchPointCount; ++i) {
         const TOUCHINPUT &winTouchInput = winTouchInputs[i];
         int id = m_touchInputIDToTouchPointID.value(winTouchInput.dwID, -1);
@@ -626,7 +631,7 @@ bool QWindowsMouseHandler::translateTouchEvent(QWindow *window, HWND,
         touchPoints.append(touchPoint);
     }
 
-    CloseTouchInputHandle(reinterpret_cast<HTOUCHINPUT>(msg.lParam));
+    QWindowsApi::instance()->pCloseTouchInputHandle(reinterpret_cast<HTOUCHINPUT>(msg.lParam));
 
     // all touch points released, forget the ids we've seen, they may not be reused
     if (allStates == QEventPoint::State::Released)
diff --git a/src/plugins/platforms/windows/qwindowsopengltester.cpp b/src/plugins/platforms/windows/qwindowsopengltester.cpp
index 6a790bcc1b..b03bcc1bf5 100644
--- a/src/plugins/platforms/windows/qwindowsopengltester.cpp
+++ b/src/plugins/platforms/windows/qwindowsopengltester.cpp
@@ -65,7 +65,11 @@ private:
 
 QDirect3D9Handle::QDirect3D9Handle()
 {
-    m_direct3D9 = Direct3DCreate9(D3D_SDK_VERSION);
+    static const auto pDirect3DCreate9 =
+        reinterpret_cast<decltype(&::Direct3DCreate9)>(
+            QSystemLibrary::resolve(u"d3d9"_s, "Direct3DCreate9"));
+    if (pDirect3DCreate9)
+        m_direct3D9 = pDirect3DCreate9(D3D_SDK_VERSION);
 }
 
 QDirect3D9Handle::~QDirect3D9Handle()
diff --git a/src/plugins/platforms/windows/qwindowspointerhandler.cpp b/src/plugins/platforms/windows/qwindowspointerhandler.cpp
index 88f02347b3..75226c3810 100644
--- a/src/plugins/platforms/windows/qwindowspointerhandler.cpp
+++ b/src/plugins/platforms/windows/qwindowspointerhandler.cpp
@@ -45,10 +45,13 @@ QWindowsPointerHandler::~QWindowsPointerHandler()
 
 bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, QtWindows::WindowsEventType et, MSG msg, LRESULT *result)
 {
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     *result = 0;
     const quint32 pointerId = GET_POINTERID_WPARAM(msg.wParam);
 
-    if (!GetPointerType(pointerId, &m_pointerType)) {
+    if (!QWindowsApi::instance()->pGetPointerType(pointerId, &m_pointerType)) {
         qWarning() << "GetPointerType() failed:" << qt_error_string();
         return false;
     }
@@ -62,12 +65,12 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
     }
     case QT_PT_TOUCH: {
         quint32 pointerCount = 0;
-        if (!GetPointerFrameTouchInfo(pointerId, &pointerCount, nullptr)) {
+        if (!QWindowsApi::instance()->pGetPointerFrameTouchInfo(pointerId, &pointerCount, nullptr)) {
             qWarning() << "GetPointerFrameTouchInfo() failed:" << qt_error_string();
             return false;
         }
         QVarLengthArray<POINTER_TOUCH_INFO, 10> touchInfo(pointerCount);
-        if (!GetPointerFrameTouchInfo(pointerId, &pointerCount, touchInfo.data())) {
+        if (!QWindowsApi::instance()->pGetPointerFrameTouchInfo(pointerId, &pointerCount, touchInfo.data())) {
             qWarning() << "GetPointerFrameTouchInfo() failed:" << qt_error_string();
             return false;
         }
@@ -80,7 +83,7 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
         // dispatch any skipped frames if event compression is disabled by the app
         if (historyCount > 1 && !QCoreApplication::testAttribute(Qt::AA_CompressHighFrequencyEvents)) {
             touchInfo.resize(pointerCount * historyCount);
-            if (!GetPointerFrameTouchInfoHistory(pointerId,
+            if (!QWindowsApi::instance()->pGetPointerFrameTouchInfoHistory(pointerId,
                                                  &historyCount,
                                                  &pointerCount,
                                                  touchInfo.data())) {
@@ -101,7 +104,7 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
     }
     case QT_PT_PEN: {
         POINTER_PEN_INFO penInfo;
-        if (!GetPointerPenInfo(pointerId, &penInfo)) {
+        if (!QWindowsApi::instance()->pGetPointerPenInfo(pointerId, &penInfo)) {
             qWarning() << "GetPointerPenInfo() failed:" << qt_error_string();
             return false;
         }
@@ -113,7 +116,7 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
                 || !QCoreApplication::testAttribute(Qt::AA_CompressTabletEvents))) {
             QVarLengthArray<POINTER_PEN_INFO, 10> penInfoHistory(historyCount);
 
-            if (!GetPointerPenInfoHistory(pointerId, &historyCount, penInfoHistory.data())) {
+            if (!QWindowsApi::instance()->pGetPointerPenInfoHistory(pointerId, &historyCount, penInfoHistory.data())) {
                 qWarning() << "GetPointerPenInfoHistory() failed:" << qt_error_string();
                 return false;
             }
@@ -419,6 +422,9 @@ bool QWindowsPointerHandler::translateTouchEvent(QWindow *window, HWND hwnd,
 {
     Q_UNUSED(hwnd);
 
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     auto *touchInfo = static_cast<POINTER_TOUCH_INFO *>(vTouchInfo);
 
     if (et & QtWindows::NonClientEventFlag)
@@ -517,7 +523,7 @@ bool QWindowsPointerHandler::translateTouchEvent(QWindow *window, HWND hwnd,
         inputIds.insert(touchPoint.id);
 
         // Avoid getting repeated messages for this frame if there are multiple pointerIds
-        SkipPointerFrameMessages(touchInfo[i].pointerInfo.pointerId);
+        QWindowsApi::instance()->pSkipPointerFrameMessages(touchInfo[i].pointerInfo.pointerId);
     }
 
     // Some devices send touches for each finger in a different message/frame, instead of consolidating
@@ -557,13 +563,16 @@ bool QWindowsPointerHandler::translatePenEvent(QWindow *window, HWND hwnd, QtWin
                                                MSG msg, PVOID vPenInfo)
 {
 #if QT_CONFIG(tabletevent)
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     if (et & QtWindows::NonClientEventFlag)
         return false; // Let DefWindowProc() handle Non Client messages.
 
     auto *penInfo = static_cast<POINTER_PEN_INFO *>(vPenInfo);
 
     RECT pRect, dRect;
-    if (!GetPointerDeviceRects(penInfo->pointerInfo.sourceDevice, &pRect, &dRect))
+    if (!QWindowsApi::instance()->pGetPointerDeviceRects(penInfo->pointerInfo.sourceDevice, &pRect, &dRect))
         return false;
 
     const auto systemId = (qint64)penInfo->pointerInfo.sourceDevice;
diff --git a/src/plugins/platforms/windows/qwindowsscreen.cpp b/src/plugins/platforms/windows/qwindowsscreen.cpp
index 2168e00605..a808288f87 100644
--- a/src/plugins/platforms/windows/qwindowsscreen.cpp
+++ b/src/plugins/platforms/windows/qwindowsscreen.cpp
@@ -35,22 +35,14 @@ QT_BEGIN_NAMESPACE
 
 using namespace Qt::StringLiterals;
 
-static inline QDpi deviceDPI(HDC hdc)
-{
-    return QDpi(GetDeviceCaps(hdc, LOGPIXELSX), GetDeviceCaps(hdc, LOGPIXELSY));
-}
-
-static inline QDpi monitorDPI(HMONITOR hMonitor)
-{
-    UINT dpiX;
-    UINT dpiY;
-    if (SUCCEEDED(GetDpiForMonitor(hMonitor, MDT_EFFECTIVE_DPI, &dpiX, &dpiY)))
-        return QDpi(dpiX, dpiY);
-    return {0, 0};
-}
-
 static std::vector<DISPLAYCONFIG_PATH_INFO> getPathInfo(const MONITORINFOEX &viewInfo)
 {
+    if (!QWindowsApi::instance()->pGetDisplayConfigBufferSizes
+            || !QWindowsApi::instance()->pQueryDisplayConfig
+            || !QWindowsApi::instance()->pDisplayConfigGetDeviceInfo) {
+        return {};
+    }
+
     // We might want to consider storing adapterId/id from DISPLAYCONFIG_PATH_TARGET_INFO.
     std::vector<DISPLAYCONFIG_PATH_INFO> pathInfos;
     std::vector<DISPLAYCONFIG_MODE_INFO> modeInfos;
@@ -63,13 +55,13 @@ static std::vector<DISPLAYCONFIG_PATH_INFO> getPathInfo(const MONITORINFOEX &vie
         // QueryDisplayConfig documentation doesn't say the number of needed elements is updated
         // when the call fails with ERROR_INSUFFICIENT_BUFFER, so we need a separate call to
         // look up the needed buffer sizes.
-        if (GetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &numPathArrayElements,
+        if (QWindowsApi::instance()->pGetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &numPathArrayElements,
                                         &numModeInfoArrayElements) != ERROR_SUCCESS) {
             return {};
         }
         pathInfos.resize(numPathArrayElements);
         modeInfos.resize(numModeInfoArrayElements);
-        result = QueryDisplayConfig(QDC_ONLY_ACTIVE_PATHS, &numPathArrayElements, pathInfos.data(),
+        result = QWindowsApi::instance()->pQueryDisplayConfig(QDC_ONLY_ACTIVE_PATHS, &numPathArrayElements, pathInfos.data(),
                                     &numModeInfoArrayElements, modeInfos.data(), nullptr);
     } while (result == ERROR_INSUFFICIENT_BUFFER);
 
@@ -84,7 +76,7 @@ static std::vector<DISPLAYCONFIG_PATH_INFO> getPathInfo(const MONITORINFOEX &vie
                 deviceName.header.size = sizeof(DISPLAYCONFIG_SOURCE_DEVICE_NAME);
                 deviceName.header.adapterId = path.sourceInfo.adapterId;
                 deviceName.header.id = path.sourceInfo.id;
-                if (DisplayConfigGetDeviceInfo(&deviceName.header) == ERROR_SUCCESS) {
+                if (QWindowsApi::instance()->pDisplayConfigGetDeviceInfo(&deviceName.header) == ERROR_SUCCESS) {
                     return wcscmp(viewInfo.szDevice, deviceName.viewGdiDeviceName) != 0;
                 }
                 return true;
@@ -99,8 +91,9 @@ static std::vector<DISPLAYCONFIG_PATH_INFO> getPathInfo(const MONITORINFOEX &vie
 // Needed later for HDR support
 static float getMonitorSDRWhiteLevel(DISPLAYCONFIG_PATH_TARGET_INFO *targetInfo)
 {
-    const float defaultSdrWhiteLevel = 200.0;
-    if (!targetInfo)
+    static constexpr const float defaultSdrWhiteLevel = 200.0;
+
+    if (!QWindowsApi::instance()->pDisplayConfigGetDeviceInfo || !targetInfo)
         return defaultSdrWhiteLevel;
 
     DISPLAYCONFIG_SDR_WHITE_LEVEL whiteLevel = {};
@@ -108,7 +101,7 @@ static float getMonitorSDRWhiteLevel(DISPLAYCONFIG_PATH_TARGET_INFO *targetInfo)
     whiteLevel.header.size = sizeof(DISPLAYCONFIG_SDR_WHITE_LEVEL);
     whiteLevel.header.adapterId = targetInfo->adapterId;
     whiteLevel.header.id = targetInfo->id;
-    if (DisplayConfigGetDeviceInfo(&whiteLevel.header) != ERROR_SUCCESS)
+    if (QWindowsApi::instance()->pDisplayConfigGetDeviceInfo(&whiteLevel.header) != ERROR_SUCCESS)
         return defaultSdrWhiteLevel;
     return whiteLevel.SDRWhiteLevel * 80.0 / 1000.0;
 }
@@ -130,7 +123,7 @@ using RegistryHandlePtr = std::unique_ptr<std::remove_pointer_t<HKEY>, RegistryH
 static void setMonitorDataFromSetupApi(QWindowsScreenData &data,
                                        const std::vector<DISPLAYCONFIG_PATH_INFO> &pathGroup)
 {
-    if (pathGroup.empty()) {
+    if (pathGroup.empty() || !QWindowsApi::instance()->pDisplayConfigGetDeviceInfo) {
         return;
     }
 
@@ -142,7 +135,7 @@ static void setMonitorDataFromSetupApi(QWindowsScreenData &data,
         // The first element in the clone group is the main monitor.
         deviceName.header.adapterId = pathGroup[0].targetInfo.adapterId;
         deviceName.header.id = pathGroup[0].targetInfo.id;
-        if (DisplayConfigGetDeviceInfo(&deviceName.header) == ERROR_SUCCESS) {
+        if (QWindowsApi::instance()->pDisplayConfigGetDeviceInfo(&deviceName.header) == ERROR_SUCCESS) {
             data.devicePath = QString::fromWCharArray(deviceName.monitorDevicePath);
         } else {
             qCWarning(lcQpaScreen)
@@ -163,7 +156,7 @@ static void setMonitorDataFromSetupApi(QWindowsScreenData &data,
         deviceName.header.size = sizeof(DISPLAYCONFIG_TARGET_DEVICE_NAME);
         deviceName.header.adapterId = path.targetInfo.adapterId;
         deviceName.header.id = path.targetInfo.id;
-        if (DisplayConfigGetDeviceInfo(&deviceName.header) != ERROR_SUCCESS) {
+        if (QWindowsApi::instance()->pDisplayConfigGetDeviceInfo(&deviceName.header) != ERROR_SUCCESS) {
             qCWarning(lcQpaScreen)
                     << u"Unable to get device information for %1:"_s.arg(path.targetInfo.id)
                     << QSystemError::windowsString();
@@ -275,8 +268,8 @@ static bool monitorData(HMONITOR hMonitor, QWindowsScreenData *data)
         data->flags |= QWindowsScreenData::LockScreen;
     } else {
         if (const HDC hdc = CreateDC(info.szDevice, nullptr, nullptr, nullptr)) {
-            const QDpi dpi = monitorDPI(hMonitor);
-            data->dpi = dpi.first > 0 ? dpi : deviceDPI(hdc);
+            const UINT dpi = QWindowsContext::getMostPossibleDpiForMonitor(hMonitor);
+            data->dpi = QDpi(dpi, dpi);
             data->depth = GetDeviceCaps(hdc, BITSPIXEL);
             data->format = data->depth == 16 ? QImage::Format_RGB16 : QImage::Format_RGB32;
             data->physicalSizeMM = QSizeF(GetDeviceCaps(hdc, HORZSIZE), GetDeviceCaps(hdc, VERTSIZE));
@@ -563,7 +556,8 @@ QRect QWindowsScreen::virtualGeometry(const QPlatformScreen *screen) // cf QScre
 
 bool QWindowsScreen::setOrientationPreference(Qt::ScreenOrientation o)
 {
-    bool result = false;
+    if (!QWindowsApi::instance()->pSetDisplayAutoRotationPreferences)
+        return false;
     ORIENTATION_PREFERENCE orientationPreference = ORIENTATION_PREFERENCE_NONE;
     switch (o) {
     case Qt::PrimaryOrientation:
@@ -581,33 +575,29 @@ bool QWindowsScreen::setOrientationPreference(Qt::ScreenOrientation o)
         orientationPreference = ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED;
         break;
     }
-    result = SetDisplayAutoRotationPreferences(orientationPreference);
-    return result;
+    return QWindowsApi::instance()->pSetDisplayAutoRotationPreferences(orientationPreference);
 }
 
 Qt::ScreenOrientation QWindowsScreen::orientationPreference()
 {
-    Qt::ScreenOrientation result = Qt::PrimaryOrientation;
+    if (!QWindowsApi::instance()->pGetDisplayAutoRotationPreferences)
+        return Qt::PrimaryOrientation;
     ORIENTATION_PREFERENCE orientationPreference = ORIENTATION_PREFERENCE_NONE;
-    if (GetDisplayAutoRotationPreferences(&orientationPreference)) {
+    if (QWindowsApi::instance()->pGetDisplayAutoRotationPreferences(&orientationPreference)) {
         switch (orientationPreference) {
         case ORIENTATION_PREFERENCE_NONE:
-            break;
+            return Qt::PrimaryOrientation;
         case ORIENTATION_PREFERENCE_LANDSCAPE:
-            result = Qt::LandscapeOrientation;
-            break;
+            return Qt::LandscapeOrientation;
         case ORIENTATION_PREFERENCE_PORTRAIT:
-            result = Qt::PortraitOrientation;
-            break;
+            return Qt::PortraitOrientation;
         case ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED:
-            result = Qt::InvertedLandscapeOrientation;
-            break;
+            return Qt::InvertedLandscapeOrientation;
         case ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED:
-            result = Qt::InvertedPortraitOrientation;
-            break;
+            return Qt::InvertedPortraitOrientation;
         }
     }
-    return result;
+    return Qt::PrimaryOrientation;
 }
 
 /*!
diff --git a/src/plugins/platforms/windows/qwindowssystemtrayicon.cpp b/src/plugins/platforms/windows/qwindowssystemtrayicon.cpp
index 3bad237f9e..7a9b2c5b07 100644
--- a/src/plugins/platforms/windows/qwindowssystemtrayicon.cpp
+++ b/src/plugins/platforms/windows/qwindowssystemtrayicon.cpp
@@ -184,13 +184,16 @@ void QWindowsSystemTrayIcon::updateToolTip(const QString &tooltip)
 
 QRect QWindowsSystemTrayIcon::geometry() const
 {
+    if (!QWindowsApi::instance()->pShell_NotifyIconGetRect)
+        return {};
     NOTIFYICONIDENTIFIER nid;
     memset(&nid, 0, sizeof(nid));
     nid.cbSize = sizeof(nid);
     nid.hWnd = m_hwnd;
     nid.uID = q_uNOTIFYICONID;
     RECT rect;
-    const QRect result = SUCCEEDED(Shell_NotifyIconGetRect(&nid, &rect))
+    const QRect result =
+        SUCCEEDED(QWindowsApi::instance()->pShell_NotifyIconGetRect(&nid, &rect))
         ? QRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top)
         : QRect();
     qCDebug(lcQpaTrayIcon) << __FUNCTION__ << this << "returns" << result;
@@ -272,7 +275,8 @@ bool QWindowsSystemTrayIcon::ensureInstalled()
     if (!MYWM_TASKBARCREATED)
         MYWM_TASKBARCREATED = RegisterWindowMessage(L"TaskbarCreated");
     // Allow the WM_TASKBARCREATED message through the UIPI filter
-    ChangeWindowMessageFilterEx(m_hwnd, MYWM_TASKBARCREATED, MSGFLT_ALLOW, nullptr);
+    if (QWindowsApi::instance()->pChangeWindowMessageFilterEx)
+        QWindowsApi::instance()->pChangeWindowMessageFilterEx(m_hwnd, MYWM_TASKBARCREATED, MSGFLT_ALLOW, nullptr);
     qCDebug(lcQpaTrayIcon) << __FUNCTION__ << this << "MYWM_TASKBARCREATED=" << MYWM_TASKBARCREATED;
 
     QWindowsHwndSystemTrayIconEntry entry{m_hwnd, this};
diff --git a/src/plugins/platforms/windows/qwindowstheme.cpp b/src/plugins/platforms/windows/qwindowstheme.cpp
index 6fba9e55c1..64b38c594a 100644
--- a/src/plugins/platforms/windows/qwindowstheme.cpp
+++ b/src/plugins/platforms/windows/qwindowstheme.cpp
@@ -39,6 +39,7 @@
 #include <private/qsystemlibrary_p.h>
 #include <private/qwinregistry_p.h>
 #include <QtCore/private/qfunctions_win_p.h>
+#include <QtCore/qoperatingsystemversion.h>
 
 #include <algorithm>
 
@@ -232,11 +233,12 @@ void QWindowsTheme::populateLightSystemBasePalette(QPalette &result)
     QColor accent = getSysColor(COLOR_HIGHLIGHT);
 
 #if QT_CONFIG(cpp_winrt)
-    // respect the Windows 11 accent color
-    using namespace winrt::Windows::UI::ViewManagement;
-    const auto settings = UISettings();
-
-    accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+    if (QOperatingSystemVersion::isWin10RS5OrGreater()) {
+        // respect the Windows 11 accent color
+        using namespace winrt::Windows::UI::ViewManagement;
+        const auto settings = UISettings();
+        accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+    }
 #endif
 
     const QColor btnFace = background;
@@ -271,41 +273,62 @@ void QWindowsTheme::populateLightSystemBasePalette(QPalette &result)
 
 static void populateDarkSystemBasePalette(QPalette &result)
 {
+    QColor foreground;
+    QColor background;
+    QColor accent;
+    QColor accentDark;
+    QColor accentDarker;
+    QColor accentDarkest;
+    QColor accentLight;
+    QColor accentLighter;
+    QColor accentLightest;
+    QColor linkColor;
+
+    bool colorSet = false;
+
 #if QT_CONFIG(cpp_winrt)
-    using namespace winrt::Windows::UI::ViewManagement;
-    const auto settings = UISettings();
-
-    // We have to craft a palette from these colors. The settings.UIElementColor(UIElementType) API
-    // returns the old system colors, not the dark mode colors. If the background is black (which it
-    // usually), then override it with a dark gray instead so that we can go up and down the lightness.
-    const QColor foreground = getSysColor(settings.GetColorValue(UIColorType::Foreground));
-    const QColor background = [&settings]() -> QColor {
-        auto systemBackground = getSysColor(settings.GetColorValue(UIColorType::Background));
-        if (systemBackground == Qt::black)
-            systemBackground = QColor(0x1E, 0x1E, 0x1E);
-        return systemBackground;
-    }();
-
-    const QColor accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
-    const QColor accentDark = getSysColor(settings.GetColorValue(UIColorType::AccentDark1));
-    const QColor accentDarker = getSysColor(settings.GetColorValue(UIColorType::AccentDark2));
-    const QColor accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
-    const QColor accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
-    const QColor accentLighter = getSysColor(settings.GetColorValue(UIColorType::AccentLight2));
-    const QColor accentLightest = getSysColor(settings.GetColorValue(UIColorType::AccentLight3));
-    const QColor linkColor = accent;
-#else
-    const QColor foreground = Qt::white;
-    const QColor background = QColor(0x1E, 0x1E, 0x1E);
-    const QColor accent = QColor(0x00, 0x55, 0xff);
-    const QColor accentDark = accent.darker(120);
-    const QColor accentDarker = accentDark.darker(120);
-    const QColor accentDarkest = accentDarker.darker(120);
-    const QColor accentLight = accent.lighter(120);
-    const QColor accentLighter = accentLight.lighter(120);
-    const QColor accentLightest = accentLighter.lighter(120);
-    const QColor linkColor = Qt::blue;
+    if (QOperatingSystemVersion::isWin10RS5OrGreater()) {
+        using namespace winrt::Windows::UI::ViewManagement;
+        const auto settings = UISettings();
+
+        // We have to craft a palette from these colors. The settings.UIElementColor(UIElementType) API
+        // returns the old system colors, not the dark mode colors. If the background is black (which it
+        // usually), then override it with a dark gray instead so that we can go up and down the lightness.
+        foreground = getSysColor(settings.GetColorValue(UIColorType::Foreground));
+        background = [&settings]() -> QColor {
+            auto systemBackground = getSysColor(settings.GetColorValue(UIColorType::Background));
+            if (systemBackground == Qt::black)
+                systemBackground = QColor(0x1E, 0x1E, 0x1E);
+            return systemBackground;
+        }();
+
+        accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+        accentDark = getSysColor(settings.GetColorValue(UIColorType::AccentDark1));
+        accentDarker = getSysColor(settings.GetColorValue(UIColorType::AccentDark2));
+        accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
+        accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
+        accentLighter = getSysColor(settings.GetColorValue(UIColorType::AccentLight2));
+        accentLightest = getSysColor(settings.GetColorValue(UIColorType::AccentLight3));
+        linkColor = accent;
+
+        colorSet = true;
+    }
 #endif
+
+    if (!colorSet) {
+        foreground = Qt::white;
+        background = QColor(0x1E, 0x1E, 0x1E);
+        accent = QColor(0x00, 0x55, 0xff);
+        accentDark = accent.darker(120);
+        accentDarker = accentDark.darker(120);
+        accentDarkest = accentDarker.darker(120);
+        accentLight = accent.lighter(120);
+        accentLighter = accentLight.lighter(120);
+        accentLightest = accentLighter.lighter(120);
+        linkColor = Qt::blue;
+        colorSet = true;
+    }
+
     const QColor buttonColor = background.lighter(200);
 
     result.setColor(QPalette::All, QPalette::WindowText, foreground);
@@ -561,25 +584,31 @@ void QWindowsTheme::refreshPalettes()
     m_palettes[MenuPalette] = new QPalette(menuPalette(*m_palettes[SystemPalette], light));
     m_palettes[MenuBarPalette] = menuBarPalette(*m_palettes[MenuPalette], light);
     if (!light) {
+        bool colorSet = false;
 #if QT_CONFIG(cpp_winrt)
-        using namespace winrt::Windows::UI::ViewManagement;
-        const auto settings = UISettings();
-        const QColor accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
-        const QColor accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
-        const QColor accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
-        m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Base, accent);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Button, accentLight);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Inactive, QPalette::Base, accentDarkest);
-#else
-        m_palettes[ButtonPalette] = new QPalette(*m_palettes[SystemPalette]);
-        m_palettes[ButtonPalette]->setColor(QPalette::Button, QColor(0x666666u));
-        const QColor checkBoxBlue(0x0078d7u);
-        m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Base, checkBoxBlue);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Button, checkBoxBlue);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::ButtonText, Qt::white);
+        if (QOperatingSystemVersion::isWin10RS5OrGreater()) {
+            using namespace winrt::Windows::UI::ViewManagement;
+            const auto settings = UISettings();
+            const QColor accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+            const QColor accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
+            const QColor accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
+            m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Base, accent);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Button, accentLight);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Inactive, QPalette::Base, accentDarkest);
+            colorSet = true;
+        }
 #endif
+        if (!colorSet) {
+            m_palettes[ButtonPalette] = new QPalette(*m_palettes[SystemPalette]);
+            m_palettes[ButtonPalette]->setColor(QPalette::Button, QColor(0x666666u));
+            const QColor checkBoxBlue(0x0078d7u);
+            m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Base, checkBoxBlue);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Button, checkBoxBlue);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::ButtonText, Qt::white);
+            colorSet = true;
+        }
         m_palettes[RadioButtonPalette] = new QPalette(*m_palettes[CheckBoxPalette]);
     }
 }
@@ -637,7 +666,10 @@ void QWindowsTheme::refreshFonts()
     fixedFont.setStyleHint(QFont::TypeWriter);
 
     LOGFONT lfIconTitleFont;
-    SystemParametersInfoForDpi(SPI_GETICONTITLELOGFONT, sizeof(lfIconTitleFont), &lfIconTitleFont, 0, dpi);
+    if (QWindowsApi::instance()->pSystemParametersInfoForDpi)
+        QWindowsApi::instance()->pSystemParametersInfoForDpi(SPI_GETICONTITLELOGFONT, sizeof(lfIconTitleFont), &lfIconTitleFont, 0, dpi);
+    else
+        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lfIconTitleFont), &lfIconTitleFont, 0);
     const QFont iconTitleFont = QWindowsFontDatabase::LOGFONT_to_QFont(lfIconTitleFont, dpi);
 
     m_fonts[SystemFont] = new QFont(QWindowsFontDatabase::systemDefaultFont());
@@ -1070,7 +1102,7 @@ bool QWindowsTheme::useNativeMenus()
 
 bool QWindowsTheme::queryDarkMode()
 {
-    if (queryHighContrast()) {
+    if (!QOperatingSystemVersion::isWin10RS5OrGreater() || queryHighContrast()) {
         return false;
     }
     const auto setting = QWinRegistryKey(HKEY_CURRENT_USER, LR"(Software\Microsoft\Windows\CurrentVersion\Themes\Personalize)")
diff --git a/src/plugins/platforms/windows/qwindowswindow.cpp b/src/plugins/platforms/windows/qwindowswindow.cpp
index 2c8d2d7be8..d4e0c71c15 100644
--- a/src/plugins/platforms/windows/qwindowswindow.cpp
+++ b/src/plugins/platforms/windows/qwindowswindow.cpp
@@ -22,6 +22,7 @@
 #  include "qwindowscursor.h"
 #endif
 
+#include <QtCore/qoperatingsystemversion.h>
 #include <QtGui/qguiapplication.h>
 #include <QtGui/qscreen.h>
 #include <QtGui/qwindow.h>
@@ -52,6 +53,36 @@ enum {
     defaultWindowHeight = 160
 };
 
+struct QtDwmApis
+{
+    decltype(&::DwmIsCompositionEnabled) pDwmIsCompositionEnabled = nullptr;
+    decltype(&::DwmEnableBlurBehindWindow) pDwmEnableBlurBehindWindow = nullptr;
+    decltype(&::DwmGetWindowAttribute) pDwmGetWindowAttribute = nullptr;
+    decltype(&::DwmSetWindowAttribute) pDwmSetWindowAttribute = nullptr;
+
+    explicit QtDwmApis()
+    {
+        QSystemLibrary dwmapi(u"dwmapi"_s);
+        pDwmIsCompositionEnabled = reinterpret_cast<decltype(pDwmIsCompositionEnabled)>(dwmapi.resolve("DwmIsCompositionEnabled"));
+        pDwmEnableBlurBehindWindow = reinterpret_cast<decltype(pDwmEnableBlurBehindWindow)>(dwmapi.resolve("DwmEnableBlurBehindWindow"));
+        pDwmGetWindowAttribute = reinterpret_cast<decltype(pDwmGetWindowAttribute)>(dwmapi.resolve("DwmGetWindowAttribute"));
+        pDwmSetWindowAttribute = reinterpret_cast<decltype(pDwmSetWindowAttribute)>(dwmapi.resolve("DwmSetWindowAttribute"));
+    }
+
+    ~QtDwmApis() = default;
+
+    [[nodiscard]] static QtDwmApis *instance()
+    {
+        static QtDwmApis inst;
+        return &inst;
+    }
+
+    [[nodiscard]] bool isDwmAvailable() const
+    {
+        return pDwmIsCompositionEnabled && pDwmEnableBlurBehindWindow && pDwmGetWindowAttribute && pDwmSetWindowAttribute;
+    }
+};
+
 Q_GUI_EXPORT HICON qt_pixmapToWinHICON(const QPixmap &);
 
 static QByteArray debugWinStyle(DWORD style)
@@ -441,15 +472,34 @@ static inline bool windowIsAccelerated(const QWindow *w)
     }
 }
 
-static bool applyBlurBehindWindow(HWND hwnd)
+static inline bool dwmIsCompositionEnabled()
 {
+    // DWM composition is always enabled and can't be disabled since Win8.
+    if (QOperatingSystemVersion::isWin8OrGreater())
+        return true;
+    if (!QtDwmApis::instance()->isDwmAvailable())
+        return false;
+    BOOL enabled = FALSE;
+    return SUCCEEDED(QtDwmApis::instance()->pDwmIsCompositionEnabled(&enabled)) && enabled != FALSE;
+}
+
+static inline bool applyBlurBehindWindow(HWND hwnd)
+{
+    if (!QtDwmApis::instance()->isDwmAvailable())
+        return false;
+
     DWM_BLURBEHIND blurBehind = {0, 0, nullptr, 0};
 
-    blurBehind.dwFlags = DWM_BB_ENABLE | DWM_BB_BLURREGION;
-    blurBehind.fEnable = TRUE;
-    blurBehind.hRgnBlur = CreateRectRgn(0, 0, -1, -1);
+    if (dwmIsCompositionEnabled()) {
+        blurBehind.dwFlags = DWM_BB_ENABLE | DWM_BB_BLURREGION;
+        blurBehind.fEnable = TRUE;
+        blurBehind.hRgnBlur = CreateRectRgn(0, 0, -1, -1);
+    } else {
+        blurBehind.dwFlags = DWM_BB_ENABLE;
+        blurBehind.fEnable = FALSE;
+    }
 
-    const bool result = DwmEnableBlurBehindWindow(hwnd, &blurBehind) == S_OK;
+    const bool result = QtDwmApis::instance()->pDwmEnableBlurBehindWindow(hwnd, &blurBehind) == S_OK;
 
     if (blurBehind.hRgnBlur)
         DeleteObject(blurBehind.hRgnBlur);
@@ -514,15 +564,6 @@ static inline void updateGLWindowSettings(const QWindow *w, HWND hwnd, Qt::Windo
     setWindowOpacity(hwnd, flags, hasAlpha, isAccelerated, opacity);
 }
 
-[[nodiscard]] static inline int getResizeBorderThickness(const UINT dpi)
-{
-    // The width of the padded border will always be 0 if DWM composition is
-    // disabled, but since it will always be enabled and can't be programtically
-    // disabled from Windows 8, we are safe to go.
-    return GetSystemMetricsForDpi(SM_CXSIZEFRAME, dpi)
-           + GetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi);
-}
-
 /*!
     Calculates the dimensions of the invisible borders within the
     window frames which only exist on Windows 10 and onwards.
@@ -530,22 +571,21 @@ static inline void updateGLWindowSettings(const QWindow *w, HWND hwnd, Qt::Windo
 
 static QMargins invisibleMargins(QPoint screenPoint)
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return QMargins();
     POINT pt = {screenPoint.x(), screenPoint.y()};
     if (HMONITOR hMonitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONULL)) {
-        UINT dpiX;
-        UINT dpiY;
-        if (SUCCEEDED(GetDpiForMonitor(hMonitor, MDT_EFFECTIVE_DPI, &dpiX, &dpiY))) {
-            const int gap = getResizeBorderThickness(dpiX);
-            return QMargins(gap, 0, gap, gap);
-        }
+        const int gap = QWindowsContext::getResizeBorderThickness(hMonitor);
+        return QMargins(gap, 0, gap, gap);
     }
     return QMargins();
 }
 
 [[nodiscard]] static inline QMargins invisibleMargins(const HWND hwnd)
 {
-    const UINT dpi = GetDpiForWindow(hwnd);
-    const int gap = getResizeBorderThickness(dpi);
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return QMargins();
+    const int gap = QWindowsContext::getResizeBorderThickness(hwnd);
     return QMargins(gap, 0, gap, gap);
 }
 
@@ -785,10 +825,8 @@ void WindowCreationData::fromWindow(const QWindow *w, const Qt::WindowFlags flag
     } else if (topLevel) {
         if (flags & Qt::FramelessWindowHint)
             style = WS_POPUP;                // no border
-        else if (flags & Qt::WindowTitleHint)
-            style = WS_OVERLAPPED;
         else
-            style = 0;
+            style = WS_OVERLAPPED;
     } else {
         style = WS_CHILD;
     }
@@ -805,7 +843,6 @@ void WindowCreationData::fromWindow(const QWindow *w, const Qt::WindowFlags flag
     if (topLevel) {
         if ((type == Qt::Window || dialog || tool)) {
             if (!(flags & Qt::FramelessWindowHint)) {
-                style |= WS_POPUP;
                 if (flags & Qt::MSWindowsFixedSizeDialogHint) {
                     style |= WS_DLGFRAME;
                 } else {
@@ -833,13 +870,17 @@ void WindowCreationData::fromWindow(const QWindow *w, const Qt::WindowFlags flag
             if ((flags & Qt::WindowContextHelpButtonHint) && !showMinimizeButton
                 && !showMaximizeButton)
                 exStyle |= WS_EX_CONTEXTHELP;
+            if (qEnvironmentVariableIntValue("QT_QPA_WINDOWS_DISABLE_BITMAP_REDIRECTION")
+                    && QOperatingSystemVersion::isWin8OrGreater()) {
+                exStyle |= WS_EX_NOREDIRECTIONBITMAP;
+            }
         } else {
              exStyle |= WS_EX_TOOLWINDOW;
         }
 
         // make mouse events fall through this window
         // NOTE: WS_EX_TRANSPARENT flag can make mouse inputs fall through a layered window
-        if (flagsIn & Qt::WindowTransparentForInput)
+        if (flags & Qt::WindowTransparentForInput)
             exStyle |= WS_EX_LAYERED | WS_EX_TRANSPARENT;
     }
 }
@@ -1052,9 +1093,12 @@ QMargins QWindowsGeometryHint::frame(const QWindow *w, DWORD style, DWORD exStyl
 {
     if (!w->isTopLevel() || w->flags().testFlag(Qt::FramelessWindowHint))
         return {};
+    if (!QWindowsApi::instance()->pAdjustWindowRectExForDpi)
+        return frameOnPrimaryScreen(w, style, exStyle);
     RECT rect = {0,0,0,0};
     style &= ~DWORD(WS_OVERLAPPED); // Not permitted, see docs.
-    if (AdjustWindowRectExForDpi(&rect, style, FALSE, exStyle, unsigned(qRound(dpi))) == FALSE) {
+    if (QWindowsApi::instance()->pAdjustWindowRectExForDpi(
+            &rect, style, FALSE, exStyle, unsigned(qRound(dpi))) == FALSE) {
         qErrnoWarning("%s: AdjustWindowRectExForDpi failed", __FUNCTION__);
     }
     const QMargins result(qAbs(rect.left), qAbs(rect.top),
@@ -1094,7 +1138,8 @@ QMargins QWindowsGeometryHint::frame(const QWindow *w, const QRect &geometry,
 {
     if (!w->isTopLevel() || w->flags().testFlag(Qt::FramelessWindowHint))
         return {};
-    if (QWindowsScreenManager::isSingleScreen()
+    if (!QWindowsApi::instance()->pAdjustWindowRectExForDpi
+        || QWindowsScreenManager::isSingleScreen()
         || !QWindowsContext::shouldHaveNonClientDpiScaling(w)) {
         return frameOnPrimaryScreen(w, style, exStyle);
     }
@@ -1249,10 +1294,12 @@ QMargins QWindowsBaseWindow::frameMargins_sys() const
 std::optional<QWindowsBaseWindow::TouchWindowTouchTypes>
     QWindowsBaseWindow::touchWindowTouchTypes_sys() const
 {
+    if (!QWindowsApi::instance()->pIsTouchWindow)
+        return std::nullopt;
     ULONG touchFlags = 0;
-    if (IsTouchWindow(handle(), &touchFlags) == FALSE)
-        return {};
-    TouchWindowTouchTypes result;
+    if (QWindowsApi::instance()->pIsTouchWindow(handle(), &touchFlags) == FALSE)
+        return std::nullopt;
+    TouchWindowTouchTypes result = {};
     if ((touchFlags & TWF_FINETOUCH) != 0)
         result.setFlag(TouchWindowTouchType::FineTouch);
     if ((touchFlags & TWF_WANTPALM) != 0)
@@ -1520,8 +1567,8 @@ QWindowsWindow::QWindowsWindow(QWindow *aWindow, const QWindowsWindowData &data)
 QWindowsWindow::~QWindowsWindow()
 {
     setFlag(WithinDestroy);
-    if (testFlag(TouchRegistered))
-        UnregisterTouchWindow(m_data.hwnd);
+    if (testFlag(TouchRegistered) && QWindowsApi::instance()->pUnregisterTouchWindow)
+        QWindowsApi::instance()->pUnregisterTouchWindow(m_data.hwnd);
     destroyWindow();
     destroyIcon();
 }
@@ -1548,7 +1595,7 @@ void QWindowsWindow::initialize()
             QWindowSystemInterface::handleGeometryChange<QWindowSystemInterface::SynchronousDelivery>(w, obtainedGeometry);
         }
     }
-    QWindowsWindow::setSavedDpi(GetDpiForWindow(handle()));
+    QWindowsWindow::setSavedDpi(QWindowsContext::getMostPossibleDpiForWindow(handle()));
 }
 
 QSurfaceFormat QWindowsWindow::format() const
@@ -2040,7 +2087,7 @@ void QWindowsWindow::handleDpiChanged(HWND hwnd, WPARAM wParam, LPARAM lParam)
 
 void QWindowsWindow::handleDpiChangedAfterParent(HWND hwnd)
 {
-    const UINT dpi = GetDpiForWindow(hwnd);
+    const UINT dpi = QWindowsContext::getMostPossibleDpiForWindow(hwnd);
     const qreal scale = dpiRelativeScale(dpi);
     setSavedDpi(dpi);
 
@@ -2382,13 +2429,22 @@ bool QWindowsWindow::handleWmPaint(HWND hwnd, UINT message,
         return false;
     PAINTSTRUCT ps;
 
-    // GL software rendering (QTBUG-58178) with some AMD cards
+    // GL software rendering (QTBUG-58178) and Windows 7/Aero off with some AMD cards
     // (QTBUG-60527) need InvalidateRect() to suppress artifacts while resizing.
-    if (testFlag(OpenGLSurface) && isSoftwareGl())
+    if (testFlag(OpenGLSurface) && (isSoftwareGl() || !dwmIsCompositionEnabled()))
         InvalidateRect(hwnd, nullptr, false);
 
     BeginPaint(hwnd, &ps);
 
+    // Observed painting problems with Aero style disabled (QTBUG-7865).
+    if (Q_UNLIKELY(!dwmIsCompositionEnabled())
+        && ((testFlag(OpenGLSurface) && testFlag(OpenGLDoubleBuffered))
+            || testFlag(VulkanSurface)
+            || testFlag(Direct3DSurface)))
+    {
+        SelectClipRgn(ps.hdc, nullptr);
+    }
+
     // If the a window is obscured by another window (such as a child window)
     // we still need to send isExposed=true, for compatibility.
     // Our tests depend on it.
@@ -3011,7 +3067,7 @@ bool QWindowsWindow::handleNonClientHitTest(const QPoint &globalPos, LRESULT *re
             return true;
         }
         if (localPos.y() < 0) {
-            const int topResizeBarPos = invisibleMargins(m_data.hwnd).left() - frameMargins().top();
+            const int topResizeBarPos = QWindowsContext::getResizeBorderThickness(m_data.hwnd) - frameMargins().top();
             if (localPos.y() < topResizeBarPos) {
                 *result = HTCAPTION; // Extend caption over top resize bar, let's user move the window.
                 return true;
@@ -3201,10 +3257,12 @@ enum : WORD {
 
 static bool queryDarkBorder(HWND hwnd)
 {
+    if (!QtDwmApis::instance()->isDwmAvailable())
+        return false;
     BOOL result = FALSE;
     const bool ok =
-        SUCCEEDED(DwmGetWindowAttribute(hwnd, DwmwaUseImmersiveDarkMode, &result, sizeof(result)))
-        || SUCCEEDED(DwmGetWindowAttribute(hwnd, DwmwaUseImmersiveDarkModeBefore20h1, &result, sizeof(result)));
+        SUCCEEDED(QtDwmApis::instance()->pDwmGetWindowAttribute(hwnd, DwmwaUseImmersiveDarkMode, &result, sizeof(result)))
+        || SUCCEEDED(QtDwmApis::instance()->pDwmGetWindowAttribute(hwnd, DwmwaUseImmersiveDarkModeBefore20h1, &result, sizeof(result)));
     if (!ok)
         qCWarning(lcQpaWindow, "%s: Unable to retrieve dark window border setting.", __FUNCTION__);
     return result == TRUE;
@@ -3212,10 +3270,12 @@ static bool queryDarkBorder(HWND hwnd)
 
 bool QWindowsWindow::setDarkBorderToWindow(HWND hwnd, bool d)
 {
+    if (!QtDwmApis::instance()->isDwmAvailable())
+        return false;
     const BOOL darkBorder = d ? TRUE : FALSE;
     const bool ok =
-        SUCCEEDED(DwmSetWindowAttribute(hwnd, DwmwaUseImmersiveDarkMode, &darkBorder, sizeof(darkBorder)))
-        || SUCCEEDED(DwmSetWindowAttribute(hwnd, DwmwaUseImmersiveDarkModeBefore20h1, &darkBorder, sizeof(darkBorder)));
+        SUCCEEDED(QtDwmApis::instance()->pDwmSetWindowAttribute(hwnd, DwmwaUseImmersiveDarkMode, &darkBorder, sizeof(darkBorder)))
+        || SUCCEEDED(QtDwmApis::instance()->pDwmSetWindowAttribute(hwnd, DwmwaUseImmersiveDarkModeBefore20h1, &darkBorder, sizeof(darkBorder)));
     if (!ok)
         qCWarning(lcQpaWindow, "%s: Unable to set %s window border.", __FUNCTION__, d ? "dark" : "light");
     return ok;
@@ -3336,6 +3396,9 @@ void QWindowsWindow::registerTouchWindow()
     if ((QWindowsContext::instance()->systemInfo() & QWindowsContext::SI_SupportsTouch) == 0)
         return;
 
+    if (!QWindowsApi::instance()->pRegisterTouchWindow)
+        return;
+
     // Initially register or re-register to change the flags
     const auto touchTypes = QWindowsIntegration::instance()->touchWindowTouchType();
     if (testFlag(TouchRegistered)) {
@@ -3349,7 +3412,7 @@ void QWindowsWindow::registerTouchWindow()
         touchFlags |= TWF_FINETOUCH;
     if (touchTypes.testFlag(TouchWindowTouchType::WantPalmTouch))
         touchFlags |= TWF_WANTPALM;
-    if (RegisterTouchWindow(m_data.hwnd, touchFlags))
+    if (QWindowsApi::instance()->pRegisterTouchWindow(m_data.hwnd, touchFlags))
         setFlag(TouchRegistered);
     else
         qErrnoWarning("RegisterTouchWindow() failed for window '%s'.", qPrintable(window()->objectName()));
diff --git a/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp b/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp
index 1438ded5ce..7e70c2c456 100644
--- a/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp
+++ b/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp
@@ -3982,6 +3982,21 @@ void QWindowsVistaStyle::drawComplexControl(ComplexControl control, const QStyle
                     theme.partId = flags & State_Horizontal ? SBP_THUMBBTNHORZ : SBP_THUMBBTNVERT;
                     theme.stateId = stateId;
                     d->drawBackground(theme);
+
+                    if (!QOperatingSystemVersion::isWin8OrGreater()) {
+                        const QRect gripperBounds = QWindowsVistaStylePrivate::scrollBarGripperBounds(flags, widget, &theme);
+                        // Draw gripper if there is enough space
+                        if (!gripperBounds.isEmpty() && flags & State_Enabled) {
+                            painter->save();
+                            QWindowsThemeData grippBackground = theme;
+                            grippBackground.partId = flags & State_Horizontal ? SBP_LOWERTRACKHORZ : SBP_LOWERTRACKVERT;
+                            theme.rect = gripperBounds;
+                            painter->setClipRegion(d->region(theme));// Only change inside the region of the gripper
+                            d->drawBackground(grippBackground);// The gutter is the grippers background
+                            d->drawBackground(theme);          // Transparent gripper ontop of background
+                            painter->restore();
+                        }
+                    }
                 }
             }
         }
@@ -5072,4 +5087,20 @@ QIcon QWindowsVistaStyle::standardIcon(StandardPixmap standardIcon,
     return QWindowsStyle::standardIcon(standardIcon, option, widget);
 }
 
+QRect QWindowsVistaStylePrivate::scrollBarGripperBounds(QStyle::State flags, const QWidget *widget, QWindowsThemeData *theme)
+{
+    const bool horizontal = flags & QStyle::State_Horizontal;
+    const qreal factor = QWindowsStylePrivate::nativeMetricScaleFactor(widget);
+    const QMargins contentsMargin =
+        (theme->margins(theme->rect, TMT_SIZINGMARGINS) * factor).toMargins();
+    theme->partId = horizontal ? SBP_GRIPPERHORZ : SBP_GRIPPERVERT;
+    const QSize size = (theme->size() * factor).toSize();
+
+    const int hSpace = theme->rect.width() - size.width();
+    const int vSpace = theme->rect.height() - size.height();
+    const bool sufficientSpace = (horizontal && hSpace > (contentsMargin.left() + contentsMargin.right()))
+        || vSpace > contentsMargin.top() + contentsMargin.bottom();
+    return sufficientSpace ? QRect(theme->rect.topLeft() + QPoint(hSpace, vSpace) / 2, size) : QRect();
+}
+
 QT_END_NAMESPACE
diff --git a/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h b/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h
index e8364678e0..669acbe976 100644
--- a/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h
+++ b/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h
@@ -121,6 +121,7 @@ public:
     static int pixelMetricFromSystemDp(QStyle::PixelMetric pm, const QStyleOption *option = nullptr, const QWidget *widget = nullptr);
     static int fixedPixelMetric(QStyle::PixelMetric pm);
     static bool isLineEditBaseColorSet(const QStyleOption *option, const QWidget *widget);
+    static QRect scrollBarGripperBounds(QStyle::State flags, const QWidget *widget, QWindowsThemeData *theme);
     static HWND winId(const QWidget *widget);
     static bool useVista(bool update = false);
     static QBackingStore *backingStoreForWidget(const QWidget *widget);
diff --git a/src/tools/rcc/CMakeLists.txt b/src/tools/rcc/CMakeLists.txt
index 55d4de2e28..581d2c3810 100644
--- a/src/tools/rcc/CMakeLists.txt
+++ b/src/tools/rcc/CMakeLists.txt
@@ -5,6 +5,9 @@
 ## rcc Tool:
 #####################################################################
 
+qt_find_package(WrapZLIB PROVIDED_TARGETS WrapZLIB::WrapZLIB)
+qt_find_package(WrapZSTD PROVIDED_TARGETS WrapZSTD::WrapZSTD)
+
 qt_get_tool_target_name(target_name rcc)
 qt_internal_add_tool(${target_name}
     TRY_RUN
@@ -14,6 +17,9 @@ qt_internal_add_tool(${target_name}
     SOURCES
         main.cpp
         rcc.cpp rcc.h
+    LIBRARIES
+        WrapZLIB::WrapZLIB
+        WrapZSTD::WrapZSTD
     DEFINES
         QT_NO_CAST_FROM_ASCII
         QT_NO_FOREACH
@@ -26,7 +32,12 @@ qt_internal_return_unless_building_tools()
 ## Scopes:
 #####################################################################
 
-qt_internal_extend_target(${target_name} CONDITION QT_FEATURE_zstd
+qt_internal_extend_target(${target_name} CONDITION NOT QT_FEATURE_system_zlib
     LIBRARIES
-        WrapZSTD::WrapZSTD
+        ZlibPrivate
+)
+
+qt_internal_extend_target(${target_name} CONDITION NOT QT_FEATURE_system_zstd
+    LIBRARIES
+        ZstdPrivate
 )
diff --git a/src/tools/rcc/main.cpp b/src/tools/rcc/main.cpp
index 2751bc39d6..ac0258fc1e 100644
--- a/src/tools/rcc/main.cpp
+++ b/src/tools/rcc/main.cpp
@@ -34,9 +34,7 @@ void dumpRecursive(const QDir &dir, QTextStream &out)
         if (entry.isDir()) {
             dumpRecursive(entry.filePath(), out);
         } else {
-            out << "<file>"_L1
-                << entry.filePath()
-                << "</file>\n"_L1;
+            out << "  <file>"_L1 << entry.filePath() << "</file>\n"_L1;
         }
     }
 }
@@ -64,7 +62,8 @@ int createProject(const QString &outFileName)
     }
 
     QTextStream out(&file);
-    out << "<!DOCTYPE RCC><RCC version=\"1.0\">\n"
+    out << "<!DOCTYPE RCC>\n"
+           "<RCC version=\"1.0\">\n"
            "<qresource>\n"_L1;
 
     // use "." as dir to get relative file paths
@@ -136,12 +135,8 @@ int runRcc(int argc, char *argv[])
     QCommandLineOption rootOption(QStringLiteral("root"), QStringLiteral("Prefix resource access path with root path."), QStringLiteral("path"));
     parser.addOption(rootOption);
 
-#if QT_CONFIG(zstd) && !defined(QT_NO_COMPRESS)
+#if !defined(QT_NO_COMPRESS)
 #  define ALGOS     "[zstd], zlib, none"
-#elif QT_CONFIG(zstd)
-#  define ALGOS     "[zstd], none"
-#elif !defined(QT_NO_COMPRESS)
-#  define ALGOS     "[zlib], none"
 #else
 #  define ALGOS     "[none]"
 #endif
diff --git a/src/tools/rcc/rcc.cpp b/src/tools/rcc/rcc.cpp
index a87f15de33..60387ceee5 100644
--- a/src/tools/rcc/rcc.cpp
+++ b/src/tools/rcc/rcc.cpp
@@ -17,9 +17,7 @@
 
 #include <algorithm>
 
-#if QT_CONFIG(zstd)
-#  include <zstd.h>
-#endif
+#include <zstd.h>
 
 // Note: A copy of this file is used in Qt Designer (qttools/src/designer/src/lib/shared/rcc.cpp)
 
@@ -236,10 +234,10 @@ qint64 RCCFileInfo::writeDataBlob(RCCResourceLibrary &lib, qint64 offset,
 
     // Check if compression is useful for this file
     if (data.size() != 0) {
-#if QT_CONFIG(zstd)
+#ifndef QT_NO_COMPRESS
         if (m_compressAlgo == RCCResourceLibrary::CompressionAlgorithm::Best && !m_noZstd) {
             m_compressAlgo = RCCResourceLibrary::CompressionAlgorithm::Zstd;
-            m_compressLevel = 19;   // not ZSTD_maxCLevel(), as 20+ are experimental
+            m_compressLevel = ZSTD_maxCLevel();
         }
         if (m_compressAlgo == RCCResourceLibrary::CompressionAlgorithm::Zstd && !m_noZstd) {
             if (lib.m_zstdCCtx == nullptr)
@@ -283,12 +281,6 @@ qint64 RCCFileInfo::writeDataBlob(RCCResourceLibrary &lib, qint64 offset,
                 lib.m_errorDevice->write(msg.toUtf8());
             }
         }
-#endif
-#ifndef QT_NO_COMPRESS
-        if (m_compressAlgo == RCCResourceLibrary::CompressionAlgorithm::Best) {
-            m_compressAlgo = RCCResourceLibrary::CompressionAlgorithm::Zlib;
-            m_compressLevel = 9;
-        }
         if (m_compressAlgo == RCCResourceLibrary::CompressionAlgorithm::Zlib) {
             QByteArray compressed =
                     qCompress(reinterpret_cast<uchar *>(data.data()), data.size(), m_compressLevel);
@@ -444,17 +436,13 @@ RCCResourceLibrary::RCCResourceLibrary(quint8 formatVersion)
     m_noZstd(false)
 {
     m_out.reserve(30 * 1000 * 1000);
-#if QT_CONFIG(zstd)
     m_zstdCCtx = nullptr;
-#endif
 }
 
 RCCResourceLibrary::~RCCResourceLibrary()
 {
     delete m_root;
-#if QT_CONFIG(zstd)
     ZSTD_freeCCtx(m_zstdCCtx);
-#endif
 }
 
 enum RCCXmlTag {
@@ -845,10 +833,10 @@ RCCResourceLibrary::CompressionAlgorithm RCCResourceLibrary::parseCompressionAlg
         return CompressionAlgorithm::Zlib;
 #endif
     } else if (value == "zstd"_L1) {
-#if QT_CONFIG(zstd)
-        return CompressionAlgorithm::Zstd;
-#else
+#ifdef QT_NO_COMPRESS
         *errorMsg = "Zstandard support not compiled in"_L1;
+#else
+        return CompressionAlgorithm::Zstd;
 #endif
     } else if (value != "none"_L1) {
         *errorMsg = QString::fromLatin1("Unknown compression algorithm '%1'").arg(value);
@@ -871,10 +859,8 @@ int RCCResourceLibrary::parseCompressionLevel(CompressionAlgorithm algo, const Q
                 return c;
             break;
         case CompressionAlgorithm::Zstd:
-#if QT_CONFIG(zstd)
             if (c >= 0 && c <= ZSTD_maxCLevel())
                 return c;
-#endif
             break;
         }
     }
@@ -1097,7 +1083,7 @@ bool RCCResourceLibrary::writeDataBlobs()
     Q_ASSERT(m_errorDevice);
     switch (m_format) {
     case C_Code:
-        writeString("static const unsigned char qt_resource_data[] = {\n");
+        writeString("static constexpr const unsigned char qt_resource_data[] = {\n");
         break;
     case Python_Code:
         writeString("qt_resource_data = b\"\\\n");
@@ -1141,7 +1127,7 @@ bool RCCResourceLibrary::writeDataBlobs()
     case Pass1:
         if (offset < 8)
             offset = 8;
-        writeString("\nstatic const unsigned char qt_resource_data[");
+        writeString("\nstatic constexpr const unsigned char qt_resource_data[");
         writeByteArray(QByteArray::number(offset));
         writeString("] = { 'Q', 'R', 'C', '_', 'D', 'A', 'T', 'A' };\n\n");
         break;
@@ -1156,7 +1142,7 @@ bool RCCResourceLibrary::writeDataNames()
     switch (m_format) {
     case C_Code:
     case Pass1:
-        writeString("static const unsigned char qt_resource_name[] = {\n");
+        writeString("static constexpr const unsigned char qt_resource_name[] = {\n");
         break;
     case Python_Code:
         writeString("qt_resource_name = b\"\\\n");
@@ -1218,7 +1204,7 @@ bool RCCResourceLibrary::writeDataStructure()
     switch (m_format) {
     case C_Code:
     case Pass1:
-        writeString("static const unsigned char qt_resource_struct[] = {\n");
+        writeString("static constexpr const unsigned char qt_resource_struct[] = {\n");
         break;
     case Python_Code:
         writeString("qt_resource_struct = b\"\\\n");
diff --git a/src/tools/rcc/rcc.h b/src/tools/rcc/rcc.h
index fe0e0989df..7b56c18497 100644
--- a/src/tools/rcc/rcc.h
+++ b/src/tools/rcc/rcc.h
@@ -123,9 +123,7 @@ private:
     void write(const char *, int len);
     void writeString(const char *s) { write(s, static_cast<int>(strlen(s))); }
 
-#if QT_CONFIG(zstd)
     ZSTD_CCtx *m_zstdCCtx;
-#endif
 
     const Strings m_strings;
     RCCFileInfo *m_root;
diff --git a/src/widgets/CMakeLists.txt b/src/widgets/CMakeLists.txt
index aaa81286ab..6b38174a40 100644
--- a/src/widgets/CMakeLists.txt
+++ b/src/widgets/CMakeLists.txt
@@ -322,7 +322,6 @@ qt_internal_extend_target(Widgets CONDITION MACOS
 
 qt_internal_extend_target(Widgets CONDITION WIN32
     LIBRARIES
-        dwmapi
         shell32
         uxtheme
 )
diff --git a/src/widgets/dialogs/qwizard_win.cpp b/src/widgets/dialogs/qwizard_win.cpp
index e95f0e3b7b..6cc6bb821a 100644
--- a/src/widgets/dialogs/qwizard_win.cpp
+++ b/src/widgets/dialogs/qwizard_win.cpp
@@ -16,6 +16,7 @@
 #include <QtCore/QOperatingSystemVersion>
 #include <QtCore/QVariant>
 #include <QtCore/QDebug>
+#include <QtCore/private/qsystemlibrary_p.h>
 #include <QtGui/QMouseEvent>
 #include <QtGui/QWindow>
 #include <QtGui/private/qhighdpiscaling_p.h>
@@ -33,6 +34,36 @@ Q_DECLARE_METATYPE(QMargins)
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
+struct DwmApis
+{
+    decltype(&::DwmIsCompositionEnabled) pDwmIsCompositionEnabled = nullptr;
+    decltype(&::DwmExtendFrameIntoClientArea) pDwmExtendFrameIntoClientArea = nullptr;
+    decltype(&::DwmDefWindowProc) pDwmDefWindowProc = nullptr;
+
+    explicit DwmApis()
+    {
+        QSystemLibrary dwmapi(u"dwmapi"_s);
+        pDwmIsCompositionEnabled = reinterpret_cast<decltype(pDwmIsCompositionEnabled)>(dwmapi.resolve("DwmIsCompositionEnabled"));
+        pDwmExtendFrameIntoClientArea = reinterpret_cast<decltype(pDwmExtendFrameIntoClientArea)>(dwmapi.resolve("DwmExtendFrameIntoClientArea"));
+        pDwmDefWindowProc = reinterpret_cast<decltype(pDwmDefWindowProc)>(dwmapi.resolve("DwmDefWindowProc"));
+    }
+
+    ~DwmApis() = default;
+
+    [[nodiscard]] bool isDwmAvailable() const
+    {
+        return pDwmIsCompositionEnabled && pDwmExtendFrameIntoClientArea && pDwmDefWindowProc;
+    }
+
+    [[nodiscard]] static DwmApis *instance()
+    {
+        static DwmApis inst;
+        return &inst;
+    }
+};
+
 int QVistaHelper::instanceCount = 0;
 int QVistaHelper::m_devicePixelRatio = 1;
 QVistaHelper::VistaState QVistaHelper::cachedVistaState = QVistaHelper::Dirty;
@@ -152,7 +183,13 @@ void QVistaHelper::updateCustomMargins(bool vistaMargins)
 
 bool QVistaHelper::isCompositionEnabled()
 {
-    return true;
+    // DWM composition is always enabled and can't be disabled since Win8.
+    if (QOperatingSystemVersion::isWin8OrGreater())
+        return true;
+    if (!DwmApis::instance()->isDwmAvailable())
+        return false;
+    BOOL enabled = FALSE;
+    return SUCCEEDED(DwmApis::instance()->pDwmIsCompositionEnabled(&enabled)) && enabled != FALSE;
 }
 
 bool QVistaHelper::isThemeActive()
@@ -188,6 +225,8 @@ QColor QVistaHelper::basicWindowFrameColor()
 
 bool QVistaHelper::setDWMTitleBar(TitleBarChangeType type)
 {
+    if (!DwmApis::instance()->isDwmAvailable())
+        return false;
     bool value = false;
     if (vistaState() == VistaAero) {
         MARGINS mar = {0, 0, 0, 0};
@@ -196,7 +235,7 @@ bool QVistaHelper::setDWMTitleBar(TitleBarChangeType type)
         else
             mar.cyTopHeight = (titleBarSize() + topOffset(wizard)) * QVistaHelper::m_devicePixelRatio;
         if (const HWND wizardHandle = wizardHWND())
-            if (SUCCEEDED(DwmExtendFrameIntoClientArea(wizardHandle, &mar)))
+            if (SUCCEEDED(DwmApis::instance()->pDwmExtendFrameIntoClientArea(wizardHandle, &mar)))
                 value = true;
     }
     return value;
@@ -307,7 +346,9 @@ bool QVistaHelper::winEvent(MSG* msg, qintptr *result)
     case WM_NCHITTEST: {
         LRESULT lResult;
         // Perform hit testing using DWM
-        if (DwmDefWindowProc(msg->hwnd, msg->message, msg->wParam, msg->lParam, &lResult)) {
+        if (DwmApis::instance()->isDwmAvailable() &&
+                DwmApis::instance()->pDwmDefWindowProc(
+                    msg->hwnd, msg->message, msg->wParam, msg->lParam, &lResult)) {
             // DWM returned a hit, no further processing necessary
             *result = lResult;
         } else {
@@ -326,7 +367,9 @@ bool QVistaHelper::winEvent(MSG* msg, qintptr *result)
     default:
         LRESULT lResult;
         // Pass to DWM to handle
-        if (DwmDefWindowProc(msg->hwnd, msg->message, msg->wParam, msg->lParam, &lResult))
+        if (DwmApis::instance()->isDwmAvailable() &&
+                DwmApis::instance()->pDwmDefWindowProc(
+                    msg->hwnd, msg->message, msg->wParam, msg->lParam, &lResult))
             *result = lResult;
         // If the message wasn't handled by DWM, continue processing it as normal
         else
@@ -663,7 +706,9 @@ int QVistaHelper::topOffset(const QPaintDevice *device)
 {
     if (vistaState() != VistaAero)
         return titleBarSize() + 3;
-    static const int aeroOffset = QStyleHelper::dpiScaled(13, device);
+    static const int aeroOffset =
+        QOperatingSystemVersion::isWin8OrGreater() ?
+        QStyleHelper::dpiScaled(13, device) : QStyleHelper::dpiScaled(4, device);
     return aeroOffset + titleBarSize();
 }
 
diff --git a/src/widgets/kernel/qwidget.cpp b/src/widgets/kernel/qwidget.cpp
index 2a116e8490..fb0a3bb42e 100644
--- a/src/widgets/kernel/qwidget.cpp
+++ b/src/widgets/kernel/qwidget.cpp
@@ -5134,6 +5134,17 @@ void QWidget::render(QPainter *painter, const QPoint &targetOffset,
         return; // Fully transparent.
 
     Q_D(QWidget);
+
+    // Patch: save and restore dirtyOpaqueChildren field.
+    //
+    // Just like in QWidget::grab() this field should be restored
+    // after the d->render() call, because it will be set to 1 and
+    // opaqueChildren field will be filled with empty region in
+    // case the widget is hidden (because all the opaque children
+    // will be skipped in isVisible() check).
+    //
+    const bool oldDirtyOpaqueChildren = d->dirtyOpaqueChildren;
+
     const bool inRenderWithPainter = d->extra && d->extra->inRenderWithPainter;
     const QRegion toBePainted = !inRenderWithPainter ? d->prepareToRender(sourceRegion, renderFlags)
                                                      : sourceRegion;
@@ -5155,6 +5166,10 @@ void QWidget::render(QPainter *painter, const QPoint &targetOffset,
     if (!inRenderWithPainter && (opacity < 1.0 || (target->devType() == QInternal::Printer))) {
         d->render_helper(painter, targetOffset, toBePainted, renderFlags);
         d->extra->inRenderWithPainter = inRenderWithPainter;
+
+        // Patch: save and restore dirtyOpaqueChildren field.
+        d->dirtyOpaqueChildren = oldDirtyOpaqueChildren;
+
         return;
     }
 
@@ -5187,6 +5202,9 @@ void QWidget::render(QPainter *painter, const QPoint &targetOffset,
     d->setSharedPainter(oldPainter);
 
     d->extra->inRenderWithPainter = inRenderWithPainter;
+
+    // Patch: save and restore dirtyOpaqueChildren field.
+    d->dirtyOpaqueChildren = oldDirtyOpaqueChildren;
 }
 
 static void sendResizeEvents(QWidget *target)
-- 
2.41.0.windows.2

