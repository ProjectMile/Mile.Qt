From 4bc4e1c0f82bc9d831ae3e0f45f584ca867da1ac Mon Sep 17 00:00:00 2001
From: Yuhang Zhao <2546789017@qq.com>
Date: Fri, 17 Jun 2022 20:33:03 +0800
Subject: [PATCH] wangwenx190: Custom tweaks

Important changes list:

01. Win32: Remove WS_POPUP for most cases.
02. Win32: Remove UI Automation wrapper layer.
03. Win32: Disable the Direct2D QPA, it's useless and has bad performance.
04. Disable the offscreen QPA, it's useless.
05. Disable the minimal QPA, it's useless.
06. Win32: Add more entries to QOperatingSystemVersion.
07. Win32: Add environment variable to add offset to the system menu.
08. Win32: Add environment variable to disable bitmap redirection.
09. Win32: Restore Windows 7 compatibility (QtMutex & QtRhi & QPA).
10. MSVC: Add support for VC-LTL.
11. Other minor tweaks.

Signed-off-by: Yuhang Zhao <2546789017@qq.com>
---
 cmake/QtBaseGlobalTargets.cmake               |   1 +
 cmake/QtBuild.cmake                           |   7 +
 cmake/QtCompilerOptimization.cmake            |  15 +-
 cmake/QtInternalTargets.cmake                 |  37 +-
 cmake/VC-LTL.cmake                            |  94 ++++
 configure.cmake                               |   5 +
 qt_cmdline.cmake                              |   1 +
 .../VulkanMemoryAllocator/vk_mem_alloc.h      |  30 +-
 src/corelib/CMakeLists.txt                    |   2 +
 src/corelib/global/qlibraryinfo.cpp           |  20 +-
 src/corelib/global/qlibraryinfo.h             |   5 +
 .../global/qoperatingsystemversion.cpp        |  10 +
 src/corelib/global/qoperatingsystemversion.h  |  40 ++
 .../global/qoperatingsystemversion_win.cpp    |  20 +-
 src/corelib/global/qsysinfo.cpp               |  34 +-
 src/corelib/io/qlockfile_win.cpp              |  14 +-
 src/corelib/kernel/qcoreapplication.cpp       |  11 +
 src/corelib/kernel/qeventdispatcher_win.cpp   |  12 +-
 src/corelib/kernel/qfunctions_win.cpp         |  10 +-
 src/corelib/plugin/qsystemlibrary.cpp         |  39 +-
 src/corelib/text/qlocale_win.cpp              |  23 +-
 src/corelib/thread/qfutex_p.h                 |  76 ++-
 src/corelib/thread/qlocking_p.h               |   7 +-
 src/corelib/thread/qmutex.cpp                 |   2 +
 src/corelib/thread/qmutex_p.h                 |   9 +-
 src/corelib/thread/qmutex_win.cpp             |  30 +
 src/corelib/thread/qwaitcondition_p.h         |   7 +-
 src/gui/CMakeLists.txt                        |  16 -
 .../windows/apisupport/qwindowsuiawrapper.cpp |  89 ---
 .../windows/apisupport/qwindowsuiawrapper_p.h |  67 ---
 .../windows/apisupport/uiaattributeids_p.h    |  63 ---
 .../apisupport/uiaclientinterfaces_p.h        | 230 --------
 .../windows/apisupport/uiacontroltypeids_p.h  |  60 --
 .../windows/apisupport/uiaerrorids_p.h        |  26 -
 .../windows/apisupport/uiaeventids_p.h        |  54 --
 .../windows/apisupport/uiageneralids_p.h      |  21 -
 .../windows/apisupport/uiapatternids_p.h      |  53 --
 .../windows/apisupport/uiapropertyids_p.h     | 188 -------
 .../apisupport/uiaserverinterfaces_p.h        | 367 ------------
 .../windows/apisupport/uiatypes_p.h           | 157 ------
 src/gui/configure.cmake                       |  10 +-
 src/gui/opengl/qopengl.cpp                    |  32 +-
 src/gui/rhi/qrhid3d11.cpp                     | 525 +++++++++++-------
 src/gui/rhi/qrhid3d11_p_p.h                   |   3 +-
 .../qwindowsdirectwritefontdatabase.cpp       |   6 +-
 src/gui/text/windows/qwindowsfontdatabase.cpp |   3 +-
 .../text/windows/qwindowsfontdatabasebase.cpp |   9 +-
 .../windows/qwindowsfontenginedirectwrite.cpp |   9 +-
 .../qnetworklistmanagerevents.cpp             |  54 +-
 src/plugins/platforms/CMakeLists.txt          |   9 -
 src/plugins/platforms/windows/CMakeLists.txt  |   2 +
 .../platforms/windows/qwin10helpers.cpp       |  43 +-
 .../platforms/windows/qwindowsapplication.cpp |  12 +-
 .../platforms/windows/qwindowscontext.cpp     | 202 ++++++-
 .../platforms/windows/qwindowscontext.h       | 131 ++++-
 .../platforms/windows/qwindowsdrag.cpp        |   7 +-
 .../platforms/windows/qwindowsintegration.cpp |  29 +-
 .../platforms/windows/qwindowskeymapper.cpp   |  18 +-
 .../windows/qwindowsmousehandler.cpp          |  11 +-
 .../windows/qwindowsopengltester.cpp          |   6 +-
 .../windows/qwindowspointerhandler.cpp        |  25 +-
 .../platforms/windows/qwindowsscreen.cpp      |  71 ++-
 .../windows/qwindowssystemtrayicon.cpp        |   8 +-
 .../platforms/windows/qwindowstheme.cpp       | 135 +++--
 .../platforms/windows/qwindowswindow.cpp      | 101 ++--
 .../uiautomation/qwindowsuiaaccessibility.cpp |   9 +-
 .../uiautomation/qwindowsuiabaseprovider.h    |   4 +-
 .../uiautomation/qwindowsuiamainprovider.cpp  |  53 +-
 .../windows/uiautomation/qwindowsuiautils.h   |   2 +-
 .../windowsvista/qwindowsvistastyle.cpp       |  31 ++
 .../windowsvista/qwindowsvistastyle_p_p.h     |   1 +
 src/tools/rcc/main.cpp                        |   7 +-
 src/tools/rcc/rcc.cpp                         |   8 +-
 src/widgets/dialogs/qwizard_win.cpp           |   9 +-
 74 files changed, 1589 insertions(+), 1948 deletions(-)
 create mode 100644 cmake/VC-LTL.cmake
 create mode 100644 src/corelib/thread/qmutex_win.cpp
 delete mode 100644 src/gui/accessible/windows/apisupport/qwindowsuiawrapper.cpp
 delete mode 100644 src/gui/accessible/windows/apisupport/qwindowsuiawrapper_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiaattributeids_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiaclientinterfaces_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiacontroltypeids_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiaerrorids_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiaeventids_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiageneralids_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiapatternids_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiapropertyids_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiaserverinterfaces_p.h
 delete mode 100644 src/gui/accessible/windows/apisupport/uiatypes_p.h

diff --git a/cmake/QtBaseGlobalTargets.cmake b/cmake/QtBaseGlobalTargets.cmake
index ac3b63a874..ac79b3db05 100644
--- a/cmake/QtBaseGlobalTargets.cmake
+++ b/cmake/QtBaseGlobalTargets.cmake
@@ -286,6 +286,7 @@ qt_copy_or_install(FILES
                    cmake/QtWasmHelpers.cmake
                    cmake/QtWrapperScriptHelpers.cmake
                    cmake/QtWriteArgsFile.cmake
+                   cmake/VC-LTL.cmake
                    cmake/modulecppexports.h.in
                    cmake/modulecppexports_p.h.in
                    cmake/qbatchedtestrunner.in.cpp
diff --git a/cmake/QtBuild.cmake b/cmake/QtBuild.cmake
index 7f87cf71b1..840ae858b9 100644
--- a/cmake/QtBuild.cmake
+++ b/cmake/QtBuild.cmake
@@ -573,3 +573,10 @@ _qt_internal_generate_tool_command_wrapper()
 if(CMAKE_VERSION VERSION_LESS "3.19.0")
     variable_watch(CMAKE_CURRENT_LIST_DIR qt_watch_current_list_dir)
 endif()
+
+if(MSVC)
+    include(VC-LTL)
+    if("x${SupportLTL}" STREQUAL "xtrue")
+        set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>" CACHE STRING "" FORCE)
+    endif()
+endif()
diff --git a/cmake/QtCompilerOptimization.cmake b/cmake/QtCompilerOptimization.cmake
index b5b49ab78a..2a756b229b 100644
--- a/cmake/QtCompilerOptimization.cmake
+++ b/cmake/QtCompilerOptimization.cmake
@@ -92,10 +92,15 @@ endif()
 
 # Windows MSVC
 if(MSVC)
-    set(QT_CFLAGS_OPTIMIZE "-O2")
-    set(QT_CFLAGS_OPTIMIZE_DEBUG "-Od")
-    set(QT_CFLAGS_OPTIMIZE_SIZE "-O1")
-    set(QT_CFLAGS_OPTIMIZE_VALID_VALUES "/O2" "/O1" "/Od" "/Ob0" "/Ob1" "/Ob2" "/O0" "-O0")
+    set(QT_CFLAGS_OPTIMIZE "-O2 -Oi -Oy -Ot")
+    if(MSVC_VERSION GREATER_EQUAL 1920) # Visual Studio 2019 version 16.0
+        string(APPEND QT_CFLAGS_OPTIMIZE " -Ob3 ")
+    else()
+        string(APPEND QT_CFLAGS_OPTIMIZE " -Ob2 ")
+    endif()
+    set(QT_CFLAGS_OPTIMIZE_DEBUG "-Od -Ob0")
+    set(QT_CFLAGS_OPTIMIZE_SIZE "-O1 -Ob2 -Oi- -Os")
+    set(QT_CFLAGS_OPTIMIZE_VALID_VALUES "/O2" "/O1" "/Od" "/Ob0" "/Ob1" "/Ob2" "/Ob3" "/O0" "-O0")
 
     if(CLANG)
         set(QT_CFLAGS_OPTIMIZE_FULL "/clang:-O3")
@@ -124,5 +129,5 @@ endif()
 # Emscripten Clang
 if(WASM)
     set(QT_CFLAGS_OPTIMIZE_DEBUG "-O2 -g") # -Og is not supported
-    set(QT_CFLAGS_SSE2 -O2 -msimd128 -msse -msse2)
+    set(QT_CFLAGS_SSE2 "-O2 -msimd128 -msse -msse2")
 endif()
diff --git a/cmake/QtInternalTargets.cmake b/cmake/QtInternalTargets.cmake
index dc45b57eec..80dd598b4c 100644
--- a/cmake/QtInternalTargets.cmake
+++ b/cmake/QtInternalTargets.cmake
@@ -253,6 +253,11 @@ if (MSVC)
             #-Zc:preprocessor # breaks build due to bug in default Windows SDK 10.0.19041
         )
     endif()
+    if (MSVC_VERSION GREATER_EQUAL 1925 AND NOT CLANG) # Visual Studio 2019 version 16.5
+        target_compile_options(PlatformCommonInternal INTERFACE
+            $<$<NOT:$<CONFIG:Debug>>:-QIntel-jcc-erratum>
+        )
+    endif()
 
     target_compile_options(PlatformCommonInternal INTERFACE
         -Zc:wchar_t
@@ -260,13 +265,19 @@ if (MSVC)
     )
 
     target_compile_options(PlatformCommonInternal INTERFACE
-        $<$<NOT:$<CONFIG:Debug>>:-guard:cf -Gw>
+        $<$<NOT:$<CONFIG:Debug>>:-fp:fast -guard:cf -GF -GT -Gw -Gy> # -GA for executables.
     )
 
     target_link_options(PlatformCommonInternal INTERFACE
         -DYNAMICBASE -NXCOMPAT -LARGEADDRESSAWARE
-        $<$<NOT:$<CONFIG:Debug>>:-OPT:REF -OPT:ICF -GUARD:CF>
+        $<$<NOT:$<CONFIG:Debug>>:-OPT:REF -OPT:ICF -OPT:LBR -GUARD:CF>
     )
+
+    if(TEST_architecture_arch STREQUAL "x86_64")
+        target_link_options(PlatformCommonInternal INTERFACE
+            -HIGHENTROPYVA
+        )
+    endif()
 endif()
 
 if(MINGW)
@@ -279,9 +290,11 @@ endif()
 
 if(QT_FEATURE_intelcet)
     if(MSVC)
-        target_link_options(PlatformCommonInternal INTERFACE
-            -CETCOMPAT
-        )
+        if(MSVC_VERSION GREATER_EQUAL 1920) # Visual Studio 2019 version 16.0
+            target_link_options(PlatformCommonInternal INTERFACE
+                -CETCOMPAT
+            )
+        endif()
     else()
         target_compile_options(PlatformCommonInternal INTERFACE
             -fcf-protection=full
@@ -289,6 +302,20 @@ if(QT_FEATURE_intelcet)
     endif()
 endif()
 
+if(QT_FEATURE_spectre)
+    if(MSVC)
+        if(MSVC_VERSION GREATER_EQUAL 1925) # Visual Studio 2019 version 16.5
+            target_compile_options(PlatformCommonInternal INTERFACE
+                -Qspectre-load
+            )
+        elseif(MSVC_VERSION GREATER_EQUAL 1912) # Visual Studio 2017 version 15.5
+            target_compile_options(PlatformCommonInternal INTERFACE
+                -Qspectre
+            )
+        endif()
+    endif()
+endif()
+
 if(QT_FEATURE_force_asserts)
     target_compile_definitions(PlatformCommonInternal INTERFACE QT_FORCE_ASSERTS)
 endif()
diff --git a/cmake/VC-LTL.cmake b/cmake/VC-LTL.cmake
new file mode 100644
index 0000000000..2bab2f21d6
--- /dev/null
+++ b/cmake/VC-LTL.cmake
@@ -0,0 +1,94 @@
+﻿# https://github.com/Chuyu-Team/VC-LTL5
+
+#
+#  VC-LTL自动化加载配置，建议你将此文件单独复制到你的工程再使用，该文件能自动识别当前环境是否存在VC-LTL，并且自动应用。
+#
+#  使用方法：
+#    1. 在“CMakeLists.txt” 添加 “include("VC-LTL helper for cmake.cmake")”。
+#
+#  VC-LTL默认搜索顺序
+#    1. “VC-LTL helper for cmake.cmake”所在根目录，即 ${CMAKE_CURRENT_LIST_DIR}
+#    2. 当前CMake根目录，即 ${CMAKE_CURRENT_SOURCE_DIR}/VC-LTL
+#    3. 当前项目根目录，即 ${PROJECT_SOURCE_DIR}/VC-LTL
+#    4. 当前CMake父目录，即 ${CMAKE_CURRENT_SOURCE_DIR}/../VC-LTL
+#    5. 当前项目根目录，即 ${PROJECT_SOURCE_DIR}/../VC-LTL
+#    6. 注册表HKEY_CURRENT_USER\Code\VC-LTL@Root
+#
+#  把VC-LTL放在其中一个位置即可，VC-LTL就能被自动引用。
+#
+#  如果你对默认搜索顺序不满，你可以修改此文件。你也可以直接指定${VC_LTL_Root}宏更加任性的去加载VC-LTL。
+#
+
+if(NOT MSVC OR DEFINED __VC_LTL_CMAKE_INCLUDE_GUARD)
+    return()
+endif()
+set(__VC_LTL_CMAKE_INCLUDE_GUARD 1)
+
+#####################################################################VC-LTL设置#####################################################################
+
+#控制TargetPlatform版本，目前可用版本为5.1.2600.0     6.0.6000.0（默认）    6.2.9200.0     10.0.10240.0    10.0.19041.0
+if(NOT DEFINED WindowsTargetPlatformMinVersion)
+    set(WindowsTargetPlatformMinVersion "10.0.19041.0" CACHE STRING "" FORCE)
+endif()
+
+#启用干净的导入表，消除 ucrt apiset(如：api-ms-win-crt-time-l1-1-0.dll)，满足强迫症患者。
+if(NOT DEFINED CleanImport)
+    set(CleanImport "true" CACHE STRING "" FORCE)
+endif()
+
+####################################################################################################################################################
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${CMAKE_CURRENT_LIST_DIR}/_msvcrt.h)
+		set(VC_LTL_Root ${CMAKE_CURRENT_LIST_DIR})
+	endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/VC-LTL/_msvcrt.h)
+		set(VC_LTL_Root ${CMAKE_CURRENT_SOURCE_DIR}/VC-LTL)
+	endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${PROJECT_SOURCE_DIR}/VC-LTL/_msvcrt.h)
+        set(VC_LTL_Root ${PROJECT_SOURCE_DIR}/VC-LTL)
+    endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/../VC-LTL/_msvcrt.h)
+        set(VC_LTL_Root ${CMAKE_CURRENT_SOURCE_DIR}/../VC-LTL)
+    endif()
+endif()
+
+if(NOT VC_LTL_Root)
+	if(EXISTS ${PROJECT_SOURCE_DIR}/../VC-LTL/_msvcrt.h)
+        set(VC_LTL_Root ${PROJECT_SOURCE_DIR}/../VC-LTL)
+    endif()
+endif()
+
+if(NOT VC_LTL_Root)
+    EXECUTE_PROCESS(COMMAND reg query "HKEY_CURRENT_USER\\Code\\VC-LTL" -v "Root"
+                    OUTPUT_VARIABLE FOUND_FILE
+                    ERROR_VARIABLE ERROR_INFO
+                   )
+
+    string(REGEX MATCH "[a-zA-Z]:\\\\.+\\\\"
+           FOUND_LTL
+           ${FOUND_FILE})
+    if (NOT ${FOUND_LTL} STREQUAL "")
+        set(VC_LTL_Root ${FOUND_LTL})
+    endif()
+
+    if(NOT DEFINED VC_LTL_Root)
+        string(REGEX MATCH "\\\\\\\\.+\\\\" FOUND_LTL ${FOUND_FILE})
+        if (NOT ${FOUND_LTL} STREQUAL "")
+            set(VC_LTL_Root ${FOUND_LTL})
+        endif()
+    endif()
+endif()
+
+if(VC_LTL_Root)
+    include("${VC_LTL_Root}\\config\\config.cmake")
+endif()
diff --git a/configure.cmake b/configure.cmake
index 776299189b..f9bdfb2233 100644
--- a/configure.cmake
+++ b/configure.cmake
@@ -1124,6 +1124,10 @@ qt_feature("intelcet" PRIVATE
     LABEL "Using Intel CET"
     CONDITION ( INPUT_intelcet STREQUAL yes ) OR TEST_intelcet
 )
+qt_feature("spectre" PRIVATE
+    LABEL "Mitigate Spectre security vulnerabilities."
+    CONDITION INPUT_spectre STREQUAL yes
+)
 qt_configure_add_summary_build_type_and_config()
 qt_configure_add_summary_section(NAME "Build options")
 qt_configure_add_summary_build_mode(Mode)
@@ -1174,6 +1178,7 @@ qt_configure_add_summary_entry(ARGS "relocatable")
 qt_configure_add_summary_entry(ARGS "precompile_header")
 qt_configure_add_summary_entry(ARGS "ltcg")
 qt_configure_add_summary_entry(ARGS "intelcet")
+qt_configure_add_summary_entry(ARGS "spectre")
 qt_configure_add_summary_entry(
     ARGS "wasm-simd128"
     CONDITION ( TEST_architecture_arch STREQUAL wasm )
diff --git a/qt_cmdline.cmake b/qt_cmdline.cmake
index 5450b2562c..2da78922c8 100644
--- a/qt_cmdline.cmake
+++ b/qt_cmdline.cmake
@@ -74,6 +74,7 @@ qt_commandline_option(openssl-runtime TYPE void NAME openssl VALUE runtime)
 qt_commandline_option(linker TYPE optionalString VALUES bfd gold lld mold)
 qt_commandline_option(ltcg TYPE boolean)
 qt_commandline_option(intelcet TYPE boolean)
+qt_commandline_option(spectre TYPE boolean)
 # special case begin
 qt_commandline_option(make TYPE addString VALUES examples libs tests tools
                       benchmarks manual-tests minimal-static-tests)
diff --git a/src/3rdparty/VulkanMemoryAllocator/vk_mem_alloc.h b/src/3rdparty/VulkanMemoryAllocator/vk_mem_alloc.h
index b8f9ab52aa..9e08c3257b 100644
--- a/src/3rdparty/VulkanMemoryAllocator/vk_mem_alloc.h
+++ b/src/3rdparty/VulkanMemoryAllocator/vk_mem_alloc.h
@@ -2883,10 +2883,36 @@ static void vma_aligned_free(void* VMA_NULLABLE ptr)
             VmaRWMutex() { InitializeSRWLock(&m_Lock); }
             void LockRead() { AcquireSRWLockShared(&m_Lock); }
             void UnlockRead() { ReleaseSRWLockShared(&m_Lock); }
-            bool TryLockRead() { return TryAcquireSRWLockShared(&m_Lock) != FALSE; }
+            bool TryLockRead() {
+                // TryAcquireSRWLockShared: available on Win7+
+                using PFN_TryAcquireSRWLockShared = decltype(&::TryAcquireSRWLockShared);
+                static const auto pTryAcquireSRWLockShared = []() -> PFN_TryAcquireSRWLockShared {
+                    const HMODULE library = LoadLibraryW(L"kernel32");
+                    if (!library)
+                        return nullptr;
+                    const FARPROC func = GetProcAddress(library, "TryAcquireSRWLockShared");
+                    if (!func)
+                        return nullptr;
+                    return reinterpret_cast<PFN_TryAcquireSRWLockShared>(func);
+                }();
+                return pTryAcquireSRWLockShared && pTryAcquireSRWLockShared(&m_Lock) != FALSE;
+            }
             void LockWrite() { AcquireSRWLockExclusive(&m_Lock); }
             void UnlockWrite() { ReleaseSRWLockExclusive(&m_Lock); }
-            bool TryLockWrite() { return TryAcquireSRWLockExclusive(&m_Lock) != FALSE; }
+            bool TryLockWrite() {
+                // TryAcquireSRWLockExclusive: available on Win7+
+                using PFN_TryAcquireSRWLockExclusive = decltype(&::TryAcquireSRWLockExclusive);
+                static const auto pTryAcquireSRWLockExclusive = []() -> PFN_TryAcquireSRWLockExclusive {
+                    const HMODULE library = LoadLibraryW(L"kernel32");
+                    if (!library)
+                        return nullptr;
+                    const FARPROC func = GetProcAddress(library, "TryAcquireSRWLockExclusive");
+                    if (!func)
+                        return nullptr;
+                    return reinterpret_cast<PFN_TryAcquireSRWLockExclusive>(func);
+                }();
+                return pTryAcquireSRWLockExclusive && pTryAcquireSRWLockExclusive(&m_Lock) != FALSE;
+            }
         private:
             SRWLOCK m_Lock;
         };
diff --git a/src/corelib/CMakeLists.txt b/src/corelib/CMakeLists.txt
index 8fc301e27f..ce803de948 100644
--- a/src/corelib/CMakeLists.txt
+++ b/src/corelib/CMakeLists.txt
@@ -540,6 +540,7 @@ qt_internal_extend_target(Core CONDITION QT_FEATURE_animation
 # from the wrong DLL at runtime and crash!
 qt_internal_extend_target(Core CONDITION QT_FEATURE_thread AND WIN32
     SOURCES
+        thread/qmutex_win.cpp
         thread/qwaitcondition_win.cpp
     LIBRARIES
         synchronization
@@ -1320,6 +1321,7 @@ qt_internal_extend_target(Core CONDITION WASM
 set_source_files_properties(
     thread/qmutex_mac.cpp
     thread/qmutex_unix.cpp
+    thread/qmutex_win.cpp
     PROPERTIES HEADER_FILE_ONLY ON)  # special case: These files are included by qmutex.cpp!
 
 
diff --git a/src/corelib/global/qlibraryinfo.cpp b/src/corelib/global/qlibraryinfo.cpp
index 715bda488c..6973de9d76 100644
--- a/src/corelib/global/qlibraryinfo.cpp
+++ b/src/corelib/global/qlibraryinfo.cpp
@@ -296,8 +296,13 @@ static QString prefixFromQtCoreLibraryHelper(const QString &qtCoreLibraryPath)
 {
     const QString qtCoreLibrary = QDir::fromNativeSeparators(qtCoreLibraryPath);
     const QString libDir = QFileInfo(qtCoreLibrary).absolutePath();
-    const QString prefixDir = libDir + "/" QT_CONFIGURE_LIBLOCATION_TO_PREFIX_PATH;
-    return QDir::cleanPath(prefixDir);
+    const QString prefix = libDir + "/";
+    return QDir::cleanPath([&prefix]() -> QString {
+        if (qEnvironmentVariableIntValue("QT_FORCE_LOAD_PLUGINS_FROM_CORE_DIR")) {
+            return prefix;
+        }
+        return prefix + QT_CONFIGURE_LIBLOCATION_TO_PREFIX_PATH;
+    }());
 }
 #endif
 
@@ -686,6 +691,17 @@ const char *qVersion() noexcept
     return QT_VERSION_STR;
 }
 
+/*!
+    A special function to identify this custom Qt build.
+    It will always return the magic number "2546789017"
+    as the result. It's my QQ number and you can contact
+    me by sending me an e-mail to "2546789017@qq.com".
+*/
+quint64 __wangwenx190__() noexcept
+{
+    return 2546789017;
+}
+
 #if QT_DEPRECATED_SINCE(6, 9)
 
 bool qSharedBuild() noexcept
diff --git a/src/corelib/global/qlibraryinfo.h b/src/corelib/global/qlibraryinfo.h
index d4e8f8b050..6cd0b448cf 100644
--- a/src/corelib/global/qlibraryinfo.h
+++ b/src/corelib/global/qlibraryinfo.h
@@ -61,6 +61,11 @@ Q_CORE_EXPORT Q_DECL_CONST_FUNCTION bool qSharedBuild() noexcept;
 
 #endif
 
+#if (!defined(QT_NAMESPACE) && defined(__cplusplus))
+extern "C"
+#endif
+Q_CORE_EXPORT Q_DECL_CONST_FUNCTION quint64 __wangwenx190__(void) noexcept;
+
 QT_END_NAMESPACE
 
 #endif // QLIBRARYINFO_H
diff --git a/src/corelib/global/qoperatingsystemversion.cpp b/src/corelib/global/qoperatingsystemversion.cpp
index b9da31149e..49f30720bd 100644
--- a/src/corelib/global/qoperatingsystemversion.cpp
+++ b/src/corelib/global/qoperatingsystemversion.cpp
@@ -361,6 +361,9 @@ bool QOperatingSystemVersionBase::isAnyOfType(std::initializer_list<OSType> type
 
 #ifndef QT_BOOTSTRAPPED
 
+const QOperatingSystemVersion QOperatingSystemVersion::WindowsVista =
+    QOperatingSystemVersion(QOperatingSystemVersion::Windows, 6, 0);
+
 /*!
     \variable QOperatingSystemVersion::Windows7
     \brief a version corresponding to Windows 7 (version 6.1).
@@ -393,6 +396,13 @@ const QOperatingSystemVersion QOperatingSystemVersion::Windows8_1 =
 const QOperatingSystemVersion QOperatingSystemVersion::Windows10 =
     QOperatingSystemVersion(QOperatingSystemVersion::Windows, 10);
 
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1507;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1511;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1607;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1703;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1709;
+const QOperatingSystemVersionBase QOperatingSystemVersion::Windows10_1803;
+
 /*!
     \variable QOperatingSystemVersion::Windows10_1809
     \brief a version corresponding to Windows 10 October 2018 Update
diff --git a/src/corelib/global/qoperatingsystemversion.h b/src/corelib/global/qoperatingsystemversion.h
index 1e4eb5cc49..499a196fa7 100644
--- a/src/corelib/global/qoperatingsystemversion.h
+++ b/src/corelib/global/qoperatingsystemversion.h
@@ -123,6 +123,7 @@ public:
     // until Qt7
     // @note: New entries should be added after the if-def-ery until Qt 7!!
 #if QT_VERSION < QT_VERSION_CHECK(7, 0, 0) && !defined(QT_BOOTSTRAPPED)
+    static const QOperatingSystemVersion WindowsVista;
     static const QOperatingSystemVersion Windows7;
     static const QOperatingSystemVersion Windows8;
     static const QOperatingSystemVersion Windows8_1;
@@ -153,6 +154,7 @@ public:
     static const QOperatingSystemVersion Android10;
     static const QOperatingSystemVersion Android11;
 #else
+    static constexpr QOperatingSystemVersionBase WindowsVista { QOperatingSystemVersionBase::Windows, 6, 0 };
     static constexpr QOperatingSystemVersionBase Windows7 { QOperatingSystemVersionBase::Windows, 6, 1 };
     static constexpr QOperatingSystemVersionBase Windows8 { QOperatingSystemVersionBase::Windows, 6, 2 };
     static constexpr QOperatingSystemVersionBase Windows8_1 { QOperatingSystemVersionBase::Windows, 6, 3 };
@@ -188,6 +190,12 @@ public:
     static constexpr QOperatingSystemVersionBase Android11 { QOperatingSystemVersionBase::Android, 11, 0 };
 #endif // New (static constexpr) entries go here, only cherry-pick as far back as 6.3 (QTBUG-97808):
 
+    static constexpr QOperatingSystemVersionBase Windows10_1507 { QOperatingSystemVersionBase::Windows, 10, 0, 10240 }; // TH1
+    static constexpr QOperatingSystemVersionBase Windows10_1511 { QOperatingSystemVersionBase::Windows, 10, 0, 10586 }; // TH2
+    static constexpr QOperatingSystemVersionBase Windows10_1607 { QOperatingSystemVersionBase::Windows, 10, 0, 14393 }; // RS1
+    static constexpr QOperatingSystemVersionBase Windows10_1703 { QOperatingSystemVersionBase::Windows, 10, 0, 15063 }; // RS2
+    static constexpr QOperatingSystemVersionBase Windows10_1709 { QOperatingSystemVersionBase::Windows, 10, 0, 16299 }; // RS3
+    static constexpr QOperatingSystemVersionBase Windows10_1803 { QOperatingSystemVersionBase::Windows, 10, 0, 17134 }; // RS4
     static constexpr QOperatingSystemVersionBase Windows10_1809 { QOperatingSystemVersionBase::Windows, 10, 0, 17763 }; // RS5
     static constexpr QOperatingSystemVersionBase Windows10_1903 { QOperatingSystemVersionBase::Windows, 10, 0, 18362 }; // 19H1
     static constexpr QOperatingSystemVersionBase Windows10_1909 { QOperatingSystemVersionBase::Windows, 10, 0, 18363 }; // 19H2
@@ -206,6 +214,38 @@ public:
 
     static constexpr QOperatingSystemVersionBase MacOSVentura { QOperatingSystemVersionBase::MacOS, 13, 0 };
 
+#ifdef Q_OS_WINDOWS
+#  define MAKE_VERSION_FUNCTION(Name, Version) \
+    [[nodiscard]] static inline bool isWin##Name##OrGreater() \
+    { \
+        static const bool result = QOperatingSystemVersion::current() >= QOperatingSystemVersion::Windows##Version; \
+        return result; \
+    }
+    MAKE_VERSION_FUNCTION(Vista, Vista)
+    MAKE_VERSION_FUNCTION(7, 7)
+    MAKE_VERSION_FUNCTION(8, 8)
+    MAKE_VERSION_FUNCTION(8Point1, 8_1)
+    MAKE_VERSION_FUNCTION(10, 10)
+    MAKE_VERSION_FUNCTION(10TH1, 10_1507)
+    MAKE_VERSION_FUNCTION(10TH2, 10_1511)
+    MAKE_VERSION_FUNCTION(10RS1, 10_1607)
+    MAKE_VERSION_FUNCTION(10RS2, 10_1703)
+    MAKE_VERSION_FUNCTION(10RS3, 10_1709)
+    MAKE_VERSION_FUNCTION(10RS4, 10_1803)
+    MAKE_VERSION_FUNCTION(10RS5, 10_1809)
+    MAKE_VERSION_FUNCTION(1019H1, 10_1903)
+    MAKE_VERSION_FUNCTION(1019H2, 10_1909)
+    MAKE_VERSION_FUNCTION(1020H1, 10_2004)
+    MAKE_VERSION_FUNCTION(1020H2, 10_20H2)
+    MAKE_VERSION_FUNCTION(1021H1, 10_21H1)
+    MAKE_VERSION_FUNCTION(1021H2, 10_21H2)
+    MAKE_VERSION_FUNCTION(1022H2, 10_22H2)
+    MAKE_VERSION_FUNCTION(11, 11)
+    MAKE_VERSION_FUNCTION(1121H2, 11_21H2)
+    MAKE_VERSION_FUNCTION(1122H2, 11_22H2)
+#  undef MAKE_VERSION_FUNCTION
+#endif // Q_OS_WINDOWS
+
     constexpr QOperatingSystemVersion(const QOperatingSystemVersionBase &osversion)
         : QOperatingSystemVersionBase(osversion) {}
 
diff --git a/src/corelib/global/qoperatingsystemversion_win.cpp b/src/corelib/global/qoperatingsystemversion_win.cpp
index a209fb17b6..50edb719fd 100644
--- a/src/corelib/global/qoperatingsystemversion_win.cpp
+++ b/src/corelib/global/qoperatingsystemversion_win.cpp
@@ -51,7 +51,18 @@ OSVERSIONINFOEX qWindowsVersionInfo()
             result.wServicePackMinor = 0;
 
             const QByteArray winVerOverride = qgetenv("QT_WINVER_OVERRIDE");
-            if (winVerOverride == "WINDOWS10" || winVerOverride == "2016"
+            if (winVerOverride == "WINDOWSVISTA" || winVerOverride == "2008") {
+                result.dwMajorVersion = 6;
+            } else if (winVerOverride == "WINDOWS7" || winVerOverride == "2008_R2") {
+                result.dwMajorVersion = 6;
+                result.dwMinorVersion = 1;
+            } else if (winVerOverride == "WINDOWS8" || winVerOverride == "2012") {
+                result.dwMajorVersion = 6;
+                result.dwMinorVersion = 2;
+            } else if (winVerOverride == "WINDOWS8_1" || winVerOverride == "2012_R2") {
+                result.dwMajorVersion = 6;
+                result.dwMinorVersion = 3;
+            } else if (winVerOverride == "WINDOWS10" || winVerOverride == "2016"
                 || winVerOverride == "2019" || winVerOverride == "2022") {
                 result.dwMajorVersion = 10;
             } else if (winVerOverride == "WINDOWS11") {
@@ -61,7 +72,12 @@ OSVERSIONINFOEX qWindowsVersionInfo()
                 return realResult;
             }
 
-            if (winVerOverride == "2016" || winVerOverride == "2019"
+            if (winVerOverride == "2008"
+                || winVerOverride == "2008_R2"
+                || winVerOverride == "2012"
+                || winVerOverride == "2012_R2"
+                || winVerOverride == "2016"
+                || winVerOverride == "2019"
                 || winVerOverride == "2022") {
                 // If the current host OS is a domain controller and the override OS
                 // is also a server type OS, preserve that information
diff --git a/src/corelib/global/qsysinfo.cpp b/src/corelib/global/qsysinfo.cpp
index 9df9d96b5e..8c1ca09f7b 100644
--- a/src/corelib/global/qsysinfo.cpp
+++ b/src/corelib/global/qsysinfo.cpp
@@ -165,12 +165,17 @@ static inline QString windowsDisplayVersion()
 {
     // https://tickets.puppetlabs.com/browse/FACT-3058
     // The "ReleaseId" key stopped updating since Windows 10 20H2.
-    if (QOperatingSystemVersion::current() >= QOperatingSystemVersion::Windows10_20H2)
+    if (QOperatingSystemVersion::isWin1020H2OrGreater())
         return readVersionRegistryString(L"DisplayVersion");
     else
         return readVersionRegistryString(L"ReleaseId");
 }
 
+static QString windows7Build()
+{
+    return readVersionRegistryString(L"CurrentBuild");
+}
+
 static QString winSp_helper()
 {
     const auto osv = qWindowsVersionInfo();
@@ -194,6 +199,14 @@ static const char *osVer_helper(QOperatingSystemVersion version = QOperatingSyst
 
 #define Q_WINVER(major, minor) (major << 8 | minor)
     switch (Q_WINVER(osver.dwMajorVersion, osver.dwMinorVersion)) {
+    case Q_WINVER(6, 0):
+        return workstation ? "Vista" : "Server 2008";
+    case Q_WINVER(6, 1):
+        return workstation ? "7" : "Server 2008 R2";
+    case Q_WINVER(6, 2):
+        return workstation ? "8" : "Server 2012";
+    case Q_WINVER(6, 3):
+        return workstation ? "8.1" : "Server 2012 R2";
     case Q_WINVER(10, 0):
         if (workstation) {
             if (osver.dwBuildNumber >= 22000)
@@ -885,10 +898,21 @@ QString QSysInfo::prettyProductName()
     return result + " ("_L1 + versionString + u')';
 #  else
     // (resembling winver.exe): Windows 10 "Windows 10 Version 1809"
-    const auto displayVersion = windowsDisplayVersion();
-    if (!displayVersion.isEmpty())
-        result += " Version "_L1 + displayVersion;
-    return result;
+    if (majorVersion >= 10) {
+        const auto displayVersion = windowsDisplayVersion();
+        if (!displayVersion.isEmpty())
+            result += " Version "_L1 + displayVersion;
+        return result;
+    }
+    // Windows 7: "Windows 7 Version 6.1 (Build 7601: Service Pack 1)"
+    result += " Version "_L1 + versionString + " ("_L1;
+    const auto build = windows7Build();
+    if (!build.isEmpty())
+        result += "Build "_L1 + build;
+    const auto servicePack = winSp_helper();
+    if (!servicePack.isEmpty())
+        result += ": "_L1 + servicePack;
+    return result + u')';
 #  endif // Windows
 #elif defined(Q_OS_HAIKU)
     return "Haiku "_L1 + productVersion();
diff --git a/src/corelib/io/qlockfile_win.cpp b/src/corelib/io/qlockfile_win.cpp
index b9d7721517..33a4291035 100644
--- a/src/corelib/io/qlockfile_win.cpp
+++ b/src/corelib/io/qlockfile_win.cpp
@@ -13,8 +13,12 @@
 #include "QtCore/qdebug.h"
 #include "QtCore/qthread.h"
 
+#include <QtCore/private/qsystemlibrary_p.h>
+
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 static inline bool fileExists(const wchar_t *fileName)
 {
     WIN32_FILE_ATTRIBUTE_DATA  data;
@@ -96,12 +100,16 @@ bool QLockFilePrivate::isProcessRunning(qint64 pid, const QString &appname)
 
 QString QLockFilePrivate::processNameByPid(qint64 pid)
 {
+    static const auto pGetModuleFileNameExW =
+        reinterpret_cast<decltype(&::GetModuleFileNameExW)>(
+            QSystemLibrary::resolve(u"psapi"_s, "GetModuleFileNameExW"));
+    if (!pGetModuleFileNameExW)
+        return QString();
     HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, DWORD(pid));
-    if (!hProcess) {
+    if (!hProcess)
         return QString();
-    }
     wchar_t buf[MAX_PATH];
-    const DWORD length = GetModuleFileNameExW(hProcess, NULL, buf, sizeof(buf) / sizeof(wchar_t));
+    const DWORD length = pGetModuleFileNameExW(hProcess, NULL, buf, sizeof(buf) / sizeof(wchar_t));
     CloseHandle(hProcess);
     if (!length)
         return QString();
diff --git a/src/corelib/kernel/qcoreapplication.cpp b/src/corelib/kernel/qcoreapplication.cpp
index d9a42413e4..2bc9ec726d 100644
--- a/src/corelib/kernel/qcoreapplication.cpp
+++ b/src/corelib/kernel/qcoreapplication.cpp
@@ -108,6 +108,10 @@ QT_BEGIN_NAMESPACE
 
 using namespace Qt::StringLiterals;
 
+#ifndef QT_BOOTSTRAPPED
+static constexpr const char kWwx190EnvVar[] = "__wangwenx190__";
+#endif
+
 #if defined(Q_OS_WIN) || defined(Q_OS_MAC)
 extern QString qAppFileName();
 #endif
@@ -446,6 +450,9 @@ QCoreApplicationPrivate::QCoreApplicationPrivate(int &aargc, char **aargv)
 
 QCoreApplicationPrivate::~QCoreApplicationPrivate()
 {
+#ifndef QT_BOOTSTRAPPED
+    qunsetenv(kWwx190EnvVar);
+#endif
 #ifndef QT_NO_QOBJECT
     cleanupThreadData();
 #endif
@@ -784,6 +791,10 @@ void QCoreApplicationPrivate::init()
     Q_ASSERT_X(!QCoreApplication::self, "QCoreApplication", "there should be only one application object");
     QCoreApplication::self = q;
 
+#ifndef QT_BOOTSTRAPPED
+    qputenv(kWwx190EnvVar, QByteArray::number(__wangwenx190__()));
+#endif
+
 #if QT_CONFIG(thread)
 #ifdef Q_OS_WASM
     emscripten::val hardwareConcurrency = emscripten::val::global("navigator")["hardwareConcurrency"];
diff --git a/src/corelib/kernel/qeventdispatcher_win.cpp b/src/corelib/kernel/qeventdispatcher_win.cpp
index 1c54c97514..0da2185811 100644
--- a/src/corelib/kernel/qeventdispatcher_win.cpp
+++ b/src/corelib/kernel/qeventdispatcher_win.cpp
@@ -6,7 +6,6 @@
 
 #include "qcoreapplication.h"
 #include <private/qsystemlibrary_p.h>
-#include "qoperatingsystemversion.h"
 #include "qpair.h"
 #include "qset.h"
 #include "qsocketnotifier.h"
@@ -18,6 +17,8 @@
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 #ifndef TIME_KILL_SYNCHRONOUS
 #  define TIME_KILL_SYNCHRONOUS 0x0100
 #endif
@@ -355,8 +356,13 @@ void QEventDispatcherWin32Private::registerTimer(WinTimerInfo *t)
     }
 
     if (!ok) {
-        // user normal timers for (Very)CoarseTimers, or if no more multimedia timers available
-        ok = SetCoalescableTimer(internalHwnd, t->timerId, interval, nullptr, tolerance);
+        static const auto pSetCoalescableTimer =
+            reinterpret_cast<decltype(&::SetCoalescableTimer)>(
+                QSystemLibrary::resolve(u"user32"_s, "SetCoalescableTimer"));
+        if (pSetCoalescableTimer) {
+            // user normal timers for (Very)CoarseTimers, or if no more multimedia timers available
+            ok = pSetCoalescableTimer(internalHwnd, t->timerId, interval, nullptr, tolerance);
+        }
     }
     if (!ok)
         ok = SetTimer(internalHwnd, t->timerId, interval, nullptr);
diff --git a/src/corelib/kernel/qfunctions_win.cpp b/src/corelib/kernel/qfunctions_win.cpp
index ed0e25467c..2022ff2f24 100644
--- a/src/corelib/kernel/qfunctions_win.cpp
+++ b/src/corelib/kernel/qfunctions_win.cpp
@@ -4,6 +4,7 @@
 #include "qfunctions_win_p.h"
 
 #include <QtCore/qdebug.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 
 #include <combaseapi.h>
 #include <objbase.h>
@@ -15,6 +16,8 @@
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 QComHelper::QComHelper(COINIT concurrencyModel)
 {
     // Avoid overhead of initializing and using obsolete technology
@@ -44,8 +47,13 @@ bool qt_win_hasPackageIdentity()
 {
 #if defined(HAS_APPMODEL)
     static const bool hasPackageIdentity = []() {
+        static const auto pGetCurrentPackageFullName =
+            reinterpret_cast<decltype(&::GetCurrentPackageFullName)>(
+                QSystemLibrary::resolve(u"kernel32"_s, "GetCurrentPackageFullName"));
+        if (!pGetCurrentPackageFullName)
+            return false;
         UINT32 length = 0;
-        switch (const auto result = GetCurrentPackageFullName(&length, nullptr)) {
+        switch (const auto result = pGetCurrentPackageFullName(&length, nullptr)) {
         case ERROR_INSUFFICIENT_BUFFER:
             return true;
         case APPMODEL_ERROR_NO_PACKAGE:
diff --git a/src/corelib/plugin/qsystemlibrary.cpp b/src/corelib/plugin/qsystemlibrary.cpp
index d3dff226d9..22b4f04340 100644
--- a/src/corelib/plugin/qsystemlibrary.cpp
+++ b/src/corelib/plugin/qsystemlibrary.cpp
@@ -42,9 +42,9 @@ using namespace Qt::StringLiterals;
 extern QString qAppFileName();
 #endif
 
-static QString qSystemDirectory()
+static inline QString qSystemDirectory()
 {
-    static const QString result = []() -> QString {
+    static const auto result = []() -> QString {
         QVarLengthArray<wchar_t, MAX_PATH> fullPath = {};
         UINT retLen = ::GetSystemDirectoryW(fullPath.data(), MAX_PATH);
         if (retLen > MAX_PATH) {
@@ -57,10 +57,32 @@ static QString qSystemDirectory()
     return result;
 }
 
+static inline bool isLoadFromSystem32Available()
+{
+    static const auto result = []() -> bool {
+        const HMODULE library = ::LoadLibraryW(L"kernel32");
+        if (!library)
+            return false;
+        const bool ret = ::GetProcAddress(library, "AddDllDirectory") != nullptr;
+        ::FreeLibrary(library);
+        return ret;
+    }();
+    return result;
+}
+
 HINSTANCE QSystemLibrary::load(const wchar_t *libraryName, bool onlySystemDirectory /* = true */)
 {
-    if (onlySystemDirectory)
-        return ::LoadLibraryExW(libraryName, nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+    const QString fileName = QString::fromWCharArray(libraryName);
+
+    if (onlySystemDirectory) {
+        if (isLoadFromSystem32Available())
+            return ::LoadLibraryExW(libraryName, nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+        QString path = qSystemDirectory();
+        if (!path.endsWith(u'\\'))
+            path.append(u'\\');
+        path.append(fileName);
+        return ::LoadLibraryW(reinterpret_cast<const wchar_t *>(path.utf16()));
+    }
 
     QStringList searchOrder;
 
@@ -72,16 +94,13 @@ HINSTANCE QSystemLibrary::load(const wchar_t *libraryName, bool onlySystemDirect
     const QString PATH(QLatin1StringView(qgetenv("PATH")));
     searchOrder << PATH.split(u';', Qt::SkipEmptyParts);
 
-    const QString fileName = QString::fromWCharArray(libraryName);
-
     // Start looking in the order specified
-    for (int i = 0; i < searchOrder.count(); ++i) {
+    for (int i = 0; i != searchOrder.count(); ++i) {
         QString fullPathAttempt = searchOrder.at(i);
-        if (!fullPathAttempt.endsWith(u'\\')) {
+        if (!fullPathAttempt.endsWith(u'\\'))
             fullPathAttempt.append(u'\\');
-        }
         fullPathAttempt.append(fileName);
-        HINSTANCE inst = ::LoadLibrary(reinterpret_cast<const wchar_t *>(fullPathAttempt.utf16()));
+        const HINSTANCE inst = ::LoadLibraryW(reinterpret_cast<const wchar_t *>(fullPathAttempt.utf16()));
         if (inst != nullptr)
             return inst;
     }
diff --git a/src/corelib/text/qlocale_win.cpp b/src/corelib/text/qlocale_win.cpp
index 67fac95304..0486aa84b4 100644
--- a/src/corelib/text/qlocale_win.cpp
+++ b/src/corelib/text/qlocale_win.cpp
@@ -15,6 +15,7 @@
 #include <q20algorithm.h>
 
 #ifdef Q_OS_WIN
+#   include <qoperatingsystemversion.h>
 #   include <qt_windows.h>
 #   include <time.h>
 #endif
@@ -663,17 +664,19 @@ QVariant QSystemLocalePrivate::uiLanguages()
 {
     QStringList result;
 #if QT_CONFIG(cpp_winrt)
-    using namespace winrt;
-    using namespace Windows::System::UserProfile;
-    QT_TRY {
-        auto languages = GlobalizationPreferences::Languages();
-        for (const auto &lang : languages)
-            result << QString::fromStdString(winrt::to_string(lang));
-    } QT_CATCH(...) {
-        // pass, just fall back to WIN32 API implementation
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        using namespace winrt;
+        using namespace Windows::System::UserProfile;
+        QT_TRY {
+            const auto languages = GlobalizationPreferences::Languages();
+            for (auto &&lang : languages)
+                result << QString::fromStdString(winrt::to_string(lang));
+        } QT_CATCH(...) {
+            // pass, just fall back to WIN32 API implementation
+        }
+        if (!result.isEmpty())
+            return result; // else just fall back to WIN32 API implementation
     }
-    if (!result.isEmpty())
-        return result; // else just fall back to WIN32 API implementation
 #endif // QT_CONFIG(cpp_winrt)
     // mingw and clang still have to use Win32 API
     unsigned long cnt = 0;
diff --git a/src/corelib/thread/qfutex_p.h b/src/corelib/thread/qfutex_p.h
index 48f03f5ed0..fe799c68ca 100644
--- a/src/corelib/thread/qfutex_p.h
+++ b/src/corelib/thread/qfutex_p.h
@@ -17,9 +17,12 @@
 
 #include <private/qglobal_p.h>
 #include <QtCore/qtsan_impl.h>
+#include <QtCore/qstring.h>
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 namespace QtDummyFutex {
     constexpr inline bool futexAvailable() { return false; }
     template <typename Atomic>
@@ -109,35 +112,86 @@ namespace QtFutex = QtLinuxFutex;
 QT_END_NAMESPACE
 
 #elif defined(Q_OS_WIN)
-#  include <qt_windows.h>
+#  include <QtCore/qoperatingsystemversion.h>
+#  include <QtCore/private/qsystemlibrary_p.h>
+#  include <QtCore/qt_windows.h>
 
 QT_BEGIN_NAMESPACE
-namespace QtWindowsFutex {
-#define QT_ALWAYS_USE_FUTEX
-constexpr inline bool futexAvailable() { return true; }
+namespace QtWindowsFutex
+{
+#ifdef QT_ALWAYS_USE_FUTEX
+#  undef QT_ALWAYS_USE_FUTEX
+#endif
+
+inline bool futexAvailable()
+{
+    return QOperatingSystemVersion::isWin8OrGreater();
+}
+
+struct QFutexApi
+{
+    decltype(&::WaitOnAddress) pWaitOnAddress = nullptr;
+    decltype(&::WakeByAddressAll) pWakeByAddressAll = nullptr;
+    decltype(&::WakeByAddressSingle) pWakeByAddressSingle = nullptr;
+
+    static QFutexApi *instance()
+    {
+        static QFutexApi api;
+        return &api;
+    }
+
+private:
+    Q_DISABLE_COPY_MOVE(QFutexApi)
+
+    explicit QFutexApi()
+    {
+        if (!futexAvailable())
+            return;
+        QSystemLibrary library(u"kernelbase"_s);
+        pWaitOnAddress = reinterpret_cast<decltype(pWaitOnAddress)>(library.resolve("WaitOnAddress"));
+        pWakeByAddressAll = reinterpret_cast<decltype(pWakeByAddressAll)>(library.resolve("WakeByAddressAll"));
+        pWakeByAddressSingle = reinterpret_cast<decltype(pWakeByAddressSingle)>(library.resolve("WakeByAddressSingle"));
+    }
+
+    ~QFutexApi() = default;
+};
 
 template <typename Atomic>
 inline void futexWait(Atomic &futex, typename Atomic::Type expectedValue)
 {
+    if (!QFutexApi::instance()->pWaitOnAddress)
+        return;
     QtTsan::futexRelease(&futex);
-    WaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), INFINITE);
+    QFutexApi::instance()->pWaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), INFINITE);
     QtTsan::futexAcquire(&futex);
 }
+
 template <typename Atomic>
 inline bool futexWait(Atomic &futex, typename Atomic::Type expectedValue, qint64 nstimeout)
 {
-    BOOL r = WaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), DWORD(nstimeout / 1000 / 1000));
+    if (!QFutexApi::instance()->pWaitOnAddress)
+        return false;
+    const BOOL r = QFutexApi::instance()->pWaitOnAddress(&futex, &expectedValue, sizeof(expectedValue), DWORD(nstimeout / 1000 / 1000));
     return r || GetLastError() != ERROR_TIMEOUT;
 }
-template <typename Atomic> inline void futexWakeAll(Atomic &futex)
+
+template <typename Atomic>
+inline void futexWakeAll(Atomic &futex)
 {
-    WakeByAddressAll(&futex);
+    if (!QFutexApi::instance()->pWakeByAddressAll)
+        return;
+    QFutexApi::instance()->pWakeByAddressAll(&futex);
 }
-template <typename Atomic> inline void futexWakeOne(Atomic &futex)
+
+template <typename Atomic>
+inline void futexWakeOne(Atomic &futex)
 {
-    WakeByAddressSingle(&futex);
-}
+    if (!QFutexApi::instance()->pWakeByAddressSingle)
+        return;
+    QFutexApi::instance()->pWakeByAddressSingle(&futex);
 }
+} // namespace QtWindowsFutex
+
 namespace QtFutex = QtWindowsFutex;
 QT_END_NAMESPACE
 #else
diff --git a/src/corelib/thread/qlocking_p.h b/src/corelib/thread/qlocking_p.h
index 9fa7e70da9..0c205fff66 100644
--- a/src/corelib/thread/qlocking_p.h
+++ b/src/corelib/thread/qlocking_p.h
@@ -8,9 +8,10 @@
 //  W A R N I N G
 //  -------------
 //
-// This file is not part of the Qt API. It exists for the convenience of
-// qmutex.cpp and qmutex_unix.cpp. This header file may change from version to
-// version without notice, or even be removed.
+// This file is not part of the Qt API.  It exists for the convenience
+// of qmutex.cpp, qmutex_unix.cpp, and qmutex_win.cpp.  This header
+// file may change from version to version without notice, or even be
+// removed.
 //
 // We mean it.
 //
diff --git a/src/corelib/thread/qmutex.cpp b/src/corelib/thread/qmutex.cpp
index 7b4aac9532..ae1a3a7313 100644
--- a/src/corelib/thread/qmutex.cpp
+++ b/src/corelib/thread/qmutex.cpp
@@ -869,6 +869,8 @@ QT_END_NAMESPACE
 // nothing
 #elif defined(Q_OS_MAC)
 #  include "qmutex_mac.cpp"
+#elif defined(Q_OS_WIN)
+#  include "qmutex_win.cpp"
 #else
 #  include "qmutex_unix.cpp"
 #endif
diff --git a/src/corelib/thread/qmutex_p.h b/src/corelib/thread/qmutex_p.h
index e5932d0a66..9985a068c5 100644
--- a/src/corelib/thread/qmutex_p.h
+++ b/src/corelib/thread/qmutex_p.h
@@ -10,9 +10,10 @@
 //  W A R N I N G
 //  -------------
 //
-// This file is not part of the Qt API. It exists for the convenience of
-// qmutex.cpp and qmutex_unix.cpp. This header file may change from version to
-// version without notice, or even be removed.
+// This file is not part of the Qt API.  It exists for the convenience
+// of qmutex.cpp, qmutex_unix.cpp, and qmutex_win.cpp.  This header
+// file may change from version to version without notice, or even be
+// removed.
 //
 // We mean it.
 //
@@ -89,6 +90,8 @@ public:
     bool wakeup;
     pthread_mutex_t mutex;
     pthread_cond_t cond;
+#elif defined(Q_OS_WIN)
+    Qt::HANDLE event;
 #endif
 };
 
diff --git a/src/corelib/thread/qmutex_win.cpp b/src/corelib/thread/qmutex_win.cpp
new file mode 100644
index 0000000000..8c7741c113
--- /dev/null
+++ b/src/corelib/thread/qmutex_win.cpp
@@ -0,0 +1,30 @@
+// Copyright (C) 2016 The Qt Company Ltd.
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
+
+#include "qmutex.h"
+#include <qatomic.h>
+#include "qmutex_p.h"
+#include <qt_windows.h>
+
+QT_BEGIN_NAMESPACE
+
+QMutexPrivate::QMutexPrivate()
+{
+    event = CreateEvent(0, FALSE, FALSE, 0);
+
+    if (!event)
+        qWarning("QMutexPrivate::QMutexPrivate: Cannot create event");
+}
+
+QMutexPrivate::~QMutexPrivate()
+{ CloseHandle(event); }
+
+bool QMutexPrivate::wait(int timeout)
+{
+    return (WaitForSingleObjectEx(event, timeout < 0 ? INFINITE : timeout, FALSE) == WAIT_OBJECT_0);
+}
+
+void QMutexPrivate::wakeUp() noexcept
+{ SetEvent(event); }
+
+QT_END_NAMESPACE
diff --git a/src/corelib/thread/qwaitcondition_p.h b/src/corelib/thread/qwaitcondition_p.h
index cfb36ca30b..01bb000366 100644
--- a/src/corelib/thread/qwaitcondition_p.h
+++ b/src/corelib/thread/qwaitcondition_p.h
@@ -7,9 +7,10 @@
 //  W A R N I N G
 //  -------------
 //
-// This file is not part of the Qt API. It exists for the convenience of
-// qmutex.cpp and qmutex_unix.cpp. This header file may change from version to
-// version without notice, or even be removed.
+// This file is not part of the Qt API.  It exists for the convenience
+// of qmutex.cpp, qmutex_unix.cpp, and qmutex_win.cpp.  This header
+// file may change from version to version without notice, or even be
+// removed.
 //
 // We mean it.
 //
diff --git a/src/gui/CMakeLists.txt b/src/gui/CMakeLists.txt
index 354432195a..390df08348 100644
--- a/src/gui/CMakeLists.txt
+++ b/src/gui/CMakeLists.txt
@@ -416,7 +416,6 @@ qt_internal_extend_target(Gui CONDITION WIN32
         d3d11
         dxgi
         dxguid
-        dcomp
 )
 
 if(QT_FEATURE_egl)
@@ -450,21 +449,6 @@ qt_internal_extend_target(Gui CONDITION APPLE AND QT_FEATURE_accessibility
         ${FWFoundation}
 )
 
-qt_internal_extend_target(Gui CONDITION QT_FEATURE_accessibility AND WIN32
-    SOURCES
-        accessible/windows/apisupport/qwindowsuiawrapper.cpp accessible/windows/apisupport/qwindowsuiawrapper_p.h
-        accessible/windows/apisupport/uiaattributeids_p.h
-        accessible/windows/apisupport/uiaclientinterfaces_p.h
-        accessible/windows/apisupport/uiacontroltypeids_p.h
-        accessible/windows/apisupport/uiaerrorids_p.h
-        accessible/windows/apisupport/uiaeventids_p.h
-        accessible/windows/apisupport/uiageneralids_p.h
-        accessible/windows/apisupport/uiapatternids_p.h
-        accessible/windows/apisupport/uiapropertyids_p.h
-        accessible/windows/apisupport/uiaserverinterfaces_p.h
-        accessible/windows/apisupport/uiatypes_p.h
-)
-
 if(QT_FEATURE_accessibility AND QT_FEATURE_accessibility_atspi_bridge)
     set(atspi_accessibility ON)
 else()
diff --git a/src/gui/accessible/windows/apisupport/qwindowsuiawrapper.cpp b/src/gui/accessible/windows/apisupport/qwindowsuiawrapper.cpp
deleted file mode 100644
index d9ff723a61..0000000000
--- a/src/gui/accessible/windows/apisupport/qwindowsuiawrapper.cpp
+++ /dev/null
@@ -1,89 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#include <initguid.h>
-
-#include "qwindowsuiawrapper_p.h"
-#include <QtCore/private/qsystemlibrary_p.h>
-
-QT_BEGIN_NAMESPACE
-
-// private constructor
-QWindowsUiaWrapper::QWindowsUiaWrapper()
-{
-    QSystemLibrary uiaLib(QStringLiteral("UIAutomationCore"));
-    if (uiaLib.load()) {
-        m_pUiaReturnRawElementProvider = reinterpret_cast<PtrUiaReturnRawElementProvider>(uiaLib.resolve("UiaReturnRawElementProvider"));
-        m_pUiaHostProviderFromHwnd = reinterpret_cast<PtrUiaHostProviderFromHwnd>(uiaLib.resolve("UiaHostProviderFromHwnd"));
-        m_pUiaRaiseAutomationPropertyChangedEvent = reinterpret_cast<PtrUiaRaiseAutomationPropertyChangedEvent>(uiaLib.resolve("UiaRaiseAutomationPropertyChangedEvent"));
-        m_pUiaRaiseAutomationEvent = reinterpret_cast<PtrUiaRaiseAutomationEvent>(uiaLib.resolve("UiaRaiseAutomationEvent"));
-        m_pUiaRaiseNotificationEvent = reinterpret_cast<PtrUiaRaiseNotificationEvent>(uiaLib.resolve("UiaRaiseNotificationEvent"));
-        m_pUiaClientsAreListening = reinterpret_cast<PtrUiaClientsAreListening>(uiaLib.resolve("UiaClientsAreListening"));
-    }
-}
-
-QWindowsUiaWrapper::~QWindowsUiaWrapper()
-{
-}
-
-// shared instance
-QWindowsUiaWrapper *QWindowsUiaWrapper::instance()
-{
-    static QWindowsUiaWrapper wrapper;
-    return &wrapper;
-}
-
-// True if most symbols resolved (UiaRaiseNotificationEvent is optional).
-BOOL QWindowsUiaWrapper::ready()
-{
-    return m_pUiaReturnRawElementProvider
-        && m_pUiaHostProviderFromHwnd
-        && m_pUiaRaiseAutomationPropertyChangedEvent
-        && m_pUiaRaiseAutomationEvent
-        && m_pUiaClientsAreListening;
-}
-
-BOOL QWindowsUiaWrapper::clientsAreListening()
-{
-    if (!m_pUiaClientsAreListening)
-        return FALSE;
-    return m_pUiaClientsAreListening();
-}
-
-LRESULT QWindowsUiaWrapper::returnRawElementProvider(HWND hwnd, WPARAM wParam, LPARAM lParam, IRawElementProviderSimple *el)
-{
-    if (!m_pUiaReturnRawElementProvider)
-        return static_cast<LRESULT>(NULL);
-    return m_pUiaReturnRawElementProvider(hwnd, wParam, lParam, el);
-}
-
-HRESULT QWindowsUiaWrapper::hostProviderFromHwnd(HWND hwnd, IRawElementProviderSimple **ppProvider)
-{
-    if (!m_pUiaHostProviderFromHwnd)
-        return UIA_E_NOTSUPPORTED;
-    return m_pUiaHostProviderFromHwnd(hwnd, ppProvider);
-}
-
-HRESULT QWindowsUiaWrapper::raiseAutomationPropertyChangedEvent(IRawElementProviderSimple *pProvider, PROPERTYID id, VARIANT oldValue, VARIANT newValue)
-{
-    if (!m_pUiaRaiseAutomationPropertyChangedEvent)
-        return UIA_E_NOTSUPPORTED;
-    return m_pUiaRaiseAutomationPropertyChangedEvent(pProvider, id, oldValue, newValue);
-}
-
-HRESULT QWindowsUiaWrapper::raiseAutomationEvent(IRawElementProviderSimple *pProvider, EVENTID id)
-{
-    if (!m_pUiaRaiseAutomationEvent)
-        return UIA_E_NOTSUPPORTED;
-    return m_pUiaRaiseAutomationEvent(pProvider, id);
-}
-
-HRESULT QWindowsUiaWrapper::raiseNotificationEvent(IRawElementProviderSimple *provider, NotificationKind notificationKind, NotificationProcessing notificationProcessing, BSTR displayString, BSTR activityId)
-{
-    if (!m_pUiaRaiseNotificationEvent)
-        return UIA_E_NOTSUPPORTED;
-    return m_pUiaRaiseNotificationEvent(provider, notificationKind, notificationProcessing, displayString, activityId);
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/gui/accessible/windows/apisupport/qwindowsuiawrapper_p.h b/src/gui/accessible/windows/apisupport/qwindowsuiawrapper_p.h
deleted file mode 100644
index 05b93f8393..0000000000
--- a/src/gui/accessible/windows/apisupport/qwindowsuiawrapper_p.h
+++ /dev/null
@@ -1,67 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef QWINDOWSUIAWRAPPER_H
-#define QWINDOWSUIAWRAPPER_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists for the convenience
-// of other Qt classes.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <QtGui/private/qtguiglobal_p.h>
-
-#include "uiatypes_p.h"
-#include "uiaattributeids_p.h"
-#include "uiacontroltypeids_p.h"
-#include "uiaerrorids_p.h"
-#include "uiaeventids_p.h"
-#include "uiageneralids_p.h"
-#include "uiapatternids_p.h"
-#include "uiapropertyids_p.h"
-#include "uiaserverinterfaces_p.h"
-#include "uiaclientinterfaces_p.h"
-
-QT_REQUIRE_CONFIG(accessibility);
-
-QT_BEGIN_NAMESPACE
-
-class Q_GUI_EXPORT QWindowsUiaWrapper
-{
-    QWindowsUiaWrapper();
-    virtual ~QWindowsUiaWrapper();
-public:
-    static QWindowsUiaWrapper *instance();
-    BOOL ready();
-    BOOL clientsAreListening();
-    LRESULT returnRawElementProvider(HWND hwnd, WPARAM wParam, LPARAM lParam, IRawElementProviderSimple *el);
-    HRESULT hostProviderFromHwnd(HWND hwnd, IRawElementProviderSimple **ppProvider);
-    HRESULT raiseAutomationPropertyChangedEvent(IRawElementProviderSimple *pProvider, PROPERTYID id, VARIANT oldValue, VARIANT newValue);
-    HRESULT raiseAutomationEvent(IRawElementProviderSimple *pProvider, EVENTID id);
-    HRESULT raiseNotificationEvent(IRawElementProviderSimple *provider, NotificationKind notificationKind, NotificationProcessing notificationProcessing, BSTR displayString, BSTR activityId);
-
-private:
-    typedef LRESULT (WINAPI *PtrUiaReturnRawElementProvider)(HWND, WPARAM, LPARAM, IRawElementProviderSimple *);
-    typedef HRESULT (WINAPI *PtrUiaHostProviderFromHwnd)(HWND, IRawElementProviderSimple **);
-    typedef HRESULT (WINAPI *PtrUiaRaiseAutomationPropertyChangedEvent)(IRawElementProviderSimple *, PROPERTYID, VARIANT, VARIANT);
-    typedef HRESULT (WINAPI *PtrUiaRaiseAutomationEvent)(IRawElementProviderSimple *, EVENTID);
-    typedef HRESULT (WINAPI *PtrUiaRaiseNotificationEvent)(IRawElementProviderSimple *, NotificationKind, NotificationProcessing, BSTR, BSTR);
-    typedef BOOL (WINAPI *PtrUiaClientsAreListening)();
-    PtrUiaReturnRawElementProvider             m_pUiaReturnRawElementProvider = nullptr;
-    PtrUiaHostProviderFromHwnd                 m_pUiaHostProviderFromHwnd = nullptr;
-    PtrUiaRaiseAutomationPropertyChangedEvent  m_pUiaRaiseAutomationPropertyChangedEvent = nullptr;
-    PtrUiaRaiseAutomationEvent                 m_pUiaRaiseAutomationEvent = nullptr;
-    PtrUiaRaiseNotificationEvent               m_pUiaRaiseNotificationEvent = nullptr;
-    PtrUiaClientsAreListening                  m_pUiaClientsAreListening = nullptr;
-};
-
-QT_END_NAMESPACE
-
-#endif //QWINDOWSUIAWRAPPER_H
-
diff --git a/src/gui/accessible/windows/apisupport/uiaattributeids_p.h b/src/gui/accessible/windows/apisupport/uiaattributeids_p.h
deleted file mode 100644
index 2078351a98..0000000000
--- a/src/gui/accessible/windows/apisupport/uiaattributeids_p.h
+++ /dev/null
@@ -1,63 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIAATTRIBUTEIDS_H
-#define UIAATTRIBUTEIDS_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#define UIA_AnimationStyleAttributeId            40000
-#define UIA_BackgroundColorAttributeId           40001
-#define UIA_BulletStyleAttributeId               40002
-#define UIA_CapStyleAttributeId                  40003
-#define UIA_CultureAttributeId                   40004
-#define UIA_FontNameAttributeId                  40005
-#define UIA_FontSizeAttributeId                  40006
-#define UIA_FontWeightAttributeId                40007
-#define UIA_ForegroundColorAttributeId           40008
-#define UIA_HorizontalTextAlignmentAttributeId   40009
-#define UIA_IndentationFirstLineAttributeId      40010
-#define UIA_IndentationLeadingAttributeId        40011
-#define UIA_IndentationTrailingAttributeId       40012
-#define UIA_IsHiddenAttributeId                  40013
-#define UIA_IsItalicAttributeId                  40014
-#define UIA_IsReadOnlyAttributeId                40015
-#define UIA_IsSubscriptAttributeId               40016
-#define UIA_IsSuperscriptAttributeId             40017
-#define UIA_MarginBottomAttributeId              40018
-#define UIA_MarginLeadingAttributeId             40019
-#define UIA_MarginTopAttributeId                 40020
-#define UIA_MarginTrailingAttributeId            40021
-#define UIA_OutlineStylesAttributeId             40022
-#define UIA_OverlineColorAttributeId             40023
-#define UIA_OverlineStyleAttributeId             40024
-#define UIA_StrikethroughColorAttributeId        40025
-#define UIA_StrikethroughStyleAttributeId        40026
-#define UIA_TabsAttributeId                      40027
-#define UIA_TextFlowDirectionsAttributeId        40028
-#define UIA_UnderlineColorAttributeId            40029
-#define UIA_UnderlineStyleAttributeId            40030
-#define UIA_AnnotationTypesAttributeId           40031
-#define UIA_AnnotationObjectsAttributeId         40032
-#define UIA_StyleNameAttributeId                 40033
-#define UIA_StyleIdAttributeId                   40034
-#define UIA_LinkAttributeId                      40035
-#define UIA_IsActiveAttributeId                  40036
-#define UIA_SelectionActiveEndAttributeId        40037
-#define UIA_CaretPositionAttributeId             40038
-#define UIA_CaretBidiModeAttributeId             40039
-#define UIA_LineSpacingAttributeId               40040
-#define UIA_BeforeParagraphSpacingAttributeId    40041
-#define UIA_AfterParagraphSpacingAttributeId     40042
-#define UIA_SayAsInterpretAsAttributeId          40043
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiaclientinterfaces_p.h b/src/gui/accessible/windows/apisupport/uiaclientinterfaces_p.h
deleted file mode 100644
index fb74042bfa..0000000000
--- a/src/gui/accessible/windows/apisupport/uiaclientinterfaces_p.h
+++ /dev/null
@@ -1,230 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIACLIENTINTERFACES_H
-#define UIACLIENTINTERFACES_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <unknwn.h>
-
-#ifndef __IUIAutomationElement_INTERFACE_DEFINED__
-
-struct IUIAutomationCondition;
-struct IUIAutomationCacheRequest;
-struct IUIAutomationElementArray;
-struct IUIAutomationTreeWalker;
-struct IUIAutomationEventHandler;
-struct IUIAutomationPropertyChangedEventHandler;
-struct IUIAutomationStructureChangedEventHandler;
-struct IUIAutomationFocusChangedEventHandler;
-struct IUIAutomationProxyFactory;
-struct IUIAutomationProxyFactoryEntry;
-struct IUIAutomationProxyFactoryMapping;
-#ifndef __IAccessible_FWD_DEFINED__
-#define __IAccessible_FWD_DEFINED__
-struct IAccessible;
-#endif   /* __IAccessible_FWD_DEFINED__ */
-
-#define __IUIAutomationElement_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IUIAutomationElement, 0xd22108aa, 0x8ac5, 0x49a5, 0x83,0x7b, 0x37,0xbb,0xb3,0xd7,0x59,0x1e);
-MIDL_INTERFACE("d22108aa-8ac5-49a5-837b-37bbb3d7591e")
-IUIAutomationElement : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE SetFocus() = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetRuntimeId(__RPC__deref_out_opt SAFEARRAY **runtimeId) = 0;
-    virtual HRESULT STDMETHODCALLTYPE FindFirst(enum TreeScope scope, __RPC__in_opt IUIAutomationCondition *condition, __RPC__deref_out_opt IUIAutomationElement **found) = 0;
-    virtual HRESULT STDMETHODCALLTYPE FindAll(enum TreeScope scope, __RPC__in_opt IUIAutomationCondition *condition, __RPC__deref_out_opt IUIAutomationElementArray **found) = 0;
-    virtual HRESULT STDMETHODCALLTYPE FindFirstBuildCache(enum TreeScope scope, __RPC__in_opt IUIAutomationCondition *condition, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **found) = 0;
-    virtual HRESULT STDMETHODCALLTYPE FindAllBuildCache(enum TreeScope scope, __RPC__in_opt IUIAutomationCondition *condition, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElementArray **found) = 0;
-    virtual HRESULT STDMETHODCALLTYPE BuildUpdatedCache(__RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **updatedElement) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCurrentPropertyValue(PROPERTYID propertyId, __RPC__out VARIANT *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCurrentPropertyValueEx(PROPERTYID propertyId, BOOL ignoreDefaultValue, __RPC__out VARIANT *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCachedPropertyValue(PROPERTYID propertyId, __RPC__out VARIANT *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCachedPropertyValueEx(PROPERTYID propertyId, BOOL ignoreDefaultValue, __RPC__out VARIANT *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCurrentPatternAs(PATTERNID patternId, __RPC__in REFIID riid, __RPC__deref_out_opt void **patternObject) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCachedPatternAs(PATTERNID patternId, __RPC__in REFIID riid, __RPC__deref_out_opt void **patternObject) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCurrentPattern(PATTERNID patternId, __RPC__deref_out_opt IUnknown **patternObject) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCachedPattern(PATTERNID patternId, __RPC__deref_out_opt IUnknown **patternObject) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCachedParent(__RPC__deref_out_opt IUIAutomationElement **parent) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCachedChildren(__RPC__deref_out_opt IUIAutomationElementArray **children) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentProcessId(__RPC__out int *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentControlType(__RPC__out CONTROLTYPEID *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentLocalizedControlType(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentName(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentAcceleratorKey(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentAccessKey(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentHasKeyboardFocus(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentIsKeyboardFocusable(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentIsEnabled(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentAutomationId(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentClassName(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentHelpText(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentCulture(__RPC__out int *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentIsControlElement(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentIsContentElement(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentIsPassword(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentNativeWindowHandle(__RPC__deref_out_opt UIA_HWND *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentItemType(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentIsOffscreen(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentOrientation(__RPC__out enum OrientationType *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentFrameworkId(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentIsRequiredForForm(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentItemStatus(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentBoundingRectangle(__RPC__out RECT *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentLabeledBy(__RPC__deref_out_opt IUIAutomationElement **retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentAriaRole(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentAriaProperties(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentIsDataValidForForm(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentControllerFor(__RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentDescribedBy(__RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentFlowsTo(__RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CurrentProviderDescription(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedProcessId(__RPC__out int *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedControlType(__RPC__out CONTROLTYPEID *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedLocalizedControlType(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedName(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedAcceleratorKey(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedAccessKey(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedHasKeyboardFocus(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedIsKeyboardFocusable(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedIsEnabled(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedAutomationId(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedClassName(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedHelpText(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedCulture(__RPC__out int *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedIsControlElement(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedIsContentElement(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedIsPassword(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedNativeWindowHandle(__RPC__deref_out_opt UIA_HWND *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedItemType(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedIsOffscreen(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedOrientation(__RPC__out enum OrientationType *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedFrameworkId(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedIsRequiredForForm(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedItemStatus(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedBoundingRectangle(__RPC__out RECT *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedLabeledBy(__RPC__deref_out_opt IUIAutomationElement **retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedAriaRole(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedAriaProperties(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedIsDataValidForForm(__RPC__out BOOL *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedControllerFor(__RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedDescribedBy(__RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedFlowsTo(__RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CachedProviderDescription(__RPC__deref_out_opt BSTR *retVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetClickablePoint(__RPC__out POINT *clickable, __RPC__out BOOL *gotClickable) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IUIAutomationElement, 0xd22108aa, 0x8ac5, 0x49a5, 0x83,0x7b, 0x37,0xbb,0xb3,0xd7,0x59,0x1e)
-#endif
-#endif
-
-
-#ifndef __IUIAutomation_INTERFACE_DEFINED__
-#define __IUIAutomation_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IUIAutomation, 0x30cbe57d, 0xd9d0, 0x452a, 0xab,0x13, 0x7a,0xc5,0xac,0x48,0x25,0xee);
-MIDL_INTERFACE("30cbe57d-d9d0-452a-ab13-7ac5ac4825ee")
-IUIAutomation : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE CompareElements(__RPC__in_opt IUIAutomationElement *el1, __RPC__in_opt IUIAutomationElement *el2, __RPC__out BOOL *areSame) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CompareRuntimeIds(__RPC__in SAFEARRAY * runtimeId1, __RPC__in SAFEARRAY * runtimeId2, __RPC__out BOOL *areSame) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetRootElement(__RPC__deref_out_opt IUIAutomationElement **root) = 0;
-    virtual HRESULT STDMETHODCALLTYPE ElementFromHandle(__RPC__in UIA_HWND hwnd, __RPC__deref_out_opt IUIAutomationElement **element) = 0;
-    virtual HRESULT STDMETHODCALLTYPE ElementFromPoint(POINT pt, __RPC__deref_out_opt IUIAutomationElement **element) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetFocusedElement(__RPC__deref_out_opt IUIAutomationElement **element) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetRootElementBuildCache(__RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **root) = 0;
-    virtual HRESULT STDMETHODCALLTYPE ElementFromHandleBuildCache(__RPC__in UIA_HWND hwnd, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **element) = 0;
-    virtual HRESULT STDMETHODCALLTYPE ElementFromPointBuildCache(POINT pt, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **element) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetFocusedElementBuildCache(__RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **element) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateTreeWalker(__RPC__in_opt IUIAutomationCondition *pCondition, __RPC__deref_out_opt IUIAutomationTreeWalker **walker) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ControlViewWalker(__RPC__deref_out_opt IUIAutomationTreeWalker **walker) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ContentViewWalker(__RPC__deref_out_opt IUIAutomationTreeWalker **walker) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_RawViewWalker(__RPC__deref_out_opt IUIAutomationTreeWalker **walker) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_RawViewCondition(__RPC__deref_out_opt IUIAutomationCondition **condition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ControlViewCondition(__RPC__deref_out_opt IUIAutomationCondition **condition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ContentViewCondition(__RPC__deref_out_opt IUIAutomationCondition **condition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateCacheRequest(__RPC__deref_out_opt IUIAutomationCacheRequest **cacheRequest) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateTrueCondition(__RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateFalseCondition(__RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreatePropertyCondition(PROPERTYID propertyId, VARIANT value, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreatePropertyConditionEx(PROPERTYID propertyId, VARIANT value, enum PropertyConditionFlags flags, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateAndCondition(__RPC__in_opt IUIAutomationCondition *condition1, __RPC__in_opt IUIAutomationCondition *condition2, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateAndConditionFromArray(__RPC__in_opt SAFEARRAY * conditions, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateAndConditionFromNativeArray(__RPC__in_ecount_full(conditionCount) IUIAutomationCondition **conditions, int conditionCount, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateOrCondition(__RPC__in_opt IUIAutomationCondition *condition1, __RPC__in_opt IUIAutomationCondition *condition2, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateOrConditionFromArray(__RPC__in_opt SAFEARRAY * conditions, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateOrConditionFromNativeArray(__RPC__in_ecount_full(conditionCount) IUIAutomationCondition **conditions, int conditionCount, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateNotCondition(__RPC__in_opt IUIAutomationCondition *condition, __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
-    virtual HRESULT STDMETHODCALLTYPE AddAutomationEventHandler(EVENTID eventId, __RPC__in_opt IUIAutomationElement *element, enum TreeScope scope, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__in_opt IUIAutomationEventHandler *handler) = 0;
-    virtual HRESULT STDMETHODCALLTYPE RemoveAutomationEventHandler(EVENTID eventId, __RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationEventHandler *handler) = 0;
-    virtual HRESULT STDMETHODCALLTYPE AddPropertyChangedEventHandlerNativeArray(__RPC__in_opt IUIAutomationElement *element, enum TreeScope scope, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__in_opt IUIAutomationPropertyChangedEventHandler *handler, __RPC__in_ecount_full(propertyCount) PROPERTYID *propertyArray, int propertyCount) = 0;
-    virtual HRESULT STDMETHODCALLTYPE AddPropertyChangedEventHandler(__RPC__in_opt IUIAutomationElement *element, enum TreeScope scope, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__in_opt IUIAutomationPropertyChangedEventHandler *handler, __RPC__in SAFEARRAY * propertyArray) = 0;
-    virtual HRESULT STDMETHODCALLTYPE RemovePropertyChangedEventHandler(__RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationPropertyChangedEventHandler *handler) = 0;
-    virtual HRESULT STDMETHODCALLTYPE AddStructureChangedEventHandler(__RPC__in_opt IUIAutomationElement *element, enum TreeScope scope, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__in_opt IUIAutomationStructureChangedEventHandler *handler) = 0;
-    virtual HRESULT STDMETHODCALLTYPE RemoveStructureChangedEventHandler(__RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationStructureChangedEventHandler *handler) = 0;
-    virtual HRESULT STDMETHODCALLTYPE AddFocusChangedEventHandler(__RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__in_opt IUIAutomationFocusChangedEventHandler *handler) = 0;
-    virtual HRESULT STDMETHODCALLTYPE RemoveFocusChangedEventHandler(__RPC__in_opt IUIAutomationFocusChangedEventHandler *handler) = 0;
-    virtual HRESULT STDMETHODCALLTYPE RemoveAllEventHandlers() = 0;
-    virtual HRESULT STDMETHODCALLTYPE IntNativeArrayToSafeArray(__RPC__in_ecount_full(arrayCount) int *array, int arrayCount, __RPC__deref_out_opt SAFEARRAY **safeArray) = 0;
-    virtual HRESULT STDMETHODCALLTYPE IntSafeArrayToNativeArray(__RPC__in SAFEARRAY * intArray, __RPC__deref_out_ecount_full_opt(*arrayCount) int **array, __RPC__out int *arrayCount) = 0;
-    virtual HRESULT STDMETHODCALLTYPE RectToVariant(RECT rc, __RPC__out VARIANT *var) = 0;
-    virtual HRESULT STDMETHODCALLTYPE VariantToRect(VARIANT var, __RPC__out RECT *rc) = 0;
-    virtual HRESULT STDMETHODCALLTYPE SafeArrayToRectNativeArray(__RPC__in SAFEARRAY * rects, __RPC__deref_out_ecount_full_opt(*rectArrayCount) RECT **rectArray, __RPC__out int *rectArrayCount) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CreateProxyFactoryEntry(__RPC__in_opt IUIAutomationProxyFactory *factory, __RPC__deref_out_opt IUIAutomationProxyFactoryEntry **factoryEntry) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ProxyFactoryMapping(__RPC__deref_out_opt IUIAutomationProxyFactoryMapping **factoryMapping) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetPropertyProgrammaticName(PROPERTYID property, __RPC__deref_out_opt BSTR *name) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetPatternProgrammaticName(PATTERNID pattern, __RPC__deref_out_opt BSTR *name) = 0;
-    virtual HRESULT STDMETHODCALLTYPE PollForPotentialSupportedPatterns(__RPC__in_opt IUIAutomationElement *pElement, __RPC__deref_out_opt SAFEARRAY **patternIds, __RPC__deref_out_opt SAFEARRAY **patternNames) = 0;
-    virtual HRESULT STDMETHODCALLTYPE PollForPotentialSupportedProperties(__RPC__in_opt IUIAutomationElement *pElement, __RPC__deref_out_opt SAFEARRAY **propertyIds, __RPC__deref_out_opt SAFEARRAY **propertyNames) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CheckNotSupported(VARIANT value, __RPC__out BOOL *isNotSupported) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ReservedNotSupportedValue(__RPC__deref_out_opt IUnknown **notSupportedValue) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ReservedMixedAttributeValue(__RPC__deref_out_opt IUnknown **mixedAttributeValue) = 0;
-    virtual HRESULT STDMETHODCALLTYPE ElementFromIAccessible(__RPC__in_opt IAccessible *accessible, int childId, __RPC__deref_out_opt IUIAutomationElement **element) = 0;
-    virtual HRESULT STDMETHODCALLTYPE ElementFromIAccessibleBuildCache(__RPC__in_opt IAccessible *accessible, int childId, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **element) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IUIAutomation, 0x30cbe57d, 0xd9d0, 0x452a, 0xab,0x13, 0x7a,0xc5,0xac,0x48,0x25,0xee)
-#endif
-#endif
-
-
-#ifndef __IUIAutomationTreeWalker_INTERFACE_DEFINED__
-#define __IUIAutomationTreeWalker_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IUIAutomationTreeWalker, 0x4042c624, 0x389c, 0x4afc, 0xa6,0x30, 0x9d,0xf8,0x54,0xa5,0x41,0xfc);
-MIDL_INTERFACE("4042c624-389c-4afc-a630-9df854a541fc")
-IUIAutomationTreeWalker : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE GetParentElement(__RPC__in_opt IUIAutomationElement *element, __RPC__deref_out_opt IUIAutomationElement **parent) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetFirstChildElement(__RPC__in_opt IUIAutomationElement *element, __RPC__deref_out_opt IUIAutomationElement **first) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetLastChildElement(__RPC__in_opt IUIAutomationElement *element, __RPC__deref_out_opt IUIAutomationElement **last) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetNextSiblingElement(__RPC__in_opt IUIAutomationElement *element, __RPC__deref_out_opt IUIAutomationElement **next) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetPreviousSiblingElement(__RPC__in_opt IUIAutomationElement *element, __RPC__deref_out_opt IUIAutomationElement **previous) = 0;
-    virtual HRESULT STDMETHODCALLTYPE NormalizeElement(__RPC__in_opt IUIAutomationElement *element, __RPC__deref_out_opt IUIAutomationElement **normalized) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetParentElementBuildCache(__RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **parent) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetFirstChildElementBuildCache(__RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **first) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetLastChildElementBuildCache(__RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **last) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetNextSiblingElementBuildCache(__RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **next) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetPreviousSiblingElementBuildCache(__RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **previous) = 0;
-    virtual HRESULT STDMETHODCALLTYPE NormalizeElementBuildCache(__RPC__in_opt IUIAutomationElement *element, __RPC__in_opt IUIAutomationCacheRequest *cacheRequest, __RPC__deref_out_opt IUIAutomationElement **normalized) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_Condition(__RPC__deref_out_opt IUIAutomationCondition **condition) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IUIAutomationTreeWalker, 0x4042c624, 0x389c, 0x4afc, 0xa6,0x30, 0x9d,0xf8,0x54,0xa5,0x41,0xfc)
-#endif
-#endif
-
-DEFINE_GUID(CLSID_CUIAutomation, 0xff48dba4, 0x60ef, 0x4201, 0xaa,0x87, 0x54,0x10,0x3e,0xef,0x59,0x4e);
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiacontroltypeids_p.h b/src/gui/accessible/windows/apisupport/uiacontroltypeids_p.h
deleted file mode 100644
index 21d8080bc2..0000000000
--- a/src/gui/accessible/windows/apisupport/uiacontroltypeids_p.h
+++ /dev/null
@@ -1,60 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIACONTROLTYPEIDS_H
-#define UIACONTROLTYPEIDS_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#define UIA_ButtonControlTypeId         50000
-#define UIA_CalendarControlTypeId       50001
-#define UIA_CheckBoxControlTypeId       50002
-#define UIA_ComboBoxControlTypeId       50003
-#define UIA_EditControlTypeId           50004
-#define UIA_HyperlinkControlTypeId      50005
-#define UIA_ImageControlTypeId          50006
-#define UIA_ListItemControlTypeId       50007
-#define UIA_ListControlTypeId           50008
-#define UIA_MenuControlTypeId           50009
-#define UIA_MenuBarControlTypeId        50010
-#define UIA_MenuItemControlTypeId       50011
-#define UIA_ProgressBarControlTypeId    50012
-#define UIA_RadioButtonControlTypeId    50013
-#define UIA_ScrollBarControlTypeId      50014
-#define UIA_SliderControlTypeId         50015
-#define UIA_SpinnerControlTypeId        50016
-#define UIA_StatusBarControlTypeId      50017
-#define UIA_TabControlTypeId            50018
-#define UIA_TabItemControlTypeId        50019
-#define UIA_TextControlTypeId           50020
-#define UIA_ToolBarControlTypeId        50021
-#define UIA_ToolTipControlTypeId        50022
-#define UIA_TreeControlTypeId           50023
-#define UIA_TreeItemControlTypeId       50024
-#define UIA_CustomControlTypeId         50025
-#define UIA_GroupControlTypeId          50026
-#define UIA_ThumbControlTypeId          50027
-#define UIA_DataGridControlTypeId       50028
-#define UIA_DataItemControlTypeId       50029
-#define UIA_DocumentControlTypeId       50030
-#define UIA_SplitButtonControlTypeId    50031
-#define UIA_WindowControlTypeId         50032
-#define UIA_PaneControlTypeId           50033
-#define UIA_HeaderControlTypeId         50034
-#define UIA_HeaderItemControlTypeId     50035
-#define UIA_TableControlTypeId          50036
-#define UIA_TitleBarControlTypeId       50037
-#define UIA_SeparatorControlTypeId      50038
-#define UIA_SemanticZoomControlTypeId   50039
-#define UIA_AppBarControlTypeId         50040
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiaerrorids_p.h b/src/gui/accessible/windows/apisupport/uiaerrorids_p.h
deleted file mode 100644
index b965fe5c30..0000000000
--- a/src/gui/accessible/windows/apisupport/uiaerrorids_p.h
+++ /dev/null
@@ -1,26 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIAERRORIDS_H
-#define UIAERRORIDS_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#define UIA_E_ELEMENTNOTENABLED      0x80040200
-#define UIA_E_ELEMENTNOTAVAILABLE    0x80040201
-#define UIA_E_NOCLICKABLEPOINT       0x80040202
-#define UIA_E_PROXYASSEMBLYNOTLOADED 0x80040203
-#define UIA_E_NOTSUPPORTED           0x80040204
-#define UIA_E_INVALIDOPERATION       0x80131509
-#define UIA_E_TIMEOUT                0x80131505
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiaeventids_p.h b/src/gui/accessible/windows/apisupport/uiaeventids_p.h
deleted file mode 100644
index 7ac6d85ec5..0000000000
--- a/src/gui/accessible/windows/apisupport/uiaeventids_p.h
+++ /dev/null
@@ -1,54 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIAEVENTIDS_H
-#define UIAEVENTIDS_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#define UIA_ToolTipOpenedEventId                                20000
-#define UIA_ToolTipClosedEventId                                20001
-#define UIA_StructureChangedEventId                             20002
-#define UIA_MenuOpenedEventId                                   20003
-#define UIA_AutomationPropertyChangedEventId                    20004
-#define UIA_AutomationFocusChangedEventId                       20005
-#define UIA_AsyncContentLoadedEventId                           20006
-#define UIA_MenuClosedEventId                                   20007
-#define UIA_LayoutInvalidatedEventId                            20008
-#define UIA_Invoke_InvokedEventId                               20009
-#define UIA_SelectionItem_ElementAddedToSelectionEventId        20010
-#define UIA_SelectionItem_ElementRemovedFromSelectionEventId    20011
-#define UIA_SelectionItem_ElementSelectedEventId                20012
-#define UIA_Selection_InvalidatedEventId                        20013
-#define UIA_Text_TextSelectionChangedEventId                    20014
-#define UIA_Text_TextChangedEventId                             20015
-#define UIA_Window_WindowOpenedEventId                          20016
-#define UIA_Window_WindowClosedEventId                          20017
-#define UIA_MenuModeStartEventId                                20018
-#define UIA_MenuModeEndEventId                                  20019
-#define UIA_InputReachedTargetEventId                           20020
-#define UIA_InputReachedOtherElementEventId                     20021
-#define UIA_InputDiscardedEventId                               20022
-#define UIA_SystemAlertEventId                                  20023
-#define UIA_LiveRegionChangedEventId                            20024
-#define UIA_HostedFragmentRootsInvalidatedEventId               20025
-#define UIA_Drag_DragStartEventId                               20026
-#define UIA_Drag_DragCancelEventId                              20027
-#define UIA_Drag_DragCompleteEventId                            20028
-#define UIA_DropTarget_DragEnterEventId                         20029
-#define UIA_DropTarget_DragLeaveEventId                         20030
-#define UIA_DropTarget_DroppedEventId                           20031
-#define UIA_TextEdit_TextChangedEventId                         20032
-#define UIA_TextEdit_ConversionTargetChangedEventId             20033
-#define UIA_ChangesEventId                                      20034
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiageneralids_p.h b/src/gui/accessible/windows/apisupport/uiageneralids_p.h
deleted file mode 100644
index a6fdeceee3..0000000000
--- a/src/gui/accessible/windows/apisupport/uiageneralids_p.h
+++ /dev/null
@@ -1,21 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIAGENERALIDS_H
-#define UIAGENERALIDS_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#define UiaAppendRuntimeId       3
-#define UiaRootObjectId        -25
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiapatternids_p.h b/src/gui/accessible/windows/apisupport/uiapatternids_p.h
deleted file mode 100644
index 0ff463cd36..0000000000
--- a/src/gui/accessible/windows/apisupport/uiapatternids_p.h
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIAPATTERNIDS_H
-#define UIAPATTERNIDS_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#define UIA_InvokePatternId             10000
-#define UIA_SelectionPatternId          10001
-#define UIA_ValuePatternId              10002
-#define UIA_RangeValuePatternId         10003
-#define UIA_ScrollPatternId             10004
-#define UIA_ExpandCollapsePatternId     10005
-#define UIA_GridPatternId               10006
-#define UIA_GridItemPatternId           10007
-#define UIA_MultipleViewPatternId       10008
-#define UIA_WindowPatternId             10009
-#define UIA_SelectionItemPatternId      10010
-#define UIA_DockPatternId               10011
-#define UIA_TablePatternId              10012
-#define UIA_TableItemPatternId          10013
-#define UIA_TextPatternId               10014
-#define UIA_TogglePatternId             10015
-#define UIA_TransformPatternId          10016
-#define UIA_ScrollItemPatternId         10017
-#define UIA_LegacyIAccessiblePatternId  10018
-#define UIA_ItemContainerPatternId      10019
-#define UIA_VirtualizedItemPatternId    10020
-#define UIA_SynchronizedInputPatternId  10021
-#define UIA_ObjectModelPatternId        10022
-#define UIA_AnnotationPatternId         10023
-#define UIA_TextPattern2Id              10024
-#define UIA_StylesPatternId             10025
-#define UIA_SpreadsheetPatternId        10026
-#define UIA_SpreadsheetItemPatternId    10027
-#define UIA_TransformPattern2Id         10028
-#define UIA_TextChildPatternId          10029
-#define UIA_DragPatternId               10030
-#define UIA_DropTargetPatternId         10031
-#define UIA_TextEditPatternId           10032
-#define UIA_CustomNavigationPatternId   10033
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiapropertyids_p.h b/src/gui/accessible/windows/apisupport/uiapropertyids_p.h
deleted file mode 100644
index 77fc454e0f..0000000000
--- a/src/gui/accessible/windows/apisupport/uiapropertyids_p.h
+++ /dev/null
@@ -1,188 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIAPROPERTYIDS_H
-#define UIAPROPERTYIDS_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#define UIA_RuntimeIdPropertyId                                30000
-#define UIA_BoundingRectanglePropertyId                        30001
-#define UIA_ProcessIdPropertyId                                30002
-#define UIA_ControlTypePropertyId                              30003
-#define UIA_LocalizedControlTypePropertyId                     30004
-#define UIA_NamePropertyId                                     30005
-#define UIA_AcceleratorKeyPropertyId                           30006
-#define UIA_AccessKeyPropertyId                                30007
-#define UIA_HasKeyboardFocusPropertyId                         30008
-#define UIA_IsKeyboardFocusablePropertyId                      30009
-#define UIA_IsEnabledPropertyId                                30010
-#define UIA_AutomationIdPropertyId                             30011
-#define UIA_ClassNamePropertyId                                30012
-#define UIA_HelpTextPropertyId                                 30013
-#define UIA_ClickablePointPropertyId                           30014
-#define UIA_CulturePropertyId                                  30015
-#define UIA_IsControlElementPropertyId                         30016
-#define UIA_IsContentElementPropertyId                         30017
-#define UIA_LabeledByPropertyId                                30018
-#define UIA_IsPasswordPropertyId                               30019
-#define UIA_NativeWindowHandlePropertyId                       30020
-#define UIA_ItemTypePropertyId                                 30021
-#define UIA_IsOffscreenPropertyId                              30022
-#define UIA_OrientationPropertyId                              30023
-#define UIA_FrameworkIdPropertyId                              30024
-#define UIA_IsRequiredForFormPropertyId                        30025
-#define UIA_ItemStatusPropertyId                               30026
-#define UIA_IsDockPatternAvailablePropertyId                   30027
-#define UIA_IsExpandCollapsePatternAvailablePropertyId         30028
-#define UIA_IsGridItemPatternAvailablePropertyId               30029
-#define UIA_IsGridPatternAvailablePropertyId                   30030
-#define UIA_IsInvokePatternAvailablePropertyId                 30031
-#define UIA_IsMultipleViewPatternAvailablePropertyId           30032
-#define UIA_IsRangeValuePatternAvailablePropertyId             30033
-#define UIA_IsScrollPatternAvailablePropertyId                 30034
-#define UIA_IsScrollItemPatternAvailablePropertyId             30035
-#define UIA_IsSelectionItemPatternAvailablePropertyId          30036
-#define UIA_IsSelectionPatternAvailablePropertyId              30037
-#define UIA_IsTablePatternAvailablePropertyId                  30038
-#define UIA_IsTableItemPatternAvailablePropertyId              30039
-#define UIA_IsTextPatternAvailablePropertyId                   30040
-#define UIA_IsTogglePatternAvailablePropertyId                 30041
-#define UIA_IsTransformPatternAvailablePropertyId              30042
-#define UIA_IsValuePatternAvailablePropertyId                  30043
-#define UIA_IsWindowPatternAvailablePropertyId                 30044
-#define UIA_ValueValuePropertyId                               30045
-#define UIA_ValueIsReadOnlyPropertyId                          30046
-#define UIA_RangeValueValuePropertyId                          30047
-#define UIA_RangeValueIsReadOnlyPropertyId                     30048
-#define UIA_RangeValueMinimumPropertyId                        30049
-#define UIA_RangeValueMaximumPropertyId                        30050
-#define UIA_RangeValueLargeChangePropertyId                    30051
-#define UIA_RangeValueSmallChangePropertyId                    30052
-#define UIA_ScrollHorizontalScrollPercentPropertyId            30053
-#define UIA_ScrollHorizontalViewSizePropertyId                 30054
-#define UIA_ScrollVerticalScrollPercentPropertyId              30055
-#define UIA_ScrollVerticalViewSizePropertyId                   30056
-#define UIA_ScrollHorizontallyScrollablePropertyId             30057
-#define UIA_ScrollVerticallyScrollablePropertyId               30058
-#define UIA_SelectionSelectionPropertyId                       30059
-#define UIA_SelectionCanSelectMultiplePropertyId               30060
-#define UIA_SelectionIsSelectionRequiredPropertyId             30061
-#define UIA_GridRowCountPropertyId                             30062
-#define UIA_GridColumnCountPropertyId                          30063
-#define UIA_GridItemRowPropertyId                              30064
-#define UIA_GridItemColumnPropertyId                           30065
-#define UIA_GridItemRowSpanPropertyId                          30066
-#define UIA_GridItemColumnSpanPropertyId                       30067
-#define UIA_GridItemContainingGridPropertyId                   30068
-#define UIA_DockDockPositionPropertyId                         30069
-#define UIA_ExpandCollapseExpandCollapseStatePropertyId        30070
-#define UIA_MultipleViewCurrentViewPropertyId                  30071
-#define UIA_MultipleViewSupportedViewsPropertyId               30072
-#define UIA_WindowCanMaximizePropertyId                        30073
-#define UIA_WindowCanMinimizePropertyId                        30074
-#define UIA_WindowWindowVisualStatePropertyId                  30075
-#define UIA_WindowWindowInteractionStatePropertyId             30076
-#define UIA_WindowIsModalPropertyId                            30077
-#define UIA_WindowIsTopmostPropertyId                          30078
-#define UIA_SelectionItemIsSelectedPropertyId                  30079
-#define UIA_SelectionItemSelectionContainerPropertyId          30080
-#define UIA_TableRowHeadersPropertyId                          30081
-#define UIA_TableColumnHeadersPropertyId                       30082
-#define UIA_TableRowOrColumnMajorPropertyId                    30083
-#define UIA_TableItemRowHeaderItemsPropertyId                  30084
-#define UIA_TableItemColumnHeaderItemsPropertyId               30085
-#define UIA_ToggleToggleStatePropertyId                        30086
-#define UIA_TransformCanMovePropertyId                         30087
-#define UIA_TransformCanResizePropertyId                       30088
-#define UIA_TransformCanRotatePropertyId                       30089
-#define UIA_IsLegacyIAccessiblePatternAvailablePropertyId      30090
-#define UIA_LegacyIAccessibleChildIdPropertyId                 30091
-#define UIA_LegacyIAccessibleNamePropertyId                    30092
-#define UIA_LegacyIAccessibleValuePropertyId                   30093
-#define UIA_LegacyIAccessibleDescriptionPropertyId             30094
-#define UIA_LegacyIAccessibleRolePropertyId                    30095
-#define UIA_LegacyIAccessibleStatePropertyId                   30096
-#define UIA_LegacyIAccessibleHelpPropertyId                    30097
-#define UIA_LegacyIAccessibleKeyboardShortcutPropertyId        30098
-#define UIA_LegacyIAccessibleSelectionPropertyId               30099
-#define UIA_LegacyIAccessibleDefaultActionPropertyId           30100
-#define UIA_AriaRolePropertyId                                 30101
-#define UIA_AriaPropertiesPropertyId                           30102
-#define UIA_IsDataValidForFormPropertyId                       30103
-#define UIA_ControllerForPropertyId                            30104
-#define UIA_DescribedByPropertyId                              30105
-#define UIA_FlowsToPropertyId                                  30106
-#define UIA_ProviderDescriptionPropertyId                      30107
-#define UIA_IsItemContainerPatternAvailablePropertyId          30108
-#define UIA_IsVirtualizedItemPatternAvailablePropertyId        30109
-#define UIA_IsSynchronizedInputPatternAvailablePropertyId      30110
-#define UIA_OptimizeForVisualContentPropertyId                 30111
-#define UIA_IsObjectModelPatternAvailablePropertyId            30112
-#define UIA_AnnotationAnnotationTypeIdPropertyId               30113
-#define UIA_AnnotationAnnotationTypeNamePropertyId             30114
-#define UIA_AnnotationAuthorPropertyId                         30115
-#define UIA_AnnotationDateTimePropertyId                       30116
-#define UIA_AnnotationTargetPropertyId                         30117
-#define UIA_IsAnnotationPatternAvailablePropertyId             30118
-#define UIA_IsTextPattern2AvailablePropertyId                  30119
-#define UIA_StylesStyleIdPropertyId                            30120
-#define UIA_StylesStyleNamePropertyId                          30121
-#define UIA_StylesFillColorPropertyId                          30122
-#define UIA_StylesFillPatternStylePropertyId                   30123
-#define UIA_StylesShapePropertyId                              30124
-#define UIA_StylesFillPatternColorPropertyId                   30125
-#define UIA_StylesExtendedPropertiesPropertyId                 30126
-#define UIA_IsStylesPatternAvailablePropertyId                 30127
-#define UIA_IsSpreadsheetPatternAvailablePropertyId            30128
-#define UIA_SpreadsheetItemFormulaPropertyId                   30129
-#define UIA_SpreadsheetItemAnnotationObjectsPropertyId         30130
-#define UIA_SpreadsheetItemAnnotationTypesPropertyId           30131
-#define UIA_IsSpreadsheetItemPatternAvailablePropertyId        30132
-#define UIA_Transform2CanZoomPropertyId                        30133
-#define UIA_IsTransformPattern2AvailablePropertyId             30134
-#define UIA_LiveSettingPropertyId                              30135
-#define UIA_IsTextChildPatternAvailablePropertyId              30136
-#define UIA_IsDragPatternAvailablePropertyId                   30137
-#define UIA_DragIsGrabbedPropertyId                            30138
-#define UIA_DragDropEffectPropertyId                           30139
-#define UIA_DragDropEffectsPropertyId                          30140
-#define UIA_IsDropTargetPatternAvailablePropertyId             30141
-#define UIA_DropTargetDropTargetEffectPropertyId               30142
-#define UIA_DropTargetDropTargetEffectsPropertyId              30143
-#define UIA_DragGrabbedItemsPropertyId                         30144
-#define UIA_Transform2ZoomLevelPropertyId                      30145
-#define UIA_Transform2ZoomMinimumPropertyId                    30146
-#define UIA_Transform2ZoomMaximumPropertyId                    30147
-#define UIA_FlowsFromPropertyId                                30148
-#define UIA_IsTextEditPatternAvailablePropertyId               30149
-#define UIA_IsPeripheralPropertyId                             30150
-#define UIA_IsCustomNavigationPatternAvailablePropertyId       30151
-#define UIA_PositionInSetPropertyId                            30152
-#define UIA_SizeOfSetPropertyId                                30153
-#define UIA_LevelPropertyId                                    30154
-#define UIA_AnnotationTypesPropertyId                          30155
-#define UIA_AnnotationObjectsPropertyId                        30156
-#define UIA_LandmarkTypePropertyId                             30157
-#define UIA_LocalizedLandmarkTypePropertyId                    30158
-#define UIA_FullDescriptionPropertyId                          30159
-#define UIA_FillColorPropertyId                                30160
-#define UIA_OutlineColorPropertyId                             30161
-#define UIA_FillTypePropertyId                                 30162
-#define UIA_VisualEffectsPropertyId                            30163
-#define UIA_OutlineThicknessPropertyId                         30164
-#define UIA_CenterPointPropertyId                              30165
-#define UIA_RotationPropertyId                                 30166
-#define UIA_SizePropertyId                                     30167
-#define UIA_IsDialogPropertyId                                 30174
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiaserverinterfaces_p.h b/src/gui/accessible/windows/apisupport/uiaserverinterfaces_p.h
deleted file mode 100644
index 6cf15cacb0..0000000000
--- a/src/gui/accessible/windows/apisupport/uiaserverinterfaces_p.h
+++ /dev/null
@@ -1,367 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIASERVERINTERFACES_H
-#define UIASERVERINTERFACES_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <unknwn.h>
-
-#ifndef __IRawElementProviderSimple_INTERFACE_DEFINED__
-#define __IRawElementProviderSimple_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IRawElementProviderSimple, 0xd6dd68d1, 0x86fd, 0x4332, 0x86,0x66, 0x9a,0xbe,0xde,0xa2,0xd2,0x4c);
-MIDL_INTERFACE("d6dd68d1-86fd-4332-8666-9abedea2d24c")
-IRawElementProviderSimple : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE get_ProviderOptions(__RPC__out enum ProviderOptions *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetPatternProvider(PATTERNID patternId, __RPC__deref_out_opt IUnknown **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetPropertyValue(PROPERTYID propertyId, __RPC__out VARIANT *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_HostRawElementProvider(__RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IRawElementProviderSimple, 0xd6dd68d1, 0x86fd, 0x4332, 0x86,0x66, 0x9a,0xbe,0xde,0xa2,0xd2,0x4c)
-#endif
-#endif
-
-
-#ifndef __IRawElementProviderFragmentRoot_FWD_DEFINED__
-#define __IRawElementProviderFragmentRoot_FWD_DEFINED__
-typedef interface IRawElementProviderFragmentRoot IRawElementProviderFragmentRoot;
-#endif
-
-
-#ifndef __IRawElementProviderFragment_FWD_DEFINED__
-#define __IRawElementProviderFragment_FWD_DEFINED__
-typedef interface IRawElementProviderFragment IRawElementProviderFragment;
-#endif
-
-
-#ifndef __IRawElementProviderFragment_INTERFACE_DEFINED__
-#define __IRawElementProviderFragment_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IRawElementProviderFragment, 0xf7063da8, 0x8359, 0x439c, 0x92,0x97, 0xbb,0xc5,0x29,0x9a,0x7d,0x87);
-MIDL_INTERFACE("f7063da8-8359-439c-9297-bbc5299a7d87")
-IRawElementProviderFragment : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE Navigate(enum NavigateDirection direction, __RPC__deref_out_opt IRawElementProviderFragment **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetRuntimeId(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_BoundingRectangle(__RPC__out struct UiaRect *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetEmbeddedFragmentRoots(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE SetFocus() = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_FragmentRoot(__RPC__deref_out_opt IRawElementProviderFragmentRoot **pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IRawElementProviderFragment, 0xf7063da8, 0x8359, 0x439c, 0x92,0x97, 0xbb,0xc5,0x29,0x9a,0x7d,0x87)
-#endif
-#endif
-
-
-#ifndef __IRawElementProviderFragmentRoot_INTERFACE_DEFINED__
-#define __IRawElementProviderFragmentRoot_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IRawElementProviderFragmentRoot, 0x620ce2a5, 0xab8f, 0x40a9, 0x86,0xcb, 0xde,0x3c,0x75,0x59,0x9b,0x58);
-MIDL_INTERFACE("620ce2a5-ab8f-40a9-86cb-de3c75599b58")
-IRawElementProviderFragmentRoot : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE ElementProviderFromPoint(double x, double y, __RPC__deref_out_opt IRawElementProviderFragment **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetFocus(__RPC__deref_out_opt IRawElementProviderFragment **pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IRawElementProviderFragmentRoot, 0x620ce2a5, 0xab8f, 0x40a9, 0x86,0xcb, 0xde,0x3c,0x75,0x59,0x9b,0x58)
-#endif
-#endif
-
-
-#ifndef __IValueProvider_INTERFACE_DEFINED__
-#define __IValueProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IValueProvider, 0xc7935180, 0x6fb3, 0x4201, 0xb1,0x74, 0x7d,0xf7,0x3a,0xdb,0xf6,0x4a);
-MIDL_INTERFACE("c7935180-6fb3-4201-b174-7df73adbf64a")
-IValueProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE SetValue(__RPC__in LPCWSTR val) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_Value(__RPC__deref_out_opt BSTR *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_IsReadOnly(__RPC__out BOOL *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IValueProvider, 0xc7935180, 0x6fb3, 0x4201, 0xb1,0x74, 0x7d,0xf7,0x3a,0xdb,0xf6,0x4a)
-#endif
-#endif
-
-
-#ifndef __IRangeValueProvider_INTERFACE_DEFINED__
-#define __IRangeValueProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IRangeValueProvider, 0x36dc7aef, 0x33e6, 0x4691, 0xaf,0xe1, 0x2b,0xe7,0x27,0x4b,0x3d,0x33);
-MIDL_INTERFACE("36dc7aef-33e6-4691-afe1-2be7274b3d33")
-IRangeValueProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE SetValue(double val) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_Value(__RPC__out double *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_IsReadOnly(__RPC__out BOOL *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_Maximum(__RPC__out double *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_Minimum(__RPC__out double *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_LargeChange(__RPC__out double *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_SmallChange(__RPC__out double *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IRangeValueProvider, 0x36dc7aef, 0x33e6, 0x4691, 0xaf,0xe1, 0x2b,0xe7,0x27,0x4b,0x3d,0x33)
-#endif
-#endif
-
-
-#ifndef __ITextRangeProvider_INTERFACE_DEFINED__
-#define __ITextRangeProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_ITextRangeProvider, 0x5347ad7b, 0xc355, 0x46f8, 0xaf,0xf5, 0x90,0x90,0x33,0x58,0x2f,0x63);
-MIDL_INTERFACE("5347ad7b-c355-46f8-aff5-909033582f63")
-ITextRangeProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE Clone(__RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE Compare(__RPC__in_opt ITextRangeProvider *range, __RPC__out BOOL *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE CompareEndpoints(enum TextPatternRangeEndpoint endpoint, __RPC__in_opt ITextRangeProvider *targetRange, enum TextPatternRangeEndpoint targetEndpoint, __RPC__out int *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE ExpandToEnclosingUnit(enum TextUnit unit) = 0;
-    virtual HRESULT STDMETHODCALLTYPE FindAttribute(TEXTATTRIBUTEID attributeId, VARIANT val, BOOL backward, __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE FindText(__RPC__in BSTR text, BOOL backward, BOOL ignoreCase, __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetAttributeValue(TEXTATTRIBUTEID attributeId, __RPC__out VARIANT *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetBoundingRectangles(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetEnclosingElement(__RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetText(int maxLength, __RPC__deref_out_opt BSTR *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE Move(enum TextUnit unit, int count, __RPC__out int *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE MoveEndpointByUnit(enum TextPatternRangeEndpoint endpoint, enum TextUnit unit, int count, __RPC__out int *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE MoveEndpointByRange(enum TextPatternRangeEndpoint endpoint, __RPC__in_opt ITextRangeProvider *targetRange, enum TextPatternRangeEndpoint targetEndpoint) = 0;
-    virtual HRESULT STDMETHODCALLTYPE Select() = 0;
-    virtual HRESULT STDMETHODCALLTYPE AddToSelection() = 0;
-    virtual HRESULT STDMETHODCALLTYPE RemoveFromSelection() = 0;
-    virtual HRESULT STDMETHODCALLTYPE ScrollIntoView(BOOL alignToTop) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetChildren(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(ITextRangeProvider, 0x5347ad7b, 0xc355, 0x46f8, 0xaf,0xf5, 0x90,0x90,0x33,0x58,0x2f,0x63)
-#endif
-#endif
-
-
-#ifndef __ITextProvider_INTERFACE_DEFINED__
-#define __ITextProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_ITextProvider, 0x3589c92c, 0x63f3, 0x4367, 0x99,0xbb, 0xad,0xa6,0x53,0xb7,0x7c,0xf2);
-MIDL_INTERFACE("3589c92c-63f3-4367-99bb-ada653b77cf2")
-ITextProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE GetSelection(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetVisibleRanges(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE RangeFromChild(__RPC__in_opt IRawElementProviderSimple *childElement, __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE RangeFromPoint(struct UiaPoint point, __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_DocumentRange(__RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_SupportedTextSelection(__RPC__out enum SupportedTextSelection *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(ITextProvider, 0x3589c92c, 0x63f3, 0x4367, 0x99,0xbb, 0xad,0xa6,0x53,0xb7,0x7c,0xf2)
-#endif
-#endif
-
-
-#ifndef __ITextProvider2_INTERFACE_DEFINED__
-#define __ITextProvider2_INTERFACE_DEFINED__
-DEFINE_GUID(IID_ITextProvider2, 0x0dc5e6ed, 0x3e16, 0x4bf1, 0x8f,0x9a, 0xa9,0x79,0x87,0x8b,0xc1,0x95);
-MIDL_INTERFACE("0dc5e6ed-3e16-4bf1-8f9a-a979878bc195")
-ITextProvider2 : public ITextProvider
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE RangeFromAnnotation(__RPC__in_opt IRawElementProviderSimple *annotationElement, __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetCaretRange(__RPC__out BOOL *isActive, __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(ITextProvider2, 0x0dc5e6ed, 0x3e16, 0x4bf1, 0x8f,0x9a, 0xa9,0x79,0x87,0x8b,0xc1,0x95)
-#endif
-#endif
-
-
-#ifndef __IToggleProvider_INTERFACE_DEFINED__
-#define __IToggleProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IToggleProvider, 0x56d00bd0, 0xc4f4, 0x433c, 0xa8,0x36, 0x1a,0x52,0xa5,0x7e,0x08,0x92);
-MIDL_INTERFACE("56d00bd0-c4f4-433c-a836-1a52a57e0892")
-IToggleProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE Toggle() = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ToggleState(__RPC__out enum ToggleState *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IToggleProvider, 0x56d00bd0, 0xc4f4, 0x433c, 0xa8,0x36, 0x1a,0x52,0xa5,0x7e,0x08,0x92)
-#endif
-#endif
-
-
-#ifndef __IInvokeProvider_INTERFACE_DEFINED__
-#define __IInvokeProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IInvokeProvider, 0x54fcb24b, 0xe18e, 0x47a2, 0xb4,0xd3, 0xec,0xcb,0xe7,0x75,0x99,0xa2);
-MIDL_INTERFACE("54fcb24b-e18e-47a2-b4d3-eccbe77599a2")
-IInvokeProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE Invoke() = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IInvokeProvider, 0x54fcb24b, 0xe18e, 0x47a2, 0xb4,0xd3, 0xec,0xcb,0xe7,0x75,0x99,0xa2)
-#endif
-#endif
-
-
-#ifndef __ISelectionProvider_INTERFACE_DEFINED__
-#define __ISelectionProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_ISelectionProvider, 0xfb8b03af, 0x3bdf, 0x48d4, 0xbd,0x36, 0x1a,0x65,0x79,0x3b,0xe1,0x68);
-MIDL_INTERFACE("fb8b03af-3bdf-48d4-bd36-1a65793be168")
-ISelectionProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE GetSelection(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CanSelectMultiple(__RPC__out BOOL *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_IsSelectionRequired(__RPC__out BOOL *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(ISelectionProvider, 0xfb8b03af, 0x3bdf, 0x48d4, 0xbd,0x36, 0x1a,0x65,0x79,0x3b,0xe1,0x68)
-#endif
-#endif
-
-
-#ifndef __ISelectionItemProvider_INTERFACE_DEFINED__
-#define __ISelectionItemProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_ISelectionItemProvider, 0x2acad808, 0xb2d4, 0x452d, 0xa4,0x07, 0x91,0xff,0x1a,0xd1,0x67,0xb2);
-MIDL_INTERFACE("2acad808-b2d4-452d-a407-91ff1ad167b2")
-ISelectionItemProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE Select() = 0;
-    virtual HRESULT STDMETHODCALLTYPE AddToSelection() = 0;
-    virtual HRESULT STDMETHODCALLTYPE RemoveFromSelection() = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_IsSelected(__RPC__out BOOL *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_SelectionContainer(__RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(ISelectionItemProvider, 0x2acad808, 0xb2d4, 0x452d, 0xa4,0x07, 0x91,0xff,0x1a,0xd1,0x67,0xb2)
-#endif
-#endif
-
-
-#ifndef __ITableProvider_INTERFACE_DEFINED__
-#define __ITableProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_ITableProvider, 0x9c860395, 0x97b3, 0x490a, 0xb5,0x2a, 0x85,0x8c,0xc2,0x2a,0xf1,0x66);
-MIDL_INTERFACE("9c860395-97b3-490a-b52a-858cc22af166")
-ITableProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE GetRowHeaders(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetColumnHeaders(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_RowOrColumnMajor(__RPC__out enum RowOrColumnMajor *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(ITableProvider, 0x9c860395, 0x97b3, 0x490a, 0xb5,0x2a, 0x85,0x8c,0xc2,0x2a,0xf1,0x66)
-#endif
-#endif
-
-
-#ifndef __ITableItemProvider_INTERFACE_DEFINED__
-#define __ITableItemProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_ITableItemProvider, 0xb9734fa6, 0x771f, 0x4d78, 0x9c,0x90, 0x25,0x17,0x99,0x93,0x49,0xcd);
-MIDL_INTERFACE("b9734fa6-771f-4d78-9c90-2517999349cd")
-ITableItemProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE GetRowHeaderItems(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE GetColumnHeaderItems(__RPC__deref_out_opt SAFEARRAY **pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(ITableItemProvider, 0xb9734fa6, 0x771f, 0x4d78, 0x9c,0x90, 0x25,0x17,0x99,0x93,0x49,0xcd)
-#endif
-#endif
-
-
-#ifndef __IGridProvider_INTERFACE_DEFINED__
-#define __IGridProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IGridProvider, 0xb17d6187, 0x0907, 0x464b, 0xa1,0x68, 0x0e,0xf1,0x7a,0x15,0x72,0xb1);
-MIDL_INTERFACE("b17d6187-0907-464b-a168-0ef17a1572b1")
-IGridProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE GetItem(int row, int column, __RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_RowCount(__RPC__out int *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ColumnCount(__RPC__out int *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IGridProvider, 0xb17d6187, 0x0907, 0x464b, 0xa1,0x68, 0x0e,0xf1,0x7a,0x15,0x72,0xb1)
-#endif
-#endif
-
-
-#ifndef __IGridItemProvider_INTERFACE_DEFINED__
-#define __IGridItemProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IGridItemProvider, 0xd02541f1, 0xfb81, 0x4d64, 0xae,0x32, 0xf5,0x20,0xf8,0xa6,0xdb,0xd1);
-MIDL_INTERFACE("d02541f1-fb81-4d64-ae32-f520f8a6dbd1")
-IGridItemProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE get_Row(__RPC__out int *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_Column(__RPC__out int *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_RowSpan(__RPC__out int *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ColumnSpan(__RPC__out int *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ContainingGrid(__RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IGridItemProvider, 0xd02541f1, 0xfb81, 0x4d64, 0xae,0x32, 0xf5,0x20,0xf8,0xa6,0xdb,0xd1)
-#endif
-#endif
-
-
-#ifndef __IWindowProvider_INTERFACE_DEFINED__
-#define __IWindowProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IWindowProvider, 0x987df77b, 0xdb06, 0x4d77, 0x8f,0x8a, 0x86,0xa9,0xc3,0xbb,0x90,0xb9);
-MIDL_INTERFACE("987df77b-db06-4d77-8f8a-86a9c3bb90b9")
-IWindowProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE SetVisualState(enum WindowVisualState state) = 0;
-    virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
-    virtual HRESULT STDMETHODCALLTYPE WaitForInputIdle(int milliseconds, __RPC__out BOOL *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CanMaximize(__RPC__out BOOL *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_CanMinimize(__RPC__out BOOL *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_IsModal(__RPC__out BOOL *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_WindowVisualState(__RPC__out enum WindowVisualState *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_WindowInteractionState(__RPC__out enum WindowInteractionState *pRetVal) = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_IsTopmost(__RPC__out BOOL *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IWindowProvider, 0x987df77b, 0xdb06, 0x4d77, 0x8f,0x8a, 0x86,0xa9,0xc3,0xbb,0x90,0xb9)
-#endif
-#endif
-
-
-#ifndef __IExpandCollapseProvider_INTERFACE_DEFINED__
-#define __IExpandCollapseProvider_INTERFACE_DEFINED__
-DEFINE_GUID(IID_IExpandCollapseProvider, 0xd847d3a5, 0xcab0, 0x4a98, 0x8c,0x32, 0xec,0xb4,0x5c,0x59,0xad,0x24);
-MIDL_INTERFACE("d847d3a5-cab0-4a98-8c32-ecb45c59ad24")
-IExpandCollapseProvider : public IUnknown
-{
-public:
-    virtual HRESULT STDMETHODCALLTYPE Expand() = 0;
-    virtual HRESULT STDMETHODCALLTYPE Collapse() = 0;
-    virtual HRESULT STDMETHODCALLTYPE get_ExpandCollapseState(__RPC__out enum ExpandCollapseState *pRetVal) = 0;
-};
-#ifdef __CRT_UUID_DECL
-__CRT_UUID_DECL(IExpandCollapseProvider, 0xd847d3a5, 0xcab0, 0x4a98, 0x8c,0x32, 0xec,0xb4,0x5c,0x59,0xad,0x24)
-#endif
-#endif
-
-#endif
diff --git a/src/gui/accessible/windows/apisupport/uiatypes_p.h b/src/gui/accessible/windows/apisupport/uiatypes_p.h
deleted file mode 100644
index 465bd07a07..0000000000
--- a/src/gui/accessible/windows/apisupport/uiatypes_p.h
+++ /dev/null
@@ -1,157 +0,0 @@
-// Copyright (C) 2017 The Qt Company Ltd.
-// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
-
-#ifndef UIATYPES_H
-#define UIATYPES_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API. It exists purely as an
-// implementation detail. This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-typedef int PROPERTYID;
-typedef int PATTERNID;
-typedef int EVENTID;
-typedef int TEXTATTRIBUTEID;
-typedef int CONTROLTYPEID;
-typedef int LANDMARKTYPEID;
-typedef int METADATAID;
-
-typedef void *UIA_HWND;
-
-enum NavigateDirection {
-    NavigateDirection_Parent           = 0,
-    NavigateDirection_NextSibling      = 1,
-    NavigateDirection_PreviousSibling  = 2,
-    NavigateDirection_FirstChild       = 3,
-    NavigateDirection_LastChild        = 4
-};
-
-enum ProviderOptions {
-    ProviderOptions_ClientSideProvider      = 0x1,
-    ProviderOptions_ServerSideProvider      = 0x2,
-    ProviderOptions_NonClientAreaProvider   = 0x4,
-    ProviderOptions_OverrideProvider        = 0x8,
-    ProviderOptions_ProviderOwnsSetFocus    = 0x10,
-    ProviderOptions_UseComThreading         = 0x20,
-    ProviderOptions_RefuseNonClientSupport  = 0x40,
-    ProviderOptions_HasNativeIAccessible    = 0x80,
-    ProviderOptions_UseClientCoordinates    = 0x100
-};
-
-enum SupportedTextSelection {
-    SupportedTextSelection_None      = 0,
-    SupportedTextSelection_Single    = 1,
-    SupportedTextSelection_Multiple  = 2
-};
-
-enum TextUnit {
-    TextUnit_Character  = 0,
-    TextUnit_Format     = 1,
-    TextUnit_Word       = 2,
-    TextUnit_Line       = 3,
-    TextUnit_Paragraph  = 4,
-    TextUnit_Page       = 5,
-    TextUnit_Document   = 6
-};
-
-enum TextPatternRangeEndpoint {
-    TextPatternRangeEndpoint_Start  = 0,
-    TextPatternRangeEndpoint_End    = 1
-};
-
-enum CaretPosition {
-    CaretPosition_Unknown           = 0,
-    CaretPosition_EndOfLine         = 1,
-    CaretPosition_BeginningOfLine   = 2
-};
-
-enum ToggleState {
-    ToggleState_Off            = 0,
-    ToggleState_On             = 1,
-    ToggleState_Indeterminate  = 2
-};
-
-enum RowOrColumnMajor {
-    RowOrColumnMajor_RowMajor       = 0,
-    RowOrColumnMajor_ColumnMajor    = 1,
-    RowOrColumnMajor_Indeterminate  = 2
-};
-
-enum TreeScope {
-    TreeScope_None        = 0,
-    TreeScope_Element     = 0x1,
-    TreeScope_Children    = 0x2,
-    TreeScope_Descendants = 0x4,
-    TreeScope_Parent      = 0x8,
-    TreeScope_Ancestors   = 0x10,
-    TreeScope_Subtree     = TreeScope_Element | TreeScope_Children | TreeScope_Descendants
-};
-
-enum OrientationType {
-    OrientationType_None        = 0,
-    OrientationType_Horizontal  = 1,
-    OrientationType_Vertical    = 2
-};
-
-enum PropertyConditionFlags {
-    PropertyConditionFlags_None        = 0,
-    PropertyConditionFlags_IgnoreCase  = 1
-};
-
-enum WindowVisualState {
-    WindowVisualState_Normal    = 0,
-    WindowVisualState_Maximized = 1,
-    WindowVisualState_Minimized = 2
-};
-
-enum WindowInteractionState {
-    WindowInteractionState_Running                 = 0,
-    WindowInteractionState_Closing                 = 1,
-    WindowInteractionState_ReadyForUserInteraction = 2,
-    WindowInteractionState_BlockedByModalWindow    = 3,
-    WindowInteractionState_NotResponding           = 4
-};
-
-enum ExpandCollapseState {
-    ExpandCollapseState_Collapsed         = 0,
-    ExpandCollapseState_Expanded          = 1,
-    ExpandCollapseState_PartiallyExpanded = 2,
-    ExpandCollapseState_LeafNode          = 3
-};
-
-enum NotificationKind {
-    NotificationKind_ItemAdded       = 0,
-    NotificationKind_ItemRemoved     = 1,
-    NotificationKind_ActionCompleted = 2,
-    NotificationKind_ActionAborted   = 3,
-    NotificationKind_Other           = 4
-};
-
-enum NotificationProcessing {
-    NotificationProcessing_ImportantAll          = 0,
-    NotificationProcessing_ImportantMostRecent   = 1,
-    NotificationProcessing_All                   = 2,
-    NotificationProcessing_MostRecent            = 3,
-    NotificationProcessing_CurrentThenMostRecent = 4
-};
-
-struct UiaRect {
-    double left;
-    double top;
-    double width;
-    double height;
-};
-
-struct UiaPoint {
-    double x;
-    double y;
-};
-
-#endif
diff --git a/src/gui/configure.cmake b/src/gui/configure.cmake
index 71ab3ee935..cf6bc15c62 100644
--- a/src/gui/configure.cmake
+++ b/src/gui/configure.cmake
@@ -563,9 +563,8 @@ qt_config_compile_test(directwrite
 "#include <dwrite_2.h>
 int main(int, char **)
 {
-    IUnknown *factory = nullptr;
-    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory2),
-                        &factory);
+    IDWriteFactory2 *factory = nullptr;
+    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, IID_PPV_ARGS(&factory));
     return 0;
 }
 ")
@@ -579,9 +578,8 @@ qt_config_compile_test(directwrite3
 "#include <dwrite_3.h>
 int main(int, char **)
 {
-    IUnknown *factory = nullptr;
-    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory3),
-                        &factory);
+    IDWriteFactory3 *factory = nullptr;
+    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, IID_PPV_ARGS(&factory));
     return 0;
 }
 ")
diff --git a/src/gui/opengl/qopengl.cpp b/src/gui/opengl/qopengl.cpp
index 7c997103d5..2821915c92 100644
--- a/src/gui/opengl/qopengl.cpp
+++ b/src/gui/opengl/qopengl.cpp
@@ -195,13 +195,35 @@ struct OsTypeTerm
     static QString hostOs();
     static QVersionNumber hostKernelVersion() { return QVersionNumber::fromString(QSysInfo::kernelVersion()); }
     static QString hostOsRelease() {
+        QString ver = {};
 #ifdef Q_OS_WIN
-        if (QOperatingSystemVersion::current() >= QOperatingSystemVersion::Windows11)
-            return u"11"_s;
-        return u"10"_s;
-#else
-        return {};
+        const auto osver = QOperatingSystemVersion::current();
+#define Q_WINVER(major, minor) (major << 8 | minor)
+        switch (Q_WINVER(osver.majorVersion(), osver.minorVersion())) {
+        case Q_WINVER(6, 0):
+            ver = QStringLiteral("Vista");
+            break;
+        case Q_WINVER(6, 1):
+            ver = QStringLiteral("7");
+            break;
+        case Q_WINVER(6, 2):
+            ver = QStringLiteral("8");
+            break;
+        case Q_WINVER(6, 3):
+            ver = QStringLiteral("8.1");
+            break;
+        case Q_WINVER(10, 0):
+            if (osver.microVersion() >= 22000)
+                ver = QStringLiteral("11");
+            else
+                ver = QStringLiteral("10");
+            break;
+        default:
+            break;
+        }
+#undef Q_WINVER
 #endif
+        return ver;
     }
 
     bool isNull() const { return type.isEmpty(); }
diff --git a/src/gui/rhi/qrhid3d11.cpp b/src/gui/rhi/qrhid3d11.cpp
index a4a83e4296..228b4b4546 100644
--- a/src/gui/rhi/qrhid3d11.cpp
+++ b/src/gui/rhi/qrhid3d11.cpp
@@ -9,6 +9,8 @@
 #include <qmath.h>
 #include <private/qsystemlibrary_p.h>
 #include <QtCore/qcryptographichash.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 #include <QtCore/private/qsystemerror_p.h>
 
 #include <d3dcompiler.h>
@@ -109,7 +111,7 @@ QRhiD3D11::QRhiD3D11(QRhiD3D11InitParams *params, QRhiD3D11NativeHandles *import
         if (importParams->dev && importParams->context) {
             dev = reinterpret_cast<ID3D11Device *>(importParams->dev);
             ID3D11DeviceContext *ctx = reinterpret_cast<ID3D11DeviceContext *>(importParams->context);
-            if (SUCCEEDED(ctx->QueryInterface(__uuidof(ID3D11DeviceContext1), reinterpret_cast<void **>(&context)))) {
+            if (SUCCEEDED(ctx->QueryInterface(IID_PPV_ARGS(&context)))) {
                 // get rid of the ref added by QueryInterface
                 ctx->Release();
                 importedDeviceAndContext = true;
@@ -129,112 +131,174 @@ inline Int aligned(Int v, Int byteAlign)
     return (v + byteAlign - 1) & ~(byteAlign - 1);
 }
 
-static IDXGIFactory1 *createDXGIFactory2()
+static bool g_using_dxgi_1_0 = false;
+
+static IDXGIFactory *createDXGIFactory()
+{
+    static const auto pCreateDXGIFactory =
+        reinterpret_cast<decltype(&::CreateDXGIFactory)>(
+            QSystemLibrary::resolve(u"dxgi"_s, "CreateDXGIFactory"));
+    if (!pCreateDXGIFactory)
+        return nullptr;
+    IDXGIFactory *result = nullptr;
+    const HRESULT hr = pCreateDXGIFactory(IID_PPV_ARGS(&result));
+    if (SUCCEEDED(hr))
+        return result;
+    qWarning("CreateDXGIFactory() failed to create DXGI factory: %s",
+        qPrintable(QSystemError::windowsComString(hr)));
+    return nullptr;
+}
+
+static IDXGIFactory1 *createDXGIFactory1()
 {
+    static const auto pCreateDXGIFactory1 =
+        reinterpret_cast<decltype(&::CreateDXGIFactory1)>(
+            QSystemLibrary::resolve(u"dxgi"_s, "CreateDXGIFactory1"));
+    if (!pCreateDXGIFactory1)
+        return nullptr;
     IDXGIFactory1 *result = nullptr;
-    const HRESULT hr = CreateDXGIFactory2(0, __uuidof(IDXGIFactory2), reinterpret_cast<void **>(&result));
-    if (FAILED(hr)) {
-        qWarning("CreateDXGIFactory2() failed to create DXGI factory: %s",
-            qPrintable(QSystemError::windowsComString(hr)));
-        result = nullptr;
-    }
-    return result;
+    const HRESULT hr = pCreateDXGIFactory1(IID_PPV_ARGS(&result));
+    if (SUCCEEDED(hr))
+        return result;
+    qWarning("CreateDXGIFactory1() failed to create DXGI factory: %s",
+        qPrintable(QSystemError::windowsComString(hr)));
+    return nullptr;
 }
 
-bool QRhiD3D11::create(QRhi::Flags flags)
+static IDXGIFactory2 *createDXGIFactory2()
 {
-    rhiFlags = flags;
+    static const auto pCreateDXGIFactory2 =
+        reinterpret_cast<decltype(&::CreateDXGIFactory2)>(
+            QSystemLibrary::resolve(u"dxgi"_s, "CreateDXGIFactory2"));
+    if (!pCreateDXGIFactory2)
+        return nullptr;
+    IDXGIFactory2 *result = nullptr;
+    const HRESULT hr = pCreateDXGIFactory2(0, IID_PPV_ARGS(&result));
+    if (SUCCEEDED(hr))
+        return result;
+    qWarning("CreateDXGIFactory2() failed to create DXGI factory: %s",
+        qPrintable(QSystemError::windowsComString(hr)));
+    return nullptr;
+}
 
-    uint devFlags = 0;
-    if (debugLayer)
-        devFlags |= D3D11_CREATE_DEVICE_DEBUG;
+bool QRhiD3D11::create(QRhi::Flags flags)
+{
+    static const auto pD3D11CreateDevice =
+        reinterpret_cast<decltype(&::D3D11CreateDevice)>(
+            QSystemLibrary::resolve(u"d3d11"_s, "D3D11CreateDevice"));
+    if (!pD3D11CreateDevice) {
+        qWarning() << "D3D11 is not available on this platform.";
+        return false;
+    }
 
     dxgiFactory = createDXGIFactory2();
-    if (!dxgiFactory)
-        return false;
+    if (dxgiFactory) {
+        supportsFlipSwapchain = QOperatingSystemVersion::isWin10OrGreater()
+            && !qEnvironmentVariableIntValue("QT_D3D_NO_FLIP");
+    } else {
+        supportsFlipSwapchain = false;
+        dxgiFactory = createDXGIFactory1();
+        if (!dxgiFactory) {
+            dxgiFactory = createDXGIFactory();
+            if (!dxgiFactory) {
+                qWarning() << "DXGI is not available on this platform.";
+                return false;
+            }
+            g_using_dxgi_1_0 = true;
+        }
+    }
 
-    // For a FLIP_* swapchain Present(0, 0) is not necessarily
-    // sufficient to get non-blocking behavior, try using ALLOW_TEARING
-    // when available.
     supportsAllowTearing = false;
-    IDXGIFactory5 *factory5 = nullptr;
-    if (SUCCEEDED(dxgiFactory->QueryInterface(__uuidof(IDXGIFactory5), reinterpret_cast<void **>(&factory5)))) {
-        BOOL allowTearing = false;
-        if (SUCCEEDED(factory5->CheckFeatureSupport(DXGI_FEATURE_PRESENT_ALLOW_TEARING, &allowTearing, sizeof(allowTearing))))
-            supportsAllowTearing = allowTearing;
-        factory5->Release();
+    if (supportsFlipSwapchain) {
+        // For a FLIP_* swapchain Present(0, 0) is not necessarily
+        // sufficient to get non-blocking behavior, try using ALLOW_TEARING
+        // when available.
+        IDXGIFactory5 *factory5 = nullptr;
+        if (SUCCEEDED(dxgiFactory->QueryInterface(IID_PPV_ARGS(&factory5)))) {
+            BOOL allowTearing = false;
+            if (SUCCEEDED(factory5->CheckFeatureSupport(DXGI_FEATURE_PRESENT_ALLOW_TEARING, &allowTearing, sizeof(allowTearing))))
+                supportsAllowTearing = allowTearing;
+            factory5->Release();
+        }
     }
 
-    if (qEnvironmentVariableIntValue("QT_D3D_FLIP_DISCARD"))
-        qWarning("The default swap effect is FLIP_DISCARD, QT_D3D_FLIP_DISCARD is now ignored");
+    qCDebug(QRHI_LOG_INFO, "FLIP_* swapchain supported = %s, ALLOW_TEARING supported = %s",
+            supportsFlipSwapchain ? "true" : "false",
+            supportsAllowTearing ? "true" : "false");
 
-    if (qEnvironmentVariableIntValue("QT_D3D_NO_FLIP"))
-        qWarning("Non-FLIP swapchains are no longer supported, QT_D3D_NO_FLIP is now ignored");
+    qCDebug(QRHI_LOG_INFO, "Default swap effect: %s",
+            supportsFlipSwapchain ? "FLIP_DISCARD" : "DISCARD");
 
-    qCDebug(QRHI_LOG_INFO, "FLIP_* swapchain supported = true, ALLOW_TEARING supported = %s",
-            supportsAllowTearing ? "true" : "false");
+    rhiFlags = flags;
 
-    qCDebug(QRHI_LOG_INFO, "Default swap effect: FLIP_DISCARD");
+    uint devFlags = 0;
+    if (debugLayer)
+        devFlags |= D3D11_CREATE_DEVICE_DEBUG;
 
     if (!importedDeviceAndContext) {
-        IDXGIAdapter1 *adapter;
-        int requestedAdapterIndex = -1;
-        if (qEnvironmentVariableIsSet("QT_D3D_ADAPTER_INDEX"))
-            requestedAdapterIndex = qEnvironmentVariableIntValue("QT_D3D_ADAPTER_INDEX");
-
-        // The importParams may specify an adapter by the luid, take that into account.
-        if (requestedAdapterIndex < 0 && (adapterLuid.LowPart || adapterLuid.HighPart)) {
-            for (int adapterIndex = 0; dxgiFactory->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
-                DXGI_ADAPTER_DESC1 desc;
-                adapter->GetDesc1(&desc);
-                adapter->Release();
-                if (desc.AdapterLuid.LowPart == adapterLuid.LowPart
-                        && desc.AdapterLuid.HighPart == adapterLuid.HighPart)
-                {
-                    requestedAdapterIndex = adapterIndex;
-                    break;
+        activeAdapter = nullptr;
+
+        if (!g_using_dxgi_1_0) {
+            IDXGIAdapter1 *adapter;
+            int requestedAdapterIndex = -1;
+            if (qEnvironmentVariableIsSet("QT_D3D_ADAPTER_INDEX"))
+                requestedAdapterIndex = qEnvironmentVariableIntValue("QT_D3D_ADAPTER_INDEX");
+
+            const auto dxgiFactory1 = static_cast<IDXGIFactory1 *>(dxgiFactory);
+
+            // The importParams may specify an adapter by the luid, take that into account.
+            if (requestedAdapterIndex < 0 && (adapterLuid.LowPart || adapterLuid.HighPart)) {
+                for (int adapterIndex = 0; dxgiFactory1->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
+                    DXGI_ADAPTER_DESC1 desc;
+                    adapter->GetDesc1(&desc);
+                    adapter->Release();
+                    if (desc.AdapterLuid.LowPart == adapterLuid.LowPart
+                            && desc.AdapterLuid.HighPart == adapterLuid.HighPart)
+                    {
+                        requestedAdapterIndex = adapterIndex;
+                        break;
+                    }
+                }
+            }
+
+            if (requestedAdapterIndex < 0 && rhiFlags.testFlag(QRhi::PreferSoftwareRenderer)) {
+                for (int adapterIndex = 0; dxgiFactory1->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
+                    DXGI_ADAPTER_DESC1 desc;
+                    adapter->GetDesc1(&desc);
+                    adapter->Release();
+                    if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) {
+                        requestedAdapterIndex = adapterIndex;
+                        break;
+                    }
                 }
             }
-        }
 
-        if (requestedAdapterIndex < 0 && flags.testFlag(QRhi::PreferSoftwareRenderer)) {
-            for (int adapterIndex = 0; dxgiFactory->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
+            for (int adapterIndex = 0; dxgiFactory1->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
                 DXGI_ADAPTER_DESC1 desc;
                 adapter->GetDesc1(&desc);
-                adapter->Release();
-                if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) {
-                    requestedAdapterIndex = adapterIndex;
-                    break;
+                const QString name = QString::fromUtf16(reinterpret_cast<char16_t *>(desc.Description));
+                qCDebug(QRHI_LOG_INFO, "Adapter %d: '%s' (vendor 0x%X device 0x%X flags 0x%X)",
+                        adapterIndex,
+                        qPrintable(name),
+                        desc.VendorId,
+                        desc.DeviceId,
+                        desc.Flags);
+                if (!activeAdapter && (requestedAdapterIndex < 0 || requestedAdapterIndex == adapterIndex)) {
+                    activeAdapter = adapter;
+                    adapterLuid = desc.AdapterLuid;
+                    driverInfoStruct.deviceName = name.toUtf8();
+                    driverInfoStruct.deviceId = desc.DeviceId;
+                    driverInfoStruct.vendorId = desc.VendorId;
+                    qCDebug(QRHI_LOG_INFO, "  using this adapter");
+                } else {
+                    adapter->Release();
                 }
             }
-        }
-
-        activeAdapter = nullptr;
-        for (int adapterIndex = 0; dxgiFactory->EnumAdapters1(UINT(adapterIndex), &adapter) != DXGI_ERROR_NOT_FOUND; ++adapterIndex) {
-            DXGI_ADAPTER_DESC1 desc;
-            adapter->GetDesc1(&desc);
-            const QString name = QString::fromUtf16(reinterpret_cast<char16_t *>(desc.Description));
-            qCDebug(QRHI_LOG_INFO, "Adapter %d: '%s' (vendor 0x%X device 0x%X flags 0x%X)",
-                    adapterIndex,
-                    qPrintable(name),
-                    desc.VendorId,
-                    desc.DeviceId,
-                    desc.Flags);
-            if (!activeAdapter && (requestedAdapterIndex < 0 || requestedAdapterIndex == adapterIndex)) {
-                activeAdapter = adapter;
-                adapterLuid = desc.AdapterLuid;
-                driverInfoStruct.deviceName = name.toUtf8();
-                driverInfoStruct.deviceId = desc.DeviceId;
-                driverInfoStruct.vendorId = desc.VendorId;
-                qCDebug(QRHI_LOG_INFO, "  using this adapter");
-            } else {
-                adapter->Release();
+            if (!activeAdapter) {
+                qWarning("No adapter");
+                return false;
             }
         }
-        if (!activeAdapter) {
-            qWarning("No adapter");
-            return false;
-        }
 
         // Normally we won't specify a requested feature level list,
         // except when a level was specified in importParams.
@@ -245,27 +309,55 @@ bool QRhiD3D11::create(QRhi::Flags flags)
             requestedFeatureLevels.append(featureLevel);
         }
 
+        const D3D_DRIVER_TYPE driverType =
+                activeAdapter ? D3D_DRIVER_TYPE_UNKNOWN : D3D_DRIVER_TYPE_HARDWARE;
         ID3D11DeviceContext *ctx = nullptr;
-        HRESULT hr = D3D11CreateDevice(activeAdapter, D3D_DRIVER_TYPE_UNKNOWN, nullptr, devFlags,
-                                       requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
-                                       requestFeatureLevels ? requestedFeatureLevels.count() : 0,
-                                       D3D11_SDK_VERSION,
-                                       &dev, &featureLevel, &ctx);
+        HRESULT hr = pD3D11CreateDevice(activeAdapter, driverType, nullptr, devFlags,
+                                        requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
+                                        requestFeatureLevels ? requestedFeatureLevels.count() : 0,
+                                        D3D11_SDK_VERSION,
+                                        &dev, &featureLevel, &ctx);
         // We cannot assume that D3D11_CREATE_DEVICE_DEBUG is always available. Retry without it, if needed.
         if (hr == DXGI_ERROR_SDK_COMPONENT_MISSING && debugLayer) {
             qCDebug(QRHI_LOG_INFO, "Debug layer was requested but is not available. "
                                    "Attempting to create D3D11 device without it.");
             devFlags &= ~D3D11_CREATE_DEVICE_DEBUG;
-            hr = D3D11CreateDevice(activeAdapter, D3D_DRIVER_TYPE_UNKNOWN, nullptr, devFlags,
-                                   requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
-                                   requestFeatureLevels ? requestedFeatureLevels.count() : 0,
-                                   D3D11_SDK_VERSION,
-                                   &dev, &featureLevel, &ctx);
+            hr = pD3D11CreateDevice(activeAdapter, driverType, nullptr, devFlags,
+                                    requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
+                                    requestFeatureLevels ? requestedFeatureLevels.count() : 0,
+                                    D3D11_SDK_VERSION,
+                                    &dev, &featureLevel, &ctx);
         }
         if (FAILED(hr)) {
-            qWarning("Failed to create D3D11 device and context: %s",
-                qPrintable(QSystemError::windowsComString(hr)));
-            return false;
+            qWarning().noquote() << "Failed to create D3D11 device:"
+                                 << QSystemError::windowsComString(hr)
+                                 << "\nTry again using WARP instead ...";
+            hr = pD3D11CreateDevice(nullptr, D3D_DRIVER_TYPE_WARP, nullptr, devFlags,
+                                    requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
+                                    requestFeatureLevels ? requestedFeatureLevels.count() : 0,
+                                    D3D11_SDK_VERSION,
+                                    &dev, &featureLevel, &ctx);
+            if (FAILED(hr)) {
+                qWarning() << "Failed to create D3D11 device with WARP:"
+                           << QSystemError::windowsComString(hr)
+                           << "\nTry again using Mesa instead ...";
+            }
+            const HMODULE soft = QSystemLibrary::load(L"d3d10sw", false);
+            if (!soft) {
+                qWarning() << "Failed to load d3d10sw.dll. D3D11 is not available.";
+                return false;
+            }
+            hr = pD3D11CreateDevice(nullptr, D3D_DRIVER_TYPE_SOFTWARE, soft, devFlags,
+                                    requestFeatureLevels ? requestedFeatureLevels.constData() : nullptr,
+                                    requestFeatureLevels ? requestedFeatureLevels.count() : 0,
+                                    D3D11_SDK_VERSION,
+                                    &dev, &featureLevel, &ctx);
+            if (FAILED(hr)) {
+                qWarning().noquote() << "Failed to create D3D11 device with Mesa:"
+                                     << QSystemError::windowsComString(hr)
+                                     << "\nD3D11 is not available.";
+                return false;
+            }
         }
 
         // Test if creating a Shader Model 5.0 vertex shader works; we want to
@@ -279,7 +371,7 @@ bool QRhiD3D11::create(QRhi::Flags flags)
             return false;
         }
 
-        const bool supports11_1 = SUCCEEDED(ctx->QueryInterface(__uuidof(ID3D11DeviceContext1), reinterpret_cast<void **>(&context)));
+        const bool supports11_1 = SUCCEEDED(ctx->QueryInterface(IID_PPV_ARGS(&context)));
         ctx->Release();
         if (!supports11_1) {
             qWarning("ID3D11DeviceContext1 not supported");
@@ -289,7 +381,7 @@ bool QRhiD3D11::create(QRhi::Flags flags)
         Q_ASSERT(dev && context);
         featureLevel = dev->GetFeatureLevel();
         IDXGIDevice *dxgiDev = nullptr;
-        if (SUCCEEDED(dev->QueryInterface(__uuidof(IDXGIDevice), reinterpret_cast<void **>(&dxgiDev)))) {
+        if (SUCCEEDED(dev->QueryInterface(IID_PPV_ARGS(&dxgiDev)))) {
             IDXGIAdapter *adapter = nullptr;
             if (SUCCEEDED(dxgiDev->GetAdapter(&adapter))) {
                 DXGI_ADAPTER_DESC desc;
@@ -305,7 +397,7 @@ bool QRhiD3D11::create(QRhi::Flags flags)
         qCDebug(QRHI_LOG_INFO, "Using imported device %p", dev);
     }
 
-    if (FAILED(context->QueryInterface(__uuidof(ID3DUserDefinedAnnotation), reinterpret_cast<void **>(&annotations))))
+    if (FAILED(context->QueryInterface(IID_PPV_ARGS(&annotations))))
         annotations = nullptr;
 
     deviceLost = false;
@@ -374,7 +466,7 @@ void QRhiD3D11::reportLiveObjects(ID3D11Device *device)
 {
     // this works only when params.enableDebugLayer was true
     ID3D11Debug *debug;
-    if (SUCCEEDED(device->QueryInterface(__uuidof(ID3D11Debug), reinterpret_cast<void **>(&debug)))) {
+    if (SUCCEEDED(device->QueryInterface(IID_PPV_ARGS(&debug)))) {
         debug->ReportLiveDeviceObjects(D3D11_RLDO_DETAIL);
         debug->Release();
     }
@@ -4748,7 +4840,7 @@ static bool output6ForWindow(QWindow *w, IDXGIAdapter1 *adapter, IDXGIOutput6 **
         }
     }
     if (currentOutput) {
-        ok = SUCCEEDED(currentOutput->QueryInterface(__uuidof(IDXGIOutput6), reinterpret_cast<void **>(result)));
+        ok = SUCCEEDED(currentOutput->QueryInterface(IID_PPV_ARGS(result)));
         currentOutput->Release();
     }
     return ok;
@@ -4776,6 +4868,8 @@ bool QD3D11SwapChain::isFormatSupported(Format f)
     }
 
     QRHI_RES_RHI(QRhiD3D11);
+    if (!rhiD->activeAdapter)
+        return false;
     DXGI_OUTPUT_DESC1 desc1;
     if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &desc1))
         return desc1.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
@@ -4788,6 +4882,8 @@ QRhiSwapChainHdrInfo QD3D11SwapChain::hdrInfo()
     QRhiSwapChainHdrInfo info = QRhiSwapChain::hdrInfo();
     if (m_format != QRhiSwapChain::SDR && m_window) {
         QRHI_RES_RHI(QRhiD3D11);
+        if (!rhiD->activeAdapter)
+            return info;
         DXGI_OUTPUT_DESC1 hdrOutputDesc;
         if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &hdrOutputDesc)) {
             info.isHardCodedDefaults = false;
@@ -4845,12 +4941,18 @@ static const DXGI_FORMAT DEFAULT_SRGB_FORMAT = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
 
 bool QRhiD3D11::ensureDirectCompositionDevice()
 {
+    static const auto pDCompositionCreateDevice =
+        reinterpret_cast<decltype(&::DCompositionCreateDevice)>(
+            QSystemLibrary::resolve(u"dcomp"_s, "DCompositionCreateDevice"));
+    if (!pDCompositionCreateDevice)
+        return false;
+
     if (dcompDevice)
         return true;
 
     qCDebug(QRHI_LOG_INFO, "Creating Direct Composition device (needed for semi-transparent windows)");
 
-    HRESULT hr = DCompositionCreateDevice(nullptr, __uuidof(IDCompositionDevice), reinterpret_cast<void **>(&dcompDevice));
+    HRESULT hr = pDCompositionCreateDevice(nullptr, IID_PPV_ARGS(&dcompDevice));
     if (FAILED(hr)) {
         qWarning("Failed to Direct Composition device: %s",
             qPrintable(QSystemError::windowsComString(hr)));
@@ -4883,12 +4985,18 @@ bool QD3D11SwapChain::createOrResize()
     HRESULT hr;
 
     QRHI_RES_RHI(QRhiD3D11);
+    bool useFlipModel = rhiD->supportsFlipSwapchain;
 
+    // Take a shortcut for alpha: whatever the platform plugin does to enable
+    // transparency for our QWindow will be sufficient on the legacy (DISCARD)
+    // path. For FLIP_* we'd need to use DirectComposition (create a
+    // IDCompositionDevice/Target/Visual).
     if (m_flags.testFlag(SurfaceHasPreMulAlpha) || m_flags.testFlag(SurfaceHasNonPreMulAlpha)) {
         if (rhiD->ensureDirectCompositionDevice()) {
             if (!dcompTarget) {
                 hr = rhiD->dcompDevice->CreateTargetForHwnd(hwnd, true, &dcompTarget);
                 if (FAILED(hr)) {
+                    useFlipModel = false;
                     qWarning("Failed to create Direct Compsition target for the window: %s",
                              qPrintable(QSystemError::windowsComString(hr)));
                 }
@@ -4896,10 +5004,15 @@ bool QD3D11SwapChain::createOrResize()
             if (dcompTarget && !dcompVisual) {
                 hr = rhiD->dcompDevice->CreateVisual(&dcompVisual);
                 if (FAILED(hr)) {
+                    useFlipModel = false;
                     qWarning("Failed to create DirectComposition visual: %s",
                              qPrintable(QSystemError::windowsComString(hr)));
                 }
             }
+        } else {
+            // Direct Composition is not available, most likely due to we are running
+            // on Windows 7. Fallback to the legacy non-flip model instead.
+            useFlipModel = false;
         }
         // simple consistency check
         if (window->requestedFormat().alphaBufferSize() <= 0)
@@ -4914,7 +5027,7 @@ bool QD3D11SwapChain::createOrResize()
     // ALLOW_TEARING, and ALLOW_TEARING is not compatible with it at all so the
     // flag must not be set then. Whereas for flip we should use it, if
     // supported, to get better results for 'unthrottled' presentation.
-    if (swapInterval == 0 && rhiD->supportsAllowTearing)
+    if (swapInterval == 0 && useFlipModel && rhiD->supportsAllowTearing)
         swapChainFlags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING;
 
     if (!swapChain) {
@@ -4922,121 +5035,145 @@ bool QD3D11SwapChain::createOrResize()
         colorFormat = DEFAULT_FORMAT;
         srgbAdjustedColorFormat = m_flags.testFlag(sRGB) ? DEFAULT_SRGB_FORMAT : DEFAULT_FORMAT;
 
-        DXGI_COLOR_SPACE_TYPE hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709; // SDR
-        DXGI_OUTPUT_DESC1 hdrOutputDesc;
-        if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &hdrOutputDesc) && m_format != SDR) {
-            // https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range
-            if (hdrOutputDesc.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020) {
-                switch (m_format) {
-                case HDRExtendedSrgbLinear:
-                    colorFormat = DXGI_FORMAT_R16G16B16A16_FLOAT;
-                    hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709;
-                    srgbAdjustedColorFormat = colorFormat;
-                    break;
-                case HDR10:
-                    colorFormat = DXGI_FORMAT_R10G10B10A2_UNORM;
-                    hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
-                    srgbAdjustedColorFormat = colorFormat;
-                    break;
-                default:
-                    break;
+        if (useFlipModel) {
+            DXGI_COLOR_SPACE_TYPE hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709; // SDR
+            DXGI_OUTPUT_DESC1 hdrOutputDesc;
+            if (outputDesc1ForWindow(m_window, rhiD->activeAdapter, &hdrOutputDesc) && m_format != SDR) {
+                // https://docs.microsoft.com/en-us/windows/win32/direct3darticles/high-dynamic-range
+                if (hdrOutputDesc.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020) {
+                    switch (m_format) {
+                    case HDRExtendedSrgbLinear:
+                        colorFormat = DXGI_FORMAT_R16G16B16A16_FLOAT;
+                        hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709;
+                        srgbAdjustedColorFormat = colorFormat;
+                        break;
+                    case HDR10:
+                        colorFormat = DXGI_FORMAT_R10G10B10A2_UNORM;
+                        hdrColorSpace = DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020;
+                        srgbAdjustedColorFormat = colorFormat;
+                        break;
+                    default:
+                        break;
+                    }
+                } else {
+                    // This happens also when Use HDR is set to Off in the Windows
+                    // Display settings. Show a helpful warning, but continue with the
+                    // default non-HDR format.
+                    qWarning("The output associated with the window is not HDR capable "
+                             "(or Use HDR is Off in the Display Settings), ignoring HDR format request");
                 }
-            } else {
-                // This happens also when Use HDR is set to Off in the Windows
-                // Display settings. Show a helpful warning, but continue with the
-                // default non-HDR format.
-                qWarning("The output associated with the window is not HDR capable "
-                         "(or Use HDR is Off in the Display Settings), ignoring HDR format request");
             }
-        }
 
-        // We use a FLIP model swapchain which implies a buffer count of 2
-        // (as opposed to the old DISCARD with back buffer count == 1).
-        // This makes no difference for the rest of the stuff except that
-        // automatic MSAA is unsupported and needs to be implemented via a
-        // custom multisample render target and an explicit resolve.
-
-        DXGI_SWAP_CHAIN_DESC1 desc = {};
-        desc.Width = UINT(pixelSize.width());
-        desc.Height = UINT(pixelSize.height());
-        desc.Format = colorFormat;
-        desc.SampleDesc.Count = 1;
-        desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
-        desc.BufferCount = BUFFER_COUNT;
-        desc.Flags = swapChainFlags;
-        desc.Scaling = DXGI_SCALING_NONE;
-        desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
-
-        if (dcompVisual) {
-            // With DirectComposition setting AlphaMode to STRAIGHT fails the
-            // swapchain creation, whereas the result seems to be identical
-            // with any of the other values, including IGNORE. (?)
-            desc.AlphaMode = DXGI_ALPHA_MODE_PREMULTIPLIED;
-
-            // DirectComposition has its own limitations, cannot use
-            // SCALING_NONE. So with semi-transparency requested we are forced
-            // to SCALING_STRETCH.
-            desc.Scaling = DXGI_SCALING_STRETCH;
-        }
+            // We use a FLIP model swapchain which implies a buffer count of 2
+            // (as opposed to the old DISCARD with back buffer count == 1).
+            // This makes no difference for the rest of the stuff except that
+            // automatic MSAA is unsupported and needs to be implemented via a
+            // custom multisample render target and an explicit resolve.
+
+            DXGI_SWAP_CHAIN_DESC1 desc = {};
+            desc.Width = UINT(pixelSize.width());
+            desc.Height = UINT(pixelSize.height());
+            desc.Format = colorFormat;
+            desc.SampleDesc.Count = 1;
+            desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
+            desc.BufferCount = BUFFER_COUNT;
+            desc.Flags = swapChainFlags;
+            desc.Scaling = DXGI_SCALING_NONE;
+            desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
 
-        IDXGIFactory2 *fac = static_cast<IDXGIFactory2 *>(rhiD->dxgiFactory);
-        IDXGISwapChain1 *sc1;
+            if (dcompVisual) {
+                // With DirectComposition setting AlphaMode to STRAIGHT fails the
+                // swapchain creation, whereas the result seems to be identical
+                // with any of the other values, including IGNORE. (?)
+                desc.AlphaMode = DXGI_ALPHA_MODE_PREMULTIPLIED;
+
+                // DirectComposition has its own limitations, cannot use
+                // SCALING_NONE. So with semi-transparency requested we are forced
+                // to SCALING_STRETCH.
+                desc.Scaling = DXGI_SCALING_STRETCH;
+            }
+
+            IDXGIFactory2 *fac = static_cast<IDXGIFactory2 *>(rhiD->dxgiFactory);
+            IDXGISwapChain1 *sc1;
 
-        if (dcompVisual)
-            hr = fac->CreateSwapChainForComposition(rhiD->dev, &desc, nullptr, &sc1);
-        else
-            hr = fac->CreateSwapChainForHwnd(rhiD->dev, hwnd, &desc, nullptr, nullptr, &sc1);
-
-        // If failed and we tried a HDR format, then try with SDR. This
-        // matches other backends, such as Vulkan where if the format is
-        // not supported, the default one is used instead.
-        if (FAILED(hr) && m_format != SDR) {
-            colorFormat = DEFAULT_FORMAT;
-            desc.Format = DEFAULT_FORMAT;
             if (dcompVisual)
                 hr = fac->CreateSwapChainForComposition(rhiD->dev, &desc, nullptr, &sc1);
             else
                 hr = fac->CreateSwapChainForHwnd(rhiD->dev, hwnd, &desc, nullptr, nullptr, &sc1);
-        }
 
-        if (SUCCEEDED(hr)) {
-            swapChain = sc1;
-            if (m_format != SDR) {
-                IDXGISwapChain3 *sc3 = nullptr;
-                if (SUCCEEDED(sc1->QueryInterface(__uuidof(IDXGISwapChain3), reinterpret_cast<void **>(&sc3)))) {
-                    hr = sc3->SetColorSpace1(hdrColorSpace);
-                    if (FAILED(hr))
-                        qWarning("Failed to set color space on swapchain: %s",
-                            qPrintable(QSystemError::windowsComString(hr)));
-                    sc3->Release();
-                } else {
-                    qWarning("IDXGISwapChain3 not available, HDR swapchain will not work as expected");
-                }
+            // If failed and we tried a HDR format, then try with SDR. This
+            // matches other backends, such as Vulkan where if the format is
+            // not supported, the default one is used instead.
+            if (FAILED(hr) && m_format != SDR) {
+                colorFormat = DEFAULT_FORMAT;
+                desc.Format = DEFAULT_FORMAT;
+                if (dcompVisual)
+                    hr = fac->CreateSwapChainForComposition(rhiD->dev, &desc, nullptr, &sc1);
+                else
+                    hr = fac->CreateSwapChainForHwnd(rhiD->dev, hwnd, &desc, nullptr, nullptr, &sc1);
             }
-            if (dcompVisual) {
-                hr = dcompVisual->SetContent(sc1);
-                if (SUCCEEDED(hr)) {
-                    hr = dcompTarget->SetRoot(dcompVisual);
-                    if (FAILED(hr)) {
-                        qWarning("Failed to associate Direct Composition visual with the target: %s",
+
+            if (SUCCEEDED(hr)) {
+                swapChain = sc1;
+                if (m_format != SDR) {
+                    IDXGISwapChain3 *sc3 = nullptr;
+                    if (SUCCEEDED(sc1->QueryInterface(IID_PPV_ARGS(&sc3)))) {
+                        hr = sc3->SetColorSpace1(hdrColorSpace);
+                        if (FAILED(hr)) {
+                            qWarning("Failed to set color space on swapchain: %s",
+                                qPrintable(QSystemError::windowsComString(hr)));
+                        }
+                        sc3->Release();
+                    } else {
+                        qWarning("IDXGISwapChain3 not available, HDR swapchain will not work as expected");
+                    }
+                }
+                if (dcompVisual) {
+                    hr = dcompVisual->SetContent(sc1);
+                    if (SUCCEEDED(hr)) {
+                        hr = dcompTarget->SetRoot(dcompVisual);
+                        if (FAILED(hr)) {
+                            qWarning("Failed to associate Direct Composition visual with the target: %s",
+                                     qPrintable(QSystemError::windowsComString(hr)));
+                        }
+                    } else {
+                        qWarning("Failed to set content for Direct Composition visual: %s",
                                  qPrintable(QSystemError::windowsComString(hr)));
                     }
-                } else {
-                    qWarning("Failed to set content for Direct Composition visual: %s",
-                             qPrintable(QSystemError::windowsComString(hr)));
                 }
             }
+        } else {
+            // Fallback: use DISCARD model. Regardless, keep on using our manual
+            // resolve for symmetry with the FLIP_* code path when MSAA is
+            // requested. This has no HDR support.
+
+            DXGI_SWAP_CHAIN_DESC desc = {};
+            desc.BufferDesc.Width = UINT(pixelSize.width());
+            desc.BufferDesc.Height = UINT(pixelSize.height());
+            desc.BufferDesc.RefreshRate.Numerator = 60;
+            desc.BufferDesc.RefreshRate.Denominator = 1;
+            desc.BufferDesc.Format = colorFormat;
+            desc.SampleDesc.Count = 1;
+            desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
+            desc.BufferCount = 1;
+            desc.OutputWindow = hwnd;
+            desc.Windowed = TRUE;
+            desc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
+            desc.Flags = swapChainFlags;
+
+            hr = rhiD->dxgiFactory->CreateSwapChain(rhiD->dev, &desc, &swapChain);
         }
         if (FAILED(hr)) {
             qWarning("Failed to create D3D11 swapchain: %s",
                 qPrintable(QSystemError::windowsComString(hr)));
             return false;
         }
-        rhiD->dxgiFactory->MakeWindowAssociation(hwnd, DXGI_MWA_NO_WINDOW_CHANGES);
+        rhiD->dxgiFactory->MakeWindowAssociation(hwnd,
+            DXGI_MWA_NO_WINDOW_CHANGES | DXGI_MWA_NO_ALT_ENTER | DXGI_MWA_NO_PRINT_SCREEN);
     } else {
         releaseBuffers();
-        // flip model -> buffer count is the real buffer count, not 1 like with the legacy modes
-        hr = swapChain->ResizeBuffers(UINT(BUFFER_COUNT), UINT(pixelSize.width()), UINT(pixelSize.height()),
+        const UINT count = useFlipModel ? BUFFER_COUNT : 1;
+        hr = swapChain->ResizeBuffers(count, UINT(pixelSize.width()), UINT(pixelSize.height()),
                                       colorFormat, swapChainFlags);
         if (hr == DXGI_ERROR_DEVICE_REMOVED || hr == DXGI_ERROR_DEVICE_RESET) {
             qWarning("Device loss detected in ResizeBuffers()");
@@ -5063,7 +5200,7 @@ bool QD3D11SwapChain::createOrResize()
     // swapchain."
 
     // So just query index 0 once (per resize) and be done with it.
-    hr = swapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<void **>(&backBufferTex));
+    hr = swapChain->GetBuffer(0, IID_PPV_ARGS(&backBufferTex));
     if (FAILED(hr)) {
         qWarning("Failed to query swapchain backbuffer: %s",
             qPrintable(QSystemError::windowsComString(hr)));
diff --git a/src/gui/rhi/qrhid3d11_p_p.h b/src/gui/rhi/qrhid3d11_p_p.h
index 3f4d8e8e31..f88c6d047f 100644
--- a/src/gui/rhi/qrhid3d11_p_p.h
+++ b/src/gui/rhi/qrhid3d11_p_p.h
@@ -737,8 +737,9 @@ public:
     LUID adapterLuid = {};
     ID3DUserDefinedAnnotation *annotations = nullptr;
     IDXGIAdapter1 *activeAdapter = nullptr;
-    IDXGIFactory1 *dxgiFactory = nullptr;
+    IDXGIFactory *dxgiFactory = nullptr;
     IDCompositionDevice *dcompDevice = nullptr;
+    bool supportsFlipSwapchain = false;
     bool supportsAllowTearing = false;
     bool deviceLost = false;
     QRhiD3D11NativeHandles nativeHandlesStruct;
diff --git a/src/gui/text/windows/qwindowsdirectwritefontdatabase.cpp b/src/gui/text/windows/qwindowsdirectwritefontdatabase.cpp
index 6b4933cca7..eed71b6e94 100644
--- a/src/gui/text/windows/qwindowsdirectwritefontdatabase.cpp
+++ b/src/gui/text/windows/qwindowsdirectwritefontdatabase.cpp
@@ -107,8 +107,7 @@ void QWindowsDirectWriteFontDatabase::populateFamily(const QString &familyName)
             IDWriteFont *font;
             if (SUCCEEDED(matchingFonts->GetFont(j, &font))) {
                 IDWriteFont1 *font1 = nullptr;
-                if (!SUCCEEDED(font->QueryInterface(__uuidof(IDWriteFont1),
-                                                   reinterpret_cast<void **>(&font1)))) {
+                if (!SUCCEEDED(font->QueryInterface(IID_PPV_ARGS(&font1)))) {
                     qCWarning(lcQpaFonts) << "COM object does not support IDWriteFont1";
                     continue;
                 }
@@ -271,8 +270,7 @@ QStringList QWindowsDirectWriteFontDatabase::addApplicationFont(const QByteArray
 
     QStringList ret;
     IDWriteFontFace3 *face3 = nullptr;
-    if (SUCCEEDED(face->QueryInterface(__uuidof(IDWriteFontFace3),
-                                      reinterpret_cast<void **>(&face3)))) {
+    if (SUCCEEDED(face->QueryInterface(IID_PPV_ARGS(&face3)))) {
         QString defaultLocaleFamilyName;
         QString englishLocaleFamilyName;
 
diff --git a/src/gui/text/windows/qwindowsfontdatabase.cpp b/src/gui/text/windows/qwindowsfontdatabase.cpp
index 2de53be6a8..4e6ffa14f7 100644
--- a/src/gui/text/windows/qwindowsfontdatabase.cpp
+++ b/src/gui/text/windows/qwindowsfontdatabase.cpp
@@ -1188,8 +1188,7 @@ QFontEngine *QWindowsFontDatabase::createEngine(const QFontDef &request, const Q
                 bool isColorFont = false;
 #if QT_CONFIG(direct2d)
                 IDWriteFontFace2 *directWriteFontFace2 = nullptr;
-                if (SUCCEEDED(directWriteFontFace->QueryInterface(__uuidof(IDWriteFontFace2),
-                                                                  reinterpret_cast<void **>(&directWriteFontFace2)))) {
+                if (SUCCEEDED(directWriteFontFace->QueryInterface(IID_PPV_ARGS(&directWriteFontFace2)))) {
                     if (directWriteFontFace2->IsColorFont())
                         isColorFont = directWriteFontFace2->GetPaletteEntryCount() > 0;
 
diff --git a/src/gui/text/windows/qwindowsfontdatabasebase.cpp b/src/gui/text/windows/qwindowsfontdatabasebase.cpp
index f45678c65c..346952186e 100644
--- a/src/gui/text/windows/qwindowsfontdatabasebase.cpp
+++ b/src/gui/text/windows/qwindowsfontdatabasebase.cpp
@@ -6,6 +6,7 @@
 
 #include <QtCore/QThreadStorage>
 #include <QtCore/QtEndian>
+#include <QtCore/private/qsystemlibrary_p.h>
 
 #if QT_CONFIG(directwrite)
 #  if QT_CONFIG(directwrite3)
@@ -685,7 +686,13 @@ QFont QWindowsFontDatabaseBase::systemDefaultFont()
     // Qt 6: Obtain default GUI font (typically "Segoe UI, 9pt", see QTBUG-58610)
     NONCLIENTMETRICS ncm = {};
     ncm.cbSize = sizeof(ncm);
-    SystemParametersInfoForDpi(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0, defaultVerticalDPI());
+    static const auto pSystemParametersInfoForDpi =
+        reinterpret_cast<decltype(&::SystemParametersInfoForDpi)>(
+            QSystemLibrary::resolve(u"user32"_s, "SystemParametersInfoForDpi"));
+    if (pSystemParametersInfoForDpi)
+        pSystemParametersInfoForDpi(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0, defaultVerticalDPI());
+    else
+        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0);
     const QFont systemFont = QWindowsFontDatabase::LOGFONT_to_QFont(ncm.lfMessageFont);
     qCDebug(lcQpaFonts) << __FUNCTION__ << systemFont;
     return systemFont;
diff --git a/src/gui/text/windows/qwindowsfontenginedirectwrite.cpp b/src/gui/text/windows/qwindowsfontenginedirectwrite.cpp
index 14dd064c33..026211c0a3 100644
--- a/src/gui/text/windows/qwindowsfontenginedirectwrite.cpp
+++ b/src/gui/text/windows/qwindowsfontenginedirectwrite.cpp
@@ -671,8 +671,7 @@ bool QWindowsFontEngineDirectWrite::supportsHorizontalSubPixelPositions() const
 QFontEngine::Properties QWindowsFontEngineDirectWrite::properties() const
 {
     IDWriteFontFace2 *directWriteFontFace2;
-    if (SUCCEEDED(m_directWriteFontFace->QueryInterface(__uuidof(IDWriteFontFace2),
-                                                        reinterpret_cast<void **>(&directWriteFontFace2)))) {
+    if (SUCCEEDED(m_directWriteFontFace->QueryInterface(IID_PPV_ARGS(&directWriteFontFace2)))) {
         DWRITE_FONT_METRICS1 metrics;
         directWriteFontFace2->GetMetrics(&metrics);
 
@@ -739,8 +738,7 @@ QImage QWindowsFontEngineDirectWrite::imageForGlyph(glyph_t t,
             : DWRITE_GRID_FIT_MODE_DEFAULT;
 
     IDWriteFactory2 *factory2 = nullptr;
-    HRESULT hr = m_fontEngineData->directWriteFactory->QueryInterface(__uuidof(IDWriteFactory2),
-                                                                      reinterpret_cast<void **>(&factory2));
+    HRESULT hr = m_fontEngineData->directWriteFactory->QueryInterface(IID_PPV_ARGS(&factory2));
     IDWriteGlyphRunAnalysis *glyphAnalysis = NULL;
     if (!SUCCEEDED(hr)) {
         qErrnoWarning(hr, "%s: Failed to query IDWriteFactory2 interface.", __FUNCTION__);
@@ -1063,8 +1061,7 @@ glyph_metrics_t QWindowsFontEngineDirectWrite::alphaMapBoundingBox(glyph_t glyph
             : DWRITE_GRID_FIT_MODE_DEFAULT;
 
     IDWriteFactory2 *factory2 = nullptr;
-    HRESULT hr = m_fontEngineData->directWriteFactory->QueryInterface(__uuidof(IDWriteFactory2),
-                                                                      reinterpret_cast<void **>(&factory2));
+    HRESULT hr = m_fontEngineData->directWriteFactory->QueryInterface(IID_PPV_ARGS(&factory2));
 
     IDWriteGlyphRunAnalysis *glyphAnalysis = NULL;
     if (SUCCEEDED(hr)) {
diff --git a/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp b/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp
index f46dfb88ee..6c1da890b9 100644
--- a/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp
+++ b/src/plugins/networkinformation/networklistmanager/qnetworklistmanagerevents.cpp
@@ -5,6 +5,7 @@
 #include <QtCore/private/qsystemerror_p.h>
 
 #include <QtCore/qpointer.h>
+#include <QtCore/qoperatingsystemversion.h>
 
 #include <mutex>
 
@@ -108,20 +109,22 @@ bool QNetworkListManagerEvents::start()
     }
 
 #if QT_CONFIG(cpp_winrt)
-    using namespace winrt::Windows::Networking::Connectivity;
-    using winrt::Windows::Foundation::IInspectable;
-    // Register for changes in the network and store a token to unregister later:
-    token = NetworkInformation::NetworkStatusChanged(
-            [owner = QPointer(this)](const IInspectable sender) {
-                Q_UNUSED(sender);
-                if (owner) {
-                    std::scoped_lock locker(owner->winrtLock);
-                    if (owner->token)
-                        owner->emitWinRTUpdates();
-                }
-            });
-    // Emit initial state
-    emitWinRTUpdates();
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        using namespace winrt::Windows::Networking::Connectivity;
+        using winrt::Windows::Foundation::IInspectable;
+        // Register for changes in the network and store a token to unregister later:
+        token = NetworkInformation::NetworkStatusChanged(
+                [owner = QPointer(this)](const IInspectable sender) {
+                    Q_UNUSED(sender);
+                    if (owner) {
+                        std::scoped_lock locker(owner->winrtLock);
+                        if (owner->token)
+                            owner->emitWinRTUpdates();
+                    }
+                });
+        // Emit initial state
+        emitWinRTUpdates();
+    }
 #endif
 
     return true;
@@ -140,13 +143,15 @@ void QNetworkListManagerEvents::stop()
     // Even if we fail we should still try to unregister from winrt events:
 
 #if QT_CONFIG(cpp_winrt)
-    // Try to synchronize unregistering with potentially in-progress callbacks
-    std::scoped_lock locker(winrtLock);
-    if (token) {
-        using namespace winrt::Windows::Networking::Connectivity;
-        // Pass the token we stored earlier to unregister:
-        NetworkInformation::NetworkStatusChanged(token);
-        token = {};
+    if (QOperatingSystemVersion::isWin10OrGreater()) {
+        // Try to synchronize unregistering with potentially in-progress callbacks
+        std::scoped_lock locker(winrtLock);
+        if (token) {
+            using namespace winrt::Windows::Networking::Connectivity;
+            // Pass the token we stored earlier to unregister:
+            NetworkInformation::NetworkStatusChanged(token);
+            token = {};
+        }
     }
 #endif
 }
@@ -197,6 +202,9 @@ using namespace winrt::Windows::Networking::Connectivity;
 [[nodiscard]]
 QNetworkInformation::TransportMedium getTransportMedium(const ConnectionProfile &profile)
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return QNetworkInformation::TransportMedium::Unknown;
+
     if (profile.IsWwanConnectionProfile())
         return QNetworkInformation::TransportMedium::Cellular;
     if (profile.IsWlanConnectionProfile())
@@ -230,6 +238,8 @@ QNetworkInformation::TransportMedium getTransportMedium(const ConnectionProfile
 
 [[nodiscard]] bool getMetered(const ConnectionProfile &profile)
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return false;
     ConnectionCost cost(nullptr);
     try {
         cost = profile.GetConnectionCost();
@@ -245,6 +255,8 @@ QNetworkInformation::TransportMedium getTransportMedium(const ConnectionProfile
 
 void QNetworkListManagerEvents::emitWinRTUpdates()
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return;
     using namespace winrt::Windows::Networking::Connectivity;
     ConnectionProfile profile = nullptr;
     try {
diff --git a/src/plugins/platforms/CMakeLists.txt b/src/plugins/platforms/CMakeLists.txt
index dfbec51877..34107a6741 100644
--- a/src/plugins/platforms/CMakeLists.txt
+++ b/src/plugins/platforms/CMakeLists.txt
@@ -6,12 +6,6 @@
 if(ANDROID)
     add_subdirectory(android)
 endif()
-if(NOT ANDROID AND NOT WASM)
-    add_subdirectory(minimal)
-endif()
-if(QT_FEATURE_freetype AND NOT ANDROID AND NOT WASM)
-    add_subdirectory(offscreen)
-endif()
 if(QT_FEATURE_xcb)
     add_subdirectory(xcb)
 endif()
@@ -24,9 +18,6 @@ endif()
 if(WIN32)
     add_subdirectory(windows)
 endif()
-if(QT_FEATURE_direct2d1_1 AND QT_FEATURE_directwrite)
-    add_subdirectory(direct2d)
-endif()
 if(QNX)
     add_subdirectory(qnx)
 endif()
diff --git a/src/plugins/platforms/windows/CMakeLists.txt b/src/plugins/platforms/windows/CMakeLists.txt
index 7884fc164e..00ec76fa8f 100644
--- a/src/plugins/platforms/windows/CMakeLists.txt
+++ b/src/plugins/platforms/windows/CMakeLists.txt
@@ -198,6 +198,8 @@ qt_internal_extend_target(QWindowsIntegrationPlugin CONDITION QT_FEATURE_accessi
         uiautomation/qwindowsuiautils.cpp uiautomation/qwindowsuiautils.h
         uiautomation/qwindowsuiavalueprovider.cpp uiautomation/qwindowsuiavalueprovider.h
         uiautomation/qwindowsuiawindowprovider.cpp uiautomation/qwindowsuiawindowprovider.h
+    LIBRARIES
+        uiautomationcore
 )
 
 qt_internal_extend_target(QWindowsIntegrationPlugin CONDITION MINGW AND QT_FEATURE_accessibility
diff --git a/src/plugins/platforms/windows/qwin10helpers.cpp b/src/plugins/platforms/windows/qwin10helpers.cpp
index 026e81cb0c..e17d2bc20d 100644
--- a/src/plugins/platforms/windows/qwin10helpers.cpp
+++ b/src/plugins/platforms/windows/qwin10helpers.cpp
@@ -4,6 +4,8 @@
 #include "qwin10helpers.h"
 
 #include <QtCore/qdebug.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 #include <winstring.h>
 #include <roapi.h>
 
@@ -60,29 +62,62 @@ public:
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
+struct QComBaseApi
+{
+    decltype(&::RoGetActivationFactory) pRoGetActivationFactory = nullptr;
+    decltype(&::WindowsCreateStringReference) pWindowsCreateStringReference = nullptr;
+
+    static QComBaseApi *instance()
+    {
+        static QComBaseApi api;
+        return &api;
+    }
+
+private:
+    Q_DISABLE_COPY_MOVE(QComBaseApi)
+
+    explicit QComBaseApi()
+    {
+        QSystemLibrary comBase(u"combase"_s);
+        pRoGetActivationFactory = reinterpret_cast<decltype(pRoGetActivationFactory)>(comBase.resolve("RoGetActivationFactory"));
+        pWindowsCreateStringReference = reinterpret_cast<decltype(pWindowsCreateStringReference)>(comBase.resolve("WindowsCreateStringReference"));
+    }
+
+    ~QComBaseApi() = default;
+};
+
 // Return tablet mode, note: Does not work for GetDesktopWindow().
 bool qt_windowsIsTabletMode(HWND hwnd)
 {
+    if (!QComBaseApi::instance()->pRoGetActivationFactory ||
+        !QComBaseApi::instance()->pWindowsCreateStringReference) {
+        return false;
+    }
+
     bool result = false;
 
     const wchar_t uiViewSettingsId[] = L"Windows.UI.ViewManagement.UIViewSettings";
     HSTRING_HEADER uiViewSettingsIdRefHeader;
     HSTRING uiViewSettingsIdHs = nullptr;
     const auto uiViewSettingsIdLen = UINT32(sizeof(uiViewSettingsId) / sizeof(uiViewSettingsId[0]) - 1);
-    if (FAILED(WindowsCreateStringReference(uiViewSettingsId, uiViewSettingsIdLen, &uiViewSettingsIdRefHeader, &uiViewSettingsIdHs)))
+    if (FAILED(QComBaseApi::instance()->pWindowsCreateStringReference(uiViewSettingsId, uiViewSettingsIdLen, &uiViewSettingsIdRefHeader, &uiViewSettingsIdHs)))
         return false;
 
     IUIViewSettingsInterop *uiViewSettingsInterop = nullptr;
     // __uuidof(IUIViewSettingsInterop);
-    const GUID uiViewSettingsInteropRefId = {0x3694dbf9, 0x8f68, 0x44be,{0x8f, 0xf5, 0x19, 0x5c, 0x98, 0xed, 0xe8, 0xa6}};
+    static constexpr const GUID uiViewSettingsInteropRefId =
+        {0x3694dbf9, 0x8f68, 0x44be,{0x8f, 0xf5, 0x19, 0x5c, 0x98, 0xed, 0xe8, 0xa6}};
 
-    HRESULT hr = RoGetActivationFactory(uiViewSettingsIdHs, uiViewSettingsInteropRefId,
+    HRESULT hr = QComBaseApi::instance()->pRoGetActivationFactory(uiViewSettingsIdHs, uiViewSettingsInteropRefId,
                                                    reinterpret_cast<void **>(&uiViewSettingsInterop));
     if (FAILED(hr))
         return false;
 
     //  __uuidof(ABI::Windows::UI::ViewManagement::IUIViewSettings);
-    const GUID uiViewSettingsRefId = {0xc63657f6, 0x8850, 0x470d,{0x88, 0xf8, 0x45, 0x5e, 0x16, 0xea, 0x2c, 0x26}};
+    static constexpr const GUID uiViewSettingsRefId =
+        {0xc63657f6, 0x8850, 0x470d,{0x88, 0xf8, 0x45, 0x5e, 0x16, 0xea, 0x2c, 0x26}};
     ABI::Windows::UI::ViewManagement::IUIViewSettings *viewSettings = nullptr;
     hr = uiViewSettingsInterop->GetForWindow(hwnd, uiViewSettingsRefId,
                                              reinterpret_cast<void **>(&viewSettings));
diff --git a/src/plugins/platforms/windows/qwindowsapplication.cpp b/src/plugins/platforms/windows/qwindowsapplication.cpp
index 5d1b6d348b..bfef10e673 100644
--- a/src/plugins/platforms/windows/qwindowsapplication.cpp
+++ b/src/plugins/platforms/windows/qwindowsapplication.cpp
@@ -12,6 +12,7 @@
 
 #include <QtCore/qvariant.h>
 #include <QtCore/private/qfunctions_win_p.h>
+#include <QtCore/qoperatingsystemversion.h>
 
 #include <QtGui/qpalette.h>
 
@@ -181,11 +182,12 @@ void QWindowsApplication::lightSystemPalette(QPalette &result) const
     QColor accent = getSysColor(COLOR_HIGHLIGHT);
 
 #if QT_CONFIG(cpp_winrt)
-    // respect the Windows 11 accent color
-    using namespace winrt::Windows::UI::ViewManagement;
-    const auto settings = UISettings();
-
-    accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+    if (QOperatingSystemVersion::isWin10RS5OrGreater()) {
+        // Respect the accent color on modern Windows.
+        using namespace winrt::Windows::UI::ViewManagement;
+        const auto settings = UISettings();
+        accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+    }
 #endif
 
     const QColor btnFace = background;
diff --git a/src/plugins/platforms/windows/qwindowscontext.cpp b/src/plugins/platforms/windows/qwindowscontext.cpp
index e8914fb6a2..d77823f8e7 100644
--- a/src/plugins/platforms/windows/qwindowscontext.cpp
+++ b/src/plugins/platforms/windows/qwindowscontext.cpp
@@ -120,15 +120,21 @@ static inline bool sessionManagerInteractionBlocked() { return false; }
 
 static inline int windowDpiAwareness(HWND hwnd)
 {
-    return static_cast<int>(GetAwarenessFromDpiAwarenessContext(GetWindowDpiAwarenessContext(hwnd)));
+    if (QWindowsApi::instance()->pGetAwarenessFromDpiAwarenessContext &&
+        QWindowsApi::instance()->pGetWindowDpiAwarenessContext) {
+        return static_cast<int>(
+            QWindowsApi::instance()->pGetAwarenessFromDpiAwarenessContext(
+                QWindowsApi::instance()->pGetWindowDpiAwarenessContext(hwnd)));
+    }
+    return -1;
 }
 
 // Note: This only works within WM_NCCREATE
 static bool enableNonClientDpiScaling(HWND hwnd)
 {
     bool result = false;
-    if (windowDpiAwareness(hwnd) == 2) {
-        result = EnableNonClientDpiScaling(hwnd) != FALSE;
+    if ((windowDpiAwareness(hwnd) == 2) && QWindowsApi::instance()->pEnableNonClientDpiScaling) {
+        result = QWindowsApi::instance()->pEnableNonClientDpiScaling(hwnd) != FALSE;
         if (!result) {
             const DWORD errorCode = GetLastError();
             qErrnoWarning(int(errorCode), "EnableNonClientDpiScaling() failed for HWND %p (%lu)",
@@ -224,7 +230,8 @@ QWindowsContext::~QWindowsContext()
     unregisterWindowClasses();
     if (d->m_oleInitializeResult == S_OK || d->m_oleInitializeResult == S_FALSE) {
 #ifdef QT_USE_FACTORY_CACHE_REGISTRATION
-        detail::QWinRTFactoryCacheRegistration::clearAllCaches();
+        if (QOperatingSystemVersion::isWin10OrGreater())
+            detail::QWinRTFactoryCacheRegistration::clearAllCaches();
 #endif
         OleUninitialize();
     }
@@ -299,6 +306,9 @@ bool QWindowsContext::initPointer(unsigned integrationOptions)
     if (integrationOptions & QWindowsIntegration::DontUseWMPointer)
         return false;
 
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     d->m_systemInfo |= QWindowsContext::SI_SupportsPointer;
     return true;
 }
@@ -369,40 +379,45 @@ void QWindowsContext::setDetectAltGrModifier(bool a)
 int QWindowsContext::processDpiAwareness()
 {
     PROCESS_DPI_AWARENESS result;
-    if (SUCCEEDED(GetProcessDpiAwareness(nullptr, &result))) {
-        return static_cast<int>(result);
+    if (QWindowsApi::instance()->pGetProcessDpiAwareness) {
+        const HRESULT hr = QWindowsApi::instance()->pGetProcessDpiAwareness(nullptr, &result);
+        if (SUCCEEDED(hr))
+            return static_cast<int>(result);
     }
     return -1;
 }
 
-void QWindowsContext::setProcessDpiAwareness(QtWindows::ProcessDpiAwareness dpiAwareness)
+bool QWindowsContext::setProcessDpiAwareness(QtWindows::ProcessDpiAwareness dpiAwareness)
 {
     qCDebug(lcQpaWindow) << __FUNCTION__ << dpiAwareness;
-    if (processDpiAwareness() == int(dpiAwareness))
-        return;
-
-    const HRESULT hr = SetProcessDpiAwareness(static_cast<PROCESS_DPI_AWARENESS>(dpiAwareness));
+    if (!QWindowsApi::instance()->pSetProcessDpiAwareness || processDpiAwareness() == int(dpiAwareness))
+        return false;
+    const HRESULT hr = QWindowsApi::instance()->pSetProcessDpiAwareness(static_cast<PROCESS_DPI_AWARENESS>(dpiAwareness));
     if (FAILED(hr)) {
         qCWarning(lcQpaWindow).noquote().nospace() << "SetProcessDpiAwareness("
             << dpiAwareness << ") failed: " << QSystemError::windowsComString(hr) << ", using "
             << QWindowsContext::processDpiAwareness() << "\nQt's fallback DPI awareness is "
             << "PROCESS_DPI_AWARENESS. If you know what you are doing consider an override in qt.conf";
+        return false;
     }
+    return true;
 }
 
 bool QWindowsContext::setProcessDpiV2Awareness()
 {
     qCDebug(lcQpaWindow) << __FUNCTION__;
-    auto dpiContext = GetThreadDpiAwarenessContext();
-    if (AreDpiAwarenessContextsEqual(dpiContext, DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2))
+    if (!QWindowsApi::instance()->pGetThreadDpiAwarenessContext
+            || !QWindowsApi::instance()->pAreDpiAwarenessContextsEqual
+            || !QWindowsApi::instance()->pSetProcessDpiAwarenessContext) {
+        return false;
+    }
+    const auto dpiContext = QWindowsApi::instance()->pGetThreadDpiAwarenessContext();
+    if (QWindowsApi::instance()->pAreDpiAwarenessContextsEqual(dpiContext, DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2))
         return true;
-
-    const BOOL ok = SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);
-    if (!ok) {
-        const DWORD dwError = GetLastError();
+    if (!QWindowsApi::instance()->pSetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2)) {
         qCWarning(lcQpaWindow).noquote().nospace()
             << "SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2) failed: "
-            << QSystemError::windowsComString(HRESULT(dwError)) << "\nQt's default DPI awareness "
+            << QSystemError::windowsString() << "\nQt's default DPI awareness "
             << "context is DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2. If you know what you "
             << "are doing you can overwrite this default using qt.conf "
             << "(https://doc.qt.io/qt-6/highdpi.html#configuring-windows)";
@@ -412,6 +427,17 @@ bool QWindowsContext::setProcessDpiV2Awareness()
     return true;
 }
 
+bool QWindowsContext::setProcessSystemDpiAware()
+{
+    qCDebug(lcQpaWindow) << __FUNCTION__;
+    if (SetProcessDPIAware() == FALSE) {
+        qCWarning(lcQpaWindow).noquote().nospace()
+            << "SetProcessDPIAware() failed: " << QSystemError::windowsString();
+        return false;
+    }
+    return true;
+}
+
 bool QWindowsContext::isDarkMode()
 {
     return QWindowsContextPrivate::m_darkMode;
@@ -837,8 +863,8 @@ void QWindowsContext::forceNcCalcSize(HWND hwnd)
 bool QWindowsContext::systemParametersInfo(unsigned action, unsigned param, void *out,
                                            unsigned dpi)
 {
-    const BOOL result = dpi != 0
-        ? SystemParametersInfoForDpi(action, param, out, 0, dpi)
+    const BOOL result = (dpi != 0) && (QWindowsApi::instance()->pSystemParametersInfoForDpi != nullptr)
+        ? QWindowsApi::instance()->pSystemParametersInfoForDpi(action, param, out, 0, dpi)
         : SystemParametersInfo(action, param, out, 0);
     return result == TRUE;
 }
@@ -885,7 +911,8 @@ bool QWindowsContext::shouldHaveNonClientDpiScaling(const QWindow *window)
     if (QWindowsContextPrivate::m_v2DpiAware)
         return true;
 
-    return window->isTopLevel()
+    return QOperatingSystemVersion::isWin10OrGreater()
+        && window->isTopLevel()
         && !window->property(QWindowsWindow::embeddedNativeParentHandleProperty).isValid()
 #if QT_CONFIG(opengl) // /QTBUG-62901, EnableNonClientDpiScaling has problems with GL
         && (window->surfaceType() != QSurface::OpenGLSurface
@@ -1532,4 +1559,137 @@ bool QWindowsContext::filterNativeEvent(QWindow *window, MSG *msg, LRESULT *resu
     return false;
 }
 
+UINT QWindowsContext::getDpiForWindow(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    if (QWindowsApi::instance()->pGetDpiForWindow)
+        return QWindowsApi::instance()->pGetDpiForWindow(hWnd);
+    if (const HDC hdc = GetDC(hWnd)) {
+        const int dpiX = GetDeviceCaps(hdc, LOGPIXELSX);
+        ReleaseDC(hWnd, hdc);
+        if (dpiX > 0)
+            return dpiX;
+    }
+    return 0;
+}
+
+UINT QWindowsContext::getDpiForMonitor(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    if (QWindowsApi::instance()->pGetDpiForMonitor) {
+        UINT dpiX = 0;
+        UINT dpiY = 0;
+        const HRESULT hr = QWindowsApi::instance()->pGetDpiForMonitor(hMonitor, MDT_EFFECTIVE_DPI, &dpiX, &dpiY);
+        if (SUCCEEDED(hr) && (dpiX > 0))
+            return dpiX;
+    }
+    MONITORINFOEXW monitorInfo;
+    SecureZeroMemory(&monitorInfo, sizeof(monitorInfo));
+    monitorInfo.cbSize = sizeof(monitorInfo);
+    GetMonitorInfoW(hMonitor, &monitorInfo);
+    if (const HDC hdc = CreateDCW(monitorInfo.szDevice, monitorInfo.szDevice, nullptr, nullptr)) {
+        const int dpiX = GetDeviceCaps(hdc, LOGPIXELSX);
+        DeleteDC(hdc);
+        if (dpiX > 0)
+            return dpiX;
+    }
+    return 0;
+}
+
+UINT QWindowsContext::getDpiForPrimaryMonitor()
+{
+    if (const HMONITOR hMonitor = MonitorFromWindow(GetDesktopWindow(), MONITOR_DEFAULTTOPRIMARY))
+        return getDpiForMonitor(hMonitor);
+    return 0;
+}
+
+UINT QWindowsContext::getMostPossibleDpiForWindow(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    UINT dpi = getDpiForWindow(hWnd);
+    if (dpi > 0)
+        return dpi;
+    if (const HMONITOR hMonitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTONEAREST)) {
+        dpi = getDpiForMonitor(hMonitor);
+        if (dpi > 0)
+            return dpi;
+    }
+    dpi = getDpiForPrimaryMonitor();
+    if (dpi > 0)
+        return dpi;
+    return USER_DEFAULT_SCREEN_DPI;
+}
+
+UINT QWindowsContext::getMostPossibleDpiForMonitor(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    UINT dpi = getDpiForMonitor(hMonitor);
+    if (dpi > 0)
+        return dpi;
+    dpi = getDpiForPrimaryMonitor();
+    if (dpi > 0)
+        return dpi;
+    return USER_DEFAULT_SCREEN_DPI;
+}
+
+int QWindowsContext::getResizeBorderThicknessForDpi(const UINT dpi)
+{
+    // The thickness of the padded border will always be 0 if DWM composition is disabled.
+    if (QWindowsApi::instance()->pGetSystemMetricsForDpi) {
+        return QWindowsApi::instance()->pGetSystemMetricsForDpi(SM_CXSIZEFRAME, dpi)
+            + QWindowsApi::instance()->pGetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi);
+    }
+    return GetSystemMetrics(SM_CXSIZEFRAME) + GetSystemMetrics(SM_CXPADDEDBORDER);
+}
+
+int QWindowsContext::getResizeBorderThickness(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    return getResizeBorderThicknessForDpi(getMostPossibleDpiForWindow(hWnd));
+}
+
+int QWindowsContext::getResizeBorderThickness(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    return getResizeBorderThicknessForDpi(getMostPossibleDpiForMonitor(hMonitor));
+}
+
+int QWindowsContext::getTitleBarHeightForDpi(const UINT dpi)
+{
+    const int border = getResizeBorderThicknessForDpi(dpi);
+    if (QWindowsApi::instance()->pGetSystemMetricsForDpi) {
+        return border +
+            QWindowsApi::instance()->pGetSystemMetricsForDpi(SM_CYCAPTION, dpi);
+    }
+    return border + GetSystemMetrics(SM_CYCAPTION);
+}
+
+int QWindowsContext::getTitleBarHeight(const HWND hWnd)
+{
+    Q_ASSERT(hWnd);
+    if (!hWnd)
+        return 0;
+    return getTitleBarHeightForDpi(getMostPossibleDpiForWindow(hWnd));
+}
+
+int QWindowsContext::getTitleBarHeight(const HMONITOR hMonitor)
+{
+    Q_ASSERT(hMonitor);
+    if (!hMonitor)
+        return 0;
+    return getTitleBarHeightForDpi(getMostPossibleDpiForMonitor(hMonitor));
+}
+
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/windows/qwindowscontext.h b/src/plugins/platforms/windows/qwindowscontext.h
index 6b3010f33c..12f581bcab 100644
--- a/src/plugins/platforms/windows/qwindowscontext.h
+++ b/src/plugins/platforms/windows/qwindowscontext.h
@@ -10,13 +10,18 @@
 #include <QtCore/qscopedpointer.h>
 #include <QtCore/qsharedpointer.h>
 #include <QtCore/qloggingcategory.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 
 #define STRICT_TYPED_ITEMIDS
 #include <shlobj.h>
 #include <shlwapi.h>
+#include <shellscalingapi.h>
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 Q_DECLARE_LOGGING_CATEGORY(lcQpaWindow)
 Q_DECLARE_LOGGING_CATEGORY(lcQpaEvents)
 Q_DECLARE_LOGGING_CATEGORY(lcQpaGl)
@@ -44,6 +49,117 @@ class QPoint;
 class QKeyEvent;
 class QPointingDevice;
 
+struct QWindowsApi
+{
+    decltype(&::GetDpiForWindow) pGetDpiForWindow = nullptr;
+    decltype(&::GetDpiForMonitor) pGetDpiForMonitor = nullptr;
+    decltype(&::SystemParametersInfoForDpi) pSystemParametersInfoForDpi = nullptr;
+    decltype(&::GetSystemMetricsForDpi) pGetSystemMetricsForDpi = nullptr;
+    decltype(&::AdjustWindowRectExForDpi) pAdjustWindowRectExForDpi = nullptr;
+    decltype(&::GetProcessDpiAwareness) pGetProcessDpiAwareness = nullptr;
+    decltype(&::SetProcessDpiAwareness) pSetProcessDpiAwareness = nullptr;
+    decltype(&::SetProcessDpiAwarenessContext) pSetProcessDpiAwarenessContext = nullptr;
+    decltype(&::EnableNonClientDpiScaling) pEnableNonClientDpiScaling = nullptr;
+    decltype(&::GetAwarenessFromDpiAwarenessContext) pGetAwarenessFromDpiAwarenessContext = nullptr;
+    decltype(&::GetWindowDpiAwarenessContext) pGetWindowDpiAwarenessContext = nullptr;
+    decltype(&::GetThreadDpiAwarenessContext) pGetThreadDpiAwarenessContext = nullptr;
+    decltype(&::AreDpiAwarenessContextsEqual) pAreDpiAwarenessContextsEqual = nullptr;
+    decltype(&::GetPointerType) pGetPointerType = nullptr;
+    decltype(&::GetPointerInfo) pGetPointerInfo = nullptr;
+    decltype(&::GetPointerFrameTouchInfo) pGetPointerFrameTouchInfo = nullptr;
+    decltype(&::GetPointerFrameTouchInfoHistory) pGetPointerFrameTouchInfoHistory = nullptr;
+    decltype(&::GetPointerPenInfo) pGetPointerPenInfo = nullptr;
+    decltype(&::GetPointerPenInfoHistory) pGetPointerPenInfoHistory = nullptr;
+    decltype(&::SkipPointerFrameMessages) pSkipPointerFrameMessages = nullptr;
+    decltype(&::GetPointerDeviceRects) pGetPointerDeviceRects = nullptr;
+    decltype(&::SetDisplayAutoRotationPreferences) pSetDisplayAutoRotationPreferences = nullptr;
+    decltype(&::GetDisplayAutoRotationPreferences) pGetDisplayAutoRotationPreferences = nullptr;
+    decltype(&::RegisterTouchWindow) pRegisterTouchWindow = nullptr;
+    decltype(&::UnregisterTouchWindow) pUnregisterTouchWindow = nullptr;
+    decltype(&::IsTouchWindow) pIsTouchWindow = nullptr;
+    decltype(&::GetDisplayConfigBufferSizes) pGetDisplayConfigBufferSizes = nullptr;
+    decltype(&::QueryDisplayConfig) pQueryDisplayConfig = nullptr;
+    decltype(&::DisplayConfigGetDeviceInfo) pDisplayConfigGetDeviceInfo = nullptr;
+    decltype(&::GetTouchInputInfo) pGetTouchInputInfo = nullptr;
+    decltype(&::CloseTouchInputHandle) pCloseTouchInputHandle = nullptr;
+    decltype(&::ChangeWindowMessageFilterEx) pChangeWindowMessageFilterEx = nullptr;
+    decltype(&::Shell_NotifyIconGetRect) pShell_NotifyIconGetRect = nullptr;
+
+    static QWindowsApi *instance()
+    {
+        static QWindowsApi api;
+        return &api;
+    }
+
+    bool supportsPointerApi() const
+    {
+        return pGetPointerType && pGetPointerInfo && pGetPointerFrameTouchInfo
+            && pGetPointerFrameTouchInfoHistory && pGetPointerPenInfo
+            && pGetPointerPenInfoHistory && pSkipPointerFrameMessages
+            && pGetPointerDeviceRects;
+    }
+
+private:
+    Q_DISABLE_COPY_MOVE(QWindowsApi)
+
+    explicit QWindowsApi()
+    {
+        if (QOperatingSystemVersion::isWin7OrGreater()) {
+            QSystemLibrary shell32(u"shell32"_s);
+            pShell_NotifyIconGetRect = reinterpret_cast<decltype(pShell_NotifyIconGetRect)>(shell32.resolve("Shell_NotifyIconGetRect"));
+
+            QSystemLibrary user32(u"user32"_s);
+            pRegisterTouchWindow = reinterpret_cast<decltype(pRegisterTouchWindow)>(user32.resolve("RegisterTouchWindow"));
+            pUnregisterTouchWindow = reinterpret_cast<decltype(pUnregisterTouchWindow)>(user32.resolve("UnregisterTouchWindow"));
+            pIsTouchWindow = reinterpret_cast<decltype(pIsTouchWindow)>(user32.resolve("IsTouchWindow"));
+            pGetDisplayConfigBufferSizes = reinterpret_cast<decltype(pGetDisplayConfigBufferSizes)>(user32.resolve("GetDisplayConfigBufferSizes"));
+            pQueryDisplayConfig = reinterpret_cast<decltype(pQueryDisplayConfig)>(user32.resolve("QueryDisplayConfig"));
+            pDisplayConfigGetDeviceInfo = reinterpret_cast<decltype(pDisplayConfigGetDeviceInfo)>(user32.resolve("DisplayConfigGetDeviceInfo"));
+            pGetTouchInputInfo = reinterpret_cast<decltype(pGetTouchInputInfo)>(user32.resolve("GetTouchInputInfo"));
+            pCloseTouchInputHandle = reinterpret_cast<decltype(pCloseTouchInputHandle)>(user32.resolve("CloseTouchInputHandle"));
+            pChangeWindowMessageFilterEx = reinterpret_cast<decltype(pChangeWindowMessageFilterEx)>(user32.resolve("ChangeWindowMessageFilterEx"));
+
+            if (QOperatingSystemVersion::isWin8OrGreater()) {
+                pGetPointerType = reinterpret_cast<decltype(pGetPointerType)>(user32.resolve("GetPointerType"));
+                pGetPointerInfo = reinterpret_cast<decltype(pGetPointerInfo)>(user32.resolve("GetPointerInfo"));
+                pGetPointerFrameTouchInfo = reinterpret_cast<decltype(pGetPointerFrameTouchInfo)>(user32.resolve("GetPointerFrameTouchInfo"));
+                pGetPointerFrameTouchInfoHistory = reinterpret_cast<decltype(pGetPointerFrameTouchInfoHistory)>(user32.resolve("GetPointerFrameTouchInfoHistory"));
+                pGetPointerPenInfo = reinterpret_cast<decltype(pGetPointerPenInfo)>(user32.resolve("GetPointerPenInfo"));
+                pGetPointerPenInfoHistory = reinterpret_cast<decltype(pGetPointerPenInfoHistory)>(user32.resolve("GetPointerPenInfoHistory"));
+                pSkipPointerFrameMessages = reinterpret_cast<decltype(pSkipPointerFrameMessages)>(user32.resolve("SkipPointerFrameMessages"));
+                pGetPointerDeviceRects = reinterpret_cast<decltype(pGetPointerDeviceRects)>(user32.resolve("GetPointerDeviceRects"));
+                pSetDisplayAutoRotationPreferences = reinterpret_cast<decltype(pSetDisplayAutoRotationPreferences)>(user32.resolve("SetDisplayAutoRotationPreferences"));
+                pGetDisplayAutoRotationPreferences = reinterpret_cast<decltype(pGetDisplayAutoRotationPreferences)>(user32.resolve("GetDisplayAutoRotationPreferences"));
+
+                if (QOperatingSystemVersion::isWin8Point1OrGreater()) {
+                    QSystemLibrary shcore(u"shcore"_s);
+                    pGetDpiForMonitor = reinterpret_cast<decltype(pGetDpiForMonitor)>(shcore.resolve("GetDpiForMonitor"));
+                    pGetProcessDpiAwareness = reinterpret_cast<decltype(pGetProcessDpiAwareness)>(shcore.resolve("GetProcessDpiAwareness"));
+                    pSetProcessDpiAwareness = reinterpret_cast<decltype(pSetProcessDpiAwareness)>(shcore.resolve("SetProcessDpiAwareness"));
+
+                    if (QOperatingSystemVersion::isWin10RS1OrGreater()) {
+                        pGetDpiForWindow = reinterpret_cast<decltype(pGetDpiForWindow)>(user32.resolve("GetDpiForWindow"));
+                        pSystemParametersInfoForDpi = reinterpret_cast<decltype(pSystemParametersInfoForDpi)>(user32.resolve("SystemParametersInfoForDpi"));
+                        pGetSystemMetricsForDpi = reinterpret_cast<decltype(pGetSystemMetricsForDpi)>(user32.resolve("GetSystemMetricsForDpi"));
+                        pAdjustWindowRectExForDpi = reinterpret_cast<decltype(pAdjustWindowRectExForDpi)>(user32.resolve("AdjustWindowRectExForDpi"));
+                        pEnableNonClientDpiScaling = reinterpret_cast<decltype(pEnableNonClientDpiScaling)>(user32.resolve("EnableNonClientDpiScaling"));
+                        pGetAwarenessFromDpiAwarenessContext = reinterpret_cast<decltype(pGetAwarenessFromDpiAwarenessContext)>(user32.resolve("GetAwarenessFromDpiAwarenessContext"));
+                        pGetWindowDpiAwarenessContext = reinterpret_cast<decltype(pGetWindowDpiAwarenessContext)>(user32.resolve("GetWindowDpiAwarenessContext"));
+                        pGetThreadDpiAwarenessContext = reinterpret_cast<decltype(pGetThreadDpiAwarenessContext)>(user32.resolve("GetThreadDpiAwarenessContext"));
+                        pAreDpiAwarenessContextsEqual = reinterpret_cast<decltype(pAreDpiAwarenessContextsEqual)>(user32.resolve("AreDpiAwarenessContextsEqual"));
+
+                        if (QOperatingSystemVersion::isWin10RS2OrGreater()) {
+                            pSetProcessDpiAwarenessContext = reinterpret_cast<decltype(pSetProcessDpiAwarenessContext)>(user32.resolve("SetProcessDpiAwarenessContext"));
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    ~QWindowsApi() = default;
+};
+
 class QWindowsContext
 {
     Q_DISABLE_COPY_MOVE(QWindowsContext)
@@ -115,9 +231,10 @@ public:
     QSharedPointer<QWindowCreationContext> windowCreationContext() const;
 
     static void setTabletAbsoluteRange(int a);
-    void setProcessDpiAwareness(QtWindows::ProcessDpiAwareness dpiAwareness);
+    bool setProcessDpiAwareness(QtWindows::ProcessDpiAwareness dpiAwareness);
     static int processDpiAwareness();
     bool setProcessDpiV2Awareness();
+    bool setProcessSystemDpiAware();
 
     static bool isDarkMode();
 
@@ -158,6 +275,18 @@ public:
     static bool filterNativeEvent(MSG *msg, LRESULT *result);
     static bool filterNativeEvent(QWindow *window, MSG *msg, LRESULT *result);
 
+    static UINT getDpiForWindow(const HWND hWnd);
+    static UINT getDpiForMonitor(const HMONITOR hMonitor);
+    static UINT getDpiForPrimaryMonitor();
+    static UINT getMostPossibleDpiForWindow(const HWND hWnd);
+    static UINT getMostPossibleDpiForMonitor(const HMONITOR hMonitor);
+    static int getResizeBorderThicknessForDpi(const UINT dpi);
+    static int getResizeBorderThickness(const HWND hWnd);
+    static int getResizeBorderThickness(const HMONITOR hMonitor);
+    static int getTitleBarHeightForDpi(const UINT dpi);
+    static int getTitleBarHeight(const HWND hWnd);
+    static int getTitleBarHeight(const HMONITOR hMonitor);
+
 private:
     void handleFocusEvent(QtWindows::WindowsEventType et, QWindowsWindow *w);
 #ifndef QT_NO_CONTEXTMENU
diff --git a/src/plugins/platforms/windows/qwindowsdrag.cpp b/src/plugins/platforms/windows/qwindowsdrag.cpp
index 93205259f8..9f5f73588c 100644
--- a/src/plugins/platforms/windows/qwindowsdrag.cpp
+++ b/src/plugins/platforms/windows/qwindowsdrag.cpp
@@ -664,12 +664,13 @@ static HRESULT startDoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
                 return ::DoDragDrop(pDataObj, pDropSource, dwOKEffects, pdwEffect);
             }
 
-            if (msg.message == WM_POINTERUPDATE) {
+            static const bool pointerApiSupported = QWindowsApi::instance()->supportsPointerApi();
+            if (msg.message == WM_POINTERUPDATE && pointerApiSupported) {
 
                 const quint32 pointerId = GET_POINTERID_WPARAM(msg.wParam);
 
                 POINTER_INFO pointerInfo{};
-                if (!GetPointerInfo(pointerId, &pointerInfo))
+                if (!QWindowsApi::instance()->pGetPointerInfo(pointerId, &pointerInfo))
                     return E_FAIL;
 
                 if (pointerInfo.pointerFlags & POINTER_FLAG_PRIMARY) {
@@ -713,7 +714,7 @@ static HRESULT startDoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
                 // Handle other messages.
                 qWindowsWndProc(msg.hwnd, msg.message, msg.wParam, msg.lParam);
 
-                if (msg.message == WM_POINTERLEAVE)
+                if (msg.message == WM_POINTERLEAVE && pointerApiSupported)
                     return E_FAIL;
             }
         } else {
diff --git a/src/plugins/platforms/windows/qwindowsintegration.cpp b/src/plugins/platforms/windows/qwindowsintegration.cpp
index 51f040e719..689d3601f9 100644
--- a/src/plugins/platforms/windows/qwindowsintegration.cpp
+++ b/src/plugins/platforms/windows/qwindowsintegration.cpp
@@ -229,8 +229,10 @@ void QWindowsIntegrationPrivate::parseOptions(QWindowsIntegration *q, const QStr
     initOpenGlBlacklistResources();
 
     static bool dpiAwarenessSet = false;
+    static const bool hasDpiAwarenessContext = QWindowsApi::instance()->pSetProcessDpiAwarenessContext != nullptr;
     // Default to per-monitor-v2 awareness (if available)
-    QtWindows::ProcessDpiAwareness dpiAwareness = QtWindows::ProcessPerMonitorV2DpiAware;
+    QtWindows::ProcessDpiAwareness dpiAwareness = hasDpiAwarenessContext ?
+        QtWindows::ProcessPerMonitorV2DpiAware : QtWindows::ProcessPerMonitorDpiAware;
 
     int tabletAbsoluteRange = -1;
     DarkModeHandling darkModeHandling = DarkModeHandlingFlag::DarkModeWindowFrames
@@ -249,10 +251,10 @@ void QWindowsIntegrationPrivate::parseOptions(QWindowsIntegration *q, const QStr
 
     if (!dpiAwarenessSet) { // Set only once in case of repeated instantiations of QGuiApplication.
         if (!QCoreApplication::testAttribute(Qt::AA_PluginApplication)) {
-            if (dpiAwareness == QtWindows::ProcessPerMonitorV2DpiAware) {
-                // DpiAwareV2 requires using new API
+            // DpiAwareV2 requires using new API
+            if (dpiAwareness == QtWindows::ProcessPerMonitorV2DpiAware && hasDpiAwarenessContext) {
                 if (m_context.setProcessDpiV2Awareness()) {
-                    qCDebug(lcQpaWindow, "DpiAwareness: DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2");
+                    qCDebug(lcQpaWindow) << "DpiAwareness: DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2";
                     dpiAwarenessSet = true;
                 } else {
                     // fallback to old API
@@ -261,12 +263,23 @@ void QWindowsIntegrationPrivate::parseOptions(QWindowsIntegration *q, const QStr
             }
 
             if (!dpiAwarenessSet) {
-                m_context.setProcessDpiAwareness(dpiAwareness);
-                qCDebug(lcQpaWindow) << "DpiAwareness=" << dpiAwareness
-                    << "effective process DPI awareness=" << QWindowsContext::processDpiAwareness();
+                if (m_context.setProcessDpiAwareness(dpiAwareness)) {
+                    qCDebug(lcQpaWindow) << "DpiAwareness=" << dpiAwareness
+                        << "effective process DPI awareness=" << QWindowsContext::processDpiAwareness();
+                    dpiAwarenessSet = true;
+                }
+            }
+
+            if (!dpiAwarenessSet) {
+                if (m_context.setProcessSystemDpiAware()) {
+                    qCDebug(lcQpaWindow) << "DpiAwareness: System Aware";
+                    dpiAwarenessSet = true;
+                }
             }
+
+            if (!dpiAwarenessSet)
+                qCWarning(lcQpaWindow) << "Failed to set Dpi Awareness mode for current process.";
         }
-        dpiAwarenessSet = true;
     }
 
     m_context.initTouch(m_options);
diff --git a/src/plugins/platforms/windows/qwindowskeymapper.cpp b/src/plugins/platforms/windows/qwindowskeymapper.cpp
index 044de5f3ea..4d55581596 100644
--- a/src/plugins/platforms/windows/qwindowskeymapper.cpp
+++ b/src/plugins/platforms/windows/qwindowskeymapper.cpp
@@ -749,21 +749,10 @@ static inline QString messageKeyText(const MSG &msg)
     return ch.isNull() ? QString() : QString(ch);
 }
 
-[[nodiscard]] static inline int getTitleBarHeight(const HWND hwnd)
-{
-    const UINT dpi = GetDpiForWindow(hwnd);
-    const int captionHeight = GetSystemMetricsForDpi(SM_CYCAPTION, dpi);
-    if (IsZoomed(hwnd))
-        return captionHeight;
-    // The frame height should also be taken into account if the window
-    // is not maximized.
-    const int frameHeight = GetSystemMetricsForDpi(SM_CYSIZEFRAME, dpi)
-                            + GetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi);
-    return captionHeight + frameHeight;
-}
-
 [[nodiscard]] static inline bool isSystemMenuOffsetNeeded(const Qt::WindowFlags flags)
 {
+    if (qEnvironmentVariableIntValue("QT_WINDOWS_SYSTEM_MENU_NEED_OFFSET"))
+        return true;
     static constexpr const Qt::WindowFlags titleBarHints =
         Qt::WindowMinMaxButtonsHint | Qt::WindowCloseButtonHint | Qt::WindowContextHelpButtonHint;
     return (flags & Qt::WindowSystemMenuHint) && (flags & Qt::WindowTitleHint) && !(flags & titleBarHints)
@@ -804,7 +793,8 @@ static void showSystemMenu(QWindow* w)
 #undef disabled
 
     const QPoint pos = QHighDpi::toNativePixels(topLevel->geometry().topLeft(), topLevel);
-    const int titleBarOffset = isSystemMenuOffsetNeeded(topLevel->flags()) ? getTitleBarHeight(topLevelHwnd) : 0;
+    const int titleBarOffset = isSystemMenuOffsetNeeded(topLevel->flags())
+        ? QWindowsContext::getTitleBarHeight(topLevelHwnd) : 0;
     const int ret = TrackPopupMenuEx(menu,
                                TPM_LEFTALIGN | TPM_TOPALIGN | TPM_NONOTIFY | TPM_RETURNCMD,
                                pos.x(), pos.y() + titleBarOffset,
diff --git a/src/plugins/platforms/windows/qwindowsmousehandler.cpp b/src/plugins/platforms/windows/qwindowsmousehandler.cpp
index 28c88ab716..c6750f87c1 100644
--- a/src/plugins/platforms/windows/qwindowsmousehandler.cpp
+++ b/src/plugins/platforms/windows/qwindowsmousehandler.cpp
@@ -564,6 +564,11 @@ bool QWindowsMouseHandler::translateTouchEvent(QWindow *window, HWND,
     using QTouchPoint = QWindowSystemInterface::TouchPoint;
     using QTouchPointList = QList<QWindowSystemInterface::TouchPoint>;
 
+    if (!QWindowsApi::instance()->pGetTouchInputInfo
+            || !QWindowsApi::instance()->pCloseTouchInputHandle) {
+        return true;
+    }
+
     if (!QWindowsContext::instance()->initTouch()) {
         qWarning("Unable to initialize touch handling.");
         return true;
@@ -584,8 +589,8 @@ bool QWindowsMouseHandler::translateTouchEvent(QWindow *window, HWND,
     touchPoints.reserve(winTouchPointCount);
     QEventPoint::States allStates;
 
-    GetTouchInputInfo(reinterpret_cast<HTOUCHINPUT>(msg.lParam),
-                      UINT(msg.wParam), winTouchInputs.data(), sizeof(TOUCHINPUT));
+    QWindowsApi::instance()->pGetTouchInputInfo(reinterpret_cast<HTOUCHINPUT>(msg.lParam),
+                UINT(msg.wParam), winTouchInputs.data(), sizeof(TOUCHINPUT));
     for (int i = 0; i < winTouchPointCount; ++i) {
         const TOUCHINPUT &winTouchInput = winTouchInputs[i];
         int id = m_touchInputIDToTouchPointID.value(winTouchInput.dwID, -1);
@@ -626,7 +631,7 @@ bool QWindowsMouseHandler::translateTouchEvent(QWindow *window, HWND,
         touchPoints.append(touchPoint);
     }
 
-    CloseTouchInputHandle(reinterpret_cast<HTOUCHINPUT>(msg.lParam));
+    QWindowsApi::instance()->pCloseTouchInputHandle(reinterpret_cast<HTOUCHINPUT>(msg.lParam));
 
     // all touch points released, forget the ids we've seen, they may not be reused
     if (allStates == QEventPoint::State::Released)
diff --git a/src/plugins/platforms/windows/qwindowsopengltester.cpp b/src/plugins/platforms/windows/qwindowsopengltester.cpp
index 6a790bcc1b..b03bcc1bf5 100644
--- a/src/plugins/platforms/windows/qwindowsopengltester.cpp
+++ b/src/plugins/platforms/windows/qwindowsopengltester.cpp
@@ -65,7 +65,11 @@ private:
 
 QDirect3D9Handle::QDirect3D9Handle()
 {
-    m_direct3D9 = Direct3DCreate9(D3D_SDK_VERSION);
+    static const auto pDirect3DCreate9 =
+        reinterpret_cast<decltype(&::Direct3DCreate9)>(
+            QSystemLibrary::resolve(u"d3d9"_s, "Direct3DCreate9"));
+    if (pDirect3DCreate9)
+        m_direct3D9 = pDirect3DCreate9(D3D_SDK_VERSION);
 }
 
 QDirect3D9Handle::~QDirect3D9Handle()
diff --git a/src/plugins/platforms/windows/qwindowspointerhandler.cpp b/src/plugins/platforms/windows/qwindowspointerhandler.cpp
index 88f02347b3..75226c3810 100644
--- a/src/plugins/platforms/windows/qwindowspointerhandler.cpp
+++ b/src/plugins/platforms/windows/qwindowspointerhandler.cpp
@@ -45,10 +45,13 @@ QWindowsPointerHandler::~QWindowsPointerHandler()
 
 bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, QtWindows::WindowsEventType et, MSG msg, LRESULT *result)
 {
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     *result = 0;
     const quint32 pointerId = GET_POINTERID_WPARAM(msg.wParam);
 
-    if (!GetPointerType(pointerId, &m_pointerType)) {
+    if (!QWindowsApi::instance()->pGetPointerType(pointerId, &m_pointerType)) {
         qWarning() << "GetPointerType() failed:" << qt_error_string();
         return false;
     }
@@ -62,12 +65,12 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
     }
     case QT_PT_TOUCH: {
         quint32 pointerCount = 0;
-        if (!GetPointerFrameTouchInfo(pointerId, &pointerCount, nullptr)) {
+        if (!QWindowsApi::instance()->pGetPointerFrameTouchInfo(pointerId, &pointerCount, nullptr)) {
             qWarning() << "GetPointerFrameTouchInfo() failed:" << qt_error_string();
             return false;
         }
         QVarLengthArray<POINTER_TOUCH_INFO, 10> touchInfo(pointerCount);
-        if (!GetPointerFrameTouchInfo(pointerId, &pointerCount, touchInfo.data())) {
+        if (!QWindowsApi::instance()->pGetPointerFrameTouchInfo(pointerId, &pointerCount, touchInfo.data())) {
             qWarning() << "GetPointerFrameTouchInfo() failed:" << qt_error_string();
             return false;
         }
@@ -80,7 +83,7 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
         // dispatch any skipped frames if event compression is disabled by the app
         if (historyCount > 1 && !QCoreApplication::testAttribute(Qt::AA_CompressHighFrequencyEvents)) {
             touchInfo.resize(pointerCount * historyCount);
-            if (!GetPointerFrameTouchInfoHistory(pointerId,
+            if (!QWindowsApi::instance()->pGetPointerFrameTouchInfoHistory(pointerId,
                                                  &historyCount,
                                                  &pointerCount,
                                                  touchInfo.data())) {
@@ -101,7 +104,7 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
     }
     case QT_PT_PEN: {
         POINTER_PEN_INFO penInfo;
-        if (!GetPointerPenInfo(pointerId, &penInfo)) {
+        if (!QWindowsApi::instance()->pGetPointerPenInfo(pointerId, &penInfo)) {
             qWarning() << "GetPointerPenInfo() failed:" << qt_error_string();
             return false;
         }
@@ -113,7 +116,7 @@ bool QWindowsPointerHandler::translatePointerEvent(QWindow *window, HWND hwnd, Q
                 || !QCoreApplication::testAttribute(Qt::AA_CompressTabletEvents))) {
             QVarLengthArray<POINTER_PEN_INFO, 10> penInfoHistory(historyCount);
 
-            if (!GetPointerPenInfoHistory(pointerId, &historyCount, penInfoHistory.data())) {
+            if (!QWindowsApi::instance()->pGetPointerPenInfoHistory(pointerId, &historyCount, penInfoHistory.data())) {
                 qWarning() << "GetPointerPenInfoHistory() failed:" << qt_error_string();
                 return false;
             }
@@ -419,6 +422,9 @@ bool QWindowsPointerHandler::translateTouchEvent(QWindow *window, HWND hwnd,
 {
     Q_UNUSED(hwnd);
 
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     auto *touchInfo = static_cast<POINTER_TOUCH_INFO *>(vTouchInfo);
 
     if (et & QtWindows::NonClientEventFlag)
@@ -517,7 +523,7 @@ bool QWindowsPointerHandler::translateTouchEvent(QWindow *window, HWND hwnd,
         inputIds.insert(touchPoint.id);
 
         // Avoid getting repeated messages for this frame if there are multiple pointerIds
-        SkipPointerFrameMessages(touchInfo[i].pointerInfo.pointerId);
+        QWindowsApi::instance()->pSkipPointerFrameMessages(touchInfo[i].pointerInfo.pointerId);
     }
 
     // Some devices send touches for each finger in a different message/frame, instead of consolidating
@@ -557,13 +563,16 @@ bool QWindowsPointerHandler::translatePenEvent(QWindow *window, HWND hwnd, QtWin
                                                MSG msg, PVOID vPenInfo)
 {
 #if QT_CONFIG(tabletevent)
+    if (!QWindowsApi::instance()->supportsPointerApi())
+        return false;
+
     if (et & QtWindows::NonClientEventFlag)
         return false; // Let DefWindowProc() handle Non Client messages.
 
     auto *penInfo = static_cast<POINTER_PEN_INFO *>(vPenInfo);
 
     RECT pRect, dRect;
-    if (!GetPointerDeviceRects(penInfo->pointerInfo.sourceDevice, &pRect, &dRect))
+    if (!QWindowsApi::instance()->pGetPointerDeviceRects(penInfo->pointerInfo.sourceDevice, &pRect, &dRect))
         return false;
 
     const auto systemId = (qint64)penInfo->pointerInfo.sourceDevice;
diff --git a/src/plugins/platforms/windows/qwindowsscreen.cpp b/src/plugins/platforms/windows/qwindowsscreen.cpp
index f15a7a870d..a513ec937d 100644
--- a/src/plugins/platforms/windows/qwindowsscreen.cpp
+++ b/src/plugins/platforms/windows/qwindowsscreen.cpp
@@ -26,22 +26,14 @@ QT_BEGIN_NAMESPACE
 
 using namespace Qt::StringLiterals;
 
-static inline QDpi deviceDPI(HDC hdc)
-{
-    return QDpi(GetDeviceCaps(hdc, LOGPIXELSX), GetDeviceCaps(hdc, LOGPIXELSY));
-}
-
-static inline QDpi monitorDPI(HMONITOR hMonitor)
-{
-    UINT dpiX;
-    UINT dpiY;
-    if (SUCCEEDED(GetDpiForMonitor(hMonitor, MDT_EFFECTIVE_DPI, &dpiX, &dpiY)))
-        return QDpi(dpiX, dpiY);
-    return {0, 0};
-}
-
 static bool getPathInfo(const MONITORINFOEX &viewInfo, DISPLAYCONFIG_PATH_INFO *pathInfo)
 {
+    if (!QWindowsApi::instance()->pGetDisplayConfigBufferSizes
+            || !QWindowsApi::instance()->pQueryDisplayConfig
+            || !QWindowsApi::instance()->pDisplayConfigGetDeviceInfo) {
+        return false;
+    }
+
     // We might want to consider storing adapterId/id from DISPLAYCONFIG_PATH_TARGET_INFO.
     std::vector<DISPLAYCONFIG_PATH_INFO> pathInfos;
     std::vector<DISPLAYCONFIG_MODE_INFO> modeInfos;
@@ -54,14 +46,15 @@ static bool getPathInfo(const MONITORINFOEX &viewInfo, DISPLAYCONFIG_PATH_INFO *
         // QueryDisplayConfig documentation doesn't say the number of needed elements is updated
         // when the call fails with ERROR_INSUFFICIENT_BUFFER, so we need a separate call to
         // look up the needed buffer sizes.
-        if (GetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &numPathArrayElements,
-                                        &numModeInfoArrayElements) != ERROR_SUCCESS) {
+        if (QWindowsApi::instance()->pGetDisplayConfigBufferSizes(
+                QDC_ONLY_ACTIVE_PATHS, &numPathArrayElements, &numModeInfoArrayElements) != ERROR_SUCCESS) {
             return false;
         }
         pathInfos.resize(numPathArrayElements);
         modeInfos.resize(numModeInfoArrayElements);
-        result = QueryDisplayConfig(QDC_ONLY_ACTIVE_PATHS, &numPathArrayElements, pathInfos.data(),
-                                    &numModeInfoArrayElements, modeInfos.data(), nullptr);
+        result = QWindowsApi::instance()->pQueryDisplayConfig(
+                    QDC_ONLY_ACTIVE_PATHS, &numPathArrayElements, pathInfos.data(),
+                    &numModeInfoArrayElements, modeInfos.data(), nullptr);
     } while (result == ERROR_INSUFFICIENT_BUFFER);
 
     if (result != ERROR_SUCCESS)
@@ -74,7 +67,7 @@ static bool getPathInfo(const MONITORINFOEX &viewInfo, DISPLAYCONFIG_PATH_INFO *
         deviceName.header.size = sizeof(DISPLAYCONFIG_SOURCE_DEVICE_NAME);
         deviceName.header.adapterId = pathInfos[p].sourceInfo.adapterId;
         deviceName.header.id = pathInfos[p].sourceInfo.id;
-        if (DisplayConfigGetDeviceInfo(&deviceName.header) == ERROR_SUCCESS) {
+        if (QWindowsApi::instance()->pDisplayConfigGetDeviceInfo(&deviceName.header) == ERROR_SUCCESS) {
             if (wcscmp(viewInfo.szDevice, deviceName.viewGdiDeviceName) == 0) {
                 *pathInfo = pathInfos[p];
                 return true;
@@ -89,8 +82,9 @@ static bool getPathInfo(const MONITORINFOEX &viewInfo, DISPLAYCONFIG_PATH_INFO *
 // Needed later for HDR support
 static float getMonitorSDRWhiteLevel(DISPLAYCONFIG_PATH_TARGET_INFO *targetInfo)
 {
-    const float defaultSdrWhiteLevel = 200.0;
-    if (!targetInfo)
+    static constexpr const float defaultSdrWhiteLevel = 200.0;
+
+    if (!QWindowsApi::instance()->pDisplayConfigGetDeviceInfo || !targetInfo)
         return defaultSdrWhiteLevel;
 
     DISPLAYCONFIG_SDR_WHITE_LEVEL whiteLevel = {};
@@ -98,7 +92,7 @@ static float getMonitorSDRWhiteLevel(DISPLAYCONFIG_PATH_TARGET_INFO *targetInfo)
     whiteLevel.header.size = sizeof(DISPLAYCONFIG_SDR_WHITE_LEVEL);
     whiteLevel.header.adapterId = targetInfo->adapterId;
     whiteLevel.header.id = targetInfo->id;
-    if (DisplayConfigGetDeviceInfo(&whiteLevel.header) != ERROR_SUCCESS)
+    if (QWindowsApi::instance()->pDisplayConfigGetDeviceInfo(&whiteLevel.header) != ERROR_SUCCESS)
         return defaultSdrWhiteLevel;
     return whiteLevel.SDRWhiteLevel * 80.0 / 1000.0;
 }
@@ -126,7 +120,7 @@ static bool monitorData(HMONITOR hMonitor, QWindowsScreenData *data)
         deviceName.header.size = sizeof(DISPLAYCONFIG_TARGET_DEVICE_NAME);
         deviceName.header.adapterId = pathInfo.targetInfo.adapterId;
         deviceName.header.id = pathInfo.targetInfo.id;
-        if (DisplayConfigGetDeviceInfo(&deviceName.header) == ERROR_SUCCESS)
+        if (QWindowsApi::instance()->pDisplayConfigGetDeviceInfo(&deviceName.header) == ERROR_SUCCESS)
             data->name = QString::fromWCharArray(deviceName.monitorFriendlyDeviceName);
     }
     if (data->name.isEmpty())
@@ -135,8 +129,8 @@ static bool monitorData(HMONITOR hMonitor, QWindowsScreenData *data)
         data->flags |= QWindowsScreenData::LockScreen;
     } else {
         if (const HDC hdc = CreateDC(info.szDevice, nullptr, nullptr, nullptr)) {
-            const QDpi dpi = monitorDPI(hMonitor);
-            data->dpi = dpi.first > 0 ? dpi : deviceDPI(hdc);
+            const UINT dpi = QWindowsContext::getMostPossibleDpiForMonitor(hMonitor);
+            data->dpi = QDpi(dpi, dpi);
             data->depth = GetDeviceCaps(hdc, BITSPIXEL);
             data->format = data->depth == 16 ? QImage::Format_RGB16 : QImage::Format_RGB32;
             data->physicalSizeMM = QSizeF(GetDeviceCaps(hdc, HORZSIZE), GetDeviceCaps(hdc, VERTSIZE));
@@ -424,7 +418,8 @@ QRect QWindowsScreen::virtualGeometry(const QPlatformScreen *screen) // cf QScre
 
 bool QWindowsScreen::setOrientationPreference(Qt::ScreenOrientation o)
 {
-    bool result = false;
+    if (!QWindowsApi::instance()->pSetDisplayAutoRotationPreferences)
+        return false;
     ORIENTATION_PREFERENCE orientationPreference = ORIENTATION_PREFERENCE_NONE;
     switch (o) {
     case Qt::PrimaryOrientation:
@@ -442,33 +437,29 @@ bool QWindowsScreen::setOrientationPreference(Qt::ScreenOrientation o)
         orientationPreference = ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED;
         break;
     }
-    result = SetDisplayAutoRotationPreferences(orientationPreference);
-    return result;
+    return QWindowsApi::instance()->pSetDisplayAutoRotationPreferences(orientationPreference);
 }
 
 Qt::ScreenOrientation QWindowsScreen::orientationPreference()
 {
-    Qt::ScreenOrientation result = Qt::PrimaryOrientation;
+    if (!QWindowsApi::instance()->pGetDisplayAutoRotationPreferences)
+        return Qt::PrimaryOrientation;
     ORIENTATION_PREFERENCE orientationPreference = ORIENTATION_PREFERENCE_NONE;
-    if (GetDisplayAutoRotationPreferences(&orientationPreference)) {
+    if (QWindowsApi::instance()->pGetDisplayAutoRotationPreferences(&orientationPreference)) {
         switch (orientationPreference) {
         case ORIENTATION_PREFERENCE_NONE:
-            break;
+            return Qt::PrimaryOrientation;
         case ORIENTATION_PREFERENCE_LANDSCAPE:
-            result = Qt::LandscapeOrientation;
-            break;
+            return Qt::LandscapeOrientation;
         case ORIENTATION_PREFERENCE_PORTRAIT:
-            result = Qt::PortraitOrientation;
-            break;
+            return Qt::PortraitOrientation;
         case ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED:
-            result = Qt::InvertedLandscapeOrientation;
-            break;
+            return Qt::InvertedLandscapeOrientation;
         case ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED:
-            result = Qt::InvertedPortraitOrientation;
-            break;
+            return Qt::InvertedPortraitOrientation;
         }
     }
-    return result;
+    return Qt::PrimaryOrientation;
 }
 
 /*!
diff --git a/src/plugins/platforms/windows/qwindowssystemtrayicon.cpp b/src/plugins/platforms/windows/qwindowssystemtrayicon.cpp
index 3bad237f9e..7a9b2c5b07 100644
--- a/src/plugins/platforms/windows/qwindowssystemtrayicon.cpp
+++ b/src/plugins/platforms/windows/qwindowssystemtrayicon.cpp
@@ -184,13 +184,16 @@ void QWindowsSystemTrayIcon::updateToolTip(const QString &tooltip)
 
 QRect QWindowsSystemTrayIcon::geometry() const
 {
+    if (!QWindowsApi::instance()->pShell_NotifyIconGetRect)
+        return {};
     NOTIFYICONIDENTIFIER nid;
     memset(&nid, 0, sizeof(nid));
     nid.cbSize = sizeof(nid);
     nid.hWnd = m_hwnd;
     nid.uID = q_uNOTIFYICONID;
     RECT rect;
-    const QRect result = SUCCEEDED(Shell_NotifyIconGetRect(&nid, &rect))
+    const QRect result =
+        SUCCEEDED(QWindowsApi::instance()->pShell_NotifyIconGetRect(&nid, &rect))
         ? QRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top)
         : QRect();
     qCDebug(lcQpaTrayIcon) << __FUNCTION__ << this << "returns" << result;
@@ -272,7 +275,8 @@ bool QWindowsSystemTrayIcon::ensureInstalled()
     if (!MYWM_TASKBARCREATED)
         MYWM_TASKBARCREATED = RegisterWindowMessage(L"TaskbarCreated");
     // Allow the WM_TASKBARCREATED message through the UIPI filter
-    ChangeWindowMessageFilterEx(m_hwnd, MYWM_TASKBARCREATED, MSGFLT_ALLOW, nullptr);
+    if (QWindowsApi::instance()->pChangeWindowMessageFilterEx)
+        QWindowsApi::instance()->pChangeWindowMessageFilterEx(m_hwnd, MYWM_TASKBARCREATED, MSGFLT_ALLOW, nullptr);
     qCDebug(lcQpaTrayIcon) << __FUNCTION__ << this << "MYWM_TASKBARCREATED=" << MYWM_TASKBARCREATED;
 
     QWindowsHwndSystemTrayIconEntry entry{m_hwnd, this};
diff --git a/src/plugins/platforms/windows/qwindowstheme.cpp b/src/plugins/platforms/windows/qwindowstheme.cpp
index b9d02a4374..3398668b98 100644
--- a/src/plugins/platforms/windows/qwindowstheme.cpp
+++ b/src/plugins/platforms/windows/qwindowstheme.cpp
@@ -39,6 +39,7 @@
 #include <private/qsystemlibrary_p.h>
 #include <private/qwinregistry_p.h>
 #include <QtCore/private/qfunctions_win_p.h>
+#include <QtCore/qoperatingsystemversion.h>
 
 #include <algorithm>
 
@@ -241,41 +242,62 @@ static void populateLightSystemBasePalette(QPalette &result)
 
 static void populateDarkSystemBasePalette(QPalette &result)
 {
+    QColor foreground;
+    QColor background;
+    QColor accent;
+    QColor accentDark;
+    QColor accentDarker;
+    QColor accentDarkest;
+    QColor accentLight;
+    QColor accentLighter;
+    QColor accentLightest;
+    QColor linkColor;
+
+    bool colorSet = false;
+
 #if QT_CONFIG(cpp_winrt)
-    using namespace winrt::Windows::UI::ViewManagement;
-    const auto settings = UISettings();
-
-    // We have to craft a palette from these colors. The settings.UIElementColor(UIElementType) API
-    // returns the old system colors, not the dark mode colors. If the background is black (which it
-    // usually), then override it with a dark gray instead so that we can go up and down the lightness.
-    const QColor foreground = getSysColor(settings.GetColorValue(UIColorType::Foreground));
-    const QColor background = [&settings]() -> QColor {
-        auto systemBackground = getSysColor(settings.GetColorValue(UIColorType::Background));
-        if (systemBackground == Qt::black)
-            systemBackground = QColor(0x1E, 0x1E, 0x1E);
-        return systemBackground;
-    }();
-
-    const QColor accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
-    const QColor accentDark = getSysColor(settings.GetColorValue(UIColorType::AccentDark1));
-    const QColor accentDarker = getSysColor(settings.GetColorValue(UIColorType::AccentDark2));
-    const QColor accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
-    const QColor accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
-    const QColor accentLighter = getSysColor(settings.GetColorValue(UIColorType::AccentLight2));
-    const QColor accentLightest = getSysColor(settings.GetColorValue(UIColorType::AccentLight3));
-    const QColor linkColor = accent;
-#else
-    const QColor foreground = Qt::white;
-    const QColor background = QColor(0x1E, 0x1E, 0x1E);
-    const QColor accent = QColor(0x00, 0x55, 0xff);
-    const QColor accentDark = accent.darker(120);
-    const QColor accentDarker = accentDark.darker(120);
-    const QColor accentDarkest = accentDarker.darker(120);
-    const QColor accentLight = accent.lighter(120);
-    const QColor accentLighter = accentLight.lighter(120);
-    const QColor accentLightest = accentLighter.lighter(120);
-    const QColor linkColor = Qt::blue;
+    if (QOperatingSystemVersion::isWin10RS5OrGreater()) {
+        using namespace winrt::Windows::UI::ViewManagement;
+        const auto settings = UISettings();
+
+        // We have to craft a palette from these colors. The settings.UIElementColor(UIElementType) API
+        // returns the old system colors, not the dark mode colors. If the background is black (which it
+        // usually), then override it with a dark gray instead so that we can go up and down the lightness.
+        foreground = getSysColor(settings.GetColorValue(UIColorType::Foreground));
+        background = [&settings]() -> QColor {
+            auto systemBackground = getSysColor(settings.GetColorValue(UIColorType::Background));
+            if (systemBackground == Qt::black)
+                systemBackground = QColor(0x1E, 0x1E, 0x1E);
+            return systemBackground;
+        }();
+
+        accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+        accentDark = getSysColor(settings.GetColorValue(UIColorType::AccentDark1));
+        accentDarker = getSysColor(settings.GetColorValue(UIColorType::AccentDark2));
+        accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
+        accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
+        accentLighter = getSysColor(settings.GetColorValue(UIColorType::AccentLight2));
+        accentLightest = getSysColor(settings.GetColorValue(UIColorType::AccentLight3));
+        linkColor = accent;
+
+        colorSet = true;
+    }
 #endif
+
+    if (!colorSet) {
+        foreground = Qt::white;
+        background = QColor(0x1E, 0x1E, 0x1E);
+        accent = QColor(0x00, 0x55, 0xff);
+        accentDark = accent.darker(120);
+        accentDarker = accentDark.darker(120);
+        accentDarkest = accentDarker.darker(120);
+        accentLight = accent.lighter(120);
+        accentLighter = accentLight.lighter(120);
+        accentLightest = accentLighter.lighter(120);
+        linkColor = Qt::blue;
+        colorSet = true;
+    }
+
     const QColor buttonColor = background.lighter(200);
 
     result.setColor(QPalette::All, QPalette::WindowText, foreground);
@@ -532,25 +554,31 @@ void QWindowsTheme::refreshPalettes()
     m_palettes[MenuPalette] = new QPalette(menuPalette(*m_palettes[SystemPalette], light));
     m_palettes[MenuBarPalette] = menuBarPalette(*m_palettes[MenuPalette], light);
     if (!light) {
+        bool colorSet = false;
 #if QT_CONFIG(cpp_winrt)
-        using namespace winrt::Windows::UI::ViewManagement;
-        const auto settings = UISettings();
-        const QColor accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
-        const QColor accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
-        const QColor accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
-        m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Base, accent);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Button, accentLight);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Inactive, QPalette::Base, accentDarkest);
-#else
-        m_palettes[ButtonPalette] = new QPalette(*m_palettes[SystemPalette]);
-        m_palettes[ButtonPalette]->setColor(QPalette::Button, QColor(0x666666u));
-        const QColor checkBoxBlue(0x0078d7u);
-        m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Base, checkBoxBlue);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::Button, checkBoxBlue);
-        m_palettes[CheckBoxPalette]->setColor(QPalette::ButtonText, Qt::white);
+        if (QOperatingSystemVersion::isWin10RS5OrGreater()) {
+            using namespace winrt::Windows::UI::ViewManagement;
+            const auto settings = UISettings();
+            const QColor accent = getSysColor(settings.GetColorValue(UIColorType::Accent));
+            const QColor accentLight = getSysColor(settings.GetColorValue(UIColorType::AccentLight1));
+            const QColor accentDarkest = getSysColor(settings.GetColorValue(UIColorType::AccentDark3));
+            m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Base, accent);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Active, QPalette::Button, accentLight);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Inactive, QPalette::Base, accentDarkest);
+            colorSet = true;
+        }
 #endif
+        if (!colorSet) {
+            m_palettes[ButtonPalette] = new QPalette(*m_palettes[SystemPalette]);
+            m_palettes[ButtonPalette]->setColor(QPalette::Button, QColor(0x666666u));
+            const QColor checkBoxBlue(0x0078d7u);
+            m_palettes[CheckBoxPalette] = new QPalette(*m_palettes[SystemPalette]);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Base, checkBoxBlue);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::Button, checkBoxBlue);
+            m_palettes[CheckBoxPalette]->setColor(QPalette::ButtonText, Qt::white);
+            colorSet = true;
+        }
         m_palettes[RadioButtonPalette] = new QPalette(*m_palettes[CheckBoxPalette]);
     }
 }
@@ -608,7 +636,10 @@ void QWindowsTheme::refreshFonts()
     fixedFont.setStyleHint(QFont::TypeWriter);
 
     LOGFONT lfIconTitleFont;
-    SystemParametersInfoForDpi(SPI_GETICONTITLELOGFONT, sizeof(lfIconTitleFont), &lfIconTitleFont, 0, dpi);
+    if (QWindowsApi::instance()->pSystemParametersInfoForDpi)
+        QWindowsApi::instance()->pSystemParametersInfoForDpi(SPI_GETICONTITLELOGFONT, sizeof(lfIconTitleFont), &lfIconTitleFont, 0, dpi);
+    else
+        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lfIconTitleFont), &lfIconTitleFont, 0);
     const QFont iconTitleFont = QWindowsFontDatabase::LOGFONT_to_QFont(lfIconTitleFont, dpi);
 
     m_fonts[SystemFont] = new QFont(QWindowsFontDatabase::systemDefaultFont());
@@ -1041,7 +1072,7 @@ bool QWindowsTheme::useNativeMenus()
 
 bool QWindowsTheme::queryDarkMode()
 {
-    if (queryHighContrast()) {
+    if (!QOperatingSystemVersion::isWin10RS5OrGreater() || queryHighContrast()) {
         return false;
     }
     const auto setting = QWinRegistryKey(HKEY_CURRENT_USER, LR"(Software\Microsoft\Windows\CurrentVersion\Themes\Personalize)")
diff --git a/src/plugins/platforms/windows/qwindowswindow.cpp b/src/plugins/platforms/windows/qwindowswindow.cpp
index f7ba002673..9bb3047841 100644
--- a/src/plugins/platforms/windows/qwindowswindow.cpp
+++ b/src/plugins/platforms/windows/qwindowswindow.cpp
@@ -22,6 +22,7 @@
 #  include "qwindowscursor.h"
 #endif
 
+#include <QtCore/qoperatingsystemversion.h>
 #include <QtGui/qguiapplication.h>
 #include <QtGui/qscreen.h>
 #include <QtGui/qwindow.h>
@@ -442,13 +443,26 @@ static inline bool windowIsAccelerated(const QWindow *w)
     }
 }
 
+static bool dwmIsCompositionEnabled()
+{
+    if (QOperatingSystemVersion::isWin8OrGreater())
+        return true;
+    BOOL enabled = FALSE;
+    return SUCCEEDED(DwmIsCompositionEnabled(&enabled)) && enabled != FALSE;
+}
+
 static bool applyBlurBehindWindow(HWND hwnd)
 {
     DWM_BLURBEHIND blurBehind = {0, 0, nullptr, 0};
 
-    blurBehind.dwFlags = DWM_BB_ENABLE | DWM_BB_BLURREGION;
-    blurBehind.fEnable = TRUE;
-    blurBehind.hRgnBlur = CreateRectRgn(0, 0, -1, -1);
+    if (dwmIsCompositionEnabled()) {
+        blurBehind.dwFlags = DWM_BB_ENABLE | DWM_BB_BLURREGION;
+        blurBehind.fEnable = TRUE;
+        blurBehind.hRgnBlur = CreateRectRgn(0, 0, -1, -1);
+    } else {
+        blurBehind.dwFlags = DWM_BB_ENABLE;
+        blurBehind.fEnable = FALSE;
+    }
 
     const bool result = DwmEnableBlurBehindWindow(hwnd, &blurBehind) == S_OK;
 
@@ -515,15 +529,6 @@ static inline void updateGLWindowSettings(const QWindow *w, HWND hwnd, Qt::Windo
     setWindowOpacity(hwnd, flags, hasAlpha, isAccelerated, opacity);
 }
 
-[[nodiscard]] static inline int getResizeBorderThickness(const UINT dpi)
-{
-    // The width of the padded border will always be 0 if DWM composition is
-    // disabled, but since it will always be enabled and can't be programtically
-    // disabled from Windows 8, we are safe to go.
-    return GetSystemMetricsForDpi(SM_CXSIZEFRAME, dpi)
-           + GetSystemMetricsForDpi(SM_CXPADDEDBORDER, dpi);
-}
-
 /*!
     Calculates the dimensions of the invisible borders within the
     window frames which only exist on Windows 10 and onwards.
@@ -531,22 +536,21 @@ static inline void updateGLWindowSettings(const QWindow *w, HWND hwnd, Qt::Windo
 
 static QMargins invisibleMargins(QPoint screenPoint)
 {
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return QMargins();
     POINT pt = {screenPoint.x(), screenPoint.y()};
     if (HMONITOR hMonitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONULL)) {
-        UINT dpiX;
-        UINT dpiY;
-        if (SUCCEEDED(GetDpiForMonitor(hMonitor, MDT_EFFECTIVE_DPI, &dpiX, &dpiY))) {
-            const int gap = getResizeBorderThickness(dpiX);
-            return QMargins(gap, 0, gap, gap);
-        }
+        const int gap = QWindowsContext::getResizeBorderThickness(hMonitor);
+        return QMargins(gap, 0, gap, gap);
     }
     return QMargins();
 }
 
 [[nodiscard]] static inline QMargins invisibleMargins(const HWND hwnd)
 {
-    const UINT dpi = GetDpiForWindow(hwnd);
-    const int gap = getResizeBorderThickness(dpi);
+    if (!QOperatingSystemVersion::isWin10OrGreater())
+        return QMargins();
+    const int gap = QWindowsContext::getResizeBorderThickness(hwnd);
     return QMargins(gap, 0, gap, gap);
 }
 
@@ -786,10 +790,8 @@ void WindowCreationData::fromWindow(const QWindow *w, const Qt::WindowFlags flag
     } else if (topLevel) {
         if (flags & Qt::FramelessWindowHint)
             style = WS_POPUP;                // no border
-        else if (flags & Qt::WindowTitleHint)
-            style = WS_OVERLAPPED;
         else
-            style = 0;
+            style = WS_OVERLAPPED;
     } else {
         style = WS_CHILD;
     }
@@ -806,7 +808,6 @@ void WindowCreationData::fromWindow(const QWindow *w, const Qt::WindowFlags flag
     if (topLevel) {
         if ((type == Qt::Window || dialog || tool)) {
             if (!(flags & Qt::FramelessWindowHint)) {
-                style |= WS_POPUP;
                 if (flags & Qt::MSWindowsFixedSizeDialogHint) {
                     style |= WS_DLGFRAME;
                 } else {
@@ -834,13 +835,17 @@ void WindowCreationData::fromWindow(const QWindow *w, const Qt::WindowFlags flag
             if ((flags & Qt::WindowContextHelpButtonHint) && !showMinimizeButton
                 && !showMaximizeButton)
                 exStyle |= WS_EX_CONTEXTHELP;
+            if (qEnvironmentVariableIntValue("QT_WINDOWS_DISABLE_BITMAP_REDIRECTION")
+                    && QOperatingSystemVersion::isWin8OrGreater()) {
+                exStyle |= WS_EX_NOREDIRECTIONBITMAP;
+            }
         } else {
              exStyle |= WS_EX_TOOLWINDOW;
         }
 
         // make mouse events fall through this window
         // NOTE: WS_EX_TRANSPARENT flag can make mouse inputs fall through a layered window
-        if (flagsIn & Qt::WindowTransparentForInput)
+        if (flags & Qt::WindowTransparentForInput)
             exStyle |= WS_EX_LAYERED | WS_EX_TRANSPARENT;
     }
 }
@@ -1049,9 +1054,12 @@ QMargins QWindowsGeometryHint::frame(const QWindow *w, DWORD style, DWORD exStyl
 {
     if (!w->isTopLevel() || w->flags().testFlag(Qt::FramelessWindowHint))
         return {};
+    if (!QWindowsApi::instance()->pAdjustWindowRectExForDpi)
+        return frameOnPrimaryScreen(w, style, exStyle);
     RECT rect = {0,0,0,0};
     style &= ~DWORD(WS_OVERLAPPED); // Not permitted, see docs.
-    if (AdjustWindowRectExForDpi(&rect, style, FALSE, exStyle, unsigned(qRound(dpi))) == FALSE) {
+    if (QWindowsApi::instance()->pAdjustWindowRectExForDpi(
+            &rect, style, FALSE, exStyle, unsigned(qRound(dpi))) == FALSE) {
         qErrnoWarning("%s: AdjustWindowRectExForDpi failed", __FUNCTION__);
     }
     const QMargins result(qAbs(rect.left), qAbs(rect.top),
@@ -1091,7 +1099,8 @@ QMargins QWindowsGeometryHint::frame(const QWindow *w, const QRect &geometry,
 {
     if (!w->isTopLevel() || w->flags().testFlag(Qt::FramelessWindowHint))
         return {};
-    if (QWindowsScreenManager::isSingleScreen()
+    if (!QWindowsApi::instance()->pAdjustWindowRectExForDpi
+        || QWindowsScreenManager::isSingleScreen()
         || !QWindowsContext::shouldHaveNonClientDpiScaling(w)) {
         return frameOnPrimaryScreen(w, style, exStyle);
     }
@@ -1246,10 +1255,12 @@ QMargins QWindowsBaseWindow::frameMargins_sys() const
 std::optional<QWindowsBaseWindow::TouchWindowTouchTypes>
     QWindowsBaseWindow::touchWindowTouchTypes_sys() const
 {
+    if (!QWindowsApi::instance()->pIsTouchWindow)
+        return std::nullopt;
     ULONG touchFlags = 0;
-    if (IsTouchWindow(handle(), &touchFlags) == FALSE)
-        return {};
-    TouchWindowTouchTypes result;
+    if (QWindowsApi::instance()->pIsTouchWindow(handle(), &touchFlags) == FALSE)
+        return std::nullopt;
+    TouchWindowTouchTypes result = {};
     if ((touchFlags & TWF_FINETOUCH) != 0)
         result.setFlag(TouchWindowTouchType::FineTouch);
     if ((touchFlags & TWF_WANTPALM) != 0)
@@ -1514,8 +1525,8 @@ QWindowsWindow::QWindowsWindow(QWindow *aWindow, const QWindowsWindowData &data)
 QWindowsWindow::~QWindowsWindow()
 {
     setFlag(WithinDestroy);
-    if (testFlag(TouchRegistered))
-        UnregisterTouchWindow(m_data.hwnd);
+    if (testFlag(TouchRegistered) && QWindowsApi::instance()->pUnregisterTouchWindow)
+        QWindowsApi::instance()->pUnregisterTouchWindow(m_data.hwnd);
     destroyWindow();
     destroyIcon();
 }
@@ -1542,7 +1553,7 @@ void QWindowsWindow::initialize()
             QWindowSystemInterface::handleGeometryChange<QWindowSystemInterface::SynchronousDelivery>(w, obtainedGeometry);
         }
     }
-    QWindowsWindow::setSavedDpi(GetDpiForWindow(handle()));
+    QWindowsWindow::setSavedDpi(QWindowsContext::getMostPossibleDpiForWindow(handle()));
 }
 
 QSurfaceFormat QWindowsWindow::format() const
@@ -2014,7 +2025,7 @@ void QWindowsWindow::handleDpiChanged(HWND hwnd, WPARAM wParam, LPARAM lParam)
 
 void QWindowsWindow::handleDpiChangedAfterParent(HWND hwnd)
 {
-    const UINT dpi = GetDpiForWindow(hwnd);
+    const UINT dpi = QWindowsContext::getMostPossibleDpiForWindow(hwnd);
     const qreal scale = qreal(dpi) / qreal(savedDpi());
     setSavedDpi(dpi);
 
@@ -2334,13 +2345,22 @@ bool QWindowsWindow::handleWmPaint(HWND hwnd, UINT message,
         return false;
     PAINTSTRUCT ps;
 
-    // GL software rendering (QTBUG-58178) with some AMD cards
+    // GL software rendering (QTBUG-58178) and Windows 7/Aero off with some AMD cards
     // (QTBUG-60527) need InvalidateRect() to suppress artifacts while resizing.
-    if (testFlag(OpenGLSurface) && isSoftwareGl())
+    if (testFlag(OpenGLSurface) && (isSoftwareGl() || !dwmIsCompositionEnabled()))
         InvalidateRect(hwnd, nullptr, false);
 
     BeginPaint(hwnd, &ps);
 
+    // Observed painting problems with Aero style disabled (QTBUG-7865).
+    if (Q_UNLIKELY(!dwmIsCompositionEnabled())
+        && ((testFlag(OpenGLSurface) && testFlag(OpenGLDoubleBuffered))
+            || testFlag(VulkanSurface)
+            || testFlag(Direct3DSurface)))
+    {
+        SelectClipRgn(ps.hdc, nullptr);
+    }
+
     // If the a window is obscured by another window (such as a child window)
     // we still need to send isExposed=true, for compatibility.
     // Our tests depend on it.
@@ -2932,7 +2952,7 @@ void QWindowsWindow::getSizeHints(MINMAXINFO *mmi) const
             mmi->ptMaxPosition.x = availablePositionDiff.x();
             mmi->ptMaxPosition.y = availablePositionDiff.y();
             if (!m_data.flags.testFlag(Qt::FramelessWindowHint)) {
-                const int borderWidth = invisibleMargins(m_data.hwnd).left();
+                const int borderWidth = QWindowsContext::getResizeBorderThickness(m_data.hwnd);
                 mmi->ptMaxSize.x += borderWidth * 2;
                 mmi->ptMaxSize.y += borderWidth * 2;
                 mmi->ptMaxTrackSize = mmi->ptMaxSize;
@@ -2973,7 +2993,7 @@ bool QWindowsWindow::handleNonClientHitTest(const QPoint &globalPos, LRESULT *re
             return true;
         }
         if (localPos.y() < 0) {
-            const int topResizeBarPos = invisibleMargins(m_data.hwnd).left() - frameMargins().top();
+            const int topResizeBarPos = QWindowsContext::getResizeBorderThickness(m_data.hwnd) - frameMargins().top();
             if (localPos.y() < topResizeBarPos) {
                 *result = HTCAPTION; // Extend caption over top resize bar, let's user move the window.
                 return true;
@@ -3287,6 +3307,9 @@ void QWindowsWindow::registerTouchWindow()
     if ((QWindowsContext::instance()->systemInfo() & QWindowsContext::SI_SupportsTouch) == 0)
         return;
 
+    if (!QWindowsApi::instance()->pRegisterTouchWindow)
+        return;
+
     // Initially register or re-register to change the flags
     const auto touchTypes = QWindowsIntegration::instance()->touchWindowTouchType();
     if (testFlag(TouchRegistered)) {
@@ -3300,7 +3323,7 @@ void QWindowsWindow::registerTouchWindow()
         touchFlags |= TWF_FINETOUCH;
     if (touchTypes.testFlag(TouchWindowTouchType::WantPalmTouch))
         touchFlags |= TWF_WANTPALM;
-    if (RegisterTouchWindow(m_data.hwnd, touchFlags))
+    if (QWindowsApi::instance()->pRegisterTouchWindow(m_data.hwnd, touchFlags))
         setFlag(TouchRegistered);
     else
         qErrnoWarning("RegisterTouchWindow() failed for window '%s'.", qPrintable(window()->objectName()));
diff --git a/src/plugins/platforms/windows/uiautomation/qwindowsuiaaccessibility.cpp b/src/plugins/platforms/windows/uiautomation/qwindowsuiaaccessibility.cpp
index 001cb8505b..3b8ecef292 100644
--- a/src/plugins/platforms/windows/uiautomation/qwindowsuiaaccessibility.cpp
+++ b/src/plugins/platforms/windows/uiautomation/qwindowsuiaaccessibility.cpp
@@ -14,7 +14,6 @@
 #include <QtGui/private/qguiapplication_p.h>
 #include <QtCore/qt_windows.h>
 #include <qpa/qplatformintegration.h>
-#include <QtGui/private/qwindowsuiawrapper_p.h>
 
 #include <QtCore/private/qwinregistry_p.h>
 
@@ -46,7 +45,7 @@ bool QWindowsUiaAccessibility::handleWmGetObject(HWND hwnd, WPARAM wParam, LPARA
     if (QWindow *window = QWindowsContext::instance()->findWindow(hwnd)) {
         if (QAccessibleInterface *accessible = window->accessibleRoot()) {
             QWindowsUiaMainProvider *provider = QWindowsUiaMainProvider::providerForAccessible(accessible);
-            *lResult = QWindowsUiaWrapper::instance()->returnRawElementProvider(hwnd, wParam, lParam, provider);
+            *lResult = UiaReturnRawElementProvider(hwnd, wParam, lParam, provider);
             return true;
         }
     }
@@ -120,12 +119,8 @@ void QWindowsUiaAccessibility::notifyAccessibilityUpdate(QAccessibleEvent *event
     if (!isActive() || !accessible || !accessible->isValid())
         return;
 
-    // Ensures QWindowsUiaWrapper is properly initialized.
-    if (!QWindowsUiaWrapper::instance()->ready())
-        return;
-
     // No need to do anything when nobody is listening.
-    if (!QWindowsUiaWrapper::instance()->clientsAreListening())
+    if (!UiaClientsAreListening())
         return;
 
     switch (event->type()) {
diff --git a/src/plugins/platforms/windows/uiautomation/qwindowsuiabaseprovider.h b/src/plugins/platforms/windows/uiautomation/qwindowsuiabaseprovider.h
index c899b4096e..2bc549f548 100644
--- a/src/plugins/platforms/windows/uiautomation/qwindowsuiabaseprovider.h
+++ b/src/plugins/platforms/windows/uiautomation/qwindowsuiabaseprovider.h
@@ -11,7 +11,9 @@
 #include <QtCore/qpointer.h>
 
 #include <qwindowscombase.h>
-#include <QtGui/private/qwindowsuiawrapper_p.h>
+#include <uiautomationcore.h>
+#include <uiautomationcoreapi.h>
+#include <uiautomationclient.h>
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/plugins/platforms/windows/uiautomation/qwindowsuiamainprovider.cpp b/src/plugins/platforms/windows/uiautomation/qwindowsuiamainprovider.cpp
index cb35ed398c..d7bcf147b9 100644
--- a/src/plugins/platforms/windows/uiautomation/qwindowsuiamainprovider.cpp
+++ b/src/plugins/platforms/windows/uiautomation/qwindowsuiamainprovider.cpp
@@ -24,6 +24,8 @@
 #include "qwindowsuiaprovidercache.h"
 
 #include <QtCore/qloggingcategory.h>
+#include <QtCore/qoperatingsystemversion.h>
+#include <QtCore/private/qsystemlibrary_p.h>
 #include <QtGui/qaccessible.h>
 #include <QtGui/qguiapplication.h>
 #include <QtGui/qwindow.h>
@@ -36,6 +38,8 @@
 
 QT_BEGIN_NAMESPACE
 
+using namespace Qt::StringLiterals;
+
 using namespace QWindowsUiAutomation;
 
 
@@ -77,7 +81,7 @@ void QWindowsUiaMainProvider::notifyFocusChange(QAccessibleEvent *event)
                 accessible = child;
         }
         if (QWindowsUiaMainProvider *provider = providerForAccessible(accessible))
-            QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_AutomationFocusChangedEventId);
+            UiaRaiseAutomationEvent(provider, UIA_AutomationFocusChangedEventId);
     }
 }
 
@@ -94,7 +98,7 @@ void QWindowsUiaMainProvider::notifyStateChange(QAccessibleStateChangeEvent *eve
                     if (accessible->state().checked)
                         toggleState = accessible->state().checkStateMixed ? ToggleState_Indeterminate : ToggleState_On;
                     setVariantI4(toggleState, &newVal);
-                    QWindowsUiaWrapper::instance()->raiseAutomationPropertyChangedEvent(provider, UIA_ToggleToggleStatePropertyId, oldVal, newVal);
+                    UiaRaiseAutomationPropertyChangedEvent(provider, UIA_ToggleToggleStatePropertyId, oldVal, newVal);
                 }
             }
         }
@@ -103,13 +107,13 @@ void QWindowsUiaMainProvider::notifyStateChange(QAccessibleStateChangeEvent *eve
                 // Notifies window opened/closed.
                 if (QWindowsUiaMainProvider *provider = providerForAccessible(accessible)) {
                     if (accessible->state().active) {
-                        QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Window_WindowOpenedEventId);
+                        UiaRaiseAutomationEvent(provider, UIA_Window_WindowOpenedEventId);
                         if (QAccessibleInterface *focused = accessible->focusChild()) {
                             if (QWindowsUiaMainProvider *focusedProvider = providerForAccessible(focused))
-                                QWindowsUiaWrapper::instance()->raiseAutomationEvent(focusedProvider, UIA_AutomationFocusChangedEventId);
+                                UiaRaiseAutomationEvent(focusedProvider, UIA_AutomationFocusChangedEventId);
                         }
                     } else {
-                        QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Window_WindowClosedEventId);
+                        UiaRaiseAutomationEvent(provider, UIA_Window_WindowClosedEventId);
                     }
                 }
             }
@@ -142,21 +146,30 @@ void QWindowsUiaMainProvider::notifyValueChange(QAccessibleValueChangeEvent *eve
                 // Tries to notify the change using UiaRaiseNotificationEvent(), which is only available on
                 // Windows 10 version 1709 or newer. Otherwise uses UiaRaiseAutomationPropertyChangedEvent().
 
-                BSTR displayString = bStrFromQString(event->value().toString());
-                BSTR activityId = bStrFromQString(QString());
+                auto hr = HRESULT(UIA_E_NOTSUPPORTED);
+
+                if (QOperatingSystemVersion::isWin10RS3OrGreater()) {
+                    static const auto pUiaRaiseNotificationEvent =
+                        reinterpret_cast<decltype(&::UiaRaiseNotificationEvent)>(
+                            QSystemLibrary::resolve(u"uiautomationcore"_s, "UiaRaiseNotificationEvent"));
+                    if (pUiaRaiseNotificationEvent) {
+                        BSTR displayString = bStrFromQString(event->value().toString());
+                        BSTR activityId = bStrFromQString(QString());
 
-                HRESULT hr = QWindowsUiaWrapper::instance()->raiseNotificationEvent(provider, NotificationKind_Other,
-                                                                                    NotificationProcessing_ImportantMostRecent,
-                                                                                    displayString, activityId);
+                        hr = pUiaRaiseNotificationEvent(provider, NotificationKind_Other,
+                                                        NotificationProcessing_ImportantMostRecent,
+                                                        displayString, activityId);
 
-                ::SysFreeString(displayString);
-                ::SysFreeString(activityId);
+                        ::SysFreeString(displayString);
+                        ::SysFreeString(activityId);
+                    }
+                }
 
                 if (hr == static_cast<HRESULT>(UIA_E_NOTSUPPORTED)) {
                     VARIANT oldVal, newVal;
                     clearVariant(&oldVal);
                     setVariantString(event->value().toString(), &newVal);
-                    QWindowsUiaWrapper::instance()->raiseAutomationPropertyChangedEvent(provider, UIA_ValueValuePropertyId, oldVal, newVal);
+                    UiaRaiseAutomationPropertyChangedEvent(provider, UIA_ValueValuePropertyId, oldVal, newVal);
                     ::SysFreeString(newVal.bstrVal);
                 }
             }
@@ -166,7 +179,7 @@ void QWindowsUiaMainProvider::notifyValueChange(QAccessibleValueChangeEvent *eve
                 VARIANT oldVal, newVal;
                 clearVariant(&oldVal);
                 setVariantDouble(valueInterface->currentValue().toDouble(), &newVal);
-                QWindowsUiaWrapper::instance()->raiseAutomationPropertyChangedEvent(provider, UIA_RangeValueValuePropertyId, oldVal, newVal);
+                UiaRaiseAutomationPropertyChangedEvent(provider, UIA_RangeValueValuePropertyId, oldVal, newVal);
             }
         }
     }
@@ -182,7 +195,7 @@ void QWindowsUiaMainProvider::notifyNameChange(QAccessibleEvent *event)
                 VARIANT oldVal, newVal;
                 clearVariant(&oldVal);
                 setVariantString(accessible->text(QAccessible::Name), &newVal);
-                QWindowsUiaWrapper::instance()->raiseAutomationPropertyChangedEvent(provider, UIA_NamePropertyId, oldVal, newVal);
+                UiaRaiseAutomationPropertyChangedEvent(provider, UIA_NamePropertyId, oldVal, newVal);
                 ::SysFreeString(newVal.bstrVal);
             }
         }
@@ -193,7 +206,7 @@ void QWindowsUiaMainProvider::notifySelectionChange(QAccessibleEvent *event)
 {
     if (QAccessibleInterface *accessible = event->accessibleInterface()) {
         if (QWindowsUiaMainProvider *provider = providerForAccessible(accessible)) {
-            QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_SelectionItem_ElementSelectedEventId);
+            UiaRaiseAutomationEvent(provider, UIA_SelectionItem_ElementSelectedEventId);
         }
     }
 }
@@ -205,13 +218,13 @@ void QWindowsUiaMainProvider::notifyTextChange(QAccessibleEvent *event)
         if (accessible->textInterface()) {
             if (QWindowsUiaMainProvider *provider = providerForAccessible(accessible)) {
                 if (event->type() == QAccessible::TextSelectionChanged) {
-                    QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Text_TextSelectionChangedEventId);
+                    UiaRaiseAutomationEvent(provider, UIA_Text_TextSelectionChangedEventId);
                 } else if (event->type() == QAccessible::TextCaretMoved) {
                     if (!accessible->state().readOnly) {
-                        QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Text_TextSelectionChangedEventId);
+                        UiaRaiseAutomationEvent(provider, UIA_Text_TextSelectionChangedEventId);
                     }
                 } else {
-                    QWindowsUiaWrapper::instance()->raiseAutomationEvent(provider, UIA_Text_TextChangedEventId);
+                    UiaRaiseAutomationEvent(provider, UIA_Text_TextChangedEventId);
                 }
             }
         }
@@ -514,7 +527,7 @@ HRESULT QWindowsUiaMainProvider::get_HostRawElementProvider(IRawElementProviderS
     // Returns a host provider only for controls associated with a native window handle. Others should return NULL.
     if (QAccessibleInterface *accessible = accessibleInterface()) {
         if (HWND hwnd = hwndForAccessible(accessible)) {
-            return QWindowsUiaWrapper::instance()->hostProviderFromHwnd(hwnd, pRetVal);
+            return UiaHostProviderFromHwnd(hwnd, pRetVal);
         }
     }
     return S_OK;
diff --git a/src/plugins/platforms/windows/uiautomation/qwindowsuiautils.h b/src/plugins/platforms/windows/uiautomation/qwindowsuiautils.h
index 8fe8b1c6d7..07367efe01 100644
--- a/src/plugins/platforms/windows/uiautomation/qwindowsuiautils.h
+++ b/src/plugins/platforms/windows/uiautomation/qwindowsuiautils.h
@@ -12,7 +12,7 @@
 #include <QtGui/qaccessible.h>
 #include <QtGui/qwindow.h>
 #include <QtCore/qrect.h>
-#include <QtGui/private/qwindowsuiawrapper_p.h>
+#include "qwindowsuiabaseprovider.h"
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp b/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp
index d14f021c0e..8f1b91f11b 100644
--- a/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp
+++ b/src/plugins/styles/windowsvista/qwindowsvistastyle.cpp
@@ -3953,6 +3953,21 @@ void QWindowsVistaStyle::drawComplexControl(ComplexControl control, const QStyle
                     theme.partId = flags & State_Horizontal ? SBP_THUMBBTNHORZ : SBP_THUMBBTNVERT;
                     theme.stateId = stateId;
                     d->drawBackground(theme);
+
+                    if (!QOperatingSystemVersion::isWin8OrGreater()) {
+                        const QRect gripperBounds = QWindowsVistaStylePrivate::scrollBarGripperBounds(flags, widget, &theme);
+                        // Draw gripper if there is enough space
+                        if (!gripperBounds.isEmpty() && flags & State_Enabled) {
+                            painter->save();
+                            QWindowsThemeData grippBackground = theme;
+                            grippBackground.partId = flags & State_Horizontal ? SBP_LOWERTRACKHORZ : SBP_LOWERTRACKVERT;
+                            theme.rect = gripperBounds;
+                            painter->setClipRegion(d->region(theme));// Only change inside the region of the gripper
+                            d->drawBackground(grippBackground);// The gutter is the grippers background
+                            d->drawBackground(theme);          // Transparent gripper ontop of background
+                            painter->restore();
+                        }
+                    }
                 }
             }
         }
@@ -5008,4 +5023,20 @@ QIcon QWindowsVistaStyle::standardIcon(StandardPixmap standardIcon,
     return QWindowsStyle::standardIcon(standardIcon, option, widget);
 }
 
+QRect QWindowsVistaStylePrivate::scrollBarGripperBounds(QStyle::State flags, const QWidget *widget, QWindowsThemeData *theme)
+{
+    const bool horizontal = flags & QStyle::State_Horizontal;
+    const qreal factor = QWindowsStylePrivate::nativeMetricScaleFactor(widget);
+    const QMargins contentsMargin =
+        (theme->margins(theme->rect, TMT_SIZINGMARGINS) * factor).toMargins();
+    theme->partId = horizontal ? SBP_GRIPPERHORZ : SBP_GRIPPERVERT;
+    const QSize size = (theme->size() * factor).toSize();
+
+    const int hSpace = theme->rect.width() - size.width();
+    const int vSpace = theme->rect.height() - size.height();
+    const bool sufficientSpace = (horizontal && hSpace > (contentsMargin.left() + contentsMargin.right()))
+        || vSpace > contentsMargin.top() + contentsMargin.bottom();
+    return sufficientSpace ? QRect(theme->rect.topLeft() + QPoint(hSpace, vSpace) / 2, size) : QRect();
+}
+
 QT_END_NAMESPACE
diff --git a/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h b/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h
index 2c38ff4b3b..7705d3200e 100644
--- a/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h
+++ b/src/plugins/styles/windowsvista/qwindowsvistastyle_p_p.h
@@ -120,6 +120,7 @@ public:
     static int pixelMetricFromSystemDp(QStyle::PixelMetric pm, const QStyleOption *option = nullptr, const QWidget *widget = nullptr);
     static int fixedPixelMetric(QStyle::PixelMetric pm);
     static bool isLineEditBaseColorSet(const QStyleOption *option, const QWidget *widget);
+    static QRect scrollBarGripperBounds(QStyle::State flags, const QWidget *widget, QWindowsThemeData *theme);
     static HWND winId(const QWidget *widget);
     static bool useVista(bool update = false);
     static QBackingStore *backingStoreForWidget(const QWidget *widget);
diff --git a/src/tools/rcc/main.cpp b/src/tools/rcc/main.cpp
index 2751bc39d6..8e44999f52 100644
--- a/src/tools/rcc/main.cpp
+++ b/src/tools/rcc/main.cpp
@@ -34,9 +34,7 @@ void dumpRecursive(const QDir &dir, QTextStream &out)
         if (entry.isDir()) {
             dumpRecursive(entry.filePath(), out);
         } else {
-            out << "<file>"_L1
-                << entry.filePath()
-                << "</file>\n"_L1;
+            out << "  <file>"_L1 << entry.filePath() << "</file>\n"_L1;
         }
     }
 }
@@ -64,7 +62,8 @@ int createProject(const QString &outFileName)
     }
 
     QTextStream out(&file);
-    out << "<!DOCTYPE RCC><RCC version=\"1.0\">\n"
+    out << "<!DOCTYPE RCC>\n"
+           "<RCC version=\"1.0\">\n"
            "<qresource>\n"_L1;
 
     // use "." as dir to get relative file paths
diff --git a/src/tools/rcc/rcc.cpp b/src/tools/rcc/rcc.cpp
index a87f15de33..51933952a5 100644
--- a/src/tools/rcc/rcc.cpp
+++ b/src/tools/rcc/rcc.cpp
@@ -1097,7 +1097,7 @@ bool RCCResourceLibrary::writeDataBlobs()
     Q_ASSERT(m_errorDevice);
     switch (m_format) {
     case C_Code:
-        writeString("static const unsigned char qt_resource_data[] = {\n");
+        writeString("static constexpr const unsigned char qt_resource_data[] = {\n");
         break;
     case Python_Code:
         writeString("qt_resource_data = b\"\\\n");
@@ -1141,7 +1141,7 @@ bool RCCResourceLibrary::writeDataBlobs()
     case Pass1:
         if (offset < 8)
             offset = 8;
-        writeString("\nstatic const unsigned char qt_resource_data[");
+        writeString("\nstatic constexpr const unsigned char qt_resource_data[");
         writeByteArray(QByteArray::number(offset));
         writeString("] = { 'Q', 'R', 'C', '_', 'D', 'A', 'T', 'A' };\n\n");
         break;
@@ -1156,7 +1156,7 @@ bool RCCResourceLibrary::writeDataNames()
     switch (m_format) {
     case C_Code:
     case Pass1:
-        writeString("static const unsigned char qt_resource_name[] = {\n");
+        writeString("static constexpr const unsigned char qt_resource_name[] = {\n");
         break;
     case Python_Code:
         writeString("qt_resource_name = b\"\\\n");
@@ -1218,7 +1218,7 @@ bool RCCResourceLibrary::writeDataStructure()
     switch (m_format) {
     case C_Code:
     case Pass1:
-        writeString("static const unsigned char qt_resource_struct[] = {\n");
+        writeString("static constexpr const unsigned char qt_resource_struct[] = {\n");
         break;
     case Python_Code:
         writeString("qt_resource_struct = b\"\\\n");
diff --git a/src/widgets/dialogs/qwizard_win.cpp b/src/widgets/dialogs/qwizard_win.cpp
index e95f0e3b7b..9c79b56a67 100644
--- a/src/widgets/dialogs/qwizard_win.cpp
+++ b/src/widgets/dialogs/qwizard_win.cpp
@@ -152,7 +152,10 @@ void QVistaHelper::updateCustomMargins(bool vistaMargins)
 
 bool QVistaHelper::isCompositionEnabled()
 {
-    return true;
+    if (QOperatingSystemVersion::isWin8OrGreater())
+        return true;
+    BOOL enabled = FALSE;
+    return SUCCEEDED(DwmIsCompositionEnabled(&enabled)) && enabled != FALSE;
 }
 
 bool QVistaHelper::isThemeActive()
@@ -663,7 +666,9 @@ int QVistaHelper::topOffset(const QPaintDevice *device)
 {
     if (vistaState() != VistaAero)
         return titleBarSize() + 3;
-    static const int aeroOffset = QStyleHelper::dpiScaled(13, device);
+    static const int aeroOffset =
+        QOperatingSystemVersion::isWin8OrGreater() ?
+        QStyleHelper::dpiScaled(13, device) : QStyleHelper::dpiScaled(4, device);
     return aeroOffset + titleBarSize();
 }
 
-- 
2.39.0.windows.2

